(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hydra = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = add

function add(a, b) {
  return rationalize(
    a[0].mul(b[1]).add(b[0].mul(a[1])),
    a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],3:[function(require,module,exports){
'use strict'

module.exports = cmp

function cmp(a, b) {
    return a[0].mul(b[1]).cmp(b[0].mul(a[1]))
}

},{}],4:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = div

function div(a, b) {
  return rationalize(a[0].mul(b[1]), a[1].mul(b[0]))
}

},{"./lib/rationalize":12}],5:[function(require,module,exports){
'use strict'

var isRat = require('./is-rat')
var isBN = require('./lib/is-bn')
var num2bn = require('./lib/num-to-bn')
var str2bn = require('./lib/str-to-bn')
var rationalize = require('./lib/rationalize')
var div = require('./div')

module.exports = makeRational

function makeRational(numer, denom) {
  if(isRat(numer)) {
    if(denom) {
      return div(numer, makeRational(denom))
    }
    return [numer[0].clone(), numer[1].clone()]
  }
  var shift = 0
  var a, b
  if(isBN(numer)) {
    a = numer.clone()
  } else if(typeof numer === 'string') {
    a = str2bn(numer)
  } else if(numer === 0) {
    return [num2bn(0), num2bn(1)]
  } else if(numer === Math.floor(numer)) {
    a = num2bn(numer)
  } else {
    while(numer !== Math.floor(numer)) {
      numer = numer * Math.pow(2, 256)
      shift -= 256
    }
    a = num2bn(numer)
  }
  if(isRat(denom)) {
    a.mul(denom[1])
    b = denom[0].clone()
  } else if(isBN(denom)) {
    b = denom.clone()
  } else if(typeof denom === 'string') {
    b = str2bn(denom)
  } else if(!denom) {
    b = num2bn(1)
  } else if(denom === Math.floor(denom)) {
    b = num2bn(denom)
  } else {
    while(denom !== Math.floor(denom)) {
      denom = denom * Math.pow(2, 256)
      shift += 256
    }
    b = num2bn(denom)
  }
  if(shift > 0) {
    a = a.ushln(shift)
  } else if(shift < 0) {
    b = b.ushln(-shift)
  }
  return rationalize(a, b)
}

},{"./div":4,"./is-rat":6,"./lib/is-bn":10,"./lib/num-to-bn":11,"./lib/rationalize":12,"./lib/str-to-bn":13}],6:[function(require,module,exports){
'use strict'

var isBN = require('./lib/is-bn')

module.exports = isRat

function isRat(x) {
  return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1])
}

},{"./lib/is-bn":10}],7:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = sign

function sign (x) {
  return x.cmp(new BN(0))
}

},{"bn.js":15}],8:[function(require,module,exports){
'use strict'

var sign = require('./bn-sign')

module.exports = bn2num

//TODO: Make this better
function bn2num(b) {
  var l = b.length
  var words = b.words
  var out = 0
  if (l === 1) {
    out = words[0]
  } else if (l === 2) {
    out = words[0] + (words[1] * 0x4000000)
  } else {
    for (var i = 0; i < l; i++) {
      var w = words[i]
      out += w * Math.pow(0x4000000, i)
    }
  }
  return sign(b) * out
}

},{"./bn-sign":7}],9:[function(require,module,exports){
'use strict'

var db = require('double-bits')
var ctz = require('bit-twiddle').countTrailingZeros

module.exports = ctzNumber

//Counts the number of trailing zeros
function ctzNumber(x) {
  var l = ctz(db.lo(x))
  if(l < 32) {
    return l
  }
  var h = ctz(db.hi(x))
  if(h > 20) {
    return 52
  }
  return h + 32
}

},{"bit-twiddle":20,"double-bits":42}],10:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = isBN

//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x) {
  return x && typeof x === 'object' && Boolean(x.words)
}

},{"bn.js":15}],11:[function(require,module,exports){
'use strict'

var BN = require('bn.js')
var db = require('double-bits')

module.exports = num2bn

function num2bn(x) {
  var e = db.exponent(x)
  if(e < 52) {
    return new BN(x)
  } else {
    return (new BN(x * Math.pow(2, 52-e))).ushln(e-52)
  }
}

},{"bn.js":15,"double-bits":42}],12:[function(require,module,exports){
'use strict'

var num2bn = require('./num-to-bn')
var sign = require('./bn-sign')

module.exports = rationalize

function rationalize(numer, denom) {
  var snumer = sign(numer)
  var sdenom = sign(denom)
  if(snumer === 0) {
    return [num2bn(0), num2bn(1)]
  }
  if(sdenom === 0) {
    return [num2bn(0), num2bn(0)]
  }
  if(sdenom < 0) {
    numer = numer.neg()
    denom = denom.neg()
  }
  var d = numer.gcd(denom)
  if(d.cmpn(1)) {
    return [ numer.div(d), denom.div(d) ]
  }
  return [ numer, denom ]
}

},{"./bn-sign":7,"./num-to-bn":11}],13:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = str2BN

function str2BN(x) {
  return new BN(x)
}

},{"bn.js":15}],14:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = mul

function mul(a, b) {
  return rationalize(a[0].mul(b[0]), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],15:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":28}],16:[function(require,module,exports){
'use strict'

var bnsign = require('./lib/bn-sign')

module.exports = sign

function sign(x) {
  return bnsign(x[0]) * bnsign(x[1])
}

},{"./lib/bn-sign":7}],17:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = sub

function sub(a, b) {
  return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],18:[function(require,module,exports){
'use strict'

var bn2num = require('./lib/bn-to-num')
var ctz = require('./lib/ctz')

module.exports = roundRat

// Round a rational to the closest float
function roundRat (f) {
  var a = f[0]
  var b = f[1]
  if (a.cmpn(0) === 0) {
    return 0
  }
  var h = a.abs().divmod(b.abs())
  var iv = h.div
  var x = bn2num(iv)
  var ir = h.mod
  var sgn = (a.negative !== b.negative) ? -1 : 1
  if (ir.cmpn(0) === 0) {
    return sgn * x
  }
  if (x) {
    var s = ctz(x) + 4
    var y = bn2num(ir.ushln(s).divRound(b))
    return sgn * (x + y * Math.pow(2, -s))
  } else {
    var ybits = b.bitLength() - ir.bitLength() + 53
    var y = bn2num(ir.ushln(ybits).divRound(b))
    if (ybits < 1023) {
      return sgn * y * Math.pow(2, -ybits)
    }
    y *= Math.pow(2, -1023)
    return sgn * y * Math.pow(2, 1023 - ybits)
  }
}

},{"./lib/bn-to-num":8,"./lib/ctz":9}],19:[function(require,module,exports){
"use strict"

// (a, y, c, l, h) = (array, y[, cmp, lo, hi])

function ge(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p >= 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function gt(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p > 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function lt(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p < 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function le(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p <= 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function eq(a, y, c, l, h) {
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p === 0) { return m }
    if (p <= 0) { l = m + 1 } else { h = m - 1 }
  }
  return -1;
};

function norm(a, y, c, l, h, f) {
  if (typeof c === 'function') {
    return f(a, y, c, (l === undefined) ? 0 : l | 0, (h === undefined) ? a.length - 1 : h | 0);
  }
  return f(a, y, undefined, (c === undefined) ? 0 : c | 0, (l === undefined) ? a.length - 1 : l | 0);
}

module.exports = {
  ge: function(a, y, c, l, h) { return norm(a, y, c, l, h, ge)},
  gt: function(a, y, c, l, h) { return norm(a, y, c, l, h, gt)},
  lt: function(a, y, c, l, h) { return norm(a, y, c, l, h, lt)},
  le: function(a, y, c, l, h) { return norm(a, y, c, l, h, le)},
  eq: function(a, y, c, l, h) { return norm(a, y, c, l, h, eq)}
}

},{}],20:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],21:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":23,"./lib/sweep":27,"typedarray-pool":139}],22:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],23:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK.length < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":22,"./median":24,"./partition":25,"./sweep":27,"bit-twiddle":20,"typedarray-pool":139}],24:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":25}],25:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],26:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],27:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":26,"bit-twiddle":20,"typedarray-pool":139}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],30:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":30,"ieee754":78}],31:[function(require,module,exports){
'use strict'

var monotoneTriangulate = require('./lib/monotone')
var makeIndex = require('./lib/triangulation')
var delaunayFlip = require('./lib/delaunay')
var filterTriangulation = require('./lib/filter')

module.exports = cdt2d

function canonicalizeEdge(e) {
  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]
}

function compareEdge(a, b) {
  return a[0]-b[0] || a[1]-b[1]
}

function canonicalizeEdges(edges) {
  return edges.map(canonicalizeEdge).sort(compareEdge)
}

function getDefault(options, property, dflt) {
  if(property in options) {
    return options[property]
  }
  return dflt
}

function cdt2d(points, edges, options) {

  if(!Array.isArray(edges)) {
    options = edges || {}
    edges = []
  } else {
    options = options || {}
    edges = edges || []
  }

  //Parse out options
  var delaunay = !!getDefault(options, 'delaunay', true)
  var interior = !!getDefault(options, 'interior', true)
  var exterior = !!getDefault(options, 'exterior', true)
  var infinity = !!getDefault(options, 'infinity', false)

  //Handle trivial case
  if((!interior && !exterior) || points.length === 0) {
    return []
  }

  //Construct initial triangulation
  var cells = monotoneTriangulate(points, edges)

  //If delaunay refinement needed, then improve quality by edge flipping
  if(delaunay || interior !== exterior || infinity) {

    //Index all of the cells to support fast neighborhood queries
    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))
    for(var i=0; i<cells.length; ++i) {
      var f = cells[i]
      triangulation.addTriangle(f[0], f[1], f[2])
    }

    //Run edge flipping
    if(delaunay) {
      delaunayFlip(points, triangulation)
    }

    //Filter points
    if(!exterior) {
      return filterTriangulation(triangulation, -1)
    } else if(!interior) {
      return filterTriangulation(triangulation,  1, infinity)
    } else if(infinity) {
      return filterTriangulation(triangulation, 0, infinity)
    } else {
      return triangulation.cells()
    }
    
  } else {
    return cells
  }
}

},{"./lib/delaunay":32,"./lib/filter":33,"./lib/monotone":34,"./lib/triangulation":35}],32:[function(require,module,exports){
'use strict'

var inCircle = require('robust-in-sphere')[4]
var bsearch = require('binary-search-bounds')

module.exports = delaunayRefine

function testFlip(points, triangulation, stack, a, b, x) {
  var y = triangulation.opposite(a, b)

  //Test boundary edge
  if(y < 0) {
    return
  }

  //Swap edge if order flipped
  if(b < a) {
    var tmp = a
    a = b
    b = tmp
    tmp = x
    x = y
    y = tmp
  }

  //Test if edge is constrained
  if(triangulation.isConstraint(a, b)) {
    return
  }

  //Test if edge is delaunay
  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
    stack.push(a, b)
  }
}

//Assume edges are sorted lexicographically
function delaunayRefine(points, triangulation) {
  var stack = []

  var numPoints = points.length
  var stars = triangulation.stars
  for(var a=0; a<numPoints; ++a) {
    var star = stars[a]
    for(var j=1; j<star.length; j+=2) {
      var b = star[j]

      //If order is not consistent, then skip edge
      if(b < a) {
        continue
      }

      //Check if edge is constrained
      if(triangulation.isConstraint(a, b)) {
        continue
      }

      //Find opposite edge
      var x = star[j-1], y = -1
      for(var k=1; k<star.length; k+=2) {
        if(star[k-1] === b) {
          y = star[k]
          break
        }
      }

      //If this is a boundary edge, don't flip it
      if(y < 0) {
        continue
      }

      //If edge is in circle, flip it
      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b)
      }
    }
  }

  while(stack.length > 0) {
    var b = stack.pop()
    var a = stack.pop()

    //Find opposite pairs
    var x = -1, y = -1
    var star = stars[a]
    for(var i=1; i<star.length; i+=2) {
      var s = star[i-1]
      var t = star[i]
      if(s === b) {
        y = t
      } else if(t === b) {
        x = s
      }
    }

    //If x/y are both valid then skip edge
    if(x < 0 || y < 0) {
      continue
    }

    //If edge is now delaunay, then don't flip it
    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {
      continue
    }

    //Flip the edge
    triangulation.flip(a, b)

    //Test flipping neighboring edges
    testFlip(points, triangulation, stack, x, a, y)
    testFlip(points, triangulation, stack, a, y, x)
    testFlip(points, triangulation, stack, y, b, x)
    testFlip(points, triangulation, stack, b, x, y)
  }
}

},{"binary-search-bounds":19,"robust-in-sphere":104}],33:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = classifyFaces

function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
  this.cells       = cells
  this.neighbor    = neighbor
  this.flags       = flags
  this.constraint  = constraint
  this.active      = active
  this.next        = next
  this.boundary    = boundary
}

var proto = FaceIndex.prototype

function compareCell(a, b) {
  return a[0] - b[0] ||
         a[1] - b[1] ||
         a[2] - b[2]
}

proto.locate = (function() {
  var key = [0,0,0]
  return function(a, b, c) {
    var x = a, y = b, z = c
    if(b < c) {
      if(b < a) {
        x = b
        y = c
        z = a
      }
    } else if(c < a) {
      x = c
      y = a
      z = b
    }
    if(x < 0) {
      return -1
    }
    key[0] = x
    key[1] = y
    key[2] = z
    return bsearch.eq(this.cells, key, compareCell)
  }
})()

function indexCells(triangulation, infinity) {
  //First get cells and canonicalize
  var cells = triangulation.cells()
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    var x = c[0], y = c[1], z = c[2]
    if(y < z) {
      if(y < x) {
        c[0] = y
        c[1] = z
        c[2] = x
      }
    } else if(z < x) {
      c[0] = z
      c[1] = x
      c[2] = y
    }
  }
  cells.sort(compareCell)

  //Initialize flag array
  var flags = new Array(nc)
  for(var i=0; i<flags.length; ++i) {
    flags[i] = 0
  }

  //Build neighbor index, initialize queues
  var active = []
  var next   = []
  var neighbor = new Array(3*nc)
  var constraint = new Array(3*nc)
  var boundary = null
  if(infinity) {
    boundary = []
  }
  var index = new FaceIndex(
    cells,
    neighbor,
    constraint,
    flags,
    active,
    next,
    boundary)
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<3; ++j) {
      var x = c[j], y = c[(j+1)%3]
      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))
      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)
      if(a < 0) {
        if(b) {
          next.push(i)
        } else {
          active.push(i)
          flags[i] = 1
        }
        if(infinity) {
          boundary.push([y, x, -1])
        }
      }
    }
  }
  return index
}

function filterCells(cells, flags, target) {
  var ptr = 0
  for(var i=0; i<cells.length; ++i) {
    if(flags[i] === target) {
      cells[ptr++] = cells[i]
    }
  }
  cells.length = ptr
  return cells
}

function classifyFaces(triangulation, target, infinity) {
  var index = indexCells(triangulation, infinity)

  if(target === 0) {
    if(infinity) {
      return index.cells.concat(index.boundary)
    } else {
      return index.cells
    }
  }

  var side = 1
  var active = index.active
  var next = index.next
  var flags = index.flags
  var cells = index.cells
  var constraint = index.constraint
  var neighbor = index.neighbor

  while(active.length > 0 || next.length > 0) {
    while(active.length > 0) {
      var t = active.pop()
      if(flags[t] === -side) {
        continue
      }
      flags[t] = side
      var c = cells[t]
      for(var j=0; j<3; ++j) {
        var f = neighbor[3*t+j]
        if(f >= 0 && flags[f] === 0) {
          if(constraint[3*t+j]) {
            next.push(f)
          } else {
            active.push(f)
            flags[f] = side
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next
    next = active
    active = tmp
    next.length = 0
    side = -side
  }

  var result = filterCells(cells, flags, target)
  if(infinity) {
    return result.concat(index.boundary)
  }
  return result
}

},{"binary-search-bounds":19}],34:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')
var orient = require('robust-orientation')[3]

var EVENT_POINT = 0
var EVENT_END   = 1
var EVENT_START = 2

module.exports = monotoneTriangulate

//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a, b, idx, lowerIds, upperIds) {
  this.a = a
  this.b = b
  this.idx = idx
  this.lowerIds = lowerIds
  this.upperIds = upperIds
}

//An event in the sweep line procedure
function Event(a, b, type, idx) {
  this.a    = a
  this.b    = b
  this.type = type
  this.idx  = idx
}

//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a, b) {
  var d =
    (a.a[0] - b.a[0]) ||
    (a.a[1] - b.a[1]) ||
    (a.type - b.type)
  if(d) { return d }
  if(a.type !== EVENT_POINT) {
    d = orient(a.a, a.b, b.b)
    if(d) { return d }
  }
  return a.idx - b.idx
}

function testPoint(hull, p) {
  return orient(hull.a, hull.b, p)
}

function addPoint(cells, hulls, points, p, idx) {
  var lo = bsearch.lt(hulls, p, testPoint)
  var hi = bsearch.gt(hulls, p, testPoint)
  for(var i=lo; i<hi; ++i) {
    var hull = hulls[i]

    //Insert p into lower hull
    var lowerIds = hull.lowerIds
    var m = lowerIds.length
    while(m > 1 && orient(
        points[lowerIds[m-2]],
        points[lowerIds[m-1]],
        p) > 0) {
      cells.push(
        [lowerIds[m-1],
         lowerIds[m-2],
         idx])
      m -= 1
    }
    lowerIds.length = m
    lowerIds.push(idx)

    //Insert p into upper hull
    var upperIds = hull.upperIds
    var m = upperIds.length
    while(m > 1 && orient(
        points[upperIds[m-2]],
        points[upperIds[m-1]],
        p) < 0) {
      cells.push(
        [upperIds[m-2],
         upperIds[m-1],
         idx])
      m -= 1
    }
    upperIds.length = m
    upperIds.push(idx)
  }
}

function findSplit(hull, edge) {
  var d
  if(hull.a[0] < edge.a[0]) {
    d = orient(hull.a, hull.b, edge.a)
  } else {
    d = orient(edge.b, edge.a, hull.a)
  }
  if(d) { return d }
  if(edge.b[0] < hull.b[0]) {
    d = orient(hull.a, hull.b, edge.b)
  } else {
    d = orient(edge.b, edge.a, hull.b)
  }
  return d || hull.idx - edge.idx
}

function splitHulls(hulls, points, event) {
  var splitIdx = bsearch.le(hulls, event, findSplit)
  var hull = hulls[splitIdx]
  var upperIds = hull.upperIds
  var x = upperIds[upperIds.length-1]
  hull.upperIds = [x]
  hulls.splice(splitIdx+1, 0,
    new PartialHull(event.a, event.b, event.idx, [x], upperIds))
}


function mergeHulls(hulls, points, event) {
  //Swap pointers for merge search
  var tmp = event.a
  event.a = event.b
  event.b = tmp
  var mergeIdx = bsearch.eq(hulls, event, findSplit)
  var upper = hulls[mergeIdx]
  var lower = hulls[mergeIdx-1]
  lower.upperIds = upper.upperIds
  hulls.splice(mergeIdx, 1)
}


function monotoneTriangulate(points, edges) {

  var numPoints = points.length
  var numEdges = edges.length

  var events = []

  //Create point events
  for(var i=0; i<numPoints; ++i) {
    events.push(new Event(
      points[i],
      null,
      EVENT_POINT,
      i))
  }

  //Create edge events
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    if(a[0] < b[0]) {
      events.push(
        new Event(a, b, EVENT_START, i),
        new Event(b, a, EVENT_END, i))
    } else if(a[0] > b[0]) {
      events.push(
        new Event(b, a, EVENT_START, i),
        new Event(a, b, EVENT_END, i))
    }
  }

  //Sort events
  events.sort(compareEvent)

  //Initialize hull
  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)
  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]

  //Process events in order
  var cells = []
  for(var i=0, numEvents=events.length; i<numEvents; ++i) {
    var event = events[i]
    var type = event.type
    if(type === EVENT_POINT) {
      addPoint(cells, hull, points, event.a, event.idx)
    } else if(type === EVENT_START) {
      splitHulls(hull, points, event)
    } else {
      mergeHulls(hull, points, event)
    }
  }

  //Return triangulation
  return cells
}

},{"binary-search-bounds":19,"robust-orientation":105}],35:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = createTriangulation

function Triangulation(stars, edges) {
  this.stars = stars
  this.edges = edges
}

var proto = Triangulation.prototype

function removePair(list, j, k) {
  for(var i=1, n=list.length; i<n; i+=2) {
    if(list[i-1] === j && list[i] === k) {
      list[i-1] = list[n-2]
      list[i] = list[n-1]
      list.length = n - 2
      return
    }
  }
}

proto.isConstraint = (function() {
  var e = [0,0]
  function compareLex(a, b) {
    return a[0] - b[0] || a[1] - b[1]
  }
  return function(i, j) {
    e[0] = Math.min(i,j)
    e[1] = Math.max(i,j)
    return bsearch.eq(this.edges, e, compareLex) >= 0
  }
})()

proto.removeTriangle = function(i, j, k) {
  var stars = this.stars
  removePair(stars[i], j, k)
  removePair(stars[j], k, i)
  removePair(stars[k], i, j)
}

proto.addTriangle = function(i, j, k) {
  var stars = this.stars
  stars[i].push(j, k)
  stars[j].push(k, i)
  stars[k].push(i, j)
}

proto.opposite = function(j, i) {
  var list = this.stars[i]
  for(var k=1, n=list.length; k<n; k+=2) {
    if(list[k] === j) {
      return list[k-1]
    }
  }
  return -1
}

proto.flip = function(i, j) {
  var a = this.opposite(i, j)
  var b = this.opposite(j, i)
  this.removeTriangle(i, j, a)
  this.removeTriangle(j, i, b)
  this.addTriangle(i, b, a)
  this.addTriangle(j, a, b)
}

proto.edges = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      result.push([list[j], list[j+1]])
    }
  }
  return result
}

proto.cells = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      var s = list[j]
      var t = list[j+1]
      if(i < Math.min(s, t)) {
        result.push([i, s, t])
      }
    }
  }
  return result
}

function createTriangulation(numVerts, edges) {
  var stars = new Array(numVerts)
  for(var i=0; i<numVerts; ++i) {
    stars[i] = []
  }
  return new Triangulation(stars, edges)
}

},{"binary-search-bounds":19}],36:[function(require,module,exports){
'use strict'

module.exports = cleanPSLG

var UnionFind = require('union-find')
var boxIntersect = require('box-intersect')
var segseg = require('robust-segment-intersect')
var rat = require('big-rat')
var ratCmp = require('big-rat/cmp')
var ratToFloat = require('big-rat/to-float')
var ratVec = require('rat-vec')
var nextafter = require('nextafter')

var solveIntersection = require('./lib/rat-seg-intersect')

// Bounds on a rational number when rounded to a float
function boundRat (r) {
  var f = ratToFloat(r)
  return [
    nextafter(f, -Infinity),
    nextafter(f, Infinity)
  ]
}

// Convert a list of edges in a pslg to bounding boxes
function boundEdges (points, edges) {
  var bounds = new Array(edges.length)
  for (var i = 0; i < edges.length; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    bounds[i] = [
      nextafter(Math.min(a[0], b[0]), -Infinity),
      nextafter(Math.min(a[1], b[1]), -Infinity),
      nextafter(Math.max(a[0], b[0]), Infinity),
      nextafter(Math.max(a[1], b[1]), Infinity)
    ]
  }
  return bounds
}

// Convert a list of points into bounding boxes by duplicating coords
function boundPoints (points) {
  var bounds = new Array(points.length)
  for (var i = 0; i < points.length; ++i) {
    var p = points[i]
    bounds[i] = [
      nextafter(p[0], -Infinity),
      nextafter(p[1], -Infinity),
      nextafter(p[0], Infinity),
      nextafter(p[1], Infinity)
    ]
  }
  return bounds
}

// Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings (points, edges, edgeBounds) {
  var result = []
  boxIntersect(edgeBounds, function (i, j) {
    var e = edges[i]
    var f = edges[j]
    if (e[0] === f[0] || e[0] === f[1] ||
      e[1] === f[0] || e[1] === f[1]) {
      return
    }
    var a = points[e[0]]
    var b = points[e[1]]
    var c = points[f[0]]
    var d = points[f[1]]
    if (segseg(a, b, c, d)) {
      result.push([i, j])
    }
  })
  return result
}

// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions (points, edges, edgeBounds, vertBounds) {
  var result = []
  boxIntersect(edgeBounds, vertBounds, function (i, v) {
    var e = edges[i]
    if (e[0] === v || e[1] === v) {
      return
    }
    var p = points[v]
    var a = points[e[0]]
    var b = points[e[1]]
    if (segseg(a, b, p, p)) {
      result.push([i, v])
    }
  })
  return result
}

// Cut edges along crossings/tjunctions
function cutEdges (floatPoints, edges, crossings, junctions, useColor) {
  var i, e

  // Convert crossings into tjunctions by constructing rational points
  var ratPoints = floatPoints.map(function(p) {
      return [
          rat(p[0]),
          rat(p[1])
      ]
  })
  for (i = 0; i < crossings.length; ++i) {
    var crossing = crossings[i]
    e = crossing[0]
    var f = crossing[1]
    var ee = edges[e]
    var ef = edges[f]
    var x = solveIntersection(
      ratVec(floatPoints[ee[0]]),
      ratVec(floatPoints[ee[1]]),
      ratVec(floatPoints[ef[0]]),
      ratVec(floatPoints[ef[1]]))
    if (!x) {
      // Segments are parallel, should already be handled by t-junctions
      continue
    }
    var idx = floatPoints.length
    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])])
    ratPoints.push(x)
    junctions.push([e, idx], [f, idx])
  }

  // Sort tjunctions
  junctions.sort(function (a, b) {
    if (a[0] !== b[0]) {
      return a[0] - b[0]
    }
    var u = ratPoints[a[1]]
    var v = ratPoints[b[1]]
    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])
  })

  // Split edges along junctions
  for (i = junctions.length - 1; i >= 0; --i) {
    var junction = junctions[i]
    e = junction[0]

    var edge = edges[e]
    var s = edge[0]
    var t = edge[1]

    // Check if edge is not lexicographically sorted
    var a = floatPoints[s]
    var b = floatPoints[t]
    if (((a[0] - b[0]) || (a[1] - b[1])) < 0) {
      var tmp = s
      s = t
      t = tmp
    }

    // Split leading edge
    edge[0] = s
    var last = edge[1] = junction[1]

    // If we are grouping edges by color, remember to track data
    var color
    if (useColor) {
      color = edge[2]
    }

    // Split other edges
    while (i > 0 && junctions[i - 1][0] === e) {
      var junction = junctions[--i]
      var next = junction[1]
      if (useColor) {
        edges.push([last, next, color])
      } else {
        edges.push([last, next])
      }
      last = next
    }

    // Add final edge
    if (useColor) {
      edges.push([last, t, color])
    } else {
      edges.push([last, t])
    }
  }

  // Return constructed rational points
  return ratPoints
}

// Merge overlapping points
function dedupPoints (floatPoints, ratPoints, floatBounds) {
  var numPoints = ratPoints.length
  var uf = new UnionFind(numPoints)

  // Compute rational bounds
  var bounds = []
  for (var i = 0; i < ratPoints.length; ++i) {
    var p = ratPoints[i]
    var xb = boundRat(p[0])
    var yb = boundRat(p[1])
    bounds.push([
      nextafter(xb[0], -Infinity),
      nextafter(yb[0], -Infinity),
      nextafter(xb[1], Infinity),
      nextafter(yb[1], Infinity)
    ])
  }

  // Link all points with over lapping boxes
  boxIntersect(bounds, function (i, j) {
    uf.link(i, j)
  })

  // Do 1 pass over points to combine points in label sets
  var noDupes = true
  var labels = new Array(numPoints)
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j !== i) {
      // Clear no-dupes flag, zero out label
      noDupes = false
      // Make each point the top-left point from its cell
      floatPoints[j] = [
        Math.min(floatPoints[i][0], floatPoints[j][0]),
        Math.min(floatPoints[i][1], floatPoints[j][1])
      ]
    }
  }

  // If no duplicates, return null to signal termination
  if (noDupes) {
    return null
  }

  var ptr = 0
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j === i) {
      labels[i] = ptr
      floatPoints[ptr++] = floatPoints[i]
    } else {
      labels[i] = -1
    }
  }

  floatPoints.length = ptr

  // Do a second pass to fix up missing labels
  for (var i = 0; i < numPoints; ++i) {
    if (labels[i] < 0) {
      labels[i] = labels[uf.find(i)]
    }
  }

  // Return resulting union-find data structure
  return labels
}

function compareLex2 (a, b) { return (a[0] - b[0]) || (a[1] - b[1]) }
function compareLex3 (a, b) {
  var d = (a[0] - b[0]) || (a[1] - b[1])
  if (d) {
    return d
  }
  if (a[2] < b[2]) {
    return -1
  } else if (a[2] > b[2]) {
    return 1
  }
  return 0
}

// Remove duplicate edge labels
function dedupEdges (edges, labels, useColor) {
  if (edges.length === 0) {
    return
  }
  if (labels) {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = labels[e[0]]
      var b = labels[e[1]]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  } else {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = e[0]
      var b = e[1]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  }
  if (useColor) {
    edges.sort(compareLex3)
  } else {
    edges.sort(compareLex2)
  }
  var ptr = 1
  for (var i = 1; i < edges.length; ++i) {
    var prev = edges[i - 1]
    var next = edges[i]
    if (next[0] === prev[0] && next[1] === prev[1] &&
      (!useColor || next[2] === prev[2])) {
      continue
    }
    edges[ptr++] = next
  }
  edges.length = ptr
}

function preRound (points, edges, useColor) {
  var labels = dedupPoints(points, [], boundPoints(points))
  dedupEdges(edges, labels, useColor)
  return !!labels
}

// Repeat until convergence
function snapRound (points, edges, useColor) {
  // 1. find edge crossings
  var edgeBounds = boundEdges(points, edges)
  var crossings = getCrossings(points, edges, edgeBounds)

  // 2. find t-junctions
  var vertBounds = boundPoints(points)
  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)

  // 3. cut edges, construct rational points
  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor)

  // 4. dedupe verts
  var labels = dedupPoints(points, ratPoints, vertBounds)

  // 5. dedupe edges
  dedupEdges(edges, labels, useColor)

  // 6. check termination
  if (!labels) {
    return (crossings.length > 0 || tjunctions.length > 0)
  }

  // More iterations necessary
  return true
}

// Main loop, runs PSLG clean up until completion
function cleanPSLG (points, edges, colors) {
  // If using colors, augment edges with color data
  var prevEdges
  if (colors) {
    prevEdges = edges
    var augEdges = new Array(edges.length)
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      augEdges[i] = [e[0], e[1], colors[i]]
    }
    edges = augEdges
  }

  // First round: remove duplicate edges and points
  var modified = preRound(points, edges, !!colors)

  // Run snap rounding until convergence
  while (snapRound(points, edges, !!colors)) {
    modified = true
  }

  // Strip color tags
  if (!!colors && modified) {
    prevEdges.length = 0
    colors.length = 0
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      prevEdges.push([e[0], e[1]])
      colors.push(e[2])
    }
  }

  return modified
}

},{"./lib/rat-seg-intersect":37,"big-rat":5,"big-rat/cmp":3,"big-rat/to-float":18,"box-intersect":21,"nextafter":87,"rat-vec":99,"robust-segment-intersect":108,"union-find":140}],37:[function(require,module,exports){
'use strict'

module.exports = solveIntersection

var ratMul = require('big-rat/mul')
var ratDiv = require('big-rat/div')
var ratSub = require('big-rat/sub')
var ratSign = require('big-rat/sign')
var rvSub = require('rat-vec/sub')
var rvAdd = require('rat-vec/add')
var rvMuls = require('rat-vec/muls')

function ratPerp (a, b) {
  return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]))
}

// Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)

function solveIntersection (a, b, c, d) {
  var ba = rvSub(b, a)
  var dc = rvSub(d, c)

  var baXdc = ratPerp(ba, dc)

  if (ratSign(baXdc) === 0) {
    return null
  }

  var ac = rvSub(a, c)
  var dcXac = ratPerp(dc, ac)

  var t = ratDiv(dcXac, baXdc)
  var s = rvMuls(ba, t)
  var r = rvAdd(a, s)

  return r
}

},{"big-rat/div":4,"big-rat/mul":14,"big-rat/sign":16,"big-rat/sub":17,"rat-vec/add":98,"rat-vec/muls":100,"rat-vec/sub":101}],38:[function(require,module,exports){
"use strict"

module.exports = compareAngle

var orient = require("robust-orientation")
var sgn = require("signum")
var twoSum = require("two-sum")
var robustProduct = require("robust-product")
var robustSum = require("robust-sum")

function testInterior(a, b, c) {
  var x0 = twoSum(a[0], -b[0])
  var y0 = twoSum(a[1], -b[1])
  var x1 = twoSum(c[0], -b[0])
  var y1 = twoSum(c[1], -b[1])

  var d = robustSum(
    robustProduct(x0, x1),
    robustProduct(y0, y1))

  return d[d.length-1] >= 0
}

function compareAngle(a, b, c, d) {
  var bcd = orient(b, c, d)
  if(bcd === 0) {
    //Handle degenerate cases
    var sabc = sgn(orient(a, b, c))
    var sabd = sgn(orient(a, b, d))
    if(sabc === sabd) {
      if(sabc === 0) {
        var ic = testInterior(a, b, c)
        var id = testInterior(a, b, d)
        if(ic === id) {
          return 0
        } else if(ic) {
          return 1
        } else {
          return -1
        }
      }
      return 0
    } else if(sabd === 0) {
      if(sabc > 0) {
        return -1
      } else if(testInterior(a, b, d)) {
        return -1
      } else {
        return 1
      }
    } else if(sabc === 0) {
      if(sabd > 0) {
        return 1
      } else if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
    return sgn(sabd - sabc)
  }
  var abc = orient(a, b, c)
  if(abc > 0) {
    if(bcd > 0 && orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else if(abc < 0) {
    if(bcd > 0 || orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else {
    var abd = orient(a, b, d)
    if(abd > 0) {
      return 1
    } else {
      if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
  }
}
},{"robust-orientation":105,"robust-product":106,"robust-sum":110,"signum":111,"two-sum":138}],39:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":41}],40:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":141}],41:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":40}],42:[function(require,module,exports){
(function (Buffer){(function (){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":30}],43:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],44:[function(require,module,exports){
"use strict"

module.exports = edgeToAdjacency

var uniq = require("uniq")

function edgeToAdjacency(edges, numVertices) {
  var numEdges = edges.length
  if(typeof numVertices !== "number") {
    numVertices = 0
    for(var i=0; i<numEdges; ++i) {
      var e = edges[i]
      numVertices = Math.max(numVertices, e[0], e[1])
    }
    numVertices = (numVertices|0) + 1
  }
  numVertices = numVertices|0
  var adj = new Array(numVertices)
  for(var i=0; i<numVertices; ++i) {
    adj[i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    adj[e[0]].push(e[1])
    adj[e[1]].push(e[0])
  }
  for(var j=0; j<numVertices; ++j) {
    uniq(adj[j], function(a, b) {
      return a - b
    })
  }
  return adj
}
},{"uniq":141}],45:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}],46:[function(require,module,exports){
// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
];

var g_ln = 607/128;
var p_ln = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.21743961811521264320e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.26190838401581408670e-4,
    0.36899182659531622704e-5
];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if(z < 0) return Number('0/0');
    var x = p_ln[0];
    for(var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5*Math.log(2*Math.PI)+(z+.5)*Math.log(t)-t+Math.log(x)-Math.log(z);
}

module.exports = function gamma (z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    }
    else if(z > 100) return Math.exp(lngamma(z));
    else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI)
            * Math.pow(t, z + 0.5)
            * Math.exp(-t)
            * x
        ;
    }
};

module.exports.log = lngamma;

},{}],47:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],48:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],49:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],50:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],51:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],52:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],53:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],54:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],55:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],56:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],57:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],58:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],59:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],60:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],61:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],62:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":47,"./clone":48,"./copy":49,"./create":50,"./determinant":51,"./fromQuat":52,"./fromRotation":53,"./fromRotationTranslation":54,"./fromScaling":55,"./fromTranslation":56,"./fromXRotation":57,"./fromYRotation":58,"./fromZRotation":59,"./frustum":60,"./identity":61,"./invert":63,"./lookAt":64,"./multiply":65,"./ortho":66,"./perspective":67,"./perspectiveFromFieldOfView":68,"./rotate":69,"./rotateX":70,"./rotateY":71,"./rotateZ":72,"./scale":73,"./str":74,"./translate":75,"./transpose":76}],63:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],64:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":61}],65:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],66:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],69:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],71:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],72:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],73:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],74:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],75:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],76:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],77:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],78:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],79:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],80:[function(require,module,exports){
"use strict"

var bounds = require("binary-search-bounds")

var NOT_FOUND = 0
var SUCCESS = 1
var EMPTY = 2

module.exports = createWrapper

function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
  this.mid = mid
  this.left = left
  this.right = right
  this.leftPoints = leftPoints
  this.rightPoints = rightPoints
  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length
}

var proto = IntervalTreeNode.prototype

function copy(a, b) {
  a.mid = b.mid
  a.left = b.left
  a.right = b.right
  a.leftPoints = b.leftPoints
  a.rightPoints = b.rightPoints
  a.count = b.count
}

function rebuild(node, intervals) {
  var ntree = createIntervalTree(intervals)
  node.mid = ntree.mid
  node.left = ntree.left
  node.right = ntree.right
  node.leftPoints = ntree.leftPoints
  node.rightPoints = ntree.rightPoints
  node.count = ntree.count
}

function rebuildWithInterval(node, interval) {
  var intervals = node.intervals([])
  intervals.push(interval)
  rebuild(node, intervals)    
}

function rebuildWithoutInterval(node, interval) {
  var intervals = node.intervals([])
  var idx = intervals.indexOf(interval)
  if(idx < 0) {
    return NOT_FOUND
  }
  intervals.splice(idx, 1)
  rebuild(node, intervals)
  return SUCCESS
}

proto.intervals = function(result) {
  result.push.apply(result, this.leftPoints)
  if(this.left) {
    this.left.intervals(result)
  }
  if(this.right) {
    this.right.intervals(result)
  }
  return result
}

proto.insert = function(interval) {
  var weight = this.count - this.leftPoints.length
  this.count += 1
  if(interval[1] < this.mid) {
    if(this.left) {
      if(4*(this.left.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.left.insert(interval)
      }
    } else {
      this.left = createIntervalTree([interval])
    }
  } else if(interval[0] > this.mid) {
    if(this.right) {
      if(4*(this.right.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.right.insert(interval)
      }
    } else {
      this.right = createIntervalTree([interval])
    }
  } else {
    var l = bounds.ge(this.leftPoints, interval, compareBegin)
    var r = bounds.ge(this.rightPoints, interval, compareEnd)
    this.leftPoints.splice(l, 0, interval)
    this.rightPoints.splice(r, 0, interval)
  }
}

proto.remove = function(interval) {
  var weight = this.count - this.leftPoints
  if(interval[1] < this.mid) {
    if(!this.left) {
      return NOT_FOUND
    }
    var rw = this.right ? this.right.count : 0
    if(4 * rw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.left.remove(interval)
    if(r === EMPTY) {
      this.left = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else if(interval[0] > this.mid) {
    if(!this.right) {
      return NOT_FOUND
    }
    var lw = this.left ? this.left.count : 0
    if(4 * lw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.right.remove(interval)
    if(r === EMPTY) {
      this.right = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else {
    if(this.count === 1) {
      if(this.leftPoints[0] === interval) {
        return EMPTY
      } else {
        return NOT_FOUND
      }
    }
    if(this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
      if(this.left && this.right) {
        var p = this
        var n = this.left
        while(n.right) {
          p = n
          n = n.right
        }
        if(p === this) {
          n.right = this.right
        } else {
          var l = this.left
          var r = this.right
          p.count -= n.count
          p.right = n.left
          n.left = l
          n.right = r
        }
        copy(this, n)
        this.count = (this.left?this.left.count:0) + (this.right?this.right.count:0) + this.leftPoints.length
      } else if(this.left) {
        copy(this, this.left)
      } else {
        copy(this, this.right)
      }
      return SUCCESS
    }
    for(var l = bounds.ge(this.leftPoints, interval, compareBegin); l<this.leftPoints.length; ++l) {
      if(this.leftPoints[l][0] !== interval[0]) {
        break
      }
      if(this.leftPoints[l] === interval) {
        this.count -= 1
        this.leftPoints.splice(l, 1)
        for(var r = bounds.ge(this.rightPoints, interval, compareEnd); r<this.rightPoints.length; ++r) {
          if(this.rightPoints[r][1] !== interval[1]) {
            break
          } else if(this.rightPoints[r] === interval) {
            this.rightPoints.splice(r, 1)
            return SUCCESS
          }
        }
      }
    }
    return NOT_FOUND
  }
}

function reportLeftRange(arr, hi, cb) {
  for(var i=0; i<arr.length && arr[i][0] <= hi; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRightRange(arr, lo, cb) {
  for(var i=arr.length-1; i>=0 && arr[i][1] >= lo; --i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRange(arr, cb) {
  for(var i=0; i<arr.length; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

proto.queryPoint = function(x, cb) {
  if(x < this.mid) {
    if(this.left) {
      var r = this.left.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportLeftRange(this.leftPoints, x, cb)
  } else if(x > this.mid) {
    if(this.right) {
      var r = this.right.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportRightRange(this.rightPoints, x, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

proto.queryInterval = function(lo, hi, cb) {
  if(lo < this.mid && this.left) {
    var r = this.left.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi > this.mid && this.right) {
    var r = this.right.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi < this.mid) {
    return reportLeftRange(this.leftPoints, hi, cb)
  } else if(lo > this.mid) {
    return reportRightRange(this.rightPoints, lo, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

function compareNumbers(a, b) {
  return a - b
}

function compareBegin(a, b) {
  var d = a[0] - b[0]
  if(d) { return d }
  return a[1] - b[1]
}

function compareEnd(a, b) {
  var d = a[1] - b[1]
  if(d) { return d }
  return a[0] - b[0]
}

function createIntervalTree(intervals) {
  if(intervals.length === 0) {
    return null
  }
  var pts = []
  for(var i=0; i<intervals.length; ++i) {
    pts.push(intervals[i][0], intervals[i][1])
  }
  pts.sort(compareNumbers)

  var mid = pts[pts.length>>1]

  var leftIntervals = []
  var rightIntervals = []
  var centerIntervals = []
  for(var i=0; i<intervals.length; ++i) {
    var s = intervals[i]
    if(s[1] < mid) {
      leftIntervals.push(s)
    } else if(mid < s[0]) {
      rightIntervals.push(s)
    } else {
      centerIntervals.push(s)
    }
  }

  //Split center intervals
  var leftPoints = centerIntervals
  var rightPoints = centerIntervals.slice()
  leftPoints.sort(compareBegin)
  rightPoints.sort(compareEnd)

  return new IntervalTreeNode(mid, 
    createIntervalTree(leftIntervals),
    createIntervalTree(rightIntervals),
    leftPoints,
    rightPoints)
}

//User friendly wrapper that makes it possible to support empty trees
function IntervalTree(root) {
  this.root = root
}

var tproto = IntervalTree.prototype

tproto.insert = function(interval) {
  if(this.root) {
    this.root.insert(interval)
  } else {
    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval])
  }
}

tproto.remove = function(interval) {
  if(this.root) {
    var r = this.root.remove(interval)
    if(r === EMPTY) {
      this.root = null
    }
    return r !== NOT_FOUND
  }
  return false
}

tproto.queryPoint = function(p, cb) {
  if(this.root) {
    return this.root.queryPoint(p, cb)
  }
}

tproto.queryInterval = function(lo, hi, cb) {
  if(lo <= hi && this.root) {
    return this.root.queryInterval(lo, hi, cb)
  }
}

Object.defineProperty(tproto, "count", {
  get: function() {
    if(this.root) {
      return this.root.count
    }
    return 0
  }
})

Object.defineProperty(tproto, "intervals", {
  get: function() {
    if(this.root) {
      return this.root.intervals([])
    }
    return []
  }
})

function createWrapper(intervals) {
  if(!intervals || intervals.length === 0) {
    return new IntervalTree(null)
  }
  return new IntervalTree(createIntervalTree(intervals))
}

},{"binary-search-bounds":19}],81:[function(require,module,exports){
"use strict"

function invertPermutation(pi, result) {
  result = result || new Array(pi.length)
  for(var i=0; i<pi.length; ++i) {
    result[pi[i]] = i
  }
  return result
}

module.exports = invertPermutation
},{}],82:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],83:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],84:[function(require,module,exports){
!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(r="undefined"!=typeof globalThis?globalThis:r||self).Meyda=t()}(this,(function(){"use strict";function r(r,t,e){if(e||2===arguments.length)for(var a,n=0,o=t.length;n<o;n++)!a&&n in t||(a||(a=Array.prototype.slice.call(t,0,n)),a[n]=t[n]);return r.concat(a||Array.prototype.slice.call(t))}var t=Object.freeze({__proto__:null,blackman:function(r){for(var t=new Float32Array(r),e=2*Math.PI/(r-1),a=2*e,n=0;n<r/2;n++)t[n]=.42-.5*Math.cos(n*e)+.08*Math.cos(n*a);for(n=Math.ceil(r/2);n>0;n--)t[r-n]=t[n-1];return t},sine:function(r){for(var t=Math.PI/(r-1),e=new Float32Array(r),a=0;a<r;a++)e[a]=Math.sin(t*a);return e},hanning:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.5-.5*Math.cos(2*Math.PI*e/(r-1));return t},hamming:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.54-.46*Math.cos(2*Math.PI*(e/r-1));return t}}),e={};function a(r){for(;r%2==0&&r>1;)r/=2;return 1===r}function n(r,a){if("rect"!==a){if(""!==a&&a||(a="hanning"),e[a]||(e[a]={}),!e[a][r.length])try{e[a][r.length]=t[a](r.length)}catch(r){throw new Error("Invalid windowing function")}r=function(r,t){for(var e=[],a=0;a<Math.min(r.length,t.length);a++)e[a]=r[a]*t[a];return e}(r,e[a][r.length])}return r}function o(r,t,e){for(var a=new Float32Array(r),n=0;n<a.length;n++)a[n]=n*t/e,a[n]=13*Math.atan(a[n]/1315.8)+3.5*Math.atan(Math.pow(a[n]/7518,2));return a}function i(r){return Float32Array.from(r)}function u(r){return 1125*Math.log(1+r/700)}function f(r,t,e){for(var a,n=new Float32Array(r+2),o=new Float32Array(r+2),i=t/2,f=u(0),c=(u(i)-f)/(r+1),l=new Array(r+2),s=0;s<n.length;s++)n[s]=s*c,o[s]=(a=n[s],700*(Math.exp(a/1125)-1)),l[s]=Math.floor((e+1)*o[s]/t);for(var m=new Array(r),p=0;p<m.length;p++){m[p]=new Array(e/2+1).fill(0);for(s=l[p];s<l[p+1];s++)m[p][s]=(s-l[p])/(l[p+1]-l[p]);for(s=l[p+1];s<l[p+2];s++)m[p][s]=(l[p+2]-s)/(l[p+2]-l[p+1])}return m}function c(t,e,a,n,o,i,u){void 0===n&&(n=5),void 0===o&&(o=2),void 0===i&&(i=!0),void 0===u&&(u=440);var f=Math.floor(a/2)+1,c=new Array(a).fill(0).map((function(r,n){return t*function(r,t){return Math.log2(16*r/t)}(e*n/a,u)}));c[0]=c[1]-1.5*t;var l,s,m,p=c.slice(1).map((function(r,t){return Math.max(r-c[t])}),1).concat([1]),h=Math.round(t/2),g=new Array(t).fill(0).map((function(r,e){return c.map((function(r){return(10*t+h+r-e)%t-h}))})),w=g.map((function(r,t){return r.map((function(r,e){return Math.exp(-.5*Math.pow(2*g[t][e]/p[e],2))}))}));if(s=(l=w)[0].map((function(){return 0})),m=l.reduce((function(r,t){return t.forEach((function(t,e){r[e]+=Math.pow(t,2)})),r}),s).map(Math.sqrt),w=l.map((function(r,t){return r.map((function(r,t){return r/(m[t]||1)}))})),o){var v=c.map((function(r){return Math.exp(-.5*Math.pow((r/t-n)/o,2))}));w=w.map((function(r){return r.map((function(r,t){return r*v[t]}))}))}return i&&(w=r(r([],w.slice(3),!0),w.slice(0,3),!0)),w.map((function(r){return r.slice(0,f)}))}function l(r,t){for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.pow(n,r)*Math.abs(t[n]),a+=t[n];return e/a}function s(r){var t=r.ampSpectrum,e=r.barkScale,a=r.numberOfBarkBands,n=void 0===a?24:a;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;var o=n,i=new Float32Array(o),u=0,f=t,c=new Int32Array(o+1);c[0]=0;for(var l=e[f.length-1]/o,s=1,m=0;m<f.length;m++)for(;e[m]>l;)c[s++]=m,l=s*e[f.length-1]/o;c[o]=f.length-1;for(m=0;m<o;m++){for(var p=0,h=c[m];h<c[m+1];h++)p+=f[h];i[m]=Math.pow(p,.23)}for(m=0;m<i.length;m++)u+=i[m];return{specific:i,total:u}}function m(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=new Float32Array(t.length),a=0;a<e.length;a++)e[a]=Math.pow(t[a],2);return e}function p(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.bufferSize;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate melBands");if("object"!=typeof e)throw new TypeError("Valid melFilterBank is required to generate melBands");for(var n=m({ampSpectrum:t}),o=e.length,i=Array(o),u=new Float32Array(o),f=0;f<u.length;f++){i[f]=new Float32Array(a/2),u[f]=0;for(var c=0;c<a/2;c++)i[f][c]=e[f][c]*n[c],u[f]+=i[f][c];u[f]=Math.log(u[f]+1)}return Array.prototype.slice.call(u)}function h(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var g={exports:{}},w=null;var v=function(r,t){var e=r.length;return t=t||2,w&&w[e]||function(r){(w=w||{})[r]=new Array(r*r);for(var t=Math.PI/r,e=0;e<r;e++)for(var a=0;a<r;a++)w[r][a+e*r]=Math.cos(t*(a+.5)*e)}(e),r.map((function(){return 0})).map((function(a,n){return t*r.reduce((function(r,t,a,o){return r+t*w[e][a+n*e]}),0)}))};!function(r){r.exports=v}(g);var d=h(g.exports);var y=Object.freeze({__proto__:null,buffer:function(r){return r.signal},rms:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(t[a],2);return e/=t.length,e=Math.sqrt(e)},energy:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(Math.abs(t[a]),2);return e},complexSpectrum:function(r){return r.complexSpectrum},spectralSlope:function(r){var t=r.ampSpectrum,e=r.sampleRate,a=r.bufferSize;if("object"!=typeof t)throw new TypeError;for(var n=0,o=0,i=new Float32Array(t.length),u=0,f=0,c=0;c<t.length;c++){n+=t[c];var l=c*e/a;i[c]=l,u+=l*l,o+=l,f+=l*t[c]}return(t.length*f-o*n)/(n*(u-Math.pow(o,2)))},spectralCentroid:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return l(1,t)},spectralRolloff:function(r){var t=r.ampSpectrum,e=r.sampleRate;if("object"!=typeof t)throw new TypeError;for(var a=t,n=e/(2*(a.length-1)),o=0,i=0;i<a.length;i++)o+=a[i];for(var u=.99*o,f=a.length-1;o>u&&f>=0;)o-=a[f],--f;return(f+1)*n},spectralFlatness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.log(t[n]),a+=t[n];return Math.exp(e/t.length)*t.length/a},spectralSpread:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return Math.sqrt(l(2,t)-Math.pow(l(1,t),2))},spectralSkewness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=l(1,t),a=l(2,t),n=l(3,t);return(2*Math.pow(e,3)-3*e*a+n)/Math.pow(Math.sqrt(a-Math.pow(e,2)),3)},spectralKurtosis:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=t,a=l(1,e),n=l(2,e),o=l(3,e),i=l(4,e);return(-3*Math.pow(a,4)+6*a*n-4*a*o+i)/Math.pow(Math.sqrt(n-Math.pow(a,2)),4)},amplitudeSpectrum:function(r){return r.ampSpectrum},zcr:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=1;a<t.length;a++)(t[a-1]>=0&&t[a]<0||t[a-1]<0&&t[a]>=0)&&e++;return e},loudness:s,perceptualSpread:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=0,a=0;a<t.specific.length;a++)t.specific[a]>e&&(e=t.specific[a]);return Math.pow((t.total-e)/t.total,2)},perceptualSharpness:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=t.specific,a=0,n=0;n<e.length;n++)a+=n<15?(n+1)*e[n+1]:.066*Math.exp(.171*(n+1));return a*=.11/t.total},powerSpectrum:m,mfcc:function(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.numberOfMFCCCoefficients,n=r.bufferSize,o=Math.min(40,Math.max(1,a||13));if(e.length<o)throw new Error("Insufficient filter bank for requested number of coefficients");var i=p({ampSpectrum:t,melFilterBank:e,bufferSize:n});return d(i).slice(0,o)},chroma:function(r){var t=r.ampSpectrum,e=r.chromaFilterBank;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate chroma");if("object"!=typeof e)throw new TypeError("Valid chromaFilterBank is required to generate chroma");var a=e.map((function(r,e){return t.reduce((function(t,e,a){return t+e*r[a]}),0)})),n=Math.max.apply(Math,a);return n?a.map((function(r){return r/n})):a},spectralFlux:function(r){var t=r.signal,e=r.previousSignal,a=r.bufferSize;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;for(var n=0,o=-a/2;o<t.length/2-1;o++)x=Math.abs(t[o])-Math.abs(e[o]),n+=(x+Math.abs(x))/2;return n},spectralCrest:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=0,a=-1/0;return t.forEach((function(r){e+=Math.pow(r,2),a=r>a?r:a})),e/=t.length,e=Math.sqrt(e),a/e},melBands:p});function S(r){if(Array.isArray(r)){for(var t=0,e=Array(r.length);t<r.length;t++)e[t]=r[t];return e}return Array.from(r)}var _={},b={},M={bitReverseArray:function(r){if(void 0===_[r]){for(var t=(r-1).toString(2).length,e="0".repeat(t),a={},n=0;n<r;n++){var o=n.toString(2);o=e.substr(o.length)+o,o=[].concat(S(o)).reverse().join(""),a[n]=parseInt(o,2)}_[r]=a}return _[r]},multiply:function(r,t){return{real:r.real*t.real-r.imag*t.imag,imag:r.real*t.imag+r.imag*t.real}},add:function(r,t){return{real:r.real+t.real,imag:r.imag+t.imag}},subtract:function(r,t){return{real:r.real-t.real,imag:r.imag-t.imag}},euler:function(r,t){var e=-2*Math.PI*r/t;return{real:Math.cos(e),imag:Math.sin(e)}},conj:function(r){return r.imag*=-1,r},constructComplexArray:function(r){var t={};t.real=void 0===r.real?r.slice():r.real.slice();var e=t.real.length;return void 0===b[e]&&(b[e]=Array.apply(null,Array(e)).map(Number.prototype.valueOf,0)),t.imag=b[e].slice(),t}},F=function(r){var t={};void 0===r.real||void 0===r.imag?t=M.constructComplexArray(r):(t.real=r.real.slice(),t.imag=r.imag.slice());var e=t.real.length,a=Math.log2(e);if(Math.round(a)!=a)throw new Error("Input size must be a power of 2.");if(t.real.length!=t.imag.length)throw new Error("Real and imaginary components must have the same length.");for(var n=M.bitReverseArray(e),o={real:[],imag:[]},i=0;i<e;i++)o.real[n[i]]=t.real[i],o.imag[n[i]]=t.imag[i];for(var u=0;u<e;u++)t.real[u]=o.real[u],t.imag[u]=o.imag[u];for(var f=1;f<=a;f++)for(var c=Math.pow(2,f),l=0;l<c/2;l++)for(var s=M.euler(l,c),m=0;m<e/c;m++){var p=c*m+l,h=c*m+l+c/2,g={real:t.real[p],imag:t.imag[p]},w={real:t.real[h],imag:t.imag[h]},v=M.multiply(s,w),d=M.subtract(g,v);t.real[h]=d.real,t.imag[h]=d.imag;var y=M.add(v,g);t.real[p]=y.real,t.imag[p]=y.imag}return t},A=F,E=function(){function r(r,t){var e=this;if(this._m=t,!r.audioContext)throw this._m.errors.noAC;if(r.bufferSize&&!a(r.bufferSize))throw this._m._errors.notPow2;if(!r.source)throw this._m._errors.noSource;this._m.audioContext=r.audioContext,this._m.bufferSize=r.bufferSize||this._m.bufferSize||256,this._m.hopSize=r.hopSize||this._m.hopSize||this._m.bufferSize,this._m.sampleRate=r.sampleRate||this._m.audioContext.sampleRate||44100,this._m.callback=r.callback,this._m.windowingFunction=r.windowingFunction||"hanning",this._m.featureExtractors=y,this._m.EXTRACTION_STARTED=r.startImmediately||!1,this._m.channel="number"==typeof r.channel?r.channel:0,this._m.inputs=r.inputs||1,this._m.outputs=r.outputs||1,this._m.numberOfMFCCCoefficients=r.numberOfMFCCCoefficients||this._m.numberOfMFCCCoefficients||13,this._m.numberOfBarkBands=r.numberOfBarkBands||this._m.numberOfBarkBands||24,this._m.spn=this._m.audioContext.createScriptProcessor(this._m.bufferSize,this._m.inputs,this._m.outputs),this._m.spn.connect(this._m.audioContext.destination),this._m._featuresToExtract=r.featureExtractors||[],this._m.barkScale=o(this._m.bufferSize,this._m.sampleRate,this._m.bufferSize),this._m.melFilterBank=f(Math.max(this._m.melBands,this._m.numberOfMFCCCoefficients),this._m.sampleRate,this._m.bufferSize),this._m.inputData=null,this._m.previousInputData=null,this._m.frame=null,this._m.previousFrame=null,this.setSource(r.source),this._m.spn.onaudioprocess=function(r){var t;null!==e._m.inputData&&(e._m.previousInputData=e._m.inputData),e._m.inputData=r.inputBuffer.getChannelData(e._m.channel),e._m.previousInputData?((t=new Float32Array(e._m.previousInputData.length+e._m.inputData.length-e._m.hopSize)).set(e._m.previousInputData.slice(e._m.hopSize)),t.set(e._m.inputData,e._m.previousInputData.length-e._m.hopSize)):t=e._m.inputData,function(r,t,e){if(r.length<t)throw new Error("Buffer is too short for frame length");if(e<1)throw new Error("Hop length cannot be less that 1");if(t<1)throw new Error("Frame length cannot be less that 1");var a=1+Math.floor((r.length-t)/e);return new Array(a).fill(0).map((function(a,n){return r.slice(n*e,n*e+t)}))}(t,e._m.bufferSize,e._m.hopSize).forEach((function(r){e._m.frame=r;var t=e._m.extract(e._m._featuresToExtract,e._m.frame,e._m.previousFrame);"function"==typeof e._m.callback&&e._m.EXTRACTION_STARTED&&e._m.callback(t),e._m.previousFrame=e._m.frame}))}}return r.prototype.start=function(r){this._m._featuresToExtract=r||this._m._featuresToExtract,this._m.EXTRACTION_STARTED=!0},r.prototype.stop=function(){this._m.EXTRACTION_STARTED=!1},r.prototype.setSource=function(r){this._m.source&&this._m.source.disconnect(this._m.spn),this._m.source=r,this._m.source.connect(this._m.spn)},r.prototype.setChannel=function(r){r<=this._m.inputs?this._m.channel=r:console.error("Channel ".concat(r," does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r," when instantiating the MeydaAnalyzer"))},r.prototype.get=function(r){return this._m.inputData?this._m.extract(r||this._m._featuresToExtract,this._m.inputData,this._m.previousInputData):null},r}(),C={audioContext:null,spn:null,bufferSize:512,sampleRate:44100,melBands:26,chromaBands:12,callback:null,windowingFunction:"hanning",featureExtractors:y,EXTRACTION_STARTED:!1,numberOfMFCCCoefficients:13,numberOfBarkBands:24,_featuresToExtract:[],windowing:n,_errors:{notPow2:new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"),featureUndef:new Error("Meyda: No features defined."),invalidFeatureFmt:new Error("Meyda: Invalid feature format"),invalidInput:new Error("Meyda: Invalid input."),noAC:new Error("Meyda: No AudioContext specified."),noSource:new Error("Meyda: No source node specified.")},createMeydaAnalyzer:function(r){return new E(r,Object.assign({},C))},listAvailableFeatureExtractors:function(){return Object.keys(this.featureExtractors)},extract:function(r,t,e){var n=this;if(!t)throw this._errors.invalidInput;if("object"!=typeof t)throw this._errors.invalidInput;if(!r)throw this._errors.featureUndef;if(!a(t.length))throw this._errors.notPow2;void 0!==this.barkScale&&this.barkScale.length==this.bufferSize||(this.barkScale=o(this.bufferSize,this.sampleRate,this.bufferSize)),void 0!==this.melFilterBank&&this.barkScale.length==this.bufferSize&&this.melFilterBank.length==this.melBands||(this.melFilterBank=f(Math.max(this.melBands,this.numberOfMFCCCoefficients),this.sampleRate,this.bufferSize)),void 0!==this.chromaFilterBank&&this.chromaFilterBank.length==this.chromaBands||(this.chromaFilterBank=c(this.chromaBands,this.sampleRate,this.bufferSize)),"buffer"in t&&void 0===t.buffer?this.signal=i(t):this.signal=t;var u=k(t,this.windowingFunction,this.bufferSize);if(this.signal=u.windowedSignal,this.complexSpectrum=u.complexSpectrum,this.ampSpectrum=u.ampSpectrum,e){var l=k(e,this.windowingFunction,this.bufferSize);this.previousSignal=l.windowedSignal,this.previousComplexSpectrum=l.complexSpectrum,this.previousAmpSpectrum=l.ampSpectrum}var s=function(r){return n.featureExtractors[r]({ampSpectrum:n.ampSpectrum,chromaFilterBank:n.chromaFilterBank,complexSpectrum:n.complexSpectrum,signal:n.signal,bufferSize:n.bufferSize,sampleRate:n.sampleRate,barkScale:n.barkScale,melFilterBank:n.melFilterBank,previousSignal:n.previousSignal,previousAmpSpectrum:n.previousAmpSpectrum,previousComplexSpectrum:n.previousComplexSpectrum,numberOfMFCCCoefficients:n.numberOfMFCCCoefficients,numberOfBarkBands:n.numberOfBarkBands})};if("object"==typeof r)return r.reduce((function(r,t){var e;return Object.assign({},r,((e={})[t]=s(t),e))}),{});if("string"==typeof r)return s(r);throw this._errors.invalidFeatureFmt}},k=function(r,t,e){var a={};void 0===r.buffer?a.signal=i(r):a.signal=r,a.windowedSignal=n(a.signal,t),a.complexSpectrum=A(a.windowedSignal),a.ampSpectrum=new Float32Array(e/2);for(var o=0;o<e/2;o++)a.ampSpectrum[o]=Math.sqrt(Math.pow(a.complexSpectrum.real[o],2)+Math.pow(a.complexSpectrum.imag[o],2));return a};return"undefined"!=typeof window&&(window.Meyda=C),C}));


},{}],85:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")

module.exports = createSurfaceExtractor

//Helper macros
function array(i) {
  return "a" + i
}
function data(i) {
  return "d" + i
}
function cube(i,bitmask) {
  return "c" + i + "_" + bitmask
}
function shape(i) {
  return "s" + i
}
function stride(i,j) {
  return "t" + i + "_" + j
}
function offset(i) {
  return "o" + i
}
function scalar(i) {
  return "x" + i
}
function pointer(i) {
  return "p" + i
}
function delta(i,bitmask) {
  return "d" + i + "_" + bitmask
}
function index(i) {
  return "i" + i
}
function step(i,j) {
  return "u" + i + "_" + j
}
function pcube(bitmask) {
  return "b" + bitmask
}
function qcube(bitmask) {
  return "y" + bitmask
}
function pdelta(bitmask) {
  return "e" + bitmask
}
function vert(i) {
  return "v" + i
}
var VERTEX_IDS = "V"
var PHASES = "P"
var VERTEX_COUNT = "N"
var POOL_SIZE = "Q"
var POINTER = "X"
var TEMPORARY = "T"

function permBitmask(dimension, mask, order) {
  var r = 0
  for(var i=0; i<dimension; ++i) {
    if(mask & (1<<i)) {
      r |= (1<<order[i])
    }
  }
  return r
}

//Generates the surface procedure
function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {
  var arrayArgs = typesig.length
  var dimension = order.length

  if(dimension < 2) {
    throw new Error("ndarray-extract-contour: Dimension must be at least 2")
  }

  var funcName = "extractContour" + order.join("_")
  var code = []
  var vars = []
  var args = []

  //Assemble arguments
  for(var i=0; i<arrayArgs; ++i) {
    args.push(array(i))  
  }
  for(var i=0; i<scalarArgs; ++i) {
    args.push(scalar(i))
  }

  //Shape
  for(var i=0; i<dimension; ++i) {
    vars.push(shape(i) + "=" + array(0) + ".shape[" + i + "]|0")
  }
  //Data, stride, offset pointers
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(data(i) + "=" + array(i) + ".data",
              offset(i) + "=" + array(i) + ".offset|0")
    for(var j=0; j<dimension; ++j) {
      vars.push(stride(i,j) + "=" + array(i) + ".stride[" + j + "]|0")
    }
  }
  //Pointer, delta and cube variables
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(pointer(i) + "=" + offset(i))
    vars.push(cube(i,0))
    for(var j=1; j<(1<<dimension); ++j) {
      var ptrStr = []
      for(var k=0; k<dimension; ++k) {
        if(j & (1<<k)) {
          ptrStr.push("-" + stride(i,k))
        }
      }
      vars.push(delta(i,j) + "=(" + ptrStr.join("") + ")|0")
      vars.push(cube(i,j) + "=0")
    }
  }
  //Create step variables
  for(var i=0; i<arrayArgs; ++i) {
    for(var j=0; j<dimension; ++j) {
      var stepVal = [ stride(i,order[j]) ]
      if(j > 0) {
        stepVal.push(stride(i, order[j-1]) + "*" + shape(order[j-1]) )
      }
      vars.push(step(i,order[j]) + "=(" + stepVal.join("-") + ")|0")
    }
  }
  //Create index variables
  for(var i=0; i<dimension; ++i) {
    vars.push(index(i) + "=0")
  }
  //Vertex count
  vars.push(VERTEX_COUNT + "=0")
  //Compute pool size, initialize pool step
  var sizeVariable = ["2"]
  for(var i=dimension-2; i>=0; --i) {
    sizeVariable.push(shape(order[i]))
  }
  //Previous phases and vertex_ids
  vars.push(POOL_SIZE + "=(" + sizeVariable.join("*") + ")|0",
            PHASES + "=mallocUint32(" + POOL_SIZE + ")",
            VERTEX_IDS + "=mallocUint32(" + POOL_SIZE + ")",
            POINTER + "=0")
  //Create cube variables for phases
  vars.push(pcube(0) + "=0")
  for(var j=1; j<(1<<dimension); ++j) {
    var cubeDelta = []
    var cubeStep = [ ]
    for(var k=0; k<dimension; ++k) {
      if(j & (1<<k)) {
        if(cubeStep.length === 0) {
          cubeDelta.push("1")
        } else {
          cubeDelta.unshift(cubeStep.join("*"))
        }
      }
      cubeStep.push(shape(order[k]))
    }
    var signFlag = ""
    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {
      signFlag = "-"
    }
    var jperm = permBitmask(dimension, j, order)
    vars.push(pdelta(jperm) + "=(-" + cubeDelta.join("-") + ")|0",
              qcube(jperm) + "=(" + signFlag + cubeDelta.join("-") + ")|0",
              pcube(jperm) + "=0")
  }
  vars.push(vert(0) + "=0", TEMPORARY + "=0")

  function forLoopBegin(i, start) {
    code.push("for(", index(order[i]), "=", start, ";",
      index(order[i]), "<", shape(order[i]), ";",
      "++", index(order[i]), "){")
  }

  function forLoopEnd(i) {
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    code.push("}")
  }

  function fillEmptySlice(k) {
    for(var i=k-1; i>=0; --i) {
      forLoopBegin(i, 0) 
    }
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        phaseFuncArgs.push(data(i) + ".get(" + pointer(i) + ")")
      } else {
        phaseFuncArgs.push(data(i) + "[" + pointer(i) + "]")
      }
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    code.push(PHASES, "[", POINTER, "++]=phase(", phaseFuncArgs.join(), ");")
    for(var i=0; i<k; ++i) {
      forLoopEnd(i)
    }
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[k]), ";")
    }
  }

  function processGridCell(mask) {
    //Read in local data
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        code.push(cube(i,0), "=", data(i), ".get(", pointer(i), ");")
      } else {
        code.push(cube(i,0), "=", data(i), "[", pointer(i), "];")
      }
    }

    //Read in phase
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      phaseFuncArgs.push(cube(i,0))
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    
    code.push(pcube(0), "=", PHASES, "[", POINTER, "]=phase(", phaseFuncArgs.join(), ");")
    
    //Read in other cube data
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(pcube(j), "=", PHASES, "[", POINTER, "+", pdelta(j), "];")
    }

    //Check for boundary crossing
    var vertexPredicate = []
    for(var j=1; j<(1<<dimension); ++j) {
      vertexPredicate.push("(" + pcube(0) + "!==" + pcube(j) + ")")
    }
    code.push("if(", vertexPredicate.join("||"), "){")

    //Read in boundary data
    var vertexArgs = []
    for(var i=0; i<dimension; ++i) {
      vertexArgs.push(index(i))
    }
    for(var i=0; i<arrayArgs; ++i) {
      vertexArgs.push(cube(i,0))
      for(var j=1; j<(1<<dimension); ++j) {
        if(typesig[i]) {
          code.push(cube(i,j), "=", data(i), ".get(", pointer(i), "+", delta(i,j), ");")
        } else {
          code.push(cube(i,j), "=", data(i), "[", pointer(i), "+", delta(i,j), "];")
        }
        vertexArgs.push(cube(i,j))
      }
    }
    for(var i=0; i<(1<<dimension); ++i) {
      vertexArgs.push(pcube(i))
    }
    for(var i=0; i<scalarArgs; ++i) {
      vertexArgs.push(scalar(i))
    }

    //Generate vertex
    code.push("vertex(", vertexArgs.join(), ");",
      vert(0), "=", VERTEX_IDS, "[", POINTER, "]=", VERTEX_COUNT, "++;")

    //Check for face crossings
    var base = (1<<dimension)-1
    var corner = pcube(base)
    for(var j=0; j<dimension; ++j) {
      if((mask & ~(1<<j))===0) {
        //Check face
        var subset = base^(1<<j)
        var edge = pcube(subset)
        var faceArgs = [ ]
        for(var k=subset; k>0; k=(k-1)&subset) {
          faceArgs.push(VERTEX_IDS + "[" + POINTER + "+" + pdelta(k) + "]")
        }
        faceArgs.push(vert(0))
        for(var k=0; k<arrayArgs; ++k) {
          if(j&1) {
            faceArgs.push(cube(k,base), cube(k,subset))
          } else {
            faceArgs.push(cube(k,subset), cube(k,base))
          }
        }
        if(j&1) {
          faceArgs.push(corner, edge)
        } else {
          faceArgs.push(edge, corner)
        }
        for(var k=0; k<scalarArgs; ++k) {
          faceArgs.push(scalar(k))
        }
        code.push("if(", corner, "!==", edge, "){",
          "face(", faceArgs.join(), ")}")
      }
    }
    
    //Increment pointer, close off if statement
    code.push("}",
      POINTER, "+=1;")
  }

  function flip() {
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(TEMPORARY, "=", pdelta(j), ";",
                pdelta(j), "=", qcube(j), ";",
                qcube(j), "=", TEMPORARY, ";")
    }
  }

  function createLoop(i, mask) {
    if(i < 0) {
      processGridCell(mask)
      return
    }
    fillEmptySlice(i)
    code.push("if(", shape(order[i]), ">0){",
      index(order[i]), "=1;")
    createLoop(i-1, mask|(1<<order[i]))

    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    if(i === dimension-1) {
      code.push(POINTER, "=0;")
      flip()
    }
    forLoopBegin(i, 2)
    createLoop(i-1, mask)
    if(i === dimension-1) {
      code.push("if(", index(order[dimension-1]), "&1){",
        POINTER, "=0;}")
      flip()
    }
    forLoopEnd(i)
    code.push("}")
  }

  createLoop(dimension-1, 0)

  //Release scratch memory
  code.push("freeUint32(", VERTEX_IDS, ");freeUint32(", PHASES, ");")

  //Compile and link procedure
  var procedureCode = [
    "'use strict';",
    "function ", funcName, "(", args.join(), "){",
      "var ", vars.join(), ";",
      code.join(""),
    "}",
    "return ", funcName ].join("")

  var proc = new Function(
    "vertex", 
    "face", 
    "phase", 
    "mallocUint32", 
    "freeUint32",
    procedureCode)
  return proc(
    vertexFunc, 
    faceFunc, 
    phaseFunc, 
    pool.mallocUint32, 
    pool.freeUint32)
}

function createSurfaceExtractor(args) {
  function error(msg) {
    throw new Error("ndarray-extract-contour: " + msg)
  }
  if(typeof args !== "object") {
    error("Must specify arguments")
  }
  var order = args.order
  if(!Array.isArray(order)) {
    error("Must specify order")
  }
  var arrays = args.arrayArguments||1
  if(arrays < 1) {
    error("Must have at least one array argument")
  }
  var scalars = args.scalarArguments||0
  if(scalars < 0) {
    error("Scalar arg count must be > 0")
  }
  if(typeof args.vertex !== "function") {
    error("Must specify vertex creation function")
  }
  if(typeof args.cell !== "function") {
    error("Must specify cell creation function")
  }
  if(typeof args.phase !== "function") {
    error("Must specify phase function")
  }
  var getters = args.getters || []
  var typesig = new Array(arrays)
  for(var i=0; i<arrays; ++i) {
    if(getters.indexOf(i) >= 0) {
      typesig[i] = true
    } else {
      typesig[i] = false
    }
  }
  return compileSurfaceProcedure(
    args.vertex,
    args.cell,
    args.phase,
    scalars,
    order,
    typesig)
}
},{"typedarray-pool":139}],86:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":82,"is-buffer":83}],87:[function(require,module,exports){
"use strict"

var doubleBits = require("double-bits")

var SMALLEST_DENORM = Math.pow(2, -1074)
var UINT_MAX = (-1)>>>0

module.exports = nextafter

function nextafter(x, y) {
  if(isNaN(x) || isNaN(y)) {
    return NaN
  }
  if(x === y) {
    return x
  }
  if(x === 0) {
    if(y < 0) {
      return -SMALLEST_DENORM
    } else {
      return SMALLEST_DENORM
    }
  }
  var hi = doubleBits.hi(x)
  var lo = doubleBits.lo(x)
  if((y > x) === (x > 0)) {
    if(lo === UINT_MAX) {
      hi += 1
      lo = 0
    } else {
      lo += 1
    }
  } else {
    if(lo === 0) {
      lo = UINT_MAX
      hi -= 1
    } else {
      lo -= 1
    }
  }
  return doubleBits.pack(lo, hi)
}
},{"double-bits":42}],88:[function(require,module,exports){
(function (process){(function (){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this)}).call(this,require('_process'))

},{"_process":95}],89:[function(require,module,exports){
"use strict"

module.exports = permutationSign

var BRUTE_FORCE_CUTOFF = 32

var pool = require("typedarray-pool")

function permutationSign(p) {
  var n = p.length
  if(n < BRUTE_FORCE_CUTOFF) {
    //Use quadratic algorithm for small n
    var sgn = 1
    for(var i=0; i<n; ++i) {
      for(var j=0; j<i; ++j) {
        if(p[i] < p[j]) {
          sgn = -sgn
        } else if(p[i] === p[j]) {
          return 0
        }
      }
    }
    return sgn
  } else {
    //Otherwise use linear time algorithm
    var visited = pool.mallocUint8(n)
    for(var i=0; i<n; ++i) {
      visited[i] = 0
    }
    var sgn = 1
    for(var i=0; i<n; ++i) {
      if(!visited[i]) {
        var count = 1
        visited[i] = 1
        for(var j=p[i]; j!==i; j=p[j]) {
          if(visited[j]) {
            pool.freeUint8(visited)
            return 0
          }
          count += 1
          visited[j] = 1
        }
        if(!(count & 1)) {
          sgn = -sgn
        }
      }
    }
    pool.freeUint8(visited)
    return sgn
  }
}
},{"typedarray-pool":139}],90:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var inverse = require("invert-permutation")

function rank(permutation) {
  var n = permutation.length
  switch(n) {
    case 0:
    case 1:
      return 0
    case 2:
      return permutation[1]
    default:
      break
  }
  var p = pool.mallocUint32(n)
  var pinv = pool.mallocUint32(n)
  var r = 0, s, t, i
  inverse(permutation, pinv)
  for(i=0; i<n; ++i) {
    p[i] = permutation[i]
  }
  for(i=n-1; i>0; --i) {
    t = pinv[i]
    s = p[i]
    p[i] = p[t]
    p[t] = s
    pinv[i] = pinv[s]
    pinv[s] = t
    r = (r + s) * i
  }
  pool.freeUint32(pinv)
  pool.freeUint32(p)
  return r
}

function unrank(n, r, p) {
  switch(n) {
    case 0:
      if(p) { return p }
      return []
    case 1:
      if(p) {
        p[0] = 0
        return p
      } else {
        return [0]
      }
    case 2:
      if(p) {
        if(r) {
          p[0] = 0
          p[1] = 1
        } else {
          p[0] = 1
          p[1] = 0
        }
        return p
      } else {
        return r ? [0,1] : [1,0]
      }
    default:
      break
  }
  p = p || new Array(n)
  var s, t, i, nf=1
  p[0] = 0
  for(i=1; i<n; ++i) {
    p[i] = i
    nf = (nf*i)|0
  }
  for(i=n-1; i>0; --i) {
    s = (r / nf)|0
    r = (r - s * nf)|0
    nf = (nf / i)|0
    t = p[i]|0
    p[i] = p[s]|0
    p[s] = t|0
  }
  return p
}

exports.rank = rank
exports.unrank = unrank

},{"invert-permutation":81,"typedarray-pool":139}],91:[function(require,module,exports){
"use strict"

module.exports = planarDual

var compareAngle = require("compare-angle")

function planarDual(cells, positions) {

  var numVertices = positions.length|0
  var numEdges = cells.length
  var adj = [new Array(numVertices), new Array(numVertices)]
  for(var i=0; i<numVertices; ++i) {
    adj[0][i] = []
    adj[1][i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var c = cells[i]
    adj[0][c[0]].push(c)
    adj[1][c[1]].push(c)
  }

  var cycles = []

  //Add isolated vertices as trivial case
  for(var i=0; i<numVertices; ++i) {
    if(adj[0][i].length + adj[1][i].length === 0) {
      cycles.push( [i] )
    }
  }

  //Remove a half edge
  function cut(c, i) {
    var a = adj[i][c[i]]
    a.splice(a.indexOf(c), 1)
  }

  //Find next vertex and cut edge
  function next(a, b, noCut) {
    var nextCell, nextVertex, nextDir
    for(var i=0; i<2; ++i) {
      if(adj[i][b].length > 0) {
        nextCell = adj[i][b][0]
        nextDir = i
        break
      }
    }
    nextVertex = nextCell[nextDir^1]

    for(var dir=0; dir<2; ++dir) {
      var nbhd = adj[dir][b]
      for(var k=0; k<nbhd.length; ++k) {
        var e = nbhd[k]
        var p = e[dir^1]
        var cmp = compareAngle(
            positions[a], 
            positions[b], 
            positions[nextVertex],
            positions[p])
        if(cmp > 0) {
          nextCell = e
          nextVertex = p
          nextDir = dir
        }
      }
    }
    if(noCut) {
      return nextVertex
    }
    if(nextCell) {
      cut(nextCell, nextDir)
    }
    return nextVertex
  }

  function extractCycle(v, dir) {
    var e0 = adj[dir][v][0]
    var cycle = [v]
    cut(e0, dir)
    var u = e0[dir^1]
    var d0 = dir
    while(true) {
      while(u !== v) {
        cycle.push(u)
        u = next(cycle[cycle.length-2], u, false)
      }
      if(adj[0][v].length + adj[1][v].length === 0) {
        break
      }
      var a = cycle[cycle.length-1]
      var b = v
      var c = cycle[1]
      var d = next(a, b, true)
      if(compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {
        break
      }
      cycle.push(v)
      u = next(a, b)
    }
    return cycle
  }

  function shouldGlue(pcycle, ncycle) {
    return (ncycle[1] === ncycle[ncycle.length-1])
  }

  for(var i=0; i<numVertices; ++i) {
    for(var j=0; j<2; ++j) {
      var pcycle = []
      while(adj[j][i].length > 0) {
        var ni = adj[0][i].length
        var ncycle = extractCycle(i,j)
        if(shouldGlue(pcycle, ncycle)) {
          //Glue together trivial cycles
          pcycle.push.apply(pcycle, ncycle)
        } else {
          if(pcycle.length > 0) {
            cycles.push(pcycle)
          }
          pcycle = ncycle
        }
      }
      if(pcycle.length > 0) {
        cycles.push(pcycle)
      }
    }
  }

  //Combine paths and loops together
  return cycles
}
},{"compare-angle":38}],92:[function(require,module,exports){
'use strict'

module.exports = trimLeaves

var e2a = require('edges-to-adjacency-list')

function trimLeaves(edges, positions) {
  var adj = e2a(edges, positions.length)
  var live = new Array(positions.length)
  var nbhd = new Array(positions.length)

  var dead = []
  for(var i=0; i<positions.length; ++i) {
    var count = adj[i].length
    nbhd[i] = count
    live[i] = true
    if(count <= 1) {
      dead.push(i)
    }
  }

  while(dead.length > 0) {
    var v = dead.pop()
    live[v] = false
    var n = adj[v]
    for(var i=0; i<n.length; ++i) {
      var u = n[i]
      if(--nbhd[u] === 0) {
        dead.push(u)
      }
    }
  }

  var newIndex = new Array(positions.length)
  var npositions = []
  for(var i=0; i<positions.length; ++i) {
    if(live[i]) {
      var v = npositions.length
      newIndex[i] = v
      npositions.push(positions[i])
    } else {
      newIndex[i] = -1
    }
  }

  var nedges = []
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    if(live[e[0]] && live[e[1]]) {
      nedges.push([ newIndex[e[0]], newIndex[e[1]] ])
    }
  }
  
  return [ nedges, npositions ]
}
},{"edges-to-adjacency-list":44}],93:[function(require,module,exports){
'use strict'

module.exports = planarGraphToPolyline

var e2a = require('edges-to-adjacency-list')
var planarDual = require('planar-dual')
var preprocessPolygon = require('point-in-big-polygon')
var twoProduct = require('two-product')
var robustSum = require('robust-sum')
var uniq = require('uniq')
var trimLeaves = require('./lib/trim-leaves')

function makeArray(length, fill) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = fill
  }
  return result
}

function makeArrayOfArrays(length) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = []
  }
  return result
}


function planarGraphToPolyline(edges, positions) {

  //Trim leaves
  var result = trimLeaves(edges, positions)
  edges = result[0]
  positions = result[1]

  var numVertices = positions.length
  var numEdges = edges.length

  //Calculate adjacency list, check manifold
  var adj = e2a(edges, positions.length)
  for(var i=0; i<numVertices; ++i) {
    if(adj[i].length % 2 === 1) {
      throw new Error('planar-graph-to-polyline: graph must be manifold')
    }
  }

  //Get faces
  var faces = planarDual(edges, positions)

  //Check orientation of a polygon using exact arithmetic
  function ccw(c) {
    var n = c.length
    var area = [0]
    for(var j=0; j<n; ++j) {
      var a = positions[c[j]]
      var b = positions[c[(j+1)%n]]
      var t00 = twoProduct(-a[0], a[1])
      var t01 = twoProduct(-a[0], b[1])
      var t10 = twoProduct( b[0], a[1])
      var t11 = twoProduct( b[0], b[1])
      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))
    }
    return area[area.length-1] > 0
  }

  //Extract all clockwise faces
  faces = faces.filter(ccw)

  //Detect which loops are contained in one another to handle parent-of relation
  var numFaces = faces.length
  var parent = new Array(numFaces)
  var containment = new Array(numFaces)
  for(var i=0; i<numFaces; ++i) {
    parent[i] = i
    var row = new Array(numFaces)
    var loopVertices = faces[i].map(function(v) {
      return positions[v]
    })
    var pmc = preprocessPolygon([loopVertices])
    var count = 0
    outer:
    for(var j=0; j<numFaces; ++j) {
      row[j] = 0
      if(i === j) {
        continue
      }
      var c = faces[j]
      var n = c.length
      for(var k=0; k<n; ++k) {
        var d = pmc(positions[c[k]])
        if(d !== 0) {
          if(d < 0) {
            row[j] = 1
            count += 1
          }
          continue outer
        }
      }
      row[j] = 1
      count += 1
    }
    containment[i] = [count, i, row]
  }
  containment.sort(function(a,b) {
    return b[0] - a[0]
  })
  for(var i=0; i<numFaces; ++i) {
    var row = containment[i]
    var idx = row[1]
    var children = row[2]
    for(var j=0; j<numFaces; ++j) {
      if(children[j]) {
        parent[j] = idx
      }
    }
  }

  //Initialize face adjacency list
  var fadj = makeArrayOfArrays(numFaces)
  for(var i=0; i<numFaces; ++i) {
    fadj[i].push(parent[i])
    fadj[parent[i]].push(i)
  }

  //Build adjacency matrix for edges
  var edgeAdjacency = {}
  var internalVertices = makeArray(numVertices, false)
  for(var i=0; i<numFaces; ++i) {
    var c = faces[i]
    var n = c.length
    for(var j=0; j<n; ++j) {
      var a = c[j]
      var b = c[(j+1)%n]
      var key = Math.min(a,b) + ":" + Math.max(a,b)
      if(key in edgeAdjacency) {
        var neighbor = edgeAdjacency[key]
        fadj[neighbor].push(i)
        fadj[i].push(neighbor)
        internalVertices[a] = internalVertices[b] = true
      } else {
        edgeAdjacency[key] = i
      }
    }
  }

  function sharedBoundary(c) {
    var n = c.length
    for(var i=0; i<n; ++i) {
      if(!internalVertices[c[i]]) {
        return false
      }
    }
    return true
  }

  var toVisit = []
  var parity = makeArray(numFaces, -1)
  for(var i=0; i<numFaces; ++i) {
    if(parent[i] === i && !sharedBoundary(faces[i])) {
      toVisit.push(i)
      parity[i] = 0
    } else {
      parity[i] = -1
    }
  }

  //Using face adjacency, classify faces as in/out
  var result = []
  while(toVisit.length > 0) {
    var top = toVisit.pop()
    var nbhd = fadj[top]
    uniq(nbhd, function(a,b) {
      return a-b
    })
    var nnbhr = nbhd.length
    var p = parity[top]
    var polyline
    if(p === 0) {
      var c = faces[top]
      polyline = [c]
    }
    for(var i=0; i<nnbhr; ++i) {
      var f = nbhd[i]
      if(parity[f] >= 0) {
        continue
      }
      parity[f] = p^1
      toVisit.push(f)
      if(p === 0) {
        var c = faces[f]
        if(!sharedBoundary(c)) {
          c.reverse()
          polyline.push(c)
        }
      }
    }
    if(p === 0) {
      result.push(polyline)
    }
  }

  return result
}
},{"./lib/trim-leaves":92,"edges-to-adjacency-list":44,"planar-dual":91,"point-in-big-polygon":94,"robust-sum":110,"two-product":137,"uniq":141}],94:[function(require,module,exports){
module.exports = preprocessPolygon

var orient = require('robust-orientation')[3]
var makeSlabs = require('slab-decomposition')
var makeIntervalTree = require('interval-tree-1d')
var bsearch = require('binary-search-bounds')

function visitInterval() {
  return true
}

function intervalSearch(table) {
  return function(x, y) {
    var tree = table[x]
    if(tree) {
      return !!tree.queryPoint(y, visitInterval)
    }
    return false
  }
}

function buildVerticalIndex(segments) {
  var table = {}
  for(var i=0; i<segments.length; ++i) {
    var s = segments[i]
    var x = s[0][0]
    var y0 = s[0][1]
    var y1 = s[1][1]
    var p = [ Math.min(y0, y1), Math.max(y0, y1) ]
    if(x in table) {
      table[x].push(p)
    } else {
      table[x] = [ p ]
    }
  }
  var intervalTable = {}
  var keys = Object.keys(table)
  for(var i=0; i<keys.length; ++i) {
    var segs = table[keys[i]]
    intervalTable[keys[i]] = makeIntervalTree(segs)
  }
  return intervalSearch(intervalTable)
}

function buildSlabSearch(slabs, coordinates) {
  return function(p) {
    var bucket = bsearch.le(coordinates, p[0])
    if(bucket < 0) {
      return 1
    }
    var root = slabs[bucket]
    if(!root) {
      if(bucket > 0 && coordinates[bucket] === p[0]) {
        root = slabs[bucket-1]
      } else {
        return 1
      }
    }
    var lastOrientation = 1
    while(root) {
      var s = root.key
      var o = orient(p, s[0], s[1])
      if(s[0][0] < s[1][0]) {
        if(o < 0) {
          root = root.left
        } else if(o > 0) {
          lastOrientation = -1
          root = root.right
        } else {
          return 0
        }
      } else {
        if(o > 0) {
          root = root.left
        } else if(o < 0) {
          lastOrientation = 1
          root = root.right
        } else {
          return 0
        }
      }
    }
    return lastOrientation
  }
}

function classifyEmpty(p) {
  return 1
}

function createClassifyVertical(testVertical) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return 1
  }
}

function createClassifyPointDegen(testVertical, testNormal) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return testNormal(p)
  }
}

function preprocessPolygon(loops) {
  //Compute number of loops
  var numLoops = loops.length

  //Unpack segments
  var segments = []
  var vsegments = []
  var ptr = 0
  for(var i=0; i<numLoops; ++i) {
    var loop = loops[i]
    var numVertices = loop.length
    for(var s=numVertices-1,t=0; t<numVertices; s=(t++)) {
      var a = loop[s]
      var b = loop[t]
      if(a[0] === b[0]) {
        vsegments.push([a,b])
      } else {
        segments.push([a,b])
      }
    }
  }

  //Degenerate case: All loops are empty
  if(segments.length === 0) {
    if(vsegments.length === 0) {
      return classifyEmpty
    } else {
      return createClassifyVertical(buildVerticalIndex(vsegments))
    }
  }

  //Build slab decomposition
  var slabs = makeSlabs(segments)
  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates)

  if(vsegments.length === 0) {
    return testSlab
  } else {
    return createClassifyPointDegen(
      buildVerticalIndex(vsegments),
      testSlab)
  }
}
},{"binary-search-bounds":19,"interval-tree-1d":80,"robust-orientation":105,"slab-decomposition":117}],95:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],96:[function(require,module,exports){
var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter
var now = require('right-now')
var raf = require('raf')

module.exports = Engine
function Engine(fn) {
    if (!(this instanceof Engine)) 
        return new Engine(fn)
    this.running = false
    this.last = now()
    this._frame = 0
    this._tick = this.tick.bind(this)

    if (fn)
        this.on('tick', fn)
}

inherits(Engine, EventEmitter)

Engine.prototype.start = function() {
    if (this.running) 
        return
    this.running = true
    this.last = now()
    this._frame = raf(this._tick)
    return this
}

Engine.prototype.stop = function() {
    this.running = false
    if (this._frame !== 0)
        raf.cancel(this._frame)
    this._frame = 0
    return this
}

Engine.prototype.tick = function() {
    this._frame = raf(this._tick)
    var time = now()
    var dt = time - this.last
    this.emit('tick', dt)
    this.last = time
}
},{"events":29,"inherits":79,"raf":97,"right-now":103}],97:[function(require,module,exports){
(function (global){(function (){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":88}],98:[function(require,module,exports){
'use strict'

var bnadd = require('big-rat/add')

module.exports = add

function add (a, b) {
  var n = a.length
  var r = new Array(n)
  for (var i=0; i<n; ++i) {
    r[i] = bnadd(a[i], b[i])
  }
  return r
}

},{"big-rat/add":2}],99:[function(require,module,exports){
'use strict'

module.exports = float2rat

var rat = require('big-rat')

function float2rat(v) {
  var result = new Array(v.length)
  for(var i=0; i<v.length; ++i) {
    result[i] = rat(v[i])
  }
  return result
}

},{"big-rat":5}],100:[function(require,module,exports){
'use strict'

var rat = require('big-rat')
var mul = require('big-rat/mul')

module.exports = muls

function muls(a, x) {
  var s = rat(x)
  var n = a.length
  var r = new Array(n)
  for(var i=0; i<n; ++i) {
    r[i] = mul(a[i], s)
  }
  return r
}

},{"big-rat":5,"big-rat/mul":14}],101:[function(require,module,exports){
'use strict'

var bnsub = require('big-rat/sub')

module.exports = sub

function sub(a, b) {
  var n = a.length
  var r = new Array(n)
    for(var i=0; i<n; ++i) {
    r[i] = bnsub(a[i], b[i])
  }
  return r
}

},{"big-rat/sub":17}],102:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.createREGL = factory());
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map((y, i) => unbox(y, path + '[' + i + ']')))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
    extend(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])

      if (!limits.npotTextureCube) {
        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
      }

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              if (colorTexture) {
                check$1.oneOf(
                  options.colorFormat, colorTextureFormats,
                  'invalid color format for texture')
              } else {
                check$1.oneOf(
                  options.colorFormat, colorRenderbufferFormats,
                  'invalid color format for renderbuffer')
              }
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = this
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (attributes) {
      check$1(Array.isArray(attributes), 'arguments to vertex array constructor must be an array')
      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0
      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      if (extensions.oes_texture_float) {
        check$1(
          type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
          'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

        if (type === GL_FLOAT$7) {
          check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
        }
      } else {
        check$1(
          type === GL_UNSIGNED_BYTE$7,
          'Reading from a framebuffer is only allowed for the type \'uint8\'')
      }
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        if (isBufferArgs(elements)) {
          elements = elementState.getElements(elementState.create(elements, true))
        } else if (elements) {
          elements = elementState.getElements(elements)
          check$1.command(elements, 'invalid elements', env.commandStr)
        }
        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      }

      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset && elements) {
        return createStaticDecl(function (env, scope) {
          env.OFFSET = '0'
          return 0
        })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      }
      return null
    }

    return {
      elements: elements,
      primitive: parsePrimitive(),
      count: parseVertCount(),
      instances: parseParam(S_INSTANCES, false),
      offset: OFFSET
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            if ('divisor' in value) {
              check$1.command(divisor === 0 || extInstancing,
                'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
              check$1.command(divisor >= 0,
                'invalid divisor for attribute "' + attribute + '"', env.commandStr)
            }

            check$1.optional(function () {
              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseVAO (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic
    if (S_VAO in staticOptions) {
      var vao = staticOptions[S_VAO]
      if (vao !== null && attributeState.getVAO(vao) === null) {
        vao = attributeState.createVAO(vao)
      }
      return createStaticDecl(function (env) {
        return env.link(attributeState.getVAO(vao))
      })
    } else if (S_VAO in dynamicOptions) {
      var dyn = dynamicOptions[S_VAO]
      return createDynamicDecl(dyn, function (env, scope) {
        var vaoRef = env.invoke(scope, dyn)
        return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
      })
    }
    return null
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = parseVAO(options, env)
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO(staticBindings))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      scope(GL, '.uniform', infix, '(', LOCATION, ',')
      if (infix.charAt(0) === 'M') {
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
      } else if (unroll > 1) {
        scope(loop(unroll, function (i) {
          return Array.isArray(VALUE) ? VALUE[i] : VALUE + '[' + i + ']'
        }))
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        scope(VALUE)
      }
      scope(');')
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
      } else {
        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS)
      }
      if (ELEMENTS) {
        scope(
          'if(' + ELEMENTS + ')' +
          GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements)

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    })
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()
    attributeState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));


},{}],103:[function(require,module,exports){
(function (global){(function (){
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],104:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustDiff = require("robust-subtract")
var robustScale = require("robust-scale")

var NUM_EXPAND = 6

function orientation(n) {
  var fn =
    n === 3 ? inSphere3 :
    n === 4 ? inSphere4 :
    n === 5 ? inSphere5 : inSphere6;

  return fn(robustSum, robustDiff, twoProduct, robustScale)
}

function inSphere0() { return 0 }
function inSphere1() { return 0 }
function inSphere2() { return 0 }

function inSphere3(sum, diff, prod, scale) {
  function exactInSphere3(m0, m1, m2) {
    var w0 = prod(m0[0], m0[0])
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w1 = prod(m1[0], m1[0])
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w2 = prod(m2[0], m2[0])
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var p = sum(diff(w2m1, w1m2), diff(w1m0, w0m1))
    var n = diff(w2m0, w0m2)
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere3
}

function inSphere4(sum, diff, prod, scale) {
  function exactInSphere4(m0, m1, m2, m3) {
    var w0 = sum(prod(m0[0], m0[0]), prod(m0[1], m0[1]))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w1 = sum(prod(m1[0], m1[0]), prod(m1[1], m1[1]))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w2 = sum(prod(m2[0], m2[0]), prod(m2[1], m2[1]))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w3 = sum(prod(m3[0], m3[0]), prod(m3[1], m3[1]))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var p = sum(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))))
    var n = sum(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere4
}


function inSphere5(sum, diff, prod, scale) {
  function exactInSphere5(m0, m1, m2, m3, m4) {
    var w0 = sum(prod(m0[0], m0[0]), sum(prod(m0[1], m0[1]), prod(m0[2], m0[2])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w1 = sum(prod(m1[0], m1[0]), sum(prod(m1[1], m1[1]), prod(m1[2], m1[2])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w2 = sum(prod(m2[0], m2[0]), sum(prod(m2[1], m2[1]), prod(m2[2], m2[2])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w3 = sum(prod(m3[0], m3[0]), sum(prod(m3[1], m3[1]), prod(m3[2], m3[2])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w4 = sum(prod(m4[0], m4[0]), sum(prod(m4[1], m4[1]), prod(m4[2], m4[2])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var p = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])))), sum(sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2])))))
    var n = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }

    return exactInSphere5
}

function inSphere6(sum, diff, prod, scale) {
  function exactInSphere6(m0, m1, m2, m3, m4, m5) {
    var w0 = sum(sum(prod(m0[0], m0[0]), prod(m0[1], m0[1])), sum(prod(m0[2], m0[2]), prod(m0[3], m0[3])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w0m5 = scale(w0, m5[0])
    var w1 = sum(sum(prod(m1[0], m1[0]), prod(m1[1], m1[1])), sum(prod(m1[2], m1[2]), prod(m1[3], m1[3])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w1m5 = scale(w1, m5[0])
    var w2 = sum(sum(prod(m2[0], m2[0]), prod(m2[1], m2[1])), sum(prod(m2[2], m2[2]), prod(m2[3], m2[3])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w2m5 = scale(w2, m5[0])
    var w3 = sum(sum(prod(m3[0], m3[0]), prod(m3[1], m3[1])), sum(prod(m3[2], m3[2]), prod(m3[3], m3[3])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w3m5 = scale(w3, m5[0])
    var w4 = sum(sum(prod(m4[0], m4[0]), prod(m4[1], m4[1])), sum(prod(m4[2], m4[2]), prod(m4[3], m4[3])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var w4m5 = scale(w4, m5[0])
    var w5 = sum(sum(prod(m5[0], m5[0]), prod(m5[1], m5[1])), sum(prod(m5[2], m5[2]), prod(m5[3], m5[3])))
    var w5m0 = scale(w5, m0[0])
    var w5m1 = scale(w5, m1[0])
    var w5m2 = scale(w5, m2[0])
    var w5m3 = scale(w5, m3[0])
    var w5m4 = scale(w5, m4[0])
    var p = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m1[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m3[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m5[3])))))
    var n = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m0[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m4[3])))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere6
}

var CACHED = [
  inSphere0,
  inSphere1,
  inSphere2
]

function slowInSphere(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc(slow, o0, o1, o2, o3, o4, o5, o6) {
  function testInSphere(a0, a1, a2, a3, a4, a5) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
      case 6:
        return o6(a0, a1, a2, a3, a4, a5)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
  return testInSphere
}

function generateInSphereTest() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }

  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateInSphereTest()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":137}],105:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function orientation_3(sum, prod, scale, sub) {
  return function orientation3Exact(m0, m1, m2) {
    var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])))
    var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_4(sum, prod, scale, sub) {
  return function orientation4Exact(m0, m1, m2, m3) {
    var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))))
    var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_5(sum, prod, scale, sub) {
  return function orientation5Exact(m0, m1, m2, m3, m4) {
    var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))))
    var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation(n) {
  var fn =
    n === 3 ? orientation_3 :
    n === 4 ? orientation_4 : orientation_5

  return fn(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) {
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy)
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc (slow, o0, o1, o2, o3, o4, o5) {
  return function getOrientation(a0, a1, a2, a3, a4) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":137}],106:[function(require,module,exports){
"use strict"

var robustSum = require("robust-sum")
var robustScale = require("robust-scale")

module.exports = robustProduct

function robustProduct(a, b) {
  if(a.length === 1) {
    return robustScale(b, a[0])
  }
  if(b.length === 1) {
    return robustScale(a, b[0])
  }
  if(a.length === 0 || b.length === 0) {
    return [0]
  }
  var r = [0]
  if(a.length < b.length) {
    for(var i=0; i<a.length; ++i) {
      r = robustSum(r, robustScale(b, a[i]))
    }
  } else {
    for(var i=0; i<b.length; ++i) {
      r = robustSum(r, robustScale(a, b[i]))
    }    
  }
  return r
}
},{"robust-scale":107,"robust-sum":110}],107:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":137,"two-sum":138}],108:[function(require,module,exports){
"use strict"

module.exports = segmentsIntersect

var orient = require("robust-orientation")[3]

function checkCollinear(a0, a1, b0, b1) {

  for(var d=0; d<2; ++d) {
    var x0 = a0[d]
    var y0 = a1[d]
    var l0 = Math.min(x0, y0)
    var h0 = Math.max(x0, y0)    

    var x1 = b0[d]
    var y1 = b1[d]
    var l1 = Math.min(x1, y1)
    var h1 = Math.max(x1, y1)    

    if(h1 < l0 || h0 < l1) {
      return false
    }
  }

  return true
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1)
  var y0 = orient(a1, b0, b1)
  if((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {
    return false
  }

  var x1 = orient(b0, a0, a1)
  var y1 = orient(b1, a0, a1)
  if((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {
    return false
  }

  //Check for degenerate collinear case
  if(x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1)
  }

  return true
}
},{"robust-orientation":105}],109:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],110:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],111:[function(require,module,exports){
"use strict"

module.exports = function signum(x) {
  if(x < 0) { return -1 }
  if(x > 0) { return 1 }
  return 0.0
}
},{}],112:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],113:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

UnionFind.prototype.length = function() {
  return this.roots.length;
}

UnionFind.prototype.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

UnionFind.prototype.find = function(x) {
  var roots = this.roots;
  while(roots[x] !== x) {
    var y = roots[x];
    roots[x] = roots[y];
    x = y;
  }
  return x;
}

UnionFind.prototype.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}


},{}],114:[function(require,module,exports){
"use strict"; "use restrict";

var bits      = require("bit-twiddle")
  , UnionFind = require("union-find")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents

},{"bit-twiddle":112,"union-find":113}],115:[function(require,module,exports){
"use strict"

module.exports = simplifyPolygon

var orient = require("robust-orientation")
var sc = require("simplicial-complex")

function errorWeight(base, a, b) {
  var area = Math.abs(orient(base, a, b))
  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))
  return area / perim
}

function simplifyPolygon(cells, positions, minArea) {

  var n = positions.length
  var nc = cells.length
  var inv = new Array(n)
  var outv = new Array(n)
  var weights = new Array(n)
  var dead = new Array(n)
  
  //Initialize tables
  for(var i=0; i<n; ++i) {
    inv[i] = outv[i] = -1
    weights[i] = Infinity
    dead[i] = false
  }

  //Compute neighbors
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.length !== 2) {
      throw new Error("Input must be a graph")
    }
    var s = c[1]
    var t = c[0]
    if(outv[t] !== -1) {
      outv[t] = -2
    } else {
      outv[t] = s
    }
    if(inv[s] !== -1) {
      inv[s] = -2
    } else {
      inv[s] = t
    }
  }

  //Updates the weight for vertex i
  function computeWeight(i) {
    if(dead[i]) {
      return Infinity
    }
    //TODO: Check that the line segment doesn't cross once simplified
    var s = inv[i]
    var t = outv[i]
    if((s<0) || (t<0)) {
      return Infinity
    } else {
      return errorWeight(positions[i], positions[s], positions[t])
    }
  }

  //Swaps two nodes on the heap (i,j) are the index of the nodes
  function heapSwap(i,j) {
    var a = heap[i]
    var b = heap[j]
    heap[i] = b
    heap[j] = a
    index[a] = j
    index[b] = i
  }

  //Returns the weight of node i on the heap
  function heapWeight(i) {
    return weights[heap[i]]
  }

  function heapParent(i) {
    if(i & 1) {
      return (i - 1) >> 1
    }
    return (i >> 1) - 1
  }

  //Bubble element i down the heap
  function heapDown(i) {
    var w = heapWeight(i)
    while(true) {
      var tw = w
      var left  = 2*i + 1
      var right = 2*(i + 1)
      var next = i
      if(left < heapCount) {
        var lw = heapWeight(left)
        if(lw < tw) {
          next = left
          tw = lw
        }
      }
      if(right < heapCount) {
        var rw = heapWeight(right)
        if(rw < tw) {
          next = right
        }
      }
      if(next === i) {
        return i
      }
      heapSwap(i, next)
      i = next      
    }
  }

  //Bubbles element i up the heap
  function heapUp(i) {
    var w = heapWeight(i)
    while(i > 0) {
      var parent = heapParent(i)
      if(parent >= 0) {
        var pw = heapWeight(parent)
        if(w < pw) {
          heapSwap(i, parent)
          i = parent
          continue
        }
      }
      return i
    }
  }

  //Pop minimum element
  function heapPop() {
    if(heapCount > 0) {
      var head = heap[0]
      heapSwap(0, heapCount-1)
      heapCount -= 1
      heapDown(0)
      return head
    }
    return -1
  }

  //Update heap item i
  function heapUpdate(i, w) {
    var a = heap[i]
    if(weights[a] === w) {
      return i
    }
    weights[a] = -Infinity
    heapUp(i)
    heapPop()
    weights[a] = w
    heapCount += 1
    return heapUp(heapCount-1)
  }

  //Kills a vertex (assume vertex already removed from heap)
  function kill(i) {
    if(dead[i]) {
      return
    }
    //Kill vertex
    dead[i] = true
    //Fixup topology
    var s = inv[i]
    var t = outv[i]
    if(inv[t] >= 0) {
      inv[t] = s
    }
    if(outv[s] >= 0) {
      outv[s] = t
    }

    //Update weights on s and t
    if(index[s] >= 0) {
      heapUpdate(index[s], computeWeight(s))
    }
    if(index[t] >= 0) {
      heapUpdate(index[t], computeWeight(t))
    }
  }

  //Initialize weights and heap
  var heap = []
  var index = new Array(n)
  for(var i=0; i<n; ++i) {
    var w = weights[i] = computeWeight(i)
    if(w < Infinity) {
      index[i] = heap.length
      heap.push(i)
    } else {
      index[i] = -1
    }
  }
  var heapCount = heap.length
  for(var i=heapCount>>1; i>=0; --i) {
    heapDown(i)
  }
  
  //Kill vertices
  while(true) {
    var hmin = heapPop()
    if((hmin < 0) || (weights[hmin] > minArea)) {
      break
    }
    kill(hmin)
  }

  //Build collapsed vertex table
  var npositions = []
  for(var i=0; i<n; ++i) {
    if(!dead[i]) {
      index[i] = npositions.length
      npositions.push(positions[i].slice())
    }
  }
  var nv = npositions.length

  function tortoiseHare(seq, start) {
    if(seq[start] < 0) {
      return start
    }
    var t = start
    var h = start
    do {
      //Walk two steps with h
      var nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh
      nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh

      //Walk one step with t
      t = seq[t]
    } while(t !== h)
    //Compress cycles
    for(var v=start; v!==h; v = seq[v]) {
      seq[v] = h
    }
    return h
  }

  var ncells = []
  cells.forEach(function(c) {
    var tin = tortoiseHare(inv, c[0])
    var tout = tortoiseHare(outv, c[1])
    if(tin >= 0 && tout >= 0 && tin !== tout) {
      var cin = index[tin]
      var cout = index[tout]
      if(cin !== cout) {
        ncells.push([ cin, cout ])
      }
    }
  })

  //Normalize result
  sc.unique(sc.normalize(ncells))

  //Return final list of cells
  return {
    positions: npositions,
    edges: ncells
  }
}
},{"robust-orientation":105,"simplicial-complex":114}],116:[function(require,module,exports){
"use strict"

module.exports = orderSegments

var orient = require("robust-orientation")

function horizontalOrder(a, b) {
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    var alo = Math.min(a[0][1], a[1][1])
    var ahi = Math.max(a[0][1], a[1][1])
    var blo = Math.min(b[0][1], b[1][1])
    var bhi = Math.max(b[0][1], b[1][1])
    if(ahi < blo) {
      return ahi - blo
    }
    if(alo > bhi) {
      return alo - bhi
    }
    return ahi - bhi
  }
  var al, ar
  if(a[0][1] < a[1][1]) {
    al = a[0]
    ar = a[1]
  } else {
    al = a[1]
    ar = a[0]
  }
  var d = orient(br, bl, al)
  if(d) {
    return d
  }
  d = orient(br, bl, ar)
  if(d) {
    return d
  }
  return ar - br
}

function orderSegments(b, a) {
  var al, ar
  if(a[0][0] < a[1][0]) {
    al = a[0]
    ar = a[1]
  } else if(a[0][0] > a[1][0]) {
    al = a[1]
    ar = a[0]
  } else {
    return horizontalOrder(a, b)
  }
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    return -horizontalOrder(b, a)
  }
  var d1 = orient(al, ar, br)
  var d2 = orient(al, ar, bl)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  d1 = orient(br, bl, ar)
  d2 = orient(br, bl, al)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  return ar[0] - br[0]
}
},{"robust-orientation":105}],117:[function(require,module,exports){
"use strict"

module.exports = createSlabDecomposition

var bounds = require("binary-search-bounds")
var createRBTree = require("functional-red-black-tree")
var orient = require("robust-orientation")
var orderSegments = require("./lib/order-segments")

function SlabDecomposition(slabs, coordinates, horizontal) {
  this.slabs = slabs
  this.coordinates = coordinates
  this.horizontal = horizontal
}

var proto = SlabDecomposition.prototype

function compareHorizontal(e, y) {
  return e.y - y
}

function searchBucket(root, p) {
  var lastNode = null
  while(root) {
    var seg = root.key
    var l, r
    if(seg[0][0] < seg[1][0]) {
      l = seg[0]
      r = seg[1]
    } else {
      l = seg[1]
      r = seg[0]
    }
    var o = orient(l, r, p)
    if(o < 0) {
      root = root.left
    } else if(o > 0) {
      if(p[0] !== seg[1][0]) {
        lastNode = root
        root = root.right
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    } else {
      if(p[0] !== seg[1][0]) {
        return root
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    }
  }
  return lastNode
}

proto.castUp = function(p) {
  var bucket = bounds.le(this.coordinates, p[0])
  if(bucket < 0) {
    return -1
  }
  var root = this.slabs[bucket]
  var hitNode = searchBucket(this.slabs[bucket], p)
  var lastHit = -1
  if(hitNode) {
    lastHit = hitNode.value
  }
  //Edge case: need to handle horizontal segments (sucks)
  if(this.coordinates[bucket] === p[0]) {
    var lastSegment = null
    if(hitNode) {
      lastSegment = hitNode.key
    }
    if(bucket > 0) {
      var otherHitNode = searchBucket(this.slabs[bucket-1], p)
      if(otherHitNode) {
        if(lastSegment) {
          if(orderSegments(otherHitNode.key, lastSegment) > 0) {
            lastSegment = otherHitNode.key
            lastHit = otherHitNode.value
          }
        } else {
          lastHit = otherHitNode.value
          lastSegment = otherHitNode.key
        }
      }
    }
    var horiz = this.horizontal[bucket]
    if(horiz.length > 0) {
      var hbucket = bounds.ge(horiz, p[1], compareHorizontal)
      if(hbucket < horiz.length) {
        var e = horiz[hbucket]
        if(p[1] === e.y) {
          if(e.closed) {
            return e.index
          } else {
            while(hbucket < horiz.length-1 && horiz[hbucket+1].y === p[1]) {
              hbucket = hbucket+1
              e = horiz[hbucket]
              if(e.closed) {
                return e.index
              }
            }
            if(e.y === p[1] && !e.start) {
              hbucket = hbucket+1
              if(hbucket >= horiz.length) {
                return lastHit
              }
              e = horiz[hbucket]
            }
          }
        }
        //Check if e is above/below last segment
        if(e.start) {
          if(lastSegment) {
            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y])
            if(lastSegment[0][0] > lastSegment[1][0]) {
              o = -o
            }
            if(o > 0) {
              lastHit = e.index
            }
          } else {
            lastHit = e.index
          }
        } else if(e.y !== p[1]) {
          lastHit = e.index
        }
      }
    }
  }
  return lastHit
}

function IntervalSegment(y, index, start, closed) {
  this.y = y
  this.index = index
  this.start = start
  this.closed = closed
}

function Event(x, segment, create, index) {
  this.x = x
  this.segment = segment
  this.create = create
  this.index = index
}


function createSlabDecomposition(segments) {
  var numSegments = segments.length
  var numEvents = 2 * numSegments
  var events = new Array(numEvents)
  for(var i=0; i<numSegments; ++i) {
    var s = segments[i]
    var f = s[0][0] < s[1][0]
    events[2*i] = new Event(s[0][0], s, f, i)
    events[2*i+1] = new Event(s[1][0], s, !f, i)
  }
  events.sort(function(a,b) {
    var d = a.x - b.x
    if(d) {
      return d
    }
    d = a.create - b.create
    if(d) {
      return d
    }
    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1])
  })
  var tree = createRBTree(orderSegments)
  var slabs = []
  var lines = []
  var horizontal = []
  var lastX = -Infinity
  for(var i=0; i<numEvents; ) {
    var x = events[i].x
    var horiz = []
    while(i < numEvents) {
      var e = events[i]
      if(e.x !== x) {
        break
      }
      i += 1
      if(e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
        if(e.create) {
          if(e.segment[0][1] < e.segment[1][1]) {
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                true,
                true))
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                false,
                false))
          } else {
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                true,
                false))
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                false,
                true))
          }
        }
      } else {
        if(e.create) {
          tree = tree.insert(e.segment, e.index)
        } else {
          tree = tree.remove(e.segment)
        }
      }
    }
    slabs.push(tree.root)
    lines.push(x)
    horizontal.push(horiz)
  }
  return new SlabDecomposition(slabs, lines, horizontal)
}
},{"./lib/order-segments":116,"binary-search-bounds":19,"functional-red-black-tree":45,"robust-orientation":105}],118:[function(require,module,exports){
"use strict"

module.exports = surfaceNets

var generateContourExtractor = require("ndarray-extract-contour")
var triangulateCube = require("triangulate-hypercube")
var zeroCrossings = require("zero-crossings")

function buildSurfaceNets(order, dtype) {
  var dimension = order.length
  var code = ["'use strict';"]
  var funcName = "surfaceNets" + order.join("_") + "d" + dtype

  //Contour extraction function
  code.push(
    "var contour=genContour({",
      "order:[", order.join(), "],",
      "scalarArguments: 3,",
      "phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },")
  if(dtype === "generic") {
    code.push("getters:[0],")
  }

  //Generate vertex function
  var cubeArgs = []
  var extraArgs = []
  for(var i=0; i<dimension; ++i) {
    cubeArgs.push("d" + i)
    extraArgs.push("d" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("v" + i)
    extraArgs.push("v" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("p" + i)
    extraArgs.push("p" + i)
  }
  cubeArgs.push("a", "b", "c")
  extraArgs.push("a", "c")
  code.push("vertex:function vertexFunc(", cubeArgs.join(), "){")
  //Mask args together
  var maskStr = []
  for(var i=0; i<(1<<dimension); ++i) {
    maskStr.push("(p" + i + "<<" + i + ")")
  }
  //Generate variables and giganto switch statement
  code.push("var m=(", maskStr.join("+"), ")|0;if(m===0||m===", (1<<(1<<dimension))-1, "){return}")
  var extraFuncs = []
  var currentFunc = []
  if(1<<(1<<dimension) <= 128) {
    code.push("switch(m){")
    currentFunc = code
  } else {
    code.push("switch(m>>>7){")
  }
  for(var i=0; i<1<<(1<<dimension); ++i) {
    if(1<<(1<<dimension) > 128) {
      if((i%128)===0) {
        if(extraFuncs.length > 0) {
          currentFunc.push("}}")
        }
        var efName = "vExtra" + extraFuncs.length
        code.push("case ", (i>>>7), ":", efName, "(m&0x7f,", extraArgs.join(), ");break;")
        currentFunc = [
          "function ", efName, "(m,", extraArgs.join(), "){switch(m){"
        ]
        extraFuncs.push(currentFunc)
      }  
    }
    currentFunc.push("case ", (i&0x7f), ":")
    var crossings = new Array(dimension)
    var denoms = new Array(dimension)
    var crossingCount = new Array(dimension)
    var bias = new Array(dimension)
    var totalCrossings = 0
    for(var j=0; j<dimension; ++j) {
      crossings[j] = []
      denoms[j] = []
      crossingCount[j] = 0
      bias[j] = 0
    }
    for(var j=0; j<(1<<dimension); ++j) {
      for(var k=0; k<dimension; ++k) {
        var u = j ^ (1<<k)
        if(u > j) {
          continue
        }
        if(!(i&(1<<u)) !== !(i&(1<<j))) {
          var sign = 1
          if(i&(1<<u)) {
            denoms[k].push("v" + u + "-v" + j)
          } else {
            denoms[k].push("v" + j + "-v" + u)
            sign = -sign
          }
          if(sign < 0) {
            crossings[k].push("-v" + j + "-v" + u)
            crossingCount[k] += 2
          } else {
            crossings[k].push("v" + j + "+v" + u)
            crossingCount[k] -= 2            
          }
          totalCrossings += 1
          for(var l=0; l<dimension; ++l) {
            if(l === k) {
              continue
            }
            if(u&(1<<l)) {
              bias[l] += 1
            } else {
              bias[l] -= 1
            }
          }
        }
      }
    }
    var vertexStr = []
    for(var k=0; k<dimension; ++k) {
      if(crossings[k].length === 0) {
        vertexStr.push("d" + k + "-0.5")
      } else {
        var cStr = ""
        if(crossingCount[k] < 0) {
          cStr = crossingCount[k] + "*c"
        } else if(crossingCount[k] > 0) {
          cStr = "+" + crossingCount[k] + "*c"
        }
        var weight = 0.5 * (crossings[k].length / totalCrossings)
        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings)
        vertexStr.push("d" + k + "-" + shift + "-" + weight + "*(" + crossings[k].join("+") + cStr + ")/(" + denoms[k].join("+") + ")")
        
      }
    }
    currentFunc.push("a.push([", vertexStr.join(), "]);",
      "break;")
  }
  code.push("}},")
  if(extraFuncs.length > 0) {
    currentFunc.push("}}")
  }

  //Create face function
  var faceArgs = []
  for(var i=0; i<(1<<(dimension-1)); ++i) {
    faceArgs.push("v" + i)
  }
  faceArgs.push("c0", "c1", "p0", "p1", "a", "b", "c")
  code.push("cell:function cellFunc(", faceArgs.join(), "){")

  var facets = triangulateCube(dimension-1)
  code.push("if(p0){b.push(",
    facets.map(function(f) {
      return "[" + f.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(), ")}else{b.push(",
    facets.map(function(f) {
      var e = f.slice()
      e.reverse()
      return "[" + e.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(),
    ")}}});function ", funcName, "(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return ", funcName, ";")

  for(var i=0; i<extraFuncs.length; ++i) {
    code.push(extraFuncs[i].join(""))
  }

  //Compile and link
  var proc = new Function("genContour", code.join(""))
  return proc(generateContourExtractor)
}

//1D case: Need to handle specially
function mesh1D(array, level) {
  var zc = zeroCrossings(array, level)
  var n = zc.length
  var npos = new Array(n)
  var ncel = new Array(n)
  for(var i=0; i<n; ++i) {
    npos[i] = [ zc[i] ]
    ncel[i] = [ i ]
  }
  return {
    positions: npos,
    cells: ncel
  }
}

var CACHE = {}

function surfaceNets(array,level) {
  if(array.dimension <= 0) {
    return { positions: [], cells: [] }
  } else if(array.dimension === 1) {
    return mesh1D(array, level)
  }
  var typesig = array.order.join() + "-" + array.dtype
  var proc = CACHE[typesig]
  var level = (+level) || 0.0
  if(!proc) {
    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype)
  }
  return proc(array,level)
}
},{"ndarray-extract-contour":85,"triangulate-hypercube":136,"zero-crossings":145}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LinearDisplayP3ColorSpace = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.FrontSide = exports.FloatType = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DisplayP3ColorSpace = exports.DepthStencilFormat = exports.DepthFormat = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.ByteType = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.sRGBEncoding = exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WebGPUCoordinateSystem = exports.WebGLCoordinateSystem = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UVMapping = exports.TwoPassDoubleSide = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.ShortType = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = void 0;
const REVISION = '156';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const TwoPassDoubleSide = 2; // r149

exports.TwoPassDoubleSide = TwoPassDoubleSide;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const RGB_BPTC_SIGNED_Format = 36494;
exports.RGB_BPTC_SIGNED_Format = RGB_BPTC_SIGNED_Format;
const RGB_BPTC_UNSIGNED_Format = 36495;
exports.RGB_BPTC_UNSIGNED_Format = RGB_BPTC_UNSIGNED_Format;
const RED_RGTC1_Format = 36283;
exports.RED_RGTC1_Format = RED_RGTC1_Format;
const SIGNED_RED_RGTC1_Format = 36284;
exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
const RED_GREEN_RGTC2_Format = 36285;
exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */

exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
/** @deprecated Use SRGBColorSpace in three.js r152+. */

exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const NoColorSpace = '';
exports.NoColorSpace = NoColorSpace;
const SRGBColorSpace = 'srgb';
exports.SRGBColorSpace = SRGBColorSpace;
const LinearSRGBColorSpace = 'srgb-linear';
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
const DisplayP3ColorSpace = 'display-p3';
exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
const LinearDisplayP3ColorSpace = 'display-p3-linear';
exports.LinearDisplayP3ColorSpace = LinearDisplayP3ColorSpace;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const NeverCompare = 512;
exports.NeverCompare = NeverCompare;
const LessCompare = 513;
exports.LessCompare = LessCompare;
const EqualCompare = 514;
exports.EqualCompare = EqualCompare;
const LessEqualCompare = 515;
exports.LessEqualCompare = LessEqualCompare;
const GreaterCompare = 516;
exports.GreaterCompare = GreaterCompare;
const NotEqualCompare = 517;
exports.NotEqualCompare = NotEqualCompare;
const GreaterEqualCompare = 518;
exports.GreaterEqualCompare = GreaterEqualCompare;
const AlwaysCompare = 519;
exports.AlwaysCompare = AlwaysCompare;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';
exports.GLSL3 = GLSL3;
const _SRGBAFormat = 1035; // fallback for WebGL 1

exports._SRGBAFormat = _SRGBAFormat;
const WebGLCoordinateSystem = 2000;
exports.WebGLCoordinateSystem = WebGLCoordinateSystem;
const WebGPUCoordinateSystem = 2001;
exports.WebGPUCoordinateSystem = WebGPUCoordinateSystem;

},{}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.BufferAttribute = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _MathUtils = require("../math/MathUtils.js");

var _constants = require("../constants.js");

var _DataUtils = require("../extras/DataUtils.js");

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _vector2 = /*@__PURE__*/new _Vector2.Vector2();

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = _constants.StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.gpuType = _constants.FloatType;
    this.version = 0;
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  copyArray(array) {
    this.array.set(array);
    return this;
  }

  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);

        _vector2.applyMatrix3(m);

        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector.fromBufferAttribute(this, i);

        _vector.applyMatrix3(m);

        this.setXYZ(i, _vector.x, _vector.y, _vector.z);
      }
    }

    return this;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyMatrix4(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyNormalMatrix(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.transformDirection(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  set(value, offset = 0) {
    // Matching BufferAttribute constructor, do not normalize the array.
    this.array.set(value, offset);
    return this;
  }

  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = (0, _MathUtils.denormalize)(value, this.array);
    return value;
  }

  setComponent(index, component, value) {
    if (this.normalized) value = (0, _MathUtils.normalize)(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }

  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }

  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }

  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }

  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }

  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== '') data.name = this.name;
    if (this.usage !== _constants.StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }

} //


exports.BufferAttribute = BufferAttribute;

class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }

}

exports.Int8BufferAttribute = Int8BufferAttribute;

class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }

}

exports.Uint8BufferAttribute = Uint8BufferAttribute;

class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }

}

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }

}

exports.Int16BufferAttribute = Int16BufferAttribute;

class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Uint16BufferAttribute = Uint16BufferAttribute;

class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }

}

exports.Int32BufferAttribute = Int32BufferAttribute;

class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }

}

exports.Uint32BufferAttribute = Uint32BufferAttribute;

class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }

  getX(index) {
    let x = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize]);
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = (0, _DataUtils.toHalfFloat)(x);
    return this;
  }

  getY(index) {
    let y = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  getZ(index) {
    let z = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  getW(index) {
    let w = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    this.array[index + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

}

exports.Float16BufferAttribute = Float16BufferAttribute;

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }

}

exports.Float32BufferAttribute = Float32BufferAttribute;

class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }

} //


exports.Float64BufferAttribute = Float64BufferAttribute;

},{"../constants.js":119,"../extras/DataUtils.js":125,"../math/MathUtils.js":128,"../math/Vector2.js":133,"../math/Vector3.js":134}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferGeometry = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _Box = require("../math/Box3.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _BufferAttribute = require("./BufferAttribute.js");

var _Sphere = require("../math/Sphere.js");

var _Object3D = require("./Object3D.js");

var _Matrix = require("../math/Matrix4.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _utils = require("../utils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _id = 0;

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _obj = /*@__PURE__*/new _Object3D.Object3D();

const _offset = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new _Box.Box3();

const _boxMorphTargets = /*@__PURE__*/new _Box.Box3();

const _vector = /*@__PURE__*/new _Vector.Vector3();

class BufferGeometry extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, 'id', {
      value: _id++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new ((0, _utils.arrayNeedsUint32)(index) ? _BufferAttribute.Uint32BufferAttribute : _BufferAttribute.Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }

  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }

  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  }

  clearGroups() {
    this.groups = [];
  }

  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }

  applyMatrix4(matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new _Matrix2.Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  }

  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  }

  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }

  setFromPoints(points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(position, 3));
    return this;
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new _Box.Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new _Vector.Vector3(-Infinity, -Infinity, -Infinity), new _Vector.Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(this.boundingBox.min, _box.min);

            this.boundingBox.expandByPoint(_vector);

            _vector.addVectors(this.boundingBox.max, _box.max);

            this.boundingBox.expandByPoint(_vector);
          } else {
            this.boundingBox.expandByPoint(_box.min);
            this.boundingBox.expandByPoint(_box.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new _Sphere.Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new _Vector.Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(_box.min, _boxMorphTargets.min);

            _box.expandByPoint(_vector);

            _vector.addVectors(_box.max, _boxMorphTargets.max);

            _box.expandByPoint(_vector);
          } else {
            _box.expandByPoint(_boxMorphTargets.min);

            _box.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }

  computeTangents() {
    const index = this.index;
    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;

    if (this.hasAttribute('tangent') === false) {
      this.setAttribute('tangent', new _BufferAttribute.BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    const tangents = this.getAttribute('tangent').array;
    const tan1 = [],
          tan2 = [];

    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new _Vector.Vector3();
      tan2[i] = new _Vector.Vector3();
    }

    const vA = new _Vector.Vector3(),
          vB = new _Vector.Vector3(),
          vC = new _Vector.Vector3(),
          uvA = new _Vector2.Vector2(),
          uvB = new _Vector2.Vector2(),
          uvC = new _Vector2.Vector2(),
          sdir = new _Vector.Vector3(),
          tdir = new _Vector.Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    let groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    const tmp = new _Vector.Vector3(),
          tmp2 = new _Vector.Vector3();
    const n = new _Vector.Vector3(),
          n2 = new _Vector.Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }

  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new _BufferAttribute.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new _Vector.Vector3(),
            pB = new _Vector.Vector3(),
            pC = new _Vector.Vector3();
      const nA = new _Vector.Vector3(),
            nB = new _Vector.Vector3(),
            nC = new _Vector.Vector3();
      const cb = new _Vector.Vector3(),
            ab = new _Vector.Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }

  normalizeNormals() {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector.fromBufferAttribute(normals, i);

      _vector.normalize();

      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
  }

  toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices[i] * itemSize;
        }

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new _BufferAttribute.BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.BufferGeometry = BufferGeometry;

},{"../math/Box3.js":126,"../math/MathUtils.js":128,"../math/Matrix3.js":129,"../math/Matrix4.js":130,"../math/Sphere.js":132,"../math/Vector2.js":133,"../math/Vector3.js":134,"../utils.js":135,"./BufferAttribute.js":120,"./EventDispatcher.js":122,"./Object3D.js":124}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventDispatcher = void 0;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  hasEventListener(type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }

      event.target = null;
    }
  }

}

exports.EventDispatcher = EventDispatcher;

},{}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layers = void 0;

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }

}

exports.Layers = Layers;

},{}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Object3D = void 0;

var _Quaternion = require("../math/Quaternion.js");

var _Vector = require("../math/Vector3.js");

var _Matrix = require("../math/Matrix4.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _Euler = require("../math/Euler.js");

var _Layers = require("./Layers.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _object3DId = 0;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _q1 = /*@__PURE__*/new _Quaternion.Quaternion();

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _target = /*@__PURE__*/new _Vector.Vector3();

const _position = /*@__PURE__*/new _Vector.Vector3();

const _scale = /*@__PURE__*/new _Vector.Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

const _xAxis = /*@__PURE__*/new _Vector.Vector3(1, 0, 0);

const _yAxis = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);

const _zAxis = /*@__PURE__*/new _Vector.Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

class Object3D extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new _Vector.Vector3();
    const rotation = new _Euler.Euler();
    const quaternion = new _Quaternion.Quaternion();
    const scale = new _Vector.Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new _Matrix.Matrix4()
      },
      normalMatrix: {
        value: new _Matrix2.Matrix3()
      }
    });
    this.matrix = new _Matrix.Matrix4();
    this.matrixWorld = new _Matrix.Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

    this.layers = new _Layers.Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }

  onBeforeRender() {}

  onAfterRender() {}

  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }

  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }

  setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  }

  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }

  setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  }

  setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  }

  rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  }

  rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  }

  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }

  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }

  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }

  translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1.multiplyScalar(distance));
    return this;
  }

  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }

  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }

  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }

  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }

  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  }

  lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1);

    if (parent) {
      _m1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1);

      this.quaternion.premultiply(_q1.invert());
    }
  }

  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  }

  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  }

  removeFromParent() {
    const parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  }

  clear() {
    return this.remove(...this.children);
  }

  attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
    this.updateWorldMatrix(true, false);

    _m1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }

  getObjectById(id) {
    return this.getObjectByProperty('id', id);
  }

  getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  }

  getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  }

  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value) result.push(this);

    for (let i = 0, l = this.children.length; i < l; i++) {
      const childResult = this.children[i].getObjectsByProperty(name, value);

      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }

    return result;
  }

  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }

  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  }

  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  }

  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }

  raycast() {}

  traverse(callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }

  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }

  traverseAncestors(callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }

  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }

  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];

      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }

  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];

        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }

  toJSON(meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }

      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  }

  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }

  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }

}

exports.Object3D = Object3D;
Object3D.DEFAULT_UP = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

},{"../math/Euler.js":127,"../math/MathUtils.js":128,"../math/Matrix3.js":129,"../math/Matrix4.js":130,"../math/Quaternion.js":131,"../math/Vector3.js":134,"./EventDispatcher.js":122,"./Layers.js":123}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataUtils = void 0;
exports.fromHalfFloat = fromHalfFloat;
exports.toHalfFloat = toHalfFloat;

var _MathUtils = require("../math/MathUtils.js");

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
const _tables = /*@__PURE__*/_generateTables();

function _generateTables() {
  // float32 to float16 helpers
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);

  for (let i = 0; i < 256; ++i) {
    const e = i - 127; // very small number (0, -0)

    if (e < -27) {
      baseTable[i] = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // small number (denorm)
    } else if (e < -14) {
      baseTable[i] = 0x0400 >> -e - 14;
      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
      shiftTable[i] = -e - 1;
      shiftTable[i | 0x100] = -e - 1; // normal number
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
    } else if (e < 128) {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
    } else {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;
    }
  } // float16 to float32 helpers


  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);

  for (let i = 1; i < 1024; ++i) {
    let m = i << 13; // zero pad mantissa bits

    let e = 0; // zero exponent
    // normalized

    while ((m & 0x00800000) === 0) {
      m <<= 1;
      e -= 0x00800000; // decrement exponent
    }

    m &= ~0x00800000; // clear leading 1 bit

    e += 0x38800000; // adjust bias

    mantissaTable[i] = m | e;
  }

  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
  }

  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }

  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;

  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 0x80000000 + (i - 32 << 23);
  }

  exponentTable[63] = 0xc7800000;

  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }

  return {
    floatView: floatView,
    uint32View: uint32View,
    baseTable: baseTable,
    shiftTable: shiftTable,
    mantissaTable: mantissaTable,
    exponentTable: exponentTable,
    offsetTable: offsetTable
  };
} // float32 to float16


function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
  val = (0, _MathUtils.clamp)(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 0x1ff;
  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
} // float16 to float32


function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}

const DataUtils = {
  toHalfFloat: toHalfFloat,
  fromHalfFloat: fromHalfFloat
};
exports.DataUtils = DataUtils;

},{"../math/MathUtils.js":128}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box3 = void 0;

var _Vector = require("./Vector3.js");

class Box3 {
  constructor(min = new _Vector.Vector3(+Infinity, +Infinity, +Infinity), max = new _Vector.Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    this.makeEmpty();

    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector.fromArray(array, i));
    }

    return this;
  }

  setFromBufferAttribute(attribute) {
    this.makeEmpty();

    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector.fromBufferAttribute(attribute, i));
    }

    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object, precise = false) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);

    if (object.boundingBox !== undefined) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }

      _box.copy(object.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    } else {
      const geometry = object.geometry;

      if (geometry !== undefined) {
        if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
          const position = geometry.attributes.position;

          for (let i = 0, l = position.count; i < l; i++) {
            _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }

          _box.copy(geometry.boundingBox);

          _box.applyMatrix4(object.matrixWorld);

          this.union(_box);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1, _v0);

    _f1.subVectors(_v2, _v1);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }

  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    return this.clampPoint(point, _vector).distanceTo(point);
  }

  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector).length() * 0.5;
    }

    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;
const _points = [/*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3()];

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new Box3(); // triangle centered vertices


const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3(); // triangle edge vectors


const _f0 = /*@__PURE__*/new _Vector.Vector3();

const _f1 = /*@__PURE__*/new _Vector.Vector3();

const _f2 = /*@__PURE__*/new _Vector.Vector3();

const _center = /*@__PURE__*/new _Vector.Vector3();

const _extents = /*@__PURE__*/new _Vector.Vector3();

const _triangleNormal = /*@__PURE__*/new _Vector.Vector3();

const _testAxis = /*@__PURE__*/new _Vector.Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the separating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }

  return true;
}

},{"./Vector3.js":134}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Euler = void 0;

var _Quaternion = require("./Quaternion.js");

var _Matrix = require("./Matrix4.js");

var _MathUtils = require("./MathUtils.js");

const _matrix = /*@__PURE__*/new _Matrix.Matrix4();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order = this._order, update = true) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    switch (order) {
      case 'XYZ':
        this._y = Math.asin((0, _MathUtils.clamp)(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-(0, _MathUtils.clamp)(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin((0, _MathUtils.clamp)(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-(0, _MathUtils.clamp)(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin((0, _MathUtils.clamp)(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-(0, _MathUtils.clamp)(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion.setFromEuler(this);

    return this.setFromQuaternion(_quaternion, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }

}

exports.Euler = Euler;
Euler.DEFAULT_ORDER = 'XYZ';

},{"./MathUtils.js":128,"./Matrix4.js":130,"./Quaternion.js":131}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RAD2DEG = exports.MathUtils = exports.DEG2RAD = void 0;
exports.ceilPowerOfTwo = ceilPowerOfTwo;
exports.clamp = clamp;
exports.damp = damp;
exports.degToRad = degToRad;
exports.denormalize = denormalize;
exports.euclideanModulo = euclideanModulo;
exports.floorPowerOfTwo = floorPowerOfTwo;
exports.generateUUID = generateUUID;
exports.inverseLerp = inverseLerp;
exports.isPowerOfTwo = isPowerOfTwo;
exports.lerp = lerp;
exports.mapLinear = mapLinear;
exports.normalize = normalize;
exports.pingpong = pingpong;
exports.radToDeg = radToDeg;
exports.randFloat = randFloat;
exports.randFloatSpread = randFloatSpread;
exports.randInt = randInt;
exports.seededRandom = seededRandom;
exports.setQuaternionFromProperEuler = setQuaternionFromProperEuler;
exports.smootherstep = smootherstep;
exports.smoothstep = smoothstep;
const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
exports.DEG2RAD = DEG2RAD;
const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

exports.RAD2DEG = RAD2DEG;

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.

  return uuid.toLowerCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s; // Mulberry32 generator

  let t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return value / 4294967295.0;

    case Uint16Array:
      return value / 65535.0;

    case Uint8Array:
      return value / 255.0;

    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);

    case Int16Array:
      return Math.max(value / 32767.0, -1.0);

    case Int8Array:
      return Math.max(value / 127.0, -1.0);

    default:
      throw new Error('Invalid component type.');
  }
}

function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return Math.round(value * 4294967295.0);

    case Uint16Array:
      return Math.round(value * 65535.0);

    case Uint8Array:
      return Math.round(value * 255.0);

    case Int32Array:
      return Math.round(value * 2147483647.0);

    case Int16Array:
      return Math.round(value * 32767.0);

    case Int8Array:
      return Math.round(value * 127.0);

    default:
      throw new Error('Invalid component type.');
  }
}

const MathUtils = {
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize
};
exports.MathUtils = MathUtils;

},{}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix3 = void 0;

class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  invert() {
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  } //


  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }

  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }

  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  } // for 2D Transforms


  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
    }

    return this;
  }

  makeRotation(theta) {
    // counterclockwise
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y) {
    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  } //


  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

}

exports.Matrix3 = Matrix3;

const _m3 = /*@__PURE__*/new Matrix3();

},{}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix4 = void 0;

var _constants = require("../constants.js");

var _Vector = require("./Vector3.js");

class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }

    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1.set(te[0], te[1], te[2]).length();

    const sy = _v1.set(te[4], te[5], te[6]).length();

    const sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _m1 = /*@__PURE__*/new Matrix4();

const _zero = /*@__PURE__*/new _Vector.Vector3(0, 0, 0);

const _one = /*@__PURE__*/new _Vector.Vector3(1, 1, 1);

const _x = /*@__PURE__*/new _Vector.Vector3();

const _y = /*@__PURE__*/new _Vector.Vector3();

const _z = /*@__PURE__*/new _Vector.Vector3();

},{"../constants.js":119,"./Vector3.js":134}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quaternion = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }

    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }

  random() {
    // Derived from http://planning.cs.uiuc.edu/node198.html
    // Note, this source uses w, x, y, z ordering,
    // so we swap the order below.
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  toJSON() {
    return this.toArray();
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }

}

exports.Quaternion = Quaternion;

},{"./MathUtils.js":128}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sphere = void 0;

var _Box = require("./Box3.js");

var _Vector = require("./Vector3.js");

const _box = /*@__PURE__*/new _Box.Box3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

class Sphere {
  constructor(center = new _Vector.Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }

    _v1.subVectors(point, this.center);

    const lengthSq = _v1.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      // calculate the minimal sphere
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1, delta / length);
      this.radius += delta;
    }

    return this;
  }

  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }

    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }

    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);

      this.expandByPoint(_v1.copy(sphere.center).add(_v2));
      this.expandByPoint(_v1.copy(sphere.center).sub(_v2));
    }

    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Sphere = Sphere;

},{"./Box3.js":126,"./Vector3.js":134}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector2 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }

}

exports.Vector2 = Vector2;

},{"./MathUtils.js":128}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector3 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

var _Quaternion = require("./Quaternion.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v) {
    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }

  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

  randomDirection() {
    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }

}

exports.Vector3 = Vector3;

const _vector = /*@__PURE__*/new Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

},{"./MathUtils.js":128,"./Quaternion.js":131}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMax = arrayMax;
exports.arrayMin = arrayMin;
exports.arrayNeedsUint32 = arrayNeedsUint32;
exports.createCanvasElement = createCanvasElement;
exports.createElementNS = createElementNS;
exports.getTypedArray = getTypedArray;
exports.warnOnce = warnOnce;

function arrayMin(array) {
  if (array.length === 0) return Infinity;
  let min = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] < min) min = array[i];
  }

  return min;
}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

function arrayNeedsUint32(array) {
  // assumes larger values usually on last
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }

  return false;
}

const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function createCanvasElement() {
  const canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}

const _cache = {};

function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}

},{}],136:[function(require,module,exports){
"use strict"

module.exports = triangulateCube

var perm = require("permutation-rank")
var sgn = require("permutation-parity")
var gamma = require("gamma")

function triangulateCube(dimension) {
  if(dimension < 0) {
    return [ ]
  }
  if(dimension === 0) {
    return [ [0] ]
  }
  var dfactorial = Math.round(gamma(dimension+1))|0
  var result = []
  for(var i=0; i<dfactorial; ++i) {
    var p = perm.unrank(dimension, i)
    var cell = [ 0 ]
    var v = 0
    for(var j=0; j<p.length; ++j) {
      v += (1<<p[j])
      cell.push(v)
    }
    if(sgn(p) < 1) {
      cell[0] = v
      cell[dimension] = 0
    }
    result.push(cell)
  }
  return result
}
},{"gamma":46,"permutation-parity":89,"permutation-rank":90}],137:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],138:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],139:[function(require,module,exports){
(function (global){(function (){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')
var Buffer = require('buffer').Buffer

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined'
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0])
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeBigUint64 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeBigInt64 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigUint64 = mallocBigUint64

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigInt64 = mallocBigInt64

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.BIGUINT64[i].length = 0
    POOL.BIGINT64[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"bit-twiddle":20,"buffer":30,"dup":43}],140:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],141:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],142:[function(require,module,exports){
"use strict"

module.exports = createText

var vectorizeText = require("./lib/vtext")
var defaultCanvas = null
var defaultContext = null

if(typeof document !== 'undefined') {
  defaultCanvas = document.createElement('canvas')
  defaultCanvas.width = 8192
  defaultCanvas.height = 1024
  defaultContext = defaultCanvas.getContext("2d")
}

function createText(str, options) {
  if((typeof options !== "object") || (options === null)) {
    options = {}
  }
  return vectorizeText(
    str,
    options.canvas || defaultCanvas,
    options.context || defaultContext,
    options)
}

},{"./lib/vtext":143}],143:[function(require,module,exports){
module.exports = vectorizeText
module.exports.processPixels = processPixels

var surfaceNets = require('surface-nets')
var ndarray = require('ndarray')
var simplify = require('simplify-planar-graph')
var cleanPSLG = require('clean-pslg')
var cdt2d = require('cdt2d')
var toPolygonCrappy = require('planar-graph-to-polyline')

var TAG_bold = "b"
var CHR_bold = 'b|'

var TAG_italic = "i"
var CHR_italic = 'i|'

var TAG_super = "sup"
var CHR_super0 = '+'
var CHR_super = '+1'

var TAG_sub = "sub"
var CHR_sub0 = '-'
var CHR_sub = '-1'

function parseTag(tag, TAG_CHR, str, map) {

  var opnTag =  "<"  + tag + ">"
  var clsTag =  "</" + tag + ">"

  var nOPN = opnTag.length
  var nCLS = clsTag.length

  var isRecursive = (TAG_CHR[0] === CHR_super0) ||
                    (TAG_CHR[0] === CHR_sub0);

  var a = 0
  var b = -nCLS
  while (a > -1) {
    a = str.indexOf(opnTag, a)
    if(a === -1) break

    b = str.indexOf(clsTag, a + nOPN)
    if(b === -1) break

    if(b <= a) break

    for(var i = a; i < b + nCLS; ++i){
      if((i < a + nOPN) || (i >= b)) {
        map[i] = null
        str = str.substr(0, i) + " " + str.substr(i + 1)
      } else {
        if(map[i] !== null) {
          var pos = map[i].indexOf(TAG_CHR[0])
          if(pos === -1) {
            map[i] += TAG_CHR
          } else { // i.e. to handle multiple sub/super-scripts
            if(isRecursive) {
              // i.e to increase the sub/sup number
              map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2)
            }
          }
        }
      }
    }

    var start = a + nOPN
    var remainingStr = str.substr(start, b - start)

    var c = remainingStr.indexOf(opnTag)
    if(c !== -1) a = c
    else a = b + nCLS
  }

  return map
}

function transformPositions(positions, options, size) {
  var align = options.textAlign || "start"
  var baseline = options.textBaseline || "alphabetic"

  var lo = [1<<30, 1<<30]
  var hi = [0,0]
  var n = positions.length
  for(var i=0; i<n; ++i) {
    var p = positions[i]
    for(var j=0; j<2; ++j) {
      lo[j] = Math.min(lo[j], p[j])|0
      hi[j] = Math.max(hi[j], p[j])|0
    }
  }

  var xShift = 0
  switch(align) {
    case "center":
      xShift = -0.5 * (lo[0] + hi[0])
    break

    case "right":
    case "end":
      xShift = -hi[0]
    break

    case "left":
    case "start":
      xShift = -lo[0]
    break

    default:
      throw new Error("vectorize-text: Unrecognized textAlign: '" + align + "'")
  }

  var yShift = 0
  switch(baseline) {
    case "hanging":
    case "top":
      yShift = -lo[1]
    break

    case "middle":
      yShift = -0.5 * (lo[1] + hi[1])
    break

    case "alphabetic":
    case "ideographic":
      yShift = -3 * size
    break

    case "bottom":
      yShift = -hi[1]
    break

    default:
      throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'")
  }

  var scale = 1.0 / size
  if("lineHeight" in options) {
    scale *= +options.lineHeight
  } else if("width" in options) {
    scale = options.width / (hi[0] - lo[0])
  } else if("height" in options) {
    scale = options.height / (hi[1] - lo[1])
  }

  return positions.map(function(p) {
    return [ scale * (p[0] + xShift), scale * (p[1] + yShift) ]
  })
}

function getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {

  rawString = rawString.replace(/\n/g, '') // don't accept \n in the input

  if(styletags.breaklines === true) {
    rawString = rawString.replace(/\<br\>/g, '\n') // replace <br> tags with \n in the string
  } else {
    rawString = rawString.replace(/\<br\>/g, ' ') // don't accept <br> tags in the input and replace with space in this case
  }

  var activeStyle = ""
  var map = []
  for(j = 0; j < rawString.length; ++j) {
    map[j] = activeStyle
  }

  if(styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map)
  if(styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map)
  if(styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map)
  if(styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map)

  var allStyles = []
  var plainText = ""
  for(j = 0; j < rawString.length; ++j) {
    if(map[j] !== null) {
      plainText += rawString[j]
      allStyles.push(map[j])
    }
  }

  var allTexts = plainText.split('\n')

  var numberOfLines = allTexts.length
  var lineHeight = Math.round(lineSpacing * fontSize)
  var offsetX = fontSize
  var offsetY = fontSize * 2
  var maxWidth = 0
  var minHeight = numberOfLines * lineHeight + offsetY

  if(canvas.height < minHeight) {
    canvas.height = minHeight
  }

  context.fillStyle = "#000"
  context.fillRect(0, 0, canvas.width, canvas.height)

  context.fillStyle = "#fff"
  var i, j, xPos, yPos, zPos
  var nDone = 0

  var buffer = ""
  function writeBuffer() {
    if(buffer !== "") {
      var delta = context.measureText(buffer).width

      context.fillText(buffer, offsetX + xPos, offsetY + yPos)
      xPos += delta
    }
  }

  function getTextFontSize() {
    return "" + Math.round(zPos) + "px ";
  }

  function changeStyle(oldStyle, newStyle) {
    var ctxFont = "" + context.font;

    if(styletags.subscripts === true) {
      var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);
      var newIndex_Sub = newStyle.indexOf(CHR_sub0);

      var oldSub = (oldIndex_Sub > -1) ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;
      var newSub = (newIndex_Sub > -1) ? parseInt(newStyle[1 + newIndex_Sub]) : 0;

      if(oldSub !== newSub) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSub - oldSub))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos += 0.25 * lineHeight * (newSub - oldSub);
    }

    if(styletags.superscripts === true) {
      var oldIndex_Super = oldStyle.indexOf(CHR_super0);
      var newIndex_Super = newStyle.indexOf(CHR_super0);

      var oldSuper = (oldIndex_Super > -1) ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;
      var newSuper = (newIndex_Super > -1) ? parseInt(newStyle[1 + newIndex_Super]) : 0;

      if(oldSuper !== newSuper) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSuper - oldSuper))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos -= 0.25 * lineHeight * (newSuper - oldSuper);
    }

    if(styletags.bolds === true) {
      var wasBold = (oldStyle.indexOf(CHR_bold) > -1)
      var is_Bold = (newStyle.indexOf(CHR_bold) > -1)

      if(!wasBold && is_Bold) {
        if(wasItalic) {
          ctxFont = ctxFont.replace("italic ", "italic bold ")
        } else {
          ctxFont = "bold " + ctxFont
        }
      }
      if(wasBold && !is_Bold) {
        ctxFont = ctxFont.replace("bold ", '')
      }
    }

    if(styletags.italics === true) {
      var wasItalic = (oldStyle.indexOf(CHR_italic) > -1)
      var is_Italic = (newStyle.indexOf(CHR_italic) > -1)

      if(!wasItalic && is_Italic) {
        ctxFont = "italic " + ctxFont
      }
      if(wasItalic && !is_Italic) {
        ctxFont = ctxFont.replace("italic ", '')
      }
    }
    context.font = ctxFont
  }

  for(i = 0; i < numberOfLines; ++i) {
    var txt = allTexts[i] + '\n'
    xPos = 0
    yPos = i * lineHeight
    zPos = fontSize

    buffer = ""
    
    for(j = 0; j < txt.length; ++j) {
      var style = (j + nDone < allStyles.length) ? allStyles[j + nDone] : allStyles[allStyles.length - 1]
      if(activeStyle === style) {
        buffer += txt[j]
      } else {
        writeBuffer()
        buffer = txt[j]

        if(style !== undefined) {
          changeStyle(activeStyle, style)
          activeStyle = style
        }
      }
    }
    writeBuffer()

    nDone += txt.length

    var width = Math.round(xPos + 2 * offsetX) | 0
    if(maxWidth < width) maxWidth = width
  }

  //Cut pixels from image
  var xCut = maxWidth
  var yCut = offsetY + lineHeight * numberOfLines
  var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4])
  return pixels.pick(-1, -1, 0).transpose(1, 0)
}

function getContour(pixels, doSimplify) {
  var contour = surfaceNets(pixels, 128)
  if(doSimplify) {
    return simplify(contour.cells, contour.positions, 0.25)
  }
  return {
    edges: contour.cells,
    positions: contour.positions
  }
}

function processPixelsImpl(pixels, options, size, simplify) {
  //Extract contour
  var contour = getContour(pixels, simplify)

  //Apply warp to positions
  var positions = transformPositions(contour.positions, options, size)
  var edges     = contour.edges
  var flip = "ccw" === options.orientation

  //Clean up the PSLG, resolve self intersections, etc.
  cleanPSLG(positions, edges)

  //If triangulate flag passed, triangulate the result
  if(options.polygons || options.polygon || options.polyline) {
    var result = toPolygonCrappy(edges, positions)
    var nresult = new Array(result.length)
    for(var i=0; i<result.length; ++i) {
      var loops = result[i]
      var nloops = new Array(loops.length)
      for(var j=0; j<loops.length; ++j) {
        var loop = loops[j]
        var nloop = new Array(loop.length)
        for(var k=0; k<loop.length; ++k) {
          nloop[k] = positions[loop[k]].slice()
        }
        if(flip) {
          nloop.reverse()
        }
        nloops[j] = nloop
      }
      nresult[i] = nloops
    }
    return nresult
  } else if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: cdt2d(positions, edges, {
        delaunay: false,
        exterior: false,
        interior: true
      }),
      positions: positions
    }
  } else {
    return {
      edges:     edges,
      positions: positions
    }
  }
}

function processPixels(pixels, options, size) {
  try {
    return processPixelsImpl(pixels, options, size, true)
  } catch(e) {}
  try {
    return processPixelsImpl(pixels, options, size, false)
  } catch(e) {}
  if(options.polygons || options.polyline || options.polygon) {
    return []
  }
  if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: [],
      positions: []
    }
  }
  return {
    edges: [],
    positions: []
  }
}

function vectorizeText(str, canvas, context, options) {
  var size = 64
  var lineSpacing = 1.25
  var styletags = {
    breaklines: false,
    bolds: false,
    italics: false,
    subscripts: false,
    superscripts: false
  }

  if(options) {

    if(options.size &&
       options.size > 0) size =
       options.size

    if(options.lineSpacing &&
       options.lineSpacing > 0) lineSpacing =
       options.lineSpacing

    if(options.styletags &&
       options.styletags.breaklines) styletags.breaklines =
       options.styletags.breaklines ? true : false

    if(options.styletags &&
       options.styletags.bolds) styletags.bolds =
       options.styletags.bolds ? true : false

    if(options.styletags &&
       options.styletags.italics) styletags.italics =
       options.styletags.italics ? true : false

    if(options.styletags &&
       options.styletags.subscripts) styletags.subscripts =
       options.styletags.subscripts ? true : false

    if(options.styletags &&
       options.styletags.superscripts) styletags.superscripts =
       options.styletags.superscripts ? true : false
  }

  context.font = [
    options.fontStyle,
    options.fontVariant,
    options.fontWeight,
    size + "px",
    options.font
  ].filter(function(d) {return d}).join(" ")
  context.textAlign = "start"
  context.textBaseline = "alphabetic"
  context.direction = "ltr"

  var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags)

  return processPixels(pixels, options, size)
}

},{"cdt2d":31,"clean-pslg":36,"ndarray":86,"planar-graph-to-polyline":93,"simplify-planar-graph":115,"surface-nets":118}],144:[function(require,module,exports){
module.exports = require('cwise-compiler')({
    args: ['array', {
        offset: [1],
        array: 0
    }, 'scalar', 'scalar', 'index'],
    pre: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    post: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    body: {
        "body": "{\n        var _inline_1_da = _inline_1_arg0_ - _inline_1_arg3_\n        var _inline_1_db = _inline_1_arg1_ - _inline_1_arg3_\n        if((_inline_1_da >= 0) !== (_inline_1_db >= 0)) {\n          _inline_1_arg2_.push(_inline_1_arg4_[0] + 0.5 + 0.5 * (_inline_1_da + _inline_1_db) / (_inline_1_da - _inline_1_db))\n        }\n      }",
        "args": [{
            "name": "_inline_1_arg0_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg1_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg2_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg3_",
            "lvalue": false,
            "rvalue": true,
            "count": 2
        }, {
            "name": "_inline_1_arg4_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }],
        "thisVars": [],
        "localVars": ["_inline_1_da", "_inline_1_db"]
    },
    funcName: 'zeroCrossings'
})

},{"cwise-compiler":39}],145:[function(require,module,exports){
"use strict"

module.exports = findZeroCrossings

var core = require("./lib/zc-core")

function findZeroCrossings(array, level) {
  var cross = []
  level = +level || 0.0
  core(array.hi(array.shape[0]-1), cross, level)
  return cross
}
},{"./lib/zc-core":144}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sandbox = _interopRequireDefault(require("./lib/sandbox.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// handles code evaluation and attaching relevant objects to global and evaluation contexts
class EvalSandbox {
  constructor(parent, makeGlobal, userProps = []) {
    this.makeGlobal = makeGlobal;
    this.sandbox = (0, _sandbox.default)(parent);
    this.parent = parent;
    var properties = Object.keys(parent);
    properties.forEach(property => this.add(property));
    this.userProps = userProps;
  }

  add(name) {
    if (this.makeGlobal) window[name] = this.parent[name]; // this.sandbox.addToContext(name, `parent.${name}`)
  } // sets on window as well as synth object if global (not needed for objects, which can be set directly)


  set(property, value) {
    if (this.makeGlobal) {
      window[property] = value;
    }

    this.parent[property] = value;
  }

  tick() {
    if (this.makeGlobal) {
      this.userProps.forEach(property => {
        this.parent[property] = window[property];
      }); //  this.parent.speed = window.speed
    } else {}
  }

  eval(code) {
    this.sandbox.eval(code);
  }

}

var _default = EvalSandbox;
exports.default = _default;

},{"./lib/array-utils.js":158,"./lib/sandbox.js":163}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatArguments;

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [WIP] how to treat different dimensions (?)
const DEFAULT_CONVERSIONS = {
  float: {
    'vec4': {
      name: 'sum',
      args: [[1, 1, 1, 1]]
    },
    'vec2': {
      name: 'sum',
      args: [[1, 1]]
    }
  }
};

function fillArrayWithDefaults(arr, len) {
  // fill the array with default values if it's too short
  while (arr.length < len) {
    if (arr.length === 3) {
      // push a 1 as the default for .a in vec4
      arr.push(1.0);
    } else {
      arr.push(0.0);
    }
  }

  return arr.slice(0, len);
}

const ensure_decimal_dot = val => {
  val = val.toString();

  if (val.indexOf('.') < 0) {
    val += '.';
  }

  return val;
};

function formatArguments(transform, startIndex, synthContext) {
  const defaultArgs = transform.transform.inputs;
  const userArgs = transform.userArgs;
  const {
    generators
  } = transform.synth;
  const {
    src
  } = generators; // depends on synth having src() function

  return defaultArgs.map((input, index) => {
    const typedArg = {
      value: input.default,
      type: input.type,
      //
      isUniform: false,
      name: input.name,
      vecLen: 0 //  generateGlsl: null // function for creating glsl

    };
    if (typedArg.type === 'float') typedArg.value = ensure_decimal_dot(input.default);

    if (input.type.startsWith('vec')) {
      try {
        typedArg.vecLen = Number.parseInt(input.type.substr(3));
      } catch (e) {
        console.log(`Error determining length of vector input type ${input.type} (${input.name})`);
      }
    } // if user has input something for this argument


    if (userArgs.length > index) {
      typedArg.value = userArgs[index];

      if (typeof typedArg.value === 'function' && !typedArg.value._texture && !typedArg.value._framebuffer) {
        typedArg.value = getFunctionValue(typedArg.value, input);
        typedArg.isUniform = true;
      } else if (typedArg.value.constructor === Array) {
        // todo: maybe check for undefined
        typedArg.value = getArrayValue(typedArg.value, input, typedArg.vecLen);
        typedArg.isUniform = true; // }
      }
    }

    if (startIndex < 0) {} else {
      if (typedArg.value && typedArg.value.transforms) {
        const final_transform = typedArg.value.transforms[typedArg.value.transforms.length - 1];

        if (final_transform.transform.glsl_return_type !== input.type) {
          const defaults = DEFAULT_CONVERSIONS[input.type];

          if (typeof defaults !== 'undefined') {
            const default_def = defaults[final_transform.transform.glsl_return_type];

            if (typeof default_def !== 'undefined') {
              const {
                name,
                args
              } = default_def;
              typedArg.value = typedArg.value[name](...args);
            }
          }
        }

        typedArg.isUniform = false;
      } else if (typedArg.type === 'float' && typeof typedArg.value === 'number') {
        typedArg.value = ensure_decimal_dot(typedArg.value);
      } else if (typedArg.type.startsWith('vec') && typeof typedArg.value !== 'function' && !typedArg.value.getTexture) {
        typedArg.isUniform = false;

        if (Array.isArray(typedArg.value) || typedArg.value instanceof Float32Array || typedArg.value instanceof Uint8Array) {
          // todo: accept smaller arrays?
          typedArg.value = `${typedArg.type}(${typedArg.value.map(ensure_decimal_dot).join(', ')})`;
        } else if (typeof typedArg.value === 'number') {
          const length = parseInt(typedArg.type.substr(-1));
          const arr = Array(length).fill(typedArg.value);
          typedArg.value = `${typedArg.type}(${arr.map(ensure_decimal_dot).join(', ')})`;
        }
      } else if (input.type === 'sampler2D') {
        // typedArg.tex = typedArg.value
        var x = typedArg.value;
        typedArg.value = x.getTexture ? () => x.getTexture() : x;
        typedArg.isUniform = true;
      } else {
        // if passing in a texture reference, when function asks for vec4, convert to vec4
        if (typedArg.value.getTexture || typedArg.value._texture) {
          var x1 = typedArg.value;

          if (input.type === 'vec4') {
            typedArg.value = src(x1);
          } else {
            let getter = _types.getLookup[input.type];
            typedArg.value = src(x1)[getter];
          }

          typedArg.isUniform = false;
        }
      } // add tp uniform array if is a function that will pass in a different value on each render frame,
      // or a texture/ external source


      if (input.isUniform) typedArg.isUniform = input.isUniform;

      if (typedArg.isUniform) {
        typedArg.name += startIndex; //  shaderParams.uniforms.push(typedArg)
      }
    }

    return typedArg;
  });
}

function getFunctionValue(value, input) {
  // if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //    typedArg.value = (context, props, batchId) => (fillArrayWithDefaults(userArgs[index](props), typedArg.vecLen))
  // } else {
  return (context, props, batchId) => {
    try {
      const val = value(props);

      if (typeof val === 'number') {
        return val;
      } else {
        console.warn('function does not return a number', value);
      }

      return input.default;
    } catch (e) {
      console.warn('ERROR', e);
      return input.default;
    }
  }; //  }
}

function getArrayValue(value, input, vecLen = 0) {
  //   if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //     typedArg.isUniform = true
  //     typedArg.value = fillArrayWithDefaults(typedArg.value, typedArg.vecLen)
  //  } else {
  //  console.log("is Array")
  // filter out values that are not a number
  // const filteredArray = userArgs[index].filter((val) => typeof val === 'number')
  // typedArg.value = (context, props, batchId) => arrayUtils.getValue(filteredArray)(props)
  if (vecLen) {
    return (context, props, batchId) => {
      const values = Array(vecLen);

      for (let i = 0; i < vecLen; i++) {
        const v = value[i];
        const defaultValue = input.default ? input.default.constructor === Array ? input.default[i] : input.default : 0;

        if (typeof v === 'function') {
          values[i] = getFunctionValue(v, {
            default: defaultValue
          })(context, props, batchId);
        } else if (Array.isArray(v)) {
          values[i] = _arrayUtils.default.getValue(v)(props);
        } else if (typeof v !== 'undefined') {
          values[i] = v;
        } else {
          values[i] = defaultValue;
        }
      }

      return values;
    };
  } else {
    return (context, props, batchId) => _arrayUtils.default.getValue(value)(props);
  }
}

},{"./lib/array-utils.js":158,"./types.js":168}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatArguments = _interopRequireDefault(require("./format-arguments.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// converts a tree of javascript functions to a shader
function _default(source) {
  return generateParams(createParams(), source, source.transforms);
}

function createParams(options = {}) {
  return Object.assign({
    uniforms: [],
    // list of uniforms used in shader
    glslFunctions: [],
    // list of functions used in shader
    fragColor: '',
    position: ''
  }, options);
}

function generateParams(shaderParams, source, transforms) {
  if (!shaderParams.fragColor) {
    shaderParams.fragColor = generateGlsl(source, transforms, shaderParams)('st', 'vec4', 1.0);
  }

  if (!shaderParams.position && !shaderParams.combine) {
    shaderParams.position = generateGlsl(source, transforms.filter(tr => {
      return tr.transform.type !== 'combine';
    }), shaderParams)('st', 'vec4', 1.0); // todo: should be vec3
  } // remove uniforms with duplicate names


  if (shaderParams.uniforms) {
    let uniforms = {};
    shaderParams.uniforms.forEach(uniform => uniforms[uniform.name] = uniform);
    shaderParams.uniforms = Object.values(uniforms);
  }

  return shaderParams;
} // recursive function for generating shader string from object containing functions and user arguments. Order of functions in string depends on type of function
// to do: improve variable names


function generateGlsl(source, transforms, shaderParams) {
  // transform function that outputs a shader string corresponding to gl_FragColor
  const empty = () => '';

  var fragColor = empty;
  transforms.map((transform, i) => {
    if (transform.transform.type === 'genType') {
      transform.transform = (0, _types.replaceGenType)(transform.transform, i ? 'color' : 'coord');
    }

    if (transform.transform.type === 'glsl') {
      fragColor = () => transform.userArgs[0];

      return;
    }

    if (transform.transform.type === 'vert' && !source.geometry) {
      source.setGeometry(transform.userArgs[0]);
      transform.userArgs = transform.userArgs.slice(1);
    }

    var inputs = (0, _formatArguments.default)(transform, shaderParams.uniforms.length);
    inputs.forEach(input => {
      if (input.isUniform) shaderParams.uniforms.push(input);
    }); // add new glsl function to running list of functions

    if (!contains(transform, shaderParams.glslFunctions)) shaderParams.glslFunctions.push(transform); // current function for generating frag color shader code

    var f0 = fragColor;

    if (transform.transform.type === 'src' || transform.transform.type === 'vert') {
      fragColor = (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'coord') {
      fragColor = f0 === empty ? (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}` : (uv, returnType, alpha) => `${f0(`${shaderString(uv, transform, inputs, shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else if (transform.transform.type === 'color') {
      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}`, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combine') {
      // combining two generated shader strings (i.e. for blend, mult, add funtions)
      if (source.transforms[0].transform.vert || inputs[0].value && inputs[0].value.transforms && inputs[0].value.transforms[0].transform.vert) {
        const params = Object.assign({}, shaderParams, {
          fragColor: fragColor('st', 'vec4', 1.0) || 'vec4(0)'
        });
        Object.assign(shaderParams, createParams({
          glslFunctions: [transform],
          combine: true
        }));
        const trans = source.transforms.slice(0, source.transforms.indexOf(transform));
        source.passes.unshift(source.createPass(generateParams(params, source, trans), {
          framebuffer: source.output.temp[0]
        }));
        const temp0 = src(source.output.temp[0]);

        f0 = (uv, returnType, alpha) => `${generateGlsl(temp0, temp0.transforms, shaderParams)(uv, returnType, alpha)}`;
      }

      var f1;

      if (inputs[0].value && inputs[0].value.transforms) {
        if (inputs[0].value.transforms[0].transform.vert || source.transforms[0].transform.vert) {
          inputs[0].value.output = source.output;
          source.passes.unshift(...inputs[0].value.compile({
            framebuffer: source.output.temp[1]
          }));
          const temp1 = src(source.output.temp[1]);

          f1 = (uv, returnType, alpha) => `${generateGlsl(temp1, temp1.transforms, shaderParams)(uv, returnType, alpha)}`;
        } else {
          f1 = (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}`;
        }
      } else {
        f1 = inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;
      }

      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combineCoord') {
      // combining two generated shader strings (i.e. for modulate functions)
      var f1 = inputs[0].value && inputs[0].value.transforms ? (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}` : inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;

      fragColor = (uv, returnType, alpha) => `${f0(`${shaderString(`${uv}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else {
      console.warn('no support for type: ' + transform.transform.type);
    }
  });

  if (source.getter) {
    var f2 = fragColor;

    fragColor = (uv, returnType, alpha) => (0, _types.castType)(f2(uv, returnType, alpha) + `.${source.getter}`, _types.getTypeLookup[source.getter], returnType, 1.0);
  }

  return fragColor;
} // assembles a shader string containing the arguments and the function name, i.e. 'osc(uv, frequency)'


function shaderString(uv, transform, inputs, shaderParams, returnType, alpha = 0.0) {
  const str = inputs.map(input => {
    if (input.isUniform) {
      return input.name;
    } else if (input.value && input.value.transforms) {
      // this by definition needs to be a generator, hence we start with 'st' as the initial value for generating the glsl fragment
      if (!input.value.getter && _types.typeLookup[input.value.transforms[0].transform.type] !== input.type) {
        // todo: add getter only if input.type is larger
        input.value.getter = _types.getLookup[input.type];
      }

      return `${generateGlsl(input.value, input.value.transforms, shaderParams)('st', input.type)}`;
    }

    return input.value;
  }).reduce((p, c) => `${p}, ${c}`, '');
  var func = `${transform.transform.glslName}(${uv}${str})`;
  return (0, _types.castType)(func, _types.typeLookup[transform.transform.type].returnType, returnType, alpha);
} // check whether array


function contains(object, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (object.name == arr[i].name) return true;
  }

  return false;
}

},{"./format-arguments.js":147,"./types.js":168}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

var _glslFunctions = _interopRequireDefault(require("./glsl/glsl-functions.js"));

var _vertFunctions = _interopRequireDefault(require("./glsl/vert-functions.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GeneratorFactory {
  constructor({
    defaultUniforms,
    defaultOutput,
    extendTransforms = [],
    changeListener = () => {}
  } = {}) {
    this.defaultOutput = defaultOutput;
    this.defaultUniforms = defaultUniforms;
    this.changeListener = changeListener;
    this.extendTransforms = extendTransforms;
    this.generators = {};
    this.utils = {};
    this.init();
  }

  init() {
    const functions = (0, _glslFunctions.default)();
    this.glslTransforms = {};
    this.generators = Object.entries(this.generators).reduce((prev, [method, transform]) => {
      this.changeListener({
        type: 'remove',
        synth: this,
        method
      });
      return prev;
    }, {});

    this.sourceClass = (() => {
      return class extends _glslSource.default {};
    })(); // add user definied transforms


    if (Array.isArray(this.extendTransforms)) {
      functions.concat(this.extendTransforms);
    } else if (typeof this.extendTransforms === 'object' && this.extendTransforms.type) {
      functions.push(this.extendTransforms);
    }

    functions.map(transform => this.setFunction(transform));
    const functions2 = (0, _vertFunctions.default)(this.generators); // sandbox is not ready at this moment yet

    functions2.map(transform => this.setFunction(transform));
  }

  _addMethod(method, transform) {
    const self = this;
    this.glslTransforms[method] = transform;
    let retval = undefined;

    if (['src', 'coord', 'genType', 'vert', 'glsl'].indexOf(transform.type) > -1) {
      const func = (...args) => new this.sourceClass({
        name: method,
        transform: transform,
        userArgs: args,
        defaultOutput: this.defaultOutput,
        defaultUniforms: this.defaultUniforms,
        synth: self,
        utils: this.utils
      });

      this.generators[method] = func;
      this.changeListener({
        type: 'add',
        synth: this,
        method
      });
      retval = func;
    }

    this.sourceClass.prototype[method] = function (...args) {
      if (transform.type !== 'src' && transform.type !== 'vert') {
        this.transforms.push({
          name: method,
          transform: transform,
          userArgs: args,
          synth: self
        });
      } else {
        console.error(`transform ${transform.name} not allowed after ${this.transforms[this.transforms.length - 1].name}`);
      }

      return this;
    };

    return retval;
  }

  setFunction(obj) {
    // todo: remove utils and instead manage function dependencies
    if (obj.type === 'util') this.utils[obj.name] = obj;
    var processedGlsl = processFunction(obj);
    if (processedGlsl) this._addMethod(obj.name, processedGlsl);
  }

} // expects glsl of format
// {
//   name: 'osc', // name that will be used to access function as well as within glsl
//   type: 'src', // can be src: vec4(vec2 _st), coord: vec2(vec2 _st), color: vec4(vec4 _c0), combine: vec4(vec4 _c0, vec4 _c1), combineCoord: vec2(vec2 _st, vec4 _c0)
//   inputs: [
//     {
//       name: 'freq',
//       type: 'float', // 'float'   //, 'texture', 'vec4'
//       default: 0.2
//     },
//     {
//           name: 'sync',
//           type: 'float',
//           default: 0.1
//         },
//         {
//           name: 'offset',
//           type: 'float',
//           default: 0.0
//         }
//   ],
//  glsl: `
//    vec2 st = _st;
//    float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//    float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//    float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//    return vec4(r, g, b, 1.0);
// `
// }
// // generates glsl function:
// `vec4 osc(vec2 _st, float freq, float sync, float offset){
//  vec2 st = _st;
//  float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//  float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//  float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//  return vec4(r, g, b, 1.0);
// }`


function processFunction(obj) {
  obj.glslName || (obj.glslName = obj.name);
  if (obj.type === 'glsl' || obj.type === 'genType') return obj;else if (obj.type === 'util') {
    return (0, _types.processGlsl)(obj, obj.returnType);
  }
  let t = _types.typeLookup[obj.type];

  if (t) {
    return (0, _types.processGlsl)(obj, t.returnType, t.args);
  } else {
    console.warn(`type ${obj.type} not recognized`, obj);
  }
}

var _default = GeneratorFactory;
exports.default = _default;

},{"./glsl-source.js":150,"./glsl/glsl-functions.js":152,"./glsl/vert-functions.js":154,"./types.js":168}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _generateGlsl = _interopRequireDefault(require("./generate-glsl.js"));

var _utilityFunctions = _interopRequireDefault(require("./glsl/utility-functions.js"));

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GlslSource = function (obj) {
  this.transforms = [];
  this.transforms.push(obj);
  this.defaultOutput = obj.defaultOutput;
  this.output = null;
  this.synth = obj.synth;
  this.type = 'GlslSource';
  this.defaultUniforms = obj.defaultUniforms;
  this.utils = Object.assign({}, _utilityFunctions.default, obj.utils);
  this.blendMode = typeof obj.transform.blendMode !== 'undefined' ? obj.transform.blendMode : false;
  this.lineWidth = obj.transform.lineWidth || 1;
  this._viewport = {};
  return this;
};

GlslSource.prototype.addTransform = function (obj) {
  this.transforms.push(obj);
};

GlslSource.prototype.out = function (_output) {
  var output = _output || this.defaultOutput;
  this.output = output;
  var glsl = this.compile();
  this.synth.currentFunctions = [];
  if (output) try {
    output.render(glsl);
  } catch (error) {
    console.log('shader could not compile', error);
  }
  return this;
};

GlslSource.prototype.tex = function (_output, options = {}) {
  if (!this.output) {
    this.out(_output);
  }

  return this.output.renderTexture(options);
};

GlslSource.prototype.compile = function (options = {}) {
  this.passes = [];
  this.passes.push(this.createPass((0, _generateGlsl.default)(this), options));
  return this.passes;
};

GlslSource.prototype.getInfo = function () {
  if (this.transforms.length > 0) {
    var shaderInfo = (0, _generateGlsl.default)(this);
    var uniforms = {};
    shaderInfo.uniforms.forEach(uniform => {
      uniforms[uniform.name] = uniform.value;
    });
    return {
      shaderInfo,
      utilityGlsl: this.utils,
      // todo: add support for generated vertex shader
      vert: this.transforms[0].transform.vert,
      // todo: differs from compile
      attributes: this.transforms[0].transform.attributes,
      // todo: differs from compile
      attributesCount: this.transforms[0].transform.attributesCount,
      primitive: this.transforms[0].transform.primitive,
      uniforms: Object.assign({}, this.defaultUniforms, uniforms)
    };
  }
};

GlslSource.prototype.createPass = function (shaderInfo, options = {}) {
  var uniforms = {};
  shaderInfo.uniforms.forEach(uniform => {
    uniforms[uniform.name] = uniform.value;
  });

  if (shaderInfo.combine) {
    return {
      vert: GlslSource.compileVert(this.defaultOutput.precision, false, {
        glslName: 'combine'
      }, shaderInfo),
      userArgs: this.transforms[0].userArgs,
      // todo: fix or delete
      // blendMode: this.blendMode,
      lineWidth: this.lineWidth,
      frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
      uniforms: Object.assign({}, this.defaultUniforms, uniforms),
      viewport: this._viewport,
      clear: this.clear
    };
  }

  return Object.assign({
    vert: GlslSource.compileVert(this.defaultOutput.precision, true, this.transforms[0].transform, shaderInfo, this.utils),
    primitive: this.transforms[0].transform.primitive,
    userArgs: this.transforms[0].userArgs,
    geometry: this.geometry,
    blendMode: this.blendMode,
    lineWidth: this.lineWidth,
    frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
    uniforms: Object.assign({}, this.defaultUniforms, uniforms),
    viewport: this._viewport,
    clear: this.clear
  }, options);
};

GlslSource.compileHeader = function (precision, uniforms = {}, utils = {}) {
  return `
  precision ${precision} float;
  ${Object.values(uniforms).map(uniform => {
    let type = uniform.type;

    switch (uniform.type) {
      case 'texture':
        type = 'sampler2D';
        break;
    }

    return `
      uniform ${type} ${uniform.name};`;
  }).join('')}
  uniform float time;
  uniform vec2 resolution;
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  uniform sampler2D prevBuffer;
  
  ${Object.values(utils).map(transform => {
    //  console.log(transform.glsl)
    return `
            ${transform.glsl}
          `;
  }).join('')}
  `;
};

GlslSource.compileFrag = function (precision, shaderInfo, utils) {
  const header = this.compileHeader(precision, shaderInfo.uniforms, utils);
  return header + `
  
  ${shaderInfo.glslFunctions.map(transform => {
    return `
            ${transform.transform.glsl}
          `;
  }).join('')}

  void main () {
    vec4 c = vec4(1, 0, 0, 1);
    //vec2 st = gl_FragCoord.xy/resolution.xy;
    vec2 st = vuv;
    gl_FragColor = ${shaderInfo.fragColor};
  }
  `;
};

GlslSource.compileVert = function (precision, useCamera, transform, shaderInfo, utils) {
  const useUV = typeof transform.useUV !== 'undefined' ? transform.useUV : !transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1;
  const useNormal = typeof transform.useNormal !== 'undefined' ? transform.useNormal : transform.type === 'vert' && (!transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1);
  let vertHeader = `
  precision ${precision} float;
  uniform mat4 projection, view;
  attribute vec3 position;
  ${useUV ? 'attribute vec2 uv;' : ''}
  ${useNormal ? 'attribute vec3 normal;' : ''}
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  `;
  let vertFn = `
  void ${transform.glslName}() {
    vposition = position;
    gl_Position = ${useCamera ? 'projection * view * ' : ''}vec4(position, 1.0);
  } 
  `;
  let vertCall = `${transform.glslName}();`;

  if (transform.vert) {
    vertHeader = this.compileHeader(precision, shaderInfo.uniforms, utils) + `
    uniform mat4 projection, view;
    attribute vec3 position;
    ${useUV ? 'attribute vec2 uv;' : ''}
    ${useNormal ? 'attribute vec3 normal;' : ''}
    
    ${shaderInfo.glslFunctions.map(trans => {
      if (trans.transform.name !== transform.name) {
        return `
            ${trans.transform.glsl}
          `;
      }
    }).join('')}
    `;
    vertFn = transform.vert;
    vertCall = `
    ${useUV ? 'vec2 st = uv;' : 'vec2 st = position.xy;'}
    vposition = ${shaderInfo.position}.xyz;
    gl_Position = projection * view * vec4(vposition, 1.0);
    `;
  }

  return vertHeader + `
    
  ${vertFn}

  void main () {
    ${useUV ? 'vuv = uv;' : ''}
    ${useNormal ? 'vnormal = normal;' : ''}
    ${vertCall}
  }`;
}; // todo: make hydra-synth function


GlslSource.prototype.setBlend = function (blendMode = true) {
  this.blendMode = blendMode;
  return this;
};

GlslSource.prototype.setLineWidth = function (lineWidth) {
  this.lineWidth = lineWidth;
  return this;
};

GlslSource.prototype.setGeometry = function (input) {
  const isGeometry = v => v.isBufferGeometry || v.positions && v.edges;

  const isClass = v => typeof v === 'function' && /^\s*class\s+/.test(v.toString());

  if (!input) input = [];

  if (!isGeometry(input)) {
    if (!Array.isArray(input)) input = [input];

    if (isClass(this.transforms[0].transform.geometry)) {
      if (this.transforms[0].transform.geometry === GridGeometry && this.transforms[0].transform.primitive && typeof input[0] !== 'string') {
        input.unshift(this.transforms[0].transform.primitive);
      }

      input = new this.transforms[0].transform.geometry(...input);
    } else {
      if (vertTransform.transform.geometry === _vectorizeText.default && input.length === 1) {
        input.push({
          textAlign: 'center',
          textBaseline: 'middle' // font: 'arial',
          // triangles: true, // todo: make it work

        });
      }

      input = vertTransform.transform.geometry(...input);
    }
  }

  this.geometry = input;
};

GlslSource.prototype.viewport = function (x, y, w, h) {
  this._viewport = {
    x,
    y,
    w,
    h
  };
  return this;
};

GlslSource.prototype.setAutoClear = function (amount = 1.0, options = {}) {
  this.clear = {
    amount,
    ...options
  };
  return this;
};

GlslSource.prototype.st = function (source) {
  const self = this;
  source.transforms.map(transform => {
    if (transform.transform.type === 'genType') {
      transform.transform = (0, _types.replaceGenType)(transform.transform, 'coord');
    }

    self.transforms.push(transform);
  });
  return this;
};

const glslProps = ['x', 'y', 'z', 'xy', 'xz', 'yx', 'yz', 'zx', 'zy', 'xyz', 'xyzw'];
glslProps.map(prop => {
  Object.defineProperty(GlslSource.prototype, prop, {
    get() {
      this.getter = prop;
      return this;
    }

  });
});
var _default = GlslSource;
exports.default = _default;

},{"./generate-glsl.js":148,"./glsl/utility-functions.js":153,"./types.js":168,"vectorize-text":142}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridGeometry = void 0;

var _BufferGeometry = require("three/src/core/BufferGeometry");

var _BufferAttribute = require("three/src/core/BufferAttribute");

class GridGeometry extends _BufferGeometry.BufferGeometry {
  constructor(type, width, height, options) {
    super();
    this.type = 'GridGeometry';
    this.parameters = {
      primitive: type,
      width: width,
      height: height,
      options: options
    };
    let vertices;

    switch (type) {
      case 'points':
        {
          width || (width = 1);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return (k + 1) / 3 % width / width;

              case 1:
                return (Math.floor((k - 1) / 3 / width) + 0.5) / height;

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'lines':
        {
          width || (width = 0);
          height || (height = 0);
          const count = 2 * (width + height);
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            if (k < width * 6) {
              switch (k % 6) {
                case 0:
                  return (k + 3) / 6 % width / width;

                case 1:
                  return 0.0001;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return k / 6 % width / width;

                case 4:
                  return 0.9999;
              }
            } else {
              switch (k % 6) {
                case 0:
                  return 0.0001;

                case 1:
                  return (k + 2) / 6 % height / height;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return 0.9999;

                case 4:
                  return (k - 1) / 6 % height / height;
              }
            }
          });
          break;
        }

      case 'line strip':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          const closed = typeof options === 'undefined' ? true : options;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            // todo: will be NaN when points[0] == 1
            // todo: minimum 2 points?
            switch (k % 3) {
              case 0:
                return k / 3 % width / (width - closed);

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'line loop':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return k / 3 % width / width;

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      default:
        console.error(`invalid GridGeometry type: ${type}`);
        break;
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
  }

}

exports.GridGeometry = GridGeometry;

},{"three/src/core/BufferAttribute":120,"three/src/core/BufferGeometry":121}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
Format for adding functions to hydra. For each entry in this file, hydra automatically generates a glsl function and javascript function with the same name. You can also ass functions dynamically using setFunction(object).

{
  name: 'osc', // name that will be used to access function in js as well as in glsl
  type: 'src', // can be 'src', 'color', 'combine', 'combineCoords'. see below for more info
  inputs: [
    {
      name: 'freq',
      type: 'float',
      default: 0.2
    },
    {
      name: 'sync',
      type: 'float',
      default: 0.1
    },
    {
      name: 'offset',
      type: 'float',
      default: 0.0
    }
  ],
    glsl: `
      vec2 st = _st;
      float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
      float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
      float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
      return vec4(r, g, b, 1.0);
   `
}

// The above code generates the glsl function:
`vec4 osc(vec2 _st, float freq, float sync, float offset){
 vec2 st = _st;
 float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
 float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
 float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
 return vec4(r, g, b, 1.0);
}`


Types and default arguments for hydra functions.
The value in the 'type' field lets the parser know which type the function will be returned as well as default arguments.

const types = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
}

*/
var _default = () => [{
  name: 'noise',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 0.1
  }],
  glsl: `   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);`
}, {
  name: 'voronoi',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 5
  }, {
    type: 'float',
    name: 'speed',
    default: 0.3
  }, {
    type: 'float',
    name: 'blending',
    default: 0.3
  }],
  glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
}, {
  name: 'osc',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'frequency',
    default: 60
  }, {
    type: 'float',
    name: 'sync',
    default: 0.1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
}, {
  name: 'shape',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'sides',
    default: 3
  }, {
    type: 'float',
    name: 'radius',
    default: 0.3
  }, {
    type: 'float',
    name: 'smoothing',
    default: 0.01
  }],
  glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
}, {
  name: 'gradient',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   return vec4(_st, sin(time*speed), 1.0);`
}, {
  name: 'src',
  type: 'src',
  inputs: [{
    type: 'sampler2D',
    name: 'tex',
    default: NaN
  }],
  glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
}, {
  name: 'solid',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   return vec4(r, g, b, a);`
}, {
  name: 'solid3',
  type: 'src',
  inputs: [{
    type: 'vec3',
    name: 'rgb',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   return vec4(rgb, a);`
}, {
  name: 'rotate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'angle',
    default: 10
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `  vec2 xy = _st - vec2(0.5);
   // Convert degrees to radians
   float ang = angle * (3.141592653589793 / 180.0);
   ang = ang + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'scale',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.5
  }, {
    type: 'float',
    name: 'xMult',
    default: 1
  }, {
    type: 'float',
    name: 'yMult',
    default: 1
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
}, {
  name: 'pixelate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'pixelX',
    default: 20
  }, {
    type: 'float',
    name: 'pixelY',
    default: 20
  }],
  glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'posterize',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'bins',
    default: 3
  }, {
    type: 'float',
    name: 'gamma',
    default: 0.6
  }],
  glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
}, {
  name: 'shift',
  type: 'genType',
  inputs: [{
    type: 'vec4',
    name: 'val',
    default: 0.5
  }],
  glsl: `   vec4 c2 = vec4(_c0);
   c2 = fract(c2 + val);
   return c2;`
}, {
  name: 'repeat',
  type: 'genType',
  inputs: [{
    type: 'vec3',
    name: 'repeat',
    default: 3
  }, {
    type: 'vec3',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec3 c2 = _c0.rgb * repeat;
   c2 += step(1., mod(c2,2.0)) * offset;
   return vec4(fract(c2), _c0.a);`,
  coord: {
    inputs: [{
      type: 'vec2',
      name: 'repeat',
      default: 3
    }, {
      type: 'vec2',
      name: 'offset',
      default: 0
    }],
    glsl: ` vec2 st = _st * repeat;
            st += step(1., mod(st,2.0)) * offset;
            return fract(st);`
  }
}, {
  name: 'modulateRepeat',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
}, {
  name: 'repeatX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'repeatY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'kaleid',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
}, {
  name: 'modulateKaleid',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
}, {
  name: 'scroll',
  type: 'genType',
  inputs: [{
    type: 'vec3',
    name: 'scroll',
    default: 0.5
  }, {
    type: 'vec3',
    name: 'speed',
    default: 0
  }],
  glsl: `
   _c0.rgb += scroll + time*speed;
   return vec4(fract(_c0.rgb), _c0.a);`,
  coord: {
    inputs: [{
      type: 'vec2',
      name: 'scroll',
      default: 0.5
    }, {
      type: 'vec2',
      name: 'speed',
      default: 0
    }],
    glsl: `
        _st.xy += scroll + time*speed;
        return fract(_st);`
  }
}, {
  name: 'scrollX',
  type: 'genType',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _c0.x += scrollX + time*speed;
   return vec4(fract(_c0.x), _c0.y, _c0.z, _c0.a);`,
  coord: {
    glsl: `   _st.x += scrollX + time*speed;
          return fract(_st);`
  }
}, {
  name: 'modulateScrollX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'scrollY',
  type: 'genType',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _c0.y += scrollY + time*speed;
   return vec4(_c0.x, fract(_c0.y), _c0.z, _c0.a);`,
  coord: {
    glsl: `   _st.y += scrollY + time*speed;
          return fract(_st);`
  }
}, {
  name: 'modulateScrollY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'add',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0+_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'sub',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0-_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'layer',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));`
}, {
  name: 'blend',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.5
  }],
  glsl: `   return _c0*(1.0-amount)+_c1*amount;`
}, {
  name: 'mult',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _c0*(1.0-amount)+(_c0*_c1)*amount;`
}, {
  name: 'diff',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));`
}, {
  name: 'modulate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.1
  }],
  glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
}, {
  name: 'modulateScale',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 1
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
}, {
  name: 'modulatePixelate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 3
  }],
  glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'modulateRotate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'modulateHue',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);`
}, {
  name: 'invert',
  type: 'genType',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);`,
  coord: {
    glsl: `return (1.0-_st)*amount + _st*(1.0-amount);`
  }
}, {
  name: 'contrast',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.6
  }],
  glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
}, {
  name: 'brightness',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.4
  }],
  glsl: `   return vec4(_c0.rgb + vec3(amount), _c0.a);`
}, {
  name: 'mask',
  type: 'combine',
  inputs: [],
  glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
}, {
  name: 'luma',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.1
  }],
  glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
}, {
  name: 'thresh',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.04
  }],
  glsl: `   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);`
}, {
  name: 'color',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 1
  }, {
    type: 'float',
    name: 'g',
    default: 1
  }, {
    type: 'float',
    name: 'b',
    default: 1
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
}, {
  name: 'saturate',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 2
  }],
  glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
}, {
  name: 'hue',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'hue',
    default: 0.4
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
}, {
  name: 'colorama',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.005
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
}, {
  name: 'prev',
  type: 'src',
  inputs: [],
  glsl: `   return texture2D(prevBuffer, fract(_st));`
}, {
  name: 'sum',
  type: 'color',
  inputs: [{
    type: 'vec4',
    name: 'scale',
    default: 1
  }],
  glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
}, {
  name: 'r',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.r * scale + offset);`
}, {
  name: 'g',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.g * scale + offset);`
}, {
  name: 'b',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.b * scale + offset);`
}, {
  name: 'a',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.a * scale + offset);`
}, // todo: make these genType
// todo: the question is should genType behave like coord or like color, when piped?
{
  name: 'map',
  type: 'genType',
  inputs: [{
    name: 'start1',
    type: 'vec4',
    default: NaN
  }, {
    name: 'stop1',
    type: 'vec4',
    default: NaN
  }, {
    name: 'start2',
    type: 'vec4',
    default: 0
  }, {
    name: 'stop2',
    type: 'vec4',
    default: 1
  }],
  glsl: `return (_c0 - start1) / (stop1 - start1) * (stop2 - start2) + start2;`,
  coord: {
    inputs: [{
      name: 'start1',
      type: 'vec2',
      default: NaN
    }, {
      name: 'stop1',
      type: 'vec2',
      default: NaN
    }, {
      name: 'start2',
      type: 'vec2',
      default: 0
    }, {
      name: 'stop2',
      type: 'vec2',
      default: 1
    }],
    glsl: `return (_st - start1) / (stop1 - start1) * (stop2 - start2) + start2;`
  }
}, {
  name: 'sin',
  glslName: '_sin',
  type: 'genType',
  inputs: [{
    name: 'freq',
    type: 'vec3',
    default: 1.0
  }, {
    name: 'amp',
    type: 'vec3',
    default: 1.0
  }],
  glsl: `return vec4(sin(_c0.rgb * TWO_PI * freq) * amp, _c0.a);`,
  coord: {
    inputs: [{
      name: 'freq',
      type: 'vec2',
      default: 1.0
    }, {
      name: 'amp',
      type: 'vec2',
      default: 0.5
    }],
    glsl: `return sin(_st * TWO_PI * freq) * amp;`
  }
}, {
  name: 'cos',
  glslName: '_cos',
  type: 'genType',
  inputs: [{
    name: 'freq',
    type: 'vec3',
    default: 1
  }, {
    name: 'amp',
    type: 'vec3',
    default: 1
  }],
  glsl: `return vec4(cos(_c0.rgb * TWO_PI * freq) * amp, _c0.a);`,
  coord: {
    inputs: [{
      name: 'freq',
      type: 'vec2',
      default: 1
    }, {
      name: 'amp',
      type: 'vec2',
      default: 0.5
    }],
    glsl: `return cos(_st * TWO_PI * freq) * amp;`
  }
}, {
  name: 'tan',
  glslName: '_tan',
  type: 'genType',
  inputs: [{
    name: 'freq',
    type: 'vec3',
    default: 1
  }, {
    name: 'amp',
    type: 'vec3',
    default: 1.0
  }],
  glsl: `return vec4(tan(_c0.rgb * PI * freq) * amp, _c0.a);`,
  coord: {
    inputs: [{
      name: 'freq',
      type: 'vec2',
      default: 1
    }, {
      name: 'amp',
      type: 'vec2',
      default: 0.5
    }],
    glsl: `return tan(_st * PI * freq) * amp;`
  }
}, {
  name: 'atan',
  glslName: '_atan',
  type: 'genType',
  inputs: [{
    name: 'freq',
    type: 'vec3',
    default: 1
  }, {
    name: 'amp',
    type: 'vec3',
    default: 1
  }],
  glsl: `return vec4(atan(_c0.rgb * PI * freq) * amp, _c0.a);`,
  coord: {
    inputs: [{
      name: 'freq',
      type: 'vec2',
      default: 1
    }, {
      name: 'amp',
      type: 'vec2',
      default: 0.5
    }],
    glsl: `return atan(_st * PI * freq) * amp;`
  }
}, {
  name: 'pow',
  glslName: '_pow',
  type: 'genType',
  inputs: [{
    name: 'power',
    type: 'vec3',
    default: 2
  }],
  glsl: `return vec4(pow(_c0.rgb, power), _c0.a);`,
  coord: {
    inputs: [{
      name: 'power',
      type: 'vec2',
      default: 2
    }],
    glsl: `return pow(_st, power);`
  }
}, {
  name: 'scrollZ',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scrollZ',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _c0.y += scrollZ + time*speed;
        return fract(_c0);`
}, {
  name: 'glsl',
  type: 'glsl',
  inputs: [],
  glsl: ``
}];

exports.default = _default;

},{}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// functions that are only used within other functions
var _default = {
  _pi: {
    type: 'util',
    glsl: `#define PI 3.1415926535897932384626433832795`
  },
  _twopi: {
    type: 'util',
    glsl: `#define TWO_PI 6.283185307179586`
  },
  _luminance: {
    type: 'util',
    glsl: `float _luminance(vec3 rgb){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      return dot(rgb, W);
    }`
  },
  _permute: {
    type: 'util',
    glsl: `vec4 _permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}`
  },
  _mod289: {
    type: 'util',
    glsl: `
vec3 _mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 _mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}
`
  },
  _taylorInvSqrt: {
    type: 'util',
    glsl: `vec4 _taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}`
  },
  //	Simplex 3D Noise
  //	by Ian McEwan, Ashima Arts
  _noise: {
    type: 'util',
    glsl: `
  float _noise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = _permute( _permute( _permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
    `
  },
  _rgbToHsv: {
    type: 'util',
    glsl: `vec3 _rgbToHsv(vec3 c){
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }`
  },
  _hsvToRgb: {
    type: 'util',
    glsl: `vec3 _hsvToRgb(vec3 c){
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }`
  }
};
exports.default = _default;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GridGeometry = require("./geometries/GridGeometry.js");

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const glsl = require("glslify");

const pointsVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_POINTS\nvec4 points(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vPos = pos;\n    vSize = size;\n    vColor = color;\n    gl_PointSize = vSize;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linesVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_LINES\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linestripVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const lineloopVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const dotsFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 dots(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist = 0.5;\n    outColor.a = (1.0 - smoothstep(maxDist - fade, maxDist, dist)) * outColor.a;\n    if (outColor.a <= 0.0 || dist >= maxDist) {\n        discard;\n    }\n    return outColor;\n}"]);
const squaresFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 squares(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist;\n    // todo: need to be based on angle\n    //maxDist = length(vec2(0.5, 0.5));\n    //outColor.a = 1.0 - smoothstep(maxDist - fade, maxDist, dist);\n    return outColor;\n}"]);
const linesFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    return outColor;\n}"]);
const linestripFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const lineloopFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]); // todo: respect makeGlobal?

Object.assign(window, {
  GridGeometry: _GridGeometry.GridGeometry,
  vectorizeText: _vectorizeText.default
});

var _default = hy => [{
  name: 'dots',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 10
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: dotsFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'squares',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 1
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: squaresFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'lines',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: linesFrag,
  vert: linesVert,
  primitive: 'lines',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'linestrip',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: linestripFrag,
  vert: linestripVert,
  primitive: 'line strip',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'lineloop',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: lineloopFrag,
  vert: lineloopVert,
  primitive: 'line loop',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'text',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  geometry: _vectorizeText.default,
  useUV: false,
  useNormal: false
}];

exports.default = _default;

},{"./geometries/GridGeometry.js":151,"glslify":77,"vectorize-text":142}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _webcam = _interopRequireDefault(require("./lib/webcam.js"));

var _screenmedia = _interopRequireDefault(require("./lib/screenmedia.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HydraSource {
  constructor({
    regl,
    width,
    height,
    pb,
    label = ""
  }) {
    this.label = label;
    this.regl = regl;
    this.src = null;
    this.dynamic = true;
    this.width = width;
    this.height = height;
    this.tex = this.regl.texture({
      //  shape: [width, height]
      shape: [1, 1]
    });
    this.pb = pb;
  }

  init(opts, params) {
    if ('src' in opts) {
      this.src = opts.src;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    }

    if ('dynamic' in opts) this.dynamic = opts.dynamic;
  }

  initCam(index, params) {
    const self = this;
    (0, _webcam.default)(index).then(response => {
      self.src = response.video;
      self.dynamic = true;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
    }).catch(err => console.log('could not get camera', err));
  }

  initVideo(url = '', params) {
    // const self = this
    const vid = document.createElement('video');
    vid.crossOrigin = 'anonymous';
    vid.autoplay = true;
    vid.loop = true;
    vid.muted = true; // mute in order to load without user interaction

    const onload = vid.addEventListener('loadeddata', () => {
      this.src = vid;
      vid.play();
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
      this.dynamic = true;
    });
    vid.src = url;
  }

  initImage(url = '', params) {
    const img = document.createElement('img');
    img.crossOrigin = 'anonymous';
    img.src = url;

    img.onload = () => {
      this.src = img;
      this.dynamic = false;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    };
  }

  initStream(streamName, params) {
    //  console.log("initing stream!", streamName)
    let self = this;

    if (streamName && this.pb) {
      this.pb.initSource(streamName);
      this.pb.on('got video', function (nick, video) {
        if (nick === streamName) {
          self.src = video;
          self.dynamic = true;
          self.tex = self.regl.texture({
            data: self.src,
            ...params
          });
        }
      });
    }
  } // index only relevant in atom-hydra + desktop apps


  initScreen(index = 0, params) {
    const self = this;
    (0, _screenmedia.default)().then(function (response) {
      self.src = response.video;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
      self.dynamic = true; //  console.log("received screen input")
    }).catch(err => console.log('could not get screen', err));
  }

  resize(width, height) {
    this.width = width;
    this.height = height;
  }

  clear() {
    if (this.src && this.src.srcObject) {
      if (this.src.srcObject.getTracks) {
        this.src.srcObject.getTracks().forEach(track => track.stop());
      }
    }

    this.src = null;
    this.tex = this.regl.texture({
      shape: [1, 1]
    });
  }

  tick(time) {
    //  console.log(this.src, this.tex.width, this.tex.height)
    if (this.src !== null && this.dynamic === true) {
      if (this.src.videoWidth && this.src.videoWidth !== this.tex.width) {
        console.log(this.src.videoWidth, this.src.videoHeight, this.tex.width, this.tex.height);
        this.tex.resize(this.src.videoWidth, this.src.videoHeight);
      }

      if (this.src.width && this.src.width !== this.tex.width) {
        this.tex.resize(this.src.width, this.src.height);
      }

      this.tex.subimage(this.src);
    }
  }

  getTexture() {
    return this.tex;
  }

}

var _default = HydraSource;
exports.default = _default;

},{"./lib/screenmedia.js":164,"./lib/webcam.js":166}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _output = _interopRequireDefault(require("./output.js"));

var _rafLoop = _interopRequireDefault(require("raf-loop"));

var _hydraSource = _interopRequireDefault(require("./hydra-source.js"));

var _mouse = _interopRequireDefault(require("./lib/mouse.js"));

var _audio = _interopRequireDefault(require("./lib/audio.js"));

var _videoRecorder = _interopRequireDefault(require("./lib/video-recorder.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _evalSandbox = _interopRequireDefault(require("./eval-sandbox.js"));

var _generatorFactory = _interopRequireDefault(require("./generator-factory.js"));

var _regl = _interopRequireDefault(require("regl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import strudel from './lib/strudel.js'
// const window = global.window
const Mouse = (0, _mouse.default)(); // to do: add ability to pass in certain uniforms and transforms

class HydraRenderer {
  constructor({
    pb = null,
    width = 1280,
    height = 720,
    numSources = 4,
    numOutputs = 4,
    makeGlobal = true,
    autoLoop = true,
    detectAudio = true,
    enableStreamCapture = true,
    canvas,
    precision,
    extendTransforms = {} // add your own functions on init

  } = {}) {
    _arrayUtils.default.init();

    this.pb = pb;
    this.width = width;
    this.height = height;
    this.renderAll = false;
    this.detectAudio = detectAudio;

    this._initCanvas(canvas); //global.window.test = 'hi'
    // object that contains all properties that will be made available on the global context and during local evaluation


    this.synth = {
      time: 0,
      bpm: 30,
      width: this.width,
      height: this.height,
      fps: undefined,
      stats: {
        fps: 0
      },
      speed: 1,
      mouse: Mouse,
      render: this._render.bind(this),
      setResolution: this.setResolution.bind(this),
      update: dt => {},
      // user defined update function
      hush: this.hush.bind(this),
      tick: this.tick.bind(this)
    };

    if (makeGlobal) {
      window.loadScript = this.loadScript;

      window.getCode = () => {
        const urlParams = new URLSearchParams(window.location.search);
        console.log(decodeURIComponent(urlParams.get('code')));
      };
    }

    this.timeSinceLastUpdate = 0;
    this._time = 0; // for internal use, only to use for deciding when to render frames
    // only allow valid precision options

    let precisionOptions = ['lowp', 'mediump', 'highp'];

    if (precision && precisionOptions.includes(precision.toLowerCase())) {
      this.precision = precision.toLowerCase(); //
      // if(!precisionValid){
      //   console.warn('[hydra-synth warning]\nConstructor was provided an invalid floating point precision value of "' + precision + '". Using default value of "mediump" instead.')
      // }
    } else {
      let isIOS = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream;
      this.precision = isIOS ? 'highp' : 'mediump';
    }

    this.extendTransforms = extendTransforms; // boolean to store when to save screenshot

    this.saveFrame = false; // if stream capture is enabled, this object contains the capture stream

    this.captureStream = null;
    this.generator = undefined;

    this._initRegl();

    this._initOutputs(numOutputs);

    this._initSources(numSources);

    this._generateGlslTransforms();

    this.synth.screencap = () => {
      this.saveFrame = true;
    };

    if (enableStreamCapture) {
      try {
        this.captureStream = this.canvas.captureStream(25); // to do: enable capture stream of specific sources and outputs

        this.synth.vidRecorder = new _videoRecorder.default(this.captureStream);
      } catch (e) {
        console.warn('[hydra-synth warning]\nnew MediaSource() is not currently supported on iOS.');
        console.error(e);
      }
    }

    if (detectAudio) this._initAudio();
    if (autoLoop) (0, _rafLoop.default)(this.tick.bind(this)).start(); // final argument is properties that the user can set, all others are treated as read-only

    this.sandbox = new _evalSandbox.default(this.synth, makeGlobal, ['speed', 'update', 'bpm', 'fps']);
  }

  eval(code) {
    this.sandbox.eval(code);
  }

  getScreenImage(callback) {
    this.imageCallback = callback;
    this.saveFrame = true;
  }

  hush() {
    this.s.forEach(source => {
      source.clear();
    });
    this.o.forEach(output => {
      this.synth.solid(0, 0, 0, 0).out(output);
    });
    this.synth.render(this.o[0]); // this.synth.update = (dt) => {}

    this.sandbox.set('update', dt => {});
  }

  loadScript(url = "", once = true) {
    const self = this || window;
    const p = new Promise((res, rej) => {
      if (once) {
        self.loadedScripts || (self.loadedScripts = {});

        if (self.loadedScripts[url]) {
          res();
          return;
        }
      }

      var script = document.createElement("script");

      script.onload = function () {
        console.log(`loaded script ${url}`);

        if (once) {
          self.loadedScripts[url] = true;
        }

        res();
      };

      script.onerror = err => {
        console.log(`error loading script ${url}`, "log-error");
        res();
      };

      script.src = url;
      document.head.appendChild(script);
    });
    return p;
  }

  setResolution(width, height) {
    //  console.log(width, height)
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width; // is this necessary?

    this.height = height; // ?

    this.sandbox.set('width', width);
    this.sandbox.set('height', height);
    this.o.forEach(output => {
      output.resize(width, height);
    });
    this.s.forEach(source => {
      source.resize(width, height);
    });

    this.regl._refresh();

    console.log(this.canvas.width);
  }

  canvasToImage(callback) {
    const a = document.createElement('a');
    a.style.display = 'none';
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.png`;
    document.body.appendChild(a);
    var self = this;
    this.canvas.toBlob(blob => {
      if (self.imageCallback) {
        self.imageCallback(blob);
        delete self.imageCallback;
      } else {
        a.href = URL.createObjectURL(blob);
        console.log(a.href);
        a.click();
      }
    }, 'image/png');
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(a.href);
    }, 300);
  }

  _initAudio() {
    const that = this;
    this.synth.a = new _audio.default({
      numBins: 4,
      parentEl: this.canvas.parentNode // changeListener: ({audio}) => {
      //   that.a = audio.bins.map((_, index) =>
      //     (scale = 1, offset = 0) => () => (audio.fft[index] * scale + offset)
      //   )
      //
      //   if (that.makeGlobal) {
      //     that.a.forEach((a, index) => {
      //       const aname = `a${index}`
      //       window[aname] = a
      //     })
      //   }
      // }

    });
  } // create main output canvas and add to screen


  _initCanvas(canvas) {
    if (canvas) {
      this.canvas = canvas;
      this.width = canvas.width;
      this.height = canvas.height;
    } else {
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.canvas.style.imageRendering = 'pixelated';
      document.body.appendChild(this.canvas);
    }
  }

  _initRegl() {
    this.regl = (0, _regl.default)({
      //  profile: true,
      canvas: this.canvas,
      pixelRatio: 1,
      optionalExtensions: ['oes_texture_half_float', 'oes_texture_half_float_linear', 'oes_texture_float', 'oes_texture_float_linear']
    }); // This clears the color buffer to black and the depth buffer to 1

    this.regl.clear({
      color: [0, 0, 0, 1]
    });
    this.renderAll = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;
      uniform sampler2D tex1;
      uniform sampler2D tex2;
      uniform sampler2D tex3;

      void main () {
        vec2 st = vec2(1.0 - uv.x, uv.y);
        st*= vec2(2);
        vec2 q = floor(st).xy*(vec2(2.0, 1.0));
        int quad = int(q.x) + int(q.y);
        st.x += step(1., mod(st.y,2.0));
        st.y += step(1., mod(st.x,2.0));
        st = fract(st);
        if(quad==0){
          gl_FragColor = texture2D(tex0, st);
        } else if(quad==1){
          gl_FragColor = texture2D(tex1, st);
        } else if (quad==2){
          gl_FragColor = texture2D(tex2, st);
        } else {
          gl_FragColor = texture2D(tex3, st);
        }

      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        tex1: this.regl.prop('tex1'),
        tex2: this.regl.prop('tex2'),
        tex3: this.regl.prop('tex3')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
    this.renderFbo = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform vec2 resolution;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, vec2(1.0 - uv.x, uv.y));
      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        resolution: this.regl.prop('resolution')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
  }

  _initOutputs(numOutputs) {
    const self = this;
    this.o = Array(numOutputs).fill().map((el, index) => {
      var o = new _output.default(index, this);
      self.synth['o' + index] = o;
      return o;
    }); // set default output

    this.output = this.o[0];
  }

  _initSources(numSources) {
    this.s = [];

    for (var i = 0; i < numSources; i++) {
      this.createSource(i);
    }
  }

  createSource(i) {
    let s = new _hydraSource.default({
      regl: this.regl,
      pb: this.pb,
      width: this.width,
      height: this.height,
      label: `s${i}`
    });
    this.synth['s' + this.s.length] = s;
    this.s.push(s);
    return s;
  }

  _generateGlslTransforms() {
    var self = this;
    this.generator = new _generatorFactory.default({
      defaultOutput: this.o[0],
      defaultUniforms: this.o[0].uniforms,
      extendTransforms: this.extendTransforms,
      changeListener: ({
        type,
        method,
        synth
      }) => {
        if (type === 'add') {
          self.synth[method] = synth.generators[method];
          if (self.sandbox) self.sandbox.add(method);
        } else if (type === 'remove') {// what to do here? dangerously deleting window methods
          //delete window[method]
        } //  }

      }
    });
    this.synth.setFunction = this.generator.setFunction.bind(this.generator);
  }

  _render(output) {
    if (output) {
      this.output = output;
      this.isRenderingAll = false;
    } else {
      this.isRenderingAll = true;
    }
  }

  _renderOut(i) {
    this.o[i].tick({
      time: this.synth.time,
      mouse: this.synth.mouse,
      bpm: this.synth.bpm,
      resolution: [this.canvas.width, this.canvas.height]
    });
  } // dt in ms


  tick(dt, uniforms) {
    this.sandbox.tick();
    if (this.detectAudio === true) this.synth.a.tick(); //  let updateInterval = 1000/this.synth.fps // ms

    this.sandbox.set('time', this.synth.time += dt * 0.001 * this.synth.speed);
    this.timeSinceLastUpdate += dt;

    if (!this.synth.fps || this.timeSinceLastUpdate >= 1000 / this.synth.fps) {
      //  console.log(1000/this.timeSinceLastUpdate)
      this.synth.stats.fps = Math.ceil(1000 / this.timeSinceLastUpdate);

      if (this.synth.update) {
        try {
          this.synth.update(this.timeSinceLastUpdate);
        } catch (e) {
          console.log(e);
        }
      } //  console.log(this.synth.speed, this.synth.time)


      for (let i = 0; i < this.s.length; i++) {
        this.s[i].tick(this.synth.time);
      } //  console.log(this.canvas.width, this.canvas.height)


      for (let i = 0; i < this.o.length; i++) {
        this._renderOut(i);
      }

      if (this.isRenderingAll) {
        this.renderAll({
          tex0: this.o[0].getCurrent(),
          tex1: this.o[1].getCurrent(),
          tex2: this.o[2].getCurrent(),
          tex3: this.o[3].getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      } else {
        this.renderFbo({
          tex0: this.output.getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      }

      this.timeSinceLastUpdate = 0;
    }

    if (this.saveFrame === true) {
      this.canvasToImage();
      this.saveFrame = false;
    } //  this.regl.poll()

  }

}

var _default = HydraRenderer;
exports.default = _default;

},{"./eval-sandbox.js":146,"./generator-factory.js":149,"./hydra-source.js":155,"./lib/array-utils.js":158,"./lib/audio.js":159,"./lib/mouse.js":162,"./lib/video-recorder.js":165,"./output.js":167,"raf-loop":96,"regl":102}],157:[function(require,module,exports){
"use strict";

var _hydraSynth = _interopRequireDefault(require("./hydra-synth.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import ShaderGenerator = require('./shader-generator.js')
// alert('hi')
// export default Synth
module.exports = _hydraSynth.default;

},{"./hydra-synth.js":156}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _easingFunctions = _interopRequireDefault(require("./easing-functions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// WIP utils for working with arrays
// Possibly should be integrated with lfo extension, etc.
// to do: transform time rather than array values, similar to working with coordinates in hydra
var map = (num, in_min, in_max, out_min, out_max) => {
  return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};

var _default = {
  init: () => {
    Array.prototype.fast = function (speed = 1) {
      this._speed = speed;
      return this;
    };

    Array.prototype.smooth = function (smooth = 1) {
      this._smooth = smooth;
      return this;
    };

    Array.prototype.ease = function (ease = 'linear') {
      if (typeof ease == 'function') {
        this._smooth = 1;
        this._ease = ease;
      } else if (_easingFunctions.default[ease]) {
        this._smooth = 1;
        this._ease = _easingFunctions.default[ease];
      }

      return this;
    };

    Array.prototype.offset = function (offset = 0.5) {
      this._offset = offset % 1.0;
      return this;
    }; // Array.prototype.bounce = function() {
    //   this.modifiers.bounce = true
    //   return this
    // }


    Array.prototype.fit = function (low = 0, high = 1) {
      let lowest = Math.min(...this);
      let highest = Math.max(...this);
      var newArr = this.map(num => map(num, lowest, highest, low, high));
      newArr._speed = this._speed;
      newArr._smooth = this._smooth;
      newArr._ease = this._ease;
      return newArr;
    };
  },
  getValue: (arr = []) => ({
    time,
    bpm
  }) => {
    let speed = arr._speed ? arr._speed : 1;
    let smooth = arr._smooth ? arr._smooth : 0;
    let index = time * speed * (bpm / 60) + (arr._offset || 0);

    if (smooth !== 0) {
      let ease = arr._ease ? arr._ease : _easingFunctions.default['linear'];

      let _index = index - smooth / 2;

      let currValue = arr[Math.floor(_index % arr.length)];
      let nextValue = arr[Math.floor((_index + 1) % arr.length)];
      let t = Math.min(_index % 1 / smooth, 1);
      return ease(t) * (nextValue - currValue) + currValue;
    } else {
      return arr[Math.floor(index % arr.length)];
    }
  }
};
exports.default = _default;

},{"./easing-functions.js":160}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _meyda = _interopRequireDefault(require("meyda"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Audio {
  constructor({
    numBins = 4,
    cutoff = 2,
    smooth = 0.4,
    max = 15,
    scale = 10,
    isDrawing = false,
    parentEl = document.body
  }) {
    this.vol = 0;
    this.scale = scale;
    this.max = max;
    this.cutoff = cutoff;
    this.smooth = smooth;
    this.setBins(numBins); // beat detection from: https://github.com/therewasaguy/p5-music-viz/blob/gh-pages/demos/01d_beat_detect_amplitude/sketch.js

    this.beat = {
      holdFrames: 20,
      threshold: 40,
      _cutoff: 0,
      // adaptive based on sound state
      decay: 0.98,
      _framesSinceBeat: 0 // keeps track of frames

    };

    this.onBeat = () => {//  console.log("beat")
    };

    this.canvas = document.createElement('canvas');
    this.canvas.width = 100;
    this.canvas.height = 80;
    this.canvas.style.width = "100px";
    this.canvas.style.height = "80px";
    this.canvas.style.position = 'absolute';
    this.canvas.style.right = '0px';
    this.canvas.style.bottom = '0px';
    parentEl.appendChild(this.canvas);
    this.isDrawing = isDrawing;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.fillStyle = "#DFFFFF";
    this.ctx.strokeStyle = "#0ff";
    this.ctx.lineWidth = 0.5;

    if (window.navigator.mediaDevices) {
      window.navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      }).then(stream => {
        //  console.log('got mic stream', stream)
        this.stream = stream;
        this.context = new AudioContext(); //  this.context = new AudioContext()

        let audio_stream = this.context.createMediaStreamSource(stream); //  console.log(this.context)

        this.meyda = _meyda.default.createMeydaAnalyzer({
          audioContext: this.context,
          source: audio_stream,
          featureExtractors: ['loudness' //  'perceptualSpread',
          //  'perceptualSharpness',
          //  'spectralCentroid'
          ]
        });
      }).catch(err => console.log('ERROR', err));
    }
  }

  detectBeat(level) {
    //console.log(level,   this.beat._cutoff)
    if (level > this.beat._cutoff && level > this.beat.threshold) {
      this.onBeat();
      this.beat._cutoff = level * 1.2;
      this.beat._framesSinceBeat = 0;
    } else {
      if (this.beat._framesSinceBeat <= this.beat.holdFrames) {
        this.beat._framesSinceBeat++;
      } else {
        this.beat._cutoff *= this.beat.decay;
        this.beat._cutoff = Math.max(this.beat._cutoff, this.beat.threshold);
      }
    }
  }

  tick() {
    if (this.meyda) {
      var features = this.meyda.get();

      if (features && features !== null) {
        this.vol = features.loudness.total;
        this.detectBeat(this.vol); // reduce loudness array to number of bins

        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        let spacing = Math.floor(features.loudness.specific.length / this.bins.length);
        this.prevBins = this.bins.slice(0);
        this.bins = this.bins.map((bin, index) => {
          return features.loudness.specific.slice(index * spacing, (index + 1) * spacing).reduce(reducer);
        }).map((bin, index) => {
          // map to specified range
          // return (bin * (1.0 - this.smooth) + this.prevBins[index] * this.smooth)
          return bin * (1.0 - this.settings[index].smooth) + this.prevBins[index] * this.settings[index].smooth;
        }); // var y = this.canvas.height - scale*this.settings[index].cutoff
        // this.ctx.beginPath()
        // this.ctx.moveTo(index*spacing, y)
        // this.ctx.lineTo((index+1)*spacing, y)
        // this.ctx.stroke()
        //
        // var yMax = this.canvas.height - scale*(this.settings[index].scale + this.settings[index].cutoff)

        this.fft = this.bins.map((bin, index) => // Math.max(0, (bin - this.cutoff) / (this.max - this.cutoff))
        Math.max(0, (bin - this.settings[index].cutoff) / this.settings[index].scale));
        if (this.isDrawing) this.draw();
      }
    }
  }

  setCutoff(cutoff) {
    this.cutoff = cutoff;
    this.settings = this.settings.map(el => {
      el.cutoff = cutoff;
      return el;
    });
  }

  setSmooth(smooth) {
    this.smooth = smooth;
    this.settings = this.settings.map(el => {
      el.smooth = smooth;
      return el;
    });
  }

  setBins(numBins) {
    this.bins = Array(numBins).fill(0);
    this.prevBins = Array(numBins).fill(0);
    this.fft = Array(numBins).fill(0);
    this.settings = Array(numBins).fill(0).map(() => ({
      cutoff: this.cutoff,
      scale: this.scale,
      smooth: this.smooth
    })); // to do: what to do in non-global mode?

    this.bins.forEach((bin, index) => {
      window['a' + index] = (scale = 1, offset = 0) => () => a.fft[index] * scale + offset;
    }); //  console.log(this.settings)
  }

  setScale(scale) {
    this.scale = scale;
    this.settings = this.settings.map(el => {
      el.scale = scale;
      return el;
    });
  }

  setMax(max) {
    this.max = max;
    console.log('set max is deprecated');
  }

  hide() {
    this.isDrawing = false;
    this.canvas.style.display = 'none';
  }

  show() {
    this.isDrawing = true;
    this.canvas.style.display = 'block';
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    var spacing = this.canvas.width / this.bins.length;
    var scale = this.canvas.height / (this.max * 2); //  console.log(this.bins)

    this.bins.forEach((bin, index) => {
      var height = bin * scale;
      this.ctx.fillRect(index * spacing, this.canvas.height - height, spacing, height); //   console.log(this.settings[index])

      var y = this.canvas.height - scale * this.settings[index].cutoff;
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, y);
      this.ctx.lineTo((index + 1) * spacing, y);
      this.ctx.stroke();
      var yMax = this.canvas.height - scale * (this.settings[index].scale + this.settings[index].cutoff);
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, yMax);
      this.ctx.lineTo((index + 1) * spacing, yMax);
      this.ctx.stroke();
    });
    /*var y = this.canvas.height - scale*this.cutoff
    this.ctx.beginPath()
    this.ctx.moveTo(0, y)
    this.ctx.lineTo(this.canvas.width, y)
    this.ctx.stroke()
    var yMax = this.canvas.height - scale*this.max
    this.ctx.beginPath()
    this.ctx.moveTo(0, yMax)
    this.ctx.lineTo(this.canvas.width, yMax)
    this.ctx.stroke()*/
  }

}

var _default = Audio;
exports.default = _default;

},{"meyda":84}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// from https://gist.github.com/gre/1650294
var _default = {
  // no easing, no acceleration
  linear: function (t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function (t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  },
  // sin shape
  sin: function (t) {
    return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;
  }
};
exports.default = _default;

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// https://github.com/mikolalysenko/mouse-event
const mouse = {};

function mouseButtons(ev) {
  if (typeof ev === 'object') {
    if ('buttons' in ev) {
      return ev.buttons;
    } else if ('which' in ev) {
      var b = ev.which;

      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ('button' in ev) {
      var b = ev.button;

      if (b === 1) {
        return 4;
      } else if (b === 2) {
        return 2;
      } else if (b >= 0) {
        return 1 << b;
      }
    }
  }

  return 0;
}

mouse.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window;
}

mouse.element = mouseElement;

function mouseRelativeX(ev) {
  if (typeof ev === 'object') {
    if ('pageX' in ev) {
      return ev.pageX;
    }
  }

  return 0;
}

mouse.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if (typeof ev === 'object') {
    if ('pageY' in ev) {
      return ev.pageY;
    }
  }

  return 0;
}

mouse.y = mouseRelativeY;
var _default = mouse;
exports.default = _default;

},{}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mouseEvent = _interopRequireDefault(require("./mouse-event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://github.com/mikolalysenko/mouse-change
var _default = mouseListen;
exports.default = _default;

function mouseListen(element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods(ev) {
    var changed = false;

    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }

    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }

    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }

    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }

    return changed;
  }

  function handleEvent(nextButtons, ev) {
    var nextX = _mouseEvent.default.x(ev);

    var nextY = _mouseEvent.default.y(ev);

    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }

    if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState(ev) {
    handleEvent(0, ev);
  }

  function handleBlur() {
    if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods(ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove(ev) {
    if (_mouseEvent.default.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown(ev) {
    handleEvent(buttonState | _mouseEvent.default.buttons(ev), ev);
  }

  function handleMouseUp(ev) {
    handleEvent(buttonState & ~_mouseEvent.default.buttons(ev), ev);
  }

  function attachListeners() {
    if (attached) {
      return;
    }

    attached = true;
    element.addEventListener('mousemove', handleMouseMove);
    element.addEventListener('mousedown', handleMouseDown);
    element.addEventListener('mouseup', handleMouseUp);
    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);
    element.addEventListener('blur', handleBlur);
    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);
      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners() {
    if (!attached) {
      return;
    }

    attached = false;
    element.removeEventListener('mousemove', handleMouseMove);
    element.removeEventListener('mousedown', handleMouseDown);
    element.removeEventListener('mouseup', handleMouseUp);
    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);
    element.removeEventListener('blur', handleBlur);
    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  } // Attach listeners


  attachListeners();
  var result = {
    element: element
  };
  Object.defineProperties(result, {
    enabled: {
      get: function () {
        return attached;
      },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () {
        return buttonState;
      },
      enumerable: true
    },
    x: {
      get: function () {
        return x;
      },
      enumerable: true
    },
    y: {
      get: function () {
        return y;
      },
      enumerable: true
    },
    mods: {
      get: function () {
        return mods;
      },
      enumerable: true
    }
  });
  return result;
}

},{"./mouse-event.js":161}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// attempt custom evaluation sandbox for hydra functions
// for now, just avoids polluting the global namespace
// should probably be replaced with an abstract syntax tree
var _default = parent => {
  var initialCode = ``;
  var sandbox = createSandbox(initialCode);

  var addToContext = (name, object) => {
    initialCode += `
      var ${name} = ${object}
    `;
    sandbox = createSandbox(initialCode);
  };

  return {
    addToContext: addToContext,
    eval: code => sandbox.eval(code)
  };

  function createSandbox(initial) {
    globalThis.eval(initial); // optional params

    var localEval = function (code) {
      globalThis.eval(code);
    }; // API/data for end-user


    return {
      eval: localEval
    };
  }
};

exports.default = _default;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(options) {
  return new Promise(function (resolve, reject) {
    //  async function startCapture(displayMediaOptions) {
    navigator.mediaDevices.getDisplayMedia(options).then(stream => {
      const video = document.createElement('video');
      video.srcObject = stream;
      video.addEventListener('loadedmetadata', () => {
        video.play();
        resolve({
          video: video
        });
      });
    }).catch(err => reject(err));
  });
}

},{}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class VideoRecorder {
  constructor(stream) {
    this.mediaSource = new MediaSource();
    this.stream = stream; // testing using a recording as input

    this.output = document.createElement('video');
    this.output.autoplay = true;
    this.output.loop = true;
    let self = this;
    this.mediaSource.addEventListener('sourceopen', () => {
      console.log('MediaSource opened');
      self.sourceBuffer = self.mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      console.log('Source buffer: ', sourceBuffer);
    });
  }

  start() {
    //  let options = {mimeType: 'video/webm'};
    //   let options = {mimeType: 'video/webm;codecs=h264'};
    let options = {
      mimeType: 'video/webm;codecs=vp9'
    };
    this.recordedBlobs = [];

    try {
      this.mediaRecorder = new MediaRecorder(this.stream, options);
    } catch (e0) {
      console.log('Unable to create MediaRecorder with options Object: ', e0);

      try {
        options = {
          mimeType: 'video/webm,codecs=vp9'
        };
        this.mediaRecorder = new MediaRecorder(this.stream, options);
      } catch (e1) {
        console.log('Unable to create MediaRecorder with options Object: ', e1);

        try {
          options = 'video/vp8'; // Chrome 47

          this.mediaRecorder = new MediaRecorder(this.stream, options);
        } catch (e2) {
          alert('MediaRecorder is not supported by this browser.\n\n' + 'Try Firefox 29 or later, or Chrome 47 or later, ' + 'with Enable experimental Web Platform features enabled from chrome://flags.');
          console.error('Exception while creating MediaRecorder:', e2);
          return;
        }
      }
    }

    console.log('Created MediaRecorder', this.mediaRecorder, 'with options', options);
    this.mediaRecorder.onstop = this._handleStop.bind(this);
    this.mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this.mediaRecorder.start(100); // collect 100ms of data

    console.log('MediaRecorder started', this.mediaRecorder);
  }

  stop() {
    this.mediaRecorder.stop();
  }

  _handleStop() {
    //const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'})
    // const blob = new Blob(this.recordedBlobs, {type: 'video/webm;codecs=h264'})
    const blob = new Blob(this.recordedBlobs, {
      type: this.mediaRecorder.mimeType
    });
    const url = window.URL.createObjectURL(blob);
    this.output.src = url;
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.webm`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 300);
  }

  _handleDataAvailable(event) {
    if (event.data && event.data.size > 0) {
      this.recordedBlobs.push(event.data);
    }
  }

}

var _default = VideoRecorder;
exports.default = _default;

},{}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

//const enumerateDevices = require('enumerate-devices')
function _default(deviceId) {
  return navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(devices => devices.kind === 'videoinput')).then(cameras => {
    let constraints = {
      audio: false,
      video: true
    };

    if (cameras[deviceId]) {
      constraints['video'] = {
        deviceId: {
          exact: cameras[deviceId].deviceId
        }
      };
    } //  console.log(cameras)


    return window.navigator.mediaDevices.getUserMedia(constraints);
  }).then(stream => {
    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.setAttribute('playsinline', ''); //  video.src = window.URL.createObjectURL(stream)

    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.addEventListener('loadedmetadata', () => {
        video.play().then(() => resolve({
          video: video
        }));
      });
    });
  }).catch(console.log.bind(console));
}

},{}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var mat4 = _interopRequireWildcard(require("gl-mat4"));

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Output = function (index, synth) {
  this.id = index;
  this.synth = synth;
  this.width = synth.width;
  this.height = synth.height;
  this.regl = synth.regl;
  this.precision = synth.precision;
  this.label = `o${index}`;
  this.positionBuffer = this.regl.buffer([[-5, -1, 0], [-1, -5, 0], [3, 3, 0]]);
  this.uvBuffer = this.regl.buffer([[-2, 0], [0, -2], [2, 2]]);
  this.draw = [];
  this.init();
  this.pingPongIndex = 0;
  this.initFbos();
  this.copyPass = this.regl({
    frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, uv);
      }
      `,
    vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(2.0 * position - 1.0, 0, 1);
      }`,
    attributes: {
      position: [[-2, 0], [0, -2], [2, 2]]
    },
    uniforms: {
      tex0: this.regl.prop('tex0')
    },
    count: 3,
    depth: {
      enable: false
    },
    framebuffer: () => this.getTexture()
  });
};

Output.prototype._initFbo = function (options = {}) {
  let {
    color,
    ...fbOptions
  } = options;
  color = Object.assign({
    mag: 'nearest',
    width: this.width,
    height: this.height,
    format: 'rgba'
  }, color || {});
  fbOptions = Object.assign({
    depthStencil: false
  }, fbOptions);
  return this.regl.framebuffer({
    color: this.regl.texture(color),
    ...fbOptions
  });
};

Output.prototype.initFbos = function (options = {}) {
  // for each output, create two fbos for pingponging
  this.fbos = Array(2).fill().map(() => this._initFbo(options)); // for each output, create two temp buffers

  this.temp = Array(2).fill().map(() => this._initFbo(options));
};

Output.prototype.initFloat = function (options = {}) {
  let {
    color,
    ...fbOptions
  } = options;
  color = Object.assign({
    type: this.regl.hasExtension('oes_texture_float') ? 'float' : this.regl.hasExtension('oes_texture_half_float' ? 'half float' : 'uint8')
  }, color || {});
  this.initFbos(Object.assign(options, {
    color: color,
    ...fbOptions
  }));
};

Output.prototype.resize = function (width, height) {
  this.width = width;
  this.height = height;
  this.fbos.forEach(fbo => {
    fbo.resize(width, height);
  });
  this.temp.forEach(tmp => {
    tmp.resize(width, height);
  });
};

Output.prototype.getCurrent = function () {
  return this.fbos[this.pingPongIndex];
};

Output.prototype.getTexture = function () {
  var index = this.pingPongIndex ? 0 : 1;
  return this.fbos[index];
};

Output.prototype.init = function () {
  this.attributes = {
    position: this.positionBuffer,
    uv: this.uvBuffer
  };
  this.uniforms = {
    time: this.regl.prop('time'),
    resolution: this.regl.prop('resolution')
  };
  this.initCamera();
  return this;
};

Output.prototype.initCamera = function () {
  this._camera = this.regl({
    context: {
      projection: mat4.identity([]),
      view: mat4.identity([])
    },
    uniforms: {
      view: this.regl.context('view'),
      projection: this.regl.context('projection')
    }
  });
};

Output.prototype.camera = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    fovy: Math.PI / 4,
    near: 0.1,
    far: 1000.0
  }, options);
  this.eye = eye;
  this.target = target;

  if (eye && target) {
    this._camera = this.regl({
      context: {
        projection: function (context) {
          if (options.type === 'perspective') {
            return mat4.perspective([], options.fovy, options.aspect || context.viewportWidth / context.viewportHeight, options.near, options.far);
          } else {
            return mat4.ortho([], -1.0, 1.0, -1.0, 1.0, options.near, options.far);
          }
        },
        view: function (context, props) {
          return mat4.lookAt([], props.eye, props.target, [0, 1, 0]);
        },
        eye: this.regl.prop('eye')
      },
      uniforms: {
        view: this.regl.context('view'),
        projection: this.regl.context('projection')
      }
    });
  } else {
    this.initCamera();
  }

  return this;
};

Output.prototype.perspective = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'perspective'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.ortho = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'ortho'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.render = function (passes) {
  const self = this; // ensure both fbo's have last frame

  this.copyPass({
    tex0: this.getCurrent()
  });
  self.draw = [];
  self.passes = passes;
  let clear = false;

  for (let i = 0; i < passes.length; i++) {
    if (passes[i].clear) {
      clear = passes[i].clear;
      break;
    }
  }

  if (clear) {
    if (clear.amount >= 1) {
      self.draw.push(...this.clear(false));
    } else {
      self.draw.push(this.fade({
        now: false,
        ...clear
      }));
    }
  }

  for (let i = 0; i < passes.length; i++) {
    let pass = passes[i];
    const {
      attributes,
      elements,
      primitive
    } = this.getAttributes(pass.primitive, pass.geometry);
    const uniforms = this.getUniforms(pass.uniforms);
    const blend = this.getBlend(pass.blendMode);
    const draw = self.regl({
      frag: pass.frag,
      vert: pass.vert,
      viewport: typeof pass.viewport.x !== 'undefined' ? {
        x: pass.viewport.x * this.fbos[0].width,
        y: pass.viewport.y * this.fbos[0].height,
        width: pass.viewport.w * this.fbos[0].width,
        height: pass.viewport.h * this.fbos[0].height
      } : {},
      cull: {
        enable: !!pass.geometry,
        face: 'back'
      },
      attributes,
      primitive,
      uniforms,
      count: typeof elements === 'number' ? elements : elements.length,
      elements: typeof elements === 'number' ? null : elements,
      blend,
      lineWidth: pass.lineWidth,
      framebuffer: pass.framebuffer || (() => {
        self.pingPongIndex = self.pingPongIndex ? 0 : 1;
        return self.fbos[self.pingPongIndex];
      })
    });
    self.draw.push(draw);
  }
};

Output.prototype.clear = function (now = true) {
  const result = [this.fbos[0], this.fbos[1], this.temp[0], this.temp[1]].map(fbo => {
    const clear = () => this.regl.clear({
      color: [0, 0, 0, 0],
      framebuffer: fbo
    });

    if (now) clear();else return clear;
  });
  if (now) return this;
  return result;
};

Output.prototype.fade = function (options) {
  let amount = options;
  let camera = false;
  let now = true;

  if (typeof options === 'object') {
    ({
      amount,
      camera
    } = options);
    now = typeof options.now === 'undefined' ? true : options.now;
  }

  const self = this; // todo: do we need to fade also temp buffers?

  const fade = self.regl({
    frag: `
          precision ${self.precision} float;
          varying vec2 vuv;
          uniform sampler2D prevBuffer;
          void main() {
            vec4 color = mix(texture2D(prevBuffer, vuv), vec4(0), ${amount});
            gl_FragColor = color;
          }
        `,
    vert: _glslSource.default.compileVert(this.precision, camera, {
      glslName: 'clear'
    }),
    attributes: self.attributes,
    primitive: 'triangles',
    uniforms: Object.assign({}, {
      prevBuffer: () => {
        return self.fbos[self.pingPongIndex];
      }
    }, this.uniforms),
    count: 3,
    // next framebuffer
    framebuffer: () => {
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  if (now) return this;
  return fade;
};

Output.prototype.getAttributes = function (primitive, geometry) {
  let elements = 3;
  let attributes = this.attributes;

  if (geometry) {
    attributes = {};

    if (geometry.isBufferGeometry) {
      Object.keys(geometry.attributes).forEach(key => attributes[key] = geometry.attributes[key].array);
      elements = geometry.index ? geometry.index.array : geometry.attributes.position.count;
      primitive || (primitive = geometry.parameters.primitive);
    } else if (geometry.positions && (geometry.edges || geometry.cells)) {
      attributes.position = []; // todo: should be Float32Array

      geometry.positions.map((v, k) => attributes.position.push(v[0], v[1], 0));
      elements = geometry.edges ? geometry.edges : geometry.cells;
      primitive = geometry.edges ? 'lines' : 'triangles';
    }
  }

  primitive || (primitive = 'triangles');
  return {
    attributes,
    elements,
    primitive
  };
};

Output.prototype.getUniforms = function (uniforms) {
  const self = this;
  uniforms = Object.assign(uniforms, {
    prevBuffer: () => {
      // todo: changed, originally:
      // return self.fbos[self.pingPongIndex]
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  return Object.keys(uniforms).reduce((acc, key) => {
    acc[key] = typeof uniforms[key] === 'string' ? parseFloat(uniforms[key]) : uniforms[key];
    return acc;
  }, {});
};

Output.prototype.getBlend = function (blendMode) {
  let func;

  switch (blendMode) {
    case 'custom':
      func = {
        srcRGB: 'custom',
        // Define your custom blending function here
        dstRGB: 'custom',
        srcAlpha: 'custom',
        dstAlpha: 'custom'
      };
      break;

    case 'overlay':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'one minus src color',
        srcAlpha: 'dst alpha',
        dstAlpha: 'one minus src alpha'
      };
      break;

    case 'screen':
      func = {
        srcRGB: 'one minus dst color',
        dstRGB: 'one',
        srcAlpha: 'one minus dst alpha',
        dstAlpha: 'one'
      };
      break;

    case 'multiply':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'zero',
        srcAlpha: 'dst alpha',
        dstAlpha: 'zero'
      };
      break;

    case 'add':
      func = {
        srcRGB: 'one',
        dstRGB: 'one',
        srcAlpha: 'one',
        dstAlpha: 'one'
      };
      break;

    case 'alpha':
    default:
      func = {
        srcRGB: 'src alpha',
        srcAlpha: 1,
        dstRGB: 'one minus src alpha',
        dstAlpha: 1
      };
      break;
  }

  return {
    enable: blendMode ? typeof blendMode === 'string' ? blendMode !== 'disabled' : blendMode : false,
    func
  };
};

Output.prototype.tick = function (props) {
  const doDraw = () => this.draw.map(fn => fn(props));

  this._camera({
    eye: this.eye,
    target: this.target
  }, function () {
    doDraw();
  });
};

Output.prototype.renderTexture = function (options = {}) {
  const next = this.pingPongIndex ? 0 : 1;
  const original = this.fbos;
  this.initFbos({
    color: options
  });

  this.synth._renderOut(this.id);

  const colorTex = this.fbos[this.pingPongIndex].color;
  this.fbos = original;
  return Array.isArray(colorTex) ? colorTex[0] : colorTex;
};

var _default = Output;
exports.default = _default;

},{"./glsl-source.js":150,"gl-mat4":62}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeLookup = exports.getLookup = exports.castType = void 0;
exports.processGlsl = processGlsl;
exports.replaceGenType = replaceGenType;
exports.typeLookup = void 0;
const typeLookup = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'vert': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
};
exports.typeLookup = typeLookup;
const getLookup = {
  float: 'x',
  vec2: 'xy',
  vec3: 'xyz',
  vec4: 'xyzw'
};
exports.getLookup = getLookup;
const getTypeLookup = {
  x: 'float',
  y: 'float',
  z: 'float',
  xy: 'vec2',
  yx: 'vec2',
  xyz: 'vec3',
  xzy: 'vec3',
  yzx: 'vec3',
  yxz: 'vec3',
  zxy: 'vec3',
  zyx: 'vec3',
  xyzw: 'vec4'
};
exports.getTypeLookup = getTypeLookup;

const castType = (func, fromType, toType, alpha = 0.0) => {
  let fromLen = fromType.substring(3);
  let toLen = toType.substring(3);
  const nonVec = {
    float: 1,
    sampler2D: 4
  };
  Object.keys(nonVec).map(t => {
    if (fromType === t) fromLen = nonVec[t];
    if (toType === t) toLen = nonVec[t];
  });

  if (fromLen < toLen) {
    let diff = toLen - fromLen;
    let last = '';

    if (toType === 'vec4') {
      diff -= 1;
      last = ', ' + alpha;
    }

    func = `vec${toLen}(${func}${', 0.0'.repeat(diff)}${last})`;
  }

  return func;
};

exports.castType = castType;

function processGlsl(obj, returnType, args = []) {
  let baseArgs = args.map(arg => arg).join(", ");
  let customArgs = (obj.inputs || (obj.inputs = [])).map(input => `${input.type} ${input.name}`).join(', ');
  let allArgs = `${baseArgs}${customArgs.length > 0 ? ', ' + customArgs : ''}`;
  const func = `${returnType || ''} ${obj.glslName}(${allArgs}`;

  const fixOrWrap = glsl => {
    if (glsl.indexOf(func) === -1) {
      if (glsl.indexOf(`${returnType} main(${allArgs}`) > -1) {
        return glsl.replace(`${returnType} main(${allArgs}`, func);
      } else {
        if (obj.primitive) {
          let primitiveFn = obj.primitive.split(" ").join("");

          if (glsl.indexOf(primitiveFn) > -1) {
            return glsl.replace(`${returnType} ${primitiveFn}(${allArgs}`, func);
          }
        }

        if (returnType) {
          return `
  ${func}) {
      ${glsl}
  }
`;
        }
      }
    }

    return glsl;
  };

  obj.glsl = fixOrWrap(obj.glsl);

  if (obj.vert) {
    obj.vert = fixOrWrap(obj.vert);
  } // add extra input to beginning for backward combatibility @todo update compiler so this is no longer necessary


  if (obj.type === 'combine' || obj.type === 'combineCoord') obj.inputs.unshift({
    name: 'color',
    type: 'vec4'
  });
  return Object.assign({}, obj, {
    returnType
  });
}

function replaceGenType(transform, toType) {
  const t = typeLookup[toType];
  let result;

  if (toType === 'coord') {
    result = Object.assign({}, transform, transform.coord, {
      type: toType
    });
  } else {
    // color
    result = Object.assign({}, transform, {
      type: toType
    });
  }

  return processGlsl(result, t.returnType, t.args);
}

},{}]},{},[157])(157)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvY21wLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvZGl2LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9pcy1yYXQuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvYm4tc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9ibi10by1udW0uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvY3R6LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL2lzLWJuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL251bS10by1ibi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9yYXRpb25hbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9zdHItdG8tYm4uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9tdWwuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3N1Yi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3RvLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2JpbmFyeS1zZWFyY2gtYm91bmRzL3NlYXJjaC1ib3VuZHMuanMiLCJub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2JydXRlLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2ludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9tZWRpYW4uanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvcGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3NvcnQuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvc3dlZXAuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2NkdDJkLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9kZWxhdW5heS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9tb25vdG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvdHJpYW5ndWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL2NsZWFuLXBzbGcuanMiLCJub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9saWIvcmF0LXNlZy1pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvY29tcGFyZS1hbmdsZS9jbXBhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanMiLCJub2RlX21vZHVsZXMvZG91YmxlLWJpdHMvZG91YmxlLmpzIiwibm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZWRnZXMtdG8tYWRqYWNlbmN5LWxpc3QvZTJhLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uYWwtcmVkLWJsYWNrLXRyZWUvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2dhbW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW50ZXJ2YWwtdHJlZS0xZC9pbnRlcnZhbC10cmVlLmpzIiwibm9kZV9tb2R1bGVzL2ludmVydC1wZXJtdXRhdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21leWRhL2Rpc3Qvd2ViL21leWRhLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LWV4dHJhY3QtY29udG91ci9jb250b3VyLmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9uZXh0YWZ0ZXIvbmV4dGFmdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXBhcml0eS9wZXJtdXRhdGlvbi1zaWduLmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXJhbmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWR1YWwvbG9vcHMuanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWdyYXBoLXRvLXBvbHlsaW5lL2xpYi90cmltLWxlYXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9wbGFuYXItZ3JhcGgtdG8tcG9seWxpbmUvcGcycGwuanMiLCJub2RlX21vZHVsZXMvcG9pbnQtaW4tYmlnLXBvbHlnb24vcG5wLWJpZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmLWxvb3AvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmF0LXZlYy9tdWxzLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvc3ViLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2wvZGlzdC9yZWdsLmpzIiwibm9kZV9tb2R1bGVzL3JpZ2h0LW5vdy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1pbi1zcGhlcmUvaW4tc3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3QtcHJvZHVjdC9wcm9kdWN0LmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1zY2FsZS9yb2J1c3Qtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXNlZ21lbnQtaW50ZXJzZWN0L3NlZ3NlZy5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3Qtc3VidHJhY3Qvcm9idXN0LWRpZmYuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXN1bS9yb2J1c3Qtc3VtLmpzIiwibm9kZV9tb2R1bGVzL3NpZ251bS9zZ24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxpY2lhbC1jb21wbGV4L25vZGVfbW9kdWxlcy91bmlvbi1maW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC90b3BvbG9neS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGlmeS1wbGFuYXItZ3JhcGgvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvc2xhYi1kZWNvbXBvc2l0aW9uL2xpYi9vcmRlci1zZWdtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zbGFiLWRlY29tcG9zaXRpb24vc2xhYnMuanMiLCJub2RlX21vZHVsZXMvc3VyZmFjZS1uZXRzL3N1cmZhY2VuZXRzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9MYXllcnMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvT2JqZWN0M0QuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9EYXRhVXRpbHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvQm94My5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9FdWxlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRoVXRpbHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4My5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRyaXg0LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1F1YXRlcm5pb24uanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvU3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1ZlY3RvcjIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtaHlwZXJjdWJlL3RyaWFuZ3VsYXRlLWN1YmUuanMiLCJub2RlX21vZHVsZXMvdHdvLXByb2R1Y3QvdHdvLXByb2R1Y3QuanMiLCJub2RlX21vZHVsZXMvdHdvLXN1bS90d28tc3VtLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3VuaW9uLWZpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvcml6ZS10ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvcml6ZS10ZXh0L2xpYi92dGV4dC5qcyIsIm5vZGVfbW9kdWxlcy96ZXJvLWNyb3NzaW5ncy9saWIvemMtY29yZS5qcyIsIm5vZGVfbW9kdWxlcy96ZXJvLWNyb3NzaW5ncy96Yy5qcyIsInNyYy9ldmFsLXNhbmRib3guanMiLCJzcmMvZm9ybWF0LWFyZ3VtZW50cy5qcyIsInNyYy9nZW5lcmF0ZS1nbHNsLmpzIiwic3JjL2dlbmVyYXRvci1mYWN0b3J5LmpzIiwic3JjL2dsc2wtc291cmNlLmpzIiwic3JjL2dsc2wvZ2VvbWV0cmllcy9HcmlkR2VvbWV0cnkuanMiLCJzcmMvZ2xzbC9nbHNsLWZ1bmN0aW9ucy5qcyIsInNyYy9nbHNsL3V0aWxpdHktZnVuY3Rpb25zLmpzIiwic3JjL2dsc2wvdmVydC1mdW5jdGlvbnMuanMiLCJzcmMvaHlkcmEtc291cmNlLmpzIiwic3JjL2h5ZHJhLXN5bnRoLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2xpYi9hcnJheS11dGlscy5qcyIsInNyYy9saWIvYXVkaW8uanMiLCJzcmMvbGliL2Vhc2luZy1mdW5jdGlvbnMuanMiLCJzcmMvbGliL21vdXNlLWV2ZW50LmpzIiwic3JjL2xpYi9tb3VzZS5qcyIsInNyYy9saWIvc2FuZGJveC5qcyIsInNyYy9saWIvc2NyZWVubWVkaWEuanMiLCJzcmMvbGliL3ZpZGVvLXJlY29yZGVyLmpzIiwic3JjL2xpYi93ZWJjYW0uanMiLCJzcmMvb3V0cHV0LmpzIiwic3JjL3R5cGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0M0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDamZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ24rQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNytUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDOU1PLE1BQU0sUUFBUSxHQUFHLEtBQWpCOztBQUVBLE1BQU0sS0FBSyxHQUFHO0VBQUUsSUFBSSxFQUFFLENBQVI7RUFBVyxNQUFNLEVBQUUsQ0FBbkI7RUFBc0IsS0FBSyxFQUFFLENBQTdCO0VBQWdDLE1BQU0sRUFBRSxDQUF4QztFQUEyQyxLQUFLLEVBQUUsQ0FBbEQ7RUFBcUQsR0FBRyxFQUFFO0FBQTFELENBQWQ7O0FBQ0EsTUFBTSxLQUFLLEdBQUc7RUFBRSxNQUFNLEVBQUUsQ0FBVjtFQUFhLEdBQUcsRUFBRSxDQUFsQjtFQUFxQixTQUFTLEVBQUUsQ0FBaEM7RUFBbUMsWUFBWSxFQUFFO0FBQWpELENBQWQ7O0FBQ0EsTUFB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RSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFDekQsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFDekQsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLENBQUYsQ0FBRixHQUFVLEVBQUUsQ0FBRSxDQUFGLENBQVo7SUFBbUIsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFBcUIsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFDM0QsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFBcUIsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFBcUIsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFBcUIsRUFBRSxDQUFFLEVBQUYsQ0FBRixHQUFXLEVBQUUsQ0FBRSxFQUFGLENBQWI7SUFFL0QsT0FBTyxJQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLENBQUYsRUFBTTtJQUVqQixNQUFNLEVBQUUsR0FBRyxLQUFLLFFBQWhCO0lBQUEsTUFBMEIsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFqQztJQUVBLEVB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TCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBOztNQUVELEtBQUssS0FBTDtRQUNDLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQTs7TUFFRCxLQUFLLEtBQUw7UUFDQyxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0E7O01BRUQsS0FBSyxLQUFMO1FBQ0MsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBOztNQUVELEtBQUssS0FBTDtRQUNDLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQTs7TUFFRCxLQUFLLEtBQUw7UUFDQyxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0E7O01BRUQ7UUFDQyxPQUFPLENBQUMsSUFBUixDQUFjLHFFQUFxRSxLQUFuRjtJQTdDRjs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QURtRTtJQUV6RSxJQUFJLEVBQUU7RUFGbUUsQ0FBbkI7RUFJMUQsT0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjLEVBQWQsRUFBa0IsR0FBbEIsRUFBdUI7SUFBRTtFQUFGLENBQXZCLENBQVA7QUFDSDs7QUFFRCxTQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsTUFBbkMsRUFBMkM7RUFDdkMsTUFBTSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQUQsQ0FBcEI7RUFDQSxJQUFJLE1BQUo7O0VBQ0EsSUFBSSxNQUFNLEtBQUssT0FBZixFQUF3QjtJQUNwQixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLFNBQWxCLEVBQTZCLFNBQVMsQ0FBQyxLQUF2QyxFQUE4QztNQUNuRCxJQUFJLEVBQUU7SUFENkMsQ0FBOUMsQ0FBVDtFQUdILENBSkQsTUFLSztJQUFFO0lBQ0gsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWMsRUFBZCxFQUFrQixTQUFsQixFQUE2QjtNQUNsQyxJQUFJLEVBQUU7SUFENEIsQ0FBN0IsQ0FBVDtFQUdIOztFQUNELE9BQU8sV0FBVyxDQUFDLE1BQUQsRUFBUyxDQUFDLENBQUMsVUFBWCxFQUF1QixDQUFDLENBQUMsSUFBekIsQ0FBbEI7QUFDSCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRcblxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKFxuICAgIGFbMF0ubXVsKGJbMV0pLmFkZChiWzBdLm11bChhWzFdKSksXG4gICAgYVsxXS5tdWwoYlsxXSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbXBcblxuZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXS5tdWwoYlsxXSkuY21wKGJbMF0ubXVsKGFbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBkaXZcblxuZnVuY3Rpb24gZGl2KGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKGFbMF0ubXVsKGJbMV0pLCBhWzFdLm11bChiWzBdKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaXNSYXQgPSByZXF1aXJlKCcuL2lzLXJhdCcpXG52YXIgaXNCTiA9IHJlcXVpcmUoJy4vbGliL2lzLWJuJylcbnZhciBudW0yYm4gPSByZXF1aXJlKCcuL2xpYi9udW0tdG8tYm4nKVxudmFyIHN0cjJibiA9IHJlcXVpcmUoJy4vbGliL3N0ci10by1ibicpXG52YXIgcmF0aW9uYWxpemUgPSByZXF1aXJlKCcuL2xpYi9yYXRpb25hbGl6ZScpXG52YXIgZGl2ID0gcmVxdWlyZSgnLi9kaXYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VSYXRpb25hbFxuXG5mdW5jdGlvbiBtYWtlUmF0aW9uYWwobnVtZXIsIGRlbm9tKSB7XG4gIGlmKGlzUmF0KG51bWVyKSkge1xuICAgIGlmKGRlbm9tKSB7XG4gICAgICByZXR1cm4gZGl2KG51bWVyLCBtYWtlUmF0aW9uYWwoZGVub20pKVxuICAgIH1cbiAgICByZXR1cm4gW251bWVyWzBdLmNsb25lKCksIG51bWVyWzFdLmNsb25lKCldXG4gIH1cbiAgdmFyIHNoaWZ0ID0gMFxuICB2YXIgYSwgYlxuICBpZihpc0JOKG51bWVyKSkge1xuICAgIGEgPSBudW1lci5jbG9uZSgpXG4gIH0gZWxzZSBpZih0eXBlb2YgbnVtZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYSA9IHN0cjJibihudW1lcilcbiAgfSBlbHNlIGlmKG51bWVyID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigxKV1cbiAgfSBlbHNlIGlmKG51bWVyID09PSBNYXRoLmZsb29yKG51bWVyKSkge1xuICAgIGEgPSBudW0yYm4obnVtZXIpXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUobnVtZXIgIT09IE1hdGguZmxvb3IobnVtZXIpKSB7XG4gICAgICBudW1lciA9IG51bWVyICogTWF0aC5wb3coMiwgMjU2KVxuICAgICAgc2hpZnQgLT0gMjU2XG4gICAgfVxuICAgIGEgPSBudW0yYm4obnVtZXIpXG4gIH1cbiAgaWYoaXNSYXQoZGVub20pKSB7XG4gICAgYS5tdWwoZGVub21bMV0pXG4gICAgYiA9IGRlbm9tWzBdLmNsb25lKClcbiAgfSBlbHNlIGlmKGlzQk4oZGVub20pKSB7XG4gICAgYiA9IGRlbm9tLmNsb25lKClcbiAgfSBlbHNlIGlmKHR5cGVvZiBkZW5vbSA9PT0gJ3N0cmluZycpIHtcbiAgICBiID0gc3RyMmJuKGRlbm9tKVxuICB9IGVsc2UgaWYoIWRlbm9tKSB7XG4gICAgYiA9IG51bTJibigxKVxuICB9IGVsc2UgaWYoZGVub20gPT09IE1hdGguZmxvb3IoZGVub20pKSB7XG4gICAgYiA9IG51bTJibihkZW5vbSlcbiAgfSBlbHNlIHtcbiAgICB3aGlsZShkZW5vbSAhPT0gTWF0aC5mbG9vcihkZW5vbSkpIHtcbiAgICAgIGRlbm9tID0gZGVub20gKiBNYXRoLnBvdygyLCAyNTYpXG4gICAgICBzaGlmdCArPSAyNTZcbiAgICB9XG4gICAgYiA9IG51bTJibihkZW5vbSlcbiAgfVxuICBpZihzaGlmdCA+IDApIHtcbiAgICBhID0gYS51c2hsbihzaGlmdClcbiAgfSBlbHNlIGlmKHNoaWZ0IDwgMCkge1xuICAgIGIgPSBiLnVzaGxuKC1zaGlmdClcbiAgfVxuICByZXR1cm4gcmF0aW9uYWxpemUoYSwgYilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaXNCTiA9IHJlcXVpcmUoJy4vbGliL2lzLWJuJylcblxubW9kdWxlLmV4cG9ydHMgPSBpc1JhdFxuXG5mdW5jdGlvbiBpc1JhdCh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpICYmIHgubGVuZ3RoID09PSAyICYmIGlzQk4oeFswXSkgJiYgaXNCTih4WzFdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5cbmZ1bmN0aW9uIHNpZ24gKHgpIHtcbiAgcmV0dXJuIHguY21wKG5ldyBCTigwKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gYm4ybnVtXG5cbi8vVE9ETzogTWFrZSB0aGlzIGJldHRlclxuZnVuY3Rpb24gYm4ybnVtKGIpIHtcbiAgdmFyIGwgPSBiLmxlbmd0aFxuICB2YXIgd29yZHMgPSBiLndvcmRzXG4gIHZhciBvdXQgPSAwXG4gIGlmIChsID09PSAxKSB7XG4gICAgb3V0ID0gd29yZHNbMF1cbiAgfSBlbHNlIGlmIChsID09PSAyKSB7XG4gICAgb3V0ID0gd29yZHNbMF0gKyAod29yZHNbMV0gKiAweDQwMDAwMDApXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB3ID0gd29yZHNbaV1cbiAgICAgIG91dCArPSB3ICogTWF0aC5wb3coMHg0MDAwMDAwLCBpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2lnbihiKSAqIG91dFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkYiA9IHJlcXVpcmUoJ2RvdWJsZS1iaXRzJylcbnZhciBjdHogPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpLmNvdW50VHJhaWxpbmdaZXJvc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0ek51bWJlclxuXG4vL0NvdW50cyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjdHpOdW1iZXIoeCkge1xuICB2YXIgbCA9IGN0eihkYi5sbyh4KSlcbiAgaWYobCA8IDMyKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgaCA9IGN0eihkYi5oaSh4KSlcbiAgaWYoaCA+IDIwKSB7XG4gICAgcmV0dXJuIDUyXG4gIH1cbiAgcmV0dXJuIGggKyAzMlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBpc0JOXG5cbi8vVGVzdCBpZiB4IGlzIGEgYmlnbnVtYmVyXG4vL0ZJWE1FOiBvYnZpb3VzbHkgdGhpcyBpcyB0aGUgd3Jvbmcgd2F5IHRvIGRvIGl0XG5mdW5jdGlvbiBpc0JOKHgpIHtcbiAgcmV0dXJuIHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIEJvb2xlYW4oeC53b3Jkcylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgZGIgPSByZXF1aXJlKCdkb3VibGUtYml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gbnVtMmJuXG5cbmZ1bmN0aW9uIG51bTJibih4KSB7XG4gIHZhciBlID0gZGIuZXhwb25lbnQoeClcbiAgaWYoZSA8IDUyKSB7XG4gICAgcmV0dXJuIG5ldyBCTih4KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAobmV3IEJOKHggKiBNYXRoLnBvdygyLCA1Mi1lKSkpLnVzaGxuKGUtNTIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbnVtMmJuID0gcmVxdWlyZSgnLi9udW0tdG8tYm4nKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL2JuLXNpZ24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhdGlvbmFsaXplXG5cbmZ1bmN0aW9uIHJhdGlvbmFsaXplKG51bWVyLCBkZW5vbSkge1xuICB2YXIgc251bWVyID0gc2lnbihudW1lcilcbiAgdmFyIHNkZW5vbSA9IHNpZ24oZGVub20pXG4gIGlmKHNudW1lciA9PT0gMCkge1xuICAgIHJldHVybiBbbnVtMmJuKDApLCBudW0yYm4oMSldXG4gIH1cbiAgaWYoc2Rlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigwKV1cbiAgfVxuICBpZihzZGVub20gPCAwKSB7XG4gICAgbnVtZXIgPSBudW1lci5uZWcoKVxuICAgIGRlbm9tID0gZGVub20ubmVnKClcbiAgfVxuICB2YXIgZCA9IG51bWVyLmdjZChkZW5vbSlcbiAgaWYoZC5jbXBuKDEpKSB7XG4gICAgcmV0dXJuIFsgbnVtZXIuZGl2KGQpLCBkZW5vbS5kaXYoZCkgXVxuICB9XG4gIHJldHVybiBbIG51bWVyLCBkZW5vbSBdXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cjJCTlxuXG5mdW5jdGlvbiBzdHIyQk4oeCkge1xuICByZXR1cm4gbmV3IEJOKHgpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bFxuXG5mdW5jdGlvbiBtdWwoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoYVswXS5tdWwoYlswXSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYyAtIDQ4KSAmIDB4ZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5zaWduID0gcmVxdWlyZSgnLi9saWIvYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIGJuc2lnbih4WzBdKSAqIGJuc2lnbih4WzFdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJcblxuZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKGFbMF0ubXVsKGJbMV0pLnN1YihhWzFdLm11bChiWzBdKSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibjJudW0gPSByZXF1aXJlKCcuL2xpYi9ibi10by1udW0nKVxudmFyIGN0eiA9IHJlcXVpcmUoJy4vbGliL2N0eicpXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmRSYXRcblxuLy8gUm91bmQgYSByYXRpb25hbCB0byB0aGUgY2xvc2VzdCBmbG9hdFxuZnVuY3Rpb24gcm91bmRSYXQgKGYpIHtcbiAgdmFyIGEgPSBmWzBdXG4gIHZhciBiID0gZlsxXVxuICBpZiAoYS5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgaCA9IGEuYWJzKCkuZGl2bW9kKGIuYWJzKCkpXG4gIHZhciBpdiA9IGguZGl2XG4gIHZhciB4ID0gYm4ybnVtKGl2KVxuICB2YXIgaXIgPSBoLm1vZFxuICB2YXIgc2duID0gKGEubmVnYXRpdmUgIT09IGIubmVnYXRpdmUpID8gLTEgOiAxXG4gIGlmIChpci5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIHNnbiAqIHhcbiAgfVxuICBpZiAoeCkge1xuICAgIHZhciBzID0gY3R6KHgpICsgNFxuICAgIHZhciB5ID0gYm4ybnVtKGlyLnVzaGxuKHMpLmRpdlJvdW5kKGIpKVxuICAgIHJldHVybiBzZ24gKiAoeCArIHkgKiBNYXRoLnBvdygyLCAtcykpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHliaXRzID0gYi5iaXRMZW5ndGgoKSAtIGlyLmJpdExlbmd0aCgpICsgNTNcbiAgICB2YXIgeSA9IGJuMm51bShpci51c2hsbih5Yml0cykuZGl2Um91bmQoYikpXG4gICAgaWYgKHliaXRzIDwgMTAyMykge1xuICAgICAgcmV0dXJuIHNnbiAqIHkgKiBNYXRoLnBvdygyLCAteWJpdHMpXG4gICAgfVxuICAgIHkgKj0gTWF0aC5wb3coMiwgLTEwMjMpXG4gICAgcmV0dXJuIHNnbiAqIHkgKiBNYXRoLnBvdygyLCAxMDIzIC0geWJpdHMpXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vIChhLCB5LCBjLCBsLCBoKSA9IChhcnJheSwgeVssIGNtcCwgbG8sIGhpXSlcblxuZnVuY3Rpb24gZ2UoYSwgeSwgYywgbCwgaCkge1xuICB2YXIgaSA9IGggKyAxO1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPj0gMCkgeyBpID0gbTsgaCA9IG0gLSAxIH0gZWxzZSB7IGwgPSBtICsgMSB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBndChhLCB5LCBjLCBsLCBoKSB7XG4gIHZhciBpID0gaCArIDE7XG4gIHdoaWxlIChsIDw9IGgpIHtcbiAgICB2YXIgbSA9IChsICsgaCkgPj4+IDEsIHggPSBhW21dO1xuICAgIHZhciBwID0gKGMgIT09IHVuZGVmaW5lZCkgPyBjKHgsIHkpIDogKHggLSB5KTtcbiAgICBpZiAocCA+IDApIHsgaSA9IG07IGggPSBtIC0gMSB9IGVsc2UgeyBsID0gbSArIDEgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gbHQoYSwgeSwgYywgbCwgaCkge1xuICB2YXIgaSA9IGwgLSAxO1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPCAwKSB7IGkgPSBtOyBsID0gbSArIDEgfSBlbHNlIHsgaCA9IG0gLSAxIH1cbiAgfVxuICByZXR1cm4gaTtcbn07XG5cbmZ1bmN0aW9uIGxlKGEsIHksIGMsIGwsIGgpIHtcbiAgdmFyIGkgPSBsIC0gMTtcbiAgd2hpbGUgKGwgPD0gaCkge1xuICAgIHZhciBtID0gKGwgKyBoKSA+Pj4gMSwgeCA9IGFbbV07XG4gICAgdmFyIHAgPSAoYyAhPT0gdW5kZWZpbmVkKSA/IGMoeCwgeSkgOiAoeCAtIHkpO1xuICAgIGlmIChwIDw9IDApIHsgaSA9IG07IGwgPSBtICsgMSB9IGVsc2UgeyBoID0gbSAtIDEgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gZXEoYSwgeSwgYywgbCwgaCkge1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPT09IDApIHsgcmV0dXJuIG0gfVxuICAgIGlmIChwIDw9IDApIHsgbCA9IG0gKyAxIH0gZWxzZSB7IGggPSBtIC0gMSB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuZnVuY3Rpb24gbm9ybShhLCB5LCBjLCBsLCBoLCBmKSB7XG4gIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmKGEsIHksIGMsIChsID09PSB1bmRlZmluZWQpID8gMCA6IGwgfCAwLCAoaCA9PT0gdW5kZWZpbmVkKSA/IGEubGVuZ3RoIC0gMSA6IGggfCAwKTtcbiAgfVxuICByZXR1cm4gZihhLCB5LCB1bmRlZmluZWQsIChjID09PSB1bmRlZmluZWQpID8gMCA6IGMgfCAwLCAobCA9PT0gdW5kZWZpbmVkKSA/IGEubGVuZ3RoIC0gMSA6IGwgfCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdlOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGdlKX0sXG4gIGd0OiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGd0KX0sXG4gIGx0OiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGx0KX0sXG4gIGxlOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGxlKX0sXG4gIGVxOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGVxKX1cbn1cbiIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0V3JhcHBlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL2xpYi9zd2VlcCcpXG52YXIgYm94SW50ZXJzZWN0SXRlciA9IHJlcXVpcmUoJy4vbGliL2ludGVyc2VjdCcpXG5cbmZ1bmN0aW9uIGJveEVtcHR5KGQsIGJveCkge1xuICBmb3IodmFyIGo9MDsgajxkOyArK2opIHtcbiAgICBpZighKGJveFtqXSA8PSBib3hbaitkXSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vL1VucGFjayBib3hlcyBpbnRvIGEgZmxhdCB0eXBlZCBhcnJheSwgcmVtb3ZlIGVtcHR5IGJveGVzXG5mdW5jdGlvbiBjb252ZXJ0Qm94ZXMoYm94ZXMsIGQsIGRhdGEsIGlkcykge1xuICB2YXIgcHRyID0gMFxuICB2YXIgY291bnQgPSAwXG4gIGZvcih2YXIgaT0wLCBuPWJveGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYiA9IGJveGVzW2ldXG4gICAgaWYoYm94RW1wdHkoZCwgYikpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPDIqZDsgKytqKSB7XG4gICAgICBkYXRhW3B0cisrXSA9IGJbal1cbiAgICB9XG4gICAgaWRzW2NvdW50KytdID0gaVxuICB9XG4gIHJldHVybiBjb3VudFxufVxuXG4vL1BlcmZvcm0gdHlwZSBjb252ZXJzaW9ucywgY2hlY2sgYm91bmRzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3QocmVkLCBibHVlLCB2aXNpdCwgZnVsbCkge1xuICB2YXIgbiA9IHJlZC5sZW5ndGhcbiAgdmFyIG0gPSBibHVlLmxlbmd0aFxuXG4gIC8vSWYgZWl0aGVyIGFycmF5IGlzIGVtcHR5LCB0aGVuIHdlIGNhbiBza2lwIHRoaXMgd2hvbGUgdGhpbmdcbiAgaWYobiA8PSAwIHx8IG0gPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvbiwgaWYgaXQgaXMgMCB0aGVuIHdlIHNraXBcbiAgdmFyIGQgPSAocmVkWzBdLmxlbmd0aCk+Pj4xXG4gIGlmKGQgPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHJldHZhbFxuXG4gIC8vQ29udmVydCByZWQgYm94ZXNcbiAgdmFyIHJlZExpc3QgID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm4pXG4gIHZhciByZWRJZHMgICA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgbiA9IGNvbnZlcnRCb3hlcyhyZWQsIGQsIHJlZExpc3QsIHJlZElkcylcblxuICBpZihuID4gMCkge1xuICAgIGlmKGQgPT09IDEgJiYgZnVsbCkge1xuICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGNvbXBsZXRlXG4gICAgICBzd2VlcC5pbml0KG4pXG4gICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcyxcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzKVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vQ29udmVydCBibHVlIGJveGVzXG4gICAgICB2YXIgYmx1ZUxpc3QgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbSlcbiAgICAgIHZhciBibHVlSWRzICA9IHBvb2wubWFsbG9jSW50MzIobSlcbiAgICAgIG0gPSBjb252ZXJ0Qm94ZXMoYmx1ZSwgZCwgYmx1ZUxpc3QsIGJsdWVJZHMpXG5cbiAgICAgIGlmKG0gPiAwKSB7XG4gICAgICAgIHN3ZWVwLmluaXQobittKVxuXG4gICAgICAgIGlmKGQgPT09IDEpIHtcbiAgICAgICAgICAvL1NwZWNpYWwgY2FzZTogMWQgYmlwYXJ0aXRlXG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgICAgICAwLCBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgMCwgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9HZW5lcmFsIGNhc2U6ICBkPjFcbiAgICAgICAgICByZXR2YWwgPSBib3hJbnRlcnNlY3RJdGVyKFxuICAgICAgICAgICAgZCwgdmlzaXQsICAgIGZ1bGwsXG4gICAgICAgICAgICBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH1cblxuICAgICAgICBwb29sLmZyZWUoYmx1ZUxpc3QpXG4gICAgICAgIHBvb2wuZnJlZShibHVlSWRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHBvb2wuZnJlZShyZWRMaXN0KVxuICAgIHBvb2wuZnJlZShyZWRJZHMpXG4gIH1cblxuICByZXR1cm4gcmV0dmFsXG59XG5cblxudmFyIFJFU1VMVFxuXG5mdW5jdGlvbiBhcHBlbmRJdGVtKGksaikge1xuICBSRVNVTFQucHVzaChbaSxqXSlcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0RnVsbEFycmF5KHgpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHgsIGFwcGVuZEl0ZW0sIHRydWUpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoeCwgeSkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeSwgYXBwZW5kSXRlbSwgZmFsc2UpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuLy9Vc2VyLWZyaWVuZGx5IHdyYXBwZXIsIGhhbmRsZSBmdWxsIGlucHV0IGFuZCBuby12aXNpdG9yIGNhc2VzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RXcmFwcGVyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgdmFyIHJlc3VsdFxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBpbnRlcnNlY3RGdWxsQXJyYXkoYXJnMClcbiAgICBjYXNlIDI6XG4gICAgICBpZih0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzAsIGFyZzEsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoYXJnMCwgYXJnMSlcbiAgICAgIH1cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzEsIGFyZzIsIGZhbHNlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JveC1pbnRlcnNlY3Q6IEludmFsaWQgYXJndW1lbnRzJylcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgRElNRU5TSU9OICAgPSAnZCdcbnZhciBBWElTICAgICAgICA9ICdheCdcbnZhciBWSVNJVCAgICAgICA9ICd2didcbnZhciBGTElQICAgICAgICA9ICdmcCdcblxudmFyIEVMRU1fU0laRSAgID0gJ2VzJ1xuXG52YXIgUkVEX1NUQVJUICAgPSAncnMnXG52YXIgUkVEX0VORCAgICAgPSAncmUnXG52YXIgUkVEX0JPWEVTICAgPSAncmInXG52YXIgUkVEX0lOREVYICAgPSAncmknXG52YXIgUkVEX1BUUiAgICAgPSAncnAnXG5cbnZhciBCTFVFX1NUQVJUICA9ICdicydcbnZhciBCTFVFX0VORCAgICA9ICdiZSdcbnZhciBCTFVFX0JPWEVTICA9ICdiYidcbnZhciBCTFVFX0lOREVYICA9ICdiaSdcbnZhciBCTFVFX1BUUiAgICA9ICdicCdcblxudmFyIFJFVFZBTCAgICAgID0gJ3J2J1xuXG52YXIgSU5ORVJfTEFCRUwgPSAnUSdcblxudmFyIEFSR1MgPSBbXG4gIERJTUVOU0lPTixcbiAgQVhJUyxcbiAgVklTSVQsXG4gIFJFRF9TVEFSVCxcbiAgUkVEX0VORCxcbiAgUkVEX0JPWEVTLFxuICBSRURfSU5ERVgsXG4gIEJMVUVfU1RBUlQsXG4gIEJMVUVfRU5ELFxuICBCTFVFX0JPWEVTLFxuICBCTFVFX0lOREVYXG5dXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyBcbiAgICAocmVkTWFqb3IgPyAnUmVkJyA6ICdCbHVlJykgKyBcbiAgICAoZmxpcCA/ICdGbGlwJyA6ICcnKSArXG4gICAgKGZ1bGwgPyAnRnVsbCcgOiAnJylcblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJywgZnVuY05hbWUsICcoJywgQVJHUy5qb2luKCksICcpeycsXG4gICAgJ3ZhciAnLCBFTEVNX1NJWkUsICc9MionLCBESU1FTlNJT04sICc7J11cblxuICB2YXIgcmVkTG9vcCA9IFxuICAgICdmb3IodmFyIGk9JyArIFJFRF9TVEFSVCArICcsJyArIFJFRF9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBSRURfU1RBUlQgKyAnOycgK1xuICAgICAgICAnaTwnICsgUkVEX0VORCArJzsnICtcbiAgICAgICAgJysraSwnICsgUkVEX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB4MD0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgICd4MT0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnICtcbiAgICAgICAgICAgICd4aT0nICsgUkVEX0lOREVYICsgJ1tpXTsnXG5cbiAgdmFyIGJsdWVMb29wID0gXG4gICAgJ2Zvcih2YXIgaj0nICsgQkxVRV9TVEFSVCArICcsJyArIEJMVUVfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgQkxVRV9TVEFSVCArICc7JyArXG4gICAgICAgICdqPCcgKyBCTFVFX0VORCArICc7JyArXG4gICAgICAgICcrK2osJyArIEJMVUVfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHkwPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAoZnVsbCA/ICd5MT0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgOiAnJykgK1xuICAgICAgICAgICAgJ3lpPScgKyBCTFVFX0lOREVYICsgJ1tqXTsnXG5cbiAgaWYocmVkTWFqb3IpIHtcbiAgICBjb2RlLnB1c2gocmVkTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgYmx1ZUxvb3ApXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGJsdWVMb29wLCBJTk5FUl9MQUJFTCwgJzonLCByZWRMb29wKVxuICB9XG5cbiAgaWYoZnVsbCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTE8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDw9eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDx4MHx8eDE8eTApY29udGludWU7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnZm9yKHZhciBrPScrQVhJUysnKzE7azwnK0RJTUVOU0lPTisnOysrayl7JytcbiAgICAndmFyIHIwPScrUkVEX0JPWEVTKydbaysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ3IxPScrUkVEX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAnYjA9JytCTFVFX0JPWEVTKydbaysnK0JMVUVfUFRSKyddLCcrXG4gICAgICAgICdiMT0nK0JMVUVfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytCTFVFX1BUUisnXTsnK1xuICAgICAgJ2lmKHIxPGIwfHxiMTxyMCljb250aW51ZSAnICsgSU5ORVJfTEFCRUwgKyAnO30nICtcbiAgICAgICd2YXIgJyArIFJFVFZBTCArICc9JyArIFZJU0lUICsgJygnKVxuXG4gIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ3lpLHhpJylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ3hpLHlpJylcbiAgfVxuXG4gIGNvZGUucHVzaCgnKTtpZignICsgUkVUVkFMICsgJyE9PXZvaWQgMClyZXR1cm4gJyArIFJFVFZBTCArICc7fX19JylcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGZ1bmNOYW1lLCBcbiAgICBjb2RlOiBjb2RlLmpvaW4oJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJ1dGVGb3JjZVBsYW5uZXIoZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyAoZnVsbCA/ICdGdWxsJyA6ICdQYXJ0aWFsJylcbiAgdmFyIHByZWZpeCA9IFtdXG4gIHZhciBmYXJncyA9IEFSR1Muc2xpY2UoKVxuICBpZighZnVsbCkge1xuICAgIGZhcmdzLnNwbGljZSgzLCAwLCBGTElQKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcgKyBmdW5jTmFtZSArICcoJyArIGZhcmdzLmpvaW4oKSArICcpeyddXG5cbiAgZnVuY3Rpb24gaW52b2tlKHJlZE1ham9yLCBmbGlwKSB7XG4gICAgdmFyIHJlcyA9IGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbClcbiAgICBwcmVmaXgucHVzaChyZXMuY29kZSlcbiAgICBjb2RlLnB1c2goJ3JldHVybiAnICsgcmVzLm5hbWUgKyAnKCcgKyBBUkdTLmpvaW4oKSArICcpOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2lmKCcgKyBSRURfRU5EICsgJy0nICsgUkVEX1NUQVJUICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgQkxVRV9FTkQgKyAnLScgKyBCTFVFX1NUQVJUICsgJyl7JylcblxuICBpZihmdWxsKSB7XG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZSh0cnVlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9fWVsc2V7aWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZShmYWxzZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICB9XG4gIGNvZGUucHVzaCgnfX1yZXR1cm4gJyArIGZ1bmNOYW1lKVxuXG4gIHZhciBjb2RlU3RyID0gcHJlZml4LmpvaW4oJycpICsgY29kZS5qb2luKCcnKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihjb2RlU3RyKVxuICByZXR1cm4gcHJvYygpXG59XG5cblxuZXhwb3J0cy5wYXJ0aWFsID0gYnJ1dGVGb3JjZVBsYW5uZXIoZmFsc2UpXG5leHBvcnRzLmZ1bGwgICAgPSBicnV0ZUZvcmNlUGxhbm5lcih0cnVlKSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdEl0ZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgYnJ1dGVGb3JjZSA9IHJlcXVpcmUoJy4vYnJ1dGUnKVxudmFyIGJydXRlRm9yY2VQYXJ0aWFsID0gYnJ1dGVGb3JjZS5wYXJ0aWFsXG52YXIgYnJ1dGVGb3JjZUZ1bGwgPSBicnV0ZUZvcmNlLmZ1bGxcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vc3dlZXAnKVxudmFyIGZpbmRNZWRpYW4gPSByZXF1aXJlKCcuL21lZGlhbicpXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG4vL1R3aWRkbGUgcGFyYW1ldGVyc1xudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiAgICA9IDEyOCAgICAgICAvL0N1dCBvZmYgZm9yIGJydXRlIGZvcmNlIHNlYXJjaFxudmFyIFNDQU5fQ1VUT0ZGICAgICAgICAgICA9ICgxPDwyMikgICAvL0N1dCBvZmYgZm9yIHR3byB3YXkgc2NhblxudmFyIFNDQU5fQ09NUExFVEVfQ1VUT0ZGICA9ICgxPDwyMikgIFxuXG4vL1BhcnRpdGlvbiBmdW5jdGlvbnNcbnZhciBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwgPSBnZW5QYXJ0aXRpb24oXG4gICchKGxvPj1wMCkmJiEocDE+PWhpKScsIFxuICBbJ3AwJywgJ3AxJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydEVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnbG89PT1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdoaTw9cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50ID0gZ2VuUGFydGl0aW9uKFxuICAnbG88PXAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxuLy9GcmFtZSBzaXplIGZvciBpdGVyYXRpdmUgbG9vcFxudmFyIElGUkFNRV9TSVpFID0gNlxudmFyIERGUkFNRV9TSVpFID0gMlxuXG4vL0RhdGEgZm9yIGJveCBzdGF0Y2tcbnZhciBJTklUX0NBUEFDSVRZID0gMTAyNFxudmFyIEJPWF9JU1RBQ0sgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJPWF9EU1RBQ0sgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSlcblxuLy9Jbml0aWFsaXplIGl0ZXJhdGl2ZSBsb29wIHF1ZXVlXG5mdW5jdGlvbiBpdGVySW5pdChkLCBjb3VudCkge1xuICB2YXIgbGV2ZWxzID0gKDggKiBiaXRzLmxvZzIoY291bnQrMSkgKiAoZCsxKSl8MFxuICB2YXIgbWF4SW50cyA9IGJpdHMubmV4dFBvdzIoSUZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfSVNUQUNLLmxlbmd0aCA8IG1heEludHMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0lTVEFDSylcbiAgICBCT1hfSVNUQUNLID0gcG9vbC5tYWxsb2NJbnQzMihtYXhJbnRzKVxuICB9XG4gIHZhciBtYXhEb3VibGVzID0gYml0cy5uZXh0UG93MihERlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9EU1RBQ0subGVuZ3RoIDwgbWF4RG91Ymxlcykge1xuICAgIHBvb2wuZnJlZShCT1hfRFNUQUNLKVxuICAgIEJPWF9EU1RBQ0sgPSBwb29sLm1hbGxvY0RvdWJsZShtYXhEb3VibGVzKVxuICB9XG59XG5cbi8vQXBwZW5kIGl0ZW0gdG8gcXVldWVcbmZ1bmN0aW9uIGl0ZXJQdXNoKHB0cixcbiAgYXhpcywgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIFxuICBzdGF0ZSwgXG4gIGxvLCBoaSkge1xuXG4gIHZhciBpcHRyID0gSUZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0lTVEFDS1tpcHRyXSAgID0gYXhpc1xuICBCT1hfSVNUQUNLW2lwdHIrMV0gPSByZWRTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrMl0gPSByZWRFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzNdID0gYmx1ZVN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cis0XSA9IGJsdWVFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzVdID0gc3RhdGVcblxuICB2YXIgZHB0ciA9IERGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9EU1RBQ0tbZHB0cl0gICA9IGxvXG4gIEJPWF9EU1RBQ0tbZHB0cisxXSA9IGhpXG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IHNpbmdsZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludFBhcnRpYWwoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYoZmxpcCAmJiBibHVlWCA9PT0gcjApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWxcbiAgICBpZihmbGlwKSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIH1cbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBvbmUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRGdWxsKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vVGhlIG1haW4gYm94IGludGVyc2VjdGlvbiByb3V0aW5lXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RJdGVyKFxuICBkLCB2aXNpdCwgaW5pdEZ1bGwsXG4gIHhTaXplLCB4Qm94ZXMsIHhJbmRleCxcbiAgeVNpemUsIHlCb3hlcywgeUluZGV4KSB7XG5cbiAgLy9SZXNlcnZlIG1lbW9yeSBmb3Igc3RhY2tcbiAgaXRlckluaXQoZCwgeFNpemUgKyB5U2l6ZSlcblxuICB2YXIgdG9wICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIHJldHZhbFxuXG4gIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMCwgeVNpemUsXG4gICAgICBpbml0RnVsbCA/IDE2IDogMCwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICBpZighaW5pdEZ1bGwpIHtcbiAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMSwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICB9XG5cbiAgd2hpbGUodG9wID4gMCkge1xuICAgIHRvcCAgLT0gMVxuXG4gICAgdmFyIGlwdHIgPSB0b3AgKiBJRlJBTUVfU0laRVxuICAgIHZhciBheGlzICAgICAgPSBCT1hfSVNUQUNLW2lwdHJdXG4gICAgdmFyIHJlZFN0YXJ0ICA9IEJPWF9JU1RBQ0tbaXB0cisxXVxuICAgIHZhciByZWRFbmQgICAgPSBCT1hfSVNUQUNLW2lwdHIrMl1cbiAgICB2YXIgYmx1ZVN0YXJ0ID0gQk9YX0lTVEFDS1tpcHRyKzNdXG4gICAgdmFyIGJsdWVFbmQgICA9IEJPWF9JU1RBQ0tbaXB0cis0XVxuICAgIHZhciBzdGF0ZSAgICAgPSBCT1hfSVNUQUNLW2lwdHIrNV1cblxuICAgIHZhciBkcHRyID0gdG9wICogREZSQU1FX1NJWkVcbiAgICB2YXIgbG8gICAgICAgID0gQk9YX0RTVEFDS1tkcHRyXVxuICAgIHZhciBoaSAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHIrMV1cblxuICAgIC8vVW5wYWNrIHN0YXRlIGluZm9cbiAgICB2YXIgZmxpcCAgICAgID0gKHN0YXRlICYgMSlcbiAgICB2YXIgZnVsbCAgICAgID0gISEoc3RhdGUgJiAxNilcblxuICAgIC8vVW5wYWNrIGluZGljZXNcbiAgICB2YXIgcmVkICAgICAgID0geEJveGVzXG4gICAgdmFyIHJlZEluZGV4ICA9IHhJbmRleFxuICAgIHZhciBibHVlICAgICAgPSB5Qm94ZXNcbiAgICB2YXIgYmx1ZUluZGV4ID0geUluZGV4XG4gICAgaWYoZmxpcCkge1xuICAgICAgcmVkICAgICAgICAgPSB5Qm94ZXNcbiAgICAgIHJlZEluZGV4ICAgID0geUluZGV4XG4gICAgICBibHVlICAgICAgICA9IHhCb3hlc1xuICAgICAgYmx1ZUluZGV4ICAgPSB4SW5kZXhcbiAgICB9XG5cbiAgICBpZihzdGF0ZSAmIDIpIHtcbiAgICAgIHJlZEVuZCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGhpKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHN0YXRlICYgNCkge1xuICAgICAgcmVkU3RhcnQgPSBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBsbylcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVkQ291bnQgID0gcmVkRW5kICAtIHJlZFN0YXJ0XG4gICAgdmFyIGJsdWVDb3VudCA9IGJsdWVFbmQgLSBibHVlU3RhcnRcblxuICAgIGlmKGZ1bGwpIHtcbiAgICAgIGlmKGQgKiByZWRDb3VudCAqIChyZWRDb3VudCArIGJsdWVDb3VudCkgPCBTQ0FOX0NPTVBMRVRFX0NVVE9GRikge1xuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQ29tcGxldGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGQgKiBNYXRoLm1pbihyZWRDb3VudCwgYmx1ZUNvdW50KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IHNtYWxsLCB0aGVuIHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlUGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkU3RhcnQsICByZWRFbmQsICByZWQsICByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKGQgKiByZWRDb3VudCAqIGJsdWVDb3VudCA8IFNDQU5fQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgbWVkaXVtIHNpemVkLCB0aGVuIHVzZSBzd2VlcCBhbmQgcHJ1bmVcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkJpcGFydGl0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9GaXJzdCwgZmluZCBhbGwgcmVkIGludGVydmFscyB3aG9zZSBpbnRlcmlvciBjb250YWlucyAobG8saGkpXG4gICAgdmFyIHJlZDAgPSBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwoXG4gICAgICBkLCBheGlzLCBcbiAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICBsbywgaGkpXG5cbiAgICAvL0xvd2VyIGRpbWVuc2lvbmFsIGNhc2VcbiAgICBpZihyZWRTdGFydCA8IHJlZDApIHtcblxuICAgICAgaWYoZCAqIChyZWQwIC0gcmVkU3RhcnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBzbWFsbCBpbnB1dHM6IHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlRnVsbChcbiAgICAgICAgICBkLCBheGlzKzEsIHZpc2l0LFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgZmxpcCxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vRGl2aWRlIGFuZCBjb25xdWVyIHBoYXNlXG4gICAgaWYocmVkMCA8IHJlZEVuZCkge1xuXG4gICAgICAvL0N1dCBibHVlIGludG8gMyBwYXJ0czpcbiAgICAgIC8vXG4gICAgICAvLyAgUG9pbnRzIDwgbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID0gbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID4gbWlkIHBvaW50XG4gICAgICAvL1xuICAgICAgdmFyIGJsdWUwID0gZmluZE1lZGlhbihcbiAgICAgICAgZCwgYXhpcywgXG4gICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgdmFyIG1pZCA9IGJsdWVbZWxlbVNpemUgKiBibHVlMCArIGF4aXNdXG4gICAgICB2YXIgYmx1ZTEgPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICBibHVlMCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICBtaWQpXG5cbiAgICAgIC8vUmlnaHQgY2FzZVxuICAgICAgaWYoYmx1ZTEgPCBibHVlRW5kKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWUxLCBibHVlRW5kLFxuICAgICAgICAgIChmbGlwfDQpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIG1pZCwgaGkpXG4gICAgICB9XG5cbiAgICAgIC8vTGVmdCBjYXNlXG4gICAgICBpZihibHVlU3RhcnQgPCBibHVlMCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWUwLFxuICAgICAgICAgIChmbGlwfDIpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIGxvLCBtaWQpXG4gICAgICB9XG5cbiAgICAgIC8vQ2VudGVyIGNhc2UgKHRoZSBoYXJkIHBhcnQpXG4gICAgICBpZihibHVlMCArIDEgPT09IGJsdWUxKSB7XG4gICAgICAgIC8vT3B0aW1pemF0aW9uOiBSYW5nZSB3aXRoIGV4YWN0bHkgMSBwb2ludCwgdXNlIGEgYnJ1dGUgZm9yY2Ugc2NhblxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRGdWxsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludFBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYmx1ZTAgPCBibHVlMSkge1xuICAgICAgICB2YXIgcmVkMVxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgLy9JZiBmdWxsIGludGVyc2VjdGlvbiwgbmVlZCB0byBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICB2YXIgcmVkWCA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICAvL0RlZ2VuZXJhdGUgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZDAsIHJlZFhdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL05vcm1hbCBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkWCwgcmVkMV0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMTYsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRNZWRpYW5cblxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oJ2xvPHAwJywgWydwMCddKVxuXG52YXIgUEFSVElUSU9OX1RIUkVTSE9MRCA9IDggICAvL0N1dCBvZmYgZm9yIHVzaW5nIGluc2VydGlvbiBzb3J0IGluIGZpbmRNZWRpYW5cblxuLy9CYXNlIGNhc2UgZm9yIG1lZGlhbiBmaW5kaW5nOiAgVXNlIGluc2VydGlvbiBzb3J0XG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJveFB0ciA9IGVsZW1TaXplICogKHN0YXJ0KzEpICsgYXhpc1xuICBmb3IodmFyIGk9c3RhcnQrMTsgaTxlbmQ7ICsraSwgYm94UHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciB4ID0gYm94ZXNbYm94UHRyXVxuICAgIGZvcih2YXIgaj1pLCBwdHI9ZWxlbVNpemUqKGktMSk7IFxuICAgICAgICBqPnN0YXJ0ICYmIGJveGVzW3B0citheGlzXSA+IHg7IFxuICAgICAgICAtLWosIHB0ci09ZWxlbVNpemUpIHtcbiAgICAgIC8vU3dhcFxuICAgICAgdmFyIGFQdHIgPSBwdHJcbiAgICAgIHZhciBiUHRyID0gcHRyK2VsZW1TaXplXG4gICAgICBmb3IodmFyIGs9MDsgazxlbGVtU2l6ZTsgKytrLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgICB2YXIgeSA9IGJveGVzW2FQdHJdXG4gICAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgICAgYm94ZXNbYlB0cl0gPSB5XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gaWRzW2pdXG4gICAgICBpZHNbal0gPSBpZHNbai0xXVxuICAgICAgaWRzW2otMV0gPSB0bXBcbiAgICB9XG4gIH1cbn1cblxuLy9GaW5kIG1lZGlhbiB1c2luZyBxdWljayBzZWxlY3QgYWxnb3JpdGhtXG4vLyAgdGFrZXMgTyhuKSB0aW1lIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuZnVuY3Rpb24gZmluZE1lZGlhbihkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIGlmKGVuZCA8PSBzdGFydCsxKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICB2YXIgbG8gICAgICAgPSBzdGFydFxuICB2YXIgaGkgICAgICAgPSBlbmRcbiAgdmFyIG1pZCAgICAgID0gKChlbmQgKyBzdGFydCkgPj4+IDEpXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgcGl2b3QgICAgPSBtaWRcbiAgdmFyIHZhbHVlICAgID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gIFxuICB3aGlsZShsbyA8IGhpKSB7XG4gICAgaWYoaGkgLSBsbyA8IFBBUlRJVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIGluc2VydGlvblNvcnQoZCwgYXhpcywgbG8sIGhpLCBib3hlcywgaWRzKVxuICAgICAgdmFsdWUgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vU2VsZWN0IHBpdm90IHVzaW5nIG1lZGlhbi1vZi0zXG4gICAgdmFyIGNvdW50ICA9IGhpIC0gbG9cbiAgICB2YXIgcGl2b3QwID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUwID0gYm94ZXNbZWxlbVNpemUqcGl2b3QwICsgYXhpc11cbiAgICB2YXIgcGl2b3QxID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUxID0gYm94ZXNbZWxlbVNpemUqcGl2b3QxICsgYXhpc11cbiAgICB2YXIgcGl2b3QyID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUyID0gYm94ZXNbZWxlbVNpemUqcGl2b3QyICsgYXhpc11cbiAgICBpZih2YWx1ZTAgPD0gdmFsdWUxKSB7XG4gICAgICBpZih2YWx1ZTIgPj0gdmFsdWUxKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUwID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodmFsdWUxID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMiA+PSB2YWx1ZTApIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGVuZCBvZiBhcnJheVxuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1BhcnRpdGlvbiB1c2luZyBwaXZvdFxuICAgIHBpdm90ID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgbG8sIGhpLTEsIGJveGVzLCBpZHMsXG4gICAgICB2YWx1ZSlcblxuICAgIC8vU3dhcCBwaXZvdCBiYWNrXG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vU3dhcCBwaXZvdCB0byBsYXN0IHBpdm90XG4gICAgaWYobWlkIDwgcGl2b3QpIHtcbiAgICAgIGhpID0gcGl2b3QtMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJiBcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqKGhpLTEpK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBoaSAtPSAxXG4gICAgICB9XG4gICAgICBoaSArPSAxXG4gICAgfSBlbHNlIGlmKHBpdm90IDwgbWlkKSB7XG4gICAgICBsbyA9IHBpdm90ICsgMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJlxuICAgICAgICBib3hlc1tlbGVtU2l6ZSpsbytheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbG8gKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vTWFrZSBzdXJlIHBpdm90IGlzIGF0IHN0YXJ0XG4gIHJldHVybiBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgIGQsIGF4aXMsIFxuICAgIHN0YXJ0LCBtaWQsIGJveGVzLCBpZHMsXG4gICAgYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdKVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblBhcnRpdGlvblxuXG52YXIgY29kZSA9ICdmb3IodmFyIGo9MiphLGs9aipjLGw9ayxtPWMsbj1iLG89YStiLHA9YztkPnA7KytwLGsrPWope3ZhciBfO2lmKCQpaWYobT09PXApbSs9MSxsKz1qO2Vsc2V7Zm9yKHZhciBzPTA7aj5zOysrcyl7dmFyIHQ9ZVtrK3NdO2VbaytzXT1lW2xdLGVbbCsrXT10fXZhciB1PWZbcF07ZltwXT1mW21dLGZbbSsrXT11fX1yZXR1cm4gbSdcblxuZnVuY3Rpb24gZ2VuUGFydGl0aW9uKHByZWRpY2F0ZSwgYXJncykge1xuICB2YXIgZmFyZ3MgPSdhYmNkZWYnLnNwbGl0KCcnKS5jb25jYXQoYXJncylcbiAgdmFyIHJlYWRzID0gW11cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2xvJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2xvPWVbaytuXScpXG4gIH1cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2hpJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2hpPWVbaytvXScpXG4gIH1cbiAgZmFyZ3MucHVzaChcbiAgICBjb2RlLnJlcGxhY2UoJ18nLCByZWFkcy5qb2luKCkpXG4gICAgICAgIC5yZXBsYWNlKCckJywgcHJlZGljYXRlKSlcbiAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHZvaWQgMCwgZmFyZ3MpXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgY29kZSBpcyBleHRyYWN0ZWQgZnJvbSBuZGFycmF5LXNvcnRcbi8vSXQgaXMgaW5saW5lZCBoZXJlIGFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmRcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyO1xuXG52YXIgSU5TRVJUX1NPUlRfQ1VUT0ZGID0gMzJcblxuZnVuY3Rpb24gd3JhcHBlcihkYXRhLCBuMCkge1xuICBpZiAobjAgPD0gNCpJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgcHRyID0gMioobGVmdCsxKVxuICBmb3IodmFyIGk9bGVmdCsxOyBpPD1yaWdodDsgKytpKSB7XG4gICAgdmFyIGEgPSBkYXRhW3B0cisrXVxuICAgIHZhciBiID0gZGF0YVtwdHIrK11cbiAgICB2YXIgaiA9IGlcbiAgICB2YXIganB0ciA9IHB0ci0yXG4gICAgd2hpbGUoai0tID4gbGVmdCkge1xuICAgICAgdmFyIHggPSBkYXRhW2pwdHItMl1cbiAgICAgIHZhciB5ID0gZGF0YVtqcHRyLTFdXG4gICAgICBpZih4IDwgYSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmKHggPT09IGEgJiYgeSA8IGIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRhdGFbanB0cl0gICA9IHhcbiAgICAgIGRhdGFbanB0cisxXSA9IHlcbiAgICAgIGpwdHIgLT0gMlxuICAgIH1cbiAgICBkYXRhW2pwdHJdICAgPSBhXG4gICAgZGF0YVtqcHRyKzFdID0gYlxuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IHhcbiAgZGF0YVtqKzFdID0geVxufVxuXG5mdW5jdGlvbiBtb3ZlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbn1cblxuZnVuY3Rpb24gcm90YXRlKGksIGosIGssIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBrICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0gZGF0YVtrXVxuICBkYXRhW2orMV0gPSBkYXRhW2srMV1cbiAgZGF0YVtrXSA9IHhcbiAgZGF0YVtrKzFdID0geVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlUGl2b3QoaSwgaiwgcHgsIHB5LCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtqXSA9IHB4XG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2orMV0gPSBweVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV0sXG4gICAgICB5ID0gZGF0YVtqXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPiBkYXRhW2orMV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGl2b3QoaSwgeSwgYiwgZGF0YSkge1xuICBpICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdIDwgYlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWlja1NvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHNpeHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gNiB8IDAsIFxuICAgICAgaW5kZXgxID0gbGVmdCArIHNpeHRoLCBcbiAgICAgIGluZGV4NSA9IHJpZ2h0IC0gc2l4dGgsIFxuICAgICAgaW5kZXgzID0gbGVmdCArIHJpZ2h0ID4+IDEsIFxuICAgICAgaW5kZXgyID0gaW5kZXgzIC0gc2l4dGgsIFxuICAgICAgaW5kZXg0ID0gaW5kZXgzICsgc2l4dGgsIFxuICAgICAgZWwxID0gaW5kZXgxLCBcbiAgICAgIGVsMiA9IGluZGV4MiwgXG4gICAgICBlbDMgPSBpbmRleDMsIFxuICAgICAgZWw0ID0gaW5kZXg0LCBcbiAgICAgIGVsNSA9IGluZGV4NSwgXG4gICAgICBsZXNzID0gbGVmdCArIDEsIFxuICAgICAgZ3JlYXQgPSByaWdodCAtIDEsIFxuICAgICAgdG1wID0gMFxuICBpZihjb21wYXJlKGVsMSwgZWwyLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsMlxuICAgIGVsMiA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDMsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDNcbiAgICBlbDMgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuXG4gIHZhciBwaXZvdDFYID0gZGF0YVsyKmVsMl1cbiAgdmFyIHBpdm90MVkgPSBkYXRhWzIqZWwyKzFdXG4gIHZhciBwaXZvdDJYID0gZGF0YVsyKmVsNF1cbiAgdmFyIHBpdm90MlkgPSBkYXRhWzIqZWw0KzFdXG5cbiAgdmFyIHB0cjAgPSAyICogZWwxO1xuICB2YXIgcHRyMiA9IDIgKiBlbDM7XG4gIHZhciBwdHI0ID0gMiAqIGVsNTtcbiAgdmFyIHB0cjUgPSAyICogaW5kZXgxO1xuICB2YXIgcHRyNiA9IDIgKiBpbmRleDM7XG4gIHZhciBwdHI3ID0gMiAqIGluZGV4NTtcbiAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IDI7ICsraTEpIHtcbiAgICB2YXIgeCA9IGRhdGFbcHRyMCtpMV07XG4gICAgdmFyIHkgPSBkYXRhW3B0cjIraTFdO1xuICAgIHZhciB6ID0gZGF0YVtwdHI0K2kxXTtcbiAgICBkYXRhW3B0cjUraTFdID0geDtcbiAgICBkYXRhW3B0cjYraTFdID0geTtcbiAgICBkYXRhW3B0cjcraTFdID0gejtcbiAgfVxuXG4gIG1vdmUoaW5kZXgyLCBsZWZ0LCBkYXRhKVxuICBtb3ZlKGluZGV4NCwgcmlnaHQsIGRhdGEpXG4gIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyArK2spIHtcbiAgICBpZiAoY29tcGFyZVBpdm90KGssIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICBzd2FwKGssIGxlc3MsIGRhdGEpXG4gICAgICB9XG4gICAgICArK2xlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY29tcGFyZVBpdm90KGssIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoLS1ncmVhdCA8IGspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGssIGxlc3MsIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICArK2xlc3M7XG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2FwKGssIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNodWZmbGVQaXZvdChsZWZ0LCBsZXNzLTEsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpXG4gIHNodWZmbGVQaXZvdChyaWdodCwgZ3JlYXQrMSwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSlcbiAgaWYgKGxlc3MgLSAyIC0gbGVmdCA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9XG4gIGlmIChyaWdodCAtIChncmVhdCArIDIpIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9XG4gIGlmIChncmVhdCAtIGxlc3MgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogICAgICAgICAgIHNxSW5pdCxcbiAgc3dlZXBCaXBhcnRpdGU6IHN3ZWVwQmlwYXJ0aXRlLFxuICBzd2VlcENvbXBsZXRlOiAgc3dlZXBDb21wbGV0ZSxcbiAgc2NhbkJpcGFydGl0ZTogIHNjYW5CaXBhcnRpdGUsXG4gIHNjYW5Db21wbGV0ZTogICBzY2FuQ29tcGxldGVcbn1cblxudmFyIHBvb2wgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzICA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBpc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpXG5cbi8vRmxhZyBmb3IgYmx1ZVxudmFyIEJMVUVfRkxBRyA9ICgxPDwyOClcblxuLy8xRCBzd2VlcCBldmVudCBxdWV1ZSBzdHVmZiAodXNlIHBvb2wgdG8gc2F2ZSBzcGFjZSlcbnZhciBJTklUX0NBUEFDSVRZICAgICAgPSAxMDI0XG52YXIgUkVEX1NXRUVQX1FVRVVFICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFJFRF9TV0VFUF9JTkRFWCAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX1FVRVVFICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9JTkRFWCAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgU1dFRVBfRVZFTlRTICAgICAgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSAqIDgpXG5cbi8vUmVzZXJ2ZXMgbWVtb3J5IGZvciB0aGUgMUQgc3dlZXAgZGF0YSBzdHJ1Y3R1cmVzXG5mdW5jdGlvbiBzcUluaXQoY291bnQpIHtcbiAgdmFyIHJjb3VudCA9IGJpdHMubmV4dFBvdzIoY291bnQpXG4gIGlmKFJFRF9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX1FVRVVFKVxuICAgIFJFRF9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKFJFRF9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX0lOREVYKVxuICAgIFJFRF9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfUVVFVUUpXG4gICAgQkxVRV9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfSU5ERVgpXG4gICAgQkxVRV9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX1FVRVVFKVxuICAgIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX0lOREVYKVxuICAgIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIHZhciBldmVudExlbmd0aCA9IDggKiByY291bnRcbiAgaWYoU1dFRVBfRVZFTlRTLmxlbmd0aCA8IGV2ZW50TGVuZ3RoKSB7XG4gICAgcG9vbC5mcmVlKFNXRUVQX0VWRU5UUylcbiAgICBTV0VFUF9FVkVOVFMgPSBwb29sLm1hbGxvY0RvdWJsZShldmVudExlbmd0aClcbiAgfVxufVxuXG4vL1JlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVBvcChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHZhciBpZHggPSBpbmRleFtpdGVtXVxuICB2YXIgdG9wID0gcXVldWVbY291bnQtMV1cbiAgcXVldWVbaWR4XSA9IHRvcFxuICBpbmRleFt0b3BdID0gaWR4XG59XG5cbi8vSW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUHVzaChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHF1ZXVlW2NvdW50XSA9IGl0ZW1cbiAgaW5kZXhbaXRlbV0gID0gY291bnRcbn1cblxuLy9SZWN1cnNpb24gYmFzZSBjYXNlOiB1c2UgMUQgc3dlZXAgYWxnb3JpdGhtXG5mdW5jdGlvbiBzd2VlcEJpcGFydGl0ZShcbiAgICBkLCB2aXNpdCxcbiAgICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIC8vc3RvcmUgZXZlbnRzIGFzIHBhaXJzIFtjb29yZGluYXRlLCBpZHhdXG4gIC8vXG4gIC8vICByZWQgY3JlYXRlOiAgLShpZHgrMSlcbiAgLy8gIHJlZCBkZXN0cm95OiBpZHhcbiAgLy8gIGJsdWUgY3JlYXRlOiAtKGlkeCtCTFVFX0ZMQUcpXG4gIC8vICBibHVlIGRlc3Ryb3k6IGlkeCtCTFVFX0ZMQUdcbiAgLy9cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gcmVkSW5kZXhbaV1cbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLShpZHgrMSlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGJsdWVJbmRleFtpXStCTFVFX0ZMQUdcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgPSAwXG4gIHZhciBibHVlQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPj0gQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgZGVzdHJveSBldmVudFxuICAgICAgZSA9IChlLUJMVUVfRkxBRyl8MFxuICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlID49IDApIHtcbiAgICAgIC8vcmVkIGRlc3Ryb3kgZXZlbnRcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA8PSAtQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLUJMVUVfRkxBRyl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgZSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcmVkIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS0xKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KGUsIEJMVUVfU1dFRVBfUVVFVUVbal0pXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBlKVxuICAgIH1cbiAgfVxufVxuXG4vL0NvbXBsZXRlIHN3ZWVwXG5mdW5jdGlvbiBzd2VlcENvbXBsZXRlKGQsIHZpc2l0LCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAocmVkSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGJsdWVJbmRleFtpXSsxKTw8MVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAoLWlkeCl8MVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4fDFcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSAgID0gMFxuICB2YXIgY29tbW9uQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSAgICAgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICB2YXIgY29sb3IgPSBlJjFcbiAgICBpZihpIDwgbi0xICYmIChlPj4xKSA9PT0gKFNXRUVQX0VWRU5UU1syKmkrM10+PjEpKSB7XG4gICAgICBjb2xvciA9IDJcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgICBcbiAgICBpZihlIDwgMCkge1xuICAgICAgLy9DcmVhdGUgZXZlbnRcbiAgICAgIHZhciBpZCA9IC0oZT4+MSkgLSAxXG5cbiAgICAgIC8vSW50ZXJzZWN0IHdpdGggY29tbW9uXG4gICAgICBmb3IodmFyIGo9MDsgajxjb21tb25BY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQ09NTU9OX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDApIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCByZWRcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMSkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIGJsdWVcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KEJMVUVfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQdXNoKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUrKywgaWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vRGVzdHJveSBldmVudFxuICAgICAgdmFyIGlkID0gKGU+PjEpIC0gMVxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQb3AoQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZS0tLCBpZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9Td2VlcCBhbmQgcHJ1bmUvc2NhbmxpbmUgYWxnb3JpdGhtOlxuLy8gIFNjYW4gYWxvbmcgYXhpcywgZGV0ZWN0IGludGVyc2VjdGlvbnNcbi8vICBCcnV0ZSBmb3JjZSBhbGwgYm94ZXMgYWxvbmcgYXhpc1xuZnVuY3Rpb24gc2NhbkJpcGFydGl0ZShcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuICBcbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICB2YXIgcmVkU2hpZnQgID0gMVxuICB2YXIgYmx1ZVNoaWZ0ID0gMVxuICBpZihmbGlwKSB7XG4gICAgYmx1ZVNoaWZ0ID0gQkxVRV9GTEFHXG4gIH0gZWxzZSB7XG4gICAgcmVkU2hpZnQgID0gQkxVRV9GTEFHXG4gIH1cblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIHJlZFNoaWZ0XG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgYmx1ZVNoaWZ0XG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgdmFyIGlzUmVkID0gZmFsc2VcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgaXNSZWQgPSAhZmxpcFxuICAgICAgICBpZHggLT0gQkxVRV9GTEFHIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSZWQgPSAhIWZsaXBcbiAgICAgICAgaWR4IC09IDFcbiAgICAgIH1cbiAgICAgIGlmKGlzUmVkKSB7XG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkeClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuICAgICAgICBcbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuXG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG4gICAgICAgICAgdmFyIHJldHZhbFxuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUgLSByZWRTaGlmdClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkNvbXBsZXRlKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIEJMVUVfRkxBR1xuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIFJFRF9TV0VFUF9RVUVVRVtyZWRBY3RpdmUrK10gPSBpZHggLSBCTFVFX0ZMQUdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCAtPSAxXG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuXG4gICAgICAgICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSAgIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkeCA9IGUgLSBCTFVFX0ZMQUdcbiAgICAgIGZvcih2YXIgaj1yZWRBY3RpdmUtMTsgaj49MDsgLS1qKSB7XG4gICAgICAgIGlmKFJFRF9TV0VFUF9RVUVVRVtqXSA9PT0gaWR4KSB7XG4gICAgICAgICAgZm9yKHZhciBrPWorMTsgazxyZWRBY3RpdmU7ICsraykge1xuICAgICAgICAgICAgUkVEX1NXRUVQX1FVRVVFW2stMV0gPSBSRURfU1dFRVBfUVVFVUVba11cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS1yZWRBY3RpdmVcbiAgICB9XG4gIH1cbn0iLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbW9ub3RvbmVUcmlhbmd1bGF0ZSA9IHJlcXVpcmUoJy4vbGliL21vbm90b25lJylcbnZhciBtYWtlSW5kZXggPSByZXF1aXJlKCcuL2xpYi90cmlhbmd1bGF0aW9uJylcbnZhciBkZWxhdW5heUZsaXAgPSByZXF1aXJlKCcuL2xpYi9kZWxhdW5heScpXG52YXIgZmlsdGVyVHJpYW5ndWxhdGlvbiA9IHJlcXVpcmUoJy4vbGliL2ZpbHRlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gY2R0MmRcblxuZnVuY3Rpb24gY2Fub25pY2FsaXplRWRnZShlKSB7XG4gIHJldHVybiBbTWF0aC5taW4oZVswXSwgZVsxXSksIE1hdGgubWF4KGVbMF0sIGVbMV0pXVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRWRnZShhLCBiKSB7XG4gIHJldHVybiBhWzBdLWJbMF0gfHwgYVsxXS1iWzFdXG59XG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUVkZ2VzKGVkZ2VzKSB7XG4gIHJldHVybiBlZGdlcy5tYXAoY2Fub25pY2FsaXplRWRnZSkuc29ydChjb21wYXJlRWRnZSlcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdChvcHRpb25zLCBwcm9wZXJ0eSwgZGZsdCkge1xuICBpZihwcm9wZXJ0eSBpbiBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNbcHJvcGVydHldXG4gIH1cbiAgcmV0dXJuIGRmbHRcbn1cblxuZnVuY3Rpb24gY2R0MmQocG9pbnRzLCBlZGdlcywgb3B0aW9ucykge1xuXG4gIGlmKCFBcnJheS5pc0FycmF5KGVkZ2VzKSkge1xuICAgIG9wdGlvbnMgPSBlZGdlcyB8fCB7fVxuICAgIGVkZ2VzID0gW11cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGVkZ2VzID0gZWRnZXMgfHwgW11cbiAgfVxuXG4gIC8vUGFyc2Ugb3V0IG9wdGlvbnNcbiAgdmFyIGRlbGF1bmF5ID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdkZWxhdW5heScsIHRydWUpXG4gIHZhciBpbnRlcmlvciA9ICEhZ2V0RGVmYXVsdChvcHRpb25zLCAnaW50ZXJpb3InLCB0cnVlKVxuICB2YXIgZXh0ZXJpb3IgPSAhIWdldERlZmF1bHQob3B0aW9ucywgJ2V4dGVyaW9yJywgdHJ1ZSlcbiAgdmFyIGluZmluaXR5ID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdpbmZpbml0eScsIGZhbHNlKVxuXG4gIC8vSGFuZGxlIHRyaXZpYWwgY2FzZVxuICBpZigoIWludGVyaW9yICYmICFleHRlcmlvcikgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy9Db25zdHJ1Y3QgaW5pdGlhbCB0cmlhbmd1bGF0aW9uXG4gIHZhciBjZWxscyA9IG1vbm90b25lVHJpYW5ndWxhdGUocG9pbnRzLCBlZGdlcylcblxuICAvL0lmIGRlbGF1bmF5IHJlZmluZW1lbnQgbmVlZGVkLCB0aGVuIGltcHJvdmUgcXVhbGl0eSBieSBlZGdlIGZsaXBwaW5nXG4gIGlmKGRlbGF1bmF5IHx8IGludGVyaW9yICE9PSBleHRlcmlvciB8fCBpbmZpbml0eSkge1xuXG4gICAgLy9JbmRleCBhbGwgb2YgdGhlIGNlbGxzIHRvIHN1cHBvcnQgZmFzdCBuZWlnaGJvcmhvb2QgcXVlcmllc1xuICAgIHZhciB0cmlhbmd1bGF0aW9uID0gbWFrZUluZGV4KHBvaW50cy5sZW5ndGgsIGNhbm9uaWNhbGl6ZUVkZ2VzKGVkZ2VzKSlcbiAgICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGYgPSBjZWxsc1tpXVxuICAgICAgdHJpYW5ndWxhdGlvbi5hZGRUcmlhbmdsZShmWzBdLCBmWzFdLCBmWzJdKVxuICAgIH1cblxuICAgIC8vUnVuIGVkZ2UgZmxpcHBpbmdcbiAgICBpZihkZWxhdW5heSkge1xuICAgICAgZGVsYXVuYXlGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbilcbiAgICB9XG5cbiAgICAvL0ZpbHRlciBwb2ludHNcbiAgICBpZighZXh0ZXJpb3IpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sIC0xKVxuICAgIH0gZWxzZSBpZighaW50ZXJpb3IpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sICAxLCBpbmZpbml0eSlcbiAgICB9IGVsc2UgaWYoaW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sIDAsIGluZmluaXR5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJpYW5ndWxhdGlvbi5jZWxscygpXG4gICAgfVxuICAgIFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZWxsc1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGluQ2lyY2xlID0gcmVxdWlyZSgncm9idXN0LWluLXNwaGVyZScpWzRdXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBkZWxhdW5heVJlZmluZVxuXG5mdW5jdGlvbiB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCBhLCBiLCB4KSB7XG4gIHZhciB5ID0gdHJpYW5ndWxhdGlvbi5vcHBvc2l0ZShhLCBiKVxuXG4gIC8vVGVzdCBib3VuZGFyeSBlZGdlXG4gIGlmKHkgPCAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL1N3YXAgZWRnZSBpZiBvcmRlciBmbGlwcGVkXG4gIGlmKGIgPCBhKSB7XG4gICAgdmFyIHRtcCA9IGFcbiAgICBhID0gYlxuICAgIGIgPSB0bXBcbiAgICB0bXAgPSB4XG4gICAgeCA9IHlcbiAgICB5ID0gdG1wXG4gIH1cblxuICAvL1Rlc3QgaWYgZWRnZSBpcyBjb25zdHJhaW5lZFxuICBpZih0cmlhbmd1bGF0aW9uLmlzQ29uc3RyYWludChhLCBiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9UZXN0IGlmIGVkZ2UgaXMgZGVsYXVuYXlcbiAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA8IDApIHtcbiAgICBzdGFjay5wdXNoKGEsIGIpXG4gIH1cbn1cblxuLy9Bc3N1bWUgZWRnZXMgYXJlIHNvcnRlZCBsZXhpY29ncmFwaGljYWxseVxuZnVuY3Rpb24gZGVsYXVuYXlSZWZpbmUocG9pbnRzLCB0cmlhbmd1bGF0aW9uKSB7XG4gIHZhciBzdGFjayA9IFtdXG5cbiAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIHN0YXJzID0gdHJpYW5ndWxhdGlvbi5zdGFyc1xuICBmb3IodmFyIGE9MDsgYTxudW1Qb2ludHM7ICsrYSkge1xuICAgIHZhciBzdGFyID0gc3RhcnNbYV1cbiAgICBmb3IodmFyIGo9MTsgajxzdGFyLmxlbmd0aDsgais9Mikge1xuICAgICAgdmFyIGIgPSBzdGFyW2pdXG5cbiAgICAgIC8vSWYgb3JkZXIgaXMgbm90IGNvbnNpc3RlbnQsIHRoZW4gc2tpcCBlZGdlXG4gICAgICBpZihiIDwgYSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvL0NoZWNrIGlmIGVkZ2UgaXMgY29uc3RyYWluZWRcbiAgICAgIGlmKHRyaWFuZ3VsYXRpb24uaXNDb25zdHJhaW50KGEsIGIpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vRmluZCBvcHBvc2l0ZSBlZGdlXG4gICAgICB2YXIgeCA9IHN0YXJbai0xXSwgeSA9IC0xXG4gICAgICBmb3IodmFyIGs9MTsgazxzdGFyLmxlbmd0aDsgays9Mikge1xuICAgICAgICBpZihzdGFyW2stMV0gPT09IGIpIHtcbiAgICAgICAgICB5ID0gc3RhcltrXVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9JZiB0aGlzIGlzIGEgYm91bmRhcnkgZWRnZSwgZG9uJ3QgZmxpcCBpdFxuICAgICAgaWYoeSA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy9JZiBlZGdlIGlzIGluIGNpcmNsZSwgZmxpcCBpdFxuICAgICAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA8IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChhLCBiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpXG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKVxuXG4gICAgLy9GaW5kIG9wcG9zaXRlIHBhaXJzXG4gICAgdmFyIHggPSAtMSwgeSA9IC0xXG4gICAgdmFyIHN0YXIgPSBzdGFyc1thXVxuICAgIGZvcih2YXIgaT0xOyBpPHN0YXIubGVuZ3RoOyBpKz0yKSB7XG4gICAgICB2YXIgcyA9IHN0YXJbaS0xXVxuICAgICAgdmFyIHQgPSBzdGFyW2ldXG4gICAgICBpZihzID09PSBiKSB7XG4gICAgICAgIHkgPSB0XG4gICAgICB9IGVsc2UgaWYodCA9PT0gYikge1xuICAgICAgICB4ID0gc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vSWYgeC95IGFyZSBib3RoIHZhbGlkIHRoZW4gc2tpcCBlZGdlXG4gICAgaWYoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy9JZiBlZGdlIGlzIG5vdyBkZWxhdW5heSwgdGhlbiBkb24ndCBmbGlwIGl0XG4gICAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA+PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vRmxpcCB0aGUgZWRnZVxuICAgIHRyaWFuZ3VsYXRpb24uZmxpcChhLCBiKVxuXG4gICAgLy9UZXN0IGZsaXBwaW5nIG5laWdoYm9yaW5nIGVkZ2VzXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgeCwgYSwgeSlcbiAgICB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCBhLCB5LCB4KVxuICAgIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIHksIGIsIHgpXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgYiwgeCwgeSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzaWZ5RmFjZXNcblxuZnVuY3Rpb24gRmFjZUluZGV4KGNlbGxzLCBuZWlnaGJvciwgY29uc3RyYWludCwgZmxhZ3MsIGFjdGl2ZSwgbmV4dCwgYm91bmRhcnkpIHtcbiAgdGhpcy5jZWxscyAgICAgICA9IGNlbGxzXG4gIHRoaXMubmVpZ2hib3IgICAgPSBuZWlnaGJvclxuICB0aGlzLmZsYWdzICAgICAgID0gZmxhZ3NcbiAgdGhpcy5jb25zdHJhaW50ICA9IGNvbnN0cmFpbnRcbiAgdGhpcy5hY3RpdmUgICAgICA9IGFjdGl2ZVxuICB0aGlzLm5leHQgICAgICAgID0gbmV4dFxuICB0aGlzLmJvdW5kYXJ5ICAgID0gYm91bmRhcnlcbn1cblxudmFyIHByb3RvID0gRmFjZUluZGV4LnByb3RvdHlwZVxuXG5mdW5jdGlvbiBjb21wYXJlQ2VsbChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXSB8fFxuICAgICAgICAgYVsxXSAtIGJbMV0gfHxcbiAgICAgICAgIGFbMl0gLSBiWzJdXG59XG5cbnByb3RvLmxvY2F0ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGtleSA9IFswLDAsMF1cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICB2YXIgeCA9IGEsIHkgPSBiLCB6ID0gY1xuICAgIGlmKGIgPCBjKSB7XG4gICAgICBpZihiIDwgYSkge1xuICAgICAgICB4ID0gYlxuICAgICAgICB5ID0gY1xuICAgICAgICB6ID0gYVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihjIDwgYSkge1xuICAgICAgeCA9IGNcbiAgICAgIHkgPSBhXG4gICAgICB6ID0gYlxuICAgIH1cbiAgICBpZih4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGtleVswXSA9IHhcbiAgICBrZXlbMV0gPSB5XG4gICAga2V5WzJdID0gelxuICAgIHJldHVybiBic2VhcmNoLmVxKHRoaXMuY2VsbHMsIGtleSwgY29tcGFyZUNlbGwpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gaW5kZXhDZWxscyh0cmlhbmd1bGF0aW9uLCBpbmZpbml0eSkge1xuICAvL0ZpcnN0IGdldCBjZWxscyBhbmQgY2Fub25pY2FsaXplXG4gIHZhciBjZWxscyA9IHRyaWFuZ3VsYXRpb24uY2VsbHMoKVxuICB2YXIgbmMgPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICB2YXIgeCA9IGNbMF0sIHkgPSBjWzFdLCB6ID0gY1syXVxuICAgIGlmKHkgPCB6KSB7XG4gICAgICBpZih5IDwgeCkge1xuICAgICAgICBjWzBdID0geVxuICAgICAgICBjWzFdID0gelxuICAgICAgICBjWzJdID0geFxuICAgICAgfVxuICAgIH0gZWxzZSBpZih6IDwgeCkge1xuICAgICAgY1swXSA9IHpcbiAgICAgIGNbMV0gPSB4XG4gICAgICBjWzJdID0geVxuICAgIH1cbiAgfVxuICBjZWxscy5zb3J0KGNvbXBhcmVDZWxsKVxuXG4gIC8vSW5pdGlhbGl6ZSBmbGFnIGFycmF5XG4gIHZhciBmbGFncyA9IG5ldyBBcnJheShuYylcbiAgZm9yKHZhciBpPTA7IGk8ZmxhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBmbGFnc1tpXSA9IDBcbiAgfVxuXG4gIC8vQnVpbGQgbmVpZ2hib3IgaW5kZXgsIGluaXRpYWxpemUgcXVldWVzXG4gIHZhciBhY3RpdmUgPSBbXVxuICB2YXIgbmV4dCAgID0gW11cbiAgdmFyIG5laWdoYm9yID0gbmV3IEFycmF5KDMqbmMpXG4gIHZhciBjb25zdHJhaW50ID0gbmV3IEFycmF5KDMqbmMpXG4gIHZhciBib3VuZGFyeSA9IG51bGxcbiAgaWYoaW5maW5pdHkpIHtcbiAgICBib3VuZGFyeSA9IFtdXG4gIH1cbiAgdmFyIGluZGV4ID0gbmV3IEZhY2VJbmRleChcbiAgICBjZWxscyxcbiAgICBuZWlnaGJvcixcbiAgICBjb25zdHJhaW50LFxuICAgIGZsYWdzLFxuICAgIGFjdGl2ZSxcbiAgICBuZXh0LFxuICAgIGJvdW5kYXJ5KVxuICBmb3IodmFyIGk9MDsgaTxuYzsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPDM7ICsraikge1xuICAgICAgdmFyIHggPSBjW2pdLCB5ID0gY1soaisxKSUzXVxuICAgICAgdmFyIGEgPSBuZWlnaGJvclszKmkral0gPSBpbmRleC5sb2NhdGUoeSwgeCwgdHJpYW5ndWxhdGlvbi5vcHBvc2l0ZSh5LCB4KSlcbiAgICAgIHZhciBiID0gY29uc3RyYWludFszKmkral0gPSB0cmlhbmd1bGF0aW9uLmlzQ29uc3RyYWludCh4LCB5KVxuICAgICAgaWYoYSA8IDApIHtcbiAgICAgICAgaWYoYikge1xuICAgICAgICAgIG5leHQucHVzaChpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZS5wdXNoKGkpXG4gICAgICAgICAgZmxhZ3NbaV0gPSAxXG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5maW5pdHkpIHtcbiAgICAgICAgICBib3VuZGFyeS5wdXNoKFt5LCB4LCAtMV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNlbGxzKGNlbGxzLCBmbGFncywgdGFyZ2V0KSB7XG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYoZmxhZ3NbaV0gPT09IHRhcmdldCkge1xuICAgICAgY2VsbHNbcHRyKytdID0gY2VsbHNbaV1cbiAgICB9XG4gIH1cbiAgY2VsbHMubGVuZ3RoID0gcHRyXG4gIHJldHVybiBjZWxsc1xufVxuXG5mdW5jdGlvbiBjbGFzc2lmeUZhY2VzKHRyaWFuZ3VsYXRpb24sIHRhcmdldCwgaW5maW5pdHkpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhDZWxscyh0cmlhbmd1bGF0aW9uLCBpbmZpbml0eSlcblxuICBpZih0YXJnZXQgPT09IDApIHtcbiAgICBpZihpbmZpbml0eSkge1xuICAgICAgcmV0dXJuIGluZGV4LmNlbGxzLmNvbmNhdChpbmRleC5ib3VuZGFyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZGV4LmNlbGxzXG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZGUgPSAxXG4gIHZhciBhY3RpdmUgPSBpbmRleC5hY3RpdmVcbiAgdmFyIG5leHQgPSBpbmRleC5uZXh0XG4gIHZhciBmbGFncyA9IGluZGV4LmZsYWdzXG4gIHZhciBjZWxscyA9IGluZGV4LmNlbGxzXG4gIHZhciBjb25zdHJhaW50ID0gaW5kZXguY29uc3RyYWludFxuICB2YXIgbmVpZ2hib3IgPSBpbmRleC5uZWlnaGJvclxuXG4gIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwIHx8IG5leHQubGVuZ3RoID4gMCkge1xuICAgIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdCA9IGFjdGl2ZS5wb3AoKVxuICAgICAgaWYoZmxhZ3NbdF0gPT09IC1zaWRlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmbGFnc1t0XSA9IHNpZGVcbiAgICAgIHZhciBjID0gY2VsbHNbdF1cbiAgICAgIGZvcih2YXIgaj0wOyBqPDM7ICsraikge1xuICAgICAgICB2YXIgZiA9IG5laWdoYm9yWzMqdCtqXVxuICAgICAgICBpZihmID49IDAgJiYgZmxhZ3NbZl0gPT09IDApIHtcbiAgICAgICAgICBpZihjb25zdHJhaW50WzMqdCtqXSkge1xuICAgICAgICAgICAgbmV4dC5wdXNoKGYpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGYpXG4gICAgICAgICAgICBmbGFnc1tmXSA9IHNpZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1N3YXAgYXJyYXlzIGFuZCBsb29wXG4gICAgdmFyIHRtcCA9IG5leHRcbiAgICBuZXh0ID0gYWN0aXZlXG4gICAgYWN0aXZlID0gdG1wXG4gICAgbmV4dC5sZW5ndGggPSAwXG4gICAgc2lkZSA9IC1zaWRlXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gZmlsdGVyQ2VsbHMoY2VsbHMsIGZsYWdzLCB0YXJnZXQpXG4gIGlmKGluZmluaXR5KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoaW5kZXguYm91bmRhcnkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG5cbnZhciBFVkVOVF9QT0lOVCA9IDBcbnZhciBFVkVOVF9FTkQgICA9IDFcbnZhciBFVkVOVF9TVEFSVCA9IDJcblxubW9kdWxlLmV4cG9ydHMgPSBtb25vdG9uZVRyaWFuZ3VsYXRlXG5cbi8vQSBwYXJ0aWFsIGNvbnZleCBodWxsIGZyYWdtZW50LCBtYWRlIG9mIHR3byB1bmltb25vdG9uZSBwb2x5Z29uc1xuZnVuY3Rpb24gUGFydGlhbEh1bGwoYSwgYiwgaWR4LCBsb3dlcklkcywgdXBwZXJJZHMpIHtcbiAgdGhpcy5hID0gYVxuICB0aGlzLmIgPSBiXG4gIHRoaXMuaWR4ID0gaWR4XG4gIHRoaXMubG93ZXJJZHMgPSBsb3dlcklkc1xuICB0aGlzLnVwcGVySWRzID0gdXBwZXJJZHNcbn1cblxuLy9BbiBldmVudCBpbiB0aGUgc3dlZXAgbGluZSBwcm9jZWR1cmVcbmZ1bmN0aW9uIEV2ZW50KGEsIGIsIHR5cGUsIGlkeCkge1xuICB0aGlzLmEgICAgPSBhXG4gIHRoaXMuYiAgICA9IGJcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLmlkeCAgPSBpZHhcbn1cblxuLy9UaGlzIGlzIHVzZWQgdG8gY29tcGFyZSBldmVudHMgZm9yIHRoZSBzd2VlcCBsaW5lIHByb2NlZHVyZVxuLy8gUG9pbnRzIGFyZTpcbi8vICAxLiBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHlcbi8vICAyLiBzb3J0ZWQgYnkgdHlwZSAgKHBvaW50IDwgZW5kIDwgc3RhcnQpXG4vLyAgMy4gc2VnbWVudHMgc29ydGVkIGJ5IHdpbmRpbmcgb3JkZXJcbi8vICA0LiBzb3J0ZWQgYnkgaW5kZXhcbmZ1bmN0aW9uIGNvbXBhcmVFdmVudChhLCBiKSB7XG4gIHZhciBkID1cbiAgICAoYS5hWzBdIC0gYi5hWzBdKSB8fFxuICAgIChhLmFbMV0gLSBiLmFbMV0pIHx8XG4gICAgKGEudHlwZSAtIGIudHlwZSlcbiAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIGlmKGEudHlwZSAhPT0gRVZFTlRfUE9JTlQpIHtcbiAgICBkID0gb3JpZW50KGEuYSwgYS5iLCBiLmIpXG4gICAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIH1cbiAgcmV0dXJuIGEuaWR4IC0gYi5pZHhcbn1cblxuZnVuY3Rpb24gdGVzdFBvaW50KGh1bGwsIHApIHtcbiAgcmV0dXJuIG9yaWVudChodWxsLmEsIGh1bGwuYiwgcClcbn1cblxuZnVuY3Rpb24gYWRkUG9pbnQoY2VsbHMsIGh1bGxzLCBwb2ludHMsIHAsIGlkeCkge1xuICB2YXIgbG8gPSBic2VhcmNoLmx0KGh1bGxzLCBwLCB0ZXN0UG9pbnQpXG4gIHZhciBoaSA9IGJzZWFyY2guZ3QoaHVsbHMsIHAsIHRlc3RQb2ludClcbiAgZm9yKHZhciBpPWxvOyBpPGhpOyArK2kpIHtcbiAgICB2YXIgaHVsbCA9IGh1bGxzW2ldXG5cbiAgICAvL0luc2VydCBwIGludG8gbG93ZXIgaHVsbFxuICAgIHZhciBsb3dlcklkcyA9IGh1bGwubG93ZXJJZHNcbiAgICB2YXIgbSA9IGxvd2VySWRzLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW2xvd2VySWRzW20tMl1dLFxuICAgICAgICBwb2ludHNbbG93ZXJJZHNbbS0xXV0sXG4gICAgICAgIHApID4gMCkge1xuICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgW2xvd2VySWRzW20tMV0sXG4gICAgICAgICBsb3dlcklkc1ttLTJdLFxuICAgICAgICAgaWR4XSlcbiAgICAgIG0gLT0gMVxuICAgIH1cbiAgICBsb3dlcklkcy5sZW5ndGggPSBtXG4gICAgbG93ZXJJZHMucHVzaChpZHgpXG5cbiAgICAvL0luc2VydCBwIGludG8gdXBwZXIgaHVsbFxuICAgIHZhciB1cHBlcklkcyA9IGh1bGwudXBwZXJJZHNcbiAgICB2YXIgbSA9IHVwcGVySWRzLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW3VwcGVySWRzW20tMl1dLFxuICAgICAgICBwb2ludHNbdXBwZXJJZHNbbS0xXV0sXG4gICAgICAgIHApIDwgMCkge1xuICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgW3VwcGVySWRzW20tMl0sXG4gICAgICAgICB1cHBlcklkc1ttLTFdLFxuICAgICAgICAgaWR4XSlcbiAgICAgIG0gLT0gMVxuICAgIH1cbiAgICB1cHBlcklkcy5sZW5ndGggPSBtXG4gICAgdXBwZXJJZHMucHVzaChpZHgpXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNwbGl0KGh1bGwsIGVkZ2UpIHtcbiAgdmFyIGRcbiAgaWYoaHVsbC5hWzBdIDwgZWRnZS5hWzBdKSB7XG4gICAgZCA9IG9yaWVudChodWxsLmEsIGh1bGwuYiwgZWRnZS5hKVxuICB9IGVsc2Uge1xuICAgIGQgPSBvcmllbnQoZWRnZS5iLCBlZGdlLmEsIGh1bGwuYSlcbiAgfVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgaWYoZWRnZS5iWzBdIDwgaHVsbC5iWzBdKSB7XG4gICAgZCA9IG9yaWVudChodWxsLmEsIGh1bGwuYiwgZWRnZS5iKVxuICB9IGVsc2Uge1xuICAgIGQgPSBvcmllbnQoZWRnZS5iLCBlZGdlLmEsIGh1bGwuYilcbiAgfVxuICByZXR1cm4gZCB8fCBodWxsLmlkeCAtIGVkZ2UuaWR4XG59XG5cbmZ1bmN0aW9uIHNwbGl0SHVsbHMoaHVsbHMsIHBvaW50cywgZXZlbnQpIHtcbiAgdmFyIHNwbGl0SWR4ID0gYnNlYXJjaC5sZShodWxscywgZXZlbnQsIGZpbmRTcGxpdClcbiAgdmFyIGh1bGwgPSBodWxsc1tzcGxpdElkeF1cbiAgdmFyIHVwcGVySWRzID0gaHVsbC51cHBlcklkc1xuICB2YXIgeCA9IHVwcGVySWRzW3VwcGVySWRzLmxlbmd0aC0xXVxuICBodWxsLnVwcGVySWRzID0gW3hdXG4gIGh1bGxzLnNwbGljZShzcGxpdElkeCsxLCAwLFxuICAgIG5ldyBQYXJ0aWFsSHVsbChldmVudC5hLCBldmVudC5iLCBldmVudC5pZHgsIFt4XSwgdXBwZXJJZHMpKVxufVxuXG5cbmZ1bmN0aW9uIG1lcmdlSHVsbHMoaHVsbHMsIHBvaW50cywgZXZlbnQpIHtcbiAgLy9Td2FwIHBvaW50ZXJzIGZvciBtZXJnZSBzZWFyY2hcbiAgdmFyIHRtcCA9IGV2ZW50LmFcbiAgZXZlbnQuYSA9IGV2ZW50LmJcbiAgZXZlbnQuYiA9IHRtcFxuICB2YXIgbWVyZ2VJZHggPSBic2VhcmNoLmVxKGh1bGxzLCBldmVudCwgZmluZFNwbGl0KVxuICB2YXIgdXBwZXIgPSBodWxsc1ttZXJnZUlkeF1cbiAgdmFyIGxvd2VyID0gaHVsbHNbbWVyZ2VJZHgtMV1cbiAgbG93ZXIudXBwZXJJZHMgPSB1cHBlci51cHBlcklkc1xuICBodWxscy5zcGxpY2UobWVyZ2VJZHgsIDEpXG59XG5cblxuZnVuY3Rpb24gbW9ub3RvbmVUcmlhbmd1bGF0ZShwb2ludHMsIGVkZ2VzKSB7XG5cbiAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoXG5cbiAgdmFyIGV2ZW50cyA9IFtdXG5cbiAgLy9DcmVhdGUgcG9pbnQgZXZlbnRzXG4gIGZvcih2YXIgaT0wOyBpPG51bVBvaW50czsgKytpKSB7XG4gICAgZXZlbnRzLnB1c2gobmV3IEV2ZW50KFxuICAgICAgcG9pbnRzW2ldLFxuICAgICAgbnVsbCxcbiAgICAgIEVWRU5UX1BPSU5ULFxuICAgICAgaSkpXG4gIH1cblxuICAvL0NyZWF0ZSBlZGdlIGV2ZW50c1xuICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIHZhciBhID0gcG9pbnRzW2VbMF1dXG4gICAgdmFyIGIgPSBwb2ludHNbZVsxXV1cbiAgICBpZihhWzBdIDwgYlswXSkge1xuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIG5ldyBFdmVudChhLCBiLCBFVkVOVF9TVEFSVCwgaSksXG4gICAgICAgIG5ldyBFdmVudChiLCBhLCBFVkVOVF9FTkQsIGkpKVxuICAgIH0gZWxzZSBpZihhWzBdID4gYlswXSkge1xuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIG5ldyBFdmVudChiLCBhLCBFVkVOVF9TVEFSVCwgaSksXG4gICAgICAgIG5ldyBFdmVudChhLCBiLCBFVkVOVF9FTkQsIGkpKVxuICAgIH1cbiAgfVxuXG4gIC8vU29ydCBldmVudHNcbiAgZXZlbnRzLnNvcnQoY29tcGFyZUV2ZW50KVxuXG4gIC8vSW5pdGlhbGl6ZSBodWxsXG4gIHZhciBtaW5YID0gZXZlbnRzWzBdLmFbMF0gLSAoMSArIE1hdGguYWJzKGV2ZW50c1swXS5hWzBdKSkgKiBNYXRoLnBvdygyLCAtNTIpXG4gIHZhciBodWxsID0gWyBuZXcgUGFydGlhbEh1bGwoW21pblgsIDFdLCBbbWluWCwgMF0sIC0xLCBbXSwgW10sIFtdLCBbXSkgXVxuXG4gIC8vUHJvY2VzcyBldmVudHMgaW4gb3JkZXJcbiAgdmFyIGNlbGxzID0gW11cbiAgZm9yKHZhciBpPTAsIG51bUV2ZW50cz1ldmVudHMubGVuZ3RoOyBpPG51bUV2ZW50czsgKytpKSB7XG4gICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldXG4gICAgdmFyIHR5cGUgPSBldmVudC50eXBlXG4gICAgaWYodHlwZSA9PT0gRVZFTlRfUE9JTlQpIHtcbiAgICAgIGFkZFBvaW50KGNlbGxzLCBodWxsLCBwb2ludHMsIGV2ZW50LmEsIGV2ZW50LmlkeClcbiAgICB9IGVsc2UgaWYodHlwZSA9PT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIHNwbGl0SHVsbHMoaHVsbCwgcG9pbnRzLCBldmVudClcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VIdWxscyhodWxsLCBwb2ludHMsIGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8vUmV0dXJuIHRyaWFuZ3VsYXRpb25cbiAgcmV0dXJuIGNlbGxzXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLWJvdW5kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVHJpYW5ndWxhdGlvblxuXG5mdW5jdGlvbiBUcmlhbmd1bGF0aW9uKHN0YXJzLCBlZGdlcykge1xuICB0aGlzLnN0YXJzID0gc3RhcnNcbiAgdGhpcy5lZGdlcyA9IGVkZ2VzXG59XG5cbnZhciBwcm90byA9IFRyaWFuZ3VsYXRpb24ucHJvdG90eXBlXG5cbmZ1bmN0aW9uIHJlbW92ZVBhaXIobGlzdCwgaiwgaykge1xuICBmb3IodmFyIGk9MSwgbj1saXN0Lmxlbmd0aDsgaTxuOyBpKz0yKSB7XG4gICAgaWYobGlzdFtpLTFdID09PSBqICYmIGxpc3RbaV0gPT09IGspIHtcbiAgICAgIGxpc3RbaS0xXSA9IGxpc3Rbbi0yXVxuICAgICAgbGlzdFtpXSA9IGxpc3Rbbi0xXVxuICAgICAgbGlzdC5sZW5ndGggPSBuIC0gMlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG5cbnByb3RvLmlzQ29uc3RyYWludCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBbMCwwXVxuICBmdW5jdGlvbiBjb21wYXJlTGV4KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oaSwgaikge1xuICAgIGVbMF0gPSBNYXRoLm1pbihpLGopXG4gICAgZVsxXSA9IE1hdGgubWF4KGksailcbiAgICByZXR1cm4gYnNlYXJjaC5lcSh0aGlzLmVkZ2VzLCBlLCBjb21wYXJlTGV4KSA+PSAwXG4gIH1cbn0pKClcblxucHJvdG8ucmVtb3ZlVHJpYW5nbGUgPSBmdW5jdGlvbihpLCBqLCBrKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgcmVtb3ZlUGFpcihzdGFyc1tpXSwgaiwgaylcbiAgcmVtb3ZlUGFpcihzdGFyc1tqXSwgaywgaSlcbiAgcmVtb3ZlUGFpcihzdGFyc1trXSwgaSwgailcbn1cblxucHJvdG8uYWRkVHJpYW5nbGUgPSBmdW5jdGlvbihpLCBqLCBrKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgc3RhcnNbaV0ucHVzaChqLCBrKVxuICBzdGFyc1tqXS5wdXNoKGssIGkpXG4gIHN0YXJzW2tdLnB1c2goaSwgailcbn1cblxucHJvdG8ub3Bwb3NpdGUgPSBmdW5jdGlvbihqLCBpKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5zdGFyc1tpXVxuICBmb3IodmFyIGs9MSwgbj1saXN0Lmxlbmd0aDsgazxuOyBrKz0yKSB7XG4gICAgaWYobGlzdFtrXSA9PT0gaikge1xuICAgICAgcmV0dXJuIGxpc3Rbay0xXVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxucHJvdG8uZmxpcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGEgPSB0aGlzLm9wcG9zaXRlKGksIGopXG4gIHZhciBiID0gdGhpcy5vcHBvc2l0ZShqLCBpKVxuICB0aGlzLnJlbW92ZVRyaWFuZ2xlKGksIGosIGEpXG4gIHRoaXMucmVtb3ZlVHJpYW5nbGUoaiwgaSwgYilcbiAgdGhpcy5hZGRUcmlhbmdsZShpLCBiLCBhKVxuICB0aGlzLmFkZFRyaWFuZ2xlKGosIGEsIGIpXG59XG5cbnByb3RvLmVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBuPXN0YXJzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgbGlzdCA9IHN0YXJzW2ldXG4gICAgZm9yKHZhciBqPTAsIG09bGlzdC5sZW5ndGg7IGo8bTsgais9Mikge1xuICAgICAgcmVzdWx0LnB1c2goW2xpc3Rbal0sIGxpc3RbaisxXV0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxucHJvdG8uY2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJzID0gdGhpcy5zdGFyc1xuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTAsIG49c3RhcnMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBsaXN0ID0gc3RhcnNbaV1cbiAgICBmb3IodmFyIGo9MCwgbT1saXN0Lmxlbmd0aDsgajxtOyBqKz0yKSB7XG4gICAgICB2YXIgcyA9IGxpc3Rbal1cbiAgICAgIHZhciB0ID0gbGlzdFtqKzFdXG4gICAgICBpZihpIDwgTWF0aC5taW4ocywgdCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2ksIHMsIHRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyaWFuZ3VsYXRpb24obnVtVmVydHMsIGVkZ2VzKSB7XG4gIHZhciBzdGFycyA9IG5ldyBBcnJheShudW1WZXJ0cylcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydHM7ICsraSkge1xuICAgIHN0YXJzW2ldID0gW11cbiAgfVxuICByZXR1cm4gbmV3IFRyaWFuZ3VsYXRpb24oc3RhcnMsIGVkZ2VzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5QU0xHXG5cbnZhciBVbmlvbkZpbmQgPSByZXF1aXJlKCd1bmlvbi1maW5kJylcbnZhciBib3hJbnRlcnNlY3QgPSByZXF1aXJlKCdib3gtaW50ZXJzZWN0JylcbnZhciBzZWdzZWcgPSByZXF1aXJlKCdyb2J1c3Qtc2VnbWVudC1pbnRlcnNlY3QnKVxudmFyIHJhdCA9IHJlcXVpcmUoJ2JpZy1yYXQnKVxudmFyIHJhdENtcCA9IHJlcXVpcmUoJ2JpZy1yYXQvY21wJylcbnZhciByYXRUb0Zsb2F0ID0gcmVxdWlyZSgnYmlnLXJhdC90by1mbG9hdCcpXG52YXIgcmF0VmVjID0gcmVxdWlyZSgncmF0LXZlYycpXG52YXIgbmV4dGFmdGVyID0gcmVxdWlyZSgnbmV4dGFmdGVyJylcblxudmFyIHNvbHZlSW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi9saWIvcmF0LXNlZy1pbnRlcnNlY3QnKVxuXG4vLyBCb3VuZHMgb24gYSByYXRpb25hbCBudW1iZXIgd2hlbiByb3VuZGVkIHRvIGEgZmxvYXRcbmZ1bmN0aW9uIGJvdW5kUmF0IChyKSB7XG4gIHZhciBmID0gcmF0VG9GbG9hdChyKVxuICByZXR1cm4gW1xuICAgIG5leHRhZnRlcihmLCAtSW5maW5pdHkpLFxuICAgIG5leHRhZnRlcihmLCBJbmZpbml0eSlcbiAgXVxufVxuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiBlZGdlcyBpbiBhIHBzbGcgdG8gYm91bmRpbmcgYm94ZXNcbmZ1bmN0aW9uIGJvdW5kRWRnZXMgKHBvaW50cywgZWRnZXMpIHtcbiAgdmFyIGJvdW5kcyA9IG5ldyBBcnJheShlZGdlcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIGJvdW5kc1tpXSA9IFtcbiAgICAgIG5leHRhZnRlcihNYXRoLm1pbihhWzBdLCBiWzBdKSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihNYXRoLm1pbihhWzFdLCBiWzFdKSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihNYXRoLm1heChhWzBdLCBiWzBdKSwgSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKE1hdGgubWF4KGFbMV0sIGJbMV0pLCBJbmZpbml0eSlcbiAgICBdXG4gIH1cbiAgcmV0dXJuIGJvdW5kc1xufVxuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiBwb2ludHMgaW50byBib3VuZGluZyBib3hlcyBieSBkdXBsaWNhdGluZyBjb29yZHNcbmZ1bmN0aW9uIGJvdW5kUG9pbnRzIChwb2ludHMpIHtcbiAgdmFyIGJvdW5kcyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwID0gcG9pbnRzW2ldXG4gICAgYm91bmRzW2ldID0gW1xuICAgICAgbmV4dGFmdGVyKHBbMF0sIC1JbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIocFsxXSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihwWzBdLCBJbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIocFsxXSwgSW5maW5pdHkpXG4gICAgXVxuICB9XG4gIHJldHVybiBib3VuZHNcbn1cblxuLy8gRmluZCBhbGwgcGFpcnMgb2YgY3Jvc3NpbmcgZWRnZXMgaW4gYSBwc2xnIChnaXZlbiBlZGdlIGJvdW5kcylcbmZ1bmN0aW9uIGdldENyb3NzaW5ncyAocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcykge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgYm94SW50ZXJzZWN0KGVkZ2VCb3VuZHMsIGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIHZhciBmID0gZWRnZXNbal1cbiAgICBpZiAoZVswXSA9PT0gZlswXSB8fCBlWzBdID09PSBmWzFdIHx8XG4gICAgICBlWzFdID09PSBmWzBdIHx8IGVbMV0gPT09IGZbMV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgYSA9IHBvaW50c1tlWzBdXVxuICAgIHZhciBiID0gcG9pbnRzW2VbMV1dXG4gICAgdmFyIGMgPSBwb2ludHNbZlswXV1cbiAgICB2YXIgZCA9IHBvaW50c1tmWzFdXVxuICAgIGlmIChzZWdzZWcoYSwgYiwgYywgZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtpLCBqXSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gRmluZCBhbGwgcGFpcnMgb2YgY3Jvc3NpbmcgdmVydGljZXMgaW4gYSBwc2xnIChnaXZlbiBlZGdlL3ZlcnQgYm91bmRzKVxuZnVuY3Rpb24gZ2V0VEp1bmN0aW9ucyAocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcywgdmVydEJvdW5kcykge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgYm94SW50ZXJzZWN0KGVkZ2VCb3VuZHMsIHZlcnRCb3VuZHMsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGlmIChlWzBdID09PSB2IHx8IGVbMV0gPT09IHYpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcCA9IHBvaW50c1t2XVxuICAgIHZhciBhID0gcG9pbnRzW2VbMF1dXG4gICAgdmFyIGIgPSBwb2ludHNbZVsxXV1cbiAgICBpZiAoc2Vnc2VnKGEsIGIsIHAsIHApKSB7XG4gICAgICByZXN1bHQucHVzaChbaSwgdl0pXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIEN1dCBlZGdlcyBhbG9uZyBjcm9zc2luZ3MvdGp1bmN0aW9uc1xuZnVuY3Rpb24gY3V0RWRnZXMgKGZsb2F0UG9pbnRzLCBlZGdlcywgY3Jvc3NpbmdzLCBqdW5jdGlvbnMsIHVzZUNvbG9yKSB7XG4gIHZhciBpLCBlXG5cbiAgLy8gQ29udmVydCBjcm9zc2luZ3MgaW50byB0anVuY3Rpb25zIGJ5IGNvbnN0cnVjdGluZyByYXRpb25hbCBwb2ludHNcbiAgdmFyIHJhdFBvaW50cyA9IGZsb2F0UG9pbnRzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAgIHJhdChwWzBdKSxcbiAgICAgICAgICByYXQocFsxXSlcbiAgICAgIF1cbiAgfSlcbiAgZm9yIChpID0gMDsgaSA8IGNyb3NzaW5ncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjcm9zc2luZyA9IGNyb3NzaW5nc1tpXVxuICAgIGUgPSBjcm9zc2luZ1swXVxuICAgIHZhciBmID0gY3Jvc3NpbmdbMV1cbiAgICB2YXIgZWUgPSBlZGdlc1tlXVxuICAgIHZhciBlZiA9IGVkZ2VzW2ZdXG4gICAgdmFyIHggPSBzb2x2ZUludGVyc2VjdGlvbihcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZVswXV0pLFxuICAgICAgcmF0VmVjKGZsb2F0UG9pbnRzW2VlWzFdXSksXG4gICAgICByYXRWZWMoZmxvYXRQb2ludHNbZWZbMF1dKSxcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZlsxXV0pKVxuICAgIGlmICgheCkge1xuICAgICAgLy8gU2VnbWVudHMgYXJlIHBhcmFsbGVsLCBzaG91bGQgYWxyZWFkeSBiZSBoYW5kbGVkIGJ5IHQtanVuY3Rpb25zXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgaWR4ID0gZmxvYXRQb2ludHMubGVuZ3RoXG4gICAgZmxvYXRQb2ludHMucHVzaChbcmF0VG9GbG9hdCh4WzBdKSwgcmF0VG9GbG9hdCh4WzFdKV0pXG4gICAgcmF0UG9pbnRzLnB1c2goeClcbiAgICBqdW5jdGlvbnMucHVzaChbZSwgaWR4XSwgW2YsIGlkeF0pXG4gIH1cblxuICAvLyBTb3J0IHRqdW5jdGlvbnNcbiAganVuY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYVswXSAhPT0gYlswXSkge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdXG4gICAgfVxuICAgIHZhciB1ID0gcmF0UG9pbnRzW2FbMV1dXG4gICAgdmFyIHYgPSByYXRQb2ludHNbYlsxXV1cbiAgICByZXR1cm4gcmF0Q21wKHVbMF0sIHZbMF0pIHx8IHJhdENtcCh1WzFdLCB2WzFdKVxuICB9KVxuXG4gIC8vIFNwbGl0IGVkZ2VzIGFsb25nIGp1bmN0aW9uc1xuICBmb3IgKGkgPSBqdW5jdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIganVuY3Rpb24gPSBqdW5jdGlvbnNbaV1cbiAgICBlID0ganVuY3Rpb25bMF1cblxuICAgIHZhciBlZGdlID0gZWRnZXNbZV1cbiAgICB2YXIgcyA9IGVkZ2VbMF1cbiAgICB2YXIgdCA9IGVkZ2VbMV1cblxuICAgIC8vIENoZWNrIGlmIGVkZ2UgaXMgbm90IGxleGljb2dyYXBoaWNhbGx5IHNvcnRlZFxuICAgIHZhciBhID0gZmxvYXRQb2ludHNbc11cbiAgICB2YXIgYiA9IGZsb2F0UG9pbnRzW3RdXG4gICAgaWYgKCgoYVswXSAtIGJbMF0pIHx8IChhWzFdIC0gYlsxXSkpIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IHNcbiAgICAgIHMgPSB0XG4gICAgICB0ID0gdG1wXG4gICAgfVxuXG4gICAgLy8gU3BsaXQgbGVhZGluZyBlZGdlXG4gICAgZWRnZVswXSA9IHNcbiAgICB2YXIgbGFzdCA9IGVkZ2VbMV0gPSBqdW5jdGlvblsxXVxuXG4gICAgLy8gSWYgd2UgYXJlIGdyb3VwaW5nIGVkZ2VzIGJ5IGNvbG9yLCByZW1lbWJlciB0byB0cmFjayBkYXRhXG4gICAgdmFyIGNvbG9yXG4gICAgaWYgKHVzZUNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVkZ2VbMl1cbiAgICB9XG5cbiAgICAvLyBTcGxpdCBvdGhlciBlZGdlc1xuICAgIHdoaWxlIChpID4gMCAmJiBqdW5jdGlvbnNbaSAtIDFdWzBdID09PSBlKSB7XG4gICAgICB2YXIganVuY3Rpb24gPSBqdW5jdGlvbnNbLS1pXVxuICAgICAgdmFyIG5leHQgPSBqdW5jdGlvblsxXVxuICAgICAgaWYgKHVzZUNvbG9yKSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHQsIGNvbG9yXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHRdKVxuICAgICAgfVxuICAgICAgbGFzdCA9IG5leHRcbiAgICB9XG5cbiAgICAvLyBBZGQgZmluYWwgZWRnZVxuICAgIGlmICh1c2VDb2xvcikge1xuICAgICAgZWRnZXMucHVzaChbbGFzdCwgdCwgY29sb3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlcy5wdXNoKFtsYXN0LCB0XSlcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gY29uc3RydWN0ZWQgcmF0aW9uYWwgcG9pbnRzXG4gIHJldHVybiByYXRQb2ludHNcbn1cblxuLy8gTWVyZ2Ugb3ZlcmxhcHBpbmcgcG9pbnRzXG5mdW5jdGlvbiBkZWR1cFBvaW50cyAoZmxvYXRQb2ludHMsIHJhdFBvaW50cywgZmxvYXRCb3VuZHMpIHtcbiAgdmFyIG51bVBvaW50cyA9IHJhdFBvaW50cy5sZW5ndGhcbiAgdmFyIHVmID0gbmV3IFVuaW9uRmluZChudW1Qb2ludHMpXG5cbiAgLy8gQ29tcHV0ZSByYXRpb25hbCBib3VuZHNcbiAgdmFyIGJvdW5kcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF0UG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHAgPSByYXRQb2ludHNbaV1cbiAgICB2YXIgeGIgPSBib3VuZFJhdChwWzBdKVxuICAgIHZhciB5YiA9IGJvdW5kUmF0KHBbMV0pXG4gICAgYm91bmRzLnB1c2goW1xuICAgICAgbmV4dGFmdGVyKHhiWzBdLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKHliWzBdLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKHhiWzFdLCBJbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIoeWJbMV0sIEluZmluaXR5KVxuICAgIF0pXG4gIH1cblxuICAvLyBMaW5rIGFsbCBwb2ludHMgd2l0aCBvdmVyIGxhcHBpbmcgYm94ZXNcbiAgYm94SW50ZXJzZWN0KGJvdW5kcywgZnVuY3Rpb24gKGksIGopIHtcbiAgICB1Zi5saW5rKGksIGopXG4gIH0pXG5cbiAgLy8gRG8gMSBwYXNzIG92ZXIgcG9pbnRzIHRvIGNvbWJpbmUgcG9pbnRzIGluIGxhYmVsIHNldHNcbiAgdmFyIG5vRHVwZXMgPSB0cnVlXG4gIHZhciBsYWJlbHMgPSBuZXcgQXJyYXkobnVtUG9pbnRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgKytpKSB7XG4gICAgdmFyIGogPSB1Zi5maW5kKGkpXG4gICAgaWYgKGogIT09IGkpIHtcbiAgICAgIC8vIENsZWFyIG5vLWR1cGVzIGZsYWcsIHplcm8gb3V0IGxhYmVsXG4gICAgICBub0R1cGVzID0gZmFsc2VcbiAgICAgIC8vIE1ha2UgZWFjaCBwb2ludCB0aGUgdG9wLWxlZnQgcG9pbnQgZnJvbSBpdHMgY2VsbFxuICAgICAgZmxvYXRQb2ludHNbal0gPSBbXG4gICAgICAgIE1hdGgubWluKGZsb2F0UG9pbnRzW2ldWzBdLCBmbG9hdFBvaW50c1tqXVswXSksXG4gICAgICAgIE1hdGgubWluKGZsb2F0UG9pbnRzW2ldWzFdLCBmbG9hdFBvaW50c1tqXVsxXSlcbiAgICAgIF1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBkdXBsaWNhdGVzLCByZXR1cm4gbnVsbCB0byBzaWduYWwgdGVybWluYXRpb25cbiAgaWYgKG5vRHVwZXMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIHB0ciA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7ICsraSkge1xuICAgIHZhciBqID0gdWYuZmluZChpKVxuICAgIGlmIChqID09PSBpKSB7XG4gICAgICBsYWJlbHNbaV0gPSBwdHJcbiAgICAgIGZsb2F0UG9pbnRzW3B0cisrXSA9IGZsb2F0UG9pbnRzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsc1tpXSA9IC0xXG4gICAgfVxuICB9XG5cbiAgZmxvYXRQb2ludHMubGVuZ3RoID0gcHRyXG5cbiAgLy8gRG8gYSBzZWNvbmQgcGFzcyB0byBmaXggdXAgbWlzc2luZyBsYWJlbHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7ICsraSkge1xuICAgIGlmIChsYWJlbHNbaV0gPCAwKSB7XG4gICAgICBsYWJlbHNbaV0gPSBsYWJlbHNbdWYuZmluZChpKV1cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gcmVzdWx0aW5nIHVuaW9uLWZpbmQgZGF0YSBzdHJ1Y3R1cmVcbiAgcmV0dXJuIGxhYmVsc1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTGV4MiAoYSwgYikgeyByZXR1cm4gKGFbMF0gLSBiWzBdKSB8fCAoYVsxXSAtIGJbMV0pIH1cbmZ1bmN0aW9uIGNvbXBhcmVMZXgzIChhLCBiKSB7XG4gIHZhciBkID0gKGFbMF0gLSBiWzBdKSB8fCAoYVsxXSAtIGJbMV0pXG4gIGlmIChkKSB7XG4gICAgcmV0dXJuIGRcbiAgfVxuICBpZiAoYVsyXSA8IGJbMl0pIHtcbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIGlmIChhWzJdID4gYlsyXSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy8gUmVtb3ZlIGR1cGxpY2F0ZSBlZGdlIGxhYmVsc1xuZnVuY3Rpb24gZGVkdXBFZGdlcyAoZWRnZXMsIGxhYmVscywgdXNlQ29sb3IpIHtcbiAgaWYgKGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChsYWJlbHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICB2YXIgYSA9IGxhYmVsc1tlWzBdXVxuICAgICAgdmFyIGIgPSBsYWJlbHNbZVsxXV1cbiAgICAgIGVbMF0gPSBNYXRoLm1pbihhLCBiKVxuICAgICAgZVsxXSA9IE1hdGgubWF4KGEsIGIpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHZhciBhID0gZVswXVxuICAgICAgdmFyIGIgPSBlWzFdXG4gICAgICBlWzBdID0gTWF0aC5taW4oYSwgYilcbiAgICAgIGVbMV0gPSBNYXRoLm1heChhLCBiKVxuICAgIH1cbiAgfVxuICBpZiAodXNlQ29sb3IpIHtcbiAgICBlZGdlcy5zb3J0KGNvbXBhcmVMZXgzKVxuICB9IGVsc2Uge1xuICAgIGVkZ2VzLnNvcnQoY29tcGFyZUxleDIpXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwcmV2ID0gZWRnZXNbaSAtIDFdXG4gICAgdmFyIG5leHQgPSBlZGdlc1tpXVxuICAgIGlmIChuZXh0WzBdID09PSBwcmV2WzBdICYmIG5leHRbMV0gPT09IHByZXZbMV0gJiZcbiAgICAgICghdXNlQ29sb3IgfHwgbmV4dFsyXSA9PT0gcHJldlsyXSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGVkZ2VzW3B0cisrXSA9IG5leHRcbiAgfVxuICBlZGdlcy5sZW5ndGggPSBwdHJcbn1cblxuZnVuY3Rpb24gcHJlUm91bmQgKHBvaW50cywgZWRnZXMsIHVzZUNvbG9yKSB7XG4gIHZhciBsYWJlbHMgPSBkZWR1cFBvaW50cyhwb2ludHMsIFtdLCBib3VuZFBvaW50cyhwb2ludHMpKVxuICBkZWR1cEVkZ2VzKGVkZ2VzLCBsYWJlbHMsIHVzZUNvbG9yKVxuICByZXR1cm4gISFsYWJlbHNcbn1cblxuLy8gUmVwZWF0IHVudGlsIGNvbnZlcmdlbmNlXG5mdW5jdGlvbiBzbmFwUm91bmQgKHBvaW50cywgZWRnZXMsIHVzZUNvbG9yKSB7XG4gIC8vIDEuIGZpbmQgZWRnZSBjcm9zc2luZ3NcbiAgdmFyIGVkZ2VCb3VuZHMgPSBib3VuZEVkZ2VzKHBvaW50cywgZWRnZXMpXG4gIHZhciBjcm9zc2luZ3MgPSBnZXRDcm9zc2luZ3MocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcylcblxuICAvLyAyLiBmaW5kIHQtanVuY3Rpb25zXG4gIHZhciB2ZXJ0Qm91bmRzID0gYm91bmRQb2ludHMocG9pbnRzKVxuICB2YXIgdGp1bmN0aW9ucyA9IGdldFRKdW5jdGlvbnMocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcywgdmVydEJvdW5kcylcblxuICAvLyAzLiBjdXQgZWRnZXMsIGNvbnN0cnVjdCByYXRpb25hbCBwb2ludHNcbiAgdmFyIHJhdFBvaW50cyA9IGN1dEVkZ2VzKHBvaW50cywgZWRnZXMsIGNyb3NzaW5ncywgdGp1bmN0aW9ucywgdXNlQ29sb3IpXG5cbiAgLy8gNC4gZGVkdXBlIHZlcnRzXG4gIHZhciBsYWJlbHMgPSBkZWR1cFBvaW50cyhwb2ludHMsIHJhdFBvaW50cywgdmVydEJvdW5kcylcblxuICAvLyA1LiBkZWR1cGUgZWRnZXNcbiAgZGVkdXBFZGdlcyhlZGdlcywgbGFiZWxzLCB1c2VDb2xvcilcblxuICAvLyA2LiBjaGVjayB0ZXJtaW5hdGlvblxuICBpZiAoIWxhYmVscykge1xuICAgIHJldHVybiAoY3Jvc3NpbmdzLmxlbmd0aCA+IDAgfHwgdGp1bmN0aW9ucy5sZW5ndGggPiAwKVxuICB9XG5cbiAgLy8gTW9yZSBpdGVyYXRpb25zIG5lY2Vzc2FyeVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBNYWluIGxvb3AsIHJ1bnMgUFNMRyBjbGVhbiB1cCB1bnRpbCBjb21wbGV0aW9uXG5mdW5jdGlvbiBjbGVhblBTTEcgKHBvaW50cywgZWRnZXMsIGNvbG9ycykge1xuICAvLyBJZiB1c2luZyBjb2xvcnMsIGF1Z21lbnQgZWRnZXMgd2l0aCBjb2xvciBkYXRhXG4gIHZhciBwcmV2RWRnZXNcbiAgaWYgKGNvbG9ycykge1xuICAgIHByZXZFZGdlcyA9IGVkZ2VzXG4gICAgdmFyIGF1Z0VkZ2VzID0gbmV3IEFycmF5KGVkZ2VzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICBhdWdFZGdlc1tpXSA9IFtlWzBdLCBlWzFdLCBjb2xvcnNbaV1dXG4gICAgfVxuICAgIGVkZ2VzID0gYXVnRWRnZXNcbiAgfVxuXG4gIC8vIEZpcnN0IHJvdW5kOiByZW1vdmUgZHVwbGljYXRlIGVkZ2VzIGFuZCBwb2ludHNcbiAgdmFyIG1vZGlmaWVkID0gcHJlUm91bmQocG9pbnRzLCBlZGdlcywgISFjb2xvcnMpXG5cbiAgLy8gUnVuIHNuYXAgcm91bmRpbmcgdW50aWwgY29udmVyZ2VuY2VcbiAgd2hpbGUgKHNuYXBSb3VuZChwb2ludHMsIGVkZ2VzLCAhIWNvbG9ycykpIHtcbiAgICBtb2RpZmllZCA9IHRydWVcbiAgfVxuXG4gIC8vIFN0cmlwIGNvbG9yIHRhZ3NcbiAgaWYgKCEhY29sb3JzICYmIG1vZGlmaWVkKSB7XG4gICAgcHJldkVkZ2VzLmxlbmd0aCA9IDBcbiAgICBjb2xvcnMubGVuZ3RoID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHByZXZFZGdlcy5wdXNoKFtlWzBdLCBlWzFdXSlcbiAgICAgIGNvbG9ycy5wdXNoKGVbMl0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBzb2x2ZUludGVyc2VjdGlvblxuXG52YXIgcmF0TXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxudmFyIHJhdERpdiA9IHJlcXVpcmUoJ2JpZy1yYXQvZGl2JylcbnZhciByYXRTdWIgPSByZXF1aXJlKCdiaWctcmF0L3N1YicpXG52YXIgcmF0U2lnbiA9IHJlcXVpcmUoJ2JpZy1yYXQvc2lnbicpXG52YXIgcnZTdWIgPSByZXF1aXJlKCdyYXQtdmVjL3N1YicpXG52YXIgcnZBZGQgPSByZXF1aXJlKCdyYXQtdmVjL2FkZCcpXG52YXIgcnZNdWxzID0gcmVxdWlyZSgncmF0LXZlYy9tdWxzJylcblxuZnVuY3Rpb24gcmF0UGVycCAoYSwgYikge1xuICByZXR1cm4gcmF0U3ViKHJhdE11bChhWzBdLCBiWzFdKSwgcmF0TXVsKGFbMV0sIGJbMF0pKVxufVxuXG4vLyBTb2x2ZSBmb3IgaW50ZXJzZWN0aW9uXG4vLyAgeCA9IGEgKyB0IChiLWEpXG4vLyAgKHggLSBjKSBeIChkLWMpID0gMFxuLy8gICh0ICogKGItYSkgKyAoYS1jKSApIF4gKGQtYykgPSAwXG4vLyAgdCAqIChiLWEpXihkLWMpID0gKGQtYyleKGEtYylcbi8vICB0ID0gKGQtYyleKGEtYykgLyAoYi1hKV4oZC1jKVxuXG5mdW5jdGlvbiBzb2x2ZUludGVyc2VjdGlvbiAoYSwgYiwgYywgZCkge1xuICB2YXIgYmEgPSBydlN1YihiLCBhKVxuICB2YXIgZGMgPSBydlN1YihkLCBjKVxuXG4gIHZhciBiYVhkYyA9IHJhdFBlcnAoYmEsIGRjKVxuXG4gIGlmIChyYXRTaWduKGJhWGRjKSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgYWMgPSBydlN1YihhLCBjKVxuICB2YXIgZGNYYWMgPSByYXRQZXJwKGRjLCBhYylcblxuICB2YXIgdCA9IHJhdERpdihkY1hhYywgYmFYZGMpXG4gIHZhciBzID0gcnZNdWxzKGJhLCB0KVxuICB2YXIgciA9IHJ2QWRkKGEsIHMpXG5cbiAgcmV0dXJuIHJcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFuZ2xlXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgc2duID0gcmVxdWlyZShcInNpZ251bVwiKVxudmFyIHR3b1N1bSA9IHJlcXVpcmUoXCJ0d28tc3VtXCIpXG52YXIgcm9idXN0UHJvZHVjdCA9IHJlcXVpcmUoXCJyb2J1c3QtcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG5cbmZ1bmN0aW9uIHRlc3RJbnRlcmlvcihhLCBiLCBjKSB7XG4gIHZhciB4MCA9IHR3b1N1bShhWzBdLCAtYlswXSlcbiAgdmFyIHkwID0gdHdvU3VtKGFbMV0sIC1iWzFdKVxuICB2YXIgeDEgPSB0d29TdW0oY1swXSwgLWJbMF0pXG4gIHZhciB5MSA9IHR3b1N1bShjWzFdLCAtYlsxXSlcblxuICB2YXIgZCA9IHJvYnVzdFN1bShcbiAgICByb2J1c3RQcm9kdWN0KHgwLCB4MSksXG4gICAgcm9idXN0UHJvZHVjdCh5MCwgeTEpKVxuXG4gIHJldHVybiBkW2QubGVuZ3RoLTFdID49IDBcbn1cblxuZnVuY3Rpb24gY29tcGFyZUFuZ2xlKGEsIGIsIGMsIGQpIHtcbiAgdmFyIGJjZCA9IG9yaWVudChiLCBjLCBkKVxuICBpZihiY2QgPT09IDApIHtcbiAgICAvL0hhbmRsZSBkZWdlbmVyYXRlIGNhc2VzXG4gICAgdmFyIHNhYmMgPSBzZ24ob3JpZW50KGEsIGIsIGMpKVxuICAgIHZhciBzYWJkID0gc2duKG9yaWVudChhLCBiLCBkKSlcbiAgICBpZihzYWJjID09PSBzYWJkKSB7XG4gICAgICBpZihzYWJjID09PSAwKSB7XG4gICAgICAgIHZhciBpYyA9IHRlc3RJbnRlcmlvcihhLCBiLCBjKVxuICAgICAgICB2YXIgaWQgPSB0ZXN0SW50ZXJpb3IoYSwgYiwgZClcbiAgICAgICAgaWYoaWMgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfSBlbHNlIGlmKGljKSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYoc2FiZCA9PT0gMCkge1xuICAgICAgaWYoc2FiYyA+IDApIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYodGVzdEludGVyaW9yKGEsIGIsIGQpKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc2FiYyA9PT0gMCkge1xuICAgICAgaWYoc2FiZCA+IDApIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZih0ZXN0SW50ZXJpb3IoYSwgYiwgYykpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2duKHNhYmQgLSBzYWJjKVxuICB9XG4gIHZhciBhYmMgPSBvcmllbnQoYSwgYiwgYylcbiAgaWYoYWJjID4gMCkge1xuICAgIGlmKGJjZCA+IDAgJiYgb3JpZW50KGEsIGIsIGQpID4gMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH0gZWxzZSBpZihhYmMgPCAwKSB7XG4gICAgaWYoYmNkID4gMCB8fCBvcmllbnQoYSwgYiwgZCkgPiAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWJkID0gb3JpZW50KGEsIGIsIGQpXG4gICAgaWYoYWJkID4gMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGVzdEludGVyaW9yKGEsIGIsIGMpKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuLy8gVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdmVyeSBzaW1wbGUgbG9vcHMgYW5hbG9nb3VzIHRvIGhvdyB5b3UgdHlwaWNhbGx5IHRyYXZlcnNlIGFycmF5cyAodGhlIG91dGVybW9zdCBsb29wIGNvcnJlc3BvbmRzIHRvIHRoZSBzbG93ZXN0IGNoYW5naW5nIGluZGV4LCB0aGUgaW5uZXJtb3N0IGxvb3AgdG8gdGhlIGZhc3Rlc3QgY2hhbmdpbmcgaW5kZXgpXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXG5mdW5jdGlvbiBpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aD4wXG4gICAgLCBjb2RlID0gW11cbiAgICAsIHZhcnMgPSBbXVxuICAgICwgaWR4PTAsIHBpZHg9MCwgaSwgalxuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7IC8vIEl0ZXJhdGlvbiB2YXJpYWJsZXNcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkgeyAvLyBUaGUgaW5uZXJtb3N0L2Zhc3Rlc3QgZGltZW5zaW9uJ3MgZGVsdGEgaXMgc2ltcGx5IGl0cyBzdHJpZGVcbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9dFwiLGosXCJwXCIsaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9ICBcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBjb2RlLnB1c2goW1wiZm9yKGlcIixpLFwiPTA7aVwiLGksXCI8c1wiLGlkeCxcIjsrK2lcIixpLFwiKXtcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL1B1c2ggYm9keSBvZiBpbm5lciBsb29wXG4gIGNvZGUucHVzaChib2R5KVxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgcGlkeCA9IGlkeFxuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2goW1wicFwiLGosXCIrPWRcIixqLFwic1wiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgaWYoaSA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChbXCIrK2luZGV4W1wiLGlkeCxcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cbi8vIFRPRE86IElmIHRoaXMgaXMgdXNlZCwgdGhlbiB0aGUgcHJldmlvdXMgZGVjbGFyYXRpb24gKGRvbmUgYnkgZ2VuZXJhdGVDd2lzZU9wKSBvZiBzKiBpcyBlc3NlbnRpYWxseSB1bm5lY2Vzc2FyeS5cbi8vICAgICAgIEkgYmVsaWV2ZSB0aGUgcyogYXJlIG5vdCB1c2VkIGVsc2V3aGVyZSAoaW4gcGFydGljdWxhciwgSSBkb24ndCB0aGluayB0aGV5J3JlIHVzZWQgaW4gdGhlIHByZS9wb3N0IHBhcnRzIGFuZCBcInNoYXBlXCIgaXMgZGVmaW5lZCBpbmRlcGVuZGVudGx5KSwgc28gaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBkZWZpbmluZyB0aGUgcyogZGVwZW5kZW50IG9uIHdoYXQgbG9vcCBtZXRob2QgaXMgYmVpbmcgdXNlZC5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXG4gIC8vIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBkaW1lbnNpb25zIGFyZSB0cmF2ZXJzZWQgaXMgZmFpcmx5IGFyYml0cmFyeSAoZnJvbSBzbWFsbCBzdHJpZGUgdG8gbGFyZ2Ugc3RyaWRlLCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50KVxuICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBsb29wcyBhcmUgcGxhY2VkIHdvdWxkIGFsc28gYmUgc29tZWhvdyBcIm9wdGltYWxcIiAoYXQgdGhlIHZlcnkgbGVhc3Qgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaXQgcmVhbGx5IGRvZXNuJ3QgaHVydCB1cyBpZiB0aGV5J3JlIG5vdCkuXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcImZvcih2YXIgalwiK2krXCI9U1NbXCIsIG9yZGVyW2ldLCBcIl18MDtqXCIsIGksIFwiPjA7KXtcIl0uam9pbihcIlwiKSkgLy8gSXRlcmF0ZSBiYWNrIHRvIGZyb250XG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpIC8vIEVpdGhlciBkZWNyZWFzZSBqIGJ5IGJsb2NrU2l6ZSAocyA9IGJsb2NrU2l6ZSksIG9yIHNldCBpdCB0byB6ZXJvIChhZnRlciBzZXR0aW5nIHMgPSBqKS5cbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcIn1lbHNle3NcIixvcmRlcltpXSxcIj1cIixibG9ja1NpemVdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIsb3JkZXJbaV0sXCJdPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cbiAgICBmb3IodmFyIGo9bWF0Y2hlZDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgaW5kZXhTdHIucHVzaChbXCJqXCIsaixcIip0XCIsaSxcInBcIixvcmRlcltqXV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFtcInBcIixpLFwiPShcIixpbmRleFN0ci5qb2luKFwiK1wiKSxcIilcIl0uam9pbihcIlwiKSlcbiAgfVxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vL0NvdW50IHRoZSBudW1iZXIgb2YgY29tcGF0aWJsZSBpbm5lciBvcmRlcnNcbi8vIFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBjb21tb24gcHJlZml4IG9mIHRoZSBhcnJheXMgaW4gb3JkZXJzLlxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cbi8vIFRoaXMgaXMgdGh1cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGF0IGNhbiBiZSBlZmZpY2llbnRseSB0cmF2ZXJzZWQgYnkgc2ltcGxlIG5lc3RlZCBsb29wcyBmb3IgYWxsIGFycmF5cy5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhvcmRlcnMpIHtcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXG4gIHdoaWxlKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBmb3IodmFyIGo9MTsgajxvcmRlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkXG4gICAgICB9XG4gICAgfVxuICAgICsrbWF0Y2hlZFxuICB9XG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXG4vLyBSZXBsYWNlcyB2YXJpYWJsZSBuYW1lcyBieSBkaWZmZXJlbnQgb25lcywgZWl0aGVyIFwibG9jYWxcIiBvbmVzICh0aGF0IGFyZSB0aGVuIGZlcnJpZWQgaW4gYW5kIG91dCBvZiB0aGUgZ2l2ZW4gYXJyYXkpIG9yIG9uZXMgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBmdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSB1bHRpbWF0ZSBsb29wIHdpbGwgYWNjZXB0LlxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleCAvLyBBZGRzIG9mZnNldCB0byB0aGUgXCJwb2ludGVyXCIgaW4gdGhlIGFycmF5XG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcbiAgICAgICAgdmFyIGxvY2FsU3RyID0gXCJsXCIgKyBpXG4gICAgICAgIHZhciBhcnJTdHIgPSBcImFcIiArIGFyck51bVxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcbiAgICAgICAgICBpZihjYXJnLmNvdW50ID09PSAxKSB7IC8vIEFyZ3VtZW50L2FycmF5IHVzZWQgb25seSBvbmNlKD8pXG4gICAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl09XCIsIGxvY2FsU3RyXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBhIFwiYmxvY2tcIlxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxuICAgICAgICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSk7IGorKykge1xuICAgICAgICAgICAgcmVTdHJBcnIucHVzaChcIlxcXFxzKlxcXFxbKFteXFxcXF1dKylcXFxcXVwiKVxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHJlU3RyQXJyLmpvaW4oXCJcIiksIFwiZ1wiKVxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgLyppZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgcHJvZHVjZSBhbnkgbG9jYWwgdmFyaWFibGVzLCBldmVuIGlmIHZhcmlhYmxlcyBhcmUgdXNlZCBtdWx0aXBsZSB0aW1lcy4gSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gc28sIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlIHRoaW5ncyBxdWl0ZSBhIGJpdC5cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJZXCIgKyBwcm9jLnNjYWxhckFyZ3MuaW5kZXhPZihpKSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJpbmRleFwiKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcInNoYXBlXCIpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXG59XG5cbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xuICB2YXIgc3VtbWFyeSA9IG5ldyBBcnJheShkdHlwZXMubGVuZ3RoKVxuICB2YXIgYWxsRXF1YWwgPSB0cnVlXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB0ID0gZHR5cGVzW2ldXG4gICAgdmFyIGRpZ2l0cyA9IHQubWF0Y2goL1xcZCsvKVxuICAgIGlmKCFkaWdpdHMpIHtcbiAgICAgIGRpZ2l0cyA9IFwiXCJcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXG4gICAgfVxuICAgIGlmKHQuY2hhckF0KDApID09PSAwKSB7XG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW1tYXJ5W2ldID0gdC5jaGFyQXQoMCkgKyBkaWdpdHNcbiAgICB9XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGFsbEVxdWFsID0gYWxsRXF1YWwgJiYgc3VtbWFyeVtpXSA9PT0gc3VtbWFyeVtpLTFdXG4gICAgfVxuICB9XG4gIGlmKGFsbEVxdWFsKSB7XG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cbiAgfVxuICByZXR1cm4gc3VtbWFyeS5qb2luKFwiXCIpXG59XG5cbi8vR2VuZXJhdGVzIGEgY3dpc2Ugb3BlcmF0b3JcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvblxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxuICB2YXIgZGltZW5zaW9uID0gKHR5cGVzaWdbMV0ubGVuZ3RoIC0gTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkpfDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGR0eXBlc1tpXSA9IHR5cGVzaWdbMippXVxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXG4gIH1cbiAgXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxuICB2YXIgYmxvY2tCZWdpbiA9IFtdLCBibG9ja0VuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGV4cG9zZWQgYXMgYmxvY2tzXG4gIHZhciBsb29wQmVnaW4gPSBbXSwgbG9vcEVuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGl0ZXJhdGVkIG92ZXJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV08MCkge1xuICAgICAgbG9vcEJlZ2luLnB1c2goMClcbiAgICAgIGxvb3BFbmQucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcEJlZ2luLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgLy8gTm9uLW5lZ2F0aXZlXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goMClcbiAgICAgIGJsb2NrRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9XG4gICAgdmFyIG5ld09yZGVyID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvcmRlcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9yZGVyc1tpXVtqXS1sb29wQmVnaW5baV0pIC8vIElmIHRoaXMgaXMgYSBsb29wIGluZGV4LCBwdXQgaXQgaW4gbmV3T3JkZXIsIHN1YnRyYWN0aW5nIGxvb3BCZWdpbiwgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGxvb3BPcmRlcnMgYXJlIHVzaW5nIGEgY29tbW9uIHNldCBvZiBpbmRpY2VzLlxuICAgICAgfVxuICAgIH1cbiAgICBsb29wT3JkZXJzLnB1c2gobmV3T3JkZXIpXG4gIH1cblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdIC8vIFNTIGlzIHRoZSBvdmVyYWxsIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZVxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICB2YXIgdmFycyA9IFtdXG4gIFxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgIHZhcnMucHVzaChbXCJzXCIsIGosIFwiPVNTW1wiLCBqLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVGhlIGxpbWl0cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSkgLy8gQWN0dWFsIGRhdGEgYXJyYXlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSkgLy8gU3RyaWRlc1xuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBsb29waW5nXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcImJcIixqLFwiPXRcIixpLFwiW1wiLGJsb2NrQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIikgLy8gTWFrZXMgdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgKHNvIHlvdSBjYW4gdXNlIHdpZHRoL2hlaWdodCBmb3IgZXhhbXBsZSlcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUHJlcGFyZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSAobG9naWNhbCkgaW5kaWNlcywgaW5pdGlhbGl6ZWQgdG8gZGltZW5zaW9uIHplcm9lcy5cbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgbG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpIC8vIFRPRE86IFJhdGhlciB0aGFuIHBhc3NpbmcgbG9vcE9yZGVyc1swXSwgaXQgbWlnaHQgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCBwYXNzaW5nIGFuIG9yZGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbWFqb3JpdHkgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZXhhbXBsZS5cbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9XG5cbiAgLy9JbmxpbmUgZXBpbG9nXG4gIGlmKHByb2MucG9zdC5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcbiAgfVxuICBcbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVGhlIGZ1bmN0aW9uIGJlbG93IGlzIGNhbGxlZCB3aGVuIGNvbnN0cnVjdGluZyBhIGN3aXNlIGZ1bmN0aW9uIG9iamVjdCwgYW5kIGRvZXMgdGhlIGZvbGxvd2luZzpcbi8vIEEgZnVuY3Rpb24gb2JqZWN0IGlzIGNvbnN0cnVjdGVkIHdoaWNoIGFjY2VwdHMgYXMgYXJndW1lbnQgYSBjb21waWxhdGlvbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLlxuLy8gSXQgaXMgdGhpcyBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQgYnkgY3JlYXRlVGh1bmssIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmUgdGhhdCBhY3R1YWxseVxuLy8gY2hlY2tzIHdoZXRoZXIgYSBjZXJ0YWluIHBhdHRlcm4gb2YgYXJndW1lbnRzIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBiZWZvcmUgYW5kIGNvbXBpbGVzIG5ldyBsb29wcyBhcyBuZWVkZWQuXG4vLyBUaGUgY29tcGlsYXRpb24gcGFzc2VkIHRvIHRoZSBmaXJzdCBmdW5jdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgY29tcGlsaW5nIG5ldyBmdW5jdGlvbnMuXG4vLyBPbmNlIHRoaXMgZnVuY3Rpb24gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGNvbXBpbGUgYXMgYXJndW1lbnQsIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBjb21waWxlXG4vLyBpcyBib3VuZCB0byBcInByb2NcIiAoZXNzZW50aWFsbHkgY29udGFpbmluZyBhIHByZXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB1c2VyIGFyZ3VtZW50cyB0byBjd2lzZSkuXG4vLyBTbyBjcmVhdGVUaHVuayByb3VnaGx5IHdvcmtzIGxpa2UgdGhpczpcbi8vIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbi8vICAgdmFyIHRodW5rID0gZnVuY3Rpb24oY29tcGlsZUJvdW5kKSB7XG4vLyAgICAgdmFyIENBQ0hFRCA9IHt9XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5cyBhbmQgc2NhbGFycykge1xuLy8gICAgICAgaWYgKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMgaW4gQ0FDSEVEKSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXSA9IGNvbXBpbGVCb3VuZChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzKVxuLy8gICAgICAgfVxuLy8gICAgICAgcmV0dXJuIGZ1bmMoYXJyYXlzIGFuZCBzY2FsYXJzKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kMShwcm9jKSlcbi8vIH1cblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGUuc2xpY2UoXCIsIC8vIFNsaWNlIHNoYXBlIHNvIHRoYXQgd2Ugb25seSByZXRhaW4gdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSAod2hpY2ggZ2V0cyBwYXNzZWQgdG8gdGhlIGN3aXNlIG9wZXJhdG9yIGFzIFNTKS5cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/KFwiLFwiK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbMF0rXCIpXCIpOlwiKVwiXS5qb2luKFwiXCIpXVxuICB2YXIgc2hhcGVMZW5ndGhDb25kaXRpb25zID0gW10sIHNoYXBlQ29uZGl0aW9ucyA9IFtdXG4gIC8vIFByb2Nlc3MgYXJyYXkgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gICAgaWYgKGk+MCkgeyAvLyBHYXRoZXIgY29uZGl0aW9ucyB0byBjaGVjayBmb3Igc2hhcGUgZXF1YWxpdHkgKGlnbm9yaW5nIGJsb2NrIGluZGljZXMpXG4gICAgICBzaGFwZUxlbmd0aENvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aD09PWFycmF5XCIgKyBqICsgXCIuc2hhcGUubGVuZ3RoK1wiICsgKE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLU1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pKSlcbiAgICAgIHNoYXBlQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIl09PT1hcnJheVwiICsgaiArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pICsgXCJdXCIpXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBzaGFwZSBlcXVhbGl0eVxuICBpZiAocHJvYy5hcnJheUFyZ3MubGVuZ3RoID4gMSkge1xuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVMZW5ndGhDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5IScpXCIpXG4gICAgY29kZS5wdXNoKFwiZm9yKHZhciBzaGFwZUluZGV4PWFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aC1cIiArIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCI7IHNoYXBlSW5kZXgtLT4wOykge1wiKVxuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlIScpXCIpXG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIC8vIFByb2Nlc3Mgc2NhbGFyIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIC8vIENoZWNrIGZvciBjYWNoZWQgZnVuY3Rpb24gKGFuZCBpZiBub3QgcHJlc2VudCwgZ2VuZXJhdGUgaXQpXG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCB0aHVuazpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICAvL0NvbXBpbGUgdGh1bmtcbiAgdmFyIHRodW5rID0gbmV3IEZ1bmN0aW9uKFwiY29tcGlsZVwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQodW5kZWZpbmVkLCBwcm9jKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaHVua1xuIiwidmFyIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbmlmKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIERPVUJMRV9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSgxKVxuICAgICwgVUlOVF9WSUVXICAgPSBuZXcgVWludDMyQXJyYXkoRE9VQkxFX1ZJRVcuYnVmZmVyKVxuICBET1VCTEVfVklFV1swXSA9IDEuMFxuICBoYXNUeXBlZEFycmF5cyA9IHRydWVcbiAgaWYoVUlOVF9WSUVXWzFdID09PSAweDNmZjAwMDAwKSB7XG4gICAgLy9Vc2UgbGl0dGxlIGVuZGlhblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0c0xFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFsgVUlOVF9WSUVXWzBdLCBVSU5UX1ZJRVdbMV0gXVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0RvdWJsZUxFKGxvLCBoaSkge1xuICAgICAgVUlOVF9WSUVXWzBdID0gbG9cbiAgICAgIFVJTlRfVklFV1sxXSA9IGhpXG4gICAgICByZXR1cm4gRE9VQkxFX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucGFjayA9IHRvRG91YmxlTEVcbiAgICBmdW5jdGlvbiBsb3dVaW50TEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmxvID0gbG93VWludExFXG4gICAgZnVuY3Rpb24gaGlnaFVpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludExFXG4gIH0gZWxzZSBpZihVSU5UX1ZJRVdbMF0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBiaWcgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzQkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMV0sIFVJTlRfVklFV1swXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlQkUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMV0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzBdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVCRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50QkVcbiAgICBmdW5jdGlvbiBoaWdoVWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50QkVcbiAgfSBlbHNlIHtcbiAgICBoYXNUeXBlZEFycmF5cyA9IGZhbHNlXG4gIH1cbn1cbmlmKCFoYXNUeXBlZEFycmF5cykge1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcig4KVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHMobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIFsgYnVmZmVyLnJlYWRVSW50MzJMRSgwLCB0cnVlKSwgYnVmZmVyLnJlYWRVSW50MzJMRSg0LCB0cnVlKSBdXG4gIH1cbiAgZnVuY3Rpb24gdG9Eb3VibGUobG8sIGhpKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobG8sIDAsIHRydWUpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoaGksIDQsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGUgIFxuICBmdW5jdGlvbiBsb3dVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50XG4gIGZ1bmN0aW9uIGhpZ2hVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludFxufVxuXG5tb2R1bGUuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuaGkobikgPj4+IDMxXG59XG5cbm1vZHVsZS5leHBvcnRzLmV4cG9uZW50ID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAoKGI8PDEpID4+PiAyMSkgLSAxMDIzXG59XG5cbm1vZHVsZS5leHBvcnRzLmZyYWN0aW9uID0gZnVuY3Rpb24obikge1xuICB2YXIgbG8gPSBtb2R1bGUuZXhwb3J0cy5sbyhuKVxuICB2YXIgaGkgPSBtb2R1bGUuZXhwb3J0cy5oaShuKVxuICB2YXIgYiA9IGhpICYgKCgxPDwyMCkgLSAxKVxuICBpZihoaSAmIDB4N2ZmMDAwMDApIHtcbiAgICBiICs9ICgxPDwyMClcbiAgfVxuICByZXR1cm4gW2xvLCBiXVxufVxuXG5tb2R1bGUuZXhwb3J0cy5kZW5vcm1hbGl6ZWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAhKGhpICYgMHg3ZmYwMDAwMClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBlZGdlVG9BZGphY2VuY3lcblxudmFyIHVuaXEgPSByZXF1aXJlKFwidW5pcVwiKVxuXG5mdW5jdGlvbiBlZGdlVG9BZGphY2VuY3koZWRnZXMsIG51bVZlcnRpY2VzKSB7XG4gIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aFxuICBpZih0eXBlb2YgbnVtVmVydGljZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICBudW1WZXJ0aWNlcyA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICBudW1WZXJ0aWNlcyA9IE1hdGgubWF4KG51bVZlcnRpY2VzLCBlWzBdLCBlWzFdKVxuICAgIH1cbiAgICBudW1WZXJ0aWNlcyA9IChudW1WZXJ0aWNlc3wwKSArIDFcbiAgfVxuICBudW1WZXJ0aWNlcyA9IG51bVZlcnRpY2VzfDBcbiAgdmFyIGFkaiA9IG5ldyBBcnJheShudW1WZXJ0aWNlcylcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGFkaltpXSA9IFtdXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bnVtRWRnZXM7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICBhZGpbZVswXV0ucHVzaChlWzFdKVxuICAgIGFkaltlWzFdXS5wdXNoKGVbMF0pXG4gIH1cbiAgZm9yKHZhciBqPTA7IGo8bnVtVmVydGljZXM7ICsraikge1xuICAgIHVuaXEoYWRqW2pdLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGJcbiAgICB9KVxuICB9XG4gIHJldHVybiBhZGpcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJCVHJlZVxuXG52YXIgUkVEICAgPSAwXG52YXIgQkxBQ0sgPSAxXG5cbmZ1bmN0aW9uIFJCTm9kZShjb2xvciwga2V5LCB2YWx1ZSwgbGVmdCwgcmlnaHQsIGNvdW50KSB7XG4gIHRoaXMuX2NvbG9yID0gY29sb3JcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubGVmdCA9IGxlZnRcbiAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gIHRoaXMuX2NvdW50ID0gY291bnRcbn1cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBSQk5vZGUobm9kZS5fY29sb3IsIG5vZGUua2V5LCBub2RlLnZhbHVlLCBub2RlLmxlZnQsIG5vZGUucmlnaHQsIG5vZGUuX2NvdW50KVxufVxuXG5mdW5jdGlvbiByZXBhaW50KGNvbG9yLCBub2RlKSB7XG4gIHJldHVybiBuZXcgUkJOb2RlKGNvbG9yLCBub2RlLmtleSwgbm9kZS52YWx1ZSwgbm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBub2RlLl9jb3VudClcbn1cblxuZnVuY3Rpb24gcmVjb3VudChub2RlKSB7XG4gIG5vZGUuX2NvdW50ID0gMSArIChub2RlLmxlZnQgPyBub2RlLmxlZnQuX2NvdW50IDogMCkgKyAobm9kZS5yaWdodCA/IG5vZGUucmlnaHQuX2NvdW50IDogMClcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlKGNvbXBhcmUsIHJvb3QpIHtcbiAgdGhpcy5fY29tcGFyZSA9IGNvbXBhcmVcbiAgdGhpcy5yb290ID0gcm9vdFxufVxuXG52YXIgcHJvdG8gPSBSZWRCbGFja1RyZWUucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJrZXlzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaChrKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwidmFsdWVzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaCh2KVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG4vL1JldHVybnMgdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImxlbmd0aFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290Ll9jb3VudFxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG59KVxuXG4vL0luc2VydCBhIG5ldyBpdGVtIGludG8gdGhlIHRyZWVcbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgLy9GaW5kIHBvaW50IHRvIGluc2VydCBuZXcgbm9kZSBhdFxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgbl9zdGFjayA9IFtdXG4gIHZhciBkX3N0YWNrID0gW11cbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgbl9zdGFjay5wdXNoKG4pXG4gICAgZF9zdGFjay5wdXNoKGQpXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIC8vUmVidWlsZCBwYXRoIHRvIGxlYWYgbm9kZVxuICBuX3N0YWNrLnB1c2gobmV3IFJCTm9kZShSRUQsIGtleSwgdmFsdWUsIG51bGwsIG51bGwsIDEpKVxuICBmb3IodmFyIHM9bl9zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYoZF9zdGFja1tzXSA8PSAwKSB7XG4gICAgICBuX3N0YWNrW3NdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG5fc3RhY2tbcysxXSwgbi5yaWdodCwgbi5fY291bnQrMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbl9zdGFja1tzXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIG5fc3RhY2tbcysxXSwgbi5fY291bnQrMSlcbiAgICB9XG4gIH1cbiAgLy9SZWJhbGFuY2UgdHJlZSB1c2luZyByb3RhdGlvbnNcbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0IGluc2VydFwiLCBrZXksIGRfc3RhY2spXG4gIGZvcih2YXIgcz1uX3N0YWNrLmxlbmd0aC0xOyBzPjE7IC0tcykge1xuICAgIHZhciBwID0gbl9zdGFja1tzLTFdXG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYocC5fY29sb3IgPT09IEJMQUNLIHx8IG4uX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdmFyIHBwID0gbl9zdGFja1tzLTJdXG4gICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLmxlZnQgPSBwLnJpZ2h0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAucmlnaHQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IHBcbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBuXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSYlwiKVxuICAgICAgICAgIHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBwcC5sZWZ0ID0gbi5yaWdodFxuICAgICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBuLmxlZnQgPSBwXG4gICAgICAgICAgbi5yaWdodCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gblxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IHBcbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICByZWNvdW50KG4pXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocC5yaWdodCA9PT0gbikge1xuICAgICAgICB2YXIgeSA9IHBwLmxlZnRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSclwiLCB5LmtleSlcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcHAubGVmdCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLnJpZ2h0ID0gcC5sZWZ0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAubGVmdCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gcFxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IG5cbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICBpZihzID49IDMpIHtcbiAgICAgICAgICAgIHZhciBwcHAgPSBuX3N0YWNrW3MtM11cbiAgICAgICAgICAgIGlmKHBwcC5yaWdodCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLnJpZ2h0ID0gcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAubGVmdFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkxyXCIpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHBwLmxlZnQgPSByZXBhaW50KEJMQUNLLCB5KVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHMgLT0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSTGJcIilcbiAgICAgICAgICBwLmxlZnQgPSBuLnJpZ2h0XG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgbi5yaWdodCA9IHBcbiAgICAgICAgICBuLmxlZnQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IG5cbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBwXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgcmVjb3VudChuKVxuICAgICAgICAgIGlmKHMgPj0gMykge1xuICAgICAgICAgICAgdmFyIHBwcCA9IG5fc3RhY2tbcy0zXVxuICAgICAgICAgICAgaWYocHBwLnJpZ2h0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL1JldHVybiBuZXcgdHJlZVxuICBuX3N0YWNrWzBdLl9jb2xvciA9IEJMQUNLXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKGNtcCwgbl9zdGFja1swXSlcbn1cblxuXG4vL1Zpc2l0IGFsbCBub2RlcyBpbm9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0RnVsbCh2aXNpdCwgbm9kZSkge1xuICBpZihub2RlLmxlZnQpIHtcbiAgICB2YXIgdiA9IGRvVmlzaXRGdWxsKHZpc2l0LCBub2RlLmxlZnQpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgdmFyIHYgPSB2aXNpdChub2RlLmtleSwgbm9kZS52YWx1ZSlcbiAgaWYodikgeyByZXR1cm4gdiB9XG4gIGlmKG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBoYWxmIG5vZGVzIGluIG9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUpIHtcbiAgdmFyIGwgPSBjb21wYXJlKGxvLCBub2RlLmtleSlcbiAgaWYobCA8PSAwKSB7XG4gICAgaWYobm9kZS5sZWZ0KSB7XG4gICAgICB2YXIgdiA9IGRvVmlzaXRIYWxmKGxvLCBjb21wYXJlLCB2aXNpdCwgbm9kZS5sZWZ0KVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICAgIHZhciB2ID0gdmlzaXQobm9kZS5rZXksIG5vZGUudmFsdWUpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgaWYobm9kZS5yaWdodCkge1xuICAgIHJldHVybiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBhbGwgbm9kZXMgd2l0aGluIGEgcmFuZ2VcbmZ1bmN0aW9uIGRvVmlzaXQobG8sIGhpLCBjb21wYXJlLCB2aXNpdCwgbm9kZSkge1xuICB2YXIgbCA9IGNvbXBhcmUobG8sIG5vZGUua2V5KVxuICB2YXIgaCA9IGNvbXBhcmUoaGksIG5vZGUua2V5KVxuICB2YXIgdlxuICBpZihsIDw9IDApIHtcbiAgICBpZihub2RlLmxlZnQpIHtcbiAgICAgIHYgPSBkb1Zpc2l0KGxvLCBoaSwgY29tcGFyZSwgdmlzaXQsIG5vZGUubGVmdClcbiAgICAgIGlmKHYpIHsgcmV0dXJuIHYgfVxuICAgIH1cbiAgICBpZihoID4gMCkge1xuICAgICAgdiA9IHZpc2l0KG5vZGUua2V5LCBub2RlLnZhbHVlKVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICB9XG4gIGlmKGggPiAwICYmIG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdChsbywgaGksIGNvbXBhcmUsIHZpc2l0LCBub2RlLnJpZ2h0KVxuICB9XG59XG5cblxucHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIHJiVHJlZUZvckVhY2godmlzaXQsIGxvLCBoaSkge1xuICBpZighdGhpcy5yb290KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGRvVmlzaXRIYWxmKGxvLCB0aGlzLl9jb21wYXJlLCB2aXNpdCwgdGhpcy5yb290KVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIDM6XG4gICAgICBpZih0aGlzLl9jb21wYXJlKGxvLCBoaSkgPj0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb1Zpc2l0KGxvLCBoaSwgdGhpcy5fY29tcGFyZSwgdmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuICB9XG59XG5cbi8vRmlyc3QgaXRlbSBpbiBsaXN0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwiYmVnaW5cIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG4gIH1cbn0pXG5cbi8vTGFzdCBpdGVtIGluIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJlbmRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICB9XG59KVxuXG4vL0ZpbmQgdGhlIGl0aCBpdGVtIGluIHRoZSB0cmVlXG5wcm90by5hdCA9IGZ1bmN0aW9uKGlkeCkge1xuICBpZihpZHggPCAwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbiAgfVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZSh0cnVlKSB7XG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKG4ubGVmdCkge1xuICAgICAgaWYoaWR4IDwgbi5sZWZ0Ll9jb3VudCkge1xuICAgICAgICBuID0gbi5sZWZ0XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZHggLT0gbi5sZWZ0Ll9jb3VudFxuICAgIH1cbiAgICBpZighaWR4KSB7XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICAgIH1cbiAgICBpZHggLT0gMVxuICAgIGlmKG4ucmlnaHQpIHtcbiAgICAgIGlmKGlkeCA+PSBuLnJpZ2h0Ll9jb3VudCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbn1cblxucHJvdG8uZ2UgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8uZ3QgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPCAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHN0YWNrLmxlbmd0aCA9IGxhc3RfcHRyXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG59XG5cbnByb3RvLmx0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBjbXAgPSB0aGlzLl9jb21wYXJlXG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBzdGFjayA9IFtdXG4gIHZhciBsYXN0X3B0ciA9IDBcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKGQgPiAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8ubGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA+PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDwgMCkge1xuICAgICAgbiA9IG4ubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICBzdGFjay5sZW5ndGggPSBsYXN0X3B0clxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxufVxuXG4vL0ZpbmRzIHRoZSBpdGVtIHdpdGgga2V5IGlmIGl0IGV4aXN0c1xucHJvdG8uZmluZCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgW10pXG59XG5cbi8vUmVtb3ZlcyBpdGVtIHdpdGgga2V5IGZyb20gdHJlZVxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBpdGVyID0gdGhpcy5maW5kKGtleSlcbiAgaWYoaXRlcikge1xuICAgIHJldHVybiBpdGVyLnJlbW92ZSgpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy9SZXR1cm5zIHRoZSBpdGVtIGF0IGBrZXlgXG5wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG4udmFsdWVcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVyblxufVxuXG4vL0l0ZXJhdG9yIGZvciByZWQgYmxhY2sgdHJlZVxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlSXRlcmF0b3IodHJlZSwgc3RhY2spIHtcbiAgdGhpcy50cmVlID0gdHJlZVxuICB0aGlzLl9zdGFjayA9IHN0YWNrXG59XG5cbnZhciBpcHJvdG8gPSBSZWRCbGFja1RyZWVJdGVyYXRvci5wcm90b3R5cGVcblxuLy9UZXN0IGlmIGl0ZXJhdG9yIGlzIHZhbGlkXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbGlkXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2subGVuZ3RoID4gMFxuICB9XG59KVxuXG4vL05vZGUgb2YgdGhlIGl0ZXJhdG9yXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcIm5vZGVcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9NYWtlcyBhIGNvcHkgb2YgYW4gaXRlcmF0b3Jcbmlwcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMudHJlZSwgdGhpcy5fc3RhY2suc2xpY2UoKSlcbn1cblxuLy9Td2FwcyB0d28gbm9kZXNcbmZ1bmN0aW9uIHN3YXBOb2RlKG4sIHYpIHtcbiAgbi5rZXkgPSB2LmtleVxuICBuLnZhbHVlID0gdi52YWx1ZVxuICBuLmxlZnQgPSB2LmxlZnRcbiAgbi5yaWdodCA9IHYucmlnaHRcbiAgbi5fY29sb3IgPSB2Ll9jb2xvclxuICBuLl9jb3VudCA9IHYuX2NvdW50XG59XG5cbi8vRml4IHVwIGEgZG91YmxlIGJsYWNrIG5vZGUgaW4gYSB0cmVlXG5mdW5jdGlvbiBmaXhEb3VibGVCbGFjayhzdGFjaykge1xuICB2YXIgbiwgcCwgcywgelxuICBmb3IodmFyIGk9c3RhY2subGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIG4gPSBzdGFja1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwidmlzaXQgbm9kZTpcIiwgbi5rZXksIGksIHN0YWNrW2ldLmtleSwgc3RhY2tbaS0xXS5rZXkpXG4gICAgcCA9IHN0YWNrW2ktMV1cbiAgICBpZihwLmxlZnQgPT09IG4pIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJsZWZ0IGNoaWxkXCIpXG4gICAgICBzID0gcC5yaWdodFxuICAgICAgaWYocy5yaWdodCAmJiBzLnJpZ2h0Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDE6IHJpZ2h0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLnJpZ2h0ID0gY2xvbmVOb2RlKHMucmlnaHQpXG4gICAgICAgIHAucmlnaHQgPSBzLmxlZnRcbiAgICAgICAgcy5sZWZ0ID0gcFxuICAgICAgICBzLnJpZ2h0ID0gelxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICB6Ll9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5sZWZ0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHNcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLnJpZ2h0ID0gei5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHoucmlnaHRcbiAgICAgICAgei5sZWZ0ID0gcFxuICAgICAgICB6LnJpZ2h0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLmxlZnQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSB6XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gelxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gelxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmKHMuX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgICBpZihwLl9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgcmVkIHBhcmVudFwiLCBwLnJpZ2h0LnZhbHVlKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwLnJpZ2h0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIsIHAucmlnaHQudmFsdWUpXG4gICAgICAgICAgcC5yaWdodCA9IHJlcGFpbnQoUkVELCBzKVxuICAgICAgICAgIGNvbnRpbnVlICBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMzogcmVkIHNpYmxpbmdcIilcbiAgICAgICAgcyA9IGNsb25lTm9kZShzKVxuICAgICAgICBwLnJpZ2h0ID0gcy5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgICAgICAgcHAubGVmdCA9IHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAucmlnaHQgPSBzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSBzXG4gICAgICAgIHN0YWNrW2ldID0gcFxuICAgICAgICBpZihpKzEgPCBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBzdGFja1tpKzFdID0gblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgICAgfVxuICAgICAgICBpID0gaSsyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJyaWdodCBjaGlsZFwiKVxuICAgICAgcyA9IHAubGVmdFxuICAgICAgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIsIHAudmFsdWUsIHAuX2NvbG9yKVxuICAgICAgICBzID0gcC5sZWZ0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLmxlZnQgPSBzLnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSBwXG4gICAgICAgIHMubGVmdCA9IHpcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgei5fY29sb3IgPSBCTEFDS1xuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZihzLnJpZ2h0ICYmIHMucmlnaHQuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMTogcmlnaHQgc2libGluZyBjaGlsZCByZWRcIilcbiAgICAgICAgcyA9IHAubGVmdCA9IGNsb25lTm9kZShzKVxuICAgICAgICB6ID0gcy5yaWdodCA9IGNsb25lTm9kZShzLnJpZ2h0KVxuICAgICAgICBwLmxlZnQgPSB6LnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSB6LmxlZnRcbiAgICAgICAgei5yaWdodCA9IHBcbiAgICAgICAgei5sZWZ0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLnJpZ2h0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHpcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAubGVmdCA9IHpcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHpcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZihzLl9jb2xvciA9PT0gQkxBQ0spIHtcbiAgICAgICAgaWYocC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDI6IGJsYWNrIHNpYmxpbmcsIHJlZCBwYXJlbnRcIilcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIpXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgY29udGludWUgIFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAzOiByZWQgc2libGluZ1wiKVxuICAgICAgICBzID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHAubGVmdCA9IHMucmlnaHRcbiAgICAgICAgcy5yaWdodCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICBzdGFja1tpXSA9IHBcbiAgICAgICAgaWYoaSsxIDwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgc3RhY2tbaSsxXSA9IG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG4pXG4gICAgICAgIH1cbiAgICAgICAgaSA9IGkrMlxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1JlbW92ZXMgaXRlbSBhdCBpdGVyYXRvciBmcm9tIHRyZWVcbmlwcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZVxuICB9XG4gIC8vRmlyc3QgY29weSBwYXRoIHRvIG5vZGVcbiAgdmFyIGNzdGFjayA9IG5ldyBBcnJheShzdGFjay5sZW5ndGgpXG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGNzdGFja1tjc3RhY2subGVuZ3RoLTFdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpXG4gIGZvcih2YXIgaT1zdGFjay5sZW5ndGgtMjsgaT49MDsgLS1pKSB7XG4gICAgdmFyIG4gPSBzdGFja1tpXVxuICAgIGlmKG4ubGVmdCA9PT0gc3RhY2tbaSsxXSkge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIGNzdGFja1tpKzFdLCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgfVxuXG4gIC8vR2V0IG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIC8vY29uc29sZS5sb2coXCJzdGFydCByZW1vdmU6IFwiLCBuLnZhbHVlKVxuXG4gIC8vSWYgbm90IGxlYWYsIHRoZW4gc3dhcCB3aXRoIHByZXZpb3VzIG5vZGVcbiAgaWYobi5sZWZ0ICYmIG4ucmlnaHQpIHtcbiAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIHRvIGxlYWZcIilcblxuICAgIC8vRmlyc3Qgd2FsayB0byBwcmV2aW91cyBsZWFmXG4gICAgdmFyIHNwbGl0ID0gY3N0YWNrLmxlbmd0aFxuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuLnJpZ2h0KSB7XG4gICAgICBjc3RhY2sucHVzaChuKVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgLy9Db3B5IHBhdGggdG8gbGVhZlxuICAgIHZhciB2ID0gY3N0YWNrW3NwbGl0LTFdXG4gICAgY3N0YWNrLnB1c2gobmV3IFJCTm9kZShuLl9jb2xvciwgdi5rZXksIHYudmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpKVxuICAgIGNzdGFja1tzcGxpdC0xXS5rZXkgPSBuLmtleVxuICAgIGNzdGFja1tzcGxpdC0xXS52YWx1ZSA9IG4udmFsdWVcblxuICAgIC8vRml4IHVwIHN0YWNrXG4gICAgZm9yKHZhciBpPWNzdGFjay5sZW5ndGgtMjsgaT49c3BsaXQ7IC0taSkge1xuICAgICAgbiA9IGNzdGFja1tpXVxuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgICBjc3RhY2tbc3BsaXQtMV0ubGVmdCA9IGNzdGFja1tzcGxpdF1cbiAgfVxuICAvL2NvbnNvbGUubG9nKFwic3RhY2s9XCIsIGNzdGFjay5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi52YWx1ZSB9KSlcblxuICAvL1JlbW92ZSBsZWFmIG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4uX2NvbG9yID09PSBSRUQpIHtcbiAgICAvL0Vhc3kgY2FzZTogcmVtb3ZpbmcgcmVkIGxlYWZcbiAgICAvL2NvbnNvbGUubG9nKFwiUkVEIGxlYWZcIilcbiAgICB2YXIgcCA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTJdXG4gICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICBwLmxlZnQgPSBudWxsXG4gICAgfSBlbHNlIGlmKHAucmlnaHQgPT09IG4pIHtcbiAgICAgIHAucmlnaHQgPSBudWxsXG4gICAgfVxuICAgIGNzdGFjay5wb3AoKVxuICAgIGZvcih2YXIgaT0wOyBpPGNzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKHRoaXMudHJlZS5fY29tcGFyZSwgY3N0YWNrWzBdKVxuICB9IGVsc2Uge1xuICAgIGlmKG4ubGVmdCB8fCBuLnJpZ2h0KSB7XG4gICAgICAvL1NlY29uZCBlYXN5IGNhc2U6ICBTaW5nbGUgY2hpbGQgYmxhY2sgcGFyZW50XG4gICAgICAvL2NvbnNvbGUubG9nKFwiQkxBQ0sgc2luZ2xlIGNoaWxkXCIpXG4gICAgICBpZihuLmxlZnQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5sZWZ0KVxuICAgICAgfSBlbHNlIGlmKG4ucmlnaHQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5yaWdodClcbiAgICAgIH1cbiAgICAgIC8vQ2hpbGQgbXVzdCBiZSByZWQsIHNvIHJlcGFpbnQgaXQgYmxhY2sgdG8gYmFsYW5jZSBjb2xvclxuICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgZm9yKHZhciBpPTA7IGk8Y3N0YWNrLmxlbmd0aC0xOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIGNzdGFja1swXSlcbiAgICB9IGVsc2UgaWYoY3N0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy9UaGlyZCBlYXN5IGNhc2U6IHJvb3RcbiAgICAgIC8vY29uc29sZS5sb2coXCJST09UXCIpXG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSGFyZCBjYXNlOiBSZXBhaW50IG4sIGFuZCB0aGVuIGRvIHNvbWUgbmFzdHkgc3R1ZmZcbiAgICAgIC8vY29uc29sZS5sb2coXCJCTEFDSyBsZWFmIG5vIGNoaWxkcmVuXCIpXG4gICAgICBmb3IodmFyIGk9MDsgaTxjc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMl1cbiAgICAgIGZpeERvdWJsZUJsYWNrKGNzdGFjaylcbiAgICAgIC8vRml4IHVwIGxpbmtzXG4gICAgICBpZihwYXJlbnQubGVmdCA9PT0gbikge1xuICAgICAgICBwYXJlbnQubGVmdCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5yaWdodCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vUmV0dXJucyBrZXlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwia2V5XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLmtleVxuICAgIH1cbiAgICByZXR1cm5cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9SZXR1cm5zIHZhbHVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbHVlXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLnZhbHVlXG4gICAgfVxuICAgIHJldHVyblxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5cbi8vUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhpcyBpdGVyYXRvciBpbiB0aGUgc29ydGVkIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaW5kZXhcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwXG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciByID0gdGhpcy50cmVlLnJvb3RcbiAgICAgIGlmKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuX2NvdW50XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgaWR4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQuX2NvdW50XG4gICAgfVxuICAgIGZvcih2YXIgcz1zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzKzFdID09PSBzdGFja1tzXS5yaWdodCkge1xuICAgICAgICArK2lkeFxuICAgICAgICBpZihzdGFja1tzXS5sZWZ0KSB7XG4gICAgICAgICAgaWR4ICs9IHN0YWNrW3NdLmxlZnQuX2NvdW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeFxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vL0FkdmFuY2VzIGl0ZXJhdG9yIHRvIG5leHQgZWxlbWVudCBpbiBsaXN0XG5pcHJvdG8ubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBpZihuLnJpZ2h0KSB7XG4gICAgbiA9IG4ucmlnaHRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YWNrLnBvcCgpXG4gICAgd2hpbGUoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGgtMV0ucmlnaHQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IGVuZCBvZiB0cmVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcImhhc05leHRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gICAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYoc3RhY2tbc3RhY2subGVuZ3RoLTFdLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IodmFyIHM9c3RhY2subGVuZ3RoLTE7IHM+MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzLTFdLmxlZnQgPT09IHN0YWNrW3NdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59KVxuXG4vL1VwZGF0ZSB2YWx1ZVxuaXByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVwZGF0ZSBlbXB0eSBub2RlIVwiKVxuICB9XG4gIHZhciBjc3RhY2sgPSBuZXcgQXJyYXkoc3RhY2subGVuZ3RoKVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBjc3RhY2tbY3N0YWNrLmxlbmd0aC0xXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCB2YWx1ZSwgbi5sZWZ0LCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgZm9yKHZhciBpPXN0YWNrLmxlbmd0aC0yOyBpPj0wOyAtLWkpIHtcbiAgICBuID0gc3RhY2tbaV1cbiAgICBpZihuLmxlZnQgPT09IHN0YWNrW2krMV0pIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBjc3RhY2tbaSsxXSwgbi5yaWdodCwgbi5fY291bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIGNzdGFja1tpKzFdLCBuLl9jb3VudClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vTW92ZXMgaXRlcmF0b3IgYmFja3dhcmQgb25lIGVsZW1lbnRcbmlwcm90by5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4ubGVmdCkge1xuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wb3AoKVxuICAgIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IHN0YXJ0IG9mIHRyZWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaGFzUHJldlwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZm9yKHZhciBzPXN0YWNrLmxlbmd0aC0xOyBzPjA7IC0tcykge1xuICAgICAgaWYoc3RhY2tbcy0xXS5yaWdodCA9PT0gc3RhY2tbc10pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pXG5cbi8vRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIGlmKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vQnVpbGQgYSB0cmVlXG5mdW5jdGlvbiBjcmVhdGVSQlRyZWUoY29tcGFyZSkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZShjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlLCBudWxsKVxufSIsIi8vIHRyYW5zbGl0ZXJhdGVkIGZyb20gdGhlIHB5dGhvbiBzbmlwcGV0IGhlcmU6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmN6b3NfYXBwcm94aW1hdGlvblxuXG52YXIgZyA9IDc7XG52YXIgcCA9IFtcbiAgICAwLjk5OTk5OTk5OTk5OTgwOTkzLFxuICAgIDY3Ni41MjAzNjgxMjE4ODUxLFxuICAgIC0xMjU5LjEzOTIxNjcyMjQwMjgsXG4gICAgNzcxLjMyMzQyODc3NzY1MzEzLFxuICAgIC0xNzYuNjE1MDI5MTYyMTQwNTksXG4gICAgMTIuNTA3MzQzMjc4Njg2OTA1LFxuICAgIC0wLjEzODU3MTA5NTI2NTcyMDEyLFxuICAgIDkuOTg0MzY5NTc4MDE5NTcxNmUtNixcbiAgICAxLjUwNTYzMjczNTE0OTMxMTZlLTdcbl07XG5cbnZhciBnX2xuID0gNjA3LzEyODtcbnZhciBwX2xuID0gW1xuICAgIDAuOTk5OTk5OTk5OTk5OTk3MDkxODIsXG4gICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxuICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG5dO1xuXG4vLyBTcG91Z2UgYXBwcm94aW1hdGlvbiAoc3VpdGFibGUgZm9yIGxhcmdlIGFyZ3VtZW50cylcbmZ1bmN0aW9uIGxuZ2FtbWEoeikge1xuXG4gICAgaWYoeiA8IDApIHJldHVybiBOdW1iZXIoJzAvMCcpO1xuICAgIHZhciB4ID0gcF9sblswXTtcbiAgICBmb3IodmFyIGkgPSBwX2xuLmxlbmd0aCAtIDE7IGkgPiAwOyAtLWkpIHggKz0gcF9sbltpXSAvICh6ICsgaSk7XG4gICAgdmFyIHQgPSB6ICsgZ19sbiArIDAuNTtcbiAgICByZXR1cm4gLjUqTWF0aC5sb2coMipNYXRoLlBJKSsoeisuNSkqTWF0aC5sb2codCktdCtNYXRoLmxvZyh4KS1NYXRoLmxvZyh6KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnYW1tYSAoeikge1xuICAgIGlmICh6IDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiB6KSAqIGdhbW1hKDEgLSB6KSk7XG4gICAgfVxuICAgIGVsc2UgaWYoeiA+IDEwMCkgcmV0dXJuIE1hdGguZXhwKGxuZ2FtbWEoeikpO1xuICAgIGVsc2Uge1xuICAgICAgICB6IC09IDE7XG4gICAgICAgIHZhciB4ID0gcFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnICsgMjsgaSsrKSB7XG4gICAgICAgICAgICB4ICs9IHBbaV0gLyAoeiArIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0geiArIGcgKyAwLjU7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSlcbiAgICAgICAgICAgICogTWF0aC5wb3codCwgeiArIDAuNSlcbiAgICAgICAgICAgICogTWF0aC5leHAoLXQpXG4gICAgICAgICAgICAqIHhcbiAgICAgICAgO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmxvZyA9IGxuZ2FtbWE7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGRldGVybWluYW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21RdWF0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgcywgYywgdFxuICB2YXIgeCA9IGF4aXNbMF1cbiAgdmFyIHkgPSBheGlzWzFdXG4gIHZhciB6ID0gYXhpc1syXVxuICB2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeilcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW5cbiAgeCAqPSBsZW5cbiAgeSAqPSBsZW5cbiAgeiAqPSBsZW5cblxuICBzID0gTWF0aC5zaW4ocmFkKVxuICBjID0gTWF0aC5jb3MocmFkKVxuICB0ID0gMSAtIGNcblxuICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjXG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzXG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHNcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgY1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogc1xuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzXG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzXG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSAwXG4gIG91dFsxM10gPSAwXG4gIG91dFsxNF0gPSAwXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVNjYWxpbmdcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF1cbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSB2WzFdXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IHZbMl1cbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVHJhbnNsYXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAwXG4gIG91dFs0XSA9IDBcbiAgb3V0WzVdID0gMVxuICBvdXRbNl0gPSAwXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0gMFxuICBvdXRbOV0gPSAwXG4gIG91dFsxMF0gPSAxXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSB2WzBdXG4gIG91dFsxM10gPSB2WzFdXG4gIG91dFsxNF0gPSB2WzJdXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVhSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IDFcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IHNcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IC1zXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVlSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gLXNcbiAgICBvdXRbM10gPSAwXG4gICAgb3V0WzRdID0gMFxuICAgIG91dFs1XSA9IDFcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IHNcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVpSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSBzXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAtc1xuICAgIG91dFs1XSA9IGNcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IDBcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IDFcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJ1c3R1bTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vdHJhbnNwb3NlJylcbiAgLCBpbnZlcnQ6IHJlcXVpcmUoJy4vaW52ZXJ0JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIGRldGVybWluYW50OiByZXF1aXJlKCcuL2RldGVybWluYW50JylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgdHJhbnNsYXRlOiByZXF1aXJlKCcuL3RyYW5zbGF0ZScpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZyb21Sb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tUm90YXRpb24nKVxuICAsIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvblRyYW5zbGF0aW9uJylcbiAgLCBmcm9tU2NhbGluZzogcmVxdWlyZSgnLi9mcm9tU2NhbGluZycpXG4gICwgZnJvbVRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21UcmFuc2xhdGlvbicpXG4gICwgZnJvbVhSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWFJvdGF0aW9uJylcbiAgLCBmcm9tWVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21ZUm90YXRpb24nKVxuICAsIGZyb21aUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVpSb3RhdGlvbicpXG4gICwgZnJvbVF1YXQ6IHJlcXVpcmUoJy4vZnJvbVF1YXQnKVxuICAsIGZydXN0dW06IHJlcXVpcmUoJy4vZnJ1c3R1bScpXG4gICwgcGVyc3BlY3RpdmU6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmUnKVxuICAsIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3OiByZXF1aXJlKCcuL3BlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3JylcbiAgLCBvcnRobzogcmVxdWlyZSgnLi9vcnRobycpXG4gICwgbG9va0F0OiByZXF1aXJlKCcuL2xvb2tBdCcpXG4gICwgc3RyOiByZXF1aXJlKCcuL3N0cicpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydDtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb29rQXQ7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IDAuMDAwMDAxKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9ydGhvO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBlcnNwZWN0aXZlO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCAwLjAwMDAwMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHN0cjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIHN0cihhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGU7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9zZTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdzID09PSAnc3RyaW5nJykgc3RyaW5ncyA9IFtzdHJpbmdzXVxuICB2YXIgZXhwcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKVxuICB2YXIgcGFydHMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoLTE7IGkrKykge1xuICAgIHBhcnRzLnB1c2goc3RyaW5nc1tpXSwgZXhwcnNbaV0gfHwgJycpXG4gIH1cbiAgcGFydHMucHVzaChzdHJpbmdzW2ldKVxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgYm91bmRzID0gcmVxdWlyZShcImJpbmFyeS1zZWFyY2gtYm91bmRzXCIpXG5cbnZhciBOT1RfRk9VTkQgPSAwXG52YXIgU1VDQ0VTUyA9IDFcbnZhciBFTVBUWSA9IDJcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXcmFwcGVyXG5cbmZ1bmN0aW9uIEludGVydmFsVHJlZU5vZGUobWlkLCBsZWZ0LCByaWdodCwgbGVmdFBvaW50cywgcmlnaHRQb2ludHMpIHtcbiAgdGhpcy5taWQgPSBtaWRcbiAgdGhpcy5sZWZ0ID0gbGVmdFxuICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgdGhpcy5sZWZ0UG9pbnRzID0gbGVmdFBvaW50c1xuICB0aGlzLnJpZ2h0UG9pbnRzID0gcmlnaHRQb2ludHNcbiAgdGhpcy5jb3VudCA9IChsZWZ0ID8gbGVmdC5jb3VudCA6IDApICsgKHJpZ2h0ID8gcmlnaHQuY291bnQgOiAwKSArIGxlZnRQb2ludHMubGVuZ3RoXG59XG5cbnZhciBwcm90byA9IEludGVydmFsVHJlZU5vZGUucHJvdG90eXBlXG5cbmZ1bmN0aW9uIGNvcHkoYSwgYikge1xuICBhLm1pZCA9IGIubWlkXG4gIGEubGVmdCA9IGIubGVmdFxuICBhLnJpZ2h0ID0gYi5yaWdodFxuICBhLmxlZnRQb2ludHMgPSBiLmxlZnRQb2ludHNcbiAgYS5yaWdodFBvaW50cyA9IGIucmlnaHRQb2ludHNcbiAgYS5jb3VudCA9IGIuY291bnRcbn1cblxuZnVuY3Rpb24gcmVidWlsZChub2RlLCBpbnRlcnZhbHMpIHtcbiAgdmFyIG50cmVlID0gY3JlYXRlSW50ZXJ2YWxUcmVlKGludGVydmFscylcbiAgbm9kZS5taWQgPSBudHJlZS5taWRcbiAgbm9kZS5sZWZ0ID0gbnRyZWUubGVmdFxuICBub2RlLnJpZ2h0ID0gbnRyZWUucmlnaHRcbiAgbm9kZS5sZWZ0UG9pbnRzID0gbnRyZWUubGVmdFBvaW50c1xuICBub2RlLnJpZ2h0UG9pbnRzID0gbnRyZWUucmlnaHRQb2ludHNcbiAgbm9kZS5jb3VudCA9IG50cmVlLmNvdW50XG59XG5cbmZ1bmN0aW9uIHJlYnVpbGRXaXRoSW50ZXJ2YWwobm9kZSwgaW50ZXJ2YWwpIHtcbiAgdmFyIGludGVydmFscyA9IG5vZGUuaW50ZXJ2YWxzKFtdKVxuICBpbnRlcnZhbHMucHVzaChpbnRlcnZhbClcbiAgcmVidWlsZChub2RlLCBpbnRlcnZhbHMpICAgIFxufVxuXG5mdW5jdGlvbiByZWJ1aWxkV2l0aG91dEludGVydmFsKG5vZGUsIGludGVydmFsKSB7XG4gIHZhciBpbnRlcnZhbHMgPSBub2RlLmludGVydmFscyhbXSlcbiAgdmFyIGlkeCA9IGludGVydmFscy5pbmRleE9mKGludGVydmFsKVxuICBpZihpZHggPCAwKSB7XG4gICAgcmV0dXJuIE5PVF9GT1VORFxuICB9XG4gIGludGVydmFscy5zcGxpY2UoaWR4LCAxKVxuICByZWJ1aWxkKG5vZGUsIGludGVydmFscylcbiAgcmV0dXJuIFNVQ0NFU1Ncbn1cblxucHJvdG8uaW50ZXJ2YWxzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgdGhpcy5sZWZ0UG9pbnRzKVxuICBpZih0aGlzLmxlZnQpIHtcbiAgICB0aGlzLmxlZnQuaW50ZXJ2YWxzKHJlc3VsdClcbiAgfVxuICBpZih0aGlzLnJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodC5pbnRlcnZhbHMocmVzdWx0KVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgdmFyIHdlaWdodCA9IHRoaXMuY291bnQgLSB0aGlzLmxlZnRQb2ludHMubGVuZ3RoXG4gIHRoaXMuY291bnQgKz0gMVxuICBpZihpbnRlcnZhbFsxXSA8IHRoaXMubWlkKSB7XG4gICAgaWYodGhpcy5sZWZ0KSB7XG4gICAgICBpZig0Kih0aGlzLmxlZnQuY291bnQrMSkgPiAzKih3ZWlnaHQrMSkpIHtcbiAgICAgICAgcmVidWlsZFdpdGhJbnRlcnZhbCh0aGlzLCBpbnRlcnZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdC5pbnNlcnQoaW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVmdCA9IGNyZWF0ZUludGVydmFsVHJlZShbaW50ZXJ2YWxdKVxuICAgIH1cbiAgfSBlbHNlIGlmKGludGVydmFsWzBdID4gdGhpcy5taWQpIHtcbiAgICBpZih0aGlzLnJpZ2h0KSB7XG4gICAgICBpZig0Kih0aGlzLnJpZ2h0LmNvdW50KzEpID4gMyood2VpZ2h0KzEpKSB7XG4gICAgICAgIHJlYnVpbGRXaXRoSW50ZXJ2YWwodGhpcywgaW50ZXJ2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJpZ2h0Lmluc2VydChpbnRlcnZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yaWdodCA9IGNyZWF0ZUludGVydmFsVHJlZShbaW50ZXJ2YWxdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbCA9IGJvdW5kcy5nZSh0aGlzLmxlZnRQb2ludHMsIGludGVydmFsLCBjb21wYXJlQmVnaW4pXG4gICAgdmFyIHIgPSBib3VuZHMuZ2UodGhpcy5yaWdodFBvaW50cywgaW50ZXJ2YWwsIGNvbXBhcmVFbmQpXG4gICAgdGhpcy5sZWZ0UG9pbnRzLnNwbGljZShsLCAwLCBpbnRlcnZhbClcbiAgICB0aGlzLnJpZ2h0UG9pbnRzLnNwbGljZShyLCAwLCBpbnRlcnZhbClcbiAgfVxufVxuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICB2YXIgd2VpZ2h0ID0gdGhpcy5jb3VudCAtIHRoaXMubGVmdFBvaW50c1xuICBpZihpbnRlcnZhbFsxXSA8IHRoaXMubWlkKSB7XG4gICAgaWYoIXRoaXMubGVmdCkge1xuICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgIH1cbiAgICB2YXIgcncgPSB0aGlzLnJpZ2h0ID8gdGhpcy5yaWdodC5jb3VudCA6IDBcbiAgICBpZig0ICogcncgPiAzICogKHdlaWdodC0xKSkge1xuICAgICAgcmV0dXJuIHJlYnVpbGRXaXRob3V0SW50ZXJ2YWwodGhpcywgaW50ZXJ2YWwpXG4gICAgfVxuICAgIHZhciByID0gdGhpcy5sZWZ0LnJlbW92ZShpbnRlcnZhbClcbiAgICBpZihyID09PSBFTVBUWSkge1xuICAgICAgdGhpcy5sZWZ0ID0gbnVsbFxuICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH0gZWxzZSBpZihyID09PSBTVUNDRVNTKSB7XG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICB9XG4gICAgcmV0dXJuIHJcbiAgfSBlbHNlIGlmKGludGVydmFsWzBdID4gdGhpcy5taWQpIHtcbiAgICBpZighdGhpcy5yaWdodCkge1xuICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgIH1cbiAgICB2YXIgbHcgPSB0aGlzLmxlZnQgPyB0aGlzLmxlZnQuY291bnQgOiAwXG4gICAgaWYoNCAqIGx3ID4gMyAqICh3ZWlnaHQtMSkpIHtcbiAgICAgIHJldHVybiByZWJ1aWxkV2l0aG91dEludGVydmFsKHRoaXMsIGludGVydmFsKVxuICAgIH1cbiAgICB2YXIgciA9IHRoaXMucmlnaHQucmVtb3ZlKGludGVydmFsKVxuICAgIGlmKHIgPT09IEVNUFRZKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gbnVsbFxuICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH0gZWxzZSBpZihyID09PSBTVUNDRVNTKSB7XG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICB9XG4gICAgcmV0dXJuIHJcbiAgfSBlbHNlIHtcbiAgICBpZih0aGlzLmNvdW50ID09PSAxKSB7XG4gICAgICBpZih0aGlzLmxlZnRQb2ludHNbMF0gPT09IGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBFTVBUWVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgICAgfVxuICAgIH1cbiAgICBpZih0aGlzLmxlZnRQb2ludHMubGVuZ3RoID09PSAxICYmIHRoaXMubGVmdFBvaW50c1swXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgIGlmKHRoaXMubGVmdCAmJiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gdGhpc1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVmdFxuICAgICAgICB3aGlsZShuLnJpZ2h0KSB7XG4gICAgICAgICAgcCA9IG5cbiAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIGlmKHAgPT09IHRoaXMpIHtcbiAgICAgICAgICBuLnJpZ2h0ID0gdGhpcy5yaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsID0gdGhpcy5sZWZ0XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnJpZ2h0XG4gICAgICAgICAgcC5jb3VudCAtPSBuLmNvdW50XG4gICAgICAgICAgcC5yaWdodCA9IG4ubGVmdFxuICAgICAgICAgIG4ubGVmdCA9IGxcbiAgICAgICAgICBuLnJpZ2h0ID0gclxuICAgICAgICB9XG4gICAgICAgIGNvcHkodGhpcywgbilcbiAgICAgICAgdGhpcy5jb3VudCA9ICh0aGlzLmxlZnQ/dGhpcy5sZWZ0LmNvdW50OjApICsgKHRoaXMucmlnaHQ/dGhpcy5yaWdodC5jb3VudDowKSArIHRoaXMubGVmdFBvaW50cy5sZW5ndGhcbiAgICAgIH0gZWxzZSBpZih0aGlzLmxlZnQpIHtcbiAgICAgICAgY29weSh0aGlzLCB0aGlzLmxlZnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5KHRoaXMsIHRoaXMucmlnaHQpXG4gICAgICB9XG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH1cbiAgICBmb3IodmFyIGwgPSBib3VuZHMuZ2UodGhpcy5sZWZ0UG9pbnRzLCBpbnRlcnZhbCwgY29tcGFyZUJlZ2luKTsgbDx0aGlzLmxlZnRQb2ludHMubGVuZ3RoOyArK2wpIHtcbiAgICAgIGlmKHRoaXMubGVmdFBvaW50c1tsXVswXSAhPT0gaW50ZXJ2YWxbMF0pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMubGVmdFBvaW50c1tsXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICAgIHRoaXMubGVmdFBvaW50cy5zcGxpY2UobCwgMSlcbiAgICAgICAgZm9yKHZhciByID0gYm91bmRzLmdlKHRoaXMucmlnaHRQb2ludHMsIGludGVydmFsLCBjb21wYXJlRW5kKTsgcjx0aGlzLnJpZ2h0UG9pbnRzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgaWYodGhpcy5yaWdodFBvaW50c1tyXVsxXSAhPT0gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIGlmKHRoaXMucmlnaHRQb2ludHNbcl0gPT09IGludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0UG9pbnRzLnNwbGljZShyLCAxKVxuICAgICAgICAgICAgcmV0dXJuIFNVQ0NFU1NcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5PVF9GT1VORFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcG9ydExlZnRSYW5nZShhcnIsIGhpLCBjYikge1xuICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoICYmIGFycltpXVswXSA8PSBoaTsgKytpKSB7XG4gICAgdmFyIHIgPSBjYihhcnJbaV0pXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0UmlnaHRSYW5nZShhcnIsIGxvLCBjYikge1xuICBmb3IodmFyIGk9YXJyLmxlbmd0aC0xOyBpPj0wICYmIGFycltpXVsxXSA+PSBsbzsgLS1pKSB7XG4gICAgdmFyIHIgPSBjYihhcnJbaV0pXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0UmFuZ2UoYXJyLCBjYikge1xuICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgciA9IGNiKGFycltpXSlcbiAgICBpZihyKSB7IHJldHVybiByIH1cbiAgfVxufVxuXG5wcm90by5xdWVyeVBvaW50ID0gZnVuY3Rpb24oeCwgY2IpIHtcbiAgaWYoeCA8IHRoaXMubWlkKSB7XG4gICAgaWYodGhpcy5sZWZ0KSB7XG4gICAgICB2YXIgciA9IHRoaXMubGVmdC5xdWVyeVBvaW50KHgsIGNiKVxuICAgICAgaWYocikgeyByZXR1cm4gciB9XG4gICAgfVxuICAgIHJldHVybiByZXBvcnRMZWZ0UmFuZ2UodGhpcy5sZWZ0UG9pbnRzLCB4LCBjYilcbiAgfSBlbHNlIGlmKHggPiB0aGlzLm1pZCkge1xuICAgIGlmKHRoaXMucmlnaHQpIHtcbiAgICAgIHZhciByID0gdGhpcy5yaWdodC5xdWVyeVBvaW50KHgsIGNiKVxuICAgICAgaWYocikgeyByZXR1cm4gciB9XG4gICAgfVxuICAgIHJldHVybiByZXBvcnRSaWdodFJhbmdlKHRoaXMucmlnaHRQb2ludHMsIHgsIGNiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIGNiKVxuICB9XG59XG5cbnByb3RvLnF1ZXJ5SW50ZXJ2YWwgPSBmdW5jdGlvbihsbywgaGksIGNiKSB7XG4gIGlmKGxvIDwgdGhpcy5taWQgJiYgdGhpcy5sZWZ0KSB7XG4gICAgdmFyIHIgPSB0aGlzLmxlZnQucXVlcnlJbnRlcnZhbChsbywgaGksIGNiKVxuICAgIGlmKHIpIHsgcmV0dXJuIHIgfVxuICB9XG4gIGlmKGhpID4gdGhpcy5taWQgJiYgdGhpcy5yaWdodCkge1xuICAgIHZhciByID0gdGhpcy5yaWdodC5xdWVyeUludGVydmFsKGxvLCBoaSwgY2IpXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbiAgaWYoaGkgPCB0aGlzLm1pZCkge1xuICAgIHJldHVybiByZXBvcnRMZWZ0UmFuZ2UodGhpcy5sZWZ0UG9pbnRzLCBoaSwgY2IpXG4gIH0gZWxzZSBpZihsbyA+IHRoaXMubWlkKSB7XG4gICAgcmV0dXJuIHJlcG9ydFJpZ2h0UmFuZ2UodGhpcy5yaWdodFBvaW50cywgbG8sIGNiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIGNiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVCZWdpbihhLCBiKSB7XG4gIHZhciBkID0gYVswXSAtIGJbMF1cbiAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIHJldHVybiBhWzFdIC0gYlsxXVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRW5kKGEsIGIpIHtcbiAgdmFyIGQgPSBhWzFdIC0gYlsxXVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVydmFsVHJlZShpbnRlcnZhbHMpIHtcbiAgaWYoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHB0cyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGludGVydmFscy5sZW5ndGg7ICsraSkge1xuICAgIHB0cy5wdXNoKGludGVydmFsc1tpXVswXSwgaW50ZXJ2YWxzW2ldWzFdKVxuICB9XG4gIHB0cy5zb3J0KGNvbXBhcmVOdW1iZXJzKVxuXG4gIHZhciBtaWQgPSBwdHNbcHRzLmxlbmd0aD4+MV1cblxuICB2YXIgbGVmdEludGVydmFscyA9IFtdXG4gIHZhciByaWdodEludGVydmFscyA9IFtdXG4gIHZhciBjZW50ZXJJbnRlcnZhbHMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxpbnRlcnZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcyA9IGludGVydmFsc1tpXVxuICAgIGlmKHNbMV0gPCBtaWQpIHtcbiAgICAgIGxlZnRJbnRlcnZhbHMucHVzaChzKVxuICAgIH0gZWxzZSBpZihtaWQgPCBzWzBdKSB7XG4gICAgICByaWdodEludGVydmFscy5wdXNoKHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlckludGVydmFscy5wdXNoKHMpXG4gICAgfVxuICB9XG5cbiAgLy9TcGxpdCBjZW50ZXIgaW50ZXJ2YWxzXG4gIHZhciBsZWZ0UG9pbnRzID0gY2VudGVySW50ZXJ2YWxzXG4gIHZhciByaWdodFBvaW50cyA9IGNlbnRlckludGVydmFscy5zbGljZSgpXG4gIGxlZnRQb2ludHMuc29ydChjb21wYXJlQmVnaW4pXG4gIHJpZ2h0UG9pbnRzLnNvcnQoY29tcGFyZUVuZClcblxuICByZXR1cm4gbmV3IEludGVydmFsVHJlZU5vZGUobWlkLCBcbiAgICBjcmVhdGVJbnRlcnZhbFRyZWUobGVmdEludGVydmFscyksXG4gICAgY3JlYXRlSW50ZXJ2YWxUcmVlKHJpZ2h0SW50ZXJ2YWxzKSxcbiAgICBsZWZ0UG9pbnRzLFxuICAgIHJpZ2h0UG9pbnRzKVxufVxuXG4vL1VzZXIgZnJpZW5kbHkgd3JhcHBlciB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIHN1cHBvcnQgZW1wdHkgdHJlZXNcbmZ1bmN0aW9uIEludGVydmFsVHJlZShyb290KSB7XG4gIHRoaXMucm9vdCA9IHJvb3Rcbn1cblxudmFyIHRwcm90byA9IEludGVydmFsVHJlZS5wcm90b3R5cGVcblxudHByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIGlmKHRoaXMucm9vdCkge1xuICAgIHRoaXMucm9vdC5pbnNlcnQoaW50ZXJ2YWwpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yb290ID0gbmV3IEludGVydmFsVHJlZU5vZGUoaW50ZXJ2YWxbMF0sIG51bGwsIG51bGwsIFtpbnRlcnZhbF0sIFtpbnRlcnZhbF0pXG4gIH1cbn1cblxudHByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIGlmKHRoaXMucm9vdCkge1xuICAgIHZhciByID0gdGhpcy5yb290LnJlbW92ZShpbnRlcnZhbClcbiAgICBpZihyID09PSBFTVBUWSkge1xuICAgICAgdGhpcy5yb290ID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gciAhPT0gTk9UX0ZPVU5EXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbnRwcm90by5xdWVyeVBvaW50ID0gZnVuY3Rpb24ocCwgY2IpIHtcbiAgaWYodGhpcy5yb290KSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVBvaW50KHAsIGNiKVxuICB9XG59XG5cbnRwcm90by5xdWVyeUludGVydmFsID0gZnVuY3Rpb24obG8sIGhpLCBjYikge1xuICBpZihsbyA8PSBoaSAmJiB0aGlzLnJvb3QpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5SW50ZXJ2YWwobG8sIGhpLCBjYilcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodHByb3RvLCBcImNvdW50XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuY291bnRcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRwcm90bywgXCJpbnRlcnZhbHNcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMucm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbnRlcnZhbHMoW10pXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGludGVydmFscykge1xuICBpZighaW50ZXJ2YWxzIHx8IGludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsVHJlZShudWxsKVxuICB9XG4gIHJldHVybiBuZXcgSW50ZXJ2YWxUcmVlKGNyZWF0ZUludGVydmFsVHJlZShpbnRlcnZhbHMpKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW52ZXJ0UGVybXV0YXRpb24ocGksIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IEFycmF5KHBpLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cGkubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbcGlbaV1dID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRQZXJtdXRhdGlvbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiIWZ1bmN0aW9uKHIsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpyfHxzZWxmKS5NZXlkYT10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihyLHQsZSl7aWYoZXx8Mj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBhLG49MCxvPXQubGVuZ3RoO248bztuKyspIWEmJm4gaW4gdHx8KGF8fChhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCxuKSksYVtuXT10W25dKTtyZXR1cm4gci5jb25jYXQoYXx8QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpfXZhciB0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGJsYWNrbWFuOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KHIpLGU9MipNYXRoLlBJLyhyLTEpLGE9MiplLG49MDtuPHIvMjtuKyspdFtuXT0uNDItLjUqTWF0aC5jb3MobiplKSsuMDgqTWF0aC5jb3MobiphKTtmb3Iobj1NYXRoLmNlaWwoci8yKTtuPjA7bi0tKXRbci1uXT10W24tMV07cmV0dXJuIHR9LHNpbmU6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PU1hdGguUEkvKHItMSksZT1uZXcgRmxvYXQzMkFycmF5KHIpLGE9MDthPHI7YSsrKWVbYV09TWF0aC5zaW4odCphKTtyZXR1cm4gZX0saGFubmluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41LS41Kk1hdGguY29zKDIqTWF0aC5QSSplLyhyLTEpKTtyZXR1cm4gdH0saGFtbWluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41NC0uNDYqTWF0aC5jb3MoMipNYXRoLlBJKihlL3ItMSkpO3JldHVybiB0fX0pLGU9e307ZnVuY3Rpb24gYShyKXtmb3IoO3IlMj09MCYmcj4xOylyLz0yO3JldHVybiAxPT09cn1mdW5jdGlvbiBuKHIsYSl7aWYoXCJyZWN0XCIhPT1hKXtpZihcIlwiIT09YSYmYXx8KGE9XCJoYW5uaW5nXCIpLGVbYV18fChlW2FdPXt9KSwhZVthXVtyLmxlbmd0aF0pdHJ5e2VbYV1bci5sZW5ndGhdPXRbYV0oci5sZW5ndGgpfWNhdGNoKHIpe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2luZG93aW5nIGZ1bmN0aW9uXCIpfXI9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGU9W10sYT0wO2E8TWF0aC5taW4oci5sZW5ndGgsdC5sZW5ndGgpO2ErKyllW2FdPXJbYV0qdFthXTtyZXR1cm4gZX0ocixlW2FdW3IubGVuZ3RoXSl9cmV0dXJuIHJ9ZnVuY3Rpb24gbyhyLHQsZSl7Zm9yKHZhciBhPW5ldyBGbG9hdDMyQXJyYXkociksbj0wO248YS5sZW5ndGg7bisrKWFbbl09bip0L2UsYVtuXT0xMypNYXRoLmF0YW4oYVtuXS8xMzE1LjgpKzMuNSpNYXRoLmF0YW4oTWF0aC5wb3coYVtuXS83NTE4LDIpKTtyZXR1cm4gYX1mdW5jdGlvbiBpKHIpe3JldHVybiBGbG9hdDMyQXJyYXkuZnJvbShyKX1mdW5jdGlvbiB1KHIpe3JldHVybiAxMTI1Kk1hdGgubG9nKDErci83MDApfWZ1bmN0aW9uIGYocix0LGUpe2Zvcih2YXIgYSxuPW5ldyBGbG9hdDMyQXJyYXkocisyKSxvPW5ldyBGbG9hdDMyQXJyYXkocisyKSxpPXQvMixmPXUoMCksYz0odShpKS1mKS8ocisxKSxsPW5ldyBBcnJheShyKzIpLHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPXMqYyxvW3NdPShhPW5bc10sNzAwKihNYXRoLmV4cChhLzExMjUpLTEpKSxsW3NdPU1hdGguZmxvb3IoKGUrMSkqb1tzXS90KTtmb3IodmFyIG09bmV3IEFycmF5KHIpLHA9MDtwPG0ubGVuZ3RoO3ArKyl7bVtwXT1uZXcgQXJyYXkoZS8yKzEpLmZpbGwoMCk7Zm9yKHM9bFtwXTtzPGxbcCsxXTtzKyspbVtwXVtzXT0ocy1sW3BdKS8obFtwKzFdLWxbcF0pO2ZvcihzPWxbcCsxXTtzPGxbcCsyXTtzKyspbVtwXVtzXT0obFtwKzJdLXMpLyhsW3ArMl0tbFtwKzFdKX1yZXR1cm4gbX1mdW5jdGlvbiBjKHQsZSxhLG4sbyxpLHUpe3ZvaWQgMD09PW4mJihuPTUpLHZvaWQgMD09PW8mJihvPTIpLHZvaWQgMD09PWkmJihpPSEwKSx2b2lkIDA9PT11JiYodT00NDApO3ZhciBmPU1hdGguZmxvb3IoYS8yKSsxLGM9bmV3IEFycmF5KGEpLmZpbGwoMCkubWFwKChmdW5jdGlvbihyLG4pe3JldHVybiB0KmZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubG9nMigxNipyL3QpfShlKm4vYSx1KX0pKTtjWzBdPWNbMV0tMS41KnQ7dmFyIGwscyxtLHA9Yy5zbGljZSgxKS5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubWF4KHItY1t0XSl9KSwxKS5jb25jYXQoWzFdKSxoPU1hdGgucm91bmQodC8yKSxnPW5ldyBBcnJheSh0KS5maWxsKDApLm1hcCgoZnVuY3Rpb24ocixlKXtyZXR1cm4gYy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybigxMCp0K2grci1lKSV0LWh9KSl9KSksdz1nLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygyKmdbdF1bZV0vcFtlXSwyKSl9KSl9KSk7aWYocz0obD13KVswXS5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuIDB9KSksbT1sLnJlZHVjZSgoZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3JbZV0rPU1hdGgucG93KHQsMil9KSkscn0pLHMpLm1hcChNYXRoLnNxcnQpLHc9bC5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIHIubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiByLyhtW3RdfHwxKX0pKX0pKSxvKXt2YXIgdj1jLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygoci90LW4pL28sMikpfSkpO3c9dy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gcip2W3RdfSkpfSkpfXJldHVybiBpJiYodz1yKHIoW10sdy5zbGljZSgzKSwhMCksdy5zbGljZSgwLDMpLCEwKSksdy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLnNsaWNlKDAsZil9KSl9ZnVuY3Rpb24gbChyLHQpe2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5wb3cobixyKSpNYXRoLmFicyh0W25dKSxhKz10W25dO3JldHVybiBlL2F9ZnVuY3Rpb24gcyhyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5iYXJrU2NhbGUsYT1yLm51bWJlck9mQmFya0JhbmRzLG49dm9pZCAwPT09YT8yNDphO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBvPW4saT1uZXcgRmxvYXQzMkFycmF5KG8pLHU9MCxmPXQsYz1uZXcgSW50MzJBcnJheShvKzEpO2NbMF09MDtmb3IodmFyIGw9ZVtmLmxlbmd0aC0xXS9vLHM9MSxtPTA7bTxmLmxlbmd0aDttKyspZm9yKDtlW21dPmw7KWNbcysrXT1tLGw9cyplW2YubGVuZ3RoLTFdL287Y1tvXT1mLmxlbmd0aC0xO2ZvcihtPTA7bTxvO20rKyl7Zm9yKHZhciBwPTAsaD1jW21dO2g8Y1ttKzFdO2grKylwKz1mW2hdO2lbbV09TWF0aC5wb3cocCwuMjMpfWZvcihtPTA7bTxpLmxlbmd0aDttKyspdSs9aVttXTtyZXR1cm57c3BlY2lmaWM6aSx0b3RhbDp1fX1mdW5jdGlvbiBtKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksYT0wO2E8ZS5sZW5ndGg7YSsrKWVbYV09TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZX1mdW5jdGlvbiBwKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWxpZCBtZWxGaWx0ZXJCYW5rIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2Zvcih2YXIgbj1tKHthbXBTcGVjdHJ1bTp0fSksbz1lLmxlbmd0aCxpPUFycmF5KG8pLHU9bmV3IEZsb2F0MzJBcnJheShvKSxmPTA7Zjx1Lmxlbmd0aDtmKyspe2lbZl09bmV3IEZsb2F0MzJBcnJheShhLzIpLHVbZl09MDtmb3IodmFyIGM9MDtjPGEvMjtjKyspaVtmXVtjXT1lW2ZdW2NdKm5bY10sdVtmXSs9aVtmXVtjXTt1W2ZdPU1hdGgubG9nKHVbZl0rMSl9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHUpfWZ1bmN0aW9uIGgocil7cmV0dXJuIHImJnIuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJkZWZhdWx0XCIpP3IuZGVmYXVsdDpyfXZhciBnPXtleHBvcnRzOnt9fSx3PW51bGw7dmFyIHY9ZnVuY3Rpb24ocix0KXt2YXIgZT1yLmxlbmd0aDtyZXR1cm4gdD10fHwyLHcmJndbZV18fGZ1bmN0aW9uKHIpeyh3PXd8fHt9KVtyXT1uZXcgQXJyYXkocipyKTtmb3IodmFyIHQ9TWF0aC5QSS9yLGU9MDtlPHI7ZSsrKWZvcih2YXIgYT0wO2E8cjthKyspd1tyXVthK2Uqcl09TWF0aC5jb3ModCooYSsuNSkqZSl9KGUpLHIubWFwKChmdW5jdGlvbigpe3JldHVybiAwfSkpLm1hcCgoZnVuY3Rpb24oYSxuKXtyZXR1cm4gdCpyLnJlZHVjZSgoZnVuY3Rpb24ocix0LGEsbyl7cmV0dXJuIHIrdCp3W2VdW2ErbiplXX0pLDApfSkpfTshZnVuY3Rpb24ocil7ci5leHBvcnRzPXZ9KGcpO3ZhciBkPWgoZy5leHBvcnRzKTt2YXIgeT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxidWZmZXI6ZnVuY3Rpb24ocil7cmV0dXJuIHIuc2lnbmFsfSxybXM6ZnVuY3Rpb24ocil7dmFyIHQ9ci5zaWduYWw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9MCxhPTA7YTx0Lmxlbmd0aDthKyspZSs9TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZS89dC5sZW5ndGgsZT1NYXRoLnNxcnQoZSl9LGVuZXJneTpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MDthPHQubGVuZ3RoO2ErKyllKz1NYXRoLnBvdyhNYXRoLmFicyh0W2FdKSwyKTtyZXR1cm4gZX0sY29tcGxleFNwZWN0cnVtOmZ1bmN0aW9uKHIpe3JldHVybiByLmNvbXBsZXhTcGVjdHJ1bX0sc3BlY3RyYWxTbG9wZTpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5zYW1wbGVSYXRlLGE9ci5idWZmZXJTaXplO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0wLGk9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksdT0wLGY9MCxjPTA7Yzx0Lmxlbmd0aDtjKyspe24rPXRbY107dmFyIGw9YyplL2E7aVtjXT1sLHUrPWwqbCxvKz1sLGYrPWwqdFtjXX1yZXR1cm4odC5sZW5ndGgqZi1vKm4pLyhuKih1LU1hdGgucG93KG8sMikpKX0sc3BlY3RyYWxDZW50cm9pZDpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7cmV0dXJuIGwoMSx0KX0sc3BlY3RyYWxSb2xsb2ZmOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLnNhbXBsZVJhdGU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGE9dCxuPWUvKDIqKGEubGVuZ3RoLTEpKSxvPTAsaT0wO2k8YS5sZW5ndGg7aSsrKW8rPWFbaV07Zm9yKHZhciB1PS45OSpvLGY9YS5sZW5ndGgtMTtvPnUmJmY+PTA7KW8tPWFbZl0sLS1mO3JldHVybihmKzEpKm59LHNwZWN0cmFsRmxhdG5lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5sb2codFtuXSksYSs9dFtuXTtyZXR1cm4gTWF0aC5leHAoZS90Lmxlbmd0aCkqdC5sZW5ndGgvYX0sc3BlY3RyYWxTcHJlYWQ6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3JldHVybiBNYXRoLnNxcnQobCgyLHQpLU1hdGgucG93KGwoMSx0KSwyKSl9LHNwZWN0cmFsU2tld25lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBlPWwoMSx0KSxhPWwoMix0KSxuPWwoMyx0KTtyZXR1cm4oMipNYXRoLnBvdyhlLDMpLTMqZSphK24pL01hdGgucG93KE1hdGguc3FydChhLU1hdGgucG93KGUsMikpLDMpfSxzcGVjdHJhbEt1cnRvc2lzOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT10LGE9bCgxLGUpLG49bCgyLGUpLG89bCgzLGUpLGk9bCg0LGUpO3JldHVybigtMypNYXRoLnBvdyhhLDQpKzYqYSpuLTQqYSpvK2kpL01hdGgucG93KE1hdGguc3FydChuLU1hdGgucG93KGEsMikpLDQpfSxhbXBsaXR1ZGVTcGVjdHJ1bTpmdW5jdGlvbihyKXtyZXR1cm4gci5hbXBTcGVjdHJ1bX0semNyOmZ1bmN0aW9uKHIpe3ZhciB0PXIuc2lnbmFsO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBlPTAsYT0xO2E8dC5sZW5ndGg7YSsrKSh0W2EtMV0+PTAmJnRbYV08MHx8dFthLTFdPDAmJnRbYV0+PTApJiZlKys7cmV0dXJuIGV9LGxvdWRuZXNzOnMscGVyY2VwdHVhbFNwcmVhZDpmdW5jdGlvbihyKXtmb3IodmFyIHQ9cyh7YW1wU3BlY3RydW06ci5hbXBTcGVjdHJ1bSxiYXJrU2NhbGU6ci5iYXJrU2NhbGV9KSxlPTAsYT0wO2E8dC5zcGVjaWZpYy5sZW5ndGg7YSsrKXQuc3BlY2lmaWNbYV0+ZSYmKGU9dC5zcGVjaWZpY1thXSk7cmV0dXJuIE1hdGgucG93KCh0LnRvdGFsLWUpL3QudG90YWwsMil9LHBlcmNlcHR1YWxTaGFycG5lc3M6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PXMoe2FtcFNwZWN0cnVtOnIuYW1wU3BlY3RydW0sYmFya1NjYWxlOnIuYmFya1NjYWxlfSksZT10LnNwZWNpZmljLGE9MCxuPTA7bjxlLmxlbmd0aDtuKyspYSs9bjwxNT8obisxKSplW24rMV06LjA2NipNYXRoLmV4cCguMTcxKihuKzEpKTtyZXR1cm4gYSo9LjExL3QudG90YWx9LHBvd2VyU3BlY3RydW06bSxtZmNjOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyxuPXIuYnVmZmVyU2l6ZSxvPU1hdGgubWluKDQwLE1hdGgubWF4KDEsYXx8MTMpKTtpZihlLmxlbmd0aDxvKXRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBmaWx0ZXIgYmFuayBmb3IgcmVxdWVzdGVkIG51bWJlciBvZiBjb2VmZmljaWVudHNcIik7dmFyIGk9cCh7YW1wU3BlY3RydW06dCxtZWxGaWx0ZXJCYW5rOmUsYnVmZmVyU2l6ZTpufSk7cmV0dXJuIGQoaSkuc2xpY2UoMCxvKX0sY2hyb21hOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLmNocm9tYUZpbHRlckJhbms7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgY2hyb21hRmlsdGVyQmFuayBpcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBjaHJvbWFcIik7dmFyIGE9ZS5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbih0LGUsYSl7cmV0dXJuIHQrZSpyW2FdfSksMCl9KSksbj1NYXRoLm1heC5hcHBseShNYXRoLGEpO3JldHVybiBuP2EubWFwKChmdW5jdGlvbihyKXtyZXR1cm4gci9ufSkpOmF9LHNwZWN0cmFsRmx1eDpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbCxlPXIucHJldmlvdXNTaWduYWwsYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0tYS8yO288dC5sZW5ndGgvMi0xO28rKyl4PU1hdGguYWJzKHRbb10pLU1hdGguYWJzKGVbb10pLG4rPSh4K01hdGguYWJzKHgpKS8yO3JldHVybiBufSxzcGVjdHJhbENyZXN0OmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT0wLGE9LTEvMDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihyKXtlKz1NYXRoLnBvdyhyLDIpLGE9cj5hP3I6YX0pKSxlLz10Lmxlbmd0aCxlPU1hdGguc3FydChlKSxhL2V9LG1lbEJhbmRzOnB9KTtmdW5jdGlvbiBTKHIpe2lmKEFycmF5LmlzQXJyYXkocikpe2Zvcih2YXIgdD0wLGU9QXJyYXkoci5sZW5ndGgpO3Q8ci5sZW5ndGg7dCsrKWVbdF09clt0XTtyZXR1cm4gZX1yZXR1cm4gQXJyYXkuZnJvbShyKX12YXIgXz17fSxiPXt9LE09e2JpdFJldmVyc2VBcnJheTpmdW5jdGlvbihyKXtpZih2b2lkIDA9PT1fW3JdKXtmb3IodmFyIHQ9KHItMSkudG9TdHJpbmcoMikubGVuZ3RoLGU9XCIwXCIucmVwZWF0KHQpLGE9e30sbj0wO248cjtuKyspe3ZhciBvPW4udG9TdHJpbmcoMik7bz1lLnN1YnN0cihvLmxlbmd0aCkrbyxvPVtdLmNvbmNhdChTKG8pKS5yZXZlcnNlKCkuam9pbihcIlwiKSxhW25dPXBhcnNlSW50KG8sMil9X1tyXT1hfXJldHVybiBfW3JdfSxtdWx0aXBseTpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCp0LnJlYWwtci5pbWFnKnQuaW1hZyxpbWFnOnIucmVhbCp0LmltYWcrci5pbWFnKnQucmVhbH19LGFkZDpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCt0LnJlYWwsaW1hZzpyLmltYWcrdC5pbWFnfX0sc3VidHJhY3Q6ZnVuY3Rpb24ocix0KXtyZXR1cm57cmVhbDpyLnJlYWwtdC5yZWFsLGltYWc6ci5pbWFnLXQuaW1hZ319LGV1bGVyOmZ1bmN0aW9uKHIsdCl7dmFyIGU9LTIqTWF0aC5QSSpyL3Q7cmV0dXJue3JlYWw6TWF0aC5jb3MoZSksaW1hZzpNYXRoLnNpbihlKX19LGNvbmo6ZnVuY3Rpb24ocil7cmV0dXJuIHIuaW1hZyo9LTEscn0sY29uc3RydWN0Q29tcGxleEFycmF5OmZ1bmN0aW9uKHIpe3ZhciB0PXt9O3QucmVhbD12b2lkIDA9PT1yLnJlYWw/ci5zbGljZSgpOnIucmVhbC5zbGljZSgpO3ZhciBlPXQucmVhbC5sZW5ndGg7cmV0dXJuIHZvaWQgMD09PWJbZV0mJihiW2VdPUFycmF5LmFwcGx5KG51bGwsQXJyYXkoZSkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsMCkpLHQuaW1hZz1iW2VdLnNsaWNlKCksdH19LEY9ZnVuY3Rpb24ocil7dmFyIHQ9e307dm9pZCAwPT09ci5yZWFsfHx2b2lkIDA9PT1yLmltYWc/dD1NLmNvbnN0cnVjdENvbXBsZXhBcnJheShyKToodC5yZWFsPXIucmVhbC5zbGljZSgpLHQuaW1hZz1yLmltYWcuc2xpY2UoKSk7dmFyIGU9dC5yZWFsLmxlbmd0aCxhPU1hdGgubG9nMihlKTtpZihNYXRoLnJvdW5kKGEpIT1hKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIuXCIpO2lmKHQucmVhbC5sZW5ndGghPXQuaW1hZy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cIik7Zm9yKHZhciBuPU0uYml0UmV2ZXJzZUFycmF5KGUpLG89e3JlYWw6W10saW1hZzpbXX0saT0wO2k8ZTtpKyspby5yZWFsW25baV1dPXQucmVhbFtpXSxvLmltYWdbbltpXV09dC5pbWFnW2ldO2Zvcih2YXIgdT0wO3U8ZTt1KyspdC5yZWFsW3VdPW8ucmVhbFt1XSx0LmltYWdbdV09by5pbWFnW3VdO2Zvcih2YXIgZj0xO2Y8PWE7ZisrKWZvcih2YXIgYz1NYXRoLnBvdygyLGYpLGw9MDtsPGMvMjtsKyspZm9yKHZhciBzPU0uZXVsZXIobCxjKSxtPTA7bTxlL2M7bSsrKXt2YXIgcD1jKm0rbCxoPWMqbStsK2MvMixnPXtyZWFsOnQucmVhbFtwXSxpbWFnOnQuaW1hZ1twXX0sdz17cmVhbDp0LnJlYWxbaF0saW1hZzp0LmltYWdbaF19LHY9TS5tdWx0aXBseShzLHcpLGQ9TS5zdWJ0cmFjdChnLHYpO3QucmVhbFtoXT1kLnJlYWwsdC5pbWFnW2hdPWQuaW1hZzt2YXIgeT1NLmFkZCh2LGcpO3QucmVhbFtwXT15LnJlYWwsdC5pbWFnW3BdPXkuaW1hZ31yZXR1cm4gdH0sQT1GLEU9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIsdCl7dmFyIGU9dGhpcztpZih0aGlzLl9tPXQsIXIuYXVkaW9Db250ZXh0KXRocm93IHRoaXMuX20uZXJyb3JzLm5vQUM7aWYoci5idWZmZXJTaXplJiYhYShyLmJ1ZmZlclNpemUpKXRocm93IHRoaXMuX20uX2Vycm9ycy5ub3RQb3cyO2lmKCFyLnNvdXJjZSl0aHJvdyB0aGlzLl9tLl9lcnJvcnMubm9Tb3VyY2U7dGhpcy5fbS5hdWRpb0NvbnRleHQ9ci5hdWRpb0NvbnRleHQsdGhpcy5fbS5idWZmZXJTaXplPXIuYnVmZmVyU2l6ZXx8dGhpcy5fbS5idWZmZXJTaXplfHwyNTYsdGhpcy5fbS5ob3BTaXplPXIuaG9wU2l6ZXx8dGhpcy5fbS5ob3BTaXplfHx0aGlzLl9tLmJ1ZmZlclNpemUsdGhpcy5fbS5zYW1wbGVSYXRlPXIuc2FtcGxlUmF0ZXx8dGhpcy5fbS5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZXx8NDQxMDAsdGhpcy5fbS5jYWxsYmFjaz1yLmNhbGxiYWNrLHRoaXMuX20ud2luZG93aW5nRnVuY3Rpb249ci53aW5kb3dpbmdGdW5jdGlvbnx8XCJoYW5uaW5nXCIsdGhpcy5fbS5mZWF0dXJlRXh0cmFjdG9ycz15LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPXIuc3RhcnRJbW1lZGlhdGVseXx8ITEsdGhpcy5fbS5jaGFubmVsPVwibnVtYmVyXCI9PXR5cGVvZiByLmNoYW5uZWw/ci5jaGFubmVsOjAsdGhpcy5fbS5pbnB1dHM9ci5pbnB1dHN8fDEsdGhpcy5fbS5vdXRwdXRzPXIub3V0cHV0c3x8MSx0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cz1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50c3x8dGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHN8fDEzLHRoaXMuX20ubnVtYmVyT2ZCYXJrQmFuZHM9ci5udW1iZXJPZkJhcmtCYW5kc3x8dGhpcy5fbS5udW1iZXJPZkJhcmtCYW5kc3x8MjQsdGhpcy5fbS5zcG49dGhpcy5fbS5hdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKHRoaXMuX20uYnVmZmVyU2l6ZSx0aGlzLl9tLmlucHV0cyx0aGlzLl9tLm91dHB1dHMpLHRoaXMuX20uc3BuLmNvbm5lY3QodGhpcy5fbS5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXIuZmVhdHVyZUV4dHJhY3RvcnN8fFtdLHRoaXMuX20uYmFya1NjYWxlPW8odGhpcy5fbS5idWZmZXJTaXplLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20ubWVsRmlsdGVyQmFuaz1mKE1hdGgubWF4KHRoaXMuX20ubWVsQmFuZHMsdGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20uaW5wdXREYXRhPW51bGwsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YT1udWxsLHRoaXMuX20uZnJhbWU9bnVsbCx0aGlzLl9tLnByZXZpb3VzRnJhbWU9bnVsbCx0aGlzLnNldFNvdXJjZShyLnNvdXJjZSksdGhpcy5fbS5zcG4ub25hdWRpb3Byb2Nlc3M9ZnVuY3Rpb24ocil7dmFyIHQ7bnVsbCE9PWUuX20uaW5wdXREYXRhJiYoZS5fbS5wcmV2aW91c0lucHV0RGF0YT1lLl9tLmlucHV0RGF0YSksZS5fbS5pbnB1dERhdGE9ci5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShlLl9tLmNoYW5uZWwpLGUuX20ucHJldmlvdXNJbnB1dERhdGE/KCh0PW5ldyBGbG9hdDMyQXJyYXkoZS5fbS5wcmV2aW91c0lucHV0RGF0YS5sZW5ndGgrZS5fbS5pbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpLnNldChlLl9tLnByZXZpb3VzSW5wdXREYXRhLnNsaWNlKGUuX20uaG9wU2l6ZSkpLHQuc2V0KGUuX20uaW5wdXREYXRhLGUuX20ucHJldmlvdXNJbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpOnQ9ZS5fbS5pbnB1dERhdGEsZnVuY3Rpb24ocix0LGUpe2lmKHIubGVuZ3RoPHQpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGlzIHRvbyBzaG9ydCBmb3IgZnJhbWUgbGVuZ3RoXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoXCJIb3AgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTtpZih0PDEpdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTt2YXIgYT0xK01hdGguZmxvb3IoKHIubGVuZ3RoLXQpL2UpO3JldHVybiBuZXcgQXJyYXkoYSkuZmlsbCgwKS5tYXAoKGZ1bmN0aW9uKGEsbil7cmV0dXJuIHIuc2xpY2UobiplLG4qZSt0KX0pKX0odCxlLl9tLmJ1ZmZlclNpemUsZS5fbS5ob3BTaXplKS5mb3JFYWNoKChmdW5jdGlvbihyKXtlLl9tLmZyYW1lPXI7dmFyIHQ9ZS5fbS5leHRyYWN0KGUuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LGUuX20uZnJhbWUsZS5fbS5wcmV2aW91c0ZyYW1lKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLl9tLmNhbGxiYWNrJiZlLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCYmZS5fbS5jYWxsYmFjayh0KSxlLl9tLnByZXZpb3VzRnJhbWU9ZS5fbS5mcmFtZX0pKX19cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHIpe3RoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXJ8fHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPSEwfSxyLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQ9ITF9LHIucHJvdG90eXBlLnNldFNvdXJjZT1mdW5jdGlvbihyKXt0aGlzLl9tLnNvdXJjZSYmdGhpcy5fbS5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLl9tLnNwbiksdGhpcy5fbS5zb3VyY2U9cix0aGlzLl9tLnNvdXJjZS5jb25uZWN0KHRoaXMuX20uc3BuKX0sci5wcm90b3R5cGUuc2V0Q2hhbm5lbD1mdW5jdGlvbihyKXtyPD10aGlzLl9tLmlucHV0cz90aGlzLl9tLmNoYW5uZWw9cjpjb25zb2xlLmVycm9yKFwiQ2hhbm5lbCBcIi5jb25jYXQocixcIiBkb2VzIG5vdCBleGlzdC4gTWFrZSBzdXJlIHlvdSd2ZSBwcm92aWRlZCBhIHZhbHVlIGZvciAnaW5wdXRzJyB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBcIikuY29uY2F0KHIsXCIgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBNZXlkYUFuYWx5emVyXCIpKX0sci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLl9tLmlucHV0RGF0YT90aGlzLl9tLmV4dHJhY3Qocnx8dGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsdGhpcy5fbS5pbnB1dERhdGEsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YSk6bnVsbH0scn0oKSxDPXthdWRpb0NvbnRleHQ6bnVsbCxzcG46bnVsbCxidWZmZXJTaXplOjUxMixzYW1wbGVSYXRlOjQ0MTAwLG1lbEJhbmRzOjI2LGNocm9tYUJhbmRzOjEyLGNhbGxiYWNrOm51bGwsd2luZG93aW5nRnVuY3Rpb246XCJoYW5uaW5nXCIsZmVhdHVyZUV4dHJhY3RvcnM6eSxFWFRSQUNUSU9OX1NUQVJURUQ6ITEsbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzOjEzLG51bWJlck9mQmFya0JhbmRzOjI0LF9mZWF0dXJlc1RvRXh0cmFjdDpbXSx3aW5kb3dpbmc6bixfZXJyb3JzOntub3RQb3cyOm5ldyBFcnJvcihcIk1leWRhOiBCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiwgZS5nLiA2NCBvciA1MTJcIiksZmVhdHVyZVVuZGVmOm5ldyBFcnJvcihcIk1leWRhOiBObyBmZWF0dXJlcyBkZWZpbmVkLlwiKSxpbnZhbGlkRmVhdHVyZUZtdDpuZXcgRXJyb3IoXCJNZXlkYTogSW52YWxpZCBmZWF0dXJlIGZvcm1hdFwiKSxpbnZhbGlkSW5wdXQ6bmV3IEVycm9yKFwiTWV5ZGE6IEludmFsaWQgaW5wdXQuXCIpLG5vQUM6bmV3IEVycm9yKFwiTWV5ZGE6IE5vIEF1ZGlvQ29udGV4dCBzcGVjaWZpZWQuXCIpLG5vU291cmNlOm5ldyBFcnJvcihcIk1leWRhOiBObyBzb3VyY2Ugbm9kZSBzcGVjaWZpZWQuXCIpfSxjcmVhdGVNZXlkYUFuYWx5emVyOmZ1bmN0aW9uKHIpe3JldHVybiBuZXcgRShyLE9iamVjdC5hc3NpZ24oe30sQykpfSxsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnM6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5mZWF0dXJlRXh0cmFjdG9ycyl9LGV4dHJhY3Q6ZnVuY3Rpb24ocix0LGUpe3ZhciBuPXRoaXM7aWYoIXQpdGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRJbnB1dDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyB0aGlzLl9lcnJvcnMuaW52YWxpZElucHV0O2lmKCFyKXRocm93IHRoaXMuX2Vycm9ycy5mZWF0dXJlVW5kZWY7aWYoIWEodC5sZW5ndGgpKXRocm93IHRoaXMuX2Vycm9ycy5ub3RQb3cyO3ZvaWQgMCE9PXRoaXMuYmFya1NjYWxlJiZ0aGlzLmJhcmtTY2FsZS5sZW5ndGg9PXRoaXMuYnVmZmVyU2l6ZXx8KHRoaXMuYmFya1NjYWxlPW8odGhpcy5idWZmZXJTaXplLHRoaXMuc2FtcGxlUmF0ZSx0aGlzLmJ1ZmZlclNpemUpKSx2b2lkIDAhPT10aGlzLm1lbEZpbHRlckJhbmsmJnRoaXMuYmFya1NjYWxlLmxlbmd0aD09dGhpcy5idWZmZXJTaXplJiZ0aGlzLm1lbEZpbHRlckJhbmsubGVuZ3RoPT10aGlzLm1lbEJhbmRzfHwodGhpcy5tZWxGaWx0ZXJCYW5rPWYoTWF0aC5tYXgodGhpcy5tZWxCYW5kcyx0aGlzLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyksdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLHZvaWQgMCE9PXRoaXMuY2hyb21hRmlsdGVyQmFuayYmdGhpcy5jaHJvbWFGaWx0ZXJCYW5rLmxlbmd0aD09dGhpcy5jaHJvbWFCYW5kc3x8KHRoaXMuY2hyb21hRmlsdGVyQmFuaz1jKHRoaXMuY2hyb21hQmFuZHMsdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLFwiYnVmZmVyXCJpbiB0JiZ2b2lkIDA9PT10LmJ1ZmZlcj90aGlzLnNpZ25hbD1pKHQpOnRoaXMuc2lnbmFsPXQ7dmFyIHU9ayh0LHRoaXMud2luZG93aW5nRnVuY3Rpb24sdGhpcy5idWZmZXJTaXplKTtpZih0aGlzLnNpZ25hbD11LndpbmRvd2VkU2lnbmFsLHRoaXMuY29tcGxleFNwZWN0cnVtPXUuY29tcGxleFNwZWN0cnVtLHRoaXMuYW1wU3BlY3RydW09dS5hbXBTcGVjdHJ1bSxlKXt2YXIgbD1rKGUsdGhpcy53aW5kb3dpbmdGdW5jdGlvbix0aGlzLmJ1ZmZlclNpemUpO3RoaXMucHJldmlvdXNTaWduYWw9bC53aW5kb3dlZFNpZ25hbCx0aGlzLnByZXZpb3VzQ29tcGxleFNwZWN0cnVtPWwuY29tcGxleFNwZWN0cnVtLHRoaXMucHJldmlvdXNBbXBTcGVjdHJ1bT1sLmFtcFNwZWN0cnVtfXZhciBzPWZ1bmN0aW9uKHIpe3JldHVybiBuLmZlYXR1cmVFeHRyYWN0b3JzW3JdKHthbXBTcGVjdHJ1bTpuLmFtcFNwZWN0cnVtLGNocm9tYUZpbHRlckJhbms6bi5jaHJvbWFGaWx0ZXJCYW5rLGNvbXBsZXhTcGVjdHJ1bTpuLmNvbXBsZXhTcGVjdHJ1bSxzaWduYWw6bi5zaWduYWwsYnVmZmVyU2l6ZTpuLmJ1ZmZlclNpemUsc2FtcGxlUmF0ZTpuLnNhbXBsZVJhdGUsYmFya1NjYWxlOm4uYmFya1NjYWxlLG1lbEZpbHRlckJhbms6bi5tZWxGaWx0ZXJCYW5rLHByZXZpb3VzU2lnbmFsOm4ucHJldmlvdXNTaWduYWwscHJldmlvdXNBbXBTcGVjdHJ1bTpuLnByZXZpb3VzQW1wU3BlY3RydW0scHJldmlvdXNDb21wbGV4U3BlY3RydW06bi5wcmV2aW91c0NvbXBsZXhTcGVjdHJ1bSxudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6bi5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMsbnVtYmVyT2ZCYXJrQmFuZHM6bi5udW1iZXJPZkJhcmtCYW5kc30pfTtpZihcIm9iamVjdFwiPT10eXBlb2YgcilyZXR1cm4gci5yZWR1Y2UoKGZ1bmN0aW9uKHIsdCl7dmFyIGU7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sciwoKGU9e30pW3RdPXModCksZSkpfSkse30pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByKXJldHVybiBzKHIpO3Rocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkRmVhdHVyZUZtdH19LGs9ZnVuY3Rpb24ocix0LGUpe3ZhciBhPXt9O3ZvaWQgMD09PXIuYnVmZmVyP2Euc2lnbmFsPWkocik6YS5zaWduYWw9cixhLndpbmRvd2VkU2lnbmFsPW4oYS5zaWduYWwsdCksYS5jb21wbGV4U3BlY3RydW09QShhLndpbmRvd2VkU2lnbmFsKSxhLmFtcFNwZWN0cnVtPW5ldyBGbG9hdDMyQXJyYXkoZS8yKTtmb3IodmFyIG89MDtvPGUvMjtvKyspYS5hbXBTcGVjdHJ1bVtvXT1NYXRoLnNxcnQoTWF0aC5wb3coYS5jb21wbGV4U3BlY3RydW0ucmVhbFtvXSwyKStNYXRoLnBvdyhhLmNvbXBsZXhTcGVjdHJ1bS5pbWFnW29dLDIpKTtyZXR1cm4gYX07cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5NZXlkYT1DKSxDfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV5ZGEubWluLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3VyZmFjZUV4dHJhY3RvclxuXG4vL0hlbHBlciBtYWNyb3NcbmZ1bmN0aW9uIGFycmF5KGkpIHtcbiAgcmV0dXJuIFwiYVwiICsgaVxufVxuZnVuY3Rpb24gZGF0YShpKSB7XG4gIHJldHVybiBcImRcIiArIGlcbn1cbmZ1bmN0aW9uIGN1YmUoaSxiaXRtYXNrKSB7XG4gIHJldHVybiBcImNcIiArIGkgKyBcIl9cIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHNoYXBlKGkpIHtcbiAgcmV0dXJuIFwic1wiICsgaVxufVxuZnVuY3Rpb24gc3RyaWRlKGksaikge1xuICByZXR1cm4gXCJ0XCIgKyBpICsgXCJfXCIgKyBqXG59XG5mdW5jdGlvbiBvZmZzZXQoaSkge1xuICByZXR1cm4gXCJvXCIgKyBpXG59XG5mdW5jdGlvbiBzY2FsYXIoaSkge1xuICByZXR1cm4gXCJ4XCIgKyBpXG59XG5mdW5jdGlvbiBwb2ludGVyKGkpIHtcbiAgcmV0dXJuIFwicFwiICsgaVxufVxuZnVuY3Rpb24gZGVsdGEoaSxiaXRtYXNrKSB7XG4gIHJldHVybiBcImRcIiArIGkgKyBcIl9cIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIGluZGV4KGkpIHtcbiAgcmV0dXJuIFwiaVwiICsgaVxufVxuZnVuY3Rpb24gc3RlcChpLGopIHtcbiAgcmV0dXJuIFwidVwiICsgaSArIFwiX1wiICsgalxufVxuZnVuY3Rpb24gcGN1YmUoYml0bWFzaykge1xuICByZXR1cm4gXCJiXCIgKyBiaXRtYXNrXG59XG5mdW5jdGlvbiBxY3ViZShiaXRtYXNrKSB7XG4gIHJldHVybiBcInlcIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHBkZWx0YShiaXRtYXNrKSB7XG4gIHJldHVybiBcImVcIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHZlcnQoaSkge1xuICByZXR1cm4gXCJ2XCIgKyBpXG59XG52YXIgVkVSVEVYX0lEUyA9IFwiVlwiXG52YXIgUEhBU0VTID0gXCJQXCJcbnZhciBWRVJURVhfQ09VTlQgPSBcIk5cIlxudmFyIFBPT0xfU0laRSA9IFwiUVwiXG52YXIgUE9JTlRFUiA9IFwiWFwiXG52YXIgVEVNUE9SQVJZID0gXCJUXCJcblxuZnVuY3Rpb24gcGVybUJpdG1hc2soZGltZW5zaW9uLCBtYXNrLCBvcmRlcikge1xuICB2YXIgciA9IDBcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBpZihtYXNrICYgKDE8PGkpKSB7XG4gICAgICByIHw9ICgxPDxvcmRlcltpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy9HZW5lcmF0ZXMgdGhlIHN1cmZhY2UgcHJvY2VkdXJlXG5mdW5jdGlvbiBjb21waWxlU3VyZmFjZVByb2NlZHVyZSh2ZXJ0ZXhGdW5jLCBmYWNlRnVuYywgcGhhc2VGdW5jLCBzY2FsYXJBcmdzLCBvcmRlciwgdHlwZXNpZykge1xuICB2YXIgYXJyYXlBcmdzID0gdHlwZXNpZy5sZW5ndGhcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuXG4gIGlmKGRpbWVuc2lvbiA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZGFycmF5LWV4dHJhY3QtY29udG91cjogRGltZW5zaW9uIG11c3QgYmUgYXQgbGVhc3QgMlwiKVxuICB9XG5cbiAgdmFyIGZ1bmNOYW1lID0gXCJleHRyYWN0Q29udG91clwiICsgb3JkZXIuam9pbihcIl9cIilcbiAgdmFyIGNvZGUgPSBbXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciBhcmdzID0gW11cblxuICAvL0Fzc2VtYmxlIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIGFyZ3MucHVzaChhcnJheShpKSkgIFxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHNjYWxhckFyZ3M7ICsraSkge1xuICAgIGFyZ3MucHVzaChzY2FsYXIoaSkpXG4gIH1cblxuICAvL1NoYXBlXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdmFycy5wdXNoKHNoYXBlKGkpICsgXCI9XCIgKyBhcnJheSgwKSArIFwiLnNoYXBlW1wiICsgaSArIFwiXXwwXCIpXG4gIH1cbiAgLy9EYXRhLCBzdHJpZGUsIG9mZnNldCBwb2ludGVyc1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIHZhcnMucHVzaChkYXRhKGkpICsgXCI9XCIgKyBhcnJheShpKSArIFwiLmRhdGFcIixcbiAgICAgICAgICAgICAgb2Zmc2V0KGkpICsgXCI9XCIgKyBhcnJheShpKSArIFwiLm9mZnNldHwwXCIpXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIHZhcnMucHVzaChzdHJpZGUoaSxqKSArIFwiPVwiICsgYXJyYXkoaSkgKyBcIi5zdHJpZGVbXCIgKyBqICsgXCJdfDBcIilcbiAgICB9XG4gIH1cbiAgLy9Qb2ludGVyLCBkZWx0YSBhbmQgY3ViZSB2YXJpYWJsZXNcbiAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICB2YXJzLnB1c2gocG9pbnRlcihpKSArIFwiPVwiICsgb2Zmc2V0KGkpKVxuICAgIHZhcnMucHVzaChjdWJlKGksMCkpXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgdmFyIHB0clN0ciA9IFtdXG4gICAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgICBpZihqICYgKDE8PGspKSB7XG4gICAgICAgICAgcHRyU3RyLnB1c2goXCItXCIgKyBzdHJpZGUoaSxrKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFycy5wdXNoKGRlbHRhKGksaikgKyBcIj0oXCIgKyBwdHJTdHIuam9pbihcIlwiKSArIFwiKXwwXCIpXG4gICAgICB2YXJzLnB1c2goY3ViZShpLGopICsgXCI9MFwiKVxuICAgIH1cbiAgfVxuICAvL0NyZWF0ZSBzdGVwIHZhcmlhYmxlc1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICB2YXIgc3RlcFZhbCA9IFsgc3RyaWRlKGksb3JkZXJbal0pIF1cbiAgICAgIGlmKGogPiAwKSB7XG4gICAgICAgIHN0ZXBWYWwucHVzaChzdHJpZGUoaSwgb3JkZXJbai0xXSkgKyBcIipcIiArIHNoYXBlKG9yZGVyW2otMV0pIClcbiAgICAgIH1cbiAgICAgIHZhcnMucHVzaChzdGVwKGksb3JkZXJbal0pICsgXCI9KFwiICsgc3RlcFZhbC5qb2luKFwiLVwiKSArIFwiKXwwXCIpXG4gICAgfVxuICB9XG4gIC8vQ3JlYXRlIGluZGV4IHZhcmlhYmxlc1xuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHZhcnMucHVzaChpbmRleChpKSArIFwiPTBcIilcbiAgfVxuICAvL1ZlcnRleCBjb3VudFxuICB2YXJzLnB1c2goVkVSVEVYX0NPVU5UICsgXCI9MFwiKVxuICAvL0NvbXB1dGUgcG9vbCBzaXplLCBpbml0aWFsaXplIHBvb2wgc3RlcFxuICB2YXIgc2l6ZVZhcmlhYmxlID0gW1wiMlwiXVxuICBmb3IodmFyIGk9ZGltZW5zaW9uLTI7IGk+PTA7IC0taSkge1xuICAgIHNpemVWYXJpYWJsZS5wdXNoKHNoYXBlKG9yZGVyW2ldKSlcbiAgfVxuICAvL1ByZXZpb3VzIHBoYXNlcyBhbmQgdmVydGV4X2lkc1xuICB2YXJzLnB1c2goUE9PTF9TSVpFICsgXCI9KFwiICsgc2l6ZVZhcmlhYmxlLmpvaW4oXCIqXCIpICsgXCIpfDBcIixcbiAgICAgICAgICAgIFBIQVNFUyArIFwiPW1hbGxvY1VpbnQzMihcIiArIFBPT0xfU0laRSArIFwiKVwiLFxuICAgICAgICAgICAgVkVSVEVYX0lEUyArIFwiPW1hbGxvY1VpbnQzMihcIiArIFBPT0xfU0laRSArIFwiKVwiLFxuICAgICAgICAgICAgUE9JTlRFUiArIFwiPTBcIilcbiAgLy9DcmVhdGUgY3ViZSB2YXJpYWJsZXMgZm9yIHBoYXNlc1xuICB2YXJzLnB1c2gocGN1YmUoMCkgKyBcIj0wXCIpXG4gIGZvcih2YXIgaj0xOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICB2YXIgY3ViZURlbHRhID0gW11cbiAgICB2YXIgY3ViZVN0ZXAgPSBbIF1cbiAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgaWYoaiAmICgxPDxrKSkge1xuICAgICAgICBpZihjdWJlU3RlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjdWJlRGVsdGEucHVzaChcIjFcIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWJlRGVsdGEudW5zaGlmdChjdWJlU3RlcC5qb2luKFwiKlwiKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3ViZVN0ZXAucHVzaChzaGFwZShvcmRlcltrXSkpXG4gICAgfVxuICAgIHZhciBzaWduRmxhZyA9IFwiXCJcbiAgICBpZihjdWJlRGVsdGFbMF0uaW5kZXhPZihzaGFwZShvcmRlcltkaW1lbnNpb24tMl0pKSA8IDApIHtcbiAgICAgIHNpZ25GbGFnID0gXCItXCJcbiAgICB9XG4gICAgdmFyIGpwZXJtID0gcGVybUJpdG1hc2soZGltZW5zaW9uLCBqLCBvcmRlcilcbiAgICB2YXJzLnB1c2gocGRlbHRhKGpwZXJtKSArIFwiPSgtXCIgKyBjdWJlRGVsdGEuam9pbihcIi1cIikgKyBcIil8MFwiLFxuICAgICAgICAgICAgICBxY3ViZShqcGVybSkgKyBcIj0oXCIgKyBzaWduRmxhZyArIGN1YmVEZWx0YS5qb2luKFwiLVwiKSArIFwiKXwwXCIsXG4gICAgICAgICAgICAgIHBjdWJlKGpwZXJtKSArIFwiPTBcIilcbiAgfVxuICB2YXJzLnB1c2godmVydCgwKSArIFwiPTBcIiwgVEVNUE9SQVJZICsgXCI9MFwiKVxuXG4gIGZ1bmN0aW9uIGZvckxvb3BCZWdpbihpLCBzdGFydCkge1xuICAgIGNvZGUucHVzaChcImZvcihcIiwgaW5kZXgob3JkZXJbaV0pLCBcIj1cIiwgc3RhcnQsIFwiO1wiLFxuICAgICAgaW5kZXgob3JkZXJbaV0pLCBcIjxcIiwgc2hhcGUob3JkZXJbaV0pLCBcIjtcIixcbiAgICAgIFwiKytcIiwgaW5kZXgob3JkZXJbaV0pLCBcIil7XCIpXG4gIH1cblxuICBmdW5jdGlvbiBmb3JMb29wRW5kKGkpIHtcbiAgICBmb3IodmFyIGo9MDsgajxhcnJheUFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKHBvaW50ZXIoaiksIFwiKz1cIiwgc3RlcChqLG9yZGVyW2ldKSwgXCI7XCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxFbXB0eVNsaWNlKGspIHtcbiAgICBmb3IodmFyIGk9ay0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIGZvckxvb3BCZWdpbihpLCAwKSBcbiAgICB9XG4gICAgdmFyIHBoYXNlRnVuY0FyZ3MgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgICBpZih0eXBlc2lnW2ldKSB7XG4gICAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChkYXRhKGkpICsgXCIuZ2V0KFwiICsgcG9pbnRlcihpKSArIFwiKVwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGhhc2VGdW5jQXJncy5wdXNoKGRhdGEoaSkgKyBcIltcIiArIHBvaW50ZXIoaSkgKyBcIl1cIilcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8c2NhbGFyQXJnczsgKytpKSB7XG4gICAgICBwaGFzZUZ1bmNBcmdzLnB1c2goc2NhbGFyKGkpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goUEhBU0VTLCBcIltcIiwgUE9JTlRFUiwgXCIrK109cGhhc2UoXCIsIHBoYXNlRnVuY0FyZ3Muam9pbigpLCBcIik7XCIpXG4gICAgZm9yKHZhciBpPTA7IGk8azsgKytpKSB7XG4gICAgICBmb3JMb29wRW5kKGkpXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPGFycmF5QXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocG9pbnRlcihqKSwgXCIrPVwiLCBzdGVwKGosb3JkZXJba10pLCBcIjtcIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzR3JpZENlbGwobWFzaykge1xuICAgIC8vUmVhZCBpbiBsb2NhbCBkYXRhXG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIGlmKHR5cGVzaWdbaV0pIHtcbiAgICAgICAgY29kZS5wdXNoKGN1YmUoaSwwKSwgXCI9XCIsIGRhdGEoaSksIFwiLmdldChcIiwgcG9pbnRlcihpKSwgXCIpO1wiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKGN1YmUoaSwwKSwgXCI9XCIsIGRhdGEoaSksIFwiW1wiLCBwb2ludGVyKGkpLCBcIl07XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9SZWFkIGluIHBoYXNlXG4gICAgdmFyIHBoYXNlRnVuY0FyZ3MgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgICBwaGFzZUZ1bmNBcmdzLnB1c2goY3ViZShpLDApKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxzY2FsYXJBcmdzOyArK2kpIHtcbiAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChzY2FsYXIoaSkpXG4gICAgfVxuICAgIFxuICAgIGNvZGUucHVzaChwY3ViZSgwKSwgXCI9XCIsIFBIQVNFUywgXCJbXCIsIFBPSU5URVIsIFwiXT1waGFzZShcIiwgcGhhc2VGdW5jQXJncy5qb2luKCksIFwiKTtcIilcbiAgICBcbiAgICAvL1JlYWQgaW4gb3RoZXIgY3ViZSBkYXRhXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgY29kZS5wdXNoKHBjdWJlKGopLCBcIj1cIiwgUEhBU0VTLCBcIltcIiwgUE9JTlRFUiwgXCIrXCIsIHBkZWx0YShqKSwgXCJdO1wiKVxuICAgIH1cblxuICAgIC8vQ2hlY2sgZm9yIGJvdW5kYXJ5IGNyb3NzaW5nXG4gICAgdmFyIHZlcnRleFByZWRpY2F0ZSA9IFtdXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgdmVydGV4UHJlZGljYXRlLnB1c2goXCIoXCIgKyBwY3ViZSgwKSArIFwiIT09XCIgKyBwY3ViZShqKSArIFwiKVwiKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJpZihcIiwgdmVydGV4UHJlZGljYXRlLmpvaW4oXCJ8fFwiKSwgXCIpe1wiKVxuXG4gICAgLy9SZWFkIGluIGJvdW5kYXJ5IGRhdGFcbiAgICB2YXIgdmVydGV4QXJncyA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHZlcnRleEFyZ3MucHVzaChpbmRleChpKSlcbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIHZlcnRleEFyZ3MucHVzaChjdWJlKGksMCkpXG4gICAgICBmb3IodmFyIGo9MTsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICAgIGlmKHR5cGVzaWdbaV0pIHtcbiAgICAgICAgICBjb2RlLnB1c2goY3ViZShpLGopLCBcIj1cIiwgZGF0YShpKSwgXCIuZ2V0KFwiLCBwb2ludGVyKGkpLCBcIitcIiwgZGVsdGEoaSxqKSwgXCIpO1wiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUucHVzaChjdWJlKGksaiksIFwiPVwiLCBkYXRhKGkpLCBcIltcIiwgcG9pbnRlcihpKSwgXCIrXCIsIGRlbHRhKGksaiksIFwiXTtcIilcbiAgICAgICAgfVxuICAgICAgICB2ZXJ0ZXhBcmdzLnB1c2goY3ViZShpLGopKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgICB2ZXJ0ZXhBcmdzLnB1c2gocGN1YmUoaSkpXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHNjYWxhckFyZ3M7ICsraSkge1xuICAgICAgdmVydGV4QXJncy5wdXNoKHNjYWxhcihpKSlcbiAgICB9XG5cbiAgICAvL0dlbmVyYXRlIHZlcnRleFxuICAgIGNvZGUucHVzaChcInZlcnRleChcIiwgdmVydGV4QXJncy5qb2luKCksIFwiKTtcIixcbiAgICAgIHZlcnQoMCksIFwiPVwiLCBWRVJURVhfSURTLCBcIltcIiwgUE9JTlRFUiwgXCJdPVwiLCBWRVJURVhfQ09VTlQsIFwiKys7XCIpXG5cbiAgICAvL0NoZWNrIGZvciBmYWNlIGNyb3NzaW5nc1xuICAgIHZhciBiYXNlID0gKDE8PGRpbWVuc2lvbiktMVxuICAgIHZhciBjb3JuZXIgPSBwY3ViZShiYXNlKVxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpZigobWFzayAmIH4oMTw8aikpPT09MCkge1xuICAgICAgICAvL0NoZWNrIGZhY2VcbiAgICAgICAgdmFyIHN1YnNldCA9IGJhc2VeKDE8PGopXG4gICAgICAgIHZhciBlZGdlID0gcGN1YmUoc3Vic2V0KVxuICAgICAgICB2YXIgZmFjZUFyZ3MgPSBbIF1cbiAgICAgICAgZm9yKHZhciBrPXN1YnNldDsgaz4wOyBrPShrLTEpJnN1YnNldCkge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goVkVSVEVYX0lEUyArIFwiW1wiICsgUE9JTlRFUiArIFwiK1wiICsgcGRlbHRhKGspICsgXCJdXCIpXG4gICAgICAgIH1cbiAgICAgICAgZmFjZUFyZ3MucHVzaCh2ZXJ0KDApKVxuICAgICAgICBmb3IodmFyIGs9MDsgazxhcnJheUFyZ3M7ICsraykge1xuICAgICAgICAgIGlmKGomMSkge1xuICAgICAgICAgICAgZmFjZUFyZ3MucHVzaChjdWJlKGssYmFzZSksIGN1YmUoayxzdWJzZXQpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWNlQXJncy5wdXNoKGN1YmUoayxzdWJzZXQpLCBjdWJlKGssYmFzZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGomMSkge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goY29ybmVyLCBlZGdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goZWRnZSwgY29ybmVyKVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaz0wOyBrPHNjYWxhckFyZ3M7ICsraykge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goc2NhbGFyKGspKVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcImlmKFwiLCBjb3JuZXIsIFwiIT09XCIsIGVkZ2UsIFwiKXtcIixcbiAgICAgICAgICBcImZhY2UoXCIsIGZhY2VBcmdzLmpvaW4oKSwgXCIpfVwiKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvL0luY3JlbWVudCBwb2ludGVyLCBjbG9zZSBvZmYgaWYgc3RhdGVtZW50XG4gICAgY29kZS5wdXNoKFwifVwiLFxuICAgICAgUE9JTlRFUiwgXCIrPTE7XCIpXG4gIH1cblxuICBmdW5jdGlvbiBmbGlwKCkge1xuICAgIGZvcih2YXIgaj0xOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChURU1QT1JBUlksIFwiPVwiLCBwZGVsdGEoaiksIFwiO1wiLFxuICAgICAgICAgICAgICAgIHBkZWx0YShqKSwgXCI9XCIsIHFjdWJlKGopLCBcIjtcIixcbiAgICAgICAgICAgICAgICBxY3ViZShqKSwgXCI9XCIsIFRFTVBPUkFSWSwgXCI7XCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9vcChpLCBtYXNrKSB7XG4gICAgaWYoaSA8IDApIHtcbiAgICAgIHByb2Nlc3NHcmlkQ2VsbChtYXNrKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZpbGxFbXB0eVNsaWNlKGkpXG4gICAgY29kZS5wdXNoKFwiaWYoXCIsIHNoYXBlKG9yZGVyW2ldKSwgXCI+MCl7XCIsXG4gICAgICBpbmRleChvcmRlcltpXSksIFwiPTE7XCIpXG4gICAgY3JlYXRlTG9vcChpLTEsIG1hc2t8KDE8PG9yZGVyW2ldKSlcblxuICAgIGZvcih2YXIgaj0wOyBqPGFycmF5QXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocG9pbnRlcihqKSwgXCIrPVwiLCBzdGVwKGosb3JkZXJbaV0pLCBcIjtcIilcbiAgICB9XG4gICAgaWYoaSA9PT0gZGltZW5zaW9uLTEpIHtcbiAgICAgIGNvZGUucHVzaChQT0lOVEVSLCBcIj0wO1wiKVxuICAgICAgZmxpcCgpXG4gICAgfVxuICAgIGZvckxvb3BCZWdpbihpLCAyKVxuICAgIGNyZWF0ZUxvb3AoaS0xLCBtYXNrKVxuICAgIGlmKGkgPT09IGRpbWVuc2lvbi0xKSB7XG4gICAgICBjb2RlLnB1c2goXCJpZihcIiwgaW5kZXgob3JkZXJbZGltZW5zaW9uLTFdKSwgXCImMSl7XCIsXG4gICAgICAgIFBPSU5URVIsIFwiPTA7fVwiKVxuICAgICAgZmxpcCgpXG4gICAgfVxuICAgIGZvckxvb3BFbmQoaSlcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cblxuICBjcmVhdGVMb29wKGRpbWVuc2lvbi0xLCAwKVxuXG4gIC8vUmVsZWFzZSBzY3JhdGNoIG1lbW9yeVxuICBjb2RlLnB1c2goXCJmcmVlVWludDMyKFwiLCBWRVJURVhfSURTLCBcIik7ZnJlZVVpbnQzMihcIiwgUEhBU0VTLCBcIik7XCIpXG5cbiAgLy9Db21waWxlIGFuZCBsaW5rIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlQ29kZSA9IFtcbiAgICBcIid1c2Ugc3RyaWN0JztcIixcbiAgICBcImZ1bmN0aW9uIFwiLCBmdW5jTmFtZSwgXCIoXCIsIGFyZ3Muam9pbigpLCBcIil7XCIsXG4gICAgICBcInZhciBcIiwgdmFycy5qb2luKCksIFwiO1wiLFxuICAgICAgY29kZS5qb2luKFwiXCIpLFxuICAgIFwifVwiLFxuICAgIFwicmV0dXJuIFwiLCBmdW5jTmFtZSBdLmpvaW4oXCJcIilcblxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcbiAgICBcInZlcnRleFwiLCBcbiAgICBcImZhY2VcIiwgXG4gICAgXCJwaGFzZVwiLCBcbiAgICBcIm1hbGxvY1VpbnQzMlwiLCBcbiAgICBcImZyZWVVaW50MzJcIixcbiAgICBwcm9jZWR1cmVDb2RlKVxuICByZXR1cm4gcHJvYyhcbiAgICB2ZXJ0ZXhGdW5jLCBcbiAgICBmYWNlRnVuYywgXG4gICAgcGhhc2VGdW5jLCBcbiAgICBwb29sLm1hbGxvY1VpbnQzMiwgXG4gICAgcG9vbC5mcmVlVWludDMyKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdXJmYWNlRXh0cmFjdG9yKGFyZ3MpIHtcbiAgZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibmRhcnJheS1leHRyYWN0LWNvbnRvdXI6IFwiICsgbXNnKVxuICB9XG4gIGlmKHR5cGVvZiBhcmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgZXJyb3IoXCJNdXN0IHNwZWNpZnkgYXJndW1lbnRzXCIpXG4gIH1cbiAgdmFyIG9yZGVyID0gYXJncy5vcmRlclxuICBpZighQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSBvcmRlclwiKVxuICB9XG4gIHZhciBhcnJheXMgPSBhcmdzLmFycmF5QXJndW1lbnRzfHwxXG4gIGlmKGFycmF5cyA8IDEpIHtcbiAgICBlcnJvcihcIk11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnRcIilcbiAgfVxuICB2YXIgc2NhbGFycyA9IGFyZ3Muc2NhbGFyQXJndW1lbnRzfHwwXG4gIGlmKHNjYWxhcnMgPCAwKSB7XG4gICAgZXJyb3IoXCJTY2FsYXIgYXJnIGNvdW50IG11c3QgYmUgPiAwXCIpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3MudmVydGV4ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSB2ZXJ0ZXggY3JlYXRpb24gZnVuY3Rpb25cIilcbiAgfVxuICBpZih0eXBlb2YgYXJncy5jZWxsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSBjZWxsIGNyZWF0aW9uIGZ1bmN0aW9uXCIpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3MucGhhc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVycm9yKFwiTXVzdCBzcGVjaWZ5IHBoYXNlIGZ1bmN0aW9uXCIpXG4gIH1cbiAgdmFyIGdldHRlcnMgPSBhcmdzLmdldHRlcnMgfHwgW11cbiAgdmFyIHR5cGVzaWcgPSBuZXcgQXJyYXkoYXJyYXlzKVxuICBmb3IodmFyIGk9MDsgaTxhcnJheXM7ICsraSkge1xuICAgIGlmKGdldHRlcnMuaW5kZXhPZihpKSA+PSAwKSB7XG4gICAgICB0eXBlc2lnW2ldID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlc2lnW2ldID0gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGVTdXJmYWNlUHJvY2VkdXJlKFxuICAgIGFyZ3MudmVydGV4LFxuICAgIGFyZ3MuY2VsbCxcbiAgICBhcmdzLnBoYXNlLFxuICAgIHNjYWxhcnMsXG4gICAgb3JkZXIsXG4gICAgdHlwZXNpZylcbn0iLCJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ0ludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ2ludDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJiaWdpbnQ2NFwiOiBbXSxcbiAgXCJiaWd1aW50NjRcIjogW10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgZG91YmxlQml0cyA9IHJlcXVpcmUoXCJkb3VibGUtYml0c1wiKVxuXG52YXIgU01BTExFU1RfREVOT1JNID0gTWF0aC5wb3coMiwgLTEwNzQpXG52YXIgVUlOVF9NQVggPSAoLTEpPj4+MFxuXG5tb2R1bGUuZXhwb3J0cyA9IG5leHRhZnRlclxuXG5mdW5jdGlvbiBuZXh0YWZ0ZXIoeCwgeSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgIHJldHVybiBOYU5cbiAgfVxuICBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZih4ID09PSAwKSB7XG4gICAgaWYoeSA8IDApIHtcbiAgICAgIHJldHVybiAtU01BTExFU1RfREVOT1JNXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTTUFMTEVTVF9ERU5PUk1cbiAgICB9XG4gIH1cbiAgdmFyIGhpID0gZG91YmxlQml0cy5oaSh4KVxuICB2YXIgbG8gPSBkb3VibGVCaXRzLmxvKHgpXG4gIGlmKCh5ID4geCkgPT09ICh4ID4gMCkpIHtcbiAgICBpZihsbyA9PT0gVUlOVF9NQVgpIHtcbiAgICAgIGhpICs9IDFcbiAgICAgIGxvID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBsbyArPSAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmKGxvID09PSAwKSB7XG4gICAgICBsbyA9IFVJTlRfTUFYXG4gICAgICBoaSAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvIC09IDFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvdWJsZUJpdHMucGFjayhsbywgaGkpXG59IiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBwZXJtdXRhdGlvblNpZ25cblxudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiA9IDMyXG5cbnZhciBwb29sID0gcmVxdWlyZShcInR5cGVkYXJyYXktcG9vbFwiKVxuXG5mdW5jdGlvbiBwZXJtdXRhdGlvblNpZ24ocCkge1xuICB2YXIgbiA9IHAubGVuZ3RoXG4gIGlmKG4gPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAvL1VzZSBxdWFkcmF0aWMgYWxnb3JpdGhtIGZvciBzbWFsbCBuXG4gICAgdmFyIHNnbiA9IDFcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIGZvcih2YXIgaj0wOyBqPGk7ICsraikge1xuICAgICAgICBpZihwW2ldIDwgcFtqXSkge1xuICAgICAgICAgIHNnbiA9IC1zZ25cbiAgICAgICAgfSBlbHNlIGlmKHBbaV0gPT09IHBbal0pIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZ25cbiAgfSBlbHNlIHtcbiAgICAvL090aGVyd2lzZSB1c2UgbGluZWFyIHRpbWUgYWxnb3JpdGhtXG4gICAgdmFyIHZpc2l0ZWQgPSBwb29sLm1hbGxvY1VpbnQ4KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICB2aXNpdGVkW2ldID0gMFxuICAgIH1cbiAgICB2YXIgc2duID0gMVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgaWYoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMVxuICAgICAgICB2aXNpdGVkW2ldID0gMVxuICAgICAgICBmb3IodmFyIGo9cFtpXTsgaiE9PWk7IGo9cFtqXSkge1xuICAgICAgICAgIGlmKHZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVVpbnQ4KHZpc2l0ZWQpXG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgdmlzaXRlZFtqXSA9IDFcbiAgICAgICAgfVxuICAgICAgICBpZighKGNvdW50ICYgMSkpIHtcbiAgICAgICAgICBzZ24gPSAtc2duXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9vbC5mcmVlVWludDgodmlzaXRlZClcbiAgICByZXR1cm4gc2duXG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcG9vbCA9IHJlcXVpcmUoXCJ0eXBlZGFycmF5LXBvb2xcIilcbnZhciBpbnZlcnNlID0gcmVxdWlyZShcImludmVydC1wZXJtdXRhdGlvblwiKVxuXG5mdW5jdGlvbiByYW5rKHBlcm11dGF0aW9uKSB7XG4gIHZhciBuID0gcGVybXV0YXRpb24ubGVuZ3RoXG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAwXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBlcm11dGF0aW9uWzFdXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrXG4gIH1cbiAgdmFyIHAgPSBwb29sLm1hbGxvY1VpbnQzMihuKVxuICB2YXIgcGludiA9IHBvb2wubWFsbG9jVWludDMyKG4pXG4gIHZhciByID0gMCwgcywgdCwgaVxuICBpbnZlcnNlKHBlcm11dGF0aW9uLCBwaW52KVxuICBmb3IoaT0wOyBpPG47ICsraSkge1xuICAgIHBbaV0gPSBwZXJtdXRhdGlvbltpXVxuICB9XG4gIGZvcihpPW4tMTsgaT4wOyAtLWkpIHtcbiAgICB0ID0gcGludltpXVxuICAgIHMgPSBwW2ldXG4gICAgcFtpXSA9IHBbdF1cbiAgICBwW3RdID0gc1xuICAgIHBpbnZbaV0gPSBwaW52W3NdXG4gICAgcGludltzXSA9IHRcbiAgICByID0gKHIgKyBzKSAqIGlcbiAgfVxuICBwb29sLmZyZWVVaW50MzIocGludilcbiAgcG9vbC5mcmVlVWludDMyKHApXG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIHVucmFuayhuLCByLCBwKSB7XG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYocCkgeyByZXR1cm4gcCB9XG4gICAgICByZXR1cm4gW11cbiAgICBjYXNlIDE6XG4gICAgICBpZihwKSB7XG4gICAgICAgIHBbMF0gPSAwXG4gICAgICAgIHJldHVybiBwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzBdXG4gICAgICB9XG4gICAgY2FzZSAyOlxuICAgICAgaWYocCkge1xuICAgICAgICBpZihyKSB7XG4gICAgICAgICAgcFswXSA9IDBcbiAgICAgICAgICBwWzFdID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBbMF0gPSAxXG4gICAgICAgICAgcFsxXSA9IDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHIgPyBbMCwxXSA6IFsxLDBdXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrXG4gIH1cbiAgcCA9IHAgfHwgbmV3IEFycmF5KG4pXG4gIHZhciBzLCB0LCBpLCBuZj0xXG4gIHBbMF0gPSAwXG4gIGZvcihpPTE7IGk8bjsgKytpKSB7XG4gICAgcFtpXSA9IGlcbiAgICBuZiA9IChuZippKXwwXG4gIH1cbiAgZm9yKGk9bi0xOyBpPjA7IC0taSkge1xuICAgIHMgPSAociAvIG5mKXwwXG4gICAgciA9IChyIC0gcyAqIG5mKXwwXG4gICAgbmYgPSAobmYgLyBpKXwwXG4gICAgdCA9IHBbaV18MFxuICAgIHBbaV0gPSBwW3NdfDBcbiAgICBwW3NdID0gdHwwXG4gIH1cbiAgcmV0dXJuIHBcbn1cblxuZXhwb3J0cy5yYW5rID0gcmFua1xuZXhwb3J0cy51bnJhbmsgPSB1bnJhbmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbmFyRHVhbFxuXG52YXIgY29tcGFyZUFuZ2xlID0gcmVxdWlyZShcImNvbXBhcmUtYW5nbGVcIilcblxuZnVuY3Rpb24gcGxhbmFyRHVhbChjZWxscywgcG9zaXRpb25zKSB7XG5cbiAgdmFyIG51bVZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aHwwXG4gIHZhciBudW1FZGdlcyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgYWRqID0gW25ldyBBcnJheShudW1WZXJ0aWNlcyksIG5ldyBBcnJheShudW1WZXJ0aWNlcyldXG4gIGZvcih2YXIgaT0wOyBpPG51bVZlcnRpY2VzOyArK2kpIHtcbiAgICBhZGpbMF1baV0gPSBbXVxuICAgIGFkalsxXVtpXSA9IFtdXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bnVtRWRnZXM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBhZGpbMF1bY1swXV0ucHVzaChjKVxuICAgIGFkalsxXVtjWzFdXS5wdXNoKGMpXG4gIH1cblxuICB2YXIgY3ljbGVzID0gW11cblxuICAvL0FkZCBpc29sYXRlZCB2ZXJ0aWNlcyBhcyB0cml2aWFsIGNhc2VcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGlmKGFkalswXVtpXS5sZW5ndGggKyBhZGpbMV1baV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBjeWNsZXMucHVzaCggW2ldIClcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhIGhhbGYgZWRnZVxuICBmdW5jdGlvbiBjdXQoYywgaSkge1xuICAgIHZhciBhID0gYWRqW2ldW2NbaV1dXG4gICAgYS5zcGxpY2UoYS5pbmRleE9mKGMpLCAxKVxuICB9XG5cbiAgLy9GaW5kIG5leHQgdmVydGV4IGFuZCBjdXQgZWRnZVxuICBmdW5jdGlvbiBuZXh0KGEsIGIsIG5vQ3V0KSB7XG4gICAgdmFyIG5leHRDZWxsLCBuZXh0VmVydGV4LCBuZXh0RGlyXG4gICAgZm9yKHZhciBpPTA7IGk8MjsgKytpKSB7XG4gICAgICBpZihhZGpbaV1bYl0ubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0Q2VsbCA9IGFkaltpXVtiXVswXVxuICAgICAgICBuZXh0RGlyID0gaVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBuZXh0VmVydGV4ID0gbmV4dENlbGxbbmV4dERpcl4xXVxuXG4gICAgZm9yKHZhciBkaXI9MDsgZGlyPDI7ICsrZGlyKSB7XG4gICAgICB2YXIgbmJoZCA9IGFkaltkaXJdW2JdXG4gICAgICBmb3IodmFyIGs9MDsgazxuYmhkLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIHZhciBlID0gbmJoZFtrXVxuICAgICAgICB2YXIgcCA9IGVbZGlyXjFdXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlQW5nbGUoXG4gICAgICAgICAgICBwb3NpdGlvbnNbYV0sIFxuICAgICAgICAgICAgcG9zaXRpb25zW2JdLCBcbiAgICAgICAgICAgIHBvc2l0aW9uc1tuZXh0VmVydGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uc1twXSlcbiAgICAgICAgaWYoY21wID4gMCkge1xuICAgICAgICAgIG5leHRDZWxsID0gZVxuICAgICAgICAgIG5leHRWZXJ0ZXggPSBwXG4gICAgICAgICAgbmV4dERpciA9IGRpclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG5vQ3V0KSB7XG4gICAgICByZXR1cm4gbmV4dFZlcnRleFxuICAgIH1cbiAgICBpZihuZXh0Q2VsbCkge1xuICAgICAgY3V0KG5leHRDZWxsLCBuZXh0RGlyKVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFZlcnRleFxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdEN5Y2xlKHYsIGRpcikge1xuICAgIHZhciBlMCA9IGFkaltkaXJdW3ZdWzBdXG4gICAgdmFyIGN5Y2xlID0gW3ZdXG4gICAgY3V0KGUwLCBkaXIpXG4gICAgdmFyIHUgPSBlMFtkaXJeMV1cbiAgICB2YXIgZDAgPSBkaXJcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB3aGlsZSh1ICE9PSB2KSB7XG4gICAgICAgIGN5Y2xlLnB1c2godSlcbiAgICAgICAgdSA9IG5leHQoY3ljbGVbY3ljbGUubGVuZ3RoLTJdLCB1LCBmYWxzZSlcbiAgICAgIH1cbiAgICAgIGlmKGFkalswXVt2XS5sZW5ndGggKyBhZGpbMV1bdl0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB2YXIgYSA9IGN5Y2xlW2N5Y2xlLmxlbmd0aC0xXVxuICAgICAgdmFyIGIgPSB2XG4gICAgICB2YXIgYyA9IGN5Y2xlWzFdXG4gICAgICB2YXIgZCA9IG5leHQoYSwgYiwgdHJ1ZSlcbiAgICAgIGlmKGNvbXBhcmVBbmdsZShwb3NpdGlvbnNbYV0sIHBvc2l0aW9uc1tiXSwgcG9zaXRpb25zW2NdLCBwb3NpdGlvbnNbZF0pIDwgMCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY3ljbGUucHVzaCh2KVxuICAgICAgdSA9IG5leHQoYSwgYilcbiAgICB9XG4gICAgcmV0dXJuIGN5Y2xlXG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRHbHVlKHBjeWNsZSwgbmN5Y2xlKSB7XG4gICAgcmV0dXJuIChuY3ljbGVbMV0gPT09IG5jeWNsZVtuY3ljbGUubGVuZ3RoLTFdKVxuICB9XG5cbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGZvcih2YXIgaj0wOyBqPDI7ICsraikge1xuICAgICAgdmFyIHBjeWNsZSA9IFtdXG4gICAgICB3aGlsZShhZGpbal1baV0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbmkgPSBhZGpbMF1baV0ubGVuZ3RoXG4gICAgICAgIHZhciBuY3ljbGUgPSBleHRyYWN0Q3ljbGUoaSxqKVxuICAgICAgICBpZihzaG91bGRHbHVlKHBjeWNsZSwgbmN5Y2xlKSkge1xuICAgICAgICAgIC8vR2x1ZSB0b2dldGhlciB0cml2aWFsIGN5Y2xlc1xuICAgICAgICAgIHBjeWNsZS5wdXNoLmFwcGx5KHBjeWNsZSwgbmN5Y2xlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKHBjeWNsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjeWNsZXMucHVzaChwY3ljbGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHBjeWNsZSA9IG5jeWNsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihwY3ljbGUubGVuZ3RoID4gMCkge1xuICAgICAgICBjeWNsZXMucHVzaChwY3ljbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9Db21iaW5lIHBhdGhzIGFuZCBsb29wcyB0b2dldGhlclxuICByZXR1cm4gY3ljbGVzXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbUxlYXZlc1xuXG52YXIgZTJhID0gcmVxdWlyZSgnZWRnZXMtdG8tYWRqYWNlbmN5LWxpc3QnKVxuXG5mdW5jdGlvbiB0cmltTGVhdmVzKGVkZ2VzLCBwb3NpdGlvbnMpIHtcbiAgdmFyIGFkaiA9IGUyYShlZGdlcywgcG9zaXRpb25zLmxlbmd0aClcbiAgdmFyIGxpdmUgPSBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aClcbiAgdmFyIG5iaGQgPSBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aClcblxuICB2YXIgZGVhZCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb3VudCA9IGFkaltpXS5sZW5ndGhcbiAgICBuYmhkW2ldID0gY291bnRcbiAgICBsaXZlW2ldID0gdHJ1ZVxuICAgIGlmKGNvdW50IDw9IDEpIHtcbiAgICAgIGRlYWQucHVzaChpKVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlKGRlYWQubGVuZ3RoID4gMCkge1xuICAgIHZhciB2ID0gZGVhZC5wb3AoKVxuICAgIGxpdmVbdl0gPSBmYWxzZVxuICAgIHZhciBuID0gYWRqW3ZdXG4gICAgZm9yKHZhciBpPTA7IGk8bi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHUgPSBuW2ldXG4gICAgICBpZigtLW5iaGRbdV0gPT09IDApIHtcbiAgICAgICAgZGVhZC5wdXNoKHUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0luZGV4ID0gbmV3IEFycmF5KHBvc2l0aW9ucy5sZW5ndGgpXG4gIHZhciBucG9zaXRpb25zID0gW11cbiAgZm9yKHZhciBpPTA7IGk8cG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgaWYobGl2ZVtpXSkge1xuICAgICAgdmFyIHYgPSBucG9zaXRpb25zLmxlbmd0aFxuICAgICAgbmV3SW5kZXhbaV0gPSB2XG4gICAgICBucG9zaXRpb25zLnB1c2gocG9zaXRpb25zW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdJbmRleFtpXSA9IC0xXG4gICAgfVxuICB9XG5cbiAgdmFyIG5lZGdlcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGlmKGxpdmVbZVswXV0gJiYgbGl2ZVtlWzFdXSkge1xuICAgICAgbmVkZ2VzLnB1c2goWyBuZXdJbmRleFtlWzBdXSwgbmV3SW5kZXhbZVsxXV0gXSlcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBbIG5lZGdlcywgbnBvc2l0aW9ucyBdXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbmFyR3JhcGhUb1BvbHlsaW5lXG5cbnZhciBlMmEgPSByZXF1aXJlKCdlZGdlcy10by1hZGphY2VuY3ktbGlzdCcpXG52YXIgcGxhbmFyRHVhbCA9IHJlcXVpcmUoJ3BsYW5hci1kdWFsJylcbnZhciBwcmVwcm9jZXNzUG9seWdvbiA9IHJlcXVpcmUoJ3BvaW50LWluLWJpZy1wb2x5Z29uJylcbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZSgndHdvLXByb2R1Y3QnKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoJ3JvYnVzdC1zdW0nKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcbnZhciB0cmltTGVhdmVzID0gcmVxdWlyZSgnLi9saWIvdHJpbS1sZWF2ZXMnKVxuXG5mdW5jdGlvbiBtYWtlQXJyYXkobGVuZ3RoLCBmaWxsKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGZpbGxcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1ha2VBcnJheU9mQXJyYXlzKGxlbmd0aCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBbXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuXG5mdW5jdGlvbiBwbGFuYXJHcmFwaFRvUG9seWxpbmUoZWRnZXMsIHBvc2l0aW9ucykge1xuXG4gIC8vVHJpbSBsZWF2ZXNcbiAgdmFyIHJlc3VsdCA9IHRyaW1MZWF2ZXMoZWRnZXMsIHBvc2l0aW9ucylcbiAgZWRnZXMgPSByZXN1bHRbMF1cbiAgcG9zaXRpb25zID0gcmVzdWx0WzFdXG5cbiAgdmFyIG51bVZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aFxuICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGhcblxuICAvL0NhbGN1bGF0ZSBhZGphY2VuY3kgbGlzdCwgY2hlY2sgbWFuaWZvbGRcbiAgdmFyIGFkaiA9IGUyYShlZGdlcywgcG9zaXRpb25zLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGlmKGFkaltpXS5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsYW5hci1ncmFwaC10by1wb2x5bGluZTogZ3JhcGggbXVzdCBiZSBtYW5pZm9sZCcpXG4gICAgfVxuICB9XG5cbiAgLy9HZXQgZmFjZXNcbiAgdmFyIGZhY2VzID0gcGxhbmFyRHVhbChlZGdlcywgcG9zaXRpb25zKVxuXG4gIC8vQ2hlY2sgb3JpZW50YXRpb24gb2YgYSBwb2x5Z29uIHVzaW5nIGV4YWN0IGFyaXRobWV0aWNcbiAgZnVuY3Rpb24gY2N3KGMpIHtcbiAgICB2YXIgbiA9IGMubGVuZ3RoXG4gICAgdmFyIGFyZWEgPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxuOyArK2opIHtcbiAgICAgIHZhciBhID0gcG9zaXRpb25zW2Nbal1dXG4gICAgICB2YXIgYiA9IHBvc2l0aW9uc1tjWyhqKzEpJW5dXVxuICAgICAgdmFyIHQwMCA9IHR3b1Byb2R1Y3QoLWFbMF0sIGFbMV0pXG4gICAgICB2YXIgdDAxID0gdHdvUHJvZHVjdCgtYVswXSwgYlsxXSlcbiAgICAgIHZhciB0MTAgPSB0d29Qcm9kdWN0KCBiWzBdLCBhWzFdKVxuICAgICAgdmFyIHQxMSA9IHR3b1Byb2R1Y3QoIGJbMF0sIGJbMV0pXG4gICAgICBhcmVhID0gcm9idXN0U3VtKGFyZWEsIHJvYnVzdFN1bShyb2J1c3RTdW0odDAwLCB0MDEpLCByb2J1c3RTdW0odDEwLCB0MTEpKSlcbiAgICB9XG4gICAgcmV0dXJuIGFyZWFbYXJlYS5sZW5ndGgtMV0gPiAwXG4gIH1cblxuICAvL0V4dHJhY3QgYWxsIGNsb2Nrd2lzZSBmYWNlc1xuICBmYWNlcyA9IGZhY2VzLmZpbHRlcihjY3cpXG5cbiAgLy9EZXRlY3Qgd2hpY2ggbG9vcHMgYXJlIGNvbnRhaW5lZCBpbiBvbmUgYW5vdGhlciB0byBoYW5kbGUgcGFyZW50LW9mIHJlbGF0aW9uXG4gIHZhciBudW1GYWNlcyA9IGZhY2VzLmxlbmd0aFxuICB2YXIgcGFyZW50ID0gbmV3IEFycmF5KG51bUZhY2VzKVxuICB2YXIgY29udGFpbm1lbnQgPSBuZXcgQXJyYXkobnVtRmFjZXMpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICBwYXJlbnRbaV0gPSBpXG4gICAgdmFyIHJvdyA9IG5ldyBBcnJheShudW1GYWNlcylcbiAgICB2YXIgbG9vcFZlcnRpY2VzID0gZmFjZXNbaV0ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbnNbdl1cbiAgICB9KVxuICAgIHZhciBwbWMgPSBwcmVwcm9jZXNzUG9seWdvbihbbG9vcFZlcnRpY2VzXSlcbiAgICB2YXIgY291bnQgPSAwXG4gICAgb3V0ZXI6XG4gICAgZm9yKHZhciBqPTA7IGo8bnVtRmFjZXM7ICsraikge1xuICAgICAgcm93W2pdID0gMFxuICAgICAgaWYoaSA9PT0gaikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIGMgPSBmYWNlc1tqXVxuICAgICAgdmFyIG4gPSBjLmxlbmd0aFxuICAgICAgZm9yKHZhciBrPTA7IGs8bjsgKytrKSB7XG4gICAgICAgIHZhciBkID0gcG1jKHBvc2l0aW9uc1tjW2tdXSlcbiAgICAgICAgaWYoZCAhPT0gMCkge1xuICAgICAgICAgIGlmKGQgPCAwKSB7XG4gICAgICAgICAgICByb3dbal0gPSAxXG4gICAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlIG91dGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvd1tqXSA9IDFcbiAgICAgIGNvdW50ICs9IDFcbiAgICB9XG4gICAgY29udGFpbm1lbnRbaV0gPSBbY291bnQsIGksIHJvd11cbiAgfVxuICBjb250YWlubWVudC5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBiWzBdIC0gYVswXVxuICB9KVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgdmFyIHJvdyA9IGNvbnRhaW5tZW50W2ldXG4gICAgdmFyIGlkeCA9IHJvd1sxXVxuICAgIHZhciBjaGlsZHJlbiA9IHJvd1syXVxuICAgIGZvcih2YXIgaj0wOyBqPG51bUZhY2VzOyArK2opIHtcbiAgICAgIGlmKGNoaWxkcmVuW2pdKSB7XG4gICAgICAgIHBhcmVudFtqXSA9IGlkeFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vSW5pdGlhbGl6ZSBmYWNlIGFkamFjZW5jeSBsaXN0XG4gIHZhciBmYWRqID0gbWFrZUFycmF5T2ZBcnJheXMobnVtRmFjZXMpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICBmYWRqW2ldLnB1c2gocGFyZW50W2ldKVxuICAgIGZhZGpbcGFyZW50W2ldXS5wdXNoKGkpXG4gIH1cblxuICAvL0J1aWxkIGFkamFjZW5jeSBtYXRyaXggZm9yIGVkZ2VzXG4gIHZhciBlZGdlQWRqYWNlbmN5ID0ge31cbiAgdmFyIGludGVybmFsVmVydGljZXMgPSBtYWtlQXJyYXkobnVtVmVydGljZXMsIGZhbHNlKVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgdmFyIGMgPSBmYWNlc1tpXVxuICAgIHZhciBuID0gYy5sZW5ndGhcbiAgICBmb3IodmFyIGo9MDsgajxuOyArK2opIHtcbiAgICAgIHZhciBhID0gY1tqXVxuICAgICAgdmFyIGIgPSBjWyhqKzEpJW5dXG4gICAgICB2YXIga2V5ID0gTWF0aC5taW4oYSxiKSArIFwiOlwiICsgTWF0aC5tYXgoYSxiKVxuICAgICAgaWYoa2V5IGluIGVkZ2VBZGphY2VuY3kpIHtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gZWRnZUFkamFjZW5jeVtrZXldXG4gICAgICAgIGZhZGpbbmVpZ2hib3JdLnB1c2goaSlcbiAgICAgICAgZmFkaltpXS5wdXNoKG5laWdoYm9yKVxuICAgICAgICBpbnRlcm5hbFZlcnRpY2VzW2FdID0gaW50ZXJuYWxWZXJ0aWNlc1tiXSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VBZGphY2VuY3lba2V5XSA9IGlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRCb3VuZGFyeShjKSB7XG4gICAgdmFyIG4gPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgaWYoIWludGVybmFsVmVydGljZXNbY1tpXV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgdG9WaXNpdCA9IFtdXG4gIHZhciBwYXJpdHkgPSBtYWtlQXJyYXkobnVtRmFjZXMsIC0xKVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgaWYocGFyZW50W2ldID09PSBpICYmICFzaGFyZWRCb3VuZGFyeShmYWNlc1tpXSkpIHtcbiAgICAgIHRvVmlzaXQucHVzaChpKVxuICAgICAgcGFyaXR5W2ldID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJpdHlbaV0gPSAtMVxuICAgIH1cbiAgfVxuXG4gIC8vVXNpbmcgZmFjZSBhZGphY2VuY3ksIGNsYXNzaWZ5IGZhY2VzIGFzIGluL291dFxuICB2YXIgcmVzdWx0ID0gW11cbiAgd2hpbGUodG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRvcCA9IHRvVmlzaXQucG9wKClcbiAgICB2YXIgbmJoZCA9IGZhZGpbdG9wXVxuICAgIHVuaXEobmJoZCwgZnVuY3Rpb24oYSxiKSB7XG4gICAgICByZXR1cm4gYS1iXG4gICAgfSlcbiAgICB2YXIgbm5iaHIgPSBuYmhkLmxlbmd0aFxuICAgIHZhciBwID0gcGFyaXR5W3RvcF1cbiAgICB2YXIgcG9seWxpbmVcbiAgICBpZihwID09PSAwKSB7XG4gICAgICB2YXIgYyA9IGZhY2VzW3RvcF1cbiAgICAgIHBvbHlsaW5lID0gW2NdXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPG5uYmhyOyArK2kpIHtcbiAgICAgIHZhciBmID0gbmJoZFtpXVxuICAgICAgaWYocGFyaXR5W2ZdID49IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHBhcml0eVtmXSA9IHBeMVxuICAgICAgdG9WaXNpdC5wdXNoKGYpXG4gICAgICBpZihwID09PSAwKSB7XG4gICAgICAgIHZhciBjID0gZmFjZXNbZl1cbiAgICAgICAgaWYoIXNoYXJlZEJvdW5kYXJ5KGMpKSB7XG4gICAgICAgICAgYy5yZXZlcnNlKClcbiAgICAgICAgICBwb2x5bGluZS5wdXNoKGMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYocCA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2gocG9seWxpbmUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIm1vZHVsZS5leHBvcnRzID0gcHJlcHJvY2Vzc1BvbHlnb25cblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG52YXIgbWFrZVNsYWJzID0gcmVxdWlyZSgnc2xhYi1kZWNvbXBvc2l0aW9uJylcbnZhciBtYWtlSW50ZXJ2YWxUcmVlID0gcmVxdWlyZSgnaW50ZXJ2YWwtdHJlZS0xZCcpXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxuZnVuY3Rpb24gdmlzaXRJbnRlcnZhbCgpIHtcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW50ZXJ2YWxTZWFyY2godGFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdHJlZSA9IHRhYmxlW3hdXG4gICAgaWYodHJlZSkge1xuICAgICAgcmV0dXJuICEhdHJlZS5xdWVyeVBvaW50KHksIHZpc2l0SW50ZXJ2YWwpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmVydGljYWxJbmRleChzZWdtZW50cykge1xuICB2YXIgdGFibGUgPSB7fVxuICBmb3IodmFyIGk9MDsgaTxzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzID0gc2VnbWVudHNbaV1cbiAgICB2YXIgeCA9IHNbMF1bMF1cbiAgICB2YXIgeTAgPSBzWzBdWzFdXG4gICAgdmFyIHkxID0gc1sxXVsxXVxuICAgIHZhciBwID0gWyBNYXRoLm1pbih5MCwgeTEpLCBNYXRoLm1heCh5MCwgeTEpIF1cbiAgICBpZih4IGluIHRhYmxlKSB7XG4gICAgICB0YWJsZVt4XS5wdXNoKHApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlW3hdID0gWyBwIF1cbiAgICB9XG4gIH1cbiAgdmFyIGludGVydmFsVGFibGUgPSB7fVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRhYmxlKVxuICBmb3IodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHNlZ3MgPSB0YWJsZVtrZXlzW2ldXVxuICAgIGludGVydmFsVGFibGVba2V5c1tpXV0gPSBtYWtlSW50ZXJ2YWxUcmVlKHNlZ3MpXG4gIH1cbiAgcmV0dXJuIGludGVydmFsU2VhcmNoKGludGVydmFsVGFibGUpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2xhYlNlYXJjaChzbGFicywgY29vcmRpbmF0ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgYnVja2V0ID0gYnNlYXJjaC5sZShjb29yZGluYXRlcywgcFswXSlcbiAgICBpZihidWNrZXQgPCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICB2YXIgcm9vdCA9IHNsYWJzW2J1Y2tldF1cbiAgICBpZighcm9vdCkge1xuICAgICAgaWYoYnVja2V0ID4gMCAmJiBjb29yZGluYXRlc1tidWNrZXRdID09PSBwWzBdKSB7XG4gICAgICAgIHJvb3QgPSBzbGFic1tidWNrZXQtMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsYXN0T3JpZW50YXRpb24gPSAxXG4gICAgd2hpbGUocm9vdCkge1xuICAgICAgdmFyIHMgPSByb290LmtleVxuICAgICAgdmFyIG8gPSBvcmllbnQocCwgc1swXSwgc1sxXSlcbiAgICAgIGlmKHNbMF1bMF0gPCBzWzFdWzBdKSB7XG4gICAgICAgIGlmKG8gPCAwKSB7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubGVmdFxuICAgICAgICB9IGVsc2UgaWYobyA+IDApIHtcbiAgICAgICAgICBsYXN0T3JpZW50YXRpb24gPSAtMVxuICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgICByb290ID0gcm9vdC5sZWZ0XG4gICAgICAgIH0gZWxzZSBpZihvIDwgMCkge1xuICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IDFcbiAgICAgICAgICByb290ID0gcm9vdC5yaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhc3RPcmllbnRhdGlvblxuICB9XG59XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5RW1wdHkocCkge1xuICByZXR1cm4gMVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc2lmeVZlcnRpY2FsKHRlc3RWZXJ0aWNhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gY2xhc3NpZnkocCkge1xuICAgIGlmKHRlc3RWZXJ0aWNhbChwWzBdLCBwWzFdKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIDFcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc2lmeVBvaW50RGVnZW4odGVzdFZlcnRpY2FsLCB0ZXN0Tm9ybWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjbGFzc2lmeShwKSB7XG4gICAgaWYodGVzdFZlcnRpY2FsKHBbMF0sIHBbMV0pKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICByZXR1cm4gdGVzdE5vcm1hbChwKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NQb2x5Z29uKGxvb3BzKSB7XG4gIC8vQ29tcHV0ZSBudW1iZXIgb2YgbG9vcHNcbiAgdmFyIG51bUxvb3BzID0gbG9vcHMubGVuZ3RoXG5cbiAgLy9VbnBhY2sgc2VnbWVudHNcbiAgdmFyIHNlZ21lbnRzID0gW11cbiAgdmFyIHZzZWdtZW50cyA9IFtdXG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG51bUxvb3BzOyArK2kpIHtcbiAgICB2YXIgbG9vcCA9IGxvb3BzW2ldXG4gICAgdmFyIG51bVZlcnRpY2VzID0gbG9vcC5sZW5ndGhcbiAgICBmb3IodmFyIHM9bnVtVmVydGljZXMtMSx0PTA7IHQ8bnVtVmVydGljZXM7IHM9KHQrKykpIHtcbiAgICAgIHZhciBhID0gbG9vcFtzXVxuICAgICAgdmFyIGIgPSBsb29wW3RdXG4gICAgICBpZihhWzBdID09PSBiWzBdKSB7XG4gICAgICAgIHZzZWdtZW50cy5wdXNoKFthLGJdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChbYSxiXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0RlZ2VuZXJhdGUgY2FzZTogQWxsIGxvb3BzIGFyZSBlbXB0eVxuICBpZihzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZih2c2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2xhc3NpZnlFbXB0eVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ2xhc3NpZnlWZXJ0aWNhbChidWlsZFZlcnRpY2FsSW5kZXgodnNlZ21lbnRzKSlcbiAgICB9XG4gIH1cblxuICAvL0J1aWxkIHNsYWIgZGVjb21wb3NpdGlvblxuICB2YXIgc2xhYnMgPSBtYWtlU2xhYnMoc2VnbWVudHMpXG4gIHZhciB0ZXN0U2xhYiA9IGJ1aWxkU2xhYlNlYXJjaChzbGFicy5zbGFicywgc2xhYnMuY29vcmRpbmF0ZXMpXG5cbiAgaWYodnNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0ZXN0U2xhYlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVDbGFzc2lmeVBvaW50RGVnZW4oXG4gICAgICBidWlsZFZlcnRpY2FsSW5kZXgodnNlZ21lbnRzKSxcbiAgICAgIHRlc3RTbGFiKVxuICB9XG59IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBub3cgPSByZXF1aXJlKCdyaWdodC1ub3cnKVxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpXG5cbm1vZHVsZS5leHBvcnRzID0gRW5naW5lXG5mdW5jdGlvbiBFbmdpbmUoZm4pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRW5naW5lKSkgXG4gICAgICAgIHJldHVybiBuZXcgRW5naW5lKGZuKVxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IDBcbiAgICB0aGlzLl90aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcylcblxuICAgIGlmIChmbilcbiAgICAgICAgdGhpcy5vbigndGljaycsIGZuKVxufVxuXG5pbmhlcml0cyhFbmdpbmUsIEV2ZW50RW1pdHRlcilcblxuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIFxuICAgICAgICByZXR1cm5cbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IHJhZih0aGlzLl90aWNrKVxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2ZyYW1lICE9PSAwKVxuICAgICAgICByYWYuY2FuY2VsKHRoaXMuX2ZyYW1lKVxuICAgIHRoaXMuX2ZyYW1lID0gMFxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZyYW1lID0gcmFmKHRoaXMuX3RpY2spXG4gICAgdmFyIHRpbWUgPSBub3coKVxuICAgIHZhciBkdCA9IHRpbWUgLSB0aGlzLmxhc3RcbiAgICB0aGlzLmVtaXQoJ3RpY2snLCBkdClcbiAgICB0aGlzLmxhc3QgPSB0aW1lXG59IiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5hZGQgPSByZXF1aXJlKCdiaWctcmF0L2FkZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbmZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gIHZhciByID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByW2ldID0gYm5hZGQoYVtpXSwgYltpXSlcbiAgfVxuICByZXR1cm4gclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmxvYXQycmF0XG5cbnZhciByYXQgPSByZXF1aXJlKCdiaWctcmF0JylcblxuZnVuY3Rpb24gZmxvYXQycmF0KHYpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2Lmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8di5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHJhdCh2W2ldKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0ID0gcmVxdWlyZSgnYmlnLXJhdCcpXG52YXIgbXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHNcblxuZnVuY3Rpb24gbXVscyhhLCB4KSB7XG4gIHZhciBzID0gcmF0KHgpXG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IG11bChhW2ldLCBzKVxuICB9XG4gIHJldHVybiByXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJuc3ViID0gcmVxdWlyZSgnYmlnLXJhdC9zdWInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YlxuXG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gIHZhciByID0gbmV3IEFycmF5KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IGJuc3ViKGFbaV0sIGJbaV0pXG4gIH1cbiAgcmV0dXJuIHJcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbC5jcmVhdGVSRUdMID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIChcbiAgICB4IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgKVxufVxuXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGJhc2UsIG9wdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBiYXNlW2tleXNbaV1dID0gb3B0c1trZXlzW2ldXVxuICB9XG4gIHJldHVybiBiYXNlXG59XG5cbi8vIEVycm9yIGNoZWNraW5nIGFuZCBwYXJhbWV0ZXIgdmFsaWRhdGlvbi5cbi8vXG4vLyBTdGF0ZW1lbnRzIGZvciB0aGUgZm9ybSBgY2hlY2suc29tZVByb2NlZHVyZSguLi4pYCBnZXQgcmVtb3ZlZCBieVxuLy8gYSBicm93c2VyaWZ5IHRyYW5zZm9ybSBmb3Igb3B0aW1pemVkL21pbmlmaWVkIGJ1bmRsZXMuXG4vL1xuLyogZ2xvYmFscyBhdG9iICovXG52YXIgZW5kbCA9ICdcXG4nXG5cbi8vIG9ubHkgdXNlZCBmb3IgZXh0cmFjdGluZyBzaGFkZXIgbmFtZXMuICBpZiBhdG9iIG5vdCBwcmVzZW50LCB0aGVuIGVycm9yc1xuLy8gd2lsbCBiZSBzbGlnaHRseSBjcmFwcGllclxuZnVuY3Rpb24gZGVjb2RlQjY0IChzdHIpIHtcbiAgaWYgKHR5cGVvZiBhdG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhdG9iKHN0cilcbiAgfVxuICByZXR1cm4gJ2Jhc2U2NDonICsgc3RyXG59XG5cbmZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignKHJlZ2wpICcgKyBtZXNzYWdlKVxuICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB0aHJvdyBlcnJvclxufVxuXG5mdW5jdGlvbiBjaGVjayAocHJlZCwgbWVzc2FnZSkge1xuICBpZiAoIXByZWQpIHtcbiAgICByYWlzZShtZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29sb24gKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gJzogJyArIG1lc3NhZ2VcbiAgfVxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJhbWV0ZXIgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgcmFpc2UoJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICAgICAnLiBwb3NzaWJsZSB2YWx1ZXM6ICcgKyBPYmplY3Qua2V5cyhwb3NzaWJpbGl0aWVzKS5qb2luKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJc1R5cGVkQXJyYXkgKGRhdGEsIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gbXVzdCBiZSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZFR5cGVFaCAodmFsdWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCdcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVPZiAodmFsdWUsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9uTmVnYXRpdmVJbnQgKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghKCh2YWx1ZSA+PSAwKSAmJlxuICAgICAgICAoKHZhbHVlIHwgMCkgPT09IHZhbHVlKSkpIHtcbiAgICByYWlzZSgnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZSwgKCcgKyB2YWx1ZSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgICAgICcuIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja09uZU9mICh2YWx1ZSwgbGlzdCwgbWVzc2FnZSkge1xuICBpZiAobGlzdC5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICByYWlzZSgnaW52YWxpZCB2YWx1ZScgKyBlbmNvbG9uKG1lc3NhZ2UpICsgJy4gbXVzdCBiZSBvbmUgb2Y6ICcgKyBsaXN0KVxuICB9XG59XG5cbnZhciBjb25zdHJ1Y3RvcktleXMgPSBbXG4gICdnbCcsXG4gICdjYW52YXMnLFxuICAnY29udGFpbmVyJyxcbiAgJ2F0dHJpYnV0ZXMnLFxuICAncGl4ZWxSYXRpbycsXG4gICdleHRlbnNpb25zJyxcbiAgJ29wdGlvbmFsRXh0ZW5zaW9ucycsXG4gICdwcm9maWxlJyxcbiAgJ29uRG9uZSdcbl1cblxuZnVuY3Rpb24gY2hlY2tDb25zdHJ1Y3RvciAob2JqKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGNvbnN0cnVjdG9yS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICByYWlzZSgnaW52YWxpZCByZWdsIGNvbnN0cnVjdG9yIGFyZ3VtZW50IFwiJyArIGtleSArICdcIi4gbXVzdCBiZSBvbmUgb2YgJyArIGNvbnN0cnVjdG9yS2V5cylcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGxlZnRQYWQgKHN0ciwgbikge1xuICBzdHIgPSBzdHIgKyAnJ1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IG4pIHtcbiAgICBzdHIgPSAnICcgKyBzdHJcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIFNoYWRlckZpbGUgKCkge1xuICB0aGlzLm5hbWUgPSAndW5rbm93bidcbiAgdGhpcy5saW5lcyA9IFtdXG4gIHRoaXMuaW5kZXggPSB7fVxuICB0aGlzLmhhc0Vycm9ycyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIFNoYWRlckxpbmUgKG51bWJlciwgbGluZSkge1xuICB0aGlzLm51bWJlciA9IG51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lXG4gIHRoaXMuZXJyb3JzID0gW11cbn1cblxuZnVuY3Rpb24gU2hhZGVyRXJyb3IgKGZpbGVOdW1iZXIsIGxpbmVOdW1iZXIsIG1lc3NhZ2UpIHtcbiAgdGhpcy5maWxlID0gZmlsZU51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDb21tYW5kICgpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKClcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpXG4gIHZhciBwYXQgPSAvY29tcGlsZVByb2NlZHVyZS4qXFxuXFxzKmF0LipcXCgoLiopXFwpLy5leGVjKHN0YWNrKVxuICBpZiAocGF0KSB7XG4gICAgcmV0dXJuIHBhdFsxXVxuICB9XG4gIHZhciBwYXQyID0gL2NvbXBpbGVQcm9jZWR1cmUuKlxcblxccyphdFxccysoLiopKFxcbnwkKS8uZXhlYyhzdGFjaylcbiAgaWYgKHBhdDIpIHtcbiAgICByZXR1cm4gcGF0MlsxXVxuICB9XG4gIHJldHVybiAndW5rbm93bidcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDYWxsU2l0ZSAoKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcigpXG4gIHZhciBzdGFjayA9IChlcnJvci5zdGFjayB8fCBlcnJvcikudG9TdHJpbmcoKVxuICB2YXIgcGF0ID0gL2F0IFJFR0xDb21tYW5kLipcXG5cXHMrYXQuKlxcKCguKilcXCkvLmV4ZWMoc3RhY2spXG4gIGlmIChwYXQpIHtcbiAgICByZXR1cm4gcGF0WzFdXG4gIH1cbiAgdmFyIHBhdDIgPSAvYXQgUkVHTENvbW1hbmQuKlxcblxccythdFxccysoLiopXFxuLy5leGVjKHN0YWNrKVxuICBpZiAocGF0Mikge1xuICAgIHJldHVybiBwYXQyWzFdXG4gIH1cbiAgcmV0dXJuICd1bmtub3duJ1xufVxuXG5mdW5jdGlvbiBwYXJzZVNvdXJjZSAoc291cmNlLCBjb21tYW5kKSB7XG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJylcbiAgdmFyIGxpbmVOdW1iZXIgPSAxXG4gIHZhciBmaWxlTnVtYmVyID0gMFxuICB2YXIgZmlsZXMgPSB7XG4gICAgdW5rbm93bjogbmV3IFNoYWRlckZpbGUoKSxcbiAgICAwOiBuZXcgU2hhZGVyRmlsZSgpXG4gIH1cbiAgZmlsZXMudW5rbm93bi5uYW1lID0gZmlsZXNbMF0ubmFtZSA9IGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKClcbiAgZmlsZXMudW5rbm93bi5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKDAsICcnKSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV1cbiAgICB2YXIgcGFydHMgPSAvXlxccyojXFxzKihcXHcrKVxccysoLispXFxzKiQvLmV4ZWMobGluZSlcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHN3aXRjaCAocGFydHNbMV0pIHtcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFyIGxpbmVOdW1iZXJJbmZvID0gLyhcXGQrKShcXHMrXFxkKyk/Ly5leGVjKHBhcnRzWzJdKVxuICAgICAgICAgIGlmIChsaW5lTnVtYmVySW5mbykge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IGxpbmVOdW1iZXJJbmZvWzFdIHwgMFxuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJJbmZvWzJdKSB7XG4gICAgICAgICAgICAgIGZpbGVOdW1iZXIgPSBsaW5lTnVtYmVySW5mb1syXSB8IDBcbiAgICAgICAgICAgICAgaWYgKCEoZmlsZU51bWJlciBpbiBmaWxlcykpIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXSA9IG5ldyBTaGFkZXJGaWxlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdkZWZpbmUnOlxuICAgICAgICAgIHZhciBuYW1lSW5mbyA9IC9TSEFERVJfTkFNRShfQjY0KT9cXHMrKC4qKSQvLmV4ZWMocGFydHNbMl0pXG4gICAgICAgICAgaWYgKG5hbWVJbmZvKSB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXS5uYW1lID0gKG5hbWVJbmZvWzFdXG4gICAgICAgICAgICAgID8gZGVjb2RlQjY0KG5hbWVJbmZvWzJdKVxuICAgICAgICAgICAgICA6IG5hbWVJbmZvWzJdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxlc1tmaWxlTnVtYmVyXS5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKGxpbmVOdW1iZXIrKywgbGluZSkpXG4gIH1cbiAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOdW1iZXIpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgZmlsZS5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBmaWxlLmluZGV4W2xpbmUubnVtYmVyXSA9IGxpbmVcbiAgICB9KVxuICB9KVxuICByZXR1cm4gZmlsZXNcbn1cblxuZnVuY3Rpb24gcGFyc2VFcnJvckxvZyAoZXJyTG9nKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBlcnJMb2cuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGVyck1zZykge1xuICAgIGlmIChlcnJNc2cubGVuZ3RoIDwgNSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IC9eRVJST1I6XFxzKyhcXGQrKTooXFxkKyk6XFxzKiguKikkLy5leGVjKGVyck1zZylcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBTaGFkZXJFcnJvcihcbiAgICAgICAgcGFydHNbMV0gfCAwLFxuICAgICAgICBwYXJ0c1syXSB8IDAsXG4gICAgICAgIHBhcnRzWzNdLnRyaW0oKSkpXG4gICAgfSBlbHNlIGlmIChlcnJNc2cubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IFNoYWRlckVycm9yKCd1bmtub3duJywgMCwgZXJyTXNnKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gYW5ub3RhdGVGaWxlcyAoZmlsZXMsIGVycm9ycykge1xuICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2Vycm9yLmZpbGVdXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHZhciBsaW5lID0gZmlsZS5pbmRleFtlcnJvci5saW5lXVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgbGluZS5lcnJvcnMucHVzaChlcnJvcilcbiAgICAgICAgZmlsZS5oYXNFcnJvcnMgPSB0cnVlXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBmaWxlcy51bmtub3duLmhhc0Vycm9ycyA9IHRydWVcbiAgICBmaWxlcy51bmtub3duLmxpbmVzWzBdLmVycm9ycy5wdXNoKGVycm9yKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1NoYWRlckVycm9yIChnbCwgc2hhZGVyLCBzb3VyY2UsIHR5cGUsIGNvbW1hbmQpIHtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgdmFyIHR5cGVOYW1lID0gdHlwZSA9PT0gZ2wuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnXG4gICAgY2hlY2tDb21tYW5kVHlwZShzb3VyY2UsICdzdHJpbmcnLCB0eXBlTmFtZSArICcgc2hhZGVyIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJywgY29tbWFuZClcbiAgICB2YXIgZmlsZXMgPSBwYXJzZVNvdXJjZShzb3VyY2UsIGNvbW1hbmQpXG4gICAgdmFyIGVycm9ycyA9IHBhcnNlRXJyb3JMb2coZXJyTG9nKVxuICAgIGFubm90YXRlRmlsZXMoZmlsZXMsIGVycm9ycylcblxuICAgIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlTnVtYmVyKSB7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgICBpZiAoIWZpbGUuaGFzRXJyb3JzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5ncyA9IFsnJ11cbiAgICAgIHZhciBzdHlsZXMgPSBbJyddXG5cbiAgICAgIGZ1bmN0aW9uIHB1c2ggKHN0ciwgc3R5bGUpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHN0cilcbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUgfHwgJycpXG4gICAgICB9XG5cbiAgICAgIHB1c2goJ2ZpbGUgbnVtYmVyICcgKyBmaWxlTnVtYmVyICsgJzogJyArIGZpbGUubmFtZSArICdcXG4nLCAnY29sb3I6cmVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Zm9udC13ZWlnaHQ6Ym9sZCcpXG5cbiAgICAgIGZpbGUubGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHB1c2gobGVmdFBhZChsaW5lLm51bWJlciwgNCkgKyAnfCAgJywgJ2JhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICBwdXNoKGxpbmUubGluZSArIGVuZGwsICdjb2xvcjpyZWQ7IGJhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcblxuICAgICAgICAgIC8vIHRyeSB0byBndWVzcyB0b2tlblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwXG4gICAgICAgICAgbGluZS5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgdmFyIHRva2VuID0gL15cXHMqJyguKiknXFxzKjpcXHMqKC4qKSQvLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICB2YXIgdG9rZW5QYXQgPSB0b2tlblsxXVxuICAgICAgICAgICAgICBtZXNzYWdlID0gdG9rZW5bMl1cbiAgICAgICAgICAgICAgc3dpdGNoICh0b2tlblBhdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Fzc2lnbic6XG4gICAgICAgICAgICAgICAgICB0b2tlblBhdCA9ICc9J1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lLmxpbmUuaW5kZXhPZih0b2tlblBhdCwgb2Zmc2V0KSwgMClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpKVxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCdeXl4nLCBvZmZzZXQgKyAzKSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSlcbiAgICAgICAgICAgIHB1c2gobWVzc2FnZSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSArIGVuZGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaChsZWZ0UGFkKGxpbmUubnVtYmVyLCA0KSArICd8ICAnKVxuICAgICAgICAgIHB1c2gobGluZS5saW5lICsgZW5kbCwgJ2NvbG9yOnJlZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmNocm9tZSkge1xuICAgICAgICBzdHlsZXNbMF0gPSBzdHJpbmdzLmpvaW4oJyVjJylcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgc3R5bGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyaW5ncy5qb2luKCcnKSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY2hlY2sucmFpc2UoJ0Vycm9yIGNvbXBpbGluZyAnICsgdHlwZU5hbWUgKyAnIHNoYWRlciwgJyArIGZpbGVzWzBdLm5hbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tMaW5rRXJyb3IgKGdsLCBwcm9ncmFtLCBmcmFnU2hhZGVyLCB2ZXJ0U2hhZGVyLCBjb21tYW5kKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICB2YXIgZnJhZ1BhcnNlID0gcGFyc2VTb3VyY2UoZnJhZ1NoYWRlciwgY29tbWFuZClcbiAgICB2YXIgdmVydFBhcnNlID0gcGFyc2VTb3VyY2UodmVydFNoYWRlciwgY29tbWFuZClcblxuICAgIHZhciBoZWFkZXIgPSAnRXJyb3IgbGlua2luZyBwcm9ncmFtIHdpdGggdmVydGV4IHNoYWRlciwgXCInICtcbiAgICAgIHZlcnRQYXJzZVswXS5uYW1lICsgJ1wiLCBhbmQgZnJhZ21lbnQgc2hhZGVyIFwiJyArIGZyYWdQYXJzZVswXS5uYW1lICsgJ1wiJ1xuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclYycgKyBoZWFkZXIgKyBlbmRsICsgJyVjJyArIGVyckxvZyxcbiAgICAgICAgJ2NvbG9yOnJlZDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2ZvbnQtd2VpZ2h0OmJvbGQnLFxuICAgICAgICAnY29sb3I6cmVkJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coaGVhZGVyICsgZW5kbCArIGVyckxvZylcbiAgICB9XG4gICAgY2hlY2sucmFpc2UoaGVhZGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVDb21tYW5kUmVmIChvYmplY3QpIHtcbiAgb2JqZWN0Ll9jb21tYW5kUmVmID0gZ3Vlc3NDb21tYW5kKClcbn1cblxuZnVuY3Rpb24gc2F2ZURyYXdDb21tYW5kSW5mbyAob3B0cywgdW5pZm9ybXMsIGF0dHJpYnV0ZXMsIHN0cmluZ1N0b3JlKSB7XG4gIHNhdmVDb21tYW5kUmVmKG9wdHMpXG5cbiAgZnVuY3Rpb24gaWQgKHN0cikge1xuICAgIGlmIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHJpbmdTdG9yZS5pZChzdHIpXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbiAgb3B0cy5fZnJhZ0lkID0gaWQob3B0cy5zdGF0aWMuZnJhZylcbiAgb3B0cy5fdmVydElkID0gaWQob3B0cy5zdGF0aWMudmVydClcblxuICBmdW5jdGlvbiBhZGRQcm9wcyAoZGljdCwgc2V0KSB7XG4gICAgT2JqZWN0LmtleXMoc2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh1KSB7XG4gICAgICBkaWN0W3N0cmluZ1N0b3JlLmlkKHUpXSA9IHRydWVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXQgPSBvcHRzLl91bmlmb3JtU2V0ID0ge31cbiAgYWRkUHJvcHModW5pZm9ybVNldCwgdW5pZm9ybXMuc3RhdGljKVxuICBhZGRQcm9wcyh1bmlmb3JtU2V0LCB1bmlmb3Jtcy5keW5hbWljKVxuXG4gIHZhciBhdHRyaWJ1dGVTZXQgPSBvcHRzLl9hdHRyaWJ1dGVTZXQgPSB7fVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuc3RhdGljKVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuZHluYW1pYylcblxuICBvcHRzLl9oYXNDb3VudCA9IChcbiAgICAnY291bnQnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2NvdW50JyBpbiBvcHRzLmR5bmFtaWMgfHxcbiAgICAnZWxlbWVudHMnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2VsZW1lbnRzJyBpbiBvcHRzLmR5bmFtaWMpXG59XG5cbmZ1bmN0aW9uIGNvbW1hbmRSYWlzZSAobWVzc2FnZSwgY29tbWFuZCkge1xuICB2YXIgY2FsbFNpdGUgPSBndWVzc0NhbGxTaXRlKClcbiAgcmFpc2UobWVzc2FnZSArXG4gICAgJyBpbiBjb21tYW5kICcgKyAoY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSkgK1xuICAgIChjYWxsU2l0ZSA9PT0gJ3Vua25vd24nID8gJycgOiAnIGNhbGxlZCBmcm9tICcgKyBjYWxsU2l0ZSkpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29tbWFuZCAocHJlZCwgbWVzc2FnZSwgY29tbWFuZCkge1xuICBpZiAoIXByZWQpIHtcbiAgICBjb21tYW5kUmFpc2UobWVzc2FnZSwgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlckNvbW1hbmQgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlLCBjb21tYW5kKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgY29tbWFuZFJhaXNlKFxuICAgICAgJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIHBvc3NpYmxlIHZhbHVlczogJyArIE9iamVjdC5rZXlzKHBvc3NpYmlsaXRpZXMpLmpvaW4oKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tDb21tYW5kVHlwZSAodmFsdWUsIHR5cGUsIG1lc3NhZ2UsIGNvbW1hbmQpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICBjb21tYW5kUmFpc2UoXG4gICAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIGV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyAodHlwZW9mIHZhbHVlKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25hbCAoYmxvY2spIHtcbiAgYmxvY2soKVxufVxuXG5mdW5jdGlvbiBjaGVja0ZyYW1lYnVmZmVyRm9ybWF0IChhdHRhY2htZW50LCB0ZXhGb3JtYXRzLCByYkZvcm1hdHMpIHtcbiAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgIGNoZWNrT25lT2YoXG4gICAgICBhdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICB0ZXhGb3JtYXRzLFxuICAgICAgJ3Vuc3VwcG9ydGVkIHRleHR1cmUgZm9ybWF0IGZvciBhdHRhY2htZW50JylcbiAgfSBlbHNlIHtcbiAgICBjaGVja09uZU9mKFxuICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQsXG4gICAgICByYkZvcm1hdHMsXG4gICAgICAndW5zdXBwb3J0ZWQgcmVuZGVyYnVmZmVyIGZvcm1hdCBmb3IgYXR0YWNobWVudCcpXG4gIH1cbn1cblxudmFyIEdMX0NMQU1QX1RPX0VER0UgPSAweDgxMkZcblxudmFyIEdMX05FQVJFU1QgPSAweDI2MDBcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUID0gMHgyNzAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDNcblxudmFyIEdMX0JZVEUgPSA1MTIwXG52YXIgR0xfVU5TSUdORURfQllURSA9IDUxMjFcbnZhciBHTF9TSE9SVCA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCA9IDUxMjNcbnZhciBHTF9JTlQgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UID0gNTEyNVxudmFyIEdMX0ZMT0FUID0gNTEyNlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCA9IDB4ODAzM1xudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgPSAweDgwMzRcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMID0gMHg4NEZBXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MVxuXG52YXIgVFlQRV9TSVpFID0ge31cblxuVFlQRV9TSVpFW0dMX0JZVEVdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9CWVRFXSA9IDFcblxuVFlQRV9TSVpFW0dMX1NIT1JUXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRdID1cblRZUEVfU0laRVtHTF9IQUxGX0ZMT0FUX09FU10gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNl81XSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzFdID0gMlxuXG5UWVBFX1NJWkVbR0xfSU5UXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfSU5UXSA9XG5UWVBFX1NJWkVbR0xfRkxPQVRdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTF0gPSA0XG5cbmZ1bmN0aW9uIHBpeGVsU2l6ZSAodHlwZSwgY2hhbm5lbHMpIHtcbiAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81KSB7XG4gICAgcmV0dXJuIDJcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCkge1xuICAgIHJldHVybiA0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRZUEVfU0laRVt0eXBlXSAqIGNoYW5uZWxzXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQb3cyICh2KSB7XG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxufVxuXG5mdW5jdGlvbiBjaGVja1RleHR1cmUyRCAoaW5mbywgbWlwRGF0YSwgbGltaXRzKSB7XG4gIHZhciBpXG4gIHZhciB3ID0gbWlwRGF0YS53aWR0aFxuICB2YXIgaCA9IG1pcERhdGEuaGVpZ2h0XG4gIHZhciBjID0gbWlwRGF0YS5jaGFubmVsc1xuXG4gIC8vIENoZWNrIHRleHR1cmUgc2hhcGVcbiAgY2hlY2sodyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiZcbiAgICAgICAgaCA+IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsXG4gICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuXG4gIC8vIGNoZWNrIHdyYXAgbW9kZVxuICBpZiAoaW5mby53cmFwUyAhPT0gR0xfQ0xBTVBfVE9fRURHRSB8fCBpbmZvLndyYXBUICE9PSBHTF9DTEFNUF9UT19FREdFKSB7XG4gICAgY2hlY2soaXNQb3cyKHcpICYmIGlzUG93MihoKSxcbiAgICAgICdpbmNvbXBhdGlibGUgd3JhcCBtb2RlIGZvciB0ZXh0dXJlLCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBwb3dlciBvZiAyJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLm1pcG1hc2sgPT09IDEpIHtcbiAgICBpZiAodyAhPT0gMSAmJiBoICE9PSAxKSB7XG4gICAgICBjaGVjayhcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QgJiZcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiAmJlxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTElORUFSX01JUE1BUF9ORUFSRVNUICYmXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUixcbiAgICAgICAgJ21pbiBmaWx0ZXIgcmVxdWlyZXMgbWlwbWFwJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGV4dHVyZSBtdXN0IGJlIHBvd2VyIG9mIDJcbiAgICBjaGVjayhpc1BvdzIodykgJiYgaXNQb3cyKGgpLFxuICAgICAgJ3RleHR1cmUgbXVzdCBiZSBhIHNxdWFyZSBwb3dlciBvZiAyIHRvIHN1cHBvcnQgbWlwbWFwcGluZycpXG4gICAgY2hlY2sobWlwRGF0YS5taXBtYXNrID09PSAodyA8PCAxKSAtIDEsXG4gICAgICAnbWlzc2luZyBvciBpbmNvbXBsZXRlIG1pcG1hcCBkYXRhJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLnR5cGUgPT09IEdMX0ZMT0FUKSB7XG4gICAgaWYgKGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YoJ29lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpIDwgMCkge1xuICAgICAgY2hlY2soaW5mby5taW5GaWx0ZXIgPT09IEdMX05FQVJFU1QgJiYgaW5mby5tYWdGaWx0ZXIgPT09IEdMX05FQVJFU1QsXG4gICAgICAgICdmaWx0ZXIgbm90IHN1cHBvcnRlZCwgbXVzdCBlbmFibGUgb2VzX3RleHR1cmVfZmxvYXRfbGluZWFyJylcbiAgICB9XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIHdpdGggZmxvYXQgdGV4dHVyZXMnKVxuICB9XG5cbiAgLy8gY2hlY2sgaW1hZ2UgY29tcGxldGVcbiAgdmFyIG1pcGltYWdlcyA9IG1pcERhdGEuaW1hZ2VzXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgaWYgKG1pcGltYWdlc1tpXSkge1xuICAgICAgdmFyIG13ID0gdyA+PiBpXG4gICAgICB2YXIgbWggPSBoID4+IGlcbiAgICAgIGNoZWNrKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG5cbiAgICAgIHZhciBpbWcgPSBtaXBpbWFnZXNbaV1cblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgaW1nLmhlaWdodCA9PT0gbWgsXG4gICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBtaXAgaW1hZ2VzJylcblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy5mb3JtYXQgPT09IG1pcERhdGEuZm9ybWF0ICYmXG4gICAgICAgIGltZy5pbnRlcm5hbGZvcm1hdCA9PT0gbWlwRGF0YS5pbnRlcm5hbGZvcm1hdCAmJlxuICAgICAgICBpbWcudHlwZSA9PT0gbWlwRGF0YS50eXBlLFxuICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgIGlmIChpbWcuY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBzaXplIGZvciBjb21wcmVzc2VkIGltYWdlc1xuICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAvLyBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSBtdyAqIG1oICpcbiAgICAgICAgLy8gTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgIHZhciByb3dTaXplID0gTWF0aC5jZWlsKHBpeGVsU2l6ZShpbWcudHlwZSwgYykgKiBtdyAvIGltZy51bnBhY2tBbGlnbm1lbnQpICogaW1nLnVucGFja0FsaWdubWVudFxuICAgICAgICBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSByb3dTaXplICogbWgsXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICB9IGVsc2UgaWYgKGltZy5lbGVtZW50KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGVsZW1lbnQgY2FuIGJlIGxvYWRlZFxuICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBjb21wYXRpYmxlIGZvcm1hdCBhbmQgdHlwZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgY2hlY2soKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpKSA9PT0gMCwgJ2V4dHJhIG1pcG1hcCBkYXRhJylcbiAgICB9XG4gIH1cblxuICBpZiAobWlwRGF0YS5jb21wcmVzc2VkKSB7XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBmb3IgY29tcHJlc3NlZCBpbWFnZXMgbm90IHN1cHBvcnRlZCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tUZXh0dXJlQ3ViZSAodGV4dHVyZSwgaW5mbywgZmFjZXMsIGxpbWl0cykge1xuICB2YXIgdyA9IHRleHR1cmUud2lkdGhcbiAgdmFyIGggPSB0ZXh0dXJlLmhlaWdodFxuICB2YXIgYyA9IHRleHR1cmUuY2hhbm5lbHNcblxuICAvLyBDaGVjayB0ZXh0dXJlIHNoYXBlXG4gIGNoZWNrKFxuICAgIHcgPiAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplICYmIGggPiAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLFxuICAgICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICBjaGVjayhcbiAgICB3ID09PSBoLFxuICAgICdjdWJlIG1hcCBtdXN0IGJlIHNxdWFyZScpXG4gIGNoZWNrKFxuICAgIGluZm8ud3JhcFMgPT09IEdMX0NMQU1QX1RPX0VER0UgJiYgaW5mby53cmFwVCA9PT0gR0xfQ0xBTVBfVE9fRURHRSxcbiAgICAnd3JhcCBtb2RlIG5vdCBzdXBwb3J0ZWQgYnkgY3ViZSBtYXAnKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZmFjZSA9IGZhY2VzW2ldXG4gICAgY2hlY2soXG4gICAgICBmYWNlLndpZHRoID09PSB3ICYmIGZhY2UuaGVpZ2h0ID09PSBoLFxuICAgICAgJ2luY29uc2lzdGVudCBjdWJlIG1hcCBmYWNlIHNoYXBlJylcblxuICAgIGlmIChpbmZvLmdlbk1pcG1hcHMpIHtcbiAgICAgIGNoZWNrKCFmYWNlLmNvbXByZXNzZWQsXG4gICAgICAgICdjYW4gbm90IGdlbmVyYXRlIG1pcG1hcCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcycpXG4gICAgICBjaGVjayhmYWNlLm1pcG1hc2sgPT09IDEsXG4gICAgICAgICdjYW4gbm90IHNwZWNpZnkgbWlwbWFwcyBhbmQgZ2VuZXJhdGUgbWlwbWFwcycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIG1pcCBhbmQgZmlsdGVyIG1vZGVcbiAgICB9XG5cbiAgICB2YXIgbWlwbWFwcyA9IGZhY2UuaW1hZ2VzXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB2YXIgaW1nID0gbWlwbWFwc1tqXVxuICAgICAgaWYgKGltZykge1xuICAgICAgICB2YXIgbXcgPSB3ID4+IGpcbiAgICAgICAgdmFyIG1oID0gaCA+PiBqXG4gICAgICAgIGNoZWNrKGZhY2UubWlwbWFzayAmICgxIDw8IGopLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgICBpbWcuaGVpZ2h0ID09PSBtaCxcbiAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgbWlwIGltYWdlcycpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy5mb3JtYXQgPT09IHRleHR1cmUuZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLmludGVybmFsZm9ybWF0ID09PSB0ZXh0dXJlLmludGVybmFsZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLnR5cGUgPT09IHRleHR1cmUudHlwZSxcbiAgICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgICAgaWYgKGltZy5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgc2l6ZSBmb3IgY29tcHJlc3NlZCBpbWFnZXNcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAgIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IG13ICogbWggKlxuICAgICAgICAgICAgTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICAgIH0gZWxzZSBpZiAoaW1nLmVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBlbGVtZW50IGNhbiBiZSBsb2FkZWRcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGNvbXBhdGlibGUgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNoZWNrJDEgPSBleHRlbmQoY2hlY2ssIHtcbiAgb3B0aW9uYWw6IGNoZWNrT3B0aW9uYWwsXG4gIHJhaXNlOiByYWlzZSxcbiAgY29tbWFuZFJhaXNlOiBjb21tYW5kUmFpc2UsXG4gIGNvbW1hbmQ6IGNoZWNrQ29tbWFuZCxcbiAgcGFyYW1ldGVyOiBjaGVja1BhcmFtZXRlcixcbiAgY29tbWFuZFBhcmFtZXRlcjogY2hlY2tQYXJhbWV0ZXJDb21tYW5kLFxuICBjb25zdHJ1Y3RvcjogY2hlY2tDb25zdHJ1Y3RvcixcbiAgdHlwZTogY2hlY2tUeXBlT2YsXG4gIGNvbW1hbmRUeXBlOiBjaGVja0NvbW1hbmRUeXBlLFxuICBpc1R5cGVkQXJyYXk6IGNoZWNrSXNUeXBlZEFycmF5LFxuICBubmk6IGNoZWNrTm9uTmVnYXRpdmVJbnQsXG4gIG9uZU9mOiBjaGVja09uZU9mLFxuICBzaGFkZXJFcnJvcjogY2hlY2tTaGFkZXJFcnJvcixcbiAgbGlua0Vycm9yOiBjaGVja0xpbmtFcnJvcixcbiAgY2FsbFNpdGU6IGd1ZXNzQ2FsbFNpdGUsXG4gIHNhdmVDb21tYW5kUmVmOiBzYXZlQ29tbWFuZFJlZixcbiAgc2F2ZURyYXdJbmZvOiBzYXZlRHJhd0NvbW1hbmRJbmZvLFxuICBmcmFtZWJ1ZmZlckZvcm1hdDogY2hlY2tGcmFtZWJ1ZmZlckZvcm1hdCxcbiAgZ3Vlc3NDb21tYW5kOiBndWVzc0NvbW1hbmQsXG4gIHRleHR1cmUyRDogY2hlY2tUZXh0dXJlMkQsXG4gIHRleHR1cmVDdWJlOiBjaGVja1RleHR1cmVDdWJlXG59KTtcblxudmFyIFZBUklBQkxFX0NPVU5URVIgPSAwXG5cbnZhciBEWU5fRlVOQyA9IDBcbnZhciBEWU5fQ09OU1RBTlQgPSA1XG52YXIgRFlOX0FSUkFZID0gNlxuXG5mdW5jdGlvbiBEeW5hbWljVmFyaWFibGUgKHR5cGUsIGRhdGEpIHtcbiAgdGhpcy5pZCA9IChWQVJJQUJMRV9DT1VOVEVSKyspXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5kYXRhID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHIgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG59XG5cbmZ1bmN0aW9uIHNwbGl0UGFydHMgKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoMClcbiAgdmFyIGxhc3RDaGFyID0gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSlcblxuICBpZiAoc3RyLmxlbmd0aCA+IDEgJiZcbiAgICAgIGZpcnN0Q2hhciA9PT0gbGFzdENoYXIgJiZcbiAgICAgIChmaXJzdENoYXIgPT09ICdcIicgfHwgZmlyc3RDaGFyID09PSBcIidcIikpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMikpICsgJ1wiJ11cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IC9cXFsoZmFsc2V8dHJ1ZXxudWxsfFxcZCt8J1teJ10qJ3xcIlteXCJdKlwiKVxcXS8uZXhlYyhzdHIpXG4gIGlmIChwYXJ0cykge1xuICAgIHJldHVybiAoXG4gICAgICBzcGxpdFBhcnRzKHN0ci5zdWJzdHIoMCwgcGFydHMuaW5kZXgpKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMocGFydHNbMV0pKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMoc3RyLnN1YnN0cihwYXJ0cy5pbmRleCArIHBhcnRzWzBdLmxlbmd0aCkpKVxuICAgIClcbiAgfVxuXG4gIHZhciBzdWJwYXJ0cyA9IHN0ci5zcGxpdCgnLicpXG4gIGlmIChzdWJwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyKSArICdcIiddXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoc3BsaXRQYXJ0cyhzdWJwYXJ0c1tpXSkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b0FjY2Vzc29yU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuICdbJyArIHNwbGl0UGFydHMoc3RyKS5qb2luKCddWycpICsgJ10nXG59XG5cbmZ1bmN0aW9uIGRlZmluZUR5bmFtaWMgKHR5cGUsIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUodHlwZSwgdG9BY2Nlc3NvclN0cmluZyhkYXRhICsgJycpKVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWMgKHgpIHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiAheC5fcmVnbFR5cGUpIHx8ICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKVxufVxuXG5mdW5jdGlvbiB1bmJveCAoeCwgcGF0aCkge1xuICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZShEWU5fRlVOQywgeClcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHggPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1ZhcmlhYmxlKERZTl9DT05TVEFOVCwgeClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoRFlOX0FSUkFZLCB4Lm1hcCgoeSwgaSkgPT4gdW5ib3goeSwgcGF0aCArICdbJyArIGkgKyAnXScpKSlcbiAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBvcHRpb24gdHlwZSBpbiB1bmlmb3JtICcgKyBwYXRoKVxufVxuXG52YXIgZHluYW1pYyA9IHtcbiAgRHluYW1pY1ZhcmlhYmxlOiBEeW5hbWljVmFyaWFibGUsXG4gIGRlZmluZTogZGVmaW5lRHluYW1pYyxcbiAgaXNEeW5hbWljOiBpc0R5bmFtaWMsXG4gIHVuYm94OiB1bmJveCxcbiAgYWNjZXNzb3I6IHRvQWNjZXNzb3JTdHJpbmdcbn07XG5cbi8qIGdsb2JhbHMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xudmFyIHJhZiA9IHtcbiAgbmV4dDogdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGNiKSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIH1cbiAgICA6IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gc2V0VGltZW91dChjYiwgMTYpIH0sXG4gIGNhbmNlbDogdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAocmFmKSB7IHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpIH1cbiAgICA6IGNsZWFyVGltZW91dFxufTtcblxuLyogZ2xvYmFscyBwZXJmb3JtYW5jZSAqL1xudmFyIGNsb2NrID0gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KVxuICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgfVxuICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKSB9O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdTdG9yZSAoKSB7XG4gIHZhciBzdHJpbmdJZHMgPSB7ICcnOiAwIH1cbiAgdmFyIHN0cmluZ1ZhbHVlcyA9IFsnJ11cbiAgcmV0dXJuIHtcbiAgICBpZDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdID0gc3RyaW5nVmFsdWVzLmxlbmd0aFxuICAgICAgc3RyaW5nVmFsdWVzLnB1c2goc3RyKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG5cbiAgICBzdHI6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlc1tpZF1cbiAgICB9XG4gIH1cbn1cblxuLy8gQ29udGV4dCBhbmQgY2FudmFzIGNyZWF0aW9uIGhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyAoZWxlbWVudCwgb25Eb25lLCBwaXhlbFJhdGlvKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBleHRlbmQoY2FudmFzLnN0eWxlLCB7XG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGV4dGVuZChlbGVtZW50LnN0eWxlLCB7XG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZSAoKSB7XG4gICAgdmFyIHcgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBoID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB3ID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnRcbiAgICAgIGggPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcFxuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaFxuICAgIGV4dGVuZChjYW52YXMuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiB3ICsgJ3B4JyxcbiAgICAgIGhlaWdodDogaCArICdweCdcbiAgICB9KVxuICB9XG5cbiAgdmFyIHJlc2l6ZU9ic2VydmVyXG4gIGlmIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGlnbm9yZSAnUmVzaXplT2JzZXJ2ZXInIGlzIG5vdCBkZWZpbmVkXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc2V0VGltZW91dCB0byBhdm9pZCBmbGlja2VyXG4gICAgICBzZXRUaW1lb3V0KHJlc2l6ZSlcbiAgICB9KVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRGVzdHJveSAoKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSlcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMpXG4gIH1cblxuICByZXNpemUoKVxuXG4gIHJldHVybiB7XG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgb25EZXN0cm95OiBvbkRlc3Ryb3lcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0IChjYW52YXMsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XG4gIGZ1bmN0aW9uIGdldCAobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQobmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICBnZXQoJ3dlYmdsJykgfHxcbiAgICBnZXQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpIHx8XG4gICAgZ2V0KCd3ZWJnbC1leHBlcmltZW50YWwnKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIG9iai5hcHBlbmRDaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gaXNXZWJHTENvbnRleHQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmouZHJhd0FycmF5cyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBvYmouZHJhd0VsZW1lbnRzID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdCgpXG4gIH1cbiAgY2hlY2skMShBcnJheS5pc0FycmF5KGlucHV0KSwgJ2ludmFsaWQgZXh0ZW5zaW9uIGFycmF5JylcbiAgcmV0dXJuIGlucHV0XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnQgKGRlc2MpIHtcbiAgaWYgKHR5cGVvZiBkZXNjID09PSAnc3RyaW5nJykge1xuICAgIGNoZWNrJDEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJywgJ25vdCBzdXBwb3J0ZWQgb3V0c2lkZSBvZiBET00nKVxuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRlc2MpXG4gIH1cbiAgcmV0dXJuIGRlc2Ncbn1cblxuZnVuY3Rpb24gcGFyc2VBcmdzIChhcmdzXykge1xuICB2YXIgYXJncyA9IGFyZ3NfIHx8IHt9XG4gIHZhciBlbGVtZW50LCBjb250YWluZXIsIGNhbnZhcywgZ2xcbiAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0ge31cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXVxuICB2YXIgb3B0aW9uYWxFeHRlbnNpb25zID0gW11cbiAgdmFyIHBpeGVsUmF0aW8gPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gIHZhciBwcm9maWxlID0gZmFsc2VcbiAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKGVycilcbiAgICB9XG4gIH1cbiAgdmFyIG9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICdzZWxlY3RvciBxdWVyaWVzIG9ubHkgc3VwcG9ydGVkIGluIERPTSBlbnZpcm9tZW50cycpXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJncylcbiAgICBjaGVjayQxKGVsZW1lbnQsICdpbnZhbGlkIHF1ZXJ5IHN0cmluZyBmb3IgZWxlbWVudCcpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoYXJncykpIHtcbiAgICAgIGVsZW1lbnQgPSBhcmdzXG4gICAgfSBlbHNlIGlmIChpc1dlYkdMQ29udGV4dChhcmdzKSkge1xuICAgICAgZ2wgPSBhcmdzXG4gICAgICBjYW52YXMgPSBnbC5jYW52YXNcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2skMS5jb25zdHJ1Y3RvcihhcmdzKVxuICAgICAgaWYgKCdnbCcgaW4gYXJncykge1xuICAgICAgICBnbCA9IGFyZ3MuZ2xcbiAgICAgIH0gZWxzZSBpZiAoJ2NhbnZhcycgaW4gYXJncykge1xuICAgICAgICBjYW52YXMgPSBnZXRFbGVtZW50KGFyZ3MuY2FudmFzKVxuICAgICAgfSBlbHNlIGlmICgnY29udGFpbmVyJyBpbiBhcmdzKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGdldEVsZW1lbnQoYXJncy5jb250YWluZXIpXG4gICAgICB9XG4gICAgICBpZiAoJ2F0dHJpYnV0ZXMnIGluIGFyZ3MpIHtcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzLmF0dHJpYnV0ZXNcbiAgICAgICAgY2hlY2skMS50eXBlKGNvbnRleHRBdHRyaWJ1dGVzLCAnb2JqZWN0JywgJ2ludmFsaWQgY29udGV4dCBhdHRyaWJ1dGVzJylcbiAgICAgIH1cbiAgICAgIGlmICgnZXh0ZW5zaW9ucycgaW4gYXJncykge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKGFyZ3MuZXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb3B0aW9uYWxFeHRlbnNpb25zJyBpbiBhcmdzKSB7XG4gICAgICAgIG9wdGlvbmFsRXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhhcmdzLm9wdGlvbmFsRXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb25Eb25lJyBpbiBhcmdzKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBhcmdzLm9uRG9uZSwgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAnaW52YWxpZCBvciBtaXNzaW5nIG9uRG9uZSBjYWxsYmFjaycpXG4gICAgICAgIG9uRG9uZSA9IGFyZ3Mub25Eb25lXG4gICAgICB9XG4gICAgICBpZiAoJ3Byb2ZpbGUnIGluIGFyZ3MpIHtcbiAgICAgICAgcHJvZmlsZSA9ICEhYXJncy5wcm9maWxlXG4gICAgICB9XG4gICAgICBpZiAoJ3BpeGVsUmF0aW8nIGluIGFyZ3MpIHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9ICthcmdzLnBpeGVsUmF0aW9cbiAgICAgICAgY2hlY2skMShwaXhlbFJhdGlvID4gMCwgJ2ludmFsaWQgcGl4ZWwgcmF0aW8nKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsJylcbiAgfVxuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgIGNhbnZhcyA9IGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyID0gZWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2hlY2skMShcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgJ211c3QgbWFudWFsbHkgc3BlY2lmeSB3ZWJnbCBjb250ZXh0IG91dHNpZGUgb2YgRE9NIGVudmlyb25tZW50cycpXG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQ2FudmFzKGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LCBvbkRvbmUsIHBpeGVsUmF0aW8pXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY2FudmFzID0gcmVzdWx0LmNhbnZhc1xuICAgICAgb25EZXN0cm95ID0gcmVzdWx0Lm9uRGVzdHJveVxuICAgIH1cbiAgICAvLyB3b3JrYXJvdW5kIGZvciBjaHJvbWl1bSBidWcsIHByZW11bHRpcGxpZWQgYWxwaGEgdmFsdWUgaXMgcGxhdGZvcm0gZGVwZW5kZW50XG4gICAgaWYgKGNvbnRleHRBdHRyaWJ1dGVzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdW5kZWZpbmVkKSBjb250ZXh0QXR0cmlidXRlcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlXG4gICAgZ2wgPSBjcmVhdGVDb250ZXh0KGNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoIWdsKSB7XG4gICAgb25EZXN0cm95KClcbiAgICBvbkRvbmUoJ3dlYmdsIG5vdCBzdXBwb3J0ZWQsIHRyeSB1cGdyYWRpbmcgeW91ciBicm93c2VyIG9yIGdyYXBoaWNzIGRyaXZlcnMgaHR0cDovL2dldC53ZWJnbC5vcmcnKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsOiBnbCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIG9wdGlvbmFsRXh0ZW5zaW9uczogb3B0aW9uYWxFeHRlbnNpb25zLFxuICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgcHJvZmlsZTogcHJvZmlsZSxcbiAgICBvbkRvbmU6IG9uRG9uZSxcbiAgICBvbkRlc3Ryb3k6IG9uRGVzdHJveVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNhY2hlIChnbCwgY29uZmlnKSB7XG4gIHZhciBleHRlbnNpb25zID0ge31cblxuICBmdW5jdGlvbiB0cnlMb2FkRXh0ZW5zaW9uIChuYW1lXykge1xuICAgIGNoZWNrJDEudHlwZShuYW1lXywgJ3N0cmluZycsICdleHRlbnNpb24gbmFtZSBtdXN0IGJlIHN0cmluZycpXG4gICAgdmFyIG5hbWUgPSBuYW1lXy50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIGV4dFxuICAgIHRyeSB7XG4gICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gISFleHRcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbmFtZSA9IGNvbmZpZy5leHRlbnNpb25zW2ldXG4gICAgaWYgKCF0cnlMb2FkRXh0ZW5zaW9uKG5hbWUpKSB7XG4gICAgICBjb25maWcub25EZXN0cm95KClcbiAgICAgIGNvbmZpZy5vbkRvbmUoJ1wiJyArIG5hbWUgKyAnXCIgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCwgdHJ5IHVwZ3JhZGluZyB5b3VyIHN5c3RlbSBvciBhIGRpZmZlcmVudCBicm93c2VyJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uZmlnLm9wdGlvbmFsRXh0ZW5zaW9ucy5mb3JFYWNoKHRyeUxvYWRFeHRlbnNpb24pXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbbmFtZV0gJiYgIXRyeUxvYWRFeHRlbnNpb24obmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhyZWdsKTogZXJyb3IgcmVzdG9yaW5nIGV4dGVuc2lvbiAnICsgbmFtZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vcCAobiwgZikge1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBmKGkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG52YXIgR0xfQllURSQxID0gNTEyMFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkMiA9IDUxMjFcbnZhciBHTF9TSE9SVCQxID0gNTEyMlxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDEgPSA1MTIzXG52YXIgR0xfSU5UJDEgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UJDEgPSA1MTI1XG52YXIgR0xfRkxPQVQkMiA9IDUxMjZcblxuZnVuY3Rpb24gbmV4dFBvdzE2ICh2KSB7XG4gIGZvciAodmFyIGkgPSAxNjsgaSA8PSAoMSA8PCAyOCk7IGkgKj0gMTYpIHtcbiAgICBpZiAodiA8PSBpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBsb2cyICh2KSB7XG4gIHZhciByLCBzaGlmdFxuICByID0gKHYgPiAweEZGRkYpIDw8IDRcbiAgdiA+Pj49IHJcbiAgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDNcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweDMpIDw8IDFcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHJldHVybiByIHwgKHYgPj4gMSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9vbCAoKSB7XG4gIHZhciBidWZmZXJQb29sID0gbG9vcCg4LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0pXG5cbiAgZnVuY3Rpb24gYWxsb2MgKG4pIHtcbiAgICB2YXIgc3ogPSBuZXh0UG93MTYobilcbiAgICB2YXIgYmluID0gYnVmZmVyUG9vbFtsb2cyKHN6KSA+PiAyXVxuICAgIGlmIChiaW4ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGJpbi5wb3AoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKHN6KVxuICB9XG5cbiAgZnVuY3Rpb24gZnJlZSAoYnVmKSB7XG4gICAgYnVmZmVyUG9vbFtsb2cyKGJ1Zi5ieXRlTGVuZ3RoKSA+PiAyXS5wdXNoKGJ1ZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jVHlwZSAodHlwZSwgbikge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdMX0JZVEUkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQyOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfU0hPUlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoYWxsb2MoNCAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KGFsbG9jKDQgKiBuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfRkxPQVQkMjpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhbGxvYyg0ICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gbikge1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJhcnJheSgwLCBuKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlVHlwZSAoYXJyYXkpIHtcbiAgICBmcmVlKGFycmF5LmJ1ZmZlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsb2M6IGFsbG9jLFxuICAgIGZyZWU6IGZyZWUsXG4gICAgYWxsb2NUeXBlOiBhbGxvY1R5cGUsXG4gICAgZnJlZVR5cGU6IGZyZWVUeXBlXG4gIH1cbn1cblxudmFyIHBvb2wgPSBjcmVhdGVQb29sKClcblxuLy8gemVybyBwb29sIGZvciBpbml0aWFsIHplcm8gZGF0YVxucG9vbC56ZXJvID0gY3JlYXRlUG9vbCgpXG5cbnZhciBHTF9TVUJQSVhFTF9CSVRTID0gMHgwRDUwXG52YXIgR0xfUkVEX0JJVFMgPSAweDBENTJcbnZhciBHTF9HUkVFTl9CSVRTID0gMHgwRDUzXG52YXIgR0xfQkxVRV9CSVRTID0gMHgwRDU0XG52YXIgR0xfQUxQSEFfQklUUyA9IDB4MEQ1NVxudmFyIEdMX0RFUFRIX0JJVFMgPSAweDBENTZcbnZhciBHTF9TVEVOQ0lMX0JJVFMgPSAweDBENTdcblxudmFyIEdMX0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRSA9IDB4ODQ2RFxudmFyIEdMX0FMSUFTRURfTElORV9XSURUSF9SQU5HRSA9IDB4ODQ2RVxuXG52YXIgR0xfTUFYX1RFWFRVUkVfU0laRSA9IDB4MEQzM1xudmFyIEdMX01BWF9WSUVXUE9SVF9ESU1TID0gMHgwRDNBXG52YXIgR0xfTUFYX1ZFUlRFWF9BVFRSSUJTID0gMHg4ODY5XG52YXIgR0xfTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkJcbnZhciBHTF9NQVhfVkFSWUlOR19WRUNUT1JTID0gMHg4REZDXG52YXIgR0xfTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNERcbnZhciBHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNENcbnZhciBHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4ODg3MlxudmFyIEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkRcbnZhciBHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFID0gMHg4NTFDXG52YXIgR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFID0gMHg4NEU4XG5cbnZhciBHTF9WRU5ET1IgPSAweDFGMDBcbnZhciBHTF9SRU5ERVJFUiA9IDB4MUYwMVxudmFyIEdMX1ZFUlNJT04gPSAweDFGMDJcbnZhciBHTF9TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04gPSAweDhCOENcblxudmFyIEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRlxuXG52YXIgR0xfTUFYX0NPTE9SX0FUVEFDSE1FTlRTX1dFQkdMID0gMHg4Q0RGXG52YXIgR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTCA9IDB4ODgyNFxuXG52YXIgR0xfVEVYVFVSRV8yRCA9IDB4MERFMVxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTVcbnZhciBHTF9URVhUVVJFMCA9IDB4ODRDMFxudmFyIEdMX1JHQkEgPSAweDE5MDhcbnZhciBHTF9GTE9BVCQxID0gMHgxNDA2XG52YXIgR0xfVU5TSUdORURfQllURSQxID0gMHgxNDAxXG52YXIgR0xfRlJBTUVCVUZGRVIgPSAweDhENDBcbnZhciBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSA9IDB4OENENVxudmFyIEdMX0NPTE9SX0FUVEFDSE1FTlQwID0gMHg4Q0UwXG52YXIgR0xfQ09MT1JfQlVGRkVSX0JJVCQxID0gMHg0MDAwXG5cbnZhciB3cmFwTGltaXRzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zKSB7XG4gIHZhciBtYXhBbmlzb3Ryb3BpYyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljKSB7XG4gICAgbWF4QW5pc290cm9waWMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKVxuICB9XG5cbiAgdmFyIG1heERyYXdidWZmZXJzID0gMVxuICB2YXIgbWF4Q29sb3JBdHRhY2htZW50cyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzKSB7XG4gICAgbWF4RHJhd2J1ZmZlcnMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTClcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzID0gZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DT0xPUl9BVFRBQ0hNRU5UU19XRUJHTClcbiAgfVxuXG4gIC8vIGRldGVjdCBpZiByZWFkaW5nIGZsb2F0IHRleHR1cmVzIGlzIGF2YWlsYWJsZSAoU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIHJlYWRGbG9hdCA9ICEhZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdFxuICBpZiAocmVhZEZsb2F0KSB7XG4gICAgdmFyIHJlYWRGbG9hdFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlKVxuICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV8yRCwgMCwgR0xfUkdCQSwgMSwgMSwgMCwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgbnVsbClcblxuICAgIHZhciBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSLCBmYm8pXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoR0xfRlJBTUVCVUZGRVIsIEdMX0NPTE9SX0FUVEFDSE1FTlQwLCBHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlLCAwKVxuICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQsIG51bGwpXG5cbiAgICBpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhHTF9GUkFNRUJVRkZFUikgIT09IEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFKSByZWFkRmxvYXQgPSBmYWxzZVxuXG4gICAgZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCAxLCAxKVxuICAgICAgZ2wuY2xlYXJDb2xvcigxLjAsIDAuMCwgMC4wLCAxLjApXG4gICAgICBnbC5jbGVhcihHTF9DT0xPUl9CVUZGRVJfQklUJDEpXG4gICAgICB2YXIgcGl4ZWxzID0gcG9vbC5hbGxvY1R5cGUoR0xfRkxPQVQkMSwgNClcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgcGl4ZWxzKVxuXG4gICAgICBpZiAoZ2wuZ2V0RXJyb3IoKSkgcmVhZEZsb2F0ID0gZmFsc2VcbiAgICAgIGVsc2Uge1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8pXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocmVhZEZsb2F0VGV4dHVyZSlcblxuICAgICAgICByZWFkRmxvYXQgPSBwaXhlbHNbMF0gPT09IDEuMFxuICAgICAgfVxuXG4gICAgICBwb29sLmZyZWVUeXBlKHBpeGVscylcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlY3Qgbm9uIHBvd2VyIG9mIHR3byBjdWJlIHRleHR1cmVzIHN1cHBvcnQgKElFIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIGlzSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL1RyaWRlbnRcXC8vLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pIHx8IC9FZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuXG4gIHZhciBucG90VGV4dHVyZUN1YmUgPSB0cnVlXG5cbiAgaWYgKCFpc0lFKSB7XG4gICAgdmFyIGN1YmVUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgdmFyIGRhdGEgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9CWVRFJDEsIDM2KVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTApXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgY3ViZVRleHR1cmUpXG4gICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDAsIEdMX1JHQkEsIDMsIDMsIDAsIEdMX1JHQkEsIEdMX1VOU0lHTkVEX0JZVEUkMSwgZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgbnVsbClcbiAgICBnbC5kZWxldGVUZXh0dXJlKGN1YmVUZXh0dXJlKVxuICAgIG5wb3RUZXh0dXJlQ3ViZSA9ICFnbC5nZXRFcnJvcigpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRyYXdpbmcgYnVmZmVyIGJpdCBkZXB0aFxuICAgIGNvbG9yQml0czogW1xuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFRF9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9HUkVFTl9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9CTFVFX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0FMUEhBX0JJVFMpXG4gICAgXSxcbiAgICBkZXB0aEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9ERVBUSF9CSVRTKSxcbiAgICBzdGVuY2lsQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX1NURU5DSUxfQklUUyksXG4gICAgc3VicGl4ZWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1VCUElYRUxfQklUUyksXG5cbiAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnM6IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZpbHRlcihmdW5jdGlvbiAoZXh0KSB7XG4gICAgICByZXR1cm4gISFleHRlbnNpb25zW2V4dF1cbiAgICB9KSxcblxuICAgIC8vIG1heCBhbmlzbyBzYW1wbGVzXG4gICAgbWF4QW5pc290cm9waWM6IG1heEFuaXNvdHJvcGljLFxuXG4gICAgLy8gbWF4IGRyYXcgYnVmZmVyc1xuICAgIG1heERyYXdidWZmZXJzOiBtYXhEcmF3YnVmZmVycyxcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzOiBtYXhDb2xvckF0dGFjaG1lbnRzLFxuXG4gICAgLy8gcG9pbnQgYW5kIGxpbmUgc2l6ZSByYW5nZXNcbiAgICBwb2ludFNpemVEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFKSxcbiAgICBsaW5lV2lkdGhEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKSxcbiAgICBtYXhWaWV3cG9ydERpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVklFV1BPUlRfRElNUyksXG4gICAgbWF4Q29tYmluZWRUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4Q3ViZU1hcFNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhSZW5kZXJidWZmZXJTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFKSxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4VGV4dHVyZVNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhBdHRyaWJ1dGVzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZFUlRFWF9BVFRSSUJTKSxcbiAgICBtYXhWZXJ0ZXhVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSxcbiAgICBtYXhWZXJ0ZXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgIG1heFZhcnlpbmdWZWN0b3JzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZBUllJTkdfVkVDVE9SUyksXG4gICAgbWF4RnJhZ21lbnRVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxuXG4gICAgLy8gdmVuZG9yIGluZm9cbiAgICBnbHNsOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKSxcbiAgICByZW5kZXJlcjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFTkRFUkVSKSxcbiAgICB2ZW5kb3I6IGdsLmdldFBhcmFtZXRlcihHTF9WRU5ET1IpLFxuICAgIHZlcnNpb246IGdsLmdldFBhcmFtZXRlcihHTF9WRVJTSU9OKSxcblxuICAgIC8vIHF1aXJrc1xuICAgIHJlYWRGbG9hdDogcmVhZEZsb2F0LFxuICAgIG5wb3RUZXh0dXJlQ3ViZTogbnBvdFRleHR1cmVDdWJlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOREFycmF5TGlrZSAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgISFvYmogJiZcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnNoYXBlKSAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnN0cmlkZSkgJiZcbiAgICB0eXBlb2Ygb2JqLm9mZnNldCA9PT0gJ251bWJlcicgJiZcbiAgICBvYmouc2hhcGUubGVuZ3RoID09PSBvYmouc3RyaWRlLmxlbmd0aCAmJlxuICAgIChBcnJheS5pc0FycmF5KG9iai5kYXRhKSB8fFxuICAgICAgaXNUeXBlZEFycmF5KG9iai5kYXRhKSkpXG59XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XSB9KVxufVxuXG52YXIgZmxhdHRlblV0aWxzID0ge1xuICBzaGFwZTogYXJyYXlTaGFwZSQxLFxuICBmbGF0dGVuOiBmbGF0dGVuQXJyYXlcbn07XG5cbmZ1bmN0aW9uIGZsYXR0ZW4xRCAoYXJyYXksIG54LCBvdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBueDsgKytpKSB7XG4gICAgb3V0W2ldID0gYXJyYXlbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuMkQgKGFycmF5LCBueCwgbnksIG91dCkge1xuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcbiAgICB2YXIgcm93ID0gYXJyYXlbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG55OyArK2opIHtcbiAgICAgIG91dFtwdHIrK10gPSByb3dbal1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbjNEIChhcnJheSwgbngsIG55LCBueiwgb3V0LCBwdHJfKSB7XG4gIHZhciBwdHIgPSBwdHJfXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbng7ICsraSkge1xuICAgIHZhciByb3cgPSBhcnJheVtpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnk7ICsraikge1xuICAgICAgdmFyIGNvbCA9IHJvd1tqXVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuejsgKytrKSB7XG4gICAgICAgIG91dFtwdHIrK10gPSBjb2xba11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlblJlYyAoYXJyYXksIHNoYXBlLCBsZXZlbCwgb3V0LCBwdHIpIHtcbiAgdmFyIHN0cmlkZSA9IDFcbiAgZm9yICh2YXIgaSA9IGxldmVsICsgMTsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgc3RyaWRlICo9IHNoYXBlW2ldXG4gIH1cbiAgdmFyIG4gPSBzaGFwZVtsZXZlbF1cbiAgaWYgKHNoYXBlLmxlbmd0aCAtIGxldmVsID09PSA0KSB7XG4gICAgdmFyIG54ID0gc2hhcGVbbGV2ZWwgKyAxXVxuICAgIHZhciBueSA9IHNoYXBlW2xldmVsICsgMl1cbiAgICB2YXIgbnogPSBzaGFwZVtsZXZlbCArIDNdXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlbjNEKGFycmF5W2ldLCBueCwgbnksIG56LCBvdXQsIHB0cilcbiAgICAgIHB0ciArPSBzdHJpZGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlblJlYyhhcnJheVtpXSwgc2hhcGUsIGxldmVsICsgMSwgb3V0LCBwdHIpXG4gICAgICBwdHIgKz0gc3RyaWRlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSAoYXJyYXksIHNoYXBlLCB0eXBlLCBvdXRfKSB7XG4gIHZhciBzeiA9IDFcbiAgaWYgKHNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN6ID0gMFxuICB9XG4gIHZhciBvdXQgPSBvdXRfIHx8IHBvb2wuYWxsb2NUeXBlKHR5cGUsIHN6KVxuICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgZmxhdHRlbjFEKGFycmF5LCBzaGFwZVswXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6XG4gICAgICBmbGF0dGVuMkQoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDM6XG4gICAgICBmbGF0dGVuM0QoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgc2hhcGVbMl0sIG91dCwgMClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGZsYXR0ZW5SZWMoYXJyYXksIHNoYXBlLCAwLCBvdXQsIDApXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBhcnJheVNoYXBlJDEgKGFycmF5Xykge1xuICB2YXIgc2hhcGUgPSBbXVxuICBmb3IgKHZhciBhcnJheSA9IGFycmF5XzsgYXJyYXkubGVuZ3RoOyBhcnJheSA9IGFycmF5WzBdKSB7XG4gICAgc2hhcGUucHVzaChhcnJheS5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHNoYXBlXG59XG5cbnZhciBhcnJheVR5cGVzID0gIHtcblx0XCJbb2JqZWN0IEludDhBcnJheV1cIjogNTEyMCxcblx0XCJbb2JqZWN0IEludDE2QXJyYXldXCI6IDUxMjIsXG5cdFwiW29iamVjdCBJbnQzMkFycmF5XVwiOiA1MTI0LFxuXHRcIltvYmplY3QgVWludDhBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOiA1MTIxLFxuXHRcIltvYmplY3QgVWludDE2QXJyYXldXCI6IDUxMjMsXG5cdFwiW29iamVjdCBVaW50MzJBcnJheV1cIjogNTEyNSxcblx0XCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjogNTEyNixcblx0XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiOiA1MTIxXG59O1xuXG52YXIgaW50OCA9IDUxMjA7XG52YXIgaW50MTYgPSA1MTIyO1xudmFyIGludDMyID0gNTEyNDtcbnZhciB1aW50OCA9IDUxMjE7XG52YXIgdWludDE2ID0gNTEyMztcbnZhciB1aW50MzIgPSA1MTI1O1xudmFyIGZsb2F0ID0gNTEyNjtcbnZhciBmbG9hdDMyID0gNTEyNjtcbnZhciBnbFR5cGVzID0ge1xuXHRpbnQ4OiBpbnQ4LFxuXHRpbnQxNjogaW50MTYsXG5cdGludDMyOiBpbnQzMixcblx0dWludDg6IHVpbnQ4LFxuXHR1aW50MTY6IHVpbnQxNixcblx0dWludDMyOiB1aW50MzIsXG5cdGZsb2F0OiBmbG9hdCxcblx0ZmxvYXQzMjogZmxvYXQzMlxufTtcblxudmFyIGR5bmFtaWMkMSA9IDM1MDQ4O1xudmFyIHN0cmVhbSA9IDM1MDQwO1xudmFyIHVzYWdlVHlwZXMgPSB7XG5cdGR5bmFtaWM6IGR5bmFtaWMkMSxcblx0c3RyZWFtOiBzdHJlYW0sXG5cdFwic3RhdGljXCI6IDM1MDQ0XG59O1xuXG52YXIgYXJyYXlGbGF0dGVuID0gZmxhdHRlblV0aWxzLmZsYXR0ZW5cbnZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlXG5cbnZhciBHTF9TVEFUSUNfRFJBVyA9IDB4ODhFNFxudmFyIEdMX1NUUkVBTV9EUkFXID0gMHg4OEUwXG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDMgPSA1MTIxXG52YXIgR0xfRkxPQVQkMyA9IDUxMjZcblxudmFyIERUWVBFU19TSVpFUyA9IFtdXG5EVFlQRVNfU0laRVNbNTEyMF0gPSAxIC8vIGludDhcbkRUWVBFU19TSVpFU1s1MTIyXSA9IDIgLy8gaW50MTZcbkRUWVBFU19TSVpFU1s1MTI0XSA9IDQgLy8gaW50MzJcbkRUWVBFU19TSVpFU1s1MTIxXSA9IDEgLy8gdWludDhcbkRUWVBFU19TSVpFU1s1MTIzXSA9IDIgLy8gdWludDE2XG5EVFlQRVNfU0laRVNbNTEyNV0gPSA0IC8vIHVpbnQzMlxuRFRZUEVTX1NJWkVTWzUxMjZdID0gNCAvLyBmbG9hdDMyXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlDb2RlIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheSAob3V0LCBpbnApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaV0gPSBpbnBbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2UgKFxuICByZXN1bHQsIGRhdGEsIHNoYXBlWCwgc2hhcGVZLCBzdHJpZGVYLCBzdHJpZGVZLCBvZmZzZXQpIHtcbiAgdmFyIHB0ciA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZVg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGVZOyArK2opIHtcbiAgICAgIHJlc3VsdFtwdHIrK10gPSBkYXRhW3N0cmlkZVggKiBpICsgc3RyaWRlWSAqIGogKyBvZmZzZXRdXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBCdWZmZXJTdGF0ZSAoZ2wsIHN0YXRzLCBjb25maWcsIGRlc3Ryb3lCdWZmZXIpIHtcbiAgdmFyIGJ1ZmZlckNvdW50ID0gMFxuICB2YXIgYnVmZmVyU2V0ID0ge31cblxuICBmdW5jdGlvbiBSRUdMQnVmZmVyICh0eXBlKSB7XG4gICAgdGhpcy5pZCA9IGJ1ZmZlckNvdW50KytcbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDBcbiAgICB0aGlzLmRpbWVuc2lvbiA9IDFcbiAgICB0aGlzLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG5cbiAgICB0aGlzLnBlcnNpc3RlbnREYXRhID0gbnVsbFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcilcbiAgfVxuXG4gIFJFR0xCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG5cbiAgdmFyIHN0cmVhbVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAodHlwZSwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSBzdHJlYW1Qb29sLnBvcCgpXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKHR5cGUpXG4gICAgfVxuICAgIGJ1ZmZlci5iaW5kKClcbiAgICBpbml0QnVmZmVyRnJvbURhdGEoYnVmZmVyLCBkYXRhLCBHTF9TVFJFQU1fRFJBVywgMCwgMSwgZmFsc2UpXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVN0cmVhbSAoc3RyZWFtJCQxKSB7XG4gICAgc3RyZWFtUG9vbC5wdXNoKHN0cmVhbSQkMSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheSAoYnVmZmVyLCBkYXRhLCB1c2FnZSkge1xuICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgZGF0YSwgdXNhZ2UpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0QnVmZmVyRnJvbURhdGEgKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3QpIHtcbiAgICB2YXIgc2hhcGVcbiAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9GTE9BVCQzXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBmbGF0RGF0YVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgICAgIHNoYXBlID0gYXJyYXlTaGFwZShkYXRhKVxuICAgICAgICAgIHZhciBkaW0gPSAxXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZGltICo9IHNoYXBlW2ldXG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1cbiAgICAgICAgICBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIGZsYXREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gZmxhdERhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgICAgIHZhciB0eXBlZERhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgIGNvcHlBcnJheSh0eXBlZERhdGEsIGRhdGEpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgdHlwZWREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHlwZWREYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVR5cGUodHlwZWREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YVswXSkpIHtcbiAgICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGF0YVswXS5sZW5ndGhcbiAgICAgICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhWzBdKSB8fCBHTF9GTE9BVCQzXG4gICAgICAgICAgZmxhdERhdGEgPSBhcnJheUZsYXR0ZW4oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgW2RhdGEubGVuZ3RoLCBkYXRhWzBdLmxlbmd0aF0sXG4gICAgICAgICAgICBidWZmZXIuZHR5cGUpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKVxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBmbGF0RGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGZsYXREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhKVxuICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZGF0YSwgdXNhZ2UpXG4gICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBuZXcgVWludDhBcnJheShuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc05EQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgICBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIG9mZnNldCA9IGRhdGEub2Zmc2V0XG5cbiAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICB2YXIgc2hhcGVZID0gMFxuICAgICAgdmFyIHN0cmlkZVggPSAwXG4gICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSAwXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzaGFwZVggPSBzaGFwZVswXVxuICAgICAgICBzaGFwZVkgPSBzaGFwZVsxXVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSBzdHJpZGVbMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpIHx8IEdMX0ZMT0FUJDNcbiAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBzaGFwZVlcblxuICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIHNoYXBlWCAqIHNoYXBlWSlcbiAgICAgIHRyYW5zcG9zZSh0cmFuc3Bvc2VEYXRhLFxuICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgIHNoYXBlWCwgc2hhcGVZLFxuICAgICAgICBzdHJpZGVYLCBzdHJpZGVZLFxuICAgICAgICBvZmZzZXQpXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCB0cmFuc3Bvc2VEYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IHRyYW5zcG9zZURhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnVmZmVyLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG4gICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBkYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRhdGEpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95IChidWZmZXIpIHtcbiAgICBzdGF0cy5idWZmZXJDb3VudC0tXG5cbiAgICAvLyByZW1vdmUgYXR0cmlidXRlIGxpbmtcbiAgICBkZXN0cm95QnVmZmVyKGJ1ZmZlcilcblxuICAgIHZhciBoYW5kbGUgPSBidWZmZXIuYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdidWZmZXIgbXVzdCBub3QgYmUgZGVsZXRlZCBhbHJlYWR5JylcbiAgICBnbC5kZWxldGVCdWZmZXIoaGFuZGxlKVxuICAgIGJ1ZmZlci5idWZmZXIgPSBudWxsXG4gICAgZGVsZXRlIGJ1ZmZlclNldFtidWZmZXIuaWRdXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKG9wdGlvbnMsIHR5cGUsIGRlZmVySW5pdCwgcGVyc2lzdGVudCkge1xuICAgIHN0YXRzLmJ1ZmZlckNvdW50KytcblxuICAgIHZhciBidWZmZXIgPSBuZXcgUkVHTEJ1ZmZlcih0eXBlKVxuICAgIGJ1ZmZlclNldFtidWZmZXIuaWRdID0gYnVmZmVyXG5cbiAgICBmdW5jdGlvbiByZWdsQnVmZmVyIChvcHRpb25zKSB7XG4gICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgICAgdmFyIGRhdGEgPSBudWxsXG4gICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgIHZhciBkdHlwZSA9IDBcbiAgICAgIHZhciBkaW1lbnNpb24gPSAxXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzVHlwZWRBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzTkRBcnJheUxpa2Uob3B0aW9ucykgfHxcbiAgICAgICAgICBvcHRpb25zIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zIHwgMFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBvcHRpb25zLCAnb2JqZWN0JyxcbiAgICAgICAgICAnYnVmZmVyIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdCwgYSBudW1iZXIgb3IgYW4gYXJyYXknKVxuXG4gICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBkYXRhID09PSBudWxsIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICBpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBidWZmZXInKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLnVzYWdlLCB1c2FnZVR5cGVzLCAnaW52YWxpZCBidWZmZXIgdXNhZ2UnKVxuICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy50eXBlLCBnbFR5cGVzLCAnaW52YWxpZCBidWZmZXIgdHlwZScpXG4gICAgICAgICAgZHR5cGUgPSBnbFR5cGVzW29wdGlvbnMudHlwZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGltZW5zaW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZGltZW5zaW9uLCAnbnVtYmVyJywgJ2ludmFsaWQgZGltZW5zaW9uJylcbiAgICAgICAgICBkaW1lbnNpb24gPSBvcHRpb25zLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5ubmkoYnl0ZUxlbmd0aCwgJ2J1ZmZlciBsZW5ndGggbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuYmluZCgpXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gIzQ3NVxuICAgICAgICBpZiAoYnl0ZUxlbmd0aCkgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkM1xuICAgICAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdEJ1ZmZlckZyb21EYXRhKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3RlbnQpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICBidWZmZXIuc3RhdHMuc2l6ZSA9IGJ1ZmZlci5ieXRlTGVuZ3RoICogRFRZUEVTX1NJWkVTW2J1ZmZlci5kdHlwZV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTdWJEYXRhIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGNoZWNrJDEob2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoIDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAnaW52YWxpZCBidWZmZXIgc3ViZGF0YSBjYWxsLCBidWZmZXIgaXMgdG9vIHNtYWxsLiAnICsgJyBDYW5cXCd0IHdyaXRlIGRhdGEgb2Ygc2l6ZSAnICsgZGF0YS5ieXRlTGVuZ3RoICsgJyBzdGFydGluZyBmcm9tIG9mZnNldCAnICsgb2Zmc2V0ICsgJyB0byBhIGJ1ZmZlciBvZiBzaXplICcgKyBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgb2Zmc2V0LCBkYXRhKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmRhdGEgKGRhdGEsIG9mZnNldF8pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAob2Zmc2V0XyB8fCAwKSB8IDBcbiAgICAgIHZhciBzaGFwZVxuICAgICAgYnVmZmVyLmJpbmQoKVxuICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSB8fCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgc2V0U3ViRGF0YShkYXRhLCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgY29weUFycmF5KGNvbnZlcnRlZCwgZGF0YSlcbiAgICAgICAgICAgIHNldFN1YkRhdGEoY29udmVydGVkLCBvZmZzZXQpXG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGNvbnZlcnRlZClcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXSkgfHwgaXNUeXBlZEFycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgICBzaGFwZSA9IGFycmF5U2hhcGUoZGF0YSlcbiAgICAgICAgICAgIHZhciBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgICAgc2V0U3ViRGF0YShmbGF0RGF0YSwgb2Zmc2V0KVxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBidWZmZXIgZGF0YScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcbiAgICAgICAgc2hhcGUgPSBkYXRhLnNoYXBlXG4gICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuXG4gICAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICAgIHZhciBzaGFwZVkgPSAwXG4gICAgICAgIHZhciBzdHJpZGVYID0gMFxuICAgICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgICBzdHJpZGVZID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gc2hhcGVbMV1cbiAgICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKVxuICAgICAgICAgID8gYnVmZmVyLmR0eXBlXG4gICAgICAgICAgOiB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpXG5cbiAgICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShkdHlwZSwgc2hhcGVYICogc2hhcGVZKVxuICAgICAgICB0cmFuc3Bvc2UodHJhbnNwb3NlRGF0YSxcbiAgICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgICAgc2hhcGVYLCBzaGFwZVksXG4gICAgICAgICAgc3RyaWRlWCwgc3RyaWRlWSxcbiAgICAgICAgICBkYXRhLm9mZnNldClcbiAgICAgICAgc2V0U3ViRGF0YSh0cmFuc3Bvc2VEYXRhLCBvZmZzZXQpXG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgYnVmZmVyIHN1YmRhdGEnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAoIWRlZmVySW5pdCkge1xuICAgICAgcmVnbEJ1ZmZlcihvcHRpb25zKVxuICAgIH1cblxuICAgIHJlZ2xCdWZmZXIuX3JlZ2xUeXBlID0gJ2J1ZmZlcidcbiAgICByZWdsQnVmZmVyLl9idWZmZXIgPSBidWZmZXJcbiAgICByZWdsQnVmZmVyLnN1YmRhdGEgPSBzdWJkYXRhXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICByZWdsQnVmZmVyLnN0YXRzID0gYnVmZmVyLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xCdWZmZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgZGVzdHJveShidWZmZXIpIH1cblxuICAgIHJldHVybiByZWdsQnVmZmVyXG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlQnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICBidWZmZXIuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGJ1ZmZlci5idWZmZXIpXG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBidWZmZXIudHlwZSwgYnVmZmVyLnBlcnNpc3RlbnREYXRhIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIudXNhZ2UpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdywgdGhlIHN0cmVhbXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSB0b3RhbCBjb3VudC5cbiAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IGJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlQnVmZmVyLFxuXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0sXG4gICAgZGVzdHJveVN0cmVhbTogZGVzdHJveVN0cmVhbSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWx1ZXMoYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG4gICAgICBzdHJlYW1Qb29sLmZvckVhY2goZGVzdHJveSlcbiAgICB9LFxuXG4gICAgZ2V0QnVmZmVyOiBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgJiYgd3JhcHBlci5fYnVmZmVyIGluc3RhbmNlb2YgUkVHTEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5fYnVmZmVyXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlQnVmZmVycyxcblxuICAgIF9pbml0QnVmZmVyOiBpbml0QnVmZmVyRnJvbURhdGFcbiAgfVxufVxuXG52YXIgcG9pbnRzID0gMDtcbnZhciBwb2ludCA9IDA7XG52YXIgbGluZXMgPSAxO1xudmFyIGxpbmUgPSAxO1xudmFyIHRyaWFuZ2xlcyA9IDQ7XG52YXIgdHJpYW5nbGUgPSA0O1xudmFyIHByaW1UeXBlcyA9IHtcblx0cG9pbnRzOiBwb2ludHMsXG5cdHBvaW50OiBwb2ludCxcblx0bGluZXM6IGxpbmVzLFxuXHRsaW5lOiBsaW5lLFxuXHR0cmlhbmdsZXM6IHRyaWFuZ2xlcyxcblx0dHJpYW5nbGU6IHRyaWFuZ2xlLFxuXHRcImxpbmUgbG9vcFwiOiAyLFxuXHRcImxpbmUgc3RyaXBcIjogMyxcblx0XCJ0cmlhbmdsZSBzdHJpcFwiOiA1LFxuXHRcInRyaWFuZ2xlIGZhblwiOiA2XG59O1xuXG52YXIgR0xfUE9JTlRTID0gMFxudmFyIEdMX0xJTkVTID0gMVxudmFyIEdMX1RSSUFOR0xFUyA9IDRcblxudmFyIEdMX0JZVEUkMiA9IDUxMjBcbnZhciBHTF9VTlNJR05FRF9CWVRFJDQgPSA1MTIxXG52YXIgR0xfU0hPUlQkMiA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQyID0gNTEyM1xudmFyIEdMX0lOVCQyID0gNTEyNFxudmFyIEdMX1VOU0lHTkVEX0lOVCQyID0gNTEyNVxuXG52YXIgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2M1xuXG52YXIgR0xfU1RSRUFNX0RSQVckMSA9IDB4ODhFMFxudmFyIEdMX1NUQVRJQ19EUkFXJDEgPSAweDg4RTRcblxuZnVuY3Rpb24gd3JhcEVsZW1lbnRzU3RhdGUgKGdsLCBleHRlbnNpb25zLCBidWZmZXJTdGF0ZSwgc3RhdHMpIHtcbiAgdmFyIGVsZW1lbnRTZXQgPSB7fVxuICB2YXIgZWxlbWVudENvdW50ID0gMFxuXG4gIHZhciBlbGVtZW50VHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ0LFxuICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50KSB7XG4gICAgZWxlbWVudFR5cGVzLnVpbnQzMiA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gIH1cblxuICBmdW5jdGlvbiBSRUdMRWxlbWVudEJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgdGhpcy5pZCA9IGVsZW1lbnRDb3VudCsrXG4gICAgZWxlbWVudFNldFt0aGlzLmlkXSA9IHRoaXNcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlclxuICAgIHRoaXMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICB0aGlzLnZlcnRDb3VudCA9IDBcbiAgICB0aGlzLnR5cGUgPSAwXG4gIH1cblxuICBSRUdMRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1ZmZlci5iaW5kKClcbiAgfVxuXG4gIHZhciBidWZmZXJQb29sID0gW11cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50U3RyZWFtIChkYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJ1ZmZlclBvb2wucG9wKClcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbmV3IFJFR0xFbGVtZW50QnVmZmVyKGJ1ZmZlclN0YXRlLmNyZWF0ZShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlKS5fYnVmZmVyKVxuICAgIH1cbiAgICBpbml0RWxlbWVudHMocmVzdWx0LCBkYXRhLCBHTF9TVFJFQU1fRFJBVyQxLCAtMSwgLTEsIDAsIDApXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnRTdHJlYW0gKGVsZW1lbnRzKSB7XG4gICAgYnVmZmVyUG9vbC5wdXNoKGVsZW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEVsZW1lbnRzIChcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhLFxuICAgIHVzYWdlLFxuICAgIHByaW0sXG4gICAgY291bnQsXG4gICAgYnl0ZUxlbmd0aCxcbiAgICB0eXBlKSB7XG4gICAgZWxlbWVudHMuYnVmZmVyLmJpbmQoKVxuICAgIHZhciBkdHlwZVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgcHJlZGljdGVkVHlwZSA9IHR5cGVcbiAgICAgIGlmICghdHlwZSAmJiAoXG4gICAgICAgICFpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgIChpc05EQXJyYXlMaWtlKGRhdGEpICYmICFpc1R5cGVkQXJyYXkoZGF0YS5kYXRhKSkpKSB7XG4gICAgICAgIHByZWRpY3RlZFR5cGUgPSBleHRlbnNpb25zLm9lc19lbGVtZW50X2luZGV4X3VpbnRcbiAgICAgICAgICA/IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gICAgICB9XG4gICAgICBidWZmZXJTdGF0ZS5faW5pdEJ1ZmZlcihcbiAgICAgICAgZWxlbWVudHMuYnVmZmVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgcHJlZGljdGVkVHlwZSxcbiAgICAgICAgMylcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYnVmZmVyRGF0YShHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICBlbGVtZW50cy5idWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci51c2FnZSA9IHVzYWdlXG4gICAgICBlbGVtZW50cy5idWZmZXIuZGltZW5zaW9uID0gM1xuICAgICAgZWxlbWVudHMuYnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG4gICAgfVxuXG4gICAgZHR5cGUgPSB0eXBlXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICBzd2l0Y2ggKGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSkge1xuICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0JZVEUkNDpcbiAgICAgICAgY2FzZSBHTF9CWVRFJDI6XG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfVU5TSUdORURfU0hPUlQkMjpcbiAgICAgICAgY2FzZSBHTF9TSE9SVCQyOlxuICAgICAgICAgIGR0eXBlID0gR0xfVU5TSUdORURfU0hPUlQkMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMjpcbiAgICAgICAgY2FzZSBHTF9JTlQkMjpcbiAgICAgICAgICBkdHlwZSA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yIGVsZW1lbnQgYXJyYXknKVxuICAgICAgfVxuICAgICAgZWxlbWVudHMuYnVmZmVyLmR0eXBlID0gZHR5cGVcbiAgICB9XG4gICAgZWxlbWVudHMudHlwZSA9IGR0eXBlXG5cbiAgICAvLyBDaGVjayBvZXNfZWxlbWVudF9pbmRleF91aW50IGV4dGVuc2lvblxuICAgIGNoZWNrJDEoXG4gICAgICBkdHlwZSAhPT0gR0xfVU5TSUdORURfSU5UJDIgfHxcbiAgICAgICEhZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50LFxuICAgICAgJzMyIGJpdCBlbGVtZW50IGJ1ZmZlcnMgbm90IHN1cHBvcnRlZCwgZW5hYmxlIG9lc19lbGVtZW50X2luZGV4X3VpbnQgZmlyc3QnKVxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIGRlZmF1bHQgcHJpbWl0aXZlIHR5cGUgYW5kIGFyZ3VtZW50c1xuICAgIHZhciB2ZXJ0Q291bnQgPSBjb3VudFxuICAgIGlmICh2ZXJ0Q291bnQgPCAwKSB7XG4gICAgICB2ZXJ0Q291bnQgPSBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVCQyKSB7XG4gICAgICAgIHZlcnRDb3VudCA+Pj0gMVxuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gR0xfVU5TSUdORURfSU5UJDIpIHtcbiAgICAgICAgdmVydENvdW50ID4+PSAyXG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IHZlcnRDb3VudFxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIHByaW1pdGl2ZSB0eXBlIGZyb20gY2VsbCBkaW1lbnNpb25cbiAgICB2YXIgcHJpbVR5cGUgPSBwcmltXG4gICAgaWYgKHByaW0gPCAwKSB7XG4gICAgICBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IGVsZW1lbnRzLmJ1ZmZlci5kaW1lbnNpb25cbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHByaW1UeXBlID0gR0xfUE9JTlRTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAyKSBwcmltVHlwZSA9IEdMX0xJTkVTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAzKSBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgIH1cbiAgICBlbGVtZW50cy5wcmltVHlwZSA9IHByaW1UeXBlXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95RWxlbWVudHMgKGVsZW1lbnRzKSB7XG4gICAgc3RhdHMuZWxlbWVudHNDb3VudC0tXG5cbiAgICBjaGVjayQxKGVsZW1lbnRzLmJ1ZmZlciAhPT0gbnVsbCwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IGVsZW1lbnRzJylcbiAgICBkZWxldGUgZWxlbWVudFNldFtlbGVtZW50cy5pZF1cbiAgICBlbGVtZW50cy5idWZmZXIuZGVzdHJveSgpXG4gICAgZWxlbWVudHMuYnVmZmVyID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMgKG9wdGlvbnMsIHBlcnNpc3RlbnQpIHtcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyU3RhdGUuY3JlYXRlKG51bGwsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCB0cnVlKVxuICAgIHZhciBlbGVtZW50cyA9IG5ldyBSRUdMRWxlbWVudEJ1ZmZlcihidWZmZXIuX2J1ZmZlcilcbiAgICBzdGF0cy5lbGVtZW50c0NvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xFbGVtZW50cyAob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGJ1ZmZlcigpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IDBcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnVmZmVyKG9wdGlvbnMpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IG9wdGlvbnMgfCAwXG4gICAgICAgIGVsZW1lbnRzLnR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gbnVsbFxuICAgICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBVyQxXG4gICAgICAgIHZhciBwcmltVHlwZSA9IC0xXG4gICAgICAgIHZhciB2ZXJ0Q291bnQgPSAtMVxuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgICAgdmFyIGR0eXBlID0gMFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgICBpc05EQXJyYXlMaWtlKG9wdGlvbnMpKSB7XG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZWxlbWVudHMnKVxuICAgICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzVHlwZWRBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGVsZW1lbnQgYnVmZmVyJylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd1c2FnZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMudXNhZ2UsXG4gICAgICAgICAgICAgIHVzYWdlVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHVzYWdlJylcbiAgICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3ByaW1pdGl2ZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMucHJpbWl0aXZlLFxuICAgICAgICAgICAgICBwcmltVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHByaW1pdGl2ZScpXG4gICAgICAgICAgICBwcmltVHlwZSA9IHByaW1UeXBlc1tvcHRpb25zLnByaW1pdGl2ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY291bnQgPT09ICdudW1iZXInICYmIG9wdGlvbnMuY291bnQgPj0gMCxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50IGZvciBlbGVtZW50cycpXG4gICAgICAgICAgICB2ZXJ0Q291bnQgPSBvcHRpb25zLmNvdW50IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKFxuICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlcyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgZHR5cGUgPSBlbGVtZW50VHlwZXNbb3B0aW9ucy50eXBlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHwgMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdmVydENvdW50XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUJDIgfHwgZHR5cGUgPT09IEdMX1NIT1JUJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSAyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMiB8fCBkdHlwZSA9PT0gR0xfSU5UJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSA0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXRFbGVtZW50cyhcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHByaW1UeXBlLFxuICAgICAgICAgIHZlcnRDb3VudCxcbiAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgIGR0eXBlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gICAgfVxuXG4gICAgcmVnbEVsZW1lbnRzKG9wdGlvbnMpXG5cbiAgICByZWdsRWxlbWVudHMuX3JlZ2xUeXBlID0gJ2VsZW1lbnRzJ1xuICAgIHJlZ2xFbGVtZW50cy5fZWxlbWVudHMgPSBlbGVtZW50c1xuICAgIHJlZ2xFbGVtZW50cy5zdWJkYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgYnVmZmVyLnN1YmRhdGEoZGF0YSwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIHJlZ2xFbGVtZW50c1xuICAgIH1cbiAgICByZWdsRWxlbWVudHMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlc3Ryb3lFbGVtZW50cyhlbGVtZW50cylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlRWxlbWVudHMsXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVFbGVtZW50U3RyZWFtLFxuICAgIGRlc3Ryb3lTdHJlYW06IGRlc3Ryb3lFbGVtZW50U3RyZWFtLFxuICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBlbGVtZW50cy5fZWxlbWVudHMgaW5zdGFuY2VvZiBSRUdMRWxlbWVudEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuX2VsZW1lbnRzXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhlbGVtZW50U2V0KS5mb3JFYWNoKGRlc3Ryb3lFbGVtZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIEZMT0FUID0gbmV3IEZsb2F0MzJBcnJheSgxKVxudmFyIElOVCA9IG5ldyBVaW50MzJBcnJheShGTE9BVC5idWZmZXIpXG5cbnZhciBHTF9VTlNJR05FRF9TSE9SVCQ0ID0gNTEyM1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9IYWxmRmxvYXQgKGFycmF5KSB7XG4gIHZhciB1c2hvcnRzID0gcG9vbC5hbGxvY1R5cGUoR0xfVU5TSUdORURfU0hPUlQkNCwgYXJyYXkubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oYXJyYXlbaV0pKSB7XG4gICAgICB1c2hvcnRzW2ldID0gMHhmZmZmXG4gICAgfSBlbHNlIGlmIChhcnJheVtpXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweDdjMDBcbiAgICB9IGVsc2UgaWYgKGFycmF5W2ldID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZjMDBcbiAgICB9IGVsc2Uge1xuICAgICAgRkxPQVRbMF0gPSBhcnJheVtpXVxuICAgICAgdmFyIHggPSBJTlRbMF1cblxuICAgICAgdmFyIHNnbiA9ICh4ID4+PiAzMSkgPDwgMTVcbiAgICAgIHZhciBleHAgPSAoKHggPDwgMSkgPj4+IDI0KSAtIDEyN1xuICAgICAgdmFyIGZyYWMgPSAoeCA+PiAxMykgJiAoKDEgPDwgMTApIC0gMSlcblxuICAgICAgaWYgKGV4cCA8IC0yNCkge1xuICAgICAgICAvLyByb3VuZCBub24tcmVwcmVzZW50YWJsZSBkZW5vcm1hbHMgdG8gMFxuICAgICAgICB1c2hvcnRzW2ldID0gc2duXG4gICAgICB9IGVsc2UgaWYgKGV4cCA8IC0xNCkge1xuICAgICAgICAvLyBoYW5kbGUgZGVub3JtYWxzXG4gICAgICAgIHZhciBzID0gLTE0IC0gZXhwXG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAoKGZyYWMgKyAoMSA8PCAxMCkpID4+IHMpXG4gICAgICB9IGVsc2UgaWYgKGV4cCA+IDE1KSB7XG4gICAgICAgIC8vIHJvdW5kIG92ZXJmbG93IHRvICsvLSBJbmZpbml0eVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgMHg3YzAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgY29udmVydCBkaXJlY3RseVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgKChleHAgKyAxNSkgPDwgMTApICsgZnJhY1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1c2hvcnRzXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlIChzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpIHx8IGlzVHlwZWRBcnJheShzKVxufVxuXG52YXIgaXNQb3cyJDEgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gISh2ICYgKHYgLSAxKSkgJiYgKCEhdilcbn1cblxudmFyIEdMX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTID0gMHg4NkEzXG5cbnZhciBHTF9URVhUVVJFXzJEJDEgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQJDEgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSA9IDB4ODUxNVxuXG52YXIgR0xfUkdCQSQxID0gMHgxOTA4XG52YXIgR0xfQUxQSEEgPSAweDE5MDZcbnZhciBHTF9SR0IgPSAweDE5MDdcbnZhciBHTF9MVU1JTkFOQ0UgPSAweDE5MDlcbnZhciBHTF9MVU1JTkFOQ0VfQUxQSEEgPSAweDE5MEFcblxudmFyIEdMX1JHQkE0ID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSA9IDB4ODA1N1xudmFyIEdMX1JHQjU2NSA9IDB4OEQ2MlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCQxID0gMHg4MDMzXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSQxID0gMHg4MDM0XG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMJDEgPSAweDg0RkFcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMlxudmFyIEdMX0RFUFRIX1NURU5DSUwgPSAweDg0RjlcblxudmFyIEdMX1NSR0JfRVhUID0gMHg4QzQwXG52YXIgR0xfU1JHQl9BTFBIQV9FWFQgPSAweDhDNDJcblxudmFyIEdMX0hBTEZfRkxPQVRfT0VTJDEgPSAweDhENjFcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgPSAweDgzRjBcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMVxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUID0gMHg4M0YyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgPSAweDgzRjNcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTCA9IDB4OEM5MlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0wgPSAweDhDOTNcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTCA9IDB4ODdFRVxuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMFxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUcgPSAweDhDMDFcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HID0gMHg4QzAzXG5cbnZhciBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMID0gMHg4RDY0XG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDUgPSAweDE0MDFcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQzID0gMHgxNDAzXG52YXIgR0xfVU5TSUdORURfSU5UJDMgPSAweDE0MDVcbnZhciBHTF9GTE9BVCQ0ID0gMHgxNDA2XG5cbnZhciBHTF9URVhUVVJFX1dSQVBfUyA9IDB4MjgwMlxudmFyIEdMX1RFWFRVUkVfV1JBUF9UID0gMHgyODAzXG5cbnZhciBHTF9SRVBFQVQgPSAweDI5MDFcbnZhciBHTF9DTEFNUF9UT19FREdFJDEgPSAweDgxMkZcbnZhciBHTF9NSVJST1JFRF9SRVBFQVQgPSAweDgzNzBcblxudmFyIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMFxudmFyIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMVxuXG52YXIgR0xfTkVBUkVTVCQxID0gMHgyNjAwXG52YXIgR0xfTElORUFSID0gMHgyNjAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEgPSAweDI3MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSA9IDB4MjcwMlxudmFyIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDEgPSAweDI3MDNcblxudmFyIEdMX0dFTkVSQVRFX01JUE1BUF9ISU5UID0gMHg4MTkyXG52YXIgR0xfRE9OVF9DQVJFID0gMHgxMTAwXG52YXIgR0xfRkFTVEVTVCA9IDB4MTEwMVxudmFyIEdMX05JQ0VTVCA9IDB4MTEwMlxuXG52YXIgR0xfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgPSAweDg0RkVcblxudmFyIEdMX1VOUEFDS19BTElHTk1FTlQgPSAweDBDRjVcbnZhciBHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMID0gMHg5MjQwXG52YXIgR0xfVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMID0gMHg5MjQxXG52YXIgR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCA9IDB4OTI0M1xuXG52YXIgR0xfQlJPV1NFUl9ERUZBVUxUX1dFQkdMID0gMHg5MjQ0XG5cbnZhciBHTF9URVhUVVJFMCQxID0gMHg4NEMwXG5cbnZhciBNSVBNQVBfRklMVEVSUyA9IFtcbiAgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxLFxuICBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSxcbiAgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbl1cblxudmFyIENIQU5ORUxTX0ZPUk1BVCA9IFtcbiAgMCxcbiAgR0xfTFVNSU5BTkNFLFxuICBHTF9MVU1JTkFOQ0VfQUxQSEEsXG4gIEdMX1JHQixcbiAgR0xfUkdCQSQxXG5dXG5cbnZhciBGT1JNQVRfQ0hBTk5FTFMgPSB7fVxuRk9STUFUX0NIQU5ORUxTW0dMX0xVTUlOQU5DRV0gPVxuRk9STUFUX0NIQU5ORUxTW0dMX0FMUEhBXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfREVQVEhfQ09NUE9ORU5UXSA9IDFcbkZPUk1BVF9DSEFOTkVMU1tHTF9ERVBUSF9TVEVOQ0lMXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfTFVNSU5BTkNFX0FMUEhBXSA9IDJcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9TUkdCX0VYVF0gPSAzXG5GT1JNQVRfQ0hBTk5FTFNbR0xfUkdCQSQxXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfU1JHQl9BTFBIQV9FWFRdID0gNFxuXG5mdW5jdGlvbiBvYmplY3ROYW1lIChzdHIpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBzdHIgKyAnXSdcbn1cblxudmFyIENBTlZBU19DTEFTUyA9IG9iamVjdE5hbWUoJ0hUTUxDYW52YXNFbGVtZW50JylcbnZhciBPRkZTQ1JFRU5DQU5WQVNfQ0xBU1MgPSBvYmplY3ROYW1lKCdPZmZzY3JlZW5DYW52YXMnKVxudmFyIENPTlRFWFQyRF9DTEFTUyA9IG9iamVjdE5hbWUoJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCcpXG52YXIgQklUTUFQX0NMQVNTID0gb2JqZWN0TmFtZSgnSW1hZ2VCaXRtYXAnKVxudmFyIElNQUdFX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTEltYWdlRWxlbWVudCcpXG52YXIgVklERU9fQ0xBU1MgPSBvYmplY3ROYW1lKCdIVE1MVmlkZW9FbGVtZW50JylcblxudmFyIFBJWEVMX0NMQVNTRVMgPSBPYmplY3Qua2V5cyhhcnJheVR5cGVzKS5jb25jYXQoW1xuICBDQU5WQVNfQ0xBU1MsXG4gIE9GRlNDUkVFTkNBTlZBU19DTEFTUyxcbiAgQ09OVEVYVDJEX0NMQVNTLFxuICBCSVRNQVBfQ0xBU1MsXG4gIElNQUdFX0NMQVNTLFxuICBWSURFT19DTEFTU1xuXSlcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIFRZUEVfU0laRVMgPSBbXVxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9CWVRFJDVdID0gMVxuVFlQRV9TSVpFU1tHTF9GTE9BVCQ0XSA9IDRcblRZUEVfU0laRVNbR0xfSEFMRl9GTE9BVF9PRVMkMV0gPSAyXG5cblRZUEVfU0laRVNbR0xfVU5TSUdORURfU0hPUlQkM10gPSAyXG5UWVBFX1NJWkVTW0dMX1VOU0lHTkVEX0lOVCQzXSA9IDRcblxudmFyIEZPUk1BVF9TSVpFU19TUEVDSUFMID0gW11cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQkE0XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQjVfQTFdID0gMlxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfUkdCNTY1XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0RFUFRIX1NURU5DSUxdID0gNFxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRdID0gMC41XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVF0gPSAxXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVF0gPSAxXG5cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTF0gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0xdID0gMVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xdID0gMVxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNR10gPSAwLjI1XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR10gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXSA9IDAuMjVcblxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTF0gPSAwLjVcblxuZnVuY3Rpb24gaXNOdW1lcmljQXJyYXkgKGFycikge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYXJyKSAmJlxuICAgIChhcnIubGVuZ3RoID09PSAwIHx8XG4gICAgdHlwZW9mIGFyclswXSA9PT0gJ251bWJlcicpKVxufVxuXG5mdW5jdGlvbiBpc1JlY3RBcnJheSAoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIHdpZHRoID0gYXJyLmxlbmd0aFxuICBpZiAod2lkdGggPT09IDAgfHwgIWlzQXJyYXlMaWtlKGFyclswXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyAoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpXG59XG5cbmZ1bmN0aW9uIGlzQ2FudmFzRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBDQU5WQVNfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNPZmZzY3JlZW5DYW52YXMgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gT0ZGU0NSRUVOQ0FOVkFTX0NMQVNTXG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dDJEIChvYmplY3QpIHtcbiAgcmV0dXJuIGNsYXNzU3RyaW5nKG9iamVjdCkgPT09IENPTlRFWFQyRF9DTEFTU1xufVxuXG5mdW5jdGlvbiBpc0JpdG1hcCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBCSVRNQVBfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNJbWFnZUVsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gSU1BR0VfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNWaWRlb0VsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gVklERU9fQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNQaXhlbERhdGEgKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBjbGFzc05hbWUgPSBjbGFzc1N0cmluZyhvYmplY3QpXG4gIGlmIChQSVhFTF9DTEFTU0VTLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gKFxuICAgIGlzTnVtZXJpY0FycmF5KG9iamVjdCkgfHxcbiAgICBpc1JlY3RBcnJheShvYmplY3QpIHx8XG4gICAgaXNOREFycmF5TGlrZShvYmplY3QpKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5Q29kZSQxIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREYXRhIChyZXN1bHQsIGRhdGEpIHtcbiAgdmFyIG4gPSBkYXRhLmxlbmd0aFxuICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgY2FzZSBHTF9VTlNJR05FRF9CWVRFJDU6XG4gICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQzOlxuICAgIGNhc2UgR0xfVU5TSUdORURfSU5UJDM6XG4gICAgY2FzZSBHTF9GTE9BVCQ0OlxuICAgICAgdmFyIGNvbnZlcnRlZCA9IHBvb2wuYWxsb2NUeXBlKHJlc3VsdC50eXBlLCBuKVxuICAgICAgY29udmVydGVkLnNldChkYXRhKVxuICAgICAgcmVzdWx0LmRhdGEgPSBjb252ZXJ0ZWRcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIEdMX0hBTEZfRkxPQVRfT0VTJDE6XG4gICAgICByZXN1bHQuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChkYXRhKVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjaGVjayQxLnJhaXNlKCd1bnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUsIG11c3Qgc3BlY2lmeSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVDb252ZXJ0IChpbWFnZSwgbikge1xuICByZXR1cm4gcG9vbC5hbGxvY1R5cGUoXG4gICAgaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMVxuICAgICAgPyBHTF9GTE9BVCQ0XG4gICAgICA6IGltYWdlLnR5cGUsIG4pXG59XG5cbmZ1bmN0aW9uIHBvc3RDb252ZXJ0IChpbWFnZSwgZGF0YSkge1xuICBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMSkge1xuICAgIGltYWdlLmRhdGEgPSBjb252ZXJ0VG9IYWxmRmxvYXQoZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2VEYXRhIChpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIG9mZnNldCkge1xuICB2YXIgdyA9IGltYWdlLndpZHRoXG4gIHZhciBoID0gaW1hZ2UuaGVpZ2h0XG4gIHZhciBjID0gaW1hZ2UuY2hhbm5lbHNcbiAgdmFyIG4gPSB3ICogaCAqIGNcbiAgdmFyIGRhdGEgPSBwcmVDb252ZXJ0KGltYWdlLCBuKVxuXG4gIHZhciBwID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdzsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGM7ICsraykge1xuICAgICAgICBkYXRhW3ArK10gPSBhcnJheVtzdHJpZGVYICogaiArIHN0cmlkZVkgKiBpICsgc3RyaWRlQyAqIGsgKyBvZmZzZXRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zdENvbnZlcnQoaW1hZ2UsIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVTaXplIChmb3JtYXQsIHR5cGUsIHdpZHRoLCBoZWlnaHQsIGlzTWlwbWFwLCBpc0N1YmUpIHtcbiAgdmFyIHNcbiAgaWYgKHR5cGVvZiBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdlIGhhdmUgYSBzcGVjaWFsIGFycmF5IGZvciBkZWFsaW5nIHdpdGggd2VpcmQgY29sb3IgZm9ybWF0cyBzdWNoIGFzIFJHQjVBMVxuICAgIHMgPSBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdXG4gIH0gZWxzZSB7XG4gICAgcyA9IEZPUk1BVF9DSEFOTkVMU1tmb3JtYXRdICogVFlQRV9TSVpFU1t0eXBlXVxuICB9XG5cbiAgaWYgKGlzQ3ViZSkge1xuICAgIHMgKj0gNlxuICB9XG5cbiAgaWYgKGlzTWlwbWFwKSB7XG4gICAgLy8gY29tcHV0ZSB0aGUgdG90YWwgc2l6ZSBvZiBhbGwgdGhlIG1pcG1hcHMuXG4gICAgdmFyIHRvdGFsID0gMFxuXG4gICAgdmFyIHcgPSB3aWR0aFxuICAgIHdoaWxlICh3ID49IDEpIHtcbiAgICAgIC8vIHdlIGNhbiBvbmx5IHVzZSBtaXBtYXBzIG9uIGEgc3F1YXJlIGltYWdlLFxuICAgICAgLy8gc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIHdpZHRoIGFuZCBpZ25vcmUgdGhlIGhlaWdodDpcbiAgICAgIHRvdGFsICs9IHMgKiB3ICogd1xuICAgICAgdyAvPSAyXG4gICAgfVxuICAgIHJldHVybiB0b3RhbFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzICogd2lkdGggKiBoZWlnaHRcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlU2V0IChcbiAgZ2wsIGV4dGVuc2lvbnMsIGxpbWl0cywgcmVnbFBvbGwsIGNvbnRleHRTdGF0ZSwgc3RhdHMsIGNvbmZpZykge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEluaXRpYWxpemUgY29uc3RhbnRzIGFuZCBwYXJhbWV0ZXIgdGFibGVzIGhlcmVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbWlwbWFwSGludCA9IHtcbiAgICBcImRvbid0IGNhcmVcIjogR0xfRE9OVF9DQVJFLFxuICAgICdkb250IGNhcmUnOiBHTF9ET05UX0NBUkUsXG4gICAgJ25pY2UnOiBHTF9OSUNFU1QsXG4gICAgJ2Zhc3QnOiBHTF9GQVNURVNUXG4gIH1cblxuICB2YXIgd3JhcE1vZGVzID0ge1xuICAgICdyZXBlYXQnOiBHTF9SRVBFQVQsXG4gICAgJ2NsYW1wJzogR0xfQ0xBTVBfVE9fRURHRSQxLFxuICAgICdtaXJyb3InOiBHTF9NSVJST1JFRF9SRVBFQVRcbiAgfVxuXG4gIHZhciBtYWdGaWx0ZXJzID0ge1xuICAgICduZWFyZXN0JzogR0xfTkVBUkVTVCQxLFxuICAgICdsaW5lYXInOiBHTF9MSU5FQVJcbiAgfVxuXG4gIHZhciBtaW5GaWx0ZXJzID0gZXh0ZW5kKHtcbiAgICAnbWlwbWFwJzogR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMSxcbiAgICAnbmVhcmVzdCBtaXBtYXAgbmVhcmVzdCc6IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QkMSxcbiAgICAnbGluZWFyIG1pcG1hcCBuZWFyZXN0JzogR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gICAgJ25lYXJlc3QgbWlwbWFwIGxpbmVhcic6IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxLFxuICAgICdsaW5lYXIgbWlwbWFwIGxpbmVhcic6IEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbiAgfSwgbWFnRmlsdGVycylcblxuICB2YXIgY29sb3JTcGFjZSA9IHtcbiAgICAnbm9uZSc6IDAsXG4gICAgJ2Jyb3dzZXInOiBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0xcbiAgfVxuXG4gIHZhciB0ZXh0dXJlVHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ1LFxuICAgICdyZ2JhNCc6IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSxcbiAgICAncmdiNTY1JzogR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSxcbiAgICAncmdiNSBhMSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEkMVxuICB9XG5cbiAgdmFyIHRleHR1cmVGb3JtYXRzID0ge1xuICAgICdhbHBoYSc6IEdMX0FMUEhBLFxuICAgICdsdW1pbmFuY2UnOiBHTF9MVU1JTkFOQ0UsXG4gICAgJ2x1bWluYW5jZSBhbHBoYSc6IEdMX0xVTUlOQU5DRV9BTFBIQSxcbiAgICAncmdiJzogR0xfUkdCLFxuICAgICdyZ2JhJzogR0xfUkdCQSQxLFxuICAgICdyZ2JhNCc6IEdMX1JHQkE0LFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSxcbiAgICAncmdiNTY1JzogR0xfUkdCNTY1XG4gIH1cblxuICB2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0ge31cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfc3JnYikge1xuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2IgPSBHTF9TUkdCX0VYVFxuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2JhID0gR0xfU1JHQl9BTFBIQV9FWFRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzLmZsb2F0MzIgPSB0ZXh0dXJlVHlwZXMuZmxvYXQgPSBHTF9GTE9BVCQ0XG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzWydmbG9hdDE2J10gPSB0ZXh0dXJlVHlwZXNbJ2hhbGYgZmxvYXQnXSA9IEdMX0hBTEZfRkxPQVRfT0VTJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUpIHtcbiAgICBleHRlbmQodGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVCxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfREVQVEhfU1RFTkNJTFxuICAgIH0pXG5cbiAgICBleHRlbmQodGV4dHVyZVR5cGVzLCB7XG4gICAgICAndWludDE2JzogR0xfVU5TSUdORURfU0hPUlQkMyxcbiAgICAgICd1aW50MzInOiBHTF9VTlNJR05FRF9JTlQkMyxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wkMVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgczN0YyBkeHQxJzogR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCxcbiAgICAgICdyZ2JhIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICAgICAgJ3JnYmEgczN0YyBkeHQzJzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gICAgICAncmdiYSBzM3RjIGR4dDUnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfYXRjKSB7XG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBhdGMnOiBHTF9DT01QUkVTU0VEX1JHQl9BVENfV0VCR0wsXG4gICAgICAncmdiYSBhdGMgZXhwbGljaXQgYWxwaGEnOiBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMLFxuICAgICAgJ3JnYmEgYXRjIGludGVycG9sYXRlZCBhbHBoYSc6IEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyxcbiAgICAgICdyZ2IgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyxcbiAgICAgICdyZ2JhIHB2cnRjIDRicHB2MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HLFxuICAgICAgJ3JnYmEgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcbiAgICB9KVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEpIHtcbiAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHNbJ3JnYiBldGMxJ10gPSBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMXG4gIH1cblxuICAvLyBDb3B5IG92ZXIgYWxsIHRleHR1cmUgZm9ybWF0c1xuICB2YXIgc3VwcG9ydGVkQ29tcHJlc3NlZEZvcm1hdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMpKVxuICBPYmplY3Qua2V5cyhjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzW25hbWVdXG4gICAgaWYgKHN1cHBvcnRlZENvbXByZXNzZWRGb3JtYXRzLmluZGV4T2YoZm9ybWF0KSA+PSAwKSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIH1cbiAgfSlcblxuICB2YXIgc3VwcG9ydGVkRm9ybWF0cyA9IE9iamVjdC5rZXlzKHRleHR1cmVGb3JtYXRzKVxuICBsaW1pdHMudGV4dHVyZUZvcm1hdHMgPSBzdXBwb3J0ZWRGb3JtYXRzXG5cbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgZm9ybWF0IHN0cmluZyBpdHNcbiAgLy8gY29ycmVzcG9uZGluZyBHTC12YWx1ZS5cbiAgdmFyIHRleHR1cmVGb3JtYXRzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB0ZXh0dXJlRm9ybWF0c1trZXldXG4gICAgdGV4dHVyZUZvcm1hdHNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIC8vIGFzc29jaWF0ZSB3aXRoIGV2ZXJ5IHR5cGUgc3RyaW5nIGl0c1xuICAvLyBjb3JyZXNwb25kaW5nIEdMLXZhbHVlLlxuICB2YXIgdGV4dHVyZVR5cGVzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gdGV4dHVyZVR5cGVzW2tleV1cbiAgICB0ZXh0dXJlVHlwZXNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtYWdGaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWFnRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1hZ0ZpbHRlcnNba2V5XVxuICAgIG1hZ0ZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtaW5GaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWluRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1pbkZpbHRlcnNba2V5XVxuICAgIG1pbkZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciB3cmFwTW9kZXNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyh3cmFwTW9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB3cmFwTW9kZXNba2V5XVxuICAgIHdyYXBNb2Rlc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgLy8gY29sb3JGb3JtYXRzW10gZ2l2ZXMgdGhlIGZvcm1hdCAoY2hhbm5lbHMpIGFzc29jaWF0ZWQgdG8gYW5cbiAgLy8gaW50ZXJuYWxmb3JtYXRcbiAgdmFyIGNvbG9yRm9ybWF0cyA9IHN1cHBvcnRlZEZvcm1hdHMucmVkdWNlKGZ1bmN0aW9uIChjb2xvciwga2V5KSB7XG4gICAgdmFyIGdsZW51bSA9IHRleHR1cmVGb3JtYXRzW2tleV1cbiAgICBpZiAoZ2xlbnVtID09PSBHTF9MVU1JTkFOQ0UgfHxcbiAgICAgICAgZ2xlbnVtID09PSBHTF9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRV9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX1NURU5DSUwgfHxcbiAgICAgICAgKGV4dGVuc2lvbnMuZXh0X3NyZ2IgJiZcbiAgICAgICAgICAgICAgICAoZ2xlbnVtID09PSBHTF9TUkdCX0VYVCB8fFxuICAgICAgICAgICAgICAgICBnbGVudW0gPT09IEdMX1NSR0JfQUxQSEFfRVhUKSkpIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBnbGVudW1cbiAgICB9IGVsc2UgaWYgKGdsZW51bSA9PT0gR0xfUkdCNV9BMSB8fCBrZXkuaW5kZXhPZigncmdiYScpID49IDApIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JBJDFcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JbZ2xlbnVtXSA9IEdMX1JHQlxuICAgIH1cbiAgICByZXR1cm4gY29sb3JcbiAgfSwge30pXG5cbiAgZnVuY3Rpb24gVGV4RmxhZ3MgKCkge1xuICAgIC8vIGZvcm1hdCBpbmZvXG4gICAgdGhpcy5pbnRlcm5hbGZvcm1hdCA9IEdMX1JHQkEkMVxuICAgIHRoaXMuZm9ybWF0ID0gR0xfUkdCQSQxXG4gICAgdGhpcy50eXBlID0gR0xfVU5TSUdORURfQllURSQ1XG4gICAgdGhpcy5jb21wcmVzc2VkID0gZmFsc2VcblxuICAgIC8vIHBpeGVsIHN0b3JhZ2VcbiAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZVxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZVxuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMVxuICAgIHRoaXMuY29sb3JTcGFjZSA9IEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTFxuXG4gICAgLy8gc2hhcGUgaW5mb1xuICAgIHRoaXMud2lkdGggPSAwXG4gICAgdGhpcy5oZWlnaHQgPSAwXG4gICAgdGhpcy5jaGFubmVscyA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlGbGFncyAocmVzdWx0LCBvdGhlcikge1xuICAgIHJlc3VsdC5pbnRlcm5hbGZvcm1hdCA9IG90aGVyLmludGVybmFsZm9ybWF0XG4gICAgcmVzdWx0LmZvcm1hdCA9IG90aGVyLmZvcm1hdFxuICAgIHJlc3VsdC50eXBlID0gb3RoZXIudHlwZVxuICAgIHJlc3VsdC5jb21wcmVzc2VkID0gb3RoZXIuY29tcHJlc3NlZFxuXG4gICAgcmVzdWx0LnByZW11bHRpcGx5QWxwaGEgPSBvdGhlci5wcmVtdWx0aXBseUFscGhhXG4gICAgcmVzdWx0LmZsaXBZID0gb3RoZXIuZmxpcFlcbiAgICByZXN1bHQudW5wYWNrQWxpZ25tZW50ID0gb3RoZXIudW5wYWNrQWxpZ25tZW50XG4gICAgcmVzdWx0LmNvbG9yU3BhY2UgPSBvdGhlci5jb2xvclNwYWNlXG5cbiAgICByZXN1bHQud2lkdGggPSBvdGhlci53aWR0aFxuICAgIHJlc3VsdC5oZWlnaHQgPSBvdGhlci5oZWlnaHRcbiAgICByZXN1bHQuY2hhbm5lbHMgPSBvdGhlci5jaGFubmVsc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGbGFncyAoZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8ICFvcHRpb25zKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoJ3ByZW11bHRpcGx5QWxwaGEnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLnByZW11bHRpcGx5QWxwaGEsICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgcHJlbXVsdGlwbHlBbHBoYScpXG4gICAgICBmbGFncy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhXG4gICAgfVxuXG4gICAgaWYgKCdmbGlwWScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZmxpcFksICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSBmbGlwJylcbiAgICAgIGZsYWdzLmZsaXBZID0gb3B0aW9ucy5mbGlwWVxuICAgIH1cblxuICAgIGlmICgnYWxpZ25tZW50JyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLm9uZU9mKG9wdGlvbnMuYWxpZ25tZW50LCBbMSwgMiwgNCwgOF0sXG4gICAgICAgICdpbnZhbGlkIHRleHR1cmUgdW5wYWNrIGFsaWdubWVudCcpXG4gICAgICBmbGFncy51bnBhY2tBbGlnbm1lbnQgPSBvcHRpb25zLmFsaWdubWVudFxuICAgIH1cblxuICAgIGlmICgnY29sb3JTcGFjZScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy5jb2xvclNwYWNlLCBjb2xvclNwYWNlLFxuICAgICAgICAnaW52YWxpZCBjb2xvclNwYWNlJylcbiAgICAgIGZsYWdzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlW29wdGlvbnMuY29sb3JTcGFjZV1cbiAgICB9XG5cbiAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQgfHxcbiAgICAgICAgISh0eXBlID09PSAnZmxvYXQnIHx8IHR5cGUgPT09ICdmbG9hdDMyJyksXG4gICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBPRVNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCB8fFxuICAgICAgICAhKHR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCB0eXBlID09PSAnZmxvYXQxNicpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIDE2LWJpdCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4nKVxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcbiAgICAgICAgISh0eXBlID09PSAndWludDE2JyB8fCB0eXBlID09PSAndWludDMyJyB8fCB0eXBlID09PSAnZGVwdGggc3RlbmNpbCcpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJylcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHR5cGUsIHRleHR1cmVUeXBlcyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSB0eXBlJylcbiAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbdHlwZV1cbiAgICB9XG5cbiAgICB2YXIgdyA9IGZsYWdzLndpZHRoXG4gICAgdmFyIGggPSBmbGFncy5oZWlnaHRcbiAgICB2YXIgYyA9IGZsYWdzLmNoYW5uZWxzXG4gICAgdmFyIGhhc0NoYW5uZWxzID0gZmFsc2VcbiAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zaGFwZSkgJiYgb3B0aW9ucy5zaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgJ3NoYXBlIG11c3QgYmUgYW4gYXJyYXknKVxuICAgICAgdyA9IG9wdGlvbnMuc2hhcGVbMF1cbiAgICAgIGggPSBvcHRpb25zLnNoYXBlWzFdXG4gICAgICBpZiAob3B0aW9ucy5zaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYyA9IG9wdGlvbnMuc2hhcGVbMl1cbiAgICAgICAgY2hlY2skMShjID4gMCAmJiBjIDw9IDQsICdpbnZhbGlkIG51bWJlciBvZiBjaGFubmVscycpXG4gICAgICAgIGhhc0NoYW5uZWxzID0gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hlY2skMSh3ID49IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIHdpZHRoJylcbiAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ3JhZGl1cycgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgIGNoZWNrJDEodyA+PSAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCByYWRpdXMnKVxuICAgICAgfVxuICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gb3B0aW9ucy53aWR0aFxuICAgICAgICBjaGVjayQxKHcgPj0gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSwgJ2ludmFsaWQgd2lkdGgnKVxuICAgICAgfVxuICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgICAgfVxuICAgICAgaWYgKCdjaGFubmVscycgaW4gb3B0aW9ucykge1xuICAgICAgICBjID0gb3B0aW9ucy5jaGFubmVsc1xuICAgICAgICBjaGVjayQxKGMgPiAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzJylcbiAgICAgICAgaGFzQ2hhbm5lbHMgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGZsYWdzLndpZHRoID0gdyB8IDBcbiAgICBmbGFncy5oZWlnaHQgPSBoIHwgMFxuICAgIGZsYWdzLmNoYW5uZWxzID0gYyB8IDBcblxuICAgIHZhciBoYXNGb3JtYXQgPSBmYWxzZVxuICAgIGlmICgnZm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgZm9ybWF0U3RyID0gb3B0aW9ucy5mb3JtYXRcbiAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlIHx8XG4gICAgICAgICEoZm9ybWF0U3RyID09PSAnZGVwdGgnIHx8IGZvcm1hdFN0ciA9PT0gJ2RlcHRoIHN0ZW5jaWwnKSxcbiAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIFdFQkdMX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBkZXB0aC9zdGVuY2lsIHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihmb3JtYXRTdHIsIHRleHR1cmVGb3JtYXRzLFxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIGZvcm1hdCcpXG4gICAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBmbGFncy5pbnRlcm5hbGZvcm1hdCA9IHRleHR1cmVGb3JtYXRzW2Zvcm1hdFN0cl1cbiAgICAgIGZsYWdzLmZvcm1hdCA9IGNvbG9yRm9ybWF0c1tpbnRlcm5hbGZvcm1hdF1cbiAgICAgIGlmIChmb3JtYXRTdHIgaW4gdGV4dHVyZVR5cGVzKSB7XG4gICAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbZm9ybWF0U3RyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0U3RyIGluIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykge1xuICAgICAgICBmbGFncy5jb21wcmVzc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaGFzRm9ybWF0ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFJlY29uY2lsZSBjaGFubmVscyBhbmQgZm9ybWF0XG4gICAgaWYgKCFoYXNDaGFubmVscyAmJiBoYXNGb3JtYXQpIHtcbiAgICAgIGZsYWdzLmNoYW5uZWxzID0gRk9STUFUX0NIQU5ORUxTW2ZsYWdzLmZvcm1hdF1cbiAgICB9IGVsc2UgaWYgKGhhc0NoYW5uZWxzICYmICFoYXNGb3JtYXQpIHtcbiAgICAgIGlmIChmbGFncy5jaGFubmVscyAhPT0gQ0hBTk5FTFNfRk9STUFUW2ZsYWdzLmZvcm1hdF0pIHtcbiAgICAgICAgZmxhZ3MuZm9ybWF0ID0gZmxhZ3MuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbZmxhZ3MuY2hhbm5lbHNdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNGb3JtYXQgJiYgaGFzQ2hhbm5lbHMpIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZsYWdzLmNoYW5uZWxzID09PSBGT1JNQVRfQ0hBTk5FTFNbZmxhZ3MuZm9ybWF0XSxcbiAgICAgICAgJ251bWJlciBvZiBjaGFubmVscyBpbmNvbnNpc3RlbnQgd2l0aCBzcGVjaWZpZWQgZm9ybWF0JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmbGFncy5mbGlwWSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZsYWdzLnByZW11bHRpcGx5QWxwaGEpXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZmxhZ3MuY29sb3JTcGFjZSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQUxJR05NRU5ULCBmbGFncy51bnBhY2tBbGlnbm1lbnQpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRleCBpbWFnZSBkYXRhXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gVGV4SW1hZ2UgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMueE9mZnNldCA9IDBcbiAgICB0aGlzLnlPZmZzZXQgPSAwXG5cbiAgICAvLyBkYXRhXG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICAgIHRoaXMubmVlZHNGcmVlID0gZmFsc2VcblxuICAgIC8vIGh0bWwgZWxlbWVudFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcblxuICAgIC8vIGNvcHlUZXhJbWFnZSBpbmZvXG4gICAgdGhpcy5uZWVkc0NvcHkgPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJbWFnZSAoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGRhdGEgPSBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIHBpeGVsIGRhdGEgdHlwZScpXG4gICAgICBwYXJzZUZsYWdzKGltYWdlLCBvcHRpb25zKVxuICAgICAgaWYgKCd4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGltYWdlLnhPZmZzZXQgPSBvcHRpb25zLnggfCAwXG4gICAgICB9XG4gICAgICBpZiAoJ3knIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaW1hZ2UueU9mZnNldCA9IG9wdGlvbnMueSB8IDBcbiAgICAgIH1cbiAgICAgIGlmIChpc1BpeGVsRGF0YShvcHRpb25zLmRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayQxKFxuICAgICAgIWltYWdlLmNvbXByZXNzZWQgfHxcbiAgICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgJ2NvbXByZXNzZWQgdGV4dHVyZSBkYXRhIG11c3QgYmUgc3RvcmVkIGluIGEgdWludDhhcnJheScpXG5cbiAgICBpZiAob3B0aW9ucy5jb3B5KSB7XG4gICAgICBjaGVjayQxKCFkYXRhLCAnY2FuIG5vdCBzcGVjaWZ5IGNvcHkgYW5kIGRhdGEgZmllbGQgZm9yIHRoZSBzYW1lIHRleHR1cmUnKVxuICAgICAgdmFyIHZpZXdXID0gY29udGV4dFN0YXRlLnZpZXdwb3J0V2lkdGhcbiAgICAgIHZhciB2aWV3SCA9IGNvbnRleHRTdGF0ZS52aWV3cG9ydEhlaWdodFxuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAodmlld1cgLSBpbWFnZS54T2Zmc2V0KVxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IHx8ICh2aWV3SCAtIGltYWdlLnlPZmZzZXQpXG4gICAgICBpbWFnZS5uZWVkc0NvcHkgPSB0cnVlXG4gICAgICBjaGVjayQxKGltYWdlLnhPZmZzZXQgPj0gMCAmJiBpbWFnZS54T2Zmc2V0IDwgdmlld1cgJiZcbiAgICAgICAgICAgIGltYWdlLnlPZmZzZXQgPj0gMCAmJiBpbWFnZS55T2Zmc2V0IDwgdmlld0ggJiZcbiAgICAgICAgICAgIGltYWdlLndpZHRoID4gMCAmJiBpbWFnZS53aWR0aCA8PSB2aWV3VyAmJlxuICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0ID4gMCAmJiBpbWFnZS5oZWlnaHQgPD0gdmlld0gsXG4gICAgICAnY29weSB0ZXh0dXJlIHJlYWQgb3V0IG9mIGJvdW5kcycpXG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAxXG4gICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgMVxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBpbWFnZS5jaGFubmVscyB8fCA0XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gaW1hZ2UuY2hhbm5lbHMgfHwgNFxuICAgICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSAmJiBpbWFnZS50eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDUpIHtcbiAgICAgICAgaW1hZ2UudHlwZSA9IHR5cGVkQXJyYXlDb2RlJDEoZGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTnVtZXJpY0FycmF5KGRhdGEpKSB7XG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDRcbiAgICAgIGNvbnZlcnREYXRhKGltYWdlLCBkYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgdmFyIGFycmF5ID0gZGF0YS5kYXRhXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpICYmIGltYWdlLnR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNSkge1xuICAgICAgICBpbWFnZS50eXBlID0gdHlwZWRBcnJheUNvZGUkMShhcnJheSlcbiAgICAgIH1cbiAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIHNoYXBlWCwgc2hhcGVZLCBzaGFwZUMsIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUNcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc2hhcGVDID0gc2hhcGVbMl1cbiAgICAgICAgc3RyaWRlQyA9IHN0cmlkZVsyXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMShzaGFwZS5sZW5ndGggPT09IDIsICdpbnZhbGlkIG5kYXJyYXkgcGl4ZWwgZGF0YSwgbXVzdCBiZSAyIG9yIDNEJylcbiAgICAgICAgc2hhcGVDID0gMVxuICAgICAgICBzdHJpZGVDID0gMVxuICAgICAgfVxuICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgIHNoYXBlWSA9IHNoYXBlWzFdXG4gICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICBzdHJpZGVZID0gc3RyaWRlWzFdXG4gICAgICBpbWFnZS5hbGlnbm1lbnQgPSAxXG4gICAgICBpbWFnZS53aWR0aCA9IHNoYXBlWFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gc2hhcGVZXG4gICAgICBpbWFnZS5jaGFubmVscyA9IHNoYXBlQ1xuICAgICAgaW1hZ2UuZm9ybWF0ID0gaW1hZ2UuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbc2hhcGVDXVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgICAgdHJhbnNwb3NlRGF0YShpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIGRhdGEub2Zmc2V0KVxuICAgIH0gZWxzZSBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpIHx8IGlzQ29udGV4dDJEKGRhdGEpKSB7XG4gICAgICBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpKSB7XG4gICAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YS5jYW52YXNcbiAgICAgIH1cbiAgICAgIGltYWdlLndpZHRoID0gaW1hZ2UuZWxlbWVudC53aWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuZWxlbWVudC5oZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNCaXRtYXAoZGF0YSkpIHtcbiAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICBpbWFnZS53aWR0aCA9IGRhdGEud2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEuaGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzSW1hZ2VFbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLm5hdHVyYWxXaWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS5uYXR1cmFsSGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzVmlkZW9FbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLnZpZGVvV2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEudmlkZW9IZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNSZWN0QXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciB3ID0gaW1hZ2Uud2lkdGggfHwgZGF0YVswXS5sZW5ndGhcbiAgICAgIHZhciBoID0gaW1hZ2UuaGVpZ2h0IHx8IGRhdGEubGVuZ3RoXG4gICAgICB2YXIgYyA9IGltYWdlLmNoYW5uZWxzXG4gICAgICBpZiAoaXNBcnJheUxpa2UoZGF0YVswXVswXSkpIHtcbiAgICAgICAgYyA9IGMgfHwgZGF0YVswXVswXS5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBjIHx8IDFcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlKGRhdGEpXG4gICAgICB2YXIgbiA9IDFcbiAgICAgIGZvciAodmFyIGRkID0gMDsgZGQgPCBhcnJheVNoYXBlLmxlbmd0aDsgKytkZCkge1xuICAgICAgICBuICo9IGFycmF5U2hhcGVbZGRdXG4gICAgICB9XG4gICAgICB2YXIgYWxsb2NEYXRhID0gcHJlQ29udmVydChpbWFnZSwgbilcbiAgICAgIGZsYXR0ZW5VdGlscy5mbGF0dGVuKGRhdGEsIGFycmF5U2hhcGUsICcnLCBhbGxvY0RhdGEpXG4gICAgICBwb3N0Q29udmVydChpbWFnZSwgYWxsb2NEYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2Uud2lkdGggPSB3XG4gICAgICBpbWFnZS5oZWlnaHQgPSBoXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGNcbiAgICAgIGltYWdlLmZvcm1hdCA9IGltYWdlLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW2NdXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGltYWdlLnR5cGUgPT09IEdMX0ZMT0FUJDQpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfZmxvYXQnKSA+PSAwLFxuICAgICAgICAnb2VzX3RleHR1cmVfZmxvYXQgZXh0ZW5zaW9uIG5vdCBlbmFibGVkJylcbiAgICB9IGVsc2UgaWYgKGltYWdlLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTJDEpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfaGFsZl9mbG9hdCcpID49IDAsXG4gICAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IGV4dGVuc2lvbiBub3QgZW5hYmxlZCcpXG4gICAgfVxuXG4gICAgLy8gZG8gY29tcHJlc3NlZCB0ZXh0dXJlICB2YWxpZGF0aW9uIGhlcmUuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbWFnZSAoaW5mbywgdGFyZ2V0LCBtaXBsZXZlbCkge1xuICAgIHZhciBlbGVtZW50ID0gaW5mby5lbGVtZW50XG4gICAgdmFyIGRhdGEgPSBpbmZvLmRhdGFcbiAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBpbmZvLmludGVybmFsZm9ybWF0XG4gICAgdmFyIGZvcm1hdCA9IGluZm8uZm9ybWF0XG4gICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVcbiAgICB2YXIgd2lkdGggPSBpbmZvLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGluZm8uaGVpZ2h0XG5cbiAgICBzZXRGbGFncyhpbmZvKVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBkYXRhKVxuICAgIH0gZWxzZSBpZiAoaW5mby5uZWVkc0NvcHkpIHtcbiAgICAgIHJlZ2xQb2xsKClcbiAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCBmb3JtYXQsIGluZm8ueE9mZnNldCwgaW5mby55T2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBkYXRhIHx8IG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3ViSW1hZ2UgKGluZm8sIHRhcmdldCwgeCwgeSwgbWlwbGV2ZWwpIHtcbiAgICB2YXIgZWxlbWVudCA9IGluZm8uZWxlbWVudFxuICAgIHZhciBkYXRhID0gaW5mby5kYXRhXG4gICAgdmFyIGludGVybmFsZm9ybWF0ID0gaW5mby5pbnRlcm5hbGZvcm1hdFxuICAgIHZhciBmb3JtYXQgPSBpbmZvLmZvcm1hdFxuICAgIHZhciB0eXBlID0gaW5mby50eXBlXG4gICAgdmFyIHdpZHRoID0gaW5mby53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBpbmZvLmhlaWdodFxuXG4gICAgc2V0RmxhZ3MoaW5mbylcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbiAgICB9IGVsc2UgaWYgKGluZm8ubmVlZHNDb3B5KSB7XG4gICAgICByZWdsUG9sbCgpXG4gICAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgeCwgeSwgaW5mby54T2Zmc2V0LCBpbmZvLnlPZmZzZXQsIHdpZHRoLCBoZWlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyB0ZXhJbWFnZSBwb29sXG4gIHZhciBpbWFnZVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jSW1hZ2UgKCkge1xuICAgIHJldHVybiBpbWFnZVBvb2wucG9wKCkgfHwgbmV3IFRleEltYWdlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVJbWFnZSAoaW1hZ2UpIHtcbiAgICBpZiAoaW1hZ2UubmVlZHNGcmVlKSB7XG4gICAgICBwb29sLmZyZWVUeXBlKGltYWdlLmRhdGEpXG4gICAgfVxuICAgIFRleEltYWdlLmNhbGwoaW1hZ2UpXG4gICAgaW1hZ2VQb29sLnB1c2goaW1hZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE1pcCBtYXBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBNaXBNYXAgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gICAgdGhpcy5taXBtYXNrID0gMFxuICAgIHRoaXMuaW1hZ2VzID0gQXJyYXkoMTYpXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pcE1hcEZyb21TaGFwZSAobWlwbWFwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGltZyA9IG1pcG1hcC5pbWFnZXNbMF0gPSBhbGxvY0ltYWdlKClcbiAgICBtaXBtYXAubWlwbWFzayA9IDFcbiAgICBpbWcud2lkdGggPSBtaXBtYXAud2lkdGggPSB3aWR0aFxuICAgIGltZy5oZWlnaHQgPSBtaXBtYXAuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgaW1nLmNoYW5uZWxzID0gbWlwbWFwLmNoYW5uZWxzID0gNFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaXBNYXBGcm9tT2JqZWN0IChtaXBtYXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW1nRGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGltZ0RhdGEgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBvcHRpb25zKVxuICAgICAgbWlwbWFwLm1pcG1hc2sgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlRmxhZ3MobWlwbWFwLCBvcHRpb25zKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApKSB7XG4gICAgICAgIHZhciBtaXBEYXRhID0gb3B0aW9ucy5taXBtYXBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXBEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbaV0gPSBhbGxvY0ltYWdlKClcbiAgICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICAgIGltZ0RhdGEud2lkdGggPj49IGlcbiAgICAgICAgICBpbWdEYXRhLmhlaWdodCA+Pj0gaVxuICAgICAgICAgIHBhcnNlSW1hZ2UoaW1nRGF0YSwgbWlwRGF0YVtpXSlcbiAgICAgICAgICBtaXBtYXAubWlwbWFzayB8PSAoMSA8PCBpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWdEYXRhID0gbWlwbWFwLmltYWdlc1swXSA9IGFsbG9jSW1hZ2UoKVxuICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICBwYXJzZUltYWdlKGltZ0RhdGEsIG9wdGlvbnMpXG4gICAgICAgIG1pcG1hcC5taXBtYXNrID0gMVxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5RmxhZ3MobWlwbWFwLCBtaXBtYXAuaW1hZ2VzWzBdKVxuXG4gICAgLy8gRm9yIHRleHR1cmVzIG9mIHRoZSBjb21wcmVzc2VkIGZvcm1hdCBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgIC8vIHdlIG11c3QgaGF2ZSB0aGF0XG4gICAgLy9cbiAgICAvLyBcIldoZW4gbGV2ZWwgZXF1YWxzIHplcm8gd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAgICAvLyBXaGVuIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiAwIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSAwLCAxLCAyIG9yIGEgbXVsdGlwbGUgb2YgNC4gXCJcbiAgICAvL1xuICAgIC8vIGJ1dCB3ZSBkbyBub3QgeWV0IHN1cHBvcnQgaGF2aW5nIG11bHRpcGxlIG1pcG1hcCBsZXZlbHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMsXG4gICAgLy8gc28gd2Ugb25seSB0ZXN0IGZvciBsZXZlbCB6ZXJvLlxuXG4gICAgaWYgKFxuICAgICAgbWlwbWFwLmNvbXByZXNzZWQgJiZcbiAgICAgIChcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUIHx8XG4gICAgICAgIG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQgfHxcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCB8fFxuICAgICAgICBtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG4gICAgICApXG4gICAgKSB7XG4gICAgICBjaGVjayQxKG1pcG1hcC53aWR0aCAlIDQgPT09IDAgJiYgbWlwbWFwLmhlaWdodCAlIDQgPT09IDAsXG4gICAgICAgICdmb3IgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHMsIG1pcG1hcCBsZXZlbCAwIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgYXJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWlwTWFwIChtaXBtYXAsIHRhcmdldCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghaW1hZ2VzW2ldKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2V0SW1hZ2UoaW1hZ2VzW2ldLCB0YXJnZXQsIGkpXG4gICAgfVxuICB9XG5cbiAgdmFyIG1pcFBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jTWlwTWFwICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWlwUG9vbC5wb3AoKSB8fCBuZXcgTWlwTWFwKClcbiAgICBUZXhGbGFncy5jYWxsKHJlc3VsdClcbiAgICByZXN1bHQubWlwbWFzayA9IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHJlc3VsdC5pbWFnZXNbaV0gPSBudWxsXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVNaXBNYXAgKG1pcG1hcCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpbWFnZXNbaV0pIHtcbiAgICAgICAgZnJlZUltYWdlKGltYWdlc1tpXSlcbiAgICAgIH1cbiAgICAgIGltYWdlc1tpXSA9IG51bGxcbiAgICB9XG4gICAgbWlwUG9vbC5wdXNoKG1pcG1hcClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGV4IGluZm9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBUZXhJbmZvICgpIHtcbiAgICB0aGlzLm1pbkZpbHRlciA9IEdMX05FQVJFU1QkMVxuICAgIHRoaXMubWFnRmlsdGVyID0gR0xfTkVBUkVTVCQxXG5cbiAgICB0aGlzLndyYXBTID0gR0xfQ0xBTVBfVE9fRURHRSQxXG4gICAgdGhpcy53cmFwVCA9IEdMX0NMQU1QX1RPX0VER0UkMVxuXG4gICAgdGhpcy5hbmlzb3Ryb3BpYyA9IDFcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRleEluZm8gKGluZm8sIG9wdGlvbnMpIHtcbiAgICBpZiAoJ21pbicgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1pbkZpbHRlciA9IG9wdGlvbnMubWluXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtaW5GaWx0ZXIsIG1pbkZpbHRlcnMpXG4gICAgICBpbmZvLm1pbkZpbHRlciA9IG1pbkZpbHRlcnNbbWluRmlsdGVyXVxuICAgICAgaWYgKE1JUE1BUF9GSUxURVJTLmluZGV4T2YoaW5mby5taW5GaWx0ZXIpID49IDAgJiYgISgnZmFjZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ21hZycgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtYWdGaWx0ZXIsIG1hZ0ZpbHRlcnMpXG4gICAgICBpbmZvLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcnNbbWFnRmlsdGVyXVxuICAgIH1cblxuICAgIHZhciB3cmFwUyA9IGluZm8ud3JhcFNcbiAgICB2YXIgd3JhcFQgPSBpbmZvLndyYXBUXG4gICAgaWYgKCd3cmFwJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgd3JhcCA9IG9wdGlvbnMud3JhcFxuICAgICAgaWYgKHR5cGVvZiB3cmFwID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcFQgPSB3cmFwTW9kZXNbd3JhcF1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh3cmFwKSkge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwWzBdLCB3cmFwTW9kZXMpXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXBbMV0sIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFMgPSB3cmFwTW9kZXNbd3JhcFswXV1cbiAgICAgICAgd3JhcFQgPSB3cmFwTW9kZXNbd3JhcFsxXV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCd3cmFwUycgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFMgPSBvcHRpb25zLndyYXBTXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBTLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcE1vZGVzW29wdFdyYXBTXVxuICAgICAgfVxuICAgICAgaWYgKCd3cmFwVCcgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFQgPSBvcHRpb25zLndyYXBUXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBULCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBUID0gd3JhcE1vZGVzW29wdFdyYXBUXVxuICAgICAgfVxuICAgIH1cbiAgICBpbmZvLndyYXBTID0gd3JhcFNcbiAgICBpbmZvLndyYXBUID0gd3JhcFRcblxuICAgIGlmICgnYW5pc290cm9waWMnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhbmlzb3Ryb3BpYyA9IG9wdGlvbnMuYW5pc290cm9waWNcbiAgICAgIGNoZWNrJDEodHlwZW9mIGFuaXNvdHJvcGljID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgYW5pc290cm9waWMgPj0gMSAmJiBhbmlzb3Ryb3BpYyA8PSBsaW1pdHMubWF4QW5pc290cm9waWMsXG4gICAgICAnYW5pc28gc2FtcGxlcyBtdXN0IGJlIGJldHdlZW4gMSBhbmQgJylcbiAgICAgIGluZm8uYW5pc290cm9waWMgPSBvcHRpb25zLmFuaXNvdHJvcGljXG4gICAgfVxuXG4gICAgaWYgKCdtaXBtYXAnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoYXNNaXBNYXAgPSBmYWxzZVxuICAgICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucy5taXBtYXApIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLm1pcG1hcCwgbWlwbWFwSGludCxcbiAgICAgICAgICAgICdpbnZhbGlkIG1pcG1hcCBoaW50JylcbiAgICAgICAgICBpbmZvLm1pcG1hcEhpbnQgPSBtaXBtYXBIaW50W29wdGlvbnMubWlwbWFwXVxuICAgICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICBoYXNNaXBNYXAgPSBpbmZvLmdlbk1pcG1hcHMgPSBvcHRpb25zLm1pcG1hcFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApLCAnaW52YWxpZCBtaXBtYXAgdHlwZScpXG4gICAgICAgICAgaW5mby5nZW5NaXBtYXBzID0gZmFsc2VcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgbWlwbWFwIHR5cGUnKVxuICAgICAgfVxuICAgICAgaWYgKGhhc01pcE1hcCAmJiAhKCdtaW4nIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8ubWluRmlsdGVyID0gR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4SW5mbyAoaW5mbywgdGFyZ2V0KSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgaW5mby5taW5GaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiwgaW5mby5tYWdGaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9TLCBpbmZvLndyYXBTKVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX1dSQVBfVCwgaW5mby53cmFwVClcbiAgICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgaW5mby5hbmlzb3Ryb3BpYylcbiAgICB9XG4gICAgaWYgKGluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgZ2wuaGludChHTF9HRU5FUkFURV9NSVBNQVBfSElOVCwgaW5mby5taXBtYXBIaW50KVxuICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRnVsbCB0ZXh0dXJlIG9iamVjdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciB0ZXh0dXJlQ291bnQgPSAwXG4gIHZhciB0ZXh0dXJlU2V0ID0ge31cbiAgdmFyIG51bVRleFVuaXRzID0gbGltaXRzLm1heFRleHR1cmVVbml0c1xuICB2YXIgdGV4dHVyZVVuaXRzID0gQXJyYXkobnVtVGV4VW5pdHMpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSlcblxuICBmdW5jdGlvbiBSRUdMVGV4dHVyZSAodGFyZ2V0KSB7XG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKVxuICAgIHRoaXMubWlwbWFzayA9IDBcbiAgICB0aGlzLmludGVybmFsZm9ybWF0ID0gR0xfUkdCQSQxXG5cbiAgICB0aGlzLmlkID0gdGV4dHVyZUNvdW50KytcblxuICAgIHRoaXMucmVmQ291bnQgPSAxXG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFxuICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuXG4gICAgdGhpcy51bml0ID0gLTFcbiAgICB0aGlzLmJpbmRDb3VudCA9IDBcblxuICAgIHRoaXMudGV4SW5mbyA9IG5ldyBUZXhJbmZvKClcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHsgc2l6ZTogMCB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGVtcEJpbmQgKHRleHR1cmUpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEpXG4gICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIHRleHR1cmUudGV4dHVyZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBSZXN0b3JlICgpIHtcbiAgICB2YXIgcHJldiA9IHRleHR1cmVVbml0c1swXVxuICAgIGlmIChwcmV2KSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShwcmV2LnRhcmdldCwgcHJldi50ZXh0dXJlKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAodGV4dHVyZSkge1xuICAgIHZhciBoYW5kbGUgPSB0ZXh0dXJlLnRleHR1cmVcbiAgICBjaGVjayQxKGhhbmRsZSwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IHRleHR1cmUnKVxuICAgIHZhciB1bml0ID0gdGV4dHVyZS51bml0XG4gICAgdmFyIHRhcmdldCA9IHRleHR1cmUudGFyZ2V0XG4gICAgaWYgKHVuaXQgPj0gMCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgdW5pdClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgbnVsbClcbiAgICAgIHRleHR1cmVVbml0c1t1bml0XSA9IG51bGxcbiAgICB9XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShoYW5kbGUpXG4gICAgdGV4dHVyZS50ZXh0dXJlID0gbnVsbFxuICAgIHRleHR1cmUucGFyYW1zID0gbnVsbFxuICAgIHRleHR1cmUucGl4ZWxzID0gbnVsbFxuICAgIHRleHR1cmUucmVmQ291bnQgPSAwXG4gICAgZGVsZXRlIHRleHR1cmVTZXRbdGV4dHVyZS5pZF1cbiAgICBzdGF0cy50ZXh0dXJlQ291bnQtLVxuICB9XG5cbiAgZXh0ZW5kKFJFR0xUZXh0dXJlLnByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gdGhpc1xuICAgICAgdGV4dHVyZS5iaW5kQ291bnQgKz0gMVxuICAgICAgdmFyIHVuaXQgPSB0ZXh0dXJlLnVuaXRcbiAgICAgIGlmICh1bml0IDwgMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5iaW5kQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlci51bml0ID0gLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gdGV4dHVyZVxuICAgICAgICAgIHVuaXQgPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA+PSBudW1UZXhVbml0cykge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2luc3VmZmljaWVudCBudW1iZXIgb2YgdGV4dHVyZSB1bml0cycpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5wcm9maWxlICYmIHN0YXRzLm1heFRleHR1cmVVbml0cyA8ICh1bml0ICsgMSkpIHtcbiAgICAgICAgICBzdGF0cy5tYXhUZXh0dXJlVW5pdHMgPSB1bml0ICsgMSAvLyArMSwgc2luY2UgdGhlIHVuaXRzIGFyZSB6ZXJvLWJhc2VkXG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS51bml0ID0gdW5pdFxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyB1bml0KVxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaXRcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJpbmRDb3VudCAtPSAxXG4gICAgfSxcblxuICAgIGRlY1JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgIGRlc3Ryb3kodGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEIChhLCBiKSB7XG4gICAgdmFyIHRleHR1cmUgPSBuZXcgUkVHTFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxKVxuICAgIHRleHR1cmVTZXRbdGV4dHVyZS5pZF0gPSB0ZXh0dXJlXG4gICAgc3RhdHMudGV4dHVyZUNvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlMkQgKGEsIGIpIHtcbiAgICAgIHZhciB0ZXhJbmZvID0gdGV4dHVyZS50ZXhJbmZvXG4gICAgICBUZXhJbmZvLmNhbGwodGV4SW5mbylcbiAgICAgIHZhciBtaXBEYXRhID0gYWxsb2NNaXBNYXAoKVxuXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYiB8IDApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgYSB8IDAsIGEgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgICAgY2hlY2skMS50eXBlKGEsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVnbC50ZXh0dXJlJylcbiAgICAgICAgcGFyc2VUZXhJbmZvKHRleEluZm8sIGEpXG4gICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChtaXBEYXRhLCBhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgdGV4dHVyZXMgZ2V0IGFzc2lnbmVkIGEgZGVmYXVsdCBzaGFwZSBvZiAxeDFcbiAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgMSwgMSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRleEluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgICBtaXBEYXRhLm1pcG1hc2sgPSAobWlwRGF0YS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH1cbiAgICAgIHRleHR1cmUubWlwbWFzayA9IG1pcERhdGEubWlwbWFza1xuXG4gICAgICBjb3B5RmxhZ3ModGV4dHVyZSwgbWlwRGF0YSlcblxuICAgICAgY2hlY2skMS50ZXh0dXJlMkQodGV4SW5mbywgbWlwRGF0YSwgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IG1pcERhdGEuaW50ZXJuYWxmb3JtYXRcblxuICAgICAgcmVnbFRleHR1cmUyRC53aWR0aCA9IG1pcERhdGEud2lkdGhcbiAgICAgIHJlZ2xUZXh0dXJlMkQuaGVpZ2h0ID0gbWlwRGF0YS5oZWlnaHRcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldE1pcE1hcChtaXBEYXRhLCBHTF9URVhUVVJFXzJEJDEpXG4gICAgICBzZXRUZXhJbmZvKHRleEluZm8sIEdMX1RFWFRVUkVfMkQkMSlcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZU1pcE1hcChtaXBEYXRhKVxuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgdGV4dHVyZS5zdGF0cy5zaXplID0gZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgbWlwRGF0YS53aWR0aCxcbiAgICAgICAgICBtaXBEYXRhLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG4gICAgICByZWdsVGV4dHVyZTJELmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZTJELnR5cGUgPSB0ZXh0dXJlVHlwZXNJbnZlcnRbdGV4dHVyZS50eXBlXVxuXG4gICAgICByZWdsVGV4dHVyZTJELm1hZyA9IG1hZ0ZpbHRlcnNJbnZlcnRbdGV4SW5mby5tYWdGaWx0ZXJdXG4gICAgICByZWdsVGV4dHVyZTJELm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFMgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwU11cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFQgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwVF1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJpbWFnZSAoaW1hZ2UsIHhfLCB5XywgbGV2ZWxfKSB7XG4gICAgICBjaGVjayQxKCEhaW1hZ2UsICdtdXN0IHNwZWNpZnkgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHZhciB4ID0geF8gfCAwXG4gICAgICB2YXIgeSA9IHlfIHwgMFxuICAgICAgdmFyIGxldmVsID0gbGV2ZWxfIHwgMFxuXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1hZ2VEYXRhLCB0ZXh0dXJlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gMFxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IDBcbiAgICAgIHBhcnNlSW1hZ2UoaW1hZ2VEYXRhLCBpbWFnZSlcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IGltYWdlRGF0YS53aWR0aCB8fCAoKHRleHR1cmUud2lkdGggPj4gbGV2ZWwpIC0geClcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0IHx8ICgodGV4dHVyZS5oZWlnaHQgPj4gbGV2ZWwpIC0geSlcblxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS50eXBlID09PSBpbWFnZURhdGEudHlwZSAmJlxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9PT0gaW1hZ2VEYXRhLmZvcm1hdCAmJlxuICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID09PSBpbWFnZURhdGEuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICdpbmNvbXBhdGlibGUgZm9ybWF0IGZvciB0ZXh0dXJlLnN1YmltYWdlJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHggPj0gMCAmJiB5ID49IDAgJiZcbiAgICAgICAgeCArIGltYWdlRGF0YS53aWR0aCA8PSB0ZXh0dXJlLndpZHRoICYmXG4gICAgICAgIHkgKyBpbWFnZURhdGEuaGVpZ2h0IDw9IHRleHR1cmUuaGVpZ2h0LFxuICAgICAgICAndGV4dHVyZS5zdWJpbWFnZSB3cml0ZSBvdXQgb2YgYm91bmRzJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHRleHR1cmUubWlwbWFzayAmICgxIDw8IGxldmVsKSxcbiAgICAgICAgJ21pc3NpbmcgbWlwbWFwIGRhdGEnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhLmVsZW1lbnQgfHwgaW1hZ2VEYXRhLm5lZWRzQ29weSxcbiAgICAgICAgJ21pc3NpbmcgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBzZXRTdWJJbWFnZShpbWFnZURhdGEsIEdMX1RFWFRVUkVfMkQkMSwgeCwgeSwgbGV2ZWwpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGZyZWVJbWFnZShpbWFnZURhdGEpXG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcbiAgICAgIHZhciB3ID0gd18gfCAwXG4gICAgICB2YXIgaCA9IChoXyB8IDApIHx8IHdcbiAgICAgIGlmICh3ID09PSB0ZXh0dXJlLndpZHRoICYmIGggPT09IHRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgICB9XG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gd1xuICAgICAgcmVnbFRleHR1cmUyRC5oZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA9IGhcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRleHR1cmUubWlwbWFzayA+PiBpOyArK2kpIHtcbiAgICAgICAgdmFyIF93ID0gdyA+PiBpXG4gICAgICAgIHZhciBfaCA9IGggPj4gaVxuICAgICAgICBpZiAoIV93IHx8ICFfaCkgYnJlYWtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICBHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICBfdyxcbiAgICAgICAgICBfaCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICBudWxsKVxuICAgICAgfVxuICAgICAgdGVtcFJlc3RvcmUoKVxuXG4gICAgICAvLyBhbHNvLCByZWNvbXB1dGUgdGhlIHRleHR1cmUgc2l6ZS5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmUyRChhLCBiKVxuXG4gICAgcmVnbFRleHR1cmUyRC5zdWJpbWFnZSA9IHN1YmltYWdlXG4gICAgcmVnbFRleHR1cmUyRC5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZTJELl9yZWdsVHlwZSA9ICd0ZXh0dXJlMmQnXG4gICAgcmVnbFRleHR1cmUyRC5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlMkQuc3RhdHMgPSB0ZXh0dXJlLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xUZXh0dXJlMkQuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRleHR1cmUuZGVjUmVmKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBSRUdMVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmVcbiAgICBzdGF0cy5jdWJlQ291bnQrK1xuXG4gICAgdmFyIGZhY2VzID0gbmV3IEFycmF5KDYpXG5cbiAgICBmdW5jdGlvbiByZWdsVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgIHZhciBpXG4gICAgICB2YXIgdGV4SW5mbyA9IHRleHR1cmUudGV4SW5mb1xuICAgICAgVGV4SW5mby5jYWxsKHRleEluZm8pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldID0gYWxsb2NNaXBNYXAoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGEwID09PSAnbnVtYmVyJyB8fCAhYTApIHtcbiAgICAgICAgdmFyIHMgPSAoYTAgfCAwKSB8fCAxXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShmYWNlc1tpXSwgcywgcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChhMSkge1xuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1swXSwgYTApXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzFdLCBhMSlcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbMl0sIGEyKVxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1szXSwgYTMpXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzRdLCBhNClcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbNV0sIGE1KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlVGV4SW5mbyh0ZXhJbmZvLCBhMClcbiAgICAgICAgICBwYXJzZUZsYWdzKHRleHR1cmUsIGEwKVxuICAgICAgICAgIGlmICgnZmFjZXMnIGluIGEwKSB7XG4gICAgICAgICAgICB2YXIgZmFjZUlucHV0ID0gYTAuZmFjZXNcbiAgICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShmYWNlSW5wdXQpICYmIGZhY2VJbnB1dC5sZW5ndGggPT09IDYsXG4gICAgICAgICAgICAgICdjdWJlIGZhY2VzIG11c3QgYmUgYSBsZW5ndGggNiBhcnJheScpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2VJbnB1dFtpXSA9PT0gJ29iamVjdCcgJiYgISFmYWNlSW5wdXRbaV0sXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgaW5wdXQgZm9yIGN1YmUgbWFwIGZhY2UnKVxuICAgICAgICAgICAgICBjb3B5RmxhZ3MoZmFjZXNbaV0sIHRleHR1cmUpXG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgZmFjZUlucHV0W2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgYTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byBjdWJlIG1hcCcpXG4gICAgICB9XG5cbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBmYWNlc1swXSlcblxuICAgICAgaWYgKCFsaW1pdHMubnBvdFRleHR1cmVDdWJlKSB7XG4gICAgICAgIGNoZWNrJDEoaXNQb3cyJDEodGV4dHVyZS53aWR0aCkgJiYgaXNQb3cyJDEodGV4dHVyZS5oZWlnaHQpLCAneW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbm9uIHBvd2VyIG9yIHR3byB0ZXh0dXJlIGRpbWVuc2lvbnMnKVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4SW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IChmYWNlc1swXS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IGZhY2VzWzBdLm1pcG1hc2tcbiAgICAgIH1cblxuICAgICAgY2hlY2skMS50ZXh0dXJlQ3ViZSh0ZXh0dXJlLCB0ZXhJbmZvLCBmYWNlcywgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IGZhY2VzWzBdLmludGVybmFsZm9ybWF0XG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCA9IGZhY2VzWzBdLndpZHRoXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gZmFjZXNbMF0uaGVpZ2h0XG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIHNldE1pcE1hcChmYWNlc1tpXSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBpKVxuICAgICAgfVxuICAgICAgc2V0VGV4SW5mbyh0ZXhJbmZvLCBHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgcmVnbFRleHR1cmVDdWJlLmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZUN1YmUudHlwZSA9IHRleHR1cmVUeXBlc0ludmVydFt0ZXh0dXJlLnR5cGVdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5tYWcgPSBtYWdGaWx0ZXJzSW52ZXJ0W3RleEluZm8ubWFnRmlsdGVyXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLndyYXBUID0gd3JhcE1vZGVzSW52ZXJ0W3RleEluZm8ud3JhcFRdXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZnJlZU1pcE1hcChmYWNlc1tpXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmltYWdlIChmYWNlLCBpbWFnZSwgeF8sIHlfLCBsZXZlbF8pIHtcbiAgICAgIGNoZWNrJDEoISFpbWFnZSwgJ211c3Qgc3BlY2lmeSBpbWFnZSBkYXRhJylcbiAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2UgPT09ICdudW1iZXInICYmIGZhY2UgPT09IChmYWNlIHwgMCkgJiZcbiAgICAgICAgZmFjZSA+PSAwICYmIGZhY2UgPCA2LCAnaW52YWxpZCBmYWNlJylcblxuICAgICAgdmFyIHggPSB4XyB8IDBcbiAgICAgIHZhciB5ID0geV8gfCAwXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbF8gfCAwXG5cbiAgICAgIHZhciBpbWFnZURhdGEgPSBhbGxvY0ltYWdlKClcbiAgICAgIGNvcHlGbGFncyhpbWFnZURhdGEsIHRleHR1cmUpXG4gICAgICBpbWFnZURhdGEud2lkdGggPSAwXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gMFxuICAgICAgcGFyc2VJbWFnZShpbWFnZURhdGEsIGltYWdlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoIHx8ICgodGV4dHVyZS53aWR0aCA+PiBsZXZlbCkgLSB4KVxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQgfHwgKCh0ZXh0dXJlLmhlaWdodCA+PiBsZXZlbCkgLSB5KVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0ZXh0dXJlLnR5cGUgPT09IGltYWdlRGF0YS50eXBlICYmXG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID09PSBpbWFnZURhdGEuZm9ybWF0ICYmXG4gICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPT09IGltYWdlRGF0YS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgJ2luY29tcGF0aWJsZSBmb3JtYXQgZm9yIHRleHR1cmUuc3ViaW1hZ2UnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHkgPj0gMCAmJlxuICAgICAgICB4ICsgaW1hZ2VEYXRhLndpZHRoIDw9IHRleHR1cmUud2lkdGggJiZcbiAgICAgICAgeSArIGltYWdlRGF0YS5oZWlnaHQgPD0gdGV4dHVyZS5oZWlnaHQsXG4gICAgICAgICd0ZXh0dXJlLnN1YmltYWdlIHdyaXRlIG91dCBvZiBib3VuZHMnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrICYgKDEgPDwgbGV2ZWwpLFxuICAgICAgICAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICBjaGVjayQxKFxuICAgICAgICBpbWFnZURhdGEuZGF0YSB8fCBpbWFnZURhdGEuZWxlbWVudCB8fCBpbWFnZURhdGEubmVlZHNDb3B5LFxuICAgICAgICAnbWlzc2luZyBpbWFnZSBkYXRhJylcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldFN1YkltYWdlKGltYWdlRGF0YSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBmYWNlLCB4LCB5LCBsZXZlbClcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZUltYWdlKGltYWdlRGF0YSlcblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c18gfCAwXG4gICAgICBpZiAocmFkaXVzID09PSB0ZXh0dXJlLndpZHRoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gcmFkaXVzXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPSByYWRpdXNcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyB0ZXh0dXJlLm1pcG1hc2sgPj4gajsgKytqKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICAgIHJhZGl1cyA+PiBqLFxuICAgICAgICAgICAgcmFkaXVzID4+IGosXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgICBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmVDdWJlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpXG5cbiAgICByZWdsVGV4dHVyZUN1YmUuc3ViaW1hZ2UgPSBzdWJpbWFnZVxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZUN1YmUuX3JlZ2xUeXBlID0gJ3RleHR1cmVDdWJlJ1xuICAgIHJlZ2xUZXh0dXJlQ3ViZS5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5zdGF0cyA9IHRleHR1cmUuc3RhdHNcbiAgICB9XG4gICAgcmVnbFRleHR1cmVDdWJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0dXJlLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gcmVnbCBpcyBkZXN0cm95ZWRcbiAgZnVuY3Rpb24gZGVzdHJveVRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSArIGkpXG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgfVxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG5cbiAgICBzdGF0cy5jdWJlQ291bnQgPSAwXG4gICAgc3RhdHMudGV4dHVyZUNvdW50ID0gMFxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0VG90YWxUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHRleHR1cmVTZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0b3RhbCArPSB0ZXh0dXJlU2V0W2tleV0uc3RhdHMuc2l6ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVUZXh0dXJlcyAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UZXhVbml0czsgKytpKSB7XG4gICAgICB2YXIgdGV4ID0gdGV4dHVyZVVuaXRzW2ldXG4gICAgICBpZiAodGV4KSB7XG4gICAgICAgIHRleC5iaW5kQ291bnQgPSAwXG4gICAgICAgIHRleC51bml0ID0gLTFcbiAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0ZXh0dXJlLnRleHR1cmUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ZXh0dXJlLm1pcG1hc2sgJiAoMSA8PCBpKSkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLnRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQxKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUud2lkdGggPj4gaSxcbiAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2OyArK2opIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBqLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoID4+IGksXG4gICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFRleEluZm8odGV4dHVyZS50ZXhJbmZvLCB0ZXh0dXJlLnRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIHZhciB0ZXggPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgIGlmICh0ZXgpIHtcbiAgICAgICAgdGV4LmJpbmRDb3VudCA9IDBcbiAgICAgICAgdGV4LnVuaXQgPSAtMVxuICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgICB9XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyBpKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxLCBudWxsKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCQxLCBudWxsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlMkQ6IGNyZWF0ZVRleHR1cmUyRCxcbiAgICBjcmVhdGVDdWJlOiBjcmVhdGVUZXh0dXJlQ3ViZSxcbiAgICBjbGVhcjogZGVzdHJveVRleHR1cmVzLFxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVRleHR1cmVzLFxuICAgIHJlZnJlc2g6IHJlZnJlc2hUZXh0dXJlc1xuICB9XG59XG5cbnZhciBHTF9SRU5ERVJCVUZGRVIgPSAweDhENDFcblxudmFyIEdMX1JHQkE0JDEgPSAweDgwNTZcbnZhciBHTF9SR0I1X0ExJDEgPSAweDgwNTdcbnZhciBHTF9SR0I1NjUkMSA9IDB4OEQ2MlxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVDE2ID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDggPSAweDhENDhcbnZhciBHTF9ERVBUSF9TVEVOQ0lMJDEgPSAweDg0RjlcblxudmFyIEdMX1NSR0I4X0FMUEhBOF9FWFQgPSAweDhDNDNcblxudmFyIEdMX1JHQkEzMkZfRVhUID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCA9IDB4ODgxQVxudmFyIEdMX1JHQjE2Rl9FWFQgPSAweDg4MUJcblxudmFyIEZPUk1BVF9TSVpFUyA9IFtdXG5cbkZPUk1BVF9TSVpFU1tHTF9SR0JBNCQxXSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9SR0I1X0ExJDFdID0gMlxuRk9STUFUX1NJWkVTW0dMX1JHQjU2NSQxXSA9IDJcblxuRk9STUFUX1NJWkVTW0dMX0RFUFRIX0NPTVBPTkVOVDE2XSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9TVEVOQ0lMX0lOREVYOF0gPSAxXG5GT1JNQVRfU0laRVNbR0xfREVQVEhfU1RFTkNJTCQxXSA9IDRcblxuRk9STUFUX1NJWkVTW0dMX1NSR0I4X0FMUEhBOF9FWFRdID0gNFxuRk9STUFUX1NJWkVTW0dMX1JHQkEzMkZfRVhUXSA9IDE2XG5GT1JNQVRfU0laRVNbR0xfUkdCQTE2Rl9FWFRdID0gOFxuRk9STUFUX1NJWkVTW0dMX1JHQjE2Rl9FWFRdID0gNlxuXG5mdW5jdGlvbiBnZXRSZW5kZXJidWZmZXJTaXplIChmb3JtYXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIEZPUk1BVF9TSVpFU1tmb3JtYXRdICogd2lkdGggKiBoZWlnaHRcbn1cblxudmFyIHdyYXBSZW5kZXJidWZmZXJzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzLCBjb25maWcpIHtcbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgICdyZ2JhNCc6IEdMX1JHQkE0JDEsXG4gICAgJ3JnYjU2NSc6IEdMX1JHQjU2NSQxLFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSQxLFxuICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVDE2LFxuICAgICdzdGVuY2lsJzogR0xfU1RFTkNJTF9JTkRFWDgsXG4gICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XG4gICAgZm9ybWF0VHlwZXNbJ3NyZ2JhJ10gPSBHTF9TUkdCOF9BTFBIQThfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTE2ZiddID0gR0xfUkdCQTE2Rl9FWFRcbiAgICBmb3JtYXRUeXBlc1sncmdiMTZmJ10gPSBHTF9SR0IxNkZfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTMyZiddID0gR0xfUkdCQTMyRl9FWFRcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlc0ludmVydCA9IFtdXG4gIE9iamVjdC5rZXlzKGZvcm1hdFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gZm9ybWF0VHlwZXNba2V5XVxuICAgIGZvcm1hdFR5cGVzSW52ZXJ0W3ZhbF0gPSBrZXlcbiAgfSlcblxuICB2YXIgcmVuZGVyYnVmZmVyQ291bnQgPSAwXG4gIHZhciByZW5kZXJidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xSZW5kZXJidWZmZXIgKHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMuaWQgPSByZW5kZXJidWZmZXJDb3VudCsrXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB0aGlzLmZvcm1hdCA9IEdMX1JHQkE0JDFcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMUmVuZGVyYnVmZmVyLnByb3RvdHlwZS5kZWNSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICBkZXN0cm95KHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAocmIpIHtcbiAgICB2YXIgaGFuZGxlID0gcmIucmVuZGVyYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSByZW5kZXJidWZmZXInKVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihoYW5kbGUpXG4gICAgcmIucmVuZGVyYnVmZmVyID0gbnVsbFxuICAgIHJiLnJlZkNvdW50ID0gMFxuICAgIGRlbGV0ZSByZW5kZXJidWZmZXJTZXRbcmIuaWRdXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQtLVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyYnVmZmVyIChhLCBiKSB7XG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IG5ldyBSRUdMUmVuZGVyYnVmZmVyKGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpKVxuICAgIHJlbmRlcmJ1ZmZlclNldFtyZW5kZXJidWZmZXIuaWRdID0gcmVuZGVyYnVmZmVyXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbFJlbmRlcmJ1ZmZlciAoYSwgYikge1xuICAgICAgdmFyIHcgPSAwXG4gICAgICB2YXIgaCA9IDBcbiAgICAgIHZhciBmb3JtYXQgPSBHTF9SR0JBNCQxXG5cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcbiAgICAgICAgaWYgKCdzaGFwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBzaGFwZSA9IG9wdGlvbnMuc2hhcGVcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkoc2hhcGUpICYmIHNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNoYXBlJylcbiAgICAgICAgICB3ID0gc2hhcGVbMF0gfCAwXG4gICAgICAgICAgaCA9IHNoYXBlWzFdIHwgMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGggPSBvcHRpb25zLmhlaWdodCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLmZvcm1hdCwgZm9ybWF0VHlwZXMsXG4gICAgICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgZm9ybWF0JylcbiAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRUeXBlc1tvcHRpb25zLmZvcm1hdF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdyA9IGEgfCAwXG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBoID0gYiB8IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoID0gd1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhKSB7XG4gICAgICAgIHcgPSBoID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVuZGVyYnVmZmVyIGNvbnN0cnVjdG9yJylcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgc2hhcGVcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHcgPiAwICYmIGggPiAwICYmXG4gICAgICAgIHcgPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUgJiYgaCA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSxcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNpemUnKVxuXG4gICAgICBpZiAodyA9PT0gcmVuZGVyYnVmZmVyLndpZHRoICYmXG4gICAgICAgICAgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCAmJlxuICAgICAgICAgIGZvcm1hdCA9PT0gcmVuZGVyYnVmZmVyLmZvcm1hdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci53aWR0aCA9IHJlbmRlcmJ1ZmZlci53aWR0aCA9IHdcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuaGVpZ2h0ID0gcmVuZGVyYnVmZmVyLmhlaWdodCA9IGhcbiAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRcblxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgZm9ybWF0LCB3LCBoKVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbC5nZXRFcnJvcigpID09PSAwLFxuICAgICAgICAnaW52YWxpZCByZW5kZXIgYnVmZmVyIGZvcm1hdCcpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICByZW5kZXJidWZmZXIuc3RhdHMuc2l6ZSA9IGdldFJlbmRlcmJ1ZmZlclNpemUocmVuZGVyYnVmZmVyLmZvcm1hdCwgcmVuZGVyYnVmZmVyLndpZHRoLCByZW5kZXJidWZmZXIuaGVpZ2h0KVxuICAgICAgfVxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRUeXBlc0ludmVydFtyZW5kZXJidWZmZXIuZm9ybWF0XVxuXG4gICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICB2YXIgdyA9IHdfIHwgMFxuICAgICAgdmFyIGggPSAoaF8gfCAwKSB8fCB3XG5cbiAgICAgIGlmICh3ID09PSByZW5kZXJidWZmZXIud2lkdGggJiYgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBzaGFwZVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdyA+IDAgJiYgaCA+IDAgJiZcbiAgICAgICAgdyA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSAmJiBoIDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplLFxuICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2l6ZScpXG5cbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIud2lkdGggPSByZW5kZXJidWZmZXIud2lkdGggPSB3XG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmhlaWdodCA9IHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBoXG5cbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHcsIGgpXG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGdsLmdldEVycm9yKCkgPT09IDAsXG4gICAgICAgICdpbnZhbGlkIHJlbmRlciBidWZmZXIgZm9ybWF0JylcblxuICAgICAgLy8gYWxzbywgcmVjb21wdXRlIHNpemUuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgcmVuZGVyYnVmZmVyLnN0YXRzLnNpemUgPSBnZXRSZW5kZXJidWZmZXJTaXplKFxuICAgICAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHJlbmRlcmJ1ZmZlci53aWR0aCwgcmVuZGVyYnVmZmVyLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgICB9XG5cbiAgICByZWdsUmVuZGVyYnVmZmVyKGEsIGIpXG5cbiAgICByZWdsUmVuZGVyYnVmZmVyLnJlc2l6ZSA9IHJlc2l6ZVxuICAgIHJlZ2xSZW5kZXJidWZmZXIuX3JlZ2xUeXBlID0gJ3JlbmRlcmJ1ZmZlcidcbiAgICByZWdsUmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuc3RhdHMgPSByZW5kZXJidWZmZXIuc3RhdHNcbiAgICB9XG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVuZGVyYnVmZmVyLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsUmVuZGVyYnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IHJlbmRlcmJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlUmVuZGVyYnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAocmIpIHtcbiAgICAgIHJiLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpXG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgcmIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJiLmZvcm1hdCwgcmIud2lkdGgsIHJiLmhlaWdodClcbiAgICB9KVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZVJlbmRlcmJ1ZmZlcixcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVJlbmRlcmJ1ZmZlcnNcbiAgfVxufVxuXG4vLyBXZSBzdG9yZSB0aGVzZSBjb25zdGFudHMgc28gdGhhdCB0aGUgbWluaWZpZXIgY2FuIGlubGluZSB0aGVtXG52YXIgR0xfRlJBTUVCVUZGRVIkMSA9IDB4OEQ0MFxudmFyIEdMX1JFTkRFUkJVRkZFUiQxID0gMHg4RDQxXG5cbnZhciBHTF9URVhUVVJFXzJEJDIgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiA9IDB4ODUxNVxuXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSA9IDB4OENFMFxudmFyIEdMX0RFUFRIX0FUVEFDSE1FTlQgPSAweDhEMDBcbnZhciBHTF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDhEMjBcbnZhciBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDgyMUFcblxudmFyIEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEgPSAweDhDRDVcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQgPSAweDhDRDZcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCA9IDB4OENEN1xudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyA9IDB4OENEOVxudmFyIEdMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEID0gMHg4Q0REXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyQyID0gMHg4RDYxXG52YXIgR0xfVU5TSUdORURfQllURSQ2ID0gMHgxNDAxXG52YXIgR0xfRkxPQVQkNSA9IDB4MTQwNlxuXG52YXIgR0xfUkdCJDEgPSAweDE5MDdcbnZhciBHTF9SR0JBJDIgPSAweDE5MDhcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCQxID0gMHgxOTAyXG5cbnZhciBjb2xvclRleHR1cmVGb3JtYXRFbnVtcyA9IFtcbiAgR0xfUkdCJDEsXG4gIEdMX1JHQkEkMlxuXVxuXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSBmb3JtYXQsIHN0b3JlXG4vLyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG52YXIgdGV4dHVyZUZvcm1hdENoYW5uZWxzID0gW11cbnRleHR1cmVGb3JtYXRDaGFubmVsc1tHTF9SR0JBJDJdID0gNFxudGV4dHVyZUZvcm1hdENoYW5uZWxzW0dMX1JHQiQxXSA9IDNcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIHRleHR1cmVUeXBlU2l6ZXMgPSBbXVxudGV4dHVyZVR5cGVTaXplc1tHTF9VTlNJR05FRF9CWVRFJDZdID0gMVxudGV4dHVyZVR5cGVTaXplc1tHTF9GTE9BVCQ1XSA9IDRcbnRleHR1cmVUeXBlU2l6ZXNbR0xfSEFMRl9GTE9BVF9PRVMkMl0gPSAyXG5cbnZhciBHTF9SR0JBNCQyID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSQyID0gMHg4MDU3XG52YXIgR0xfUkdCNTY1JDIgPSAweDhENjJcbnZhciBHTF9ERVBUSF9DT01QT05FTlQxNiQxID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDgkMSA9IDB4OEQ0OFxudmFyIEdMX0RFUFRIX1NURU5DSUwkMiA9IDB4ODRGOVxuXG52YXIgR0xfU1JHQjhfQUxQSEE4X0VYVCQxID0gMHg4QzQzXG5cbnZhciBHTF9SR0JBMzJGX0VYVCQxID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCQxID0gMHg4ODFBXG52YXIgR0xfUkdCMTZGX0VYVCQxID0gMHg4ODFCXG5cbnZhciBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zID0gW1xuICBHTF9SR0JBNCQyLFxuICBHTF9SR0I1X0ExJDIsXG4gIEdMX1JHQjU2NSQyLFxuICBHTF9TUkdCOF9BTFBIQThfRVhUJDEsXG4gIEdMX1JHQkExNkZfRVhUJDEsXG4gIEdMX1JHQjE2Rl9FWFQkMSxcbiAgR0xfUkdCQTMyRl9FWFQkMVxuXVxuXG52YXIgc3RhdHVzQ29kZSA9IHt9XG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDFdID0gJ2NvbXBsZXRlJ1xuc3RhdHVzQ29kZVtHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdID0gJ2luY29tcGxldGUgYXR0YWNobWVudCdcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXSA9ICdpbmNvbXBsZXRlIGRpbWVuc2lvbnMnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXSA9ICdpbmNvbXBsZXRlLCBtaXNzaW5nIGF0dGFjaG1lbnQnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXSA9ICd1bnN1cHBvcnRlZCdcblxuZnVuY3Rpb24gd3JhcEZCT1N0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgdGV4dHVyZVN0YXRlLFxuICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgc3RhdHMpIHtcbiAgdmFyIGZyYW1lYnVmZmVyU3RhdGUgPSB7XG4gICAgY3VyOiBudWxsLFxuICAgIG5leHQ6IG51bGwsXG4gICAgZGlydHk6IGZhbHNlLFxuICAgIHNldEZCTzogbnVsbFxuICB9XG5cbiAgdmFyIGNvbG9yVGV4dHVyZUZvcm1hdHMgPSBbJ3JnYmEnXVxuICB2YXIgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzID0gWydyZ2JhNCcsICdyZ2I1NjUnLCAncmdiNSBhMSddXG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3NyZ2IpIHtcbiAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMucHVzaCgnc3JnYmEnKVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0KSB7XG4gICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLnB1c2goJ3JnYmExNmYnLCAncmdiMTZmJylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCkge1xuICAgIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5wdXNoKCdyZ2JhMzJmJylcbiAgfVxuXG4gIHZhciBjb2xvclR5cGVzID0gWyd1aW50OCddXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2hhbGYgZmxvYXQnLCAnZmxvYXQxNicpXG4gIH1cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2Zsb2F0JywgJ2Zsb2F0MzInKVxuICB9XG5cbiAgZnVuY3Rpb24gRnJhbWVidWZmZXJBdHRhY2htZW50ICh0YXJnZXQsIHRleHR1cmUsIHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB2YXIgdyA9IDBcbiAgICB2YXIgaCA9IDBcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdyA9IHRleHR1cmUud2lkdGhcbiAgICAgIGggPSB0ZXh0dXJlLmhlaWdodFxuICAgIH0gZWxzZSBpZiAocmVuZGVyYnVmZmVyKSB7XG4gICAgICB3ID0gcmVuZGVyYnVmZmVyLndpZHRoXG4gICAgICBoID0gcmVuZGVyYnVmZmVyLmhlaWdodFxuICAgIH1cbiAgICB0aGlzLndpZHRoID0gd1xuICAgIHRoaXMuaGVpZ2h0ID0gaFxuICB9XG5cbiAgZnVuY3Rpb24gZGVjUmVmIChhdHRhY2htZW50KSB7XG4gICAgaWYgKGF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcbiAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmRlY1JlZigpXG4gICAgICB9XG4gICAgICBpZiAoYXR0YWNobWVudC5yZW5kZXJidWZmZXIpIHtcbiAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5kZWNSZWYoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY1JlZkFuZENoZWNrU2hhcGUgKGF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZVxuICAgICAgdmFyIHR3ID0gTWF0aC5tYXgoMSwgdGV4dHVyZS53aWR0aClcbiAgICAgIHZhciB0aCA9IE1hdGgubWF4KDEsIHRleHR1cmUuaGVpZ2h0KVxuICAgICAgY2hlY2skMSh0dyA9PT0gd2lkdGggJiYgdGggPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHN1cHBsaWVkIHRleHR1cmUnKVxuICAgICAgdGV4dHVyZS5yZWZDb3VudCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZW5kZXJidWZmZXIgPSBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyXG4gICAgICBjaGVjayQxKFxuICAgICAgICByZW5kZXJidWZmZXIud2lkdGggPT09IHdpZHRoICYmIHJlbmRlcmJ1ZmZlci5oZWlnaHQgPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICByZW5kZXJidWZmZXIucmVmQ291bnQgKz0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaCAobG9jYXRpb24sIGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIGF0dGFjaG1lbnQudGFyZ2V0LFxuICAgICAgICAgIGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIEdMX1JFTkRFUkJVRkZFUiQxLFxuICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudCAoYXR0YWNobWVudCkge1xuICAgIHZhciB0YXJnZXQgPSBHTF9URVhUVVJFXzJEJDJcbiAgICB2YXIgdGV4dHVyZSA9IG51bGxcbiAgICB2YXIgcmVuZGVyYnVmZmVyID0gbnVsbFxuXG4gICAgdmFyIGRhdGEgPSBhdHRhY2htZW50XG4gICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YVxuICAgICAgaWYgKCd0YXJnZXQnIGluIGF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYXR0YWNobWVudC50YXJnZXQgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMS50eXBlKGRhdGEsICdmdW5jdGlvbicsICdpbnZhbGlkIGF0dGFjaG1lbnQgZGF0YScpXG5cbiAgICB2YXIgdHlwZSA9IGRhdGEuX3JlZ2xUeXBlXG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0dXJlMmQnKSB7XG4gICAgICB0ZXh0dXJlID0gZGF0YVxuICAgICAgY2hlY2skMSh0YXJnZXQgPT09IEdMX1RFWFRVUkVfMkQkMilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgIHRleHR1cmUgPSBkYXRhXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0YXJnZXQgPj0gR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgJiZcbiAgICAgICAgdGFyZ2V0IDwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgKyA2LFxuICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCB0YXJnZXQnKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmJ1ZmZlcicpIHtcbiAgICAgIHJlbmRlcmJ1ZmZlciA9IGRhdGFcbiAgICAgIHRhcmdldCA9IEdMX1JFTkRFUkJVRkZFUiQxXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgcmVnbCBvYmplY3QgZm9yIGF0dGFjaG1lbnQnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KHRhcmdldCwgdGV4dHVyZSwgcmVuZGVyYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NBdHRhY2htZW50IChcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgaXNUZXh0dXJlLFxuICAgIGZvcm1hdCxcbiAgICB0eXBlKSB7XG4gICAgaWYgKGlzVGV4dHVyZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQoe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSlcbiAgICAgIHRleHR1cmUuX3RleHR1cmUucmVmQ291bnQgPSAwXG4gICAgICByZXR1cm4gbmV3IEZyYW1lYnVmZmVyQXR0YWNobWVudChHTF9URVhUVVJFXzJEJDIsIHRleHR1cmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYiA9IHJlbmRlcmJ1ZmZlclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgICB9KVxuICAgICAgcmIuX3JlbmRlcmJ1ZmZlci5yZWZDb3VudCA9IDBcbiAgICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KEdMX1JFTkRFUkJVRkZFUiQxLCBudWxsLCByYilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXBBdHRhY2htZW50IChhdHRhY2htZW50KSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnQgJiYgKGF0dGFjaG1lbnQudGV4dHVyZSB8fCBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZUF0dGFjaG1lbnQgKGF0dGFjaG1lbnQsIHcsIGgpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBhdHRhY2htZW50LnRleHR1cmUucmVzaXplKHcsIGgpXG4gICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyKSB7XG4gICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLnJlc2l6ZSh3LCBoKVxuICAgICAgfVxuICAgICAgYXR0YWNobWVudC53aWR0aCA9IHdcbiAgICAgIGF0dGFjaG1lbnQuaGVpZ2h0ID0gaFxuICAgIH1cbiAgfVxuXG4gIHZhciBmcmFtZWJ1ZmZlckNvdW50ID0gMFxuICB2YXIgZnJhbWVidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xGcmFtZWJ1ZmZlciAoKSB7XG4gICAgdGhpcy5pZCA9IGZyYW1lYnVmZmVyQ291bnQrK1xuICAgIGZyYW1lYnVmZmVyU2V0W3RoaXMuaWRdID0gdGhpc1xuXG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgdGhpcy5jb2xvckF0dGFjaG1lbnRzID0gW11cbiAgICB0aGlzLmRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICB0aGlzLnN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuICAgIHRoaXMuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY0ZCT1JlZnMgKGZyYW1lYnVmZmVyKSB7XG4gICAgZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50cy5mb3JFYWNoKGRlY1JlZilcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudClcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKGZyYW1lYnVmZmVyKSB7XG4gICAgdmFyIGhhbmRsZSA9IGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSBmcmFtZWJ1ZmZlcicpXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoaGFuZGxlKVxuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gbnVsbFxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQtLVxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlclNldFtmcmFtZWJ1ZmZlci5pZF1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lYnVmZmVyIChmcmFtZWJ1ZmZlcikge1xuICAgIHZhciBpXG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIkMSwgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIpXG4gICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGF0dGFjaChHTF9DT0xPUl9BVFRBQ0hNRU5UMCQxICsgaSwgY29sb3JBdHRhY2htZW50c1tpXSlcbiAgICB9XG4gICAgZm9yIChpID0gY29sb3JBdHRhY2htZW50cy5sZW5ndGg7IGkgPCBsaW1pdHMubWF4Q29sb3JBdHRhY2htZW50czsgKytpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgR0xfRlJBTUVCVUZGRVIkMSxcbiAgICAgICAgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSArIGksXG4gICAgICAgIEdMX1RFWFRVUkVfMkQkMixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMClcbiAgICB9XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXG4gICAgICBudWxsLFxuICAgICAgMClcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgR0xfU1RFTkNJTF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG5cbiAgICBhdHRhY2goR0xfREVQVEhfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpXG5cbiAgICAvLyBDaGVjayBzdGF0dXMgY29kZVxuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKEdMX0ZSQU1FQlVGRkVSJDEpXG4gICAgaWYgKCFnbC5pc0NvbnRleHRMb3N0KCkgJiYgc3RhdHVzICE9PSBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSQxKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uIG5vdCBzdXBwb3J0ZWQsIHN0YXR1cyA9ICcgK1xuICAgICAgICBzdGF0dXNDb2RlW3N0YXR1c10pXG4gICAgfVxuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSJDEsIGZyYW1lYnVmZmVyU3RhdGUubmV4dCA/IGZyYW1lYnVmZmVyU3RhdGUubmV4dC5mcmFtZWJ1ZmZlciA6IG51bGwpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBmcmFtZWJ1ZmZlclN0YXRlLm5leHRcblxuICAgIC8vIEZJWE1FOiBDbGVhciBlcnJvciBjb2RlIGhlcmUuICBUaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIGEgYnVnIGluXG4gICAgLy8gaGVhZGxlc3MtZ2xcbiAgICBnbC5nZXRFcnJvcigpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGQk8gKGEwLCBhMSkge1xuICAgIHZhciBmcmFtZWJ1ZmZlciA9IG5ldyBSRUdMRnJhbWVidWZmZXIoKVxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbEZyYW1lYnVmZmVyIChhLCBiKSB7XG4gICAgICB2YXIgaVxuXG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHVwZGF0ZSBmcmFtZWJ1ZmZlciB3aGljaCBpcyBjdXJyZW50bHkgaW4gdXNlJylcblxuICAgICAgdmFyIHdpZHRoID0gMFxuICAgICAgdmFyIGhlaWdodCA9IDBcblxuICAgICAgdmFyIG5lZWRzRGVwdGggPSB0cnVlXG4gICAgICB2YXIgbmVlZHNTdGVuY2lsID0gdHJ1ZVxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JUZXh0dXJlID0gdHJ1ZVxuICAgICAgdmFyIGNvbG9yRm9ybWF0ID0gJ3JnYmEnXG4gICAgICB2YXIgY29sb3JUeXBlID0gJ3VpbnQ4J1xuICAgICAgdmFyIGNvbG9yQ291bnQgPSAxXG5cbiAgICAgIHZhciBkZXB0aEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQnVmZmVyID0gbnVsbFxuICAgICAgdmFyIGRlcHRoU3RlbmNpbEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxUZXh0dXJlID0gZmFsc2VcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICB3aWR0aCA9IGEgfCAwXG4gICAgICAgIGhlaWdodCA9IChiIHwgMCkgfHwgd2lkdGhcbiAgICAgIH0gZWxzZSBpZiAoIWEpIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICAgIHdpZHRoID0gc2hhcGVbMF1cbiAgICAgICAgICBoZWlnaHQgPSBzaGFwZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnd2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy53aWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2NvbG9yJyBpbiBvcHRpb25zIHx8XG4gICAgICAgICAgICAnY29sb3JzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY29sb3JCdWZmZXIgPVxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvciB8fFxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvcnNcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvckJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICAgIGNvbG9yQnVmZmVyLmxlbmd0aCA9PT0gMSB8fCBleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyxcbiAgICAgICAgICAgICAgJ211bHRpcGxlIHJlbmRlciB0YXJnZXRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29sb3JCdWZmZXIpIHtcbiAgICAgICAgICBpZiAoJ2NvbG9yQ291bnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yQ291bnQgPSBvcHRpb25zLmNvbG9yQ291bnQgfCAwXG4gICAgICAgICAgICBjaGVjayQxKGNvbG9yQ291bnQgPiAwLCAnaW52YWxpZCBjb2xvciBidWZmZXIgY291bnQnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JUZXh0dXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvclRleHR1cmUgPSAhIW9wdGlvbnMuY29sb3JUZXh0dXJlXG4gICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhNCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2NvbG9yVHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JUeXBlID0gb3B0aW9ucy5jb2xvclR5cGVcbiAgICAgICAgICAgIGlmICghY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIEVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCB0byB1c2UgMTYtYml0IHJlbmRlciBidWZmZXJzJylcbiAgICAgICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhMTZmJ1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yVHlwZSA9PT0gJ2Zsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMzItYml0IGZsb2F0aW5nIHBvaW50IHJlbmRlcmJ1ZmZlcnMnKVxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gJ3JnYmEzMmYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCB8fFxuICAgICAgICAgICAgICAgICEoY29sb3JUeXBlID09PSAnZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MzInKSxcbiAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBPRVNfdGV4dHVyZV9mbG9hdCBpbiBvcmRlciB0byB1c2UgZmxvYXRpbmcgcG9pbnQgZnJhbWVidWZmZXIgb2JqZWN0cycpXG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IHx8XG4gICAgICAgICAgICAgICAgIShjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2JyksXG4gICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMTYtYml0IGZsb2F0aW5nIHBvaW50IGZyYW1lYnVmZmVyIG9iamVjdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2skMS5vbmVPZihjb2xvclR5cGUsIGNvbG9yVHlwZXMsICdpbnZhbGlkIGNvbG9yIHR5cGUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JGb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gb3B0aW9ucy5jb2xvckZvcm1hdFxuICAgICAgICAgICAgaWYgKGNvbG9yVGV4dHVyZUZvcm1hdHMuaW5kZXhPZihjb2xvckZvcm1hdCkgPj0gMCkge1xuICAgICAgICAgICAgICBjb2xvclRleHR1cmUgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5pbmRleE9mKGNvbG9yRm9ybWF0KSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlcHRoVGV4dHVyZScgaW4gb3B0aW9ucyB8fCAnZGVwdGhTdGVuY2lsVGV4dHVyZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGRlcHRoU3RlbmNpbFRleHR1cmUgPSAhIShvcHRpb25zLmRlcHRoVGV4dHVyZSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5kZXB0aFN0ZW5jaWxUZXh0dXJlKVxuICAgICAgICAgIGNoZWNrJDEoIWRlcHRoU3RlbmNpbFRleHR1cmUgfHwgZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlLFxuICAgICAgICAgICAgJ3dlYmdsX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gb3B0aW9ucy5kZXB0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhcbiAgICAgICAgICAgIG5lZWRzU3RlbmNpbCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdzdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0ZW5jaWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5zdGVuY2lsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGhTdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoU3RlbmNpbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVwdGhTdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgYXR0YWNobWVudHNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gbnVsbFxuICAgICAgdmFyIGRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuXG4gICAgICAvLyBTZXQgdXAgY29sb3IgYXR0YWNobWVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICBjb2xvckF0dGFjaG1lbnRzID0gY29sb3JCdWZmZXIubWFwKHBhcnNlQXR0YWNobWVudClcbiAgICAgIH0gZWxzZSBpZiAoY29sb3JCdWZmZXIpIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IFtwYXJzZUF0dGFjaG1lbnQoY29sb3JCdWZmZXIpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IG5ldyBBcnJheShjb2xvckNvdW50KVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JDb3VudDsgKytpKSB7XG4gICAgICAgICAgY29sb3JBdHRhY2htZW50c1tpXSA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JUZXh0dXJlLFxuICAgICAgICAgICAgY29sb3JGb3JtYXQsXG4gICAgICAgICAgICBjb2xvclR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyB8fCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aCA8PSAxLFxuICAgICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBXRUJHTF9kcmF3X2J1ZmZlcnMgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBtdWx0aXBsZSBjb2xvciBidWZmZXJzLicpXG4gICAgICBjaGVjayQxKGNvbG9yQXR0YWNobWVudHMubGVuZ3RoIDw9IGxpbWl0cy5tYXhDb2xvckF0dGFjaG1lbnRzLFxuICAgICAgICAndG9vIG1hbnkgY29sb3IgYXR0YWNobWVudHMsIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgICB3aWR0aCA9IHdpZHRoIHx8IGNvbG9yQXR0YWNobWVudHNbMF0ud2lkdGhcbiAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBjb2xvckF0dGFjaG1lbnRzWzBdLmhlaWdodFxuXG4gICAgICBpZiAoZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KGRlcHRoQnVmZmVyKVxuICAgICAgfSBlbHNlIGlmIChuZWVkc0RlcHRoICYmICFuZWVkc1N0ZW5jaWwpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgJ3VpbnQzMicpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgIHN0ZW5jaWxBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzU3RlbmNpbCAmJiAhbmVlZHNEZXB0aCkge1xuICAgICAgICBzdGVuY2lsQXR0YWNobWVudCA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ3N0ZW5jaWwnLFxuICAgICAgICAgICd1aW50OCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChkZXB0aFN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudChkZXB0aFN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKCFkZXB0aEJ1ZmZlciAmJiAhc3RlbmNpbEJ1ZmZlciAmJiBuZWVkc1N0ZW5jaWwgJiYgbmVlZHNEZXB0aCkge1xuICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCBzdGVuY2lsJyxcbiAgICAgICAgICAnZGVwdGggc3RlbmNpbCcpXG4gICAgICB9XG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgICghIWRlcHRoQnVmZmVyKSArICghIXN0ZW5jaWxCdWZmZXIpICsgKCEhZGVwdGhTdGVuY2lsQnVmZmVyKSA8PSAxLFxuICAgICAgICAnaW52YWxpZCBmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uLCBjYW4gc3BlY2lmeSBleGFjdGx5IG9uZSBkZXB0aC9zdGVuY2lsIGF0dGFjaG1lbnQnKVxuXG4gICAgICB2YXIgY29tbW9uQ29sb3JBdHRhY2htZW50U2l6ZSA9IG51bGxcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShjb2xvckF0dGFjaG1lbnRzW2ldLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBjaGVjayQxKCFjb2xvckF0dGFjaG1lbnRzW2ldIHx8XG4gICAgICAgICAgKGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSAmJlxuICAgICAgICAgICAgY29sb3JUZXh0dXJlRm9ybWF0RW51bXMuaW5kZXhPZihjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUuZm9ybWF0KSA+PSAwKSB8fFxuICAgICAgICAgIChjb2xvckF0dGFjaG1lbnRzW2ldLnJlbmRlcmJ1ZmZlciAmJlxuICAgICAgICAgICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRFbnVtcy5pbmRleE9mKGNvbG9yQXR0YWNobWVudHNbaV0ucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZm9ybWF0KSA+PSAwKSxcbiAgICAgICAgJ2ZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgJyArIGkgKyAnIGlzIGludmFsaWQnKVxuXG4gICAgICAgIGlmIChjb2xvckF0dGFjaG1lbnRzW2ldICYmIGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSkge1xuICAgICAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRTaXplID1cbiAgICAgICAgICAgICAgdGV4dHVyZUZvcm1hdENoYW5uZWxzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS5mb3JtYXRdICpcbiAgICAgICAgICAgICAgdGV4dHVyZVR5cGVTaXplc1tjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUudHlwZV1cblxuICAgICAgICAgIGlmIChjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gY29sb3JBdHRhY2htZW50U2l6ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBjb2xvciBhdHRhY2htZW50cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRwbGFuZXNcbiAgICAgICAgICAgIC8vICh0aGF0IGlzLCB0aGUgc2FtZSBudW1lciBvZiBiaXRzIHBlciBwaXhlbClcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgdGhlIEdMRVMyLjAgc3RhbmRhcmQuIFNlZSB0aGUgYmVnaW5uaW5nIG9mIENoYXB0ZXIgNCBpbiB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgY2hlY2skMShjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBjb2xvckF0dGFjaG1lbnRTaXplLFxuICAgICAgICAgICAgICAnYWxsIGNvbG9yIGF0dGFjaG1lbnRzIG11Y2ggaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYml0cyBwZXIgcGl4ZWwuJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluY1JlZkFuZENoZWNrU2hhcGUoZGVwdGhBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhBdHRhY2htZW50IHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQudGV4dHVyZSAmJlxuICAgICAgICAgIGRlcHRoQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UJDEpIHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyICYmXG4gICAgICAgICAgZGVwdGhBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UMTYkMSksXG4gICAgICAnaW52YWxpZCBkZXB0aCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShzdGVuY2lsQXR0YWNobWVudCwgd2lkdGgsIGhlaWdodClcbiAgICAgIGNoZWNrJDEoIXN0ZW5jaWxBdHRhY2htZW50IHx8XG4gICAgICAgIChzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQgPT09IEdMX1NURU5DSUxfSU5ERVg4JDEpLFxuICAgICAgJ2ludmFsaWQgc3RlbmNpbCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShkZXB0aFN0ZW5jaWxBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhTdGVuY2lsQXR0YWNobWVudCB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlICYmXG4gICAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSxcbiAgICAgICdpbnZhbGlkIGRlcHRoLXN0ZW5jaWwgYXR0YWNobWVudCBmb3IgZnJhbWVidWZmZXIgb2JqZWN0JylcblxuICAgICAgLy8gZGVjcmVtZW50IHJlZmVyZW5jZXNcbiAgICAgIGRlY0ZCT1JlZnMoZnJhbWVidWZmZXIpXG5cbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGhcbiAgICAgIGZyYW1lYnVmZmVyLmhlaWdodCA9IGhlaWdodFxuXG4gICAgICBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzID0gY29sb3JBdHRhY2htZW50c1xuICAgICAgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50ID0gZGVwdGhBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCA9IHN0ZW5jaWxBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gZGVwdGhTdGVuY2lsQXR0YWNobWVudFxuXG4gICAgICByZWdsRnJhbWVidWZmZXIuY29sb3IgPSBjb2xvckF0dGFjaG1lbnRzLm1hcCh1bndyYXBBdHRhY2htZW50KVxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmRlcHRoID0gdW53cmFwQXR0YWNobWVudChkZXB0aEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuc3RlbmNpbCA9IHVud3JhcEF0dGFjaG1lbnQoc3RlbmNpbEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsID0gdW53cmFwQXR0YWNobWVudChkZXB0aFN0ZW5jaWxBdHRhY2htZW50KVxuXG4gICAgICByZWdsRnJhbWVidWZmZXIud2lkdGggPSBmcmFtZWJ1ZmZlci53aWR0aFxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmhlaWdodCA9IGZyYW1lYnVmZmVyLmhlaWdodFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHJlc2l6ZSBhIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgdyA9IE1hdGgubWF4KHdfIHwgMCwgMSlcbiAgICAgIHZhciBoID0gTWF0aC5tYXgoKGhfIHwgMCkgfHwgdywgMSlcbiAgICAgIGlmICh3ID09PSBmcmFtZWJ1ZmZlci53aWR0aCAmJiBoID09PSBmcmFtZWJ1ZmZlci5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyByZXNpemUgYWxsIGJ1ZmZlcnNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoY29sb3JBdHRhY2htZW50c1tpXSwgdywgaClcbiAgICAgIH1cbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50LCB3LCBoKVxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCwgdywgaClcbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudCwgdywgaClcblxuICAgICAgZnJhbWVidWZmZXIud2lkdGggPSByZWdsRnJhbWVidWZmZXIud2lkdGggPSB3XG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSByZWdsRnJhbWVidWZmZXIuaGVpZ2h0ID0gaFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlcihhMCwgYTEpXG5cbiAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlciwge1xuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlcicsXG4gICAgICBfZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95KGZyYW1lYnVmZmVyKVxuICAgICAgICBkZWNGQk9SZWZzKGZyYW1lYnVmZmVyKVxuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgICAgICBmcmFtZWJ1ZmZlcjogcmVnbEZyYW1lYnVmZmVyXG4gICAgICAgIH0sIGJsb2NrKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDdWJlRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIGZhY2VzID0gQXJyYXkoNilcblxuICAgIGZ1bmN0aW9uIHJlZ2xGcmFtZWJ1ZmZlckN1YmUgKGEpIHtcbiAgICAgIHZhciBpXG5cbiAgICAgIGNoZWNrJDEoZmFjZXMuaW5kZXhPZihmcmFtZWJ1ZmZlclN0YXRlLm5leHQpIDwgMCxcbiAgICAgICAgJ2NhbiBub3QgdXBkYXRlIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBjb2xvcjogbnVsbFxuICAgICAgfVxuXG4gICAgICB2YXIgcmFkaXVzID0gMFxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JGb3JtYXQgPSAncmdiYSdcbiAgICAgIHZhciBjb2xvclR5cGUgPSAndWludDgnXG4gICAgICB2YXIgY29sb3JDb3VudCA9IDFcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICByYWRpdXMgPSBhIHwgMFxuICAgICAgfSBlbHNlIGlmICghYSkge1xuICAgICAgICByYWRpdXMgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgIHNoYXBlWzBdID09PSBzaGFwZVsxXSxcbiAgICAgICAgICAgICdjdWJlIGZyYW1lYnVmZmVyIG11c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICByYWRpdXMgPSBzaGFwZVswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICAgIGlmICgnaGVpZ2h0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEob3B0aW9ucy5oZWlnaHQgPT09IHJhZGl1cywgJ211c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9wdGlvbnMuaGVpZ2h0IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnY29sb3InIGluIG9wdGlvbnMgfHxcbiAgICAgICAgICAgICdjb2xvcnMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yc1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgY29sb3JCdWZmZXIubGVuZ3RoID09PSAxIHx8IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzLFxuICAgICAgICAgICAgICAnbXVsdGlwbGUgcmVuZGVyIHRhcmdldHMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvckJ1ZmZlcikge1xuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JDb3VudCA9IG9wdGlvbnMuY29sb3JDb3VudCB8IDBcbiAgICAgICAgICAgIGNoZWNrJDEoY29sb3JDb3VudCA+IDAsICdpbnZhbGlkIGNvbG9yIGJ1ZmZlciBjb3VudCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvclR5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JUeXBlLCBjb2xvclR5cGVzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciB0eXBlJylcbiAgICAgICAgICAgIGNvbG9yVHlwZSA9IG9wdGlvbnMuY29sb3JUeXBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvckZvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0XG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxuICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclRleHR1cmVGb3JtYXRzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGggPSBvcHRpb25zLmRlcHRoXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IG9wdGlvbnMuc3RlbmNpbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aFN0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JDdWJlc1xuICAgICAgaWYgKGNvbG9yQnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbXVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29sb3JDdWJlc1tpXSA9IGNvbG9yQnVmZmVyW2ldXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbIGNvbG9yQnVmZmVyIF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JDdWJlcyA9IEFycmF5KGNvbG9yQ291bnQpXG4gICAgICAgIHZhciBjdWJlTWFwUGFyYW1zID0ge1xuICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgIGZvcm1hdDogY29sb3JGb3JtYXQsXG4gICAgICAgICAgdHlwZTogY29sb3JUeXBlXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQ291bnQ7ICsraSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXNbaV0gPSB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZShjdWJlTWFwUGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGNvbG9yIGN1YmVzXG4gICAgICBwYXJhbXMuY29sb3IgPSBBcnJheShjb2xvckN1YmVzLmxlbmd0aClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckN1YmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdWJlID0gY29sb3JDdWJlc1tpXVxuICAgICAgICBjaGVjayQxKFxuICAgICAgICAgIHR5cGVvZiBjdWJlID09PSAnZnVuY3Rpb24nICYmIGN1YmUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnLFxuICAgICAgICAgICdpbnZhbGlkIGN1YmUgbWFwJylcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IGN1YmUud2lkdGhcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBjdWJlLndpZHRoID09PSByYWRpdXMgJiYgY3ViZS5oZWlnaHQgPT09IHJhZGl1cyxcbiAgICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCBzaGFwZScpXG4gICAgICAgIHBhcmFtcy5jb2xvcltpXSA9IHtcbiAgICAgICAgICB0YXJnZXQ6IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyLFxuICAgICAgICAgIGRhdGE6IGNvbG9yQ3ViZXNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sb3JDdWJlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHBhcmFtcy5jb2xvcltqXS50YXJnZXQgPSBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiArIGlcbiAgICAgICAgfVxuICAgICAgICAvLyByZXVzZSBkZXB0aC1zdGVuY2lsIGF0dGFjaG1lbnRzIGFjcm9zcyBhbGwgY3ViZSBtYXBzXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHBhcmFtcy5kZXB0aCA9IGZhY2VzWzBdLmRlcHRoXG4gICAgICAgICAgcGFyYW1zLnN0ZW5jaWwgPSBmYWNlc1swXS5zdGVuY2lsXG4gICAgICAgICAgcGFyYW1zLmRlcHRoU3RlbmNpbCA9IGZhY2VzWzBdLmRlcHRoU3RlbmNpbFxuICAgICAgICB9XG4gICAgICAgIGlmIChmYWNlc1tpXSkge1xuICAgICAgICAgIChmYWNlc1tpXSkocGFyYW1zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2VzW2ldID0gY3JlYXRlRkJPKHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlckN1YmUsIHtcbiAgICAgICAgd2lkdGg6IHJhZGl1cyxcbiAgICAgICAgaGVpZ2h0OiByYWRpdXMsXG4gICAgICAgIGNvbG9yOiBjb2xvckN1YmVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIGlcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNfIHwgMFxuICAgICAgY2hlY2skMShyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSBsaW1pdHMubWF4Q3ViZU1hcFNpemUsXG4gICAgICAgICdpbnZhbGlkIHJhZGl1cyBmb3IgY3ViZSBmYm8nKVxuXG4gICAgICBpZiAocmFkaXVzID09PSByZWdsRnJhbWVidWZmZXJDdWJlLndpZHRoKSB7XG4gICAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvcnMgPSByZWdsRnJhbWVidWZmZXJDdWJlLmNvbG9yXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbG9yc1tpXS5yZXNpemUocmFkaXVzKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldLnJlc2l6ZShyYWRpdXMpXG4gICAgICB9XG5cbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUud2lkdGggPSByZWdsRnJhbWVidWZmZXJDdWJlLmhlaWdodCA9IHJhZGl1c1xuXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyQ3ViZVxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUob3B0aW9ucylcblxuICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyQ3ViZSwge1xuICAgICAgZmFjZXM6IGZhY2VzLFxuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlckN1YmUnLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgZi5kZXN0cm95KClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZUZyYW1lYnVmZmVycyAoKSB7XG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBudWxsXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID0gbnVsbFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuZGlydHkgPSB0cnVlXG4gICAgdmFsdWVzKGZyYW1lYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChmYikge1xuICAgICAgZmIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmYilcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuZChmcmFtZWJ1ZmZlclN0YXRlLCB7XG4gICAgZ2V0RnJhbWVidWZmZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nICYmIG9iamVjdC5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpIHtcbiAgICAgICAgdmFyIGZibyA9IG9iamVjdC5fZnJhbWVidWZmZXJcbiAgICAgICAgaWYgKGZibyBpbnN0YW5jZW9mIFJFR0xGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBmYm9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlRkJPLFxuICAgIGNyZWF0ZUN1YmU6IGNyZWF0ZUN1YmVGQk8sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhmcmFtZWJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZUZyYW1lYnVmZmVyc1xuICB9KVxufVxuXG52YXIgR0xfRkxPQVQkNiA9IDUxMjZcbnZhciBHTF9BUlJBWV9CVUZGRVIkMSA9IDM0OTYyXG5cbmZ1bmN0aW9uIEF0dHJpYnV0ZVJlY29yZCAoKSB7XG4gIHRoaXMuc3RhdGUgPSAwXG5cbiAgdGhpcy54ID0gMC4wXG4gIHRoaXMueSA9IDAuMFxuICB0aGlzLnogPSAwLjBcbiAgdGhpcy53ID0gMC4wXG5cbiAgdGhpcy5idWZmZXIgPSBudWxsXG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2VcbiAgdGhpcy50eXBlID0gR0xfRkxPQVQkNlxuICB0aGlzLm9mZnNldCA9IDBcbiAgdGhpcy5zdHJpZGUgPSAwXG4gIHRoaXMuZGl2aXNvciA9IDBcbn1cblxuZnVuY3Rpb24gd3JhcEF0dHJpYnV0ZVN0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgc3RhdHMsXG4gIGJ1ZmZlclN0YXRlKSB7XG4gIHZhciBOVU1fQVRUUklCVVRFUyA9IGxpbWl0cy5tYXhBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IG5ldyBBcnJheShOVU1fQVRUUklCVVRFUylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOVU1fQVRUUklCVVRFUzsgKytpKSB7XG4gICAgYXR0cmlidXRlQmluZGluZ3NbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgfVxuICB2YXIgdmFvQ291bnQgPSAwXG4gIHZhciB2YW9TZXQgPSB7fVxuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBSZWNvcmQ6IEF0dHJpYnV0ZVJlY29yZCxcbiAgICBzY29wZToge30sXG4gICAgc3RhdGU6IGF0dHJpYnV0ZUJpbmRpbmdzLFxuICAgIGN1cnJlbnRWQU86IG51bGwsXG4gICAgdGFyZ2V0VkFPOiBudWxsLFxuICAgIHJlc3RvcmU6IGV4dFZBTygpID8gcmVzdG9yZVZBTyA6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGNyZWF0ZVZBTzogY3JlYXRlVkFPLFxuICAgIGdldFZBTzogZ2V0VkFPLFxuICAgIGRlc3Ryb3lCdWZmZXI6IGRlc3Ryb3lCdWZmZXIsXG4gICAgc2V0VkFPOiBleHRWQU8oKSA/IHNldFZBT0VYVCA6IHNldFZBT0VtdWxhdGVkLFxuICAgIGNsZWFyOiBleHRWQU8oKSA/IGRlc3Ryb3lWQU9FWFQgOiBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHJlY29yZCA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICBpZiAocmVjb3JkLmJ1ZmZlciA9PT0gYnVmZmVyKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgICByZWNvcmQuYnVmZmVyID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dFZBTyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dEluc3RhbmNlZCAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5c1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VkFPICh2YW8pIHtcbiAgICBpZiAodHlwZW9mIHZhbyA9PT0gJ2Z1bmN0aW9uJyAmJiB2YW8uX3Zhbykge1xuICAgICAgcmV0dXJuIHZhby5fdmFvXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRWQU9FWFQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAodmFvKSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby52YW8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbClcbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VkFPRW11bGF0ZWQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFvKSB7XG4gICAgICB2YW8uYmluZEF0dHJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4dGkgPSBleHRJbnN0YW5jZWQoKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICAgIGlmIChiaW5kaW5nLmJ1ZmZlcikge1xuICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBiaW5kaW5nLnNpemUsIGJpbmRpbmcudHlwZSwgYmluZGluZy5ub3JtYWxpemVkLCBiaW5kaW5nLnN0cmlkZSwgYmluZGluZy5vZmZmc2V0KVxuICAgICAgICAgIGlmIChleHRpICYmIGJpbmRpbmcuZGl2aXNvcikge1xuICAgICAgICAgICAgZXh0aS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaSwgYmluZGluZy5kaXZpc29yKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZihpLCBiaW5kaW5nLngsIGJpbmRpbmcueSwgYmluZGluZy56LCBiaW5kaW5nLncpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVZBT0VYVCAoKSB7XG4gICAgdmFsdWVzKHZhb1NldCkuZm9yRWFjaChmdW5jdGlvbiAodmFvKSB7XG4gICAgICB2YW8uZGVzdHJveSgpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFJFR0xWQU8gKCkge1xuICAgIHRoaXMuaWQgPSArK3Zhb0NvdW50XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW11cbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0VkFPKClcbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICB0aGlzLnZhbyA9IGV4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFvID0gbnVsbFxuICAgIH1cbiAgICB2YW9TZXRbdGhpcy5pZF0gPSB0aGlzXG4gICAgdGhpcy5idWZmZXJzID0gW11cbiAgfVxuXG4gIFJFR0xWQU8ucHJvdG90eXBlLmJpbmRBdHRycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0aSA9IGV4dEluc3RhbmNlZCgpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXVxuICAgICAgaWYgKGF0dHIuYnVmZmVyKSB7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoR0xfQVJSQVlfQlVGRkVSJDEsIGF0dHIuYnVmZmVyLmJ1ZmZlcilcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkLCBhdHRyLnN0cmlkZSwgYXR0ci5vZmZzZXQpXG4gICAgICAgIGlmIChleHRpICYmIGF0dHIuZGl2aXNvcikge1xuICAgICAgICAgIGV4dGkudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGksIGF0dHIuZGl2aXNvcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjRmKGksIGF0dHIueCwgYXR0ci55LCBhdHRyLnosIGF0dHIudylcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgTlVNX0FUVFJJQlVURVM7ICsraikge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGopXG4gICAgfVxuICB9XG5cbiAgUkVHTFZBTy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAoZXh0KSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHRoaXMudmFvKVxuICAgICAgdGhpcy5iaW5kQXR0cnMoKVxuICAgICAgc3RhdGUuY3VycmVudFZBTyA9IHRoaXNcbiAgICB9XG4gIH1cblxuICBSRUdMVkFPLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZhbykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dFZBTygpXG4gICAgICBpZiAodGhpcyA9PT0gc3RhdGUuY3VycmVudFZBTykge1xuICAgICAgICBzdGF0ZS5jdXJyZW50VkFPID0gbnVsbFxuICAgICAgICBleHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpXG4gICAgICB9XG4gICAgICBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pXG4gICAgICB0aGlzLnZhbyA9IG51bGxcbiAgICB9XG4gICAgaWYgKHZhb1NldFt0aGlzLmlkXSkge1xuICAgICAgZGVsZXRlIHZhb1NldFt0aGlzLmlkXVxuICAgICAgc3RhdHMudmFvQ291bnQgLT0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVWQU8gKCkge1xuICAgIHZhciBleHQgPSBleHRWQU8oKVxuICAgIGlmIChleHQpIHtcbiAgICAgIHZhbHVlcyh2YW9TZXQpLmZvckVhY2goZnVuY3Rpb24gKHZhbykge1xuICAgICAgICB2YW8ucmVmcmVzaCgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZBTyAoX2F0dHIpIHtcbiAgICB2YXIgdmFvID0gbmV3IFJFR0xWQU8oKVxuICAgIHN0YXRzLnZhb0NvdW50ICs9IDFcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZBTyAoYXR0cmlidXRlcykge1xuICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpLCAnYXJndW1lbnRzIHRvIHZlcnRleCBhcnJheSBjb25zdHJ1Y3RvciBtdXN0IGJlIGFuIGFycmF5JylcbiAgICAgIGNoZWNrJDEoYXR0cmlidXRlcy5sZW5ndGggPCBOVU1fQVRUUklCVVRFUywgJ3RvbyBtYW55IGF0dHJpYnV0ZXMnKVxuICAgICAgY2hlY2skMShhdHRyaWJ1dGVzLmxlbmd0aCA+IDAsICdtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZScpXG5cbiAgICAgIHZhciBidWZVcGRhdGVkID0ge31cbiAgICAgIHZhciBuYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzXG4gICAgICBuYXR0cmlidXRlcy5sZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGVjID0gYXR0cmlidXRlc1tpXVxuICAgICAgICB2YXIgcmVjID0gbmF0dHJpYnV0ZXNbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgICAgdmFyIGRhdGEgPSBzcGVjLmRhdGEgfHwgc3BlY1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1R5cGVkQXJyYXkoZGF0YSkgfHwgaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgICAgIHZhciBidWZcbiAgICAgICAgICBpZiAodmFvLmJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgIGJ1ZiA9IHZhby5idWZmZXJzW2ldXG4gICAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpICYmIGJ1Zi5fYnVmZmVyLmJ5dGVMZW5ndGggPj0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJ1Zi5zdWJkYXRhKGRhdGEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBidWYuZGVzdHJveSgpXG4gICAgICAgICAgICAgIHZhby5idWZmZXJzW2ldID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhby5idWZmZXJzW2ldKSB7XG4gICAgICAgICAgICBidWYgPSB2YW8uYnVmZmVyc1tpXSA9IGJ1ZmZlclN0YXRlLmNyZWF0ZShzcGVjLCBHTF9BUlJBWV9CVUZGRVIkMSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoYnVmKVxuICAgICAgICAgIHJlYy5zaXplID0gcmVjLmJ1ZmZlci5kaW1lbnNpb24gfCAwXG4gICAgICAgICAgcmVjLm5vcm1hbGl6ZWQgPSBmYWxzZVxuICAgICAgICAgIHJlYy50eXBlID0gcmVjLmJ1ZmZlci5kdHlwZVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IDBcbiAgICAgICAgICByZWMuc3RhdGUgPSAxXG4gICAgICAgICAgYnVmVXBkYXRlZFtpXSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYykpIHtcbiAgICAgICAgICByZWMuYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHNwZWMpXG4gICAgICAgICAgcmVjLnNpemUgPSByZWMuYnVmZmVyLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgICByZWMubm9ybWFsaXplZCA9IGZhbHNlXG4gICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgcmVjLm9mZnNldCA9IDBcbiAgICAgICAgICByZWMuc3RyaWRlID0gMFxuICAgICAgICAgIHJlYy5kaXZpc29yID0gMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYy5idWZmZXIpKSB7XG4gICAgICAgICAgcmVjLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihzcGVjLmJ1ZmZlcilcbiAgICAgICAgICByZWMuc2l6ZSA9ICgoK3NwZWMuc2l6ZSkgfHwgcmVjLmJ1ZmZlci5kaW1lbnNpb24pIHwgMFxuICAgICAgICAgIHJlYy5ub3JtYWxpemVkID0gISFzcGVjLm5vcm1hbGl6ZWQgfHwgZmFsc2VcbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIHNwZWMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHNwZWMudHlwZSwgZ2xUeXBlcywgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgcmVjLnR5cGUgPSBnbFR5cGVzW3NwZWMudHlwZV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAoc3BlYy5vZmZzZXQgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IChzcGVjLnN0cmlkZSB8fCAwKSB8IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IChzcGVjLmRpdmlzb3IgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0YXRlID0gMVxuXG4gICAgICAgICAgY2hlY2skMShyZWMuc2l6ZSA+PSAxICYmIHJlYy5zaXplIDw9IDQsICdzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5vZmZzZXQgPj0gMCwgJ2ludmFsaWQgb2Zmc2V0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5zdHJpZGUgPj0gMCAmJiByZWMuc3RyaWRlIDw9IDI1NSwgJ3N0cmlkZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5kaXZpc29yID49IDAsICdkaXZpc29yIG11c3QgYmUgcG9zaXRpdmUnKVxuICAgICAgICAgIGNoZWNrJDEoIXJlYy5kaXZpc29yIHx8ICEhZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzLCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIGRpdmlzb3InKVxuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBzcGVjKSB7XG4gICAgICAgICAgY2hlY2skMShpID4gMCwgJ2ZpcnN0IGF0dHJpYnV0ZSBtdXN0IG5vdCBiZSBhIGNvbnN0YW50JylcbiAgICAgICAgICByZWMueCA9ICtzcGVjLnggfHwgMFxuICAgICAgICAgIHJlYy55ID0gK3NwZWMueSB8fCAwXG4gICAgICAgICAgcmVjLnogPSArc3BlYy56IHx8IDBcbiAgICAgICAgICByZWMudyA9ICtzcGVjLncgfHwgMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBhdHRyaWJ1dGUgc3BlYyBmb3IgbG9jYXRpb24gJyArIGkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmV0aXJlIHVudXNlZCBidWZmZXJzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhby5idWZmZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICghYnVmVXBkYXRlZFtqXSAmJiB2YW8uYnVmZmVyc1tqXSkge1xuICAgICAgICAgIHZhby5idWZmZXJzW2pdLmRlc3Ryb3koKVxuICAgICAgICAgIHZhby5idWZmZXJzW2pdID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhby5yZWZyZXNoKClcbiAgICAgIHJldHVybiB1cGRhdGVWQU9cbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFvLmJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKHZhby5idWZmZXJzW2pdKSB7XG4gICAgICAgICAgdmFvLmJ1ZmZlcnNbal0uZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhby5idWZmZXJzLmxlbmd0aCA9IDBcbiAgICAgIHZhby5kZXN0cm95KClcbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uX3ZhbyA9IHZhb1xuICAgIHVwZGF0ZVZBTy5fcmVnbFR5cGUgPSAndmFvJ1xuXG4gICAgcmV0dXJuIHVwZGF0ZVZBTyhfYXR0cilcbiAgfVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG52YXIgR0xfRlJBR01FTlRfU0hBREVSID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSID0gMzU2MzNcblxudmFyIEdMX0FDVElWRV9VTklGT1JNUyA9IDB4OEI4NlxudmFyIEdMX0FDVElWRV9BVFRSSUJVVEVTID0gMHg4Qjg5XG5cbmZ1bmN0aW9uIHdyYXBTaGFkZXJTdGF0ZSAoZ2wsIHN0cmluZ1N0b3JlLCBzdGF0cywgY29uZmlnKSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBnbHNsIGNvbXBpbGF0aW9uIGFuZCBsaW5raW5nXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgZnJhZ1NoYWRlcnMgPSB7fVxuICB2YXIgdmVydFNoYWRlcnMgPSB7fVxuXG4gIGZ1bmN0aW9uIEFjdGl2ZUluZm8gKG5hbWUsIGlkLCBsb2NhdGlvbiwgaW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb25cbiAgICB0aGlzLmluZm8gPSBpbmZvXG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBY3RpdmVJbmZvIChsaXN0LCBpbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobGlzdFtpXS5pZCA9PT0gaW5mby5pZCkge1xuICAgICAgICBsaXN0W2ldLmxvY2F0aW9uID0gaW5mby5sb2NhdGlvblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgbGlzdC5wdXNoKGluZm8pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaGFkZXIgKHR5cGUsIGlkLCBjb21tYW5kKSB7XG4gICAgdmFyIGNhY2hlID0gdHlwZSA9PT0gR0xfRlJBR01FTlRfU0hBREVSID8gZnJhZ1NoYWRlcnMgOiB2ZXJ0U2hhZGVyc1xuICAgIHZhciBzaGFkZXIgPSBjYWNoZVtpZF1cblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RyaW5nU3RvcmUuc3RyKGlkKVxuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcbiAgICAgIGNoZWNrJDEuc2hhZGVyRXJyb3IoZ2wsIHNoYWRlciwgc291cmNlLCB0eXBlLCBjb21tYW5kKVxuICAgICAgY2FjaGVbaWRdID0gc2hhZGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIHByb2dyYW0gbGlua2luZ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIHByb2dyYW1DYWNoZSA9IHt9XG4gIHZhciBwcm9ncmFtTGlzdCA9IFtdXG5cbiAgdmFyIFBST0dSQU1fQ09VTlRFUiA9IDBcblxuICBmdW5jdGlvbiBSRUdMUHJvZ3JhbSAoZnJhZ0lkLCB2ZXJ0SWQpIHtcbiAgICB0aGlzLmlkID0gUFJPR1JBTV9DT1VOVEVSKytcbiAgICB0aGlzLmZyYWdJZCA9IGZyYWdJZFxuICAgIHRoaXMudmVydElkID0gdmVydElkXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbFxuICAgIHRoaXMudW5pZm9ybXMgPSBbXVxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgdW5pZm9ybXNDb3VudDogMCxcbiAgICAgICAgYXR0cmlidXRlc0NvdW50OiAwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlua1Byb2dyYW0gKGRlc2MsIGNvbW1hbmQsIGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgIHZhciBpLCBpbmZvXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29tcGlsZSAmIGxpbmtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGZyYWdTaGFkZXIgPSBnZXRTaGFkZXIoR0xfRlJBR01FTlRfU0hBREVSLCBkZXNjLmZyYWdJZClcbiAgICB2YXIgdmVydFNoYWRlciA9IGdldFNoYWRlcihHTF9WRVJURVhfU0hBREVSLCBkZXNjLnZlcnRJZClcblxuICAgIHZhciBwcm9ncmFtID0gZGVzYy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpXG4gICAgaWYgKGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZUxvY2F0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUxvY2F0aW9uc1tpXVxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYmluZGluZ1swXSwgYmluZGluZ1sxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKVxuICAgIGNoZWNrJDEubGlua0Vycm9yKFxuICAgICAgZ2wsXG4gICAgICBwcm9ncmFtLFxuICAgICAgc3RyaW5nU3RvcmUuc3RyKGRlc2MuZnJhZ0lkKSxcbiAgICAgIHN0cmluZ1N0b3JlLnN0cihkZXNjLnZlcnRJZCksXG4gICAgICBjb21tYW5kKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdyYWIgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfVU5JRk9STVMpXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICBkZXNjLnN0YXRzLnVuaWZvcm1zQ291bnQgPSBudW1Vbmlmb3Jtc1xuICAgIH1cbiAgICB2YXIgdW5pZm9ybXMgPSBkZXNjLnVuaWZvcm1zXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyArK2kpIHtcbiAgICAgIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpZiAoaW5mby5zaXplID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5mby5zaXplOyArK2opIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICdbJyArIGogKyAnXScpXG4gICAgICAgICAgICBpbnNlcnRBY3RpdmVJbmZvKHVuaWZvcm1zLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQobmFtZSksXG4gICAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEFjdGl2ZUluZm8odW5pZm9ybXMsIG5ldyBBY3RpdmVJbmZvKFxuICAgICAgICAgICAgaW5mby5uYW1lLFxuICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgICAgaW5mbykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ3JhYiBhdHRyaWJ1dGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfQVRUUklCVVRFUylcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50ID0gbnVtQXR0cmlidXRlc1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZGVzYy5hdHRyaWJ1dGVzXG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7ICsraSkge1xuICAgICAgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5zZXJ0QWN0aXZlSW5mbyhhdHRyaWJ1dGVzLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICBpbmZvLm5hbWUsXG4gICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgIGluZm8pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldE1heFVuaWZvcm1zQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbSA9IDBcbiAgICAgIHByb2dyYW1MaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgaWYgKGRlc2Muc3RhdHMudW5pZm9ybXNDb3VudCA+IG0pIHtcbiAgICAgICAgICBtID0gZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cblxuICAgIHN0YXRzLmdldE1heEF0dHJpYnV0ZXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtID0gMFxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnQgPiBtKSB7XG4gICAgICAgICAgbSA9IGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTaGFkZXJzICgpIHtcbiAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgdmVydFNoYWRlcnMgPSB7fVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW1MaXN0W2ldLCBudWxsLCBwcm9ncmFtTGlzdFtpXS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICByZXR1cm4gW2luZm8ubG9jYXRpb24sIGluZm8ubmFtZV1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWxldGVTaGFkZXIgPSBnbC5kZWxldGVTaGFkZXIuYmluZChnbClcbiAgICAgIHZhbHVlcyhmcmFnU2hhZGVycykuZm9yRWFjaChkZWxldGVTaGFkZXIpXG4gICAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgICB2YWx1ZXModmVydFNoYWRlcnMpLmZvckVhY2goZGVsZXRlU2hhZGVyKVxuICAgICAgdmVydFNoYWRlcnMgPSB7fVxuXG4gICAgICBwcm9ncmFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oZGVzYy5wcm9ncmFtKVxuICAgICAgfSlcbiAgICAgIHByb2dyYW1MaXN0Lmxlbmd0aCA9IDBcbiAgICAgIHByb2dyYW1DYWNoZSA9IHt9XG5cbiAgICAgIHN0YXRzLnNoYWRlckNvdW50ID0gMFxuICAgIH0sXG5cbiAgICBwcm9ncmFtOiBmdW5jdGlvbiAodmVydElkLCBmcmFnSWQsIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgY2hlY2skMS5jb21tYW5kKHZlcnRJZCA+PSAwLCAnbWlzc2luZyB2ZXJ0ZXggc2hhZGVyJywgY29tbWFuZClcbiAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFnSWQgPj0gMCwgJ21pc3NpbmcgZnJhZ21lbnQgc2hhZGVyJywgY29tbWFuZClcblxuICAgICAgdmFyIGNhY2hlID0gcHJvZ3JhbUNhY2hlW2ZyYWdJZF1cbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBwcm9ncmFtQ2FjaGVbZnJhZ0lkXSA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgcHJldlByb2dyYW0gPSBjYWNoZVt2ZXJ0SWRdXG4gICAgICBpZiAocHJldlByb2dyYW0pIHtcbiAgICAgICAgcHJldlByb2dyYW0ucmVmQ291bnQrK1xuICAgICAgICBpZiAoIWF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICAgIHJldHVybiBwcmV2UHJvZ3JhbVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBSRUdMUHJvZ3JhbShmcmFnSWQsIHZlcnRJZClcbiAgICAgIHN0YXRzLnNoYWRlckNvdW50KytcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW0sIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucylcbiAgICAgIGlmICghcHJldlByb2dyYW0pIHtcbiAgICAgICAgY2FjaGVbdmVydElkXSA9IHByb2dyYW1cbiAgICAgIH1cbiAgICAgIHByb2dyYW1MaXN0LnB1c2gocHJvZ3JhbSlcbiAgICAgIHJldHVybiBleHRlbmQocHJvZ3JhbSwge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvZ3JhbS5yZWZDb3VudC0tXG4gICAgICAgICAgaWYgKHByb2dyYW0ucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtLnByb2dyYW0pXG4gICAgICAgICAgICB2YXIgaWR4ID0gcHJvZ3JhbUxpc3QuaW5kZXhPZihwcm9ncmFtKVxuICAgICAgICAgICAgcHJvZ3JhbUxpc3Quc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICAgIHN0YXRzLnNoYWRlckNvdW50LS1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyB2ZXJ0IGFueW1vcmVcbiAgICAgICAgICBpZiAoY2FjaGVbcHJvZ3JhbS52ZXJ0SWRdLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0U2hhZGVyc1twcm9ncmFtLnZlcnRJZF0pXG4gICAgICAgICAgICBkZWxldGUgdmVydFNoYWRlcnNbcHJvZ3JhbS52ZXJ0SWRdXG4gICAgICAgICAgICBkZWxldGUgcHJvZ3JhbUNhY2hlW3Byb2dyYW0uZnJhZ0lkXVtwcm9ncmFtLnZlcnRJZF1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyBmcmFnIGFueW1vcmVcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHByb2dyYW1DYWNoZVtwcm9ncmFtLmZyYWdJZF0pLmxlbmd0aCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdTaGFkZXJzW3Byb2dyYW0uZnJhZ0lkXSlcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFnU2hhZGVyc1twcm9ncmFtLmZyYWdJZF1cbiAgICAgICAgICAgIGRlbGV0ZSBwcm9ncmFtQ2FjaGVbcHJvZ3JhbS5mcmFnSWRdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlU2hhZGVycyxcblxuICAgIHNoYWRlcjogZ2V0U2hhZGVyLFxuXG4gICAgZnJhZzogLTEsXG4gICAgdmVydDogLTFcbiAgfVxufVxuXG52YXIgR0xfUkdCQSQzID0gNjQwOFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNyA9IDUxMjFcbnZhciBHTF9QQUNLX0FMSUdOTUVOVCA9IDB4MEQwNVxudmFyIEdMX0ZMT0FUJDcgPSAweDE0MDYgLy8gNTEyNlxuXG5mdW5jdGlvbiB3cmFwUmVhZFBpeGVscyAoXG4gIGdsLFxuICBmcmFtZWJ1ZmZlclN0YXRlLFxuICByZWdsUG9sbCxcbiAgY29udGV4dCxcbiAgZ2xBdHRyaWJ1dGVzLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMpIHtcbiAgZnVuY3Rpb24gcmVhZFBpeGVsc0ltcGwgKGlucHV0KSB7XG4gICAgdmFyIHR5cGVcbiAgICBpZiAoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID09PSBudWxsKSB7XG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAneW91IG11c3QgY3JlYXRlIGEgd2ViZ2wgY29udGV4dCB3aXRoIFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCI6dHJ1ZSBpbiBvcmRlciB0byByZWFkIHBpeGVscyBmcm9tIHRoZSBkcmF3aW5nIGJ1ZmZlcicpXG4gICAgICB0eXBlID0gR0xfVU5TSUdORURfQllURSQ3XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUubmV4dC5jb2xvckF0dGFjaG1lbnRzWzBdLnRleHR1cmUgIT09IG51bGwsXG4gICAgICAgICdZb3UgY2Fubm90IHJlYWQgZnJvbSBhIHJlbmRlcmJ1ZmZlcicpXG4gICAgICB0eXBlID0gZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmNvbG9yQXR0YWNobWVudHNbMF0udGV4dHVyZS5fdGV4dHVyZS50eXBlXG5cbiAgICAgIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3IHx8IHR5cGUgPT09IEdMX0ZMT0FUJDcsXG4gICAgICAgICAgJ1JlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIHR5cGVzIFxcJ3VpbnQ4XFwnIGFuZCBcXCdmbG9hdFxcJycpXG5cbiAgICAgICAgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcbiAgICAgICAgICBjaGVjayQxKGxpbWl0cy5yZWFkRmxvYXQsICdSZWFkaW5nIFxcJ2Zsb2F0XFwnIHZhbHVlcyBpcyBub3QgcGVybWl0dGVkIGluIHlvdXIgYnJvd3Nlci4gRm9yIGEgZmFsbGJhY2ssIHBsZWFzZSBzZWU6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dsc2wtcmVhZC1mbG9hdCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3LFxuICAgICAgICAgICdSZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSB0eXBlIFxcJ3VpbnQ4XFwnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCA9IDBcbiAgICB2YXIgeSA9IDBcbiAgICB2YXIgd2lkdGggPSBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodFxuICAgIHZhciBkYXRhID0gbnVsbFxuXG4gICAgaWYgKGlzVHlwZWRBcnJheShpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dFxuICAgIH0gZWxzZSBpZiAoaW5wdXQpIHtcbiAgICAgIGNoZWNrJDEudHlwZShpbnB1dCwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsLnJlYWQoKScpXG4gICAgICB4ID0gaW5wdXQueCB8IDBcbiAgICAgIHkgPSBpbnB1dC55IHwgMFxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHggPCBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGgsXG4gICAgICAgICdpbnZhbGlkIHggb2Zmc2V0IGZvciByZWdsLnJlYWQnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeSA+PSAwICYmIHkgPCBjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0LFxuICAgICAgICAnaW52YWxpZCB5IG9mZnNldCBmb3IgcmVnbC5yZWFkJylcbiAgICAgIHdpZHRoID0gKGlucHV0LndpZHRoIHx8IChjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGggLSB4KSkgfCAwXG4gICAgICBoZWlnaHQgPSAoaW5wdXQuaGVpZ2h0IHx8IChjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0IC0geSkpIHwgMFxuICAgICAgZGF0YSA9IGlucHV0LmRhdGEgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBpbnB1dC5kYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcpIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnVWludDhBcnJheVxcJyB3aGVuIHJlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIG9mIHR5cGUgXFwndWludDhcXCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnRmxvYXQzMkFycmF5XFwnIHdoZW4gcmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgb2YgdHlwZSBcXCdmbG9hdFxcJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMShcbiAgICAgIHdpZHRoID4gMCAmJiB3aWR0aCArIHggPD0gY29udGV4dC5mcmFtZWJ1ZmZlcldpZHRoLFxuICAgICAgJ2ludmFsaWQgd2lkdGggZm9yIHJlYWQgcGl4ZWxzJylcbiAgICBjaGVjayQxKFxuICAgICAgaGVpZ2h0ID4gMCAmJiBoZWlnaHQgKyB5IDw9IGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQsXG4gICAgICAnaW52YWxpZCBoZWlnaHQgZm9yIHJlYWQgcGl4ZWxzJylcblxuICAgIC8vIFVwZGF0ZSBXZWJHTCBzdGF0ZVxuICAgIHJlZ2xQb2xsKClcblxuICAgIC8vIENvbXB1dGUgc2l6ZVxuICAgIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQgKiA0XG5cbiAgICAvLyBBbGxvY2F0ZSBkYXRhXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAodHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3KSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGNoZWNrXG4gICAgY2hlY2skMS5pc1R5cGVkQXJyYXkoZGF0YSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSBtdXN0IGJlIGEgdHlwZWRhcnJheScpXG4gICAgY2hlY2skMShkYXRhLmJ5dGVMZW5ndGggPj0gc2l6ZSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSB0b28gc21hbGwnKVxuXG4gICAgLy8gUnVuIHJlYWQgcGl4ZWxzXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfUEFDS19BTElHTk1FTlQsIDQpXG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBHTF9SR0JBJDMsXG4gICAgICB0eXBlLFxuICAgICAgZGF0YSlcblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiByZWFkUGl4ZWxzRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgIGZyYW1lYnVmZmVyOiBvcHRpb25zLmZyYW1lYnVmZmVyXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdWx0ID0gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHMgKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgISgnZnJhbWVidWZmZXInIGluIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlYWRQaXhlbHNGQk8ob3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZFBpeGVsc1xufVxuXG5mdW5jdGlvbiBzbGljZSAoeCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoeClcbn1cblxuZnVuY3Rpb24gam9pbiAoeCkge1xuICByZXR1cm4gc2xpY2UoeCkuam9pbignJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnQgKCkge1xuICAvLyBVbmlxdWUgdmFyaWFibGUgaWQgY291bnRlclxuICB2YXIgdmFyQ291bnRlciA9IDBcblxuICAvLyBMaW5rZWQgdmFsdWVzIGFyZSBwYXNzZWQgZnJvbSB0aGlzIHNjb3BlIGludG8gdGhlIGdlbmVyYXRlZCBjb2RlIGJsb2NrXG4gIC8vIENhbGxpbmcgbGluaygpIHBhc3NlcyBhIHZhbHVlIGludG8gdGhlIGdlbmVyYXRlZCBzY29wZSBhbmQgcmV0dXJuc1xuICAvLyB0aGUgdmFyaWFibGUgbmFtZSB3aGljaCBpdCBpcyBib3VuZCB0b1xuICB2YXIgbGlua2VkTmFtZXMgPSBbXVxuICB2YXIgbGlua2VkVmFsdWVzID0gW11cbiAgZnVuY3Rpb24gbGluayAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtlZFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGxpbmtlZFZhbHVlc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtlZE5hbWVzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSAnZycgKyAodmFyQ291bnRlcisrKVxuICAgIGxpbmtlZE5hbWVzLnB1c2gobmFtZSlcbiAgICBsaW5rZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgY29kZSBibG9ja1xuICBmdW5jdGlvbiBibG9jayAoKSB7XG4gICAgdmFyIGNvZGUgPSBbXVxuICAgIGZ1bmN0aW9uIHB1c2ggKCkge1xuICAgICAgY29kZS5wdXNoLmFwcGx5KGNvZGUsIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfVxuXG4gICAgdmFyIHZhcnMgPSBbXVxuICAgIGZ1bmN0aW9uIGRlZiAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICd2JyArICh2YXJDb3VudGVyKyspXG4gICAgICB2YXJzLnB1c2gobmFtZSlcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChuYW1lLCAnPScpXG4gICAgICAgIGNvZGUucHVzaC5hcHBseShjb2RlLCBzbGljZShhcmd1bWVudHMpKVxuICAgICAgICBjb2RlLnB1c2goJzsnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQocHVzaCwge1xuICAgICAgZGVmOiBkZWYsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gam9pbihbXG4gICAgICAgICAgKHZhcnMubGVuZ3RoID4gMCA/ICd2YXIgJyArIHZhcnMuam9pbignLCcpICsgJzsnIDogJycpLFxuICAgICAgICAgIGpvaW4oY29kZSlcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gc2NvcGUgKCkge1xuICAgIHZhciBlbnRyeSA9IGJsb2NrKClcbiAgICB2YXIgZXhpdCA9IGJsb2NrKClcblxuICAgIHZhciBlbnRyeVRvU3RyaW5nID0gZW50cnkudG9TdHJpbmdcbiAgICB2YXIgZXhpdFRvU3RyaW5nID0gZXhpdC50b1N0cmluZ1xuXG4gICAgZnVuY3Rpb24gc2F2ZSAob2JqZWN0LCBwcm9wKSB7XG4gICAgICBleGl0KG9iamVjdCwgcHJvcCwgJz0nLCBlbnRyeS5kZWYob2JqZWN0LCBwcm9wKSwgJzsnKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgZW50cnkuYXBwbHkoZW50cnksIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfSwge1xuICAgICAgZGVmOiBlbnRyeS5kZWYsXG4gICAgICBlbnRyeTogZW50cnksXG4gICAgICBleGl0OiBleGl0LFxuICAgICAgc2F2ZTogc2F2ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgc2F2ZShvYmplY3QsIHByb3ApXG4gICAgICAgIGVudHJ5KG9iamVjdCwgcHJvcCwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbnRyeVRvU3RyaW5nKCkgKyBleGl0VG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25kaXRpb25hbCAoKSB7XG4gICAgdmFyIHByZWQgPSBqb2luKGFyZ3VtZW50cylcbiAgICB2YXIgdGhlbkJsb2NrID0gc2NvcGUoKVxuICAgIHZhciBlbHNlQmxvY2sgPSBzY29wZSgpXG5cbiAgICB2YXIgdGhlblRvU3RyaW5nID0gdGhlbkJsb2NrLnRvU3RyaW5nXG4gICAgdmFyIGVsc2VUb1N0cmluZyA9IGVsc2VCbG9jay50b1N0cmluZ1xuXG4gICAgcmV0dXJuIGV4dGVuZCh0aGVuQmxvY2ssIHtcbiAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhlbkJsb2NrLmFwcGx5KHRoZW5CbG9jaywgc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBlbHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsc2VCbG9jay5hcHBseShlbHNlQmxvY2ssIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsc2VDbGF1c2UgPSBlbHNlVG9TdHJpbmcoKVxuICAgICAgICBpZiAoZWxzZUNsYXVzZSkge1xuICAgICAgICAgIGVsc2VDbGF1c2UgPSAnZWxzZXsnICsgZWxzZUNsYXVzZSArICd9J1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnaWYoJywgcHJlZCwgJyl7JyxcbiAgICAgICAgICB0aGVuVG9TdHJpbmcoKSxcbiAgICAgICAgICAnfScsIGVsc2VDbGF1c2VcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gcHJvY2VkdXJlIGxpc3RcbiAgdmFyIGdsb2JhbEJsb2NrID0gYmxvY2soKVxuICB2YXIgcHJvY2VkdXJlcyA9IHt9XG4gIGZ1bmN0aW9uIHByb2MgKG5hbWUsIGNvdW50KSB7XG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZ1bmN0aW9uIGFyZyAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICdhJyArIGFyZ3MubGVuZ3RoXG4gICAgICBhcmdzLnB1c2gobmFtZSlcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuXG4gICAgY291bnQgPSBjb3VudCB8fCAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBhcmcoKVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gc2NvcGUoKVxuICAgIHZhciBib2R5VG9TdHJpbmcgPSBib2R5LnRvU3RyaW5nXG5cbiAgICB2YXIgcmVzdWx0ID0gcHJvY2VkdXJlc1tuYW1lXSA9IGV4dGVuZChib2R5LCB7XG4gICAgICBhcmc6IGFyZyxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnZnVuY3Rpb24oJywgYXJncy5qb2luKCksICcpeycsXG4gICAgICAgICAgYm9keVRvU3RyaW5nKCksXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKCkge1xuICAgIHZhciBjb2RlID0gWydcInVzZSBzdHJpY3RcIjsnLFxuICAgICAgZ2xvYmFsQmxvY2ssXG4gICAgICAncmV0dXJuIHsnXVxuICAgIE9iamVjdC5rZXlzKHByb2NlZHVyZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvZGUucHVzaCgnXCInLCBuYW1lLCAnXCI6JywgcHJvY2VkdXJlc1tuYW1lXS50b1N0cmluZygpLCAnLCcpXG4gICAgfSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICAgIHZhciBzcmMgPSBqb2luKGNvZGUpXG4gICAgICAucmVwbGFjZSgvOy9nLCAnO1xcbicpXG4gICAgICAucmVwbGFjZSgvfS9nLCAnfVxcbicpXG4gICAgICAucmVwbGFjZSgvey9nLCAne1xcbicpXG4gICAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseShudWxsLCBsaW5rZWROYW1lcy5jb25jYXQoc3JjKSlcbiAgICByZXR1cm4gcHJvYy5hcHBseShudWxsLCBsaW5rZWRWYWx1ZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsb2JhbDogZ2xvYmFsQmxvY2ssXG4gICAgbGluazogbGluayxcbiAgICBibG9jazogYmxvY2ssXG4gICAgcHJvYzogcHJvYyxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgY29uZDogY29uZGl0aW9uYWwsXG4gICAgY29tcGlsZTogY29tcGlsZVxuICB9XG59XG5cbi8vIFwiY3V0ZVwiIG5hbWVzIGZvciB2ZWN0b3IgY29tcG9uZW50c1xudmFyIENVVEVfQ09NUE9ORU5UUyA9ICd4eXp3Jy5zcGxpdCgnJylcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUkOCA9IDUxMjFcblxudmFyIEFUVFJJQl9TVEFURV9QT0lOVEVSID0gMVxudmFyIEFUVFJJQl9TVEFURV9DT05TVEFOVCA9IDJcblxudmFyIERZTl9GVU5DJDEgPSAwXG52YXIgRFlOX1BST1AkMSA9IDFcbnZhciBEWU5fQ09OVEVYVCQxID0gMlxudmFyIERZTl9TVEFURSQxID0gM1xudmFyIERZTl9USFVOSyA9IDRcbnZhciBEWU5fQ09OU1RBTlQkMSA9IDVcbnZhciBEWU5fQVJSQVkkMSA9IDZcblxudmFyIFNfRElUSEVSID0gJ2RpdGhlcidcbnZhciBTX0JMRU5EX0VOQUJMRSA9ICdibGVuZC5lbmFibGUnXG52YXIgU19CTEVORF9DT0xPUiA9ICdibGVuZC5jb2xvcidcbnZhciBTX0JMRU5EX0VRVUFUSU9OID0gJ2JsZW5kLmVxdWF0aW9uJ1xudmFyIFNfQkxFTkRfRlVOQyA9ICdibGVuZC5mdW5jJ1xudmFyIFNfREVQVEhfRU5BQkxFID0gJ2RlcHRoLmVuYWJsZSdcbnZhciBTX0RFUFRIX0ZVTkMgPSAnZGVwdGguZnVuYydcbnZhciBTX0RFUFRIX1JBTkdFID0gJ2RlcHRoLnJhbmdlJ1xudmFyIFNfREVQVEhfTUFTSyA9ICdkZXB0aC5tYXNrJ1xudmFyIFNfQ09MT1JfTUFTSyA9ICdjb2xvck1hc2snXG52YXIgU19DVUxMX0VOQUJMRSA9ICdjdWxsLmVuYWJsZSdcbnZhciBTX0NVTExfRkFDRSA9ICdjdWxsLmZhY2UnXG52YXIgU19GUk9OVF9GQUNFID0gJ2Zyb250RmFjZSdcbnZhciBTX0xJTkVfV0lEVEggPSAnbGluZVdpZHRoJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfRU5BQkxFID0gJ3BvbHlnb25PZmZzZXQuZW5hYmxlJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfT0ZGU0VUID0gJ3BvbHlnb25PZmZzZXQub2Zmc2V0J1xudmFyIFNfU0FNUExFX0FMUEhBID0gJ3NhbXBsZS5hbHBoYSdcbnZhciBTX1NBTVBMRV9FTkFCTEUgPSAnc2FtcGxlLmVuYWJsZSdcbnZhciBTX1NBTVBMRV9DT1ZFUkFHRSA9ICdzYW1wbGUuY292ZXJhZ2UnXG52YXIgU19TVEVOQ0lMX0VOQUJMRSA9ICdzdGVuY2lsLmVuYWJsZSdcbnZhciBTX1NURU5DSUxfTUFTSyA9ICdzdGVuY2lsLm1hc2snXG52YXIgU19TVEVOQ0lMX0ZVTkMgPSAnc3RlbmNpbC5mdW5jJ1xudmFyIFNfU1RFTkNJTF9PUEZST05UID0gJ3N0ZW5jaWwub3BGcm9udCdcbnZhciBTX1NURU5DSUxfT1BCQUNLID0gJ3N0ZW5jaWwub3BCYWNrJ1xudmFyIFNfU0NJU1NPUl9FTkFCTEUgPSAnc2Npc3Nvci5lbmFibGUnXG52YXIgU19TQ0lTU09SX0JPWCA9ICdzY2lzc29yLmJveCdcbnZhciBTX1ZJRVdQT1JUID0gJ3ZpZXdwb3J0J1xuXG52YXIgU19QUk9GSUxFID0gJ3Byb2ZpbGUnXG5cbnZhciBTX0ZSQU1FQlVGRkVSID0gJ2ZyYW1lYnVmZmVyJ1xudmFyIFNfVkVSVCA9ICd2ZXJ0J1xudmFyIFNfRlJBRyA9ICdmcmFnJ1xudmFyIFNfRUxFTUVOVFMgPSAnZWxlbWVudHMnXG52YXIgU19QUklNSVRJVkUgPSAncHJpbWl0aXZlJ1xudmFyIFNfQ09VTlQgPSAnY291bnQnXG52YXIgU19PRkZTRVQgPSAnb2Zmc2V0J1xudmFyIFNfSU5TVEFOQ0VTID0gJ2luc3RhbmNlcydcbnZhciBTX1ZBTyA9ICd2YW8nXG5cbnZhciBTVUZGSVhfV0lEVEggPSAnV2lkdGgnXG52YXIgU1VGRklYX0hFSUdIVCA9ICdIZWlnaHQnXG5cbnZhciBTX0ZSQU1FQlVGRkVSX1dJRFRIID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9XSURUSFxudmFyIFNfRlJBTUVCVUZGRVJfSEVJR0hUID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9IRUlHSFRcbnZhciBTX1ZJRVdQT1JUX1dJRFRIID0gU19WSUVXUE9SVCArIFNVRkZJWF9XSURUSFxudmFyIFNfVklFV1BPUlRfSEVJR0hUID0gU19WSUVXUE9SVCArIFNVRkZJWF9IRUlHSFRcbnZhciBTX0RSQVdJTkdCVUZGRVIgPSAnZHJhd2luZ0J1ZmZlcidcbnZhciBTX0RSQVdJTkdCVUZGRVJfV0lEVEggPSBTX0RSQVdJTkdCVUZGRVIgKyBTVUZGSVhfV0lEVEhcbnZhciBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUID0gU19EUkFXSU5HQlVGRkVSICsgU1VGRklYX0hFSUdIVFxuXG52YXIgTkVTVEVEX09QVElPTlMgPSBbXG4gIFNfQkxFTkRfRlVOQyxcbiAgU19CTEVORF9FUVVBVElPTixcbiAgU19TVEVOQ0lMX0ZVTkMsXG4gIFNfU1RFTkNJTF9PUEZST05ULFxuICBTX1NURU5DSUxfT1BCQUNLLFxuICBTX1NBTVBMRV9DT1ZFUkFHRSxcbiAgU19WSUVXUE9SVCxcbiAgU19TQ0lTU09SX0JPWCxcbiAgU19QT0xZR09OX09GRlNFVF9PRkZTRVRcbl1cblxudmFyIEdMX0FSUkFZX0JVRkZFUiQyID0gMzQ5NjJcbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjNcblxudmFyIEdMX0ZSQUdNRU5UX1NIQURFUiQxID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSJDEgPSAzNTYzM1xuXG52YXIgR0xfVEVYVFVSRV8yRCQzID0gMHgwREUxXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUCQyID0gMHg4NTEzXG5cbnZhciBHTF9DVUxMX0ZBQ0UgPSAweDBCNDRcbnZhciBHTF9CTEVORCA9IDB4MEJFMlxudmFyIEdMX0RJVEhFUiA9IDB4MEJEMFxudmFyIEdMX1NURU5DSUxfVEVTVCA9IDB4MEI5MFxudmFyIEdMX0RFUFRIX1RFU1QgPSAweDBCNzFcbnZhciBHTF9TQ0lTU09SX1RFU1QgPSAweDBDMTFcbnZhciBHTF9QT0xZR09OX09GRlNFVF9GSUxMID0gMHg4MDM3XG52YXIgR0xfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFID0gMHg4MDlFXG52YXIgR0xfU0FNUExFX0NPVkVSQUdFID0gMHg4MEEwXG5cbnZhciBHTF9GTE9BVCQ4ID0gNTEyNlxudmFyIEdMX0ZMT0FUX1ZFQzIgPSAzNTY2NFxudmFyIEdMX0ZMT0FUX1ZFQzMgPSAzNTY2NVxudmFyIEdMX0ZMT0FUX1ZFQzQgPSAzNTY2NlxudmFyIEdMX0lOVCQzID0gNTEyNFxudmFyIEdMX0lOVF9WRUMyID0gMzU2NjdcbnZhciBHTF9JTlRfVkVDMyA9IDM1NjY4XG52YXIgR0xfSU5UX1ZFQzQgPSAzNTY2OVxudmFyIEdMX0JPT0wgPSAzNTY3MFxudmFyIEdMX0JPT0xfVkVDMiA9IDM1NjcxXG52YXIgR0xfQk9PTF9WRUMzID0gMzU2NzJcbnZhciBHTF9CT09MX1ZFQzQgPSAzNTY3M1xudmFyIEdMX0ZMT0FUX01BVDIgPSAzNTY3NFxudmFyIEdMX0ZMT0FUX01BVDMgPSAzNTY3NVxudmFyIEdMX0ZMT0FUX01BVDQgPSAzNTY3NlxudmFyIEdMX1NBTVBMRVJfMkQgPSAzNTY3OFxudmFyIEdMX1NBTVBMRVJfQ1VCRSA9IDM1NjgwXG5cbnZhciBHTF9UUklBTkdMRVMkMSA9IDRcblxudmFyIEdMX0ZST05UID0gMTAyOFxudmFyIEdMX0JBQ0sgPSAxMDI5XG52YXIgR0xfQ1cgPSAweDA5MDBcbnZhciBHTF9DQ1cgPSAweDA5MDFcbnZhciBHTF9NSU5fRVhUID0gMHg4MDA3XG52YXIgR0xfTUFYX0VYVCA9IDB4ODAwOFxudmFyIEdMX0FMV0FZUyA9IDUxOVxudmFyIEdMX0tFRVAgPSA3NjgwXG52YXIgR0xfWkVSTyA9IDBcbnZhciBHTF9PTkUgPSAxXG52YXIgR0xfRlVOQ19BREQgPSAweDgwMDZcbnZhciBHTF9MRVNTID0gNTEzXG5cbnZhciBHTF9GUkFNRUJVRkZFUiQyID0gMHg4RDQwXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMiA9IDB4OENFMFxuXG52YXIgYmxlbmRGdW5jcyA9IHtcbiAgJzAnOiAwLFxuICAnMSc6IDEsXG4gICd6ZXJvJzogMCxcbiAgJ29uZSc6IDEsXG4gICdzcmMgY29sb3InOiA3NjgsXG4gICdvbmUgbWludXMgc3JjIGNvbG9yJzogNzY5LFxuICAnc3JjIGFscGhhJzogNzcwLFxuICAnb25lIG1pbnVzIHNyYyBhbHBoYSc6IDc3MSxcbiAgJ2RzdCBjb2xvcic6IDc3NCxcbiAgJ29uZSBtaW51cyBkc3QgY29sb3InOiA3NzUsXG4gICdkc3QgYWxwaGEnOiA3NzIsXG4gICdvbmUgbWludXMgZHN0IGFscGhhJzogNzczLFxuICAnY29uc3RhbnQgY29sb3InOiAzMjc2OSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvcic6IDMyNzcwLFxuICAnY29uc3RhbnQgYWxwaGEnOiAzMjc3MSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSc6IDMyNzcyLFxuICAnc3JjIGFscGhhIHNhdHVyYXRlJzogNzc2XG59XG5cbi8vIFRoZXJlIGFyZSBpbnZhbGlkIHZhbHVlcyBmb3Igc3JjUkdCIGFuZCBkc3RSR0IuIFNlZTpcbi8vIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jNi4xM1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9XZWJHTC9ibG9iLzBkMzIwMWY1ZjdlYzNjMDA2MGJjMWYwNDA3NzQ2MTU0MWYxOTg3YjkvY29uZm9ybWFuY2Utc3VpdGVzLzEuMC4zL2NvbmZvcm1hbmNlL21pc2Mvd2ViZ2wtc3BlY2lmaWMuaHRtbCNMNTZcbnZhciBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBbXG4gICdjb25zdGFudCBjb2xvciwgY29uc3RhbnQgYWxwaGEnLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yLCBjb25zdGFudCBhbHBoYScsXG4gICdjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ2NvbnN0YW50IGFscGhhLCBjb25zdGFudCBjb2xvcicsXG4gICdjb25zdGFudCBhbHBoYSwgb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSwgY29uc3RhbnQgY29sb3InLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhLCBvbmUgbWludXMgY29uc3RhbnQgY29sb3InXG5dXG5cbnZhciBjb21wYXJlRnVuY3MgPSB7XG4gICduZXZlcic6IDUxMixcbiAgJ2xlc3MnOiA1MTMsXG4gICc8JzogNTEzLFxuICAnZXF1YWwnOiA1MTQsXG4gICc9JzogNTE0LFxuICAnPT0nOiA1MTQsXG4gICc9PT0nOiA1MTQsXG4gICdsZXF1YWwnOiA1MTUsXG4gICc8PSc6IDUxNSxcbiAgJ2dyZWF0ZXInOiA1MTYsXG4gICc+JzogNTE2LFxuICAnbm90ZXF1YWwnOiA1MTcsXG4gICchPSc6IDUxNyxcbiAgJyE9PSc6IDUxNyxcbiAgJ2dlcXVhbCc6IDUxOCxcbiAgJz49JzogNTE4LFxuICAnYWx3YXlzJzogNTE5XG59XG5cbnZhciBzdGVuY2lsT3BzID0ge1xuICAnMCc6IDAsXG4gICd6ZXJvJzogMCxcbiAgJ2tlZXAnOiA3NjgwLFxuICAncmVwbGFjZSc6IDc2ODEsXG4gICdpbmNyZW1lbnQnOiA3NjgyLFxuICAnZGVjcmVtZW50JzogNzY4MyxcbiAgJ2luY3JlbWVudCB3cmFwJzogMzQwNTUsXG4gICdkZWNyZW1lbnQgd3JhcCc6IDM0MDU2LFxuICAnaW52ZXJ0JzogNTM4NlxufVxuXG52YXIgc2hhZGVyVHlwZSA9IHtcbiAgJ2ZyYWcnOiBHTF9GUkFHTUVOVF9TSEFERVIkMSxcbiAgJ3ZlcnQnOiBHTF9WRVJURVhfU0hBREVSJDFcbn1cblxudmFyIG9yaWVudGF0aW9uVHlwZSA9IHtcbiAgJ2N3JzogR0xfQ1csXG4gICdjY3cnOiBHTF9DQ1dcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXJBcmdzICh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpIHx8XG4gICAgaXNUeXBlZEFycmF5KHgpIHx8XG4gICAgaXNOREFycmF5TGlrZSh4KVxufVxuXG4vLyBNYWtlIHN1cmUgdmlld3BvcnQgaXMgcHJvY2Vzc2VkIGZpcnN0XG5mdW5jdGlvbiBzb3J0U3RhdGUgKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IFNfVklFV1BPUlQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gU19WSUVXUE9SVCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIChhIDwgYikgPyAtMSA6IDFcbiAgfSlcbn1cblxuZnVuY3Rpb24gRGVjbGFyYXRpb24gKHRoaXNEZXAsIGNvbnRleHREZXAsIHByb3BEZXAsIGFwcGVuZCkge1xuICB0aGlzLnRoaXNEZXAgPSB0aGlzRGVwXG4gIHRoaXMuY29udGV4dERlcCA9IGNvbnRleHREZXBcbiAgdGhpcy5wcm9wRGVwID0gcHJvcERlcFxuICB0aGlzLmFwcGVuZCA9IGFwcGVuZFxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAoZGVjbCkge1xuICByZXR1cm4gZGVjbCAmJiAhKGRlY2wudGhpc0RlcCB8fCBkZWNsLmNvbnRleHREZXAgfHwgZGVjbC5wcm9wRGVwKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNEZWNsIChhcHBlbmQpIHtcbiAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihmYWxzZSwgZmFsc2UsIGZhbHNlLCBhcHBlbmQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNEZWNsIChkeW4sIGFwcGVuZCkge1xuICB2YXIgdHlwZSA9IGR5bi50eXBlXG4gIGlmICh0eXBlID09PSBEWU5fRlVOQyQxKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBkeW4uZGF0YS5sZW5ndGhcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgdHJ1ZSxcbiAgICAgIG51bUFyZ3MgPj0gMSxcbiAgICAgIG51bUFyZ3MgPj0gMixcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fVEhVTkspIHtcbiAgICB2YXIgZGF0YSA9IGR5bi5kYXRhXG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIGRhdGEudGhpc0RlcCxcbiAgICAgIGRhdGEuY29udGV4dERlcCxcbiAgICAgIGRhdGEucHJvcERlcCxcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fQ09OU1RBTlQkMSkge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRFlOX0FSUkFZJDEpIHtcbiAgICB2YXIgdGhpc0RlcCA9IGZhbHNlXG4gICAgdmFyIGNvbnRleHREZXAgPSBmYWxzZVxuICAgIHZhciBwcm9wRGVwID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5bi5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViRHluID0gZHluLmRhdGFbaV1cbiAgICAgIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1BST1AkMSkge1xuICAgICAgICBwcm9wRGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX0NPTlRFWFQkMSkge1xuICAgICAgICBjb250ZXh0RGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1NUQVRFJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoc3ViRHluLnR5cGUgPT09IERZTl9GVU5DJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgICAgdmFyIHN1YkFyZ3MgPSBzdWJEeW4uZGF0YVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAxKSB7XG4gICAgICAgICAgY29udGV4dERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAyKSB7XG4gICAgICAgICAgcHJvcERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1RIVU5LKSB7XG4gICAgICAgIHRoaXNEZXAgPSB0aGlzRGVwIHx8IHN1YkR5bi5kYXRhLnRoaXNEZXBcbiAgICAgICAgY29udGV4dERlcCA9IGNvbnRleHREZXAgfHwgc3ViRHluLmRhdGEuY29udGV4dERlcFxuICAgICAgICBwcm9wRGVwID0gcHJvcERlcCB8fCBzdWJEeW4uZGF0YS5wcm9wRGVwXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICB0aGlzRGVwLFxuICAgICAgY29udGV4dERlcCxcbiAgICAgIHByb3BEZXAsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIHR5cGUgPT09IERZTl9TVEFURSQxLFxuICAgICAgdHlwZSA9PT0gRFlOX0NPTlRFWFQkMSxcbiAgICAgIHR5cGUgPT09IERZTl9QUk9QJDEsXG4gICAgICBhcHBlbmQpXG4gIH1cbn1cblxudmFyIFNDT1BFX0RFQ0wgPSBuZXcgRGVjbGFyYXRpb24oZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24gKCkge30pXG5cbmZ1bmN0aW9uIHJlZ2xDb3JlIChcbiAgZ2wsXG4gIHN0cmluZ1N0b3JlLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMsXG4gIGJ1ZmZlclN0YXRlLFxuICBlbGVtZW50U3RhdGUsXG4gIHRleHR1cmVTdGF0ZSxcbiAgZnJhbWVidWZmZXJTdGF0ZSxcbiAgdW5pZm9ybVN0YXRlLFxuICBhdHRyaWJ1dGVTdGF0ZSxcbiAgc2hhZGVyU3RhdGUsXG4gIGRyYXdTdGF0ZSxcbiAgY29udGV4dFN0YXRlLFxuICB0aW1lcixcbiAgY29uZmlnKSB7XG4gIHZhciBBdHRyaWJ1dGVSZWNvcmQgPSBhdHRyaWJ1dGVTdGF0ZS5SZWNvcmRcblxuICB2YXIgYmxlbmRFcXVhdGlvbnMgPSB7XG4gICAgJ2FkZCc6IDMyNzc0LFxuICAgICdzdWJ0cmFjdCc6IDMyNzc4LFxuICAgICdyZXZlcnNlIHN1YnRyYWN0JzogMzI3NzlcbiAgfVxuICBpZiAoZXh0ZW5zaW9ucy5leHRfYmxlbmRfbWlubWF4KSB7XG4gICAgYmxlbmRFcXVhdGlvbnMubWluID0gR0xfTUlOX0VYVFxuICAgIGJsZW5kRXF1YXRpb25zLm1heCA9IEdMX01BWF9FWFRcbiAgfVxuXG4gIHZhciBleHRJbnN0YW5jaW5nID0gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gIHZhciBleHREcmF3QnVmZmVycyA9IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBXRUJHTCBTVEFURVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBjdXJyZW50U3RhdGUgPSB7XG4gICAgZGlydHk6IHRydWUsXG4gICAgcHJvZmlsZTogY29uZmlnLnByb2ZpbGVcbiAgfVxuICB2YXIgbmV4dFN0YXRlID0ge31cbiAgdmFyIEdMX1NUQVRFX05BTUVTID0gW11cbiAgdmFyIEdMX0ZMQUdTID0ge31cbiAgdmFyIEdMX1ZBUklBQkxFUyA9IHt9XG5cbiAgZnVuY3Rpb24gcHJvcE5hbWUgKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCcuJywgJ18nKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVGbGFnIChzbmFtZSwgY2FwLCBpbml0KSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZShzbmFtZSlcbiAgICBHTF9TVEFURV9OQU1FUy5wdXNoKHNuYW1lKVxuICAgIG5leHRTdGF0ZVtuYW1lXSA9IGN1cnJlbnRTdGF0ZVtuYW1lXSA9ICEhaW5pdFxuICAgIEdMX0ZMQUdTW25hbWVdID0gY2FwXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZVZhcmlhYmxlIChzbmFtZSwgZnVuYywgaW5pdCkge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWUoc25hbWUpXG4gICAgR0xfU1RBVEVfTkFNRVMucHVzaChzbmFtZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gaW5pdC5zbGljZSgpXG4gICAgICBuZXh0U3RhdGVbbmFtZV0gPSBpbml0LnNsaWNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gbmV4dFN0YXRlW25hbWVdID0gaW5pdFxuICAgIH1cbiAgICBHTF9WQVJJQUJMRVNbbmFtZV0gPSBmdW5jXG4gIH1cblxuICAvLyBEaXRoZXJpbmdcbiAgc3RhdGVGbGFnKFNfRElUSEVSLCBHTF9ESVRIRVIpXG5cbiAgLy8gQmxlbmRpbmdcbiAgc3RhdGVGbGFnKFNfQkxFTkRfRU5BQkxFLCBHTF9CTEVORClcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0NPTE9SLCAnYmxlbmRDb2xvcicsIFswLCAwLCAwLCAwXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0VRVUFUSU9OLCAnYmxlbmRFcXVhdGlvblNlcGFyYXRlJyxcbiAgICBbR0xfRlVOQ19BREQsIEdMX0ZVTkNfQUREXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0ZVTkMsICdibGVuZEZ1bmNTZXBhcmF0ZScsXG4gICAgW0dMX09ORSwgR0xfWkVSTywgR0xfT05FLCBHTF9aRVJPXSlcblxuICAvLyBEZXB0aFxuICBzdGF0ZUZsYWcoU19ERVBUSF9FTkFCTEUsIEdMX0RFUFRIX1RFU1QsIHRydWUpXG4gIHN0YXRlVmFyaWFibGUoU19ERVBUSF9GVU5DLCAnZGVwdGhGdW5jJywgR0xfTEVTUylcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX1JBTkdFLCAnZGVwdGhSYW5nZScsIFswLCAxXSlcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX01BU0ssICdkZXB0aE1hc2snLCB0cnVlKVxuXG4gIC8vIENvbG9yIG1hc2tcbiAgc3RhdGVWYXJpYWJsZShTX0NPTE9SX01BU0ssIFNfQ09MT1JfTUFTSywgW3RydWUsIHRydWUsIHRydWUsIHRydWVdKVxuXG4gIC8vIEZhY2UgY3VsbGluZ1xuICBzdGF0ZUZsYWcoU19DVUxMX0VOQUJMRSwgR0xfQ1VMTF9GQUNFKVxuICBzdGF0ZVZhcmlhYmxlKFNfQ1VMTF9GQUNFLCAnY3VsbEZhY2UnLCBHTF9CQUNLKVxuXG4gIC8vIEZyb250IGZhY2Ugb3JpZW50YXRpb25cbiAgc3RhdGVWYXJpYWJsZShTX0ZST05UX0ZBQ0UsIFNfRlJPTlRfRkFDRSwgR0xfQ0NXKVxuXG4gIC8vIExpbmUgd2lkdGhcbiAgc3RhdGVWYXJpYWJsZShTX0xJTkVfV0lEVEgsIFNfTElORV9XSURUSCwgMSlcblxuICAvLyBQb2x5Z29uIG9mZnNldFxuICBzdGF0ZUZsYWcoU19QT0xZR09OX09GRlNFVF9FTkFCTEUsIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwpXG4gIHN0YXRlVmFyaWFibGUoU19QT0xZR09OX09GRlNFVF9PRkZTRVQsICdwb2x5Z29uT2Zmc2V0JywgWzAsIDBdKVxuXG4gIC8vIFNhbXBsZSBjb3ZlcmFnZVxuICBzdGF0ZUZsYWcoU19TQU1QTEVfQUxQSEEsIEdMX1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSlcbiAgc3RhdGVGbGFnKFNfU0FNUExFX0VOQUJMRSwgR0xfU0FNUExFX0NPVkVSQUdFKVxuICBzdGF0ZVZhcmlhYmxlKFNfU0FNUExFX0NPVkVSQUdFLCAnc2FtcGxlQ292ZXJhZ2UnLCBbMSwgZmFsc2VdKVxuXG4gIC8vIFN0ZW5jaWxcbiAgc3RhdGVGbGFnKFNfU1RFTkNJTF9FTkFCTEUsIEdMX1NURU5DSUxfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfTUFTSywgJ3N0ZW5jaWxNYXNrJywgLTEpXG4gIHN0YXRlVmFyaWFibGUoU19TVEVOQ0lMX0ZVTkMsICdzdGVuY2lsRnVuYycsIFtHTF9BTFdBWVMsIDAsIC0xXSlcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfT1BGUk9OVCwgJ3N0ZW5jaWxPcFNlcGFyYXRlJyxcbiAgICBbR0xfRlJPTlQsIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9PUEJBQ0ssICdzdGVuY2lsT3BTZXBhcmF0ZScsXG4gICAgW0dMX0JBQ0ssIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuXG4gIC8vIFNjaXNzb3JcbiAgc3RhdGVGbGFnKFNfU0NJU1NPUl9FTkFCTEUsIEdMX1NDSVNTT1JfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NDSVNTT1JfQk9YLCAnc2Npc3NvcicsXG4gICAgWzAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodF0pXG5cbiAgLy8gVmlld3BvcnRcbiAgc3RhdGVWYXJpYWJsZShTX1ZJRVdQT1JULCBTX1ZJRVdQT1JULFxuICAgIFswLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHRdKVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRU5WSVJPTk1FTlRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgc2hhcmVkU3RhdGUgPSB7XG4gICAgZ2w6IGdsLFxuICAgIGNvbnRleHQ6IGNvbnRleHRTdGF0ZSxcbiAgICBzdHJpbmdzOiBzdHJpbmdTdG9yZSxcbiAgICBuZXh0OiBuZXh0U3RhdGUsXG4gICAgY3VycmVudDogY3VycmVudFN0YXRlLFxuICAgIGRyYXc6IGRyYXdTdGF0ZSxcbiAgICBlbGVtZW50czogZWxlbWVudFN0YXRlLFxuICAgIGJ1ZmZlcjogYnVmZmVyU3RhdGUsXG4gICAgc2hhZGVyOiBzaGFkZXJTdGF0ZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVTdGF0ZS5zdGF0ZSxcbiAgICB2YW86IGF0dHJpYnV0ZVN0YXRlLFxuICAgIHVuaWZvcm1zOiB1bmlmb3JtU3RhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcblxuICAgIHRpbWVyOiB0aW1lcixcbiAgICBpc0J1ZmZlckFyZ3M6IGlzQnVmZmVyQXJnc1xuICB9XG5cbiAgdmFyIHNoYXJlZENvbnN0YW50cyA9IHtcbiAgICBwcmltVHlwZXM6IHByaW1UeXBlcyxcbiAgICBjb21wYXJlRnVuY3M6IGNvbXBhcmVGdW5jcyxcbiAgICBibGVuZEZ1bmNzOiBibGVuZEZ1bmNzLFxuICAgIGJsZW5kRXF1YXRpb25zOiBibGVuZEVxdWF0aW9ucyxcbiAgICBzdGVuY2lsT3BzOiBzdGVuY2lsT3BzLFxuICAgIGdsVHlwZXM6IGdsVHlwZXMsXG4gICAgb3JpZW50YXRpb25UeXBlOiBvcmllbnRhdGlvblR5cGVcbiAgfVxuXG4gIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZFN0YXRlLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VcbiAgfSlcblxuICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICBzaGFyZWRDb25zdGFudHMuYmFja0J1ZmZlciA9IFtHTF9CQUNLXVxuICAgIHNoYXJlZENvbnN0YW50cy5kcmF3QnVmZmVyID0gbG9vcChsaW1pdHMubWF4RHJhd2J1ZmZlcnMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdXG4gICAgICB9XG4gICAgICByZXR1cm4gbG9vcChpLCBmdW5jdGlvbiAoaikge1xuICAgICAgICByZXR1cm4gR0xfQ09MT1JfQVRUQUNITUVOVDAkMiArIGpcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBkcmF3Q2FsbENvdW50ZXIgPSAwXG4gIGZ1bmN0aW9uIGNyZWF0ZVJFR0xFbnZpcm9ubWVudCAoKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KClcbiAgICB2YXIgbGluayA9IGVudi5saW5rXG4gICAgdmFyIGdsb2JhbCA9IGVudi5nbG9iYWxcbiAgICBlbnYuaWQgPSBkcmF3Q2FsbENvdW50ZXIrK1xuXG4gICAgZW52LmJhdGNoSWQgPSAnMCdcblxuICAgIC8vIGxpbmsgc2hhcmVkIHN0YXRlXG4gICAgdmFyIFNIQVJFRCA9IGxpbmsoc2hhcmVkU3RhdGUpXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQgPSB7XG4gICAgICBwcm9wczogJ2EwJ1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgc2hhcmVkW3Byb3BdID0gZ2xvYmFsLmRlZihTSEFSRUQsICcuJywgcHJvcClcbiAgICB9KVxuXG4gICAgLy8gSW5qZWN0IHJ1bnRpbWUgYXNzZXJ0aW9uIHN0dWZmIGZvciBkZWJ1ZyBidWlsZHNcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5DSEVDSyA9IGxpbmsoY2hlY2skMSlcbiAgICAgIGVudi5jb21tYW5kU3RyID0gY2hlY2skMS5ndWVzc0NvbW1hbmQoKVxuICAgICAgZW52LmNvbW1hbmQgPSBsaW5rKGVudi5jb21tYW5kU3RyKVxuICAgICAgZW52LmFzc2VydCA9IGZ1bmN0aW9uIChibG9jaywgcHJlZCwgbWVzc2FnZSkge1xuICAgICAgICBibG9jayhcbiAgICAgICAgICAnaWYoISgnLCBwcmVkLCAnKSknLFxuICAgICAgICAgIHRoaXMuQ0hFQ0ssICcuY29tbWFuZFJhaXNlKCcsIGxpbmsobWVzc2FnZSksICcsJywgdGhpcy5jb21tYW5kLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBzaGFyZWRDb25zdGFudHMuaW52YWxpZEJsZW5kQ29tYmluYXRpb25zID0gaW52YWxpZEJsZW5kQ29tYmluYXRpb25zXG4gICAgfSlcblxuICAgIC8vIENvcHkgR0wgc3RhdGUgdmFyaWFibGVzIG92ZXJcbiAgICB2YXIgbmV4dFZhcnMgPSBlbnYubmV4dCA9IHt9XG4gICAgdmFyIGN1cnJlbnRWYXJzID0gZW52LmN1cnJlbnQgPSB7fVxuICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTdGF0ZVt2YXJpYWJsZV0pKSB7XG4gICAgICAgIG5leHRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLm5leHQsICcuJywgdmFyaWFibGUpXG4gICAgICAgIGN1cnJlbnRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLmN1cnJlbnQsICcuJywgdmFyaWFibGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEluaXRpYWxpemUgc2hhcmVkIGNvbnN0YW50c1xuICAgIHZhciBjb25zdGFudHMgPSBlbnYuY29uc3RhbnRzID0ge31cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRDb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnN0YW50c1tuYW1lXSA9IGdsb2JhbC5kZWYoSlNPTi5zdHJpbmdpZnkoc2hhcmVkQ29uc3RhbnRzW25hbWVdKSlcbiAgICB9KVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBjYWxsaW5nIGEgYmxvY2tcbiAgICBlbnYuaW52b2tlID0gZnVuY3Rpb24gKGJsb2NrLCB4KSB7XG4gICAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICAgICBjYXNlIERZTl9GVU5DJDE6XG4gICAgICAgICAgdmFyIGFyZ0xpc3QgPSBbXG4gICAgICAgICAgICAndGhpcycsXG4gICAgICAgICAgICBzaGFyZWQuY29udGV4dCxcbiAgICAgICAgICAgIHNoYXJlZC5wcm9wcyxcbiAgICAgICAgICAgIGVudi5iYXRjaElkXG4gICAgICAgICAgXVxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoXG4gICAgICAgICAgICBsaW5rKHguZGF0YSksICcuY2FsbCgnLFxuICAgICAgICAgICAgYXJnTGlzdC5zbGljZSgwLCBNYXRoLm1heCh4LmRhdGEubGVuZ3RoICsgMSwgNCkpLFxuICAgICAgICAgICAgJyknKVxuICAgICAgICBjYXNlIERZTl9QUk9QJDE6XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihzaGFyZWQucHJvcHMsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fQ09OVEVYVCQxOlxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoc2hhcmVkLmNvbnRleHQsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fU1RBVEUkMTpcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKCd0aGlzJywgeC5kYXRhKVxuICAgICAgICBjYXNlIERZTl9USFVOSzpcbiAgICAgICAgICB4LmRhdGEuYXBwZW5kKGVudiwgYmxvY2spXG4gICAgICAgICAgcmV0dXJuIHguZGF0YS5yZWZcbiAgICAgICAgY2FzZSBEWU5fQ09OU1RBTlQkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY2FzZSBEWU5fQVJSQVkkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5pbnZva2UoYmxvY2ssIHkpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnYuYXR0cmliQ2FjaGUgPSB7fVxuXG4gICAgdmFyIHNjb3BlQXR0cmlicyA9IHt9XG4gICAgZW52LnNjb3BlQXR0cmliID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpZCA9IHN0cmluZ1N0b3JlLmlkKG5hbWUpXG4gICAgICBpZiAoaWQgaW4gc2NvcGVBdHRyaWJzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUF0dHJpYnNbaWRdXG4gICAgICB9XG4gICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZVN0YXRlLnNjb3BlW2lkXVxuICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcgPSBhdHRyaWJ1dGVTdGF0ZS5zY29wZVtpZF0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzY29wZUF0dHJpYnNbaWRdID0gbGluayhiaW5kaW5nKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHJldHVybiBlbnZcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUEFSU0lOR1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIHBhcnNlUHJvZmlsZSAob3B0aW9ucykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBwcm9maWxlRW5hYmxlXG4gICAgaWYgKFNfUFJPRklMRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWUgPSAhIXN0YXRpY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9KVxuICAgICAgcHJvZmlsZUVuYWJsZS5lbmFibGUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoU19QUk9GSUxFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2ZpbGVFbmFibGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnJhbWVidWZmZXIgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGlmIChTX0ZSQU1FQlVGRkVSIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IHN0YXRpY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICBmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyU3RhdGUuZ2V0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFtZWJ1ZmZlciwgJ2ludmFsaWQgZnJhbWVidWZmZXIgb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgYmxvY2spIHtcbiAgICAgICAgICB2YXIgRlJBTUVCVUZGRVIgPSBlbnYubGluayhmcmFtZWJ1ZmZlcilcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUilcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0XG4gICAgICAgICAgYmxvY2suc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfV0lEVEgsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUiArICcud2lkdGgnKVxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICAgIEZSQU1FQlVGRkVSICsgJy5oZWlnaHQnKVxuICAgICAgICAgIHJldHVybiBGUkFNRUJVRkZFUlxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICAnbnVsbCcpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX1dJRFRILFxuICAgICAgICAgICAgQ09OVEVYVCArICcuJyArIFNfRFJBV0lOR0JVRkZFUl9XSURUSClcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9IRUlHSFQsXG4gICAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTX0ZSQU1FQlVGRkVSIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHZhciBGUkFNRUJVRkZFUl9GVU5DID0gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICB2YXIgRlJBTUVCVUZGRVJfU1RBVEUgPSBzaGFyZWQuZnJhbWVidWZmZXJcbiAgICAgICAgdmFyIEZSQU1FQlVGRkVSID0gc2NvcGUuZGVmKFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLCAnLmdldEZyYW1lYnVmZmVyKCcsIEZSQU1FQlVGRkVSX0ZVTkMsICcpJylcblxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgJyEnICsgRlJBTUVCVUZGRVJfRlVOQyArICd8fCcgKyBGUkFNRUJVRkZFUixcbiAgICAgICAgICAgICdpbnZhbGlkIGZyYW1lYnVmZmVyIG9iamVjdCcpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLFxuICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgRlJBTUVCVUZGRVIpXG4gICAgICAgIHZhciBDT05URVhUID0gc2hhcmVkLmNvbnRleHRcbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArICc/JyArIEZSQU1FQlVGRkVSICsgJy53aWR0aDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX1dJRFRIKVxuICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArXG4gICAgICAgICAgJz8nICsgRlJBTUVCVUZGRVIgKyAnLmhlaWdodDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgcmV0dXJuIEZSQU1FQlVGRkVSXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVmlld3BvcnRTY2lzc29yIChvcHRpb25zLCBmcmFtZWJ1ZmZlciwgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCb3ggKHBhcmFtKSB7XG4gICAgICBpZiAocGFyYW0gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgYm94ID0gc3RhdGljT3B0aW9uc1twYXJhbV1cbiAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShib3gsICdvYmplY3QnLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgIHZhciBpc1N0YXRpYyA9IHRydWVcbiAgICAgICAgdmFyIHggPSBib3gueCB8IDBcbiAgICAgICAgdmFyIHkgPSBib3gueSB8IDBcbiAgICAgICAgdmFyIHcsIGhcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gYm94KSB7XG4gICAgICAgICAgdyA9IGJveC53aWR0aCB8IDBcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodyA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzU3RhdGljID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2hlaWdodCcgaW4gYm94KSB7XG4gICAgICAgICAgaCA9IGJveC5oZWlnaHQgfCAwXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGggPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5jb250ZXh0RGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5wcm9wRGVwLFxuICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgICAgdmFyIEJPWF9XID0gd1xuICAgICAgICAgICAgaWYgKCEoJ3dpZHRoJyBpbiBib3gpKSB7XG4gICAgICAgICAgICAgIEJPWF9XID0gc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCB4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEJPWF9IID0gaFxuICAgICAgICAgICAgaWYgKCEoJ2hlaWdodCcgaW4gYm94KSkge1xuICAgICAgICAgICAgICBCT1hfSCA9IHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hULCAnLScsIHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIEJPWF9XLCBCT1hfSF1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluQm94ID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVEeW5hbWljRGVjbChkeW5Cb3gsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIEJPWCA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bkJveClcblxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgQk9YICsgJyYmdHlwZW9mICcgKyBCT1ggKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwYXJhbSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICB2YXIgQk9YX1ggPSBzY29wZS5kZWYoQk9YLCAnLnh8MCcpXG4gICAgICAgICAgdmFyIEJPWF9ZID0gc2NvcGUuZGVmKEJPWCwgJy55fDAnKVxuICAgICAgICAgIHZhciBCT1hfVyA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcIndpZHRoXCIgaW4gJywgQk9YLCAnPycsIEJPWCwgJy53aWR0aHwwOicsXG4gICAgICAgICAgICAnKCcsIENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCBCT1hfWCwgJyknKVxuICAgICAgICAgIHZhciBCT1hfSCA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcImhlaWdodFwiIGluICcsIEJPWCwgJz8nLCBCT1gsICcuaGVpZ2h0fDA6JyxcbiAgICAgICAgICAgICcoJywgQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCwgJy0nLCBCT1hfWSwgJyknKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBCT1hfVyArICc+PTAmJicgK1xuICAgICAgICAgICAgICBCT1hfSCArICc+PTAnLFxuICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBbQk9YX1gsIEJPWF9ZLCBCT1hfVywgQk9YX0hdXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC50aGlzRGVwID0gcmVzdWx0LnRoaXNEZXAgfHwgZnJhbWVidWZmZXIudGhpc0RlcFxuICAgICAgICAgIHJlc3VsdC5jb250ZXh0RGVwID0gcmVzdWx0LmNvbnRleHREZXAgfHwgZnJhbWVidWZmZXIuY29udGV4dERlcFxuICAgICAgICAgIHJlc3VsdC5wcm9wRGVwID0gcmVzdWx0LnByb3BEZXAgfHwgZnJhbWVidWZmZXIucHJvcERlcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgIGZyYW1lYnVmZmVyLmNvbnRleHREZXAsXG4gICAgICAgICAgZnJhbWVidWZmZXIucHJvcERlcCxcbiAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgIHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfV0lEVEgpLFxuICAgICAgICAgICAgICBzY29wZS5kZWYoQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCldXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0ID0gcGFyc2VCb3goU19WSUVXUE9SVClcblxuICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgdmFyIHByZXZWaWV3cG9ydCA9IHZpZXdwb3J0XG4gICAgICB2aWV3cG9ydCA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgdmlld3BvcnQudGhpc0RlcCxcbiAgICAgICAgdmlld3BvcnQuY29udGV4dERlcCxcbiAgICAgICAgdmlld3BvcnQucHJvcERlcCxcbiAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgVklFV1BPUlQgPSBwcmV2Vmlld3BvcnQuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19WSUVXUE9SVF9XSURUSCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzJdKVxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX1ZJRVdQT1JUX0hFSUdIVCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzNdKVxuICAgICAgICAgIHJldHVybiBWSUVXUE9SVFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBzY2lzc29yX2JveDogcGFyc2VCb3goU19TQ0lTU09SX0JPWClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYkxvY2F0aW9ucyAob3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgc3RhdGljUHJvZ3JhbSA9XG4gICAgICB0eXBlb2Ygc3RhdGljT3B0aW9uc1tTX0ZSQUddID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIHN0YXRpY09wdGlvbnNbU19WRVJUXSA9PT0gJ3N0cmluZydcbiAgICBpZiAoc3RhdGljUHJvZ3JhbSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuZHluYW1pYykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnN0YXRpY1xuICAgICAgdmFyIHNBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoc3RhdGljQXR0cmlidXRlcylcbiAgICAgIGlmIChzQXR0cmlidXRlcy5sZW5ndGggPiAwICYmIHR5cGVvZiBzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzWzBdXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNoZWNrJDEodHlwZW9mIHN0YXRpY0F0dHJpYnV0ZXNbc0F0dHJpYnV0ZXNbaV1dID09PSAnbnVtYmVyJywgJ211c3Qgc3BlY2lmeSBhbGwgdmVydGV4IGF0dHJpYnV0ZSBsb2NhdGlvbnMgd2hlbiB1c2luZyB2YW9zJylcbiAgICAgICAgICBiaW5kaW5ncy5wdXNoKFtzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzW2ldXSB8IDAsIHNBdHRyaWJ1dGVzW2ldXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSAob3B0aW9ucywgZW52LCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNoYWRlciAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChzdGF0aWNPcHRpb25zW25hbWVdKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzaGFkZXJTdGF0ZS5zaGFkZXIoc2hhZGVyVHlwZVtuYW1lXSwgaWQsIGNoZWNrJDEuZ3Vlc3NDb21tYW5kKCkpXG4gICAgICAgIH0pXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaWRcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0LmlkID0gaWRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tuYW1lXVxuICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBzdHIgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGlkID0gc2NvcGUuZGVmKGVudi5zaGFyZWQuc3RyaW5ncywgJy5pZCgnLCBzdHIsICcpJylcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgICBlbnYuc2hhcmVkLnNoYWRlciwgJy5zaGFkZXIoJyxcbiAgICAgICAgICAgICAgc2hhZGVyVHlwZVtuYW1lXSwgJywnLFxuICAgICAgICAgICAgICBpZCwgJywnLFxuICAgICAgICAgICAgICBlbnYuY29tbWFuZCwgJyk7JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IHBhcnNlU2hhZGVyKFNfRlJBRylcbiAgICB2YXIgdmVydCA9IHBhcnNlU2hhZGVyKFNfVkVSVClcblxuICAgIHZhciBwcm9ncmFtID0gbnVsbFxuICAgIHZhciBwcm9nVmFyXG4gICAgaWYgKGlzU3RhdGljKGZyYWcpICYmIGlzU3RhdGljKHZlcnQpKSB7XG4gICAgICBwcm9ncmFtID0gc2hhZGVyU3RhdGUucHJvZ3JhbSh2ZXJ0LmlkLCBmcmFnLmlkLCBudWxsLCBhdHRyaWJMb2NhdGlvbnMpXG4gICAgICBwcm9nVmFyID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52LmxpbmsocHJvZ3JhbSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dWYXIgPSBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgIChmcmFnICYmIGZyYWcudGhpc0RlcCkgfHwgKHZlcnQgJiYgdmVydC50aGlzRGVwKSxcbiAgICAgICAgKGZyYWcgJiYgZnJhZy5jb250ZXh0RGVwKSB8fCAodmVydCAmJiB2ZXJ0LmNvbnRleHREZXApLFxuICAgICAgICAoZnJhZyAmJiBmcmFnLnByb3BEZXApIHx8ICh2ZXJ0ICYmIHZlcnQucHJvcERlcCksXG4gICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIFNIQURFUl9TVEFURSA9IGVudi5zaGFyZWQuc2hhZGVyXG4gICAgICAgICAgdmFyIGZyYWdJZFxuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBmcmFnLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfRlJBRylcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZlcnRJZFxuICAgICAgICAgIGlmICh2ZXJ0KSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSB2ZXJ0LmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfVkVSVClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByb2dEZWYgPSBTSEFERVJfU1RBVEUgKyAnLnByb2dyYW0oJyArIHZlcnRJZCArICcsJyArIGZyYWdJZFxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvZ0RlZiArPSAnLCcgKyBlbnYuY29tbWFuZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihwcm9nRGVmICsgJyknKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgdmVydDogdmVydCxcbiAgICAgIHByb2dWYXI6IHByb2dWYXIsXG4gICAgICBwcm9ncmFtOiBwcm9ncmFtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEcmF3IChvcHRpb25zLCBlbnYpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzICgpIHtcbiAgICAgIGlmIChTX0VMRU1FTlRTIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gc3RhdGljT3B0aW9uc1tTX0VMRU1FTlRTXVxuICAgICAgICBpZiAoaXNCdWZmZXJBcmdzKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudFN0YXRlLmdldEVsZW1lbnRzKGVsZW1lbnRTdGF0ZS5jcmVhdGUoZWxlbWVudHMsIHRydWUpKVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50U3RhdGUuZ2V0RWxlbWVudHMoZWxlbWVudHMpXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGVsZW1lbnRzLCAnaW52YWxpZCBlbGVtZW50cycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmxpbmsoZWxlbWVudHMpXG4gICAgICAgICAgICBlbnYuRUxFTUVOVFMgPSByZXN1bHRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgZW52LkVMRU1FTlRTID0gbnVsbFxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGVsZW1lbnRzXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoU19FTEVNRU5UUyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19FTEVNRU5UU11cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgICAgICAgdmFyIElTX0JVRkZFUl9BUkdTID0gc2hhcmVkLmlzQnVmZmVyQXJnc1xuICAgICAgICAgIHZhciBFTEVNRU5UX1NUQVRFID0gc2hhcmVkLmVsZW1lbnRzXG5cbiAgICAgICAgICB2YXIgZWxlbWVudERlZm4gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2NvcGUuZGVmKCdudWxsJylcbiAgICAgICAgICB2YXIgZWxlbWVudFN0cmVhbSA9IHNjb3BlLmRlZihJU19CVUZGRVJfQVJHUywgJygnLCBlbGVtZW50RGVmbiwgJyknKVxuXG4gICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChlbGVtZW50U3RyZWFtKVxuICAgICAgICAgICAgLnRoZW4oZWxlbWVudHMsICc9JywgRUxFTUVOVF9TVEFURSwgJy5jcmVhdGVTdHJlYW0oJywgZWxlbWVudERlZm4sICcpOycpXG4gICAgICAgICAgICAuZWxzZShlbGVtZW50cywgJz0nLCBFTEVNRU5UX1NUQVRFLCAnLmdldEVsZW1lbnRzKCcsIGVsZW1lbnREZWZuLCAnKTsnKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KGlmdGUuZWxzZSxcbiAgICAgICAgICAgICAgJyEnICsgZWxlbWVudERlZm4gKyAnfHwnICsgZWxlbWVudHMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnRzJylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc2NvcGUuZW50cnkoaWZ0ZSlcbiAgICAgICAgICBzY29wZS5leGl0KFxuICAgICAgICAgICAgZW52LmNvbmQoZWxlbWVudFN0cmVhbSlcbiAgICAgICAgICAgICAgLnRoZW4oRUxFTUVOVF9TVEFURSwgJy5kZXN0cm95U3RyZWFtKCcsIGVsZW1lbnRzLCAnKTsnKSlcblxuICAgICAgICAgIGVudi5FTEVNRU5UUyA9IGVsZW1lbnRzXG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBwYXJzZUVsZW1lbnRzKClcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlICgpIHtcbiAgICAgIGlmIChTX1BSSU1JVElWRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBwcmltaXRpdmUgPSBzdGF0aWNPcHRpb25zW1NfUFJJTUlUSVZFXVxuICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIocHJpbWl0aXZlLCBwcmltVHlwZXMsICdpbnZhbGlkIHByaW1pdHZlJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW1UeXBlc1twcmltaXRpdmVdXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKFNfUFJJTUlUSVZFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5QcmltaXRpdmUgPSBkeW5hbWljT3B0aW9uc1tTX1BSSU1JVElWRV1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5blByaW1pdGl2ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgUFJJTV9UWVBFUyA9IGVudi5jb25zdGFudHMucHJpbVR5cGVzXG4gICAgICAgICAgdmFyIHByaW0gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5QcmltaXRpdmUpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBwcmltICsgJyBpbiAnICsgUFJJTV9UWVBFUyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbWl0aXZlLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMocHJpbVR5cGVzKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoUFJJTV9UWVBFUywgJ1snLCBwcmltLCAnXScpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0YXRpYyhlbGVtZW50cykpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudHMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnByaW1UeXBlJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEdMX1RSSUFOR0xFUyQxXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgZWxlbWVudHMudGhpc0RlcCxcbiAgICAgICAgICAgIGVsZW1lbnRzLmNvbnRleHREZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5wcm9wRGVwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZW52LkVMRU1FTlRTXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcucHJpbVR5cGU6JywgR0xfVFJJQU5HTEVTJDEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW0gKHBhcmFtLCBpc09mZnNldCkge1xuICAgICAgaWYgKHBhcmFtIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGljT3B0aW9uc1twYXJhbV0gfCAwXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZCghaXNPZmZzZXQgfHwgdmFsdWUgPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGVudi5PRkZTRVQgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5blZhbHVlID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5WYWx1ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluVmFsdWUpXG4gICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICBlbnYuT0ZGU0VUID0gcmVzdWx0XG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICByZXN1bHQgKyAnPj0wJyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzT2Zmc2V0ICYmIGVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgZW52Lk9GRlNFVCA9ICcwJ1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBPRkZTRVQgPSBwYXJzZVBhcmFtKFNfT0ZGU0VULCB0cnVlKVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWZXJ0Q291bnQgKCkge1xuICAgICAgaWYgKFNfQ09VTlQgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgY291bnQgPSBzdGF0aWNPcHRpb25zW1NfQ09VTlRdIHwgMFxuICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgdHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyAmJiBjb3VudCA+PSAwLCAnaW52YWxpZCB2ZXJ0ZXggY291bnQnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb3VudFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChTX0NPVU5UIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5Db3VudCA9IGR5bmFtaWNPcHRpb25zW1NfQ09VTlRdXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5Db3VudCwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluQ291bnQpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAndHlwZW9mICcgKyByZXN1bHQgKyAnPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgIHJlc3VsdCArICc+PTAmJicgK1xuICAgICAgICAgICAgICByZXN1bHQgKyAnPT09KCcgKyByZXN1bHQgKyAnfDApJyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKE9GRlNFVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgIE9GRlNFVC50aGlzRGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5wcm9wRGVwLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgICBlbnYuRUxFTUVOVFMsICcudmVydENvdW50LScsIGVudi5PRkZTRVQpXG5cbiAgICAgICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArICc+PTAnLFxuICAgICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIHZlcnRleCBvZmZzZXQvZWxlbWVudCBidWZmZXIgdG9vIHNtYWxsJylcbiAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVudi5FTEVNRU5UUywgJy52ZXJ0Q291bnQnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXN1bHQuTUlTU0lORyA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICAgIGVsZW1lbnRzLnRoaXNEZXAgfHwgT0ZGU0VULnRoaXNEZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5jb250ZXh0RGVwIHx8IE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgZWxlbWVudHMucHJvcERlcCB8fCBPRkZTRVQucHJvcERlcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGVudi5FTEVNRU5UU1xuICAgICAgICAgICAgICBpZiAoZW52Lk9GRlNFVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcudmVydENvdW50LScsXG4gICAgICAgICAgICAgICAgICBlbnYuT0ZGU0VULCAnOi0xJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVsZW1lbnRzLCAnPycsIGVsZW1lbnRzLCAnLnZlcnRDb3VudDotMScpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyaWFibGUuRFlOQU1JQyA9IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiB2YXJpYWJsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBwcmltaXRpdmU6IHBhcnNlUHJpbWl0aXZlKCksXG4gICAgICBjb3VudDogcGFyc2VWZXJ0Q291bnQoKSxcbiAgICAgIGluc3RhbmNlczogcGFyc2VQYXJhbShTX0lOU1RBTkNFUywgZmFsc2UpLFxuICAgICAgb2Zmc2V0OiBPRkZTRVRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdMU3RhdGUgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBTVEFURSA9IHt9XG5cbiAgICBHTF9TVEFURV9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YXIgcGFyYW0gPSBwcm9wTmFtZShwcm9wKVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZVBhcmFtIChwYXJzZVN0YXRpYywgcGFyc2VEeW5hbWljKSB7XG4gICAgICAgIGlmIChwcm9wIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVN0YXRpYyhzdGF0aWNPcHRpb25zW3Byb3BdKVxuICAgICAgICAgIFNUQVRFW3BhcmFtXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW3Byb3BdXG4gICAgICAgICAgU1RBVEVbcGFyYW1dID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHluYW1pYyhlbnYsIHNjb3BlLCBlbnYuaW52b2tlKHNjb3BlLCBkeW4pKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU19DVUxMX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0JMRU5EX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0RJVEhFUjpcbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfU0NJU1NPUl9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19QT0xZR09OX09GRlNFVF9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfQUxQSEE6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfTUFTSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnYm9vbGVhbicsIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwiYm9vbGVhblwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGZsYWcgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0RFUFRIX0ZVTkM6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBjb21wYXJlRnVuY3MsICdpbnZhbGlkICcgKyBwcm9wLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVGdW5jc1t2YWx1ZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnIGluICcgKyBDT01QQVJFX0ZVTkNTLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoY29tcGFyZUZ1bmNzKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnXScpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19ERVBUSF9SQU5HRTpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVswXSA8PSB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAnZGVwdGggcmFuZ2UgaXMgMmQgYXJyYXknLFxuICAgICAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT0yJiYnICtcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJ1swXT09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnWzFdPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICdbMF08PScgKyB2YWx1ZSArICdbMV0nLFxuICAgICAgICAgICAgICAgICAgJ2RlcHRoIHJhbmdlIG11c3QgYmUgYSAyZCBhcnJheScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIFpfTkVBUiA9IHNjb3BlLmRlZignKycsIHZhbHVlLCAnWzBdJylcbiAgICAgICAgICAgICAgdmFyIFpfRkFSID0gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbMV0nKVxuICAgICAgICAgICAgICByZXR1cm4gW1pfTkVBUiwgWl9GQVJdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9GVU5DOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCAnYmxlbmQuZnVuYycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgc3JjUkdCID0gKCdzcmNSR0InIGluIHZhbHVlID8gdmFsdWUuc3JjUkdCIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgc3JjQWxwaGEgPSAoJ3NyY0FscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLnNyY0FscGhhIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gKCdkc3RSR0InIGluIHZhbHVlID8gdmFsdWUuZHN0UkdCIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICB2YXIgZHN0QWxwaGEgPSAoJ2RzdEFscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLmRzdEFscGhhIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoc3JjUkdCLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuc3JjUkdCJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihzcmNBbHBoYSwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLnNyY0FscGhhJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihkc3RSR0IsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5kc3RSR0InLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGRzdEFscGhhLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuZHN0QWxwaGEnLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgKGludmFsaWRCbGVuZENvbWJpbmF0aW9ucy5pbmRleE9mKHNyY1JHQiArICcsICcgKyBkc3RSR0IpID09PSAtMSksXG4gICAgICAgICAgICAgICAgJ3VuYWxsb3dlZCBibGVuZGluZyBjb21iaW5hdGlvbiAoc3JjUkdCLCBkc3RSR0IpID0gKCcgKyBzcmNSR0IgKyAnLCAnICsgZHN0UkdCICsgJyknLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJsZW5kRnVuY3Nbc3JjUkdCXSxcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW2RzdFJHQl0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNBbHBoYV0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tkc3RBbHBoYV1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgQkxFTkRfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmJsZW5kRnVuY3NcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgYmxlbmQgZnVuYywgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgICAnXCInLCBwcmVmaXgsIHN1ZmZpeCwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCB2YWx1ZSwgJy4nLCBwcmVmaXgsIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICc6JywgdmFsdWUsICcuJywgcHJlZml4KVxuXG4gICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jICsgJyBpbiAnICsgQkxFTkRfRlVOQ1MsXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wICsgJy4nICsgcHJlZml4ICsgc3VmZml4ICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGJsZW5kRnVuY3MpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNyY1JHQiA9IHJlYWQoJ3NyYycsICdSR0InKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gcmVhZCgnZHN0JywgJ1JHQicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIElOVkFMSURfQkxFTkRfQ09NQklOQVRJT05TID0gZW52LmNvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnNcblxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX0JMRU5EX0NPTUJJTkFUSU9OUyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnLmluZGV4T2YoJyArIHNyY1JHQiArICcrXCIsIFwiKycgKyBkc3RSR0IgKyAnKSA9PT0gLTEgJyxcbiAgICAgICAgICAgICAgICAgICd1bmFsbG93ZWQgYmxlbmRpbmcgY29tYmluYXRpb24gZm9yIChzcmNSR0IsIGRzdFJHQiknXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHZhciBTUkNfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHNyY1JHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgU1JDX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ3NyYycsICdBbHBoYScpLCAnXScpXG4gICAgICAgICAgICAgIHZhciBEU1RfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIGRzdFJHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgRFNUX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ2RzdCcsICdBbHBoYScpLCAnXScpXG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtTUkNfUkdCLCBEU1RfUkdCLCBTUkNfQUxQSEEsIERTVF9BTFBIQV1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0JMRU5EX0VRVUFUSU9OOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBibGVuZEVxdWF0aW9ucywgJ2ludmFsaWQgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnJnYiwgYmxlbmRFcXVhdGlvbnMsIHByb3AgKyAnLnJnYicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLmFscGhhLCBibGVuZEVxdWF0aW9ucywgcHJvcCArICcuYWxwaGEnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUucmdiXSxcbiAgICAgICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlLmFscGhhXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBibGVuZC5lcXVhdGlvbicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTlMgPSBlbnYuY29uc3RhbnRzLmJsZW5kRXF1YXRpb25zXG5cbiAgICAgICAgICAgICAgdmFyIFJHQiA9IHNjb3BlLmRlZigpXG4gICAgICAgICAgICAgIHZhciBBTFBIQSA9IHNjb3BlLmRlZigpXG5cbiAgICAgICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZCgndHlwZW9mICcsIHZhbHVlLCAnPT09XCJzdHJpbmdcIicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tQcm9wIChibG9jaywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyBpbiAnICsgQkxFTkRfRVFVQVRJT05TLFxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgbmFtZSArICcsIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhibGVuZEVxdWF0aW9ucykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLnRoZW4sIHByb3AsIHZhbHVlKVxuXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChpZnRlLmVsc2UsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcClcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5yZ2InLCB2YWx1ZSArICcucmdiJylcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5hbHBoYScsIHZhbHVlICsgJy5hbHBoYScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgICAgICAgIFJHQiwgJz0nLCBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICddOycpXG4gICAgICAgICAgICAgIGlmdGUuZWxzZShcbiAgICAgICAgICAgICAgICBSR0IsICc9JywgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhbHVlLCAnLnJnYl07JyxcbiAgICAgICAgICAgICAgICBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICcuYWxwaGFdOycpXG5cbiAgICAgICAgICAgICAgc2NvcGUoaWZ0ZSlcblxuICAgICAgICAgICAgICByZXR1cm4gW1JHQiwgQUxQSEFdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9DT0xPUjpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICdibGVuZC5jb2xvciBtdXN0IGJlIGEgNGQgYXJyYXknLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlW2ldXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBlbnYuc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgdmFsdWUgKyAnKSYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcubGVuZ3RoPT09NCcsXG4gICAgICAgICAgICAgICAgICAnYmxlbmQuY29sb3IgbXVzdCBiZSBhIDRkIGFycmF5JylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbJywgaSwgJ10nKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9NQVNLOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdudW1iZXInLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5tYXNrJylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZih2YWx1ZSwgJ3wwJylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRlVOQzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgY21wID0gdmFsdWUuY21wIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUucmVmIHx8IDBcbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSAnbWFzaycgaW4gdmFsdWUgPyB2YWx1ZS5tYXNrIDogLTFcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGNtcCwgY29tcGFyZUZ1bmNzLCBwcm9wICsgJy5jbXAnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShyZWYsICdudW1iZXInLCBwcm9wICsgJy5yZWYnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShtYXNrLCAnbnVtYmVyJywgcHJvcCArICcubWFzaycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbXBhcmVGdW5jc1tjbXBdLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBtYXNrXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQgKCkge1xuICAgICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5mdW5jJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlICsgJyYmdHlwZW9mICcsIHZhbHVlLCAnPT09XCJvYmplY3RcIicpXG4gICAgICAgICAgICAgICAgYXNzZXJ0KCchKFwiY21wXCIgaW4gJywgdmFsdWUsICcpfHwoJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCAnLmNtcCBpbiAnLCBDT01QQVJFX0ZVTkNTLCAnKScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHZhciBjbXAgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1wiY21wXCIgaW4gJywgdmFsdWUsXG4gICAgICAgICAgICAgICAgJz8nLCBDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnLmNtcF0nLFxuICAgICAgICAgICAgICAgICc6JywgR0xfS0VFUClcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5yZWZ8MCcpXG4gICAgICAgICAgICAgIHZhciBtYXNrID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICdcIm1hc2tcIiBpbiAnLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAnPycsIHZhbHVlLCAnLm1hc2t8MDotMScpXG4gICAgICAgICAgICAgIHJldHVybiBbY21wLCByZWYsIG1hc2tdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QRlJPTlQ6XG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QQkFDSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFpbCA9IHZhbHVlLmZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgICAgIHZhciB6ZmFpbCA9IHZhbHVlLnpmYWlsIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgenBhc3MgPSB2YWx1ZS56cGFzcyB8fCAna2VlcCdcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGZhaWwsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLmZhaWwnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHpmYWlsLCBzdGVuY2lsT3BzLCBwcm9wICsgJy56ZmFpbCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoenBhc3MsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLnpwYXNzJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsT3BzW2ZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbemZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbenBhc3NdXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIFNURU5DSUxfT1BTID0gZW52LmNvbnN0YW50cy5zdGVuY2lsT3BzXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICchKFwiJyArIG5hbWUgKyAnXCIgaW4gJyArIHZhbHVlICsgJyl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAnKCcgKyB2YWx1ZSArICcuJyArIG5hbWUgKyAnIGluICcgKyBTVEVOQ0lMX09QUyArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLicgKyBuYW1lICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKHN0ZW5jaWxPcHMpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgJ1wiJywgbmFtZSwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCBTVEVOQ0lMX09QUywgJ1snLCB2YWx1ZSwgJy4nLCBuYW1lLCAnXTonLFxuICAgICAgICAgICAgICAgICAgR0xfS0VFUClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICByZWFkKCdmYWlsJyksXG4gICAgICAgICAgICAgICAgcmVhZCgnemZhaWwnKSxcbiAgICAgICAgICAgICAgICByZWFkKCd6cGFzcycpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gdmFsdWUuZmFjdG9yIHwgMFxuICAgICAgICAgICAgICB2YXIgdW5pdHMgPSB2YWx1ZS51bml0cyB8IDBcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShmYWN0b3IsICdudW1iZXInLCBwYXJhbSArICcuZmFjdG9yJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodW5pdHMsICdudW1iZXInLCBwYXJhbSArICcudW5pdHMnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIFtmYWN0b3IsIHVuaXRzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3ApXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIEZBQ1RPUiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5mYWN0b3J8MCcpXG4gICAgICAgICAgICAgIHZhciBVTklUUyA9IHNjb3BlLmRlZih2YWx1ZSwgJy51bml0c3wwJylcblxuICAgICAgICAgICAgICByZXR1cm4gW0ZBQ1RPUiwgVU5JVFNdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19DVUxMX0ZBQ0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIGZhY2UgPSAwXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9GUk9OVFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnYmFjaycpIHtcbiAgICAgICAgICAgICAgICBmYWNlID0gR0xfQkFDS1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWZhY2UsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGZhY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiZnJvbnRcInx8JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImJhY2tcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjdWxsLmZhY2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHZhbHVlLCAnPT09XCJmcm9udFwiPycsIEdMX0ZST05ULCAnOicsIEdMX0JBQ0spXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19MSU5FX1dJRFRIOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPj0gbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBsaW1pdHMubGluZVdpZHRoRGltc1sxXSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBsaW5lIHdpZHRoLCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIGJldHdlZW4gJyArXG4gICAgICAgICAgICAgICAgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnIGFuZCAnICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMV0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPj0nICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJzw9JyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgbGluZSB3aWR0aCcpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19GUk9OVF9GQUNFOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcih2YWx1ZSwgb3JpZW50YXRpb25UeXBlLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBvcmllbnRhdGlvblR5cGVbdmFsdWVdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImN3XCJ8fCcgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJjY3dcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBmcm9udEZhY2UsIG11c3QgYmUgb25lIG9mIGN3LGNjdycpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUgKyAnPT09XCJjd1wiPycgKyBHTF9DVyArICc6JyArIEdMX0NDVylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0NPTE9SX01BU0s6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgJ2NvbG9yLm1hc2sgbXVzdCBiZSBsZW5ndGggNCBhcnJheScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhIXYgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT00JyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yLm1hc2snKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnISEnICsgdmFsdWUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TQU1QTEVfQ09WRVJBR0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlID0gJ3ZhbHVlJyBpbiB2YWx1ZSA/IHZhbHVlLnZhbHVlIDogMVxuICAgICAgICAgICAgICB2YXIgc2FtcGxlSW52ZXJ0ID0gISF2YWx1ZS5pbnZlcnRcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBzYW1wbGVWYWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBzYW1wbGVWYWx1ZSA+PSAwICYmIHNhbXBsZVZhbHVlIDw9IDEsXG4gICAgICAgICAgICAgICAgJ3NhbXBsZS5jb3ZlcmFnZS52YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZVZhbHVlLCBzYW1wbGVJbnZlcnRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBzYW1wbGUuY292ZXJhZ2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB2YXIgVkFMVUUgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1widmFsdWVcIiBpbiAnLCB2YWx1ZSwgJz8rJywgdmFsdWUsICcudmFsdWU6MScpXG4gICAgICAgICAgICAgIHZhciBJTlZFUlQgPSBzY29wZS5kZWYoJyEhJywgdmFsdWUsICcuaW52ZXJ0JylcbiAgICAgICAgICAgICAgcmV0dXJuIFtWQUxVRSwgSU5WRVJUXVxuICAgICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIFNUQVRFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVVuaWZvcm1zICh1bmlmb3JtcywgZW52KSB7XG4gICAgdmFyIHN0YXRpY1VuaWZvcm1zID0gdW5pZm9ybXMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNVbmlmb3JtcyA9IHVuaWZvcm1zLmR5bmFtaWNcblxuICAgIHZhciBVTklGT1JNUyA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhzdGF0aWNVbmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljVW5pZm9ybXNbbmFtZV1cbiAgICAgIHZhciByZXN1bHRcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcmVnbFR5cGUgPSB2YWx1ZS5fcmVnbFR5cGVcbiAgICAgICAgaWYgKHJlZ2xUeXBlID09PSAndGV4dHVyZTJkJyB8fFxuICAgICAgICAgICAgcmVnbFR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYubGluayh2YWx1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2xUeXBlID09PSAnZnJhbWVidWZmZXInIHx8XG4gICAgICAgICAgICAgICAgICAgcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKHZhbHVlLmNvbG9yLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAnbWlzc2luZyBjb2xvciBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBzZW50IHRvIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlLmNvbG9yWzBdKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgIHZhciBJVEVNID0gZW52Lmdsb2JhbC5kZWYoJ1snLFxuICAgICAgICAgICAgbG9vcCh2YWx1ZS5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWVbaV0gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlW2ldID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtpXVxuICAgICAgICAgICAgfSksICddJylcbiAgICAgICAgICByZXR1cm4gSVRFTVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgb3IgbWlzc2luZyBkYXRhIGZvciB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCInLCBlbnYuY29tbWFuZFN0cilcbiAgICAgIH1cbiAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlXG4gICAgICBVTklGT1JNU1tuYW1lXSA9IHJlc3VsdFxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljVW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNVbmlmb3Jtc1trZXldXG4gICAgICBVTklGT1JNU1trZXldID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIFVOSUZPUk1TXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMgKGF0dHJpYnV0ZXMsIGVudikge1xuICAgIHZhciBzdGF0aWNBdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmR5bmFtaWNcblxuICAgIHZhciBhdHRyaWJ1dGVEZWZzID0ge31cblxuICAgIE9iamVjdC5rZXlzKHN0YXRpY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChhdHRyaWJ1dGUpXG5cbiAgICAgIHZhciByZWNvcmQgPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIGlmIChpc0J1ZmZlckFyZ3ModmFsdWUpKSB7XG4gICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoXG4gICAgICAgICAgYnVmZmVyU3RhdGUuY3JlYXRlKHZhbHVlLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIodmFsdWUpXG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICByZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSxcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICBpZiAoJ2NvbnN0YW50JyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbnN0YW50ID0gdmFsdWUuY29uc3RhbnRcbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSAnbnVsbCdcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9DT05TVEFOVFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdGFudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmVjb3JkLnggPSBjb25zdGFudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKGNvbnN0YW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbnN0YW50Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb25zdGFudC5sZW5ndGggPD0gNCxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBjb25zdGFudCBmb3IgYXR0cmlidXRlICcgKyBhdHRyaWJ1dGUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgY29uc3RhbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZWNvcmRbY10gPSBjb25zdGFudFtpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQnVmZmVyQXJncyh2YWx1ZS5idWZmZXIpKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihcbiAgICAgICAgICAgICAgICBidWZmZXJTdGF0ZS5jcmVhdGUodmFsdWUuYnVmZmVyLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHZhbHVlLmJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWJ1ZmZlciwgJ21pc3NpbmcgYnVmZmVyIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2YWx1ZS5vZmZzZXQgfCAwXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQob2Zmc2V0ID49IDAsXG4gICAgICAgICAgICAgICdpbnZhbGlkIG9mZnNldCBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdmFsdWUuc3RyaWRlIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHN0cmlkZSA+PSAwICYmIHN0cmlkZSA8IDI1NixcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc3RyaWRlIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBtdXN0IGJlIGludGVnZXIgYmV0d2VlZW4gWzAsIDI1NV0nLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgdmFyIHNpemUgPSB2YWx1ZS5zaXplIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEoJ3NpemUnIGluIHZhbHVlKSB8fCAoc2l6ZSA+IDAgJiYgc2l6ZSA8PSA0KSxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc2l6ZSBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgbXVzdCBiZSAxLDIsMyw0JywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gISF2YWx1ZS5ub3JtYWxpemVkXG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gMFxuICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSwgZ2xUeXBlcyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHR5cGUgPSBnbFR5cGVzW3ZhbHVlLnR5cGVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gdmFsdWUuZGl2aXNvciB8IDBcbiAgICAgICAgICAgIGlmICgnZGl2aXNvcicgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPT09IDAgfHwgZXh0SW5zdGFuY2luZyxcbiAgICAgICAgICAgICAgICAnY2Fubm90IHNwZWNpZnkgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgaW5zdGFuY2luZyBub3Qgc3VwcG9ydGVkJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChkaXZpc29yID49IDAsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBlbnYuY29tbWFuZFN0clxuXG4gICAgICAgICAgICAgIHZhciBWQUxJRF9LRVlTID0gW1xuICAgICAgICAgICAgICAgICdidWZmZXInLFxuICAgICAgICAgICAgICAgICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICdkaXZpc29yJyxcbiAgICAgICAgICAgICAgICAnbm9ybWFsaXplZCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICAgICAgICdzaXplJyxcbiAgICAgICAgICAgICAgICAnc3RyaWRlJ1xuICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBWQUxJRF9LRVlTLmluZGV4T2YocHJvcCkgPj0gMCxcbiAgICAgICAgICAgICAgICAgICd1bmtub3duIHBhcmFtZXRlciBcIicgKyBwcm9wICsgJ1wiIGZvciBhdHRyaWJ1dGUgcG9pbnRlciBcIicgKyBhdHRyaWJ1dGUgKyAnXCIgKHZhbGlkIHBhcmFtZXRlcnMgYXJlICcgKyBWQUxJRF9LRVlTICsgJyknLFxuICAgICAgICAgICAgICAgICAgY29tbWFuZClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgICAgICByZWNvcmQuc2l6ZSA9IHNpemVcbiAgICAgICAgICAgIHJlY29yZC5ub3JtYWxpemVkID0gbm9ybWFsaXplZFxuICAgICAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5kdHlwZVxuICAgICAgICAgICAgcmVjb3JkLm9mZnNldCA9IG9mZnNldFxuICAgICAgICAgICAgcmVjb3JkLnN0cmlkZSA9IHN0cmlkZVxuICAgICAgICAgICAgcmVjb3JkLmRpdmlzb3IgPSBkaXZpc29yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZURlZnNbYXR0cmlidXRlXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gZW52LmF0dHJpYkNhY2hlXG4gICAgICAgIGlmIChpZCBpbiBjYWNoZSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZVtpZF1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzU3RyZWFtOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHJlY29yZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSByZWNvcmRba2V5XVxuICAgICAgICB9KVxuICAgICAgICBpZiAocmVjb3JkLmJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC5idWZmZXIgPSBlbnYubGluayhyZWNvcmQuYnVmZmVyKVxuICAgICAgICAgIHJlc3VsdC50eXBlID0gcmVzdWx0LnR5cGUgfHwgKHJlc3VsdC5idWZmZXIgKyAnLmR0eXBlJylcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtpZF0gPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNBdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kQXR0cmlidXRlQ29kZSAoZW52LCBibG9jaykge1xuICAgICAgICB2YXIgVkFMVUUgPSBlbnYuaW52b2tlKGJsb2NrLCBkeW4pXG5cbiAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICAgICAgdmFyIGNvbnN0YW50cyA9IGVudi5jb25zdGFudHNcblxuICAgICAgICB2YXIgSVNfQlVGRkVSX0FSR1MgPSBzaGFyZWQuaXNCdWZmZXJBcmdzXG4gICAgICAgIHZhciBCVUZGRVJfU1RBVEUgPSBzaGFyZWQuYnVmZmVyXG5cbiAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uIG9uIGF0dHJpYnV0ZVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KGJsb2NrLFxuICAgICAgICAgICAgVkFMVUUgKyAnJiYodHlwZW9mICcgKyBWQUxVRSArICc9PT1cIm9iamVjdFwifHx0eXBlb2YgJyArXG4gICAgICAgICAgICBWQUxVRSArICc9PT1cImZ1bmN0aW9uXCIpJiYoJyArXG4gICAgICAgICAgICBJU19CVUZGRVJfQVJHUyArICcoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJy5idWZmZXIpfHwnICtcbiAgICAgICAgICAgIElTX0JVRkZFUl9BUkdTICsgJygnICsgVkFMVUUgKyAnLmJ1ZmZlcil8fCcgK1xuICAgICAgICAgICAgJyhcImNvbnN0YW50XCIgaW4gJyArIFZBTFVFICtcbiAgICAgICAgICAgICcmJih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudD09PVwibnVtYmVyXCJ8fCcgK1xuICAgICAgICAgICAgc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgVkFMVUUgKyAnLmNvbnN0YW50KSkpKScsXG4gICAgICAgICAgICAnaW52YWxpZCBkeW5hbWljIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGFsbG9jYXRlIG5hbWVzIGZvciByZXN1bHRcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBpc1N0cmVhbTogYmxvY2suZGVmKGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0UmVjb3JkID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpXG4gICAgICAgIGRlZmF1bHRSZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0UmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGJsb2NrLmRlZignJyArIGRlZmF1bHRSZWNvcmRba2V5XSlcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgQlVGRkVSID0gcmVzdWx0LmJ1ZmZlclxuICAgICAgICB2YXIgVFlQRSA9IHJlc3VsdC50eXBlXG4gICAgICAgIGJsb2NrKFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJykpeycsXG4gICAgICAgICAgcmVzdWx0LmlzU3RyZWFtLCAnPXRydWU7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmNyZWF0ZVN0cmVhbSgnLCBHTF9BUlJBWV9CVUZGRVIkMiwgJywnLCBWQUxVRSwgJyk7JyxcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxuICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuZ2V0QnVmZmVyKCcsIFZBTFVFLCAnKTsnLFxuICAgICAgICAgICdpZignLCBCVUZGRVIsICcpeycsXG4gICAgICAgICAgVFlQRSwgJz0nLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICAnfWVsc2UgaWYoXCJjb25zdGFudFwiIGluICcsIFZBTFVFLCAnKXsnLFxuICAgICAgICAgIHJlc3VsdC5zdGF0ZSwgJz0nLCBBVFRSSUJfU1RBVEVfQ09OU1RBTlQsICc7JyxcbiAgICAgICAgICAnaWYodHlwZW9mICcgKyBWQUxVRSArICcuY29uc3RhbnQgPT09IFwibnVtYmVyXCIpeycsXG4gICAgICAgICAgcmVzdWx0W0NVVEVfQ09NUE9ORU5UU1swXV0sICc9JywgVkFMVUUsICcuY29uc3RhbnQ7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0W25dXG4gICAgICAgICAgfSkuam9pbignPScpLCAnPTA7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gKyAnPScgKyBWQUxVRSArICcuY29uc3RhbnQubGVuZ3RoPicgKyBpICtcbiAgICAgICAgICAgICAgJz8nICsgVkFMVUUgKyAnLmNvbnN0YW50WycgKyBpICsgJ106MDsnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkuam9pbignJyksXG4gICAgICAgICAgJ319ZWxzZXsnLFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJy5idWZmZXIpKXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsIFZBTFVFLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmdldEJ1ZmZlcignLCBWQUxVRSwgJy5idWZmZXIpOycsXG4gICAgICAgICAgJ30nLFxuICAgICAgICAgIFRZUEUsICc9XCJ0eXBlXCIgaW4gJywgVkFMVUUsICc/JyxcbiAgICAgICAgICBjb25zdGFudHMuZ2xUeXBlcywgJ1snLCBWQUxVRSwgJy50eXBlXTonLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICByZXN1bHQubm9ybWFsaXplZCwgJz0hIScsIFZBTFVFLCAnLm5vcm1hbGl6ZWQ7JylcbiAgICAgICAgZnVuY3Rpb24gZW1pdFJlYWRSZWNvcmQgKG5hbWUpIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbbmFtZV0sICc9JywgVkFMVUUsICcuJywgbmFtZSwgJ3wwOycpXG4gICAgICAgIH1cbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3NpemUnKVxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnb2Zmc2V0JylcbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3N0cmlkZScpXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdkaXZpc29yJylcblxuICAgICAgICBibG9jaygnfX0nKVxuXG4gICAgICAgIGJsb2NrLmV4aXQoXG4gICAgICAgICAgJ2lmKCcsIHJlc3VsdC5pc1N0cmVhbSwgJyl7JyxcbiAgICAgICAgICBCVUZGRVJfU1RBVEUsICcuZGVzdHJveVN0cmVhbSgnLCBCVUZGRVIsICcpOycsXG4gICAgICAgICAgJ30nKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlRGVmc1thdHRyaWJ1dGVdID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBhcHBlbmRBdHRyaWJ1dGVDb2RlKVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXR0cmlidXRlRGVmc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWQU8gKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcbiAgICBpZiAoU19WQU8gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgdmFyIHZhbyA9IHN0YXRpY09wdGlvbnNbU19WQU9dXG4gICAgICBpZiAodmFvICE9PSBudWxsICYmIGF0dHJpYnV0ZVN0YXRlLmdldFZBTyh2YW8pID09PSBudWxsKSB7XG4gICAgICAgIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmNyZWF0ZVZBTyh2YW8pXG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIHJldHVybiBlbnYubGluayhhdHRyaWJ1dGVTdGF0ZS5nZXRWQU8odmFvKSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChTX1ZBTyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW1NfVkFPXVxuICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIHZhb1JlZiA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbnYuc2hhcmVkLnZhbyArICcuZ2V0VkFPKCcgKyB2YW9SZWYgKyAnKScpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb250ZXh0IChjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRpY0NvbnRleHQgPSBjb250ZXh0LnN0YXRpY1xuICAgIHZhciBkeW5hbWljQ29udGV4dCA9IGNvbnRleHQuZHluYW1pY1xuICAgIHZhciByZXN1bHQgPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoc3RhdGljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQ29udGV4dFtuYW1lXVxuICAgICAgcmVzdWx0W25hbWVdID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNDb250ZXh0W25hbWVdXG4gICAgICByZXN1bHRbbmFtZV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIEtFWV9OQU1FUyA9IFtcbiAgICAgICAgU19GUkFNRUJVRkZFUixcbiAgICAgICAgU19WRVJULFxuICAgICAgICBTX0ZSQUcsXG4gICAgICAgIFNfRUxFTUVOVFMsXG4gICAgICAgIFNfUFJJTUlUSVZFLFxuICAgICAgICBTX09GRlNFVCxcbiAgICAgICAgU19DT1VOVCxcbiAgICAgICAgU19JTlNUQU5DRVMsXG4gICAgICAgIFNfUFJPRklMRSxcbiAgICAgICAgU19WQU9cbiAgICAgIF0uY29uY2F0KEdMX1NUQVRFX05BTUVTKVxuXG4gICAgICBmdW5jdGlvbiBjaGVja0tleXMgKGRpY3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgS0VZX05BTUVTLmluZGV4T2Yoa2V5KSA+PSAwLFxuICAgICAgICAgICAgJ3Vua25vd24gcGFyYW1ldGVyIFwiJyArIGtleSArICdcIicsXG4gICAgICAgICAgICBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY2hlY2tLZXlzKHN0YXRpY09wdGlvbnMpXG4gICAgICBjaGVja0tleXMoZHluYW1pY09wdGlvbnMpXG4gICAgfSlcblxuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSBwYXJzZUF0dHJpYkxvY2F0aW9ucyhvcHRpb25zLCBhdHRyaWJ1dGVzKVxuXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gcGFyc2VGcmFtZWJ1ZmZlcihvcHRpb25zLCBlbnYpXG4gICAgdmFyIHZpZXdwb3J0QW5kU2Npc3NvciA9IHBhcnNlVmlld3BvcnRTY2lzc29yKG9wdGlvbnMsIGZyYW1lYnVmZmVyLCBlbnYpXG4gICAgdmFyIGRyYXcgPSBwYXJzZURyYXcob3B0aW9ucywgZW52KVxuICAgIHZhciBzdGF0ZSA9IHBhcnNlR0xTdGF0ZShvcHRpb25zLCBlbnYpXG4gICAgdmFyIHNoYWRlciA9IHBhcnNlUHJvZ3JhbShvcHRpb25zLCBlbnYsIGF0dHJpYkxvY2F0aW9ucylcblxuICAgIGZ1bmN0aW9uIGNvcHlCb3ggKG5hbWUpIHtcbiAgICAgIHZhciBkZWZuID0gdmlld3BvcnRBbmRTY2lzc29yW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBzdGF0ZVtuYW1lXSA9IGRlZm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29weUJveChTX1ZJRVdQT1JUKVxuICAgIGNvcHlCb3gocHJvcE5hbWUoU19TQ0lTU09SX0JPWCkpXG5cbiAgICB2YXIgZGlydHkgPSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoID4gMFxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZyYW1lYnVmZmVyOiBmcmFtZWJ1ZmZlcixcbiAgICAgIGRyYXc6IGRyYXcsXG4gICAgICBzaGFkZXI6IHNoYWRlcixcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgIHNjb3BlVkFPOiBudWxsLFxuICAgICAgZHJhd1ZBTzogbnVsbCxcbiAgICAgIHVzZVZBTzogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH1cblxuICAgIHJlc3VsdC5wcm9maWxlID0gcGFyc2VQcm9maWxlKG9wdGlvbnMsIGVudilcbiAgICByZXN1bHQudW5pZm9ybXMgPSBwYXJzZVVuaWZvcm1zKHVuaWZvcm1zLCBlbnYpXG4gICAgcmVzdWx0LmRyYXdWQU8gPSByZXN1bHQuc2NvcGVWQU8gPSBwYXJzZVZBTyhvcHRpb25zLCBlbnYpXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBjaGVjayBpZiB3ZSBjYW4gc3RhdGljYWxseSBhbGxvY2F0ZSBhIHZlcnRleCBhcnJheSBvYmplY3QgZm9yIHRoaXMgcHJvZ3JhbVxuICAgIGlmICghcmVzdWx0LmRyYXdWQU8gJiYgc2hhZGVyLnByb2dyYW0gJiYgIWF0dHJpYkxvY2F0aW9ucyAmJiBleHRlbnNpb25zLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMpIHtcbiAgICAgIHZhciB1c2VWQU8gPSB0cnVlXG4gICAgICB2YXIgc3RhdGljQmluZGluZ3MgPSBzaGFkZXIucHJvZ3JhbS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZXMuc3RhdGljW2F0dHJdXG4gICAgICAgIHVzZVZBTyA9IHVzZVZBTyAmJiAhIWJpbmRpbmdcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdcbiAgICAgIH0pXG4gICAgICBpZiAodXNlVkFPICYmIHN0YXRpY0JpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmdldFZBTyhhdHRyaWJ1dGVTdGF0ZS5jcmVhdGVWQU8oc3RhdGljQmluZGluZ3MpKVxuICAgICAgICByZXN1bHQuZHJhd1ZBTyA9IG5ldyBEZWNsYXJhdGlvbihudWxsLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHJldHVybiBlbnYubGluayh2YW8pXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGVudilcbiAgICB9XG4gICAgcmVzdWx0LmNvbnRleHQgPSBwYXJzZUNvbnRleHQoY29udGV4dCwgZW52KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09NTU9OIFVQREFURSBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBlbWl0Q29udGV4dCAoZW52LCBzY29wZSwgY29udGV4dCkge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuXG4gICAgdmFyIGNvbnRleHRFbnRlciA9IGVudi5zY29wZSgpXG5cbiAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzY29wZS5zYXZlKENPTlRFWFQsICcuJyArIG5hbWUpXG4gICAgICB2YXIgZGVmbiA9IGNvbnRleHRbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz1bJywgdmFsdWUuam9pbigpLCAnXTsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzY29wZShjb250ZXh0RW50ZXIpXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENPTU1PTiBEUkFXSU5HIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXRQb2xsRnJhbWVidWZmZXIgKGVudiwgc2NvcGUsIGZyYW1lYnVmZmVyLCBza2lwQ2hlY2spIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsXG4gICAgdmFyIEZSQU1FQlVGRkVSX1NUQVRFID0gc2hhcmVkLmZyYW1lYnVmZmVyXG4gICAgdmFyIEVYVF9EUkFXX0JVRkZFUlNcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIEVYVF9EUkFXX0JVRkZFUlMgPSBzY29wZS5kZWYoc2hhcmVkLmV4dGVuc2lvbnMsICcud2ViZ2xfZHJhd19idWZmZXJzJylcbiAgICB9XG5cbiAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50c1xuXG4gICAgdmFyIERSQVdfQlVGRkVSUyA9IGNvbnN0YW50cy5kcmF3QnVmZmVyXG4gICAgdmFyIEJBQ0tfQlVGRkVSID0gY29uc3RhbnRzLmJhY2tCdWZmZXJcblxuICAgIHZhciBORVhUXG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBORVhUID0gZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIE5FWFQgPSBzY29wZS5kZWYoRlJBTUVCVUZGRVJfU1RBVEUsICcubmV4dCcpXG4gICAgfVxuXG4gICAgaWYgKCFza2lwQ2hlY2spIHtcbiAgICAgIHNjb3BlKCdpZignLCBORVhULCAnIT09JywgRlJBTUVCVUZGRVJfU1RBVEUsICcuY3VyKXsnKVxuICAgIH1cbiAgICBzY29wZShcbiAgICAgICdpZignLCBORVhULCAnKXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsJywgTkVYVCwgJy5mcmFtZWJ1ZmZlcik7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLFxuICAgICAgICBEUkFXX0JVRkZFUlMsICdbJywgTkVYVCwgJy5jb2xvckF0dGFjaG1lbnRzLmxlbmd0aF0pOycpXG4gICAgfVxuICAgIHNjb3BlKCd9ZWxzZXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsbnVsbCk7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLCBCQUNLX0JVRkZFUiwgJyk7JylcbiAgICB9XG4gICAgc2NvcGUoXG4gICAgICAnfScsXG4gICAgICBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXI9JywgTkVYVCwgJzsnKVxuICAgIGlmICghc2tpcENoZWNrKSB7XG4gICAgICBzY29wZSgnfScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFBvbGxTdGF0ZSAoZW52LCBzY29wZSwgYXJncykge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG5cbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBORVhUX1ZBUlMgPSBlbnYubmV4dFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgTkVYVF9TVEFURSA9IHNoYXJlZC5uZXh0XG5cbiAgICB2YXIgYmxvY2sgPSBlbnYuY29uZChDVVJSRU5UX1NUQVRFLCAnLmRpcnR5JylcblxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbSA9IHByb3BOYW1lKHByb3ApXG4gICAgICBpZiAocGFyYW0gaW4gYXJncy5zdGF0ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIE5FWFQsIENVUlJFTlRcbiAgICAgIGlmIChwYXJhbSBpbiBORVhUX1ZBUlMpIHtcbiAgICAgICAgTkVYVCA9IE5FWFRfVkFSU1twYXJhbV1cbiAgICAgICAgQ1VSUkVOVCA9IENVUlJFTlRfVkFSU1twYXJhbV1cbiAgICAgICAgdmFyIHBhcnRzID0gbG9vcChjdXJyZW50U3RhdGVbcGFyYW1dLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKE5FWFQsICdbJywgaSwgJ10nKVxuICAgICAgICB9KVxuICAgICAgICBibG9jayhlbnYuY29uZChwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcCArICchPT0nICsgQ1VSUkVOVCArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkuam9pbignfHwnKSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgcGFydHMsICcpOycsXG4gICAgICAgICAgICBwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHBcbiAgICAgICAgICAgIH0pLmpvaW4oJzsnKSwgJzsnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE5FWFQgPSBibG9jay5kZWYoTkVYVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgYmxvY2soaWZ0ZSlcbiAgICAgICAgaWYgKHBhcmFtIGluIEdMX0ZMQUdTKSB7XG4gICAgICAgICAgaWZ0ZShcbiAgICAgICAgICAgIGVudi5jb25kKE5FWFQpXG4gICAgICAgICAgICAgIC50aGVuKEdMLCAnLmVuYWJsZSgnLCBHTF9GTEFHU1twYXJhbV0sICcpOycpXG4gICAgICAgICAgICAgIC5lbHNlKEdMLCAnLmRpc2FibGUoJywgR0xfRkxBR1NbcGFyYW1dLCAnKTsnKSxcbiAgICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgTkVYVCwgJzsnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmdGUoXG4gICAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIE5FWFQsICcpOycsXG4gICAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYmxvY2soQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT1mYWxzZTsnKVxuICAgIH1cbiAgICBzY29wZShibG9jaylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRTZXRPcHRpb25zIChlbnYsIHNjb3BlLCBvcHRpb25zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMob3B0aW9ucykpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZGVmbiA9IG9wdGlvbnNbcGFyYW1dXG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIoZGVmbikpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgdmFyaWFibGUgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEdMX0ZMQUdTW3BhcmFtXSkge1xuICAgICAgICB2YXIgZmxhZyA9IEdMX0ZMQUdTW3BhcmFtXVxuICAgICAgICBpZiAoaXNTdGF0aWMoZGVmbikpIHtcbiAgICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLmVuYWJsZSgnLCBmbGFnLCAnKTsnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKGVudi5jb25kKHZhcmlhYmxlKVxuICAgICAgICAgICAgLnRoZW4oR0wsICcuZW5hYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgICAuZWxzZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpKVxuICAgICAgICB9XG4gICAgICAgIHNjb3BlKENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgdmFyaWFibGUsICc7JylcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFyaWFibGUpKSB7XG4gICAgICAgIHZhciBDVVJSRU5UID0gQ1VSUkVOVF9WQVJTW3BhcmFtXVxuICAgICAgICBzY29wZShcbiAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIHZhcmlhYmxlLCAnKTsnLFxuICAgICAgICAgIHZhcmlhYmxlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHZcbiAgICAgICAgICB9KS5qb2luKCc7JyksICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgdmFyaWFibGUsICcpOycsXG4gICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25zIChlbnYsIHNjb3BlKSB7XG4gICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgIGVudi5pbnN0YW5jaW5nID0gc2NvcGUuZGVmKFxuICAgICAgICBlbnYuc2hhcmVkLmV4dGVuc2lvbnMsICcuYW5nbGVfaW5zdGFuY2VkX2FycmF5cycpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFByb2ZpbGUgKGVudiwgc2NvcGUsIGFyZ3MsIHVzZVNjb3BlLCBpbmNyZW1lbnRDb3VudGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICB2YXIgU1RBVFMgPSBlbnYuc3RhdHNcbiAgICB2YXIgQ1VSUkVOVF9TVEFURSA9IHNoYXJlZC5jdXJyZW50XG4gICAgdmFyIFRJTUVSID0gc2hhcmVkLnRpbWVyXG4gICAgdmFyIHByb2ZpbGVBcmcgPSBhcmdzLnByb2ZpbGVcblxuICAgIGZ1bmN0aW9uIHBlcmZDb3VudGVyICgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnRGF0ZS5ub3coKSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2Uubm93KCknXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENQVV9TVEFSVCwgUVVFUllfQ09VTlRFUlxuICAgIGZ1bmN0aW9uIGVtaXRQcm9maWxlU3RhcnQgKGJsb2NrKSB7XG4gICAgICBDUFVfU1RBUlQgPSBzY29wZS5kZWYoKVxuICAgICAgYmxvY2soQ1BVX1NUQVJULCAnPScsIHBlcmZDb3VudGVyKCksICc7JylcbiAgICAgIGlmICh0eXBlb2YgaW5jcmVtZW50Q291bnRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrPScsIGluY3JlbWVudENvdW50ZXIsICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrKFNUQVRTLCAnLmNvdW50Kys7JylcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBpZiAodXNlU2NvcGUpIHtcbiAgICAgICAgICBRVUVSWV9DT1VOVEVSID0gc2NvcGUuZGVmKClcbiAgICAgICAgICBibG9jayhRVUVSWV9DT1VOVEVSLCAnPScsIFRJTUVSLCAnLmdldE51bVBlbmRpbmdRdWVyaWVzKCk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5iZWdpblF1ZXJ5KCcsIFNUQVRTLCAnKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVFbmQgKGJsb2NrKSB7XG4gICAgICBibG9jayhTVEFUUywgJy5jcHVUaW1lKz0nLCBwZXJmQ291bnRlcigpLCAnLScsIENQVV9TVEFSVCwgJzsnKVxuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGlmICh1c2VTY29wZSkge1xuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLnB1c2hTY29wZVN0YXRzKCcsXG4gICAgICAgICAgICBRVUVSWV9DT1VOVEVSLCAnLCcsXG4gICAgICAgICAgICBUSU1FUiwgJy5nZXROdW1QZW5kaW5nUXVlcmllcygpLCcsXG4gICAgICAgICAgICBTVEFUUywgJyk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5lbmRRdWVyeSgpOycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY29wZVByb2ZpbGUgKHZhbHVlKSB7XG4gICAgICB2YXIgcHJldiA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKVxuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlPScsIHZhbHVlLCAnOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcucHJvZmlsZT0nLCBwcmV2LCAnOycpXG4gICAgfVxuXG4gICAgdmFyIFVTRV9QUk9GSUxFXG4gICAgaWYgKHByb2ZpbGVBcmcpIHtcbiAgICAgIGlmIChpc1N0YXRpYyhwcm9maWxlQXJnKSkge1xuICAgICAgICBpZiAocHJvZmlsZUFyZy5lbmFibGUpIHtcbiAgICAgICAgICBlbWl0UHJvZmlsZVN0YXJ0KHNjb3BlKVxuICAgICAgICAgIGVtaXRQcm9maWxlRW5kKHNjb3BlLmV4aXQpXG4gICAgICAgICAgc2NvcGVQcm9maWxlKCd0cnVlJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZVByb2ZpbGUoJ2ZhbHNlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFVTRV9QUk9GSUxFID0gcHJvZmlsZUFyZy5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHNjb3BlUHJvZmlsZShVU0VfUFJPRklMRSlcbiAgICB9IGVsc2Uge1xuICAgICAgVVNFX1BST0ZJTEUgPSBzY29wZS5kZWYoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlJylcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlU3RhcnQoc3RhcnQpXG4gICAgc2NvcGUoJ2lmKCcsIFVTRV9QUk9GSUxFLCAnKXsnLCBzdGFydCwgJ30nKVxuICAgIHZhciBlbmQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlRW5kKGVuZClcbiAgICBzY29wZS5leGl0KCdpZignLCBVU0VfUFJPRklMRSwgJyl7JywgZW5kLCAnfScpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QXR0cmlidXRlcyAoZW52LCBzY29wZSwgYXJncywgYXR0cmlidXRlcywgZmlsdGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcblxuICAgIGZ1bmN0aW9uIHR5cGVMZW5ndGggKHgpIHtcbiAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgIHJldHVybiAyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgcmV0dXJuIDNcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICByZXR1cm4gNFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdEJpbmRBdHRyaWJ1dGUgKEFUVFJJQlVURSwgc2l6ZSwgcmVjb3JkKSB7XG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgICAgdmFyIExPQ0FUSU9OID0gc2NvcGUuZGVmKEFUVFJJQlVURSwgJy5sb2NhdGlvbicpXG4gICAgICB2YXIgQklORElORyA9IHNjb3BlLmRlZihzaGFyZWQuYXR0cmlidXRlcywgJ1snLCBMT0NBVElPTiwgJ10nKVxuXG4gICAgICB2YXIgU1RBVEUgPSByZWNvcmQuc3RhdGVcbiAgICAgIHZhciBCVUZGRVIgPSByZWNvcmQuYnVmZmVyXG4gICAgICB2YXIgQ09OU1RfQ09NUE9ORU5UUyA9IFtcbiAgICAgICAgcmVjb3JkLngsXG4gICAgICAgIHJlY29yZC55LFxuICAgICAgICByZWNvcmQueixcbiAgICAgICAgcmVjb3JkLndcbiAgICAgIF1cblxuICAgICAgdmFyIENPTU1PTl9LRVlTID0gW1xuICAgICAgICAnYnVmZmVyJyxcbiAgICAgICAgJ25vcm1hbGl6ZWQnLFxuICAgICAgICAnb2Zmc2V0JyxcbiAgICAgICAgJ3N0cmlkZSdcbiAgICAgIF1cblxuICAgICAgZnVuY3Rpb24gZW1pdEJ1ZmZlciAoKSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZighJywgQklORElORywgJy5idWZmZXIpeycsXG4gICAgICAgICAgR0wsICcuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoJywgTE9DQVRJT04sICcpO30nKVxuXG4gICAgICAgIHZhciBUWVBFID0gcmVjb3JkLnR5cGVcbiAgICAgICAgdmFyIFNJWkVcbiAgICAgICAgaWYgKCFyZWNvcmQuc2l6ZSkge1xuICAgICAgICAgIFNJWkUgPSBzaXplXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgU0laRSA9IHNjb3BlLmRlZihyZWNvcmQuc2l6ZSwgJ3x8Jywgc2l6ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlKCdpZignLFxuICAgICAgICAgIEJJTkRJTkcsICcudHlwZSE9PScsIFRZUEUsICd8fCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplIT09JywgU0laRSwgJ3x8JyxcbiAgICAgICAgICBDT01NT05fS0VZUy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBrZXkgKyAnIT09JyArIHJlY29yZFtrZXldXG4gICAgICAgICAgfSkuam9pbignfHwnKSxcbiAgICAgICAgICAnKXsnLFxuICAgICAgICAgIEdMLCAnLmJpbmRCdWZmZXIoJywgR0xfQVJSQVlfQlVGRkVSJDIsICcsJywgQlVGRkVSLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWJQb2ludGVyKCcsIFtcbiAgICAgICAgICAgIExPQ0FUSU9OLFxuICAgICAgICAgICAgU0laRSxcbiAgICAgICAgICAgIFRZUEUsXG4gICAgICAgICAgICByZWNvcmQubm9ybWFsaXplZCxcbiAgICAgICAgICAgIHJlY29yZC5zdHJpZGUsXG4gICAgICAgICAgICByZWNvcmQub2Zmc2V0XG4gICAgICAgICAgXSwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnR5cGU9JywgVFlQRSwgJzsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuc2l6ZT0nLCBTSVpFLCAnOycsXG4gICAgICAgICAgQ09NTU9OX0tFWVMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBCSU5ESU5HICsgJy4nICsga2V5ICsgJz0nICsgcmVjb3JkW2tleV0gKyAnOydcbiAgICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgICAnfScpXG5cbiAgICAgICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgICAgICB2YXIgRElWSVNPUiA9IHJlY29yZC5kaXZpc29yXG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnaWYoJywgQklORElORywgJy5kaXZpc29yIT09JywgRElWSVNPUiwgJyl7JyxcbiAgICAgICAgICAgIGVudi5pbnN0YW5jaW5nLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLCBbTE9DQVRJT04sIERJVklTT1JdLCAnKTsnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yPScsIERJVklTT1IsICc7fScpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW1pdENvbnN0YW50ICgpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcsIEJJTkRJTkcsICcuYnVmZmVyKXsnLFxuICAgICAgICAgIEdMLCAnLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSgnLCBMT0NBVElPTiwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLmJ1ZmZlcj1udWxsOycsXG4gICAgICAgICAgJ31pZignLCBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnIT09JyArIENPTlNUX0NPTVBPTkVOVFNbaV1cbiAgICAgICAgICB9KS5qb2luKCd8fCcpLCAnKXsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYjRmKCcsIExPQ0FUSU9OLCAnLCcsIENPTlNUX0NPTVBPTkVOVFMsICcpOycsXG4gICAgICAgICAgQ1VURV9DT01QT05FTlRTLm1hcChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBjICsgJz0nICsgQ09OU1RfQ09NUE9ORU5UU1tpXSArICc7J1xuICAgICAgICAgIH0pLmpvaW4oJycpLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFID09PSBBVFRSSUJfU1RBVEVfUE9JTlRFUikge1xuICAgICAgICBlbWl0QnVmZmVyKClcbiAgICAgIH0gZWxzZSBpZiAoU1RBVEUgPT09IEFUVFJJQl9TVEFURV9DT05TVEFOVCkge1xuICAgICAgICBlbWl0Q29uc3RhbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUoJ2lmKCcsIFNUQVRFLCAnPT09JywgQVRUUklCX1NUQVRFX1BPSU5URVIsICcpeycpXG4gICAgICAgIGVtaXRCdWZmZXIoKVxuICAgICAgICBzY29wZSgnfWVsc2V7JylcbiAgICAgICAgZW1pdENvbnN0YW50KClcbiAgICAgICAgc2NvcGUoJ30nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICB2YXIgYXJnID0gYXJncy5hdHRyaWJ1dGVzW25hbWVdXG4gICAgICB2YXIgcmVjb3JkXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICByZWNvcmQgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWZpbHRlcihTQ09QRV9ERUNMKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgc2NvcGVBdHRyaWIgKyAnLnN0YXRlJyxcbiAgICAgICAgICAgICdtaXNzaW5nIGF0dHJpYnV0ZSAnICsgbmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgcmVjb3JkID0ge31cbiAgICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZWNvcmRba2V5XSA9IHNjb3BlLmRlZihzY29wZUF0dHJpYiwgJy4nLCBrZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbWl0QmluZEF0dHJpYnV0ZShcbiAgICAgICAgZW52LmxpbmsoYXR0cmlidXRlKSwgdHlwZUxlbmd0aChhdHRyaWJ1dGUuaW5mby50eXBlKSwgcmVjb3JkKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0VW5pZm9ybXMgKGVudiwgc2NvcGUsIGFyZ3MsIHVuaWZvcm1zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuXG4gICAgdmFyIGluZml4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1tpXVxuICAgICAgdmFyIG5hbWUgPSB1bmlmb3JtLm5hbWVcbiAgICAgIHZhciB0eXBlID0gdW5pZm9ybS5pbmZvLnR5cGVcbiAgICAgIHZhciBhcmcgPSBhcmdzLnVuaWZvcm1zW25hbWVdXG4gICAgICB2YXIgVU5JRk9STSA9IGVudi5saW5rKHVuaWZvcm0pXG4gICAgICB2YXIgTE9DQVRJT04gPSBVTklGT1JNICsgJy5sb2NhdGlvbidcblxuICAgICAgdmFyIFZBTFVFXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0YXRpYyhhcmcpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICdtaXNzaW5nIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIGlmICh0eXBlID09PSBHTF9TQU1QTEVSXzJEIHx8IHR5cGUgPT09IEdMX1NBTVBMRVJfQ1VCRSkge1xuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKCh0eXBlID09PSBHTF9TQU1QTEVSXzJEICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmUyZCcgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpKSB8fFxuICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmVDdWJlJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9yZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyQ3ViZScpKSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIHRleHR1cmUgZm9yIHVuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgdmFyIFRFWF9WQUxVRSA9IGVudi5saW5rKHZhbHVlLl90ZXh0dXJlIHx8IHZhbHVlLmNvbG9yWzBdLl90ZXh0dXJlKVxuICAgICAgICAgICAgc2NvcGUoR0wsICcudW5pZm9ybTFpKCcsIExPQ0FUSU9OLCAnLCcsIFRFWF9WQUxVRSArICcuYmluZCgpKTsnKVxuICAgICAgICAgICAgc2NvcGUuZXhpdChURVhfVkFMVUUsICcudW5iaW5kKCk7JylcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUNCkge1xuICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChpc0FycmF5TGlrZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbWF0cml4IGZvciB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICh0eXBlID09PSBHTF9GTE9BVF9NQVQyICYmIHZhbHVlLmxlbmd0aCA9PT0gNCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMyAmJiB2YWx1ZS5sZW5ndGggPT09IDkpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQgJiYgdmFsdWUubGVuZ3RoID09PSAxNiksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbGVuZ3RoIGZvciBtYXRyaXggdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFyIE1BVF9WQUxVRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KFsnICtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpICsgJ10pJylcbiAgICAgICAgICAgIHZhciBkaW0gPSAyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMykge1xuICAgICAgICAgICAgICBkaW0gPSAzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQpIHtcbiAgICAgICAgICAgICAgZGltID0gNFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAgIEdMLCAnLnVuaWZvcm1NYXRyaXgnLCBkaW0sICdmdignLFxuICAgICAgICAgICAgICBMT0NBVElPTiwgJyxmYWxzZSwnLCBNQVRfVkFMVUUsICcpOycpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ251bWJlcicsICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcxZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcyZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzM6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0ZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0JPT0w6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nLCAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMWknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzJpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDMsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAzLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzRpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtJywgaW5maXgsICcoJywgTE9DQVRJT04sICcsJyxcbiAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpIDogdmFsdWUsXG4gICAgICAgICAgICAgICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVkFMVUUgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmlsdGVyKFNDT1BFX0RFQ0wpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBWQUxVRSA9IHNjb3BlLmRlZihzaGFyZWQudW5pZm9ybXMsICdbJywgc3RyaW5nU3RvcmUuaWQobmFtZSksICddJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IEdMX1NBTVBMRVJfMkQpIHtcbiAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IHNwZWNpZnkgYSBzY2FsYXIgcHJvcCBmb3IgdGV4dHVyZXMnKVxuICAgICAgICBzY29wZShcbiAgICAgICAgICAnaWYoJywgVkFMVUUsICcmJicsIFZBTFVFLCAnLl9yZWdsVHlwZT09PVwiZnJhbWVidWZmZXJcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBzcGVjaWZ5IGEgc2NhbGFyIHByb3AgZm9yIGN1YmUgbWFwcycpXG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyYmJywgVkFMVUUsICcuX3JlZ2xUeXBlPT09XCJmcmFtZWJ1ZmZlckN1YmVcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgLy8gcGVyZm9ybSB0eXBlIHZhbGlkYXRpb25cbiAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBlbWl0Q2hlY2sgKHByZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBwcmVkLFxuICAgICAgICAgICAgJ2JhZCBkYXRhIG9yIG1pc3NpbmcgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIi4gICcgKyBtZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tUeXBlICh0eXBlKSB7XG4gICAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IG5vdCBzcGVjaWZ5IGFuIGFycmF5IHR5cGUgZm9yIHVuaWZvcm0nKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiJyArIHR5cGUgKyAnXCInLFxuICAgICAgICAgICAgJ2ludmFsaWQgdHlwZSwgZXhwZWN0ZWQgJyArIHR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZlY3RvciAobiwgdHlwZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFZBTFVFKSkge1xuICAgICAgICAgICAgY2hlY2skMShWQUxVRS5sZW5ndGggPT09IG4sICdtdXN0IGhhdmUgbGVuZ3RoICcgKyBuKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0Q2hlY2soXG4gICAgICAgICAgICAgIHNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIFZBTFVFICsgJykmJicgKyBWQUxVRSArICcubGVuZ3RoPT09JyArIG4sXG4gICAgICAgICAgICAgICdpbnZhbGlkIHZlY3Rvciwgc2hvdWxkIGhhdmUgbGVuZ3RoICcgKyBuLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1RleHR1cmUgKHRhcmdldCkge1xuICAgICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBub3Qgc3BlY2lmeSBhIHZhbHVlIHR5cGUnKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiZnVuY3Rpb25cIiYmJyArXG4gICAgICAgICAgICBWQUxVRSArICcuX3JlZ2xUeXBlPT09XCJ0ZXh0dXJlJyArXG4gICAgICAgICAgICAodGFyZ2V0ID09PSBHTF9URVhUVVJFXzJEJDMgPyAnMmQnIDogJ0N1YmUnKSArICdcIicsXG4gICAgICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgR0xfSU5UJDM6XG4gICAgICAgICAgICBjaGVja1R5cGUoJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVQkODpcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgICAgY2hlY2tUeXBlKCdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnYm9vbGVhbicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDQsICdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDksICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigxNiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl8yRDpcbiAgICAgICAgICAgIGNoZWNrVGV4dHVyZShHTF9URVhUVVJFXzJEJDMpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl9DVUJFOlxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfQ1VCRV9NQVAkMilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHZhciB1bnJvbGwgPSAxXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBHTF9TQU1QTEVSXzJEOlxuICAgICAgICBjYXNlIEdMX1NBTVBMRVJfQ1VCRTpcbiAgICAgICAgICB2YXIgVEVYID0gc2NvcGUuZGVmKFZBTFVFLCAnLl90ZXh0dXJlJylcbiAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtMWkoJywgTE9DQVRJT04sICcsJywgVEVYLCAnLmJpbmQoKSk7JylcbiAgICAgICAgICBzY29wZS5leGl0KFRFWCwgJy51bmJpbmQoKTsnKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgdW5yb2xsID0gMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgdW5yb2xsID0gM1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVCQ4OlxuICAgICAgICAgIGluZml4ID0gJzFmJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgIGluZml4ID0gJzJmJ1xuICAgICAgICAgIHVucm9sbCA9IDJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICB1bnJvbGwgPSAzXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGYnXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgIGluZml4ID0gJ01hdHJpeDJmdidcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICBpbmZpeCA9ICdNYXRyaXgzZnYnXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgaW5maXggPSAnTWF0cml4NGZ2J1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0nLCBpbmZpeCwgJygnLCBMT0NBVElPTiwgJywnKVxuICAgICAgaWYgKGluZml4LmNoYXJBdCgwKSA9PT0gJ00nKSB7XG4gICAgICAgIHZhciBtYXRTaXplID0gTWF0aC5wb3codHlwZSAtIEdMX0ZMT0FUX01BVDIgKyAyLCAyKVxuICAgICAgICB2YXIgU1RPUkFHRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KCcsIG1hdFNpemUsICcpJylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoVkFMVUUpKSB7XG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnZmFsc2UsKCcsXG4gICAgICAgICAgICBsb29wKG1hdFNpemUsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVE9SQUdFICsgJ1snICsgaSArICddPScgKyBWQUxVRVtpXVxuICAgICAgICAgICAgfSksICcsJywgU1RPUkFHRSwgJyknKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgJ2ZhbHNlLChBcnJheS5pc0FycmF5KCcsIFZBTFVFLCAnKXx8JywgVkFMVUUsICcgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpPycsIFZBTFVFLCAnOignLFxuICAgICAgICAgICAgbG9vcChtYXRTaXplLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gU1RPUkFHRSArICdbJyArIGkgKyAnXT0nICsgVkFMVUUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICB9KSwgJywnLCBTVE9SQUdFLCAnKScpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodW5yb2xsID4gMSkge1xuICAgICAgICBzY29wZShsb29wKHVucm9sbCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShWQUxVRSkgPyBWQUxVRVtpXSA6IFZBTFVFICsgJ1snICsgaSArICddJ1xuICAgICAgICB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAndW5pZm9ybSB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBhcnJheScpXG4gICAgICAgIHNjb3BlKFZBTFVFKVxuICAgICAgfVxuICAgICAgc2NvcGUoJyk7JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0RHJhdyAoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuICAgIHZhciBEUkFXX1NUQVRFID0gc2hhcmVkLmRyYXdcblxuICAgIHZhciBkcmF3T3B0aW9ucyA9IGFyZ3MuZHJhd1xuXG4gICAgZnVuY3Rpb24gZW1pdEVsZW1lbnRzICgpIHtcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuZWxlbWVudHNcbiAgICAgIHZhciBFTEVNRU5UU1xuICAgICAgdmFyIHNjb3BlID0gb3V0ZXJcbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIGlmICgoZGVmbi5jb250ZXh0RGVwICYmIGFyZ3MuY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcCkge1xuICAgICAgICAgIHNjb3BlID0gaW5uZXJcbiAgICAgICAgfVxuICAgICAgICBFTEVNRU5UUyA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFTEVNRU5UUyA9IHNjb3BlLmRlZihEUkFXX1NUQVRFLCAnLicsIFNfRUxFTUVOVFMpXG4gICAgICB9XG4gICAgICBpZiAoRUxFTUVOVFMpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcgKyBFTEVNRU5UUyArICcpJyArXG4gICAgICAgICAgR0wgKyAnLmJpbmRCdWZmZXIoJyArIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSJDEgKyAnLCcgKyBFTEVNRU5UUyArICcuYnVmZmVyLmJ1ZmZlcik7JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBFTEVNRU5UU1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRDb3VudCAoKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zLmNvdW50XG4gICAgICB2YXIgQ09VTlRcbiAgICAgIHZhciBzY29wZSA9IG91dGVyXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICBzY29wZSA9IGlubmVyXG4gICAgICAgIH1cbiAgICAgICAgQ09VTlQgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGVmbi5NSVNTSU5HKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KG91dGVyLCAnZmFsc2UnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmbi5EWU5BTUlDKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBDT1VOVCArICc+PTAnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENPVU5UID0gc2NvcGUuZGVmKERSQVdfU1RBVEUsICcuJywgU19DT1VOVClcbiAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW52LmFzc2VydChzY29wZSwgQ09VTlQgKyAnPj0wJywgJ21pc3NpbmcgdmVydGV4IGNvdW50JylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBDT1VOVFxuICAgIH1cblxuICAgIHZhciBFTEVNRU5UUyA9IGVtaXRFbGVtZW50cygpXG4gICAgZnVuY3Rpb24gZW1pdFZhbHVlIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBpbm5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBvdXRlcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG91dGVyLmRlZihEUkFXX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFBSSU1JVElWRSA9IGVtaXRWYWx1ZShTX1BSSU1JVElWRSlcbiAgICB2YXIgT0ZGU0VUID0gZW1pdFZhbHVlKFNfT0ZGU0VUKVxuXG4gICAgdmFyIENPVU5UID0gZW1pdENvdW50KClcbiAgICBpZiAodHlwZW9mIENPVU5UID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKENPVU5UID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lcignaWYoJywgQ09VTlQsICcpeycpXG4gICAgICBpbm5lci5leGl0KCd9JylcbiAgICB9XG5cbiAgICB2YXIgSU5TVEFOQ0VTLCBFWFRfSU5TVEFOQ0lOR1xuICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICBJTlNUQU5DRVMgPSBlbWl0VmFsdWUoU19JTlNUQU5DRVMpXG4gICAgICBFWFRfSU5TVEFOQ0lORyA9IGVudi5pbnN0YW5jaW5nXG4gICAgfVxuXG4gICAgdmFyIEVMRU1FTlRfVFlQRSA9IEVMRU1FTlRTICsgJy50eXBlJ1xuXG4gICAgdmFyIGVsZW1lbnRzU3RhdGljID0gZHJhd09wdGlvbnMuZWxlbWVudHMgJiYgaXNTdGF0aWMoZHJhd09wdGlvbnMuZWxlbWVudHMpXG5cbiAgICBmdW5jdGlvbiBlbWl0SW5zdGFuY2luZyAoKSB7XG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMgKCkge1xuICAgICAgICBpbm5lcihFWFRfSU5TVEFOQ0lORywgJy5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSgnLCBbXG4gICAgICAgICAgUFJJTUlUSVZFLFxuICAgICAgICAgIENPVU5ULFxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcbiAgICAgICAgICBPRkZTRVQgKyAnPDwoKCcgKyBFTEVNRU5UX1RZUEUgKyAnLScgKyBHTF9VTlNJR05FRF9CWVRFJDggKyAnKT4+MSknLFxuICAgICAgICAgIElOU1RBTkNFU1xuICAgICAgICBdLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3QXJyYXlzICgpIHtcbiAgICAgICAgaW5uZXIoRVhUX0lOU1RBTkNJTkcsICcuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCcsXG4gICAgICAgICAgW1BSSU1JVElWRSwgT0ZGU0VULCBDT1VOVCwgSU5TVEFOQ0VTXSwgJyk7JylcbiAgICAgIH1cblxuICAgICAgaWYgKEVMRU1FTlRTKSB7XG4gICAgICAgIGlmICghZWxlbWVudHNTdGF0aWMpIHtcbiAgICAgICAgICBpbm5lcignaWYoJywgRUxFTUVOVFMsICcpeycpXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgICBpbm5lcignfWVsc2V7JylcbiAgICAgICAgICBkcmF3QXJyYXlzKClcbiAgICAgICAgICBpbm5lcignfScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFJlZ3VsYXIgKCkge1xuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzICgpIHtcbiAgICAgICAgaW5uZXIoR0wgKyAnLmRyYXdFbGVtZW50cygnICsgW1xuICAgICAgICAgIFBSSU1JVElWRSxcbiAgICAgICAgICBDT1VOVCxcbiAgICAgICAgICBFTEVNRU5UX1RZUEUsXG4gICAgICAgICAgT0ZGU0VUICsgJzw8KCgnICsgRUxFTUVOVF9UWVBFICsgJy0nICsgR0xfVU5TSUdORURfQllURSQ4ICsgJyk+PjEpJ1xuICAgICAgICBdICsgJyk7JylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd0FycmF5cyAoKSB7XG4gICAgICAgIGlubmVyKEdMICsgJy5kcmF3QXJyYXlzKCcgKyBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5UXSArICcpOycpXG4gICAgICB9XG5cbiAgICAgIGlmIChFTEVNRU5UUykge1xuICAgICAgICBpZiAoIWVsZW1lbnRzU3RhdGljKSB7XG4gICAgICAgICAgaW5uZXIoJ2lmKCcsIEVMRU1FTlRTLCAnKXsnKVxuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgICAgaW5uZXIoJ31lbHNleycpXG4gICAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICAgICAgaW5uZXIoJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXdBcnJheXMoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRJbnN0YW5jaW5nICYmICh0eXBlb2YgSU5TVEFOQ0VTICE9PSAnbnVtYmVyJyB8fCBJTlNUQU5DRVMgPj0gMCkpIHtcbiAgICAgIGlmICh0eXBlb2YgSU5TVEFOQ0VTID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbm5lcignaWYoJywgSU5TVEFOQ0VTLCAnPjApeycpXG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgICAgaW5uZXIoJ31lbHNlIGlmKCcsIElOU1RBTkNFUywgJzwwKXsnKVxuICAgICAgICBlbWl0UmVndWxhcigpXG4gICAgICAgIGlubmVyKCd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFJlZ3VsYXIoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvZHkgKGVtaXRCb2R5LCBwYXJlbnRFbnYsIGFyZ3MsIHByb2dyYW0sIGNvdW50KSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ2JvZHknLCBjb3VudClcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5jb21tYW5kU3RyID0gcGFyZW50RW52LmNvbW1hbmRTdHJcbiAgICAgIGVudi5jb21tYW5kID0gZW52LmxpbmsocGFyZW50RW52LmNvbW1hbmRTdHIpXG4gICAgfSlcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgZW52Lmluc3RhbmNpbmcgPSBzY29wZS5kZWYoXG4gICAgICAgIGVudi5zaGFyZWQuZXh0ZW5zaW9ucywgJy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgICB9XG4gICAgZW1pdEJvZHkoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSlcbiAgICByZXR1cm4gZW52LmNvbXBpbGUoKS5ib2R5XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERSQVcgUFJPQ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXREcmF3Qm9keSAoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtKSB7XG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGRyYXcpXG4gICAgaWYgKGFyZ3MudXNlVkFPKSB7XG4gICAgICBpZiAoYXJncy5kcmF3VkFPKSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBkcmF3KSwgJyk7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8obnVsbCk7JylcbiAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgZHJhdywgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgICBlbWl0VW5pZm9ybXMoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtLnVuaWZvcm1zLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgZW1pdERyYXcoZW52LCBkcmF3LCBkcmF3LCBhcmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdERyYXdQcm9jIChlbnYsIGFyZ3MpIHtcbiAgICB2YXIgZHJhdyA9IGVudi5wcm9jKCdkcmF3JywgMSlcblxuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBkcmF3KVxuXG4gICAgZW1pdENvbnRleHQoZW52LCBkcmF3LCBhcmdzLmNvbnRleHQpXG4gICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGRyYXcsIGFyZ3MuZnJhbWVidWZmZXIpXG5cbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgZHJhdywgYXJncylcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGRyYXcsIGFyZ3Muc3RhdGUpXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIGRyYXcsIGFyZ3MsIGZhbHNlLCB0cnVlKVxuXG4gICAgdmFyIHByb2dyYW0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGRyYXcpXG4gICAgZHJhdyhlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgcHJvZ3JhbSwgJy5wcm9ncmFtKTsnKVxuXG4gICAgaWYgKGFyZ3Muc2hhZGVyLnByb2dyYW0pIHtcbiAgICAgIGVtaXREcmF3Qm9keShlbnYsIGRyYXcsIGFyZ3MsIGFyZ3Muc2hhZGVyLnByb2dyYW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKG51bGwpOycpXG4gICAgICB2YXIgZHJhd0NhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9JylcbiAgICAgIHZhciBQUk9HX0lEID0gZHJhdy5kZWYocHJvZ3JhbSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBkcmF3LmRlZihkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ10nKVxuICAgICAgZHJhdyhcbiAgICAgICAgZW52LmNvbmQoQ0FDSEVEX1BST0MpXG4gICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwKTsnKVxuICAgICAgICAgIC5lbHNlKFxuICAgICAgICAgICAgQ0FDSEVEX1BST0MsICc9JywgZHJhd0NhY2hlLCAnWycsIFBST0dfSUQsICddPScsXG4gICAgICAgICAgICBlbnYubGluayhmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0RHJhd0JvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMSlcbiAgICAgICAgICAgIH0pLCAnKCcsIHByb2dyYW0sICcpOycsXG4gICAgICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTApOycpKVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhhcmdzLnN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICBkcmF3KGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBCQVRDSCBQUk9DXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBlbWl0QmF0Y2hEeW5hbWljU2hhZGVyQm9keSAoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSkge1xuICAgIGVudi5iYXRjaElkID0gJ2ExJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIHNjb3BlKVxuXG4gICAgZnVuY3Rpb24gYWxsICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZW1pdEF0dHJpYnV0ZXMoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBhbGwpXG4gICAgZW1pdFVuaWZvcm1zKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGFsbClcbiAgICBlbWl0RHJhdyhlbnYsIHNjb3BlLCBzY29wZSwgYXJncylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRCYXRjaEJvZHkgKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0pIHtcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpXG5cbiAgICB2YXIgY29udGV4dER5bmFtaWMgPSBhcmdzLmNvbnRleHREZXBcblxuICAgIHZhciBCQVRDSF9JRCA9IHNjb3BlLmRlZigpXG4gICAgdmFyIFBST1BfTElTVCA9ICdhMCdcbiAgICB2YXIgTlVNX1BST1BTID0gJ2ExJ1xuICAgIHZhciBQUk9QUyA9IHNjb3BlLmRlZigpXG4gICAgZW52LnNoYXJlZC5wcm9wcyA9IFBST1BTXG4gICAgZW52LmJhdGNoSWQgPSBCQVRDSF9JRFxuXG4gICAgdmFyIG91dGVyID0gZW52LnNjb3BlKClcbiAgICB2YXIgaW5uZXIgPSBlbnYuc2NvcGUoKVxuXG4gICAgc2NvcGUoXG4gICAgICBvdXRlci5lbnRyeSxcbiAgICAgICdmb3IoJywgQkFUQ0hfSUQsICc9MDsnLCBCQVRDSF9JRCwgJzwnLCBOVU1fUFJPUFMsICc7KysnLCBCQVRDSF9JRCwgJyl7JyxcbiAgICAgIFBST1BTLCAnPScsIFBST1BfTElTVCwgJ1snLCBCQVRDSF9JRCwgJ107JyxcbiAgICAgIGlubmVyLFxuICAgICAgJ30nLFxuICAgICAgb3V0ZXIuZXhpdClcblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKChkZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc091dGVyRGVmbiAoZGVmbikge1xuICAgICAgcmV0dXJuICFpc0lubmVyRGVmbihkZWZuKVxuICAgIH1cblxuICAgIGlmIChhcmdzLm5lZWRzQ29udGV4dCkge1xuICAgICAgZW1pdENvbnRleHQoZW52LCBpbm5lciwgYXJncy5jb250ZXh0KVxuICAgIH1cbiAgICBpZiAoYXJncy5uZWVkc0ZyYW1lYnVmZmVyKSB7XG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgaW5uZXIsIGFyZ3MuZnJhbWVidWZmZXIpXG4gICAgfVxuICAgIGVtaXRTZXRPcHRpb25zKGVudiwgaW5uZXIsIGFyZ3Muc3RhdGUsIGlzSW5uZXJEZWZuKVxuXG4gICAgaWYgKGFyZ3MucHJvZmlsZSAmJiBpc0lubmVyRGVmbihhcmdzLnByb2ZpbGUpKSB7XG4gICAgICBlbWl0UHJvZmlsZShlbnYsIGlubmVyLCBhcmdzLCBmYWxzZSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIHZhciBwcm9nQ2FjaGUgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgICAgdmFyIFBST0dSQU0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGlubmVyKVxuICAgICAgdmFyIFBST0dfSUQgPSBpbm5lci5kZWYoUFJPR1JBTSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBpbm5lci5kZWYocHJvZ0NhY2hlLCAnWycsIFBST0dfSUQsICddJylcbiAgICAgIGlubmVyKFxuICAgICAgICBlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgUFJPR1JBTSwgJy5wcm9ncmFtKTsnLFxuICAgICAgICAnaWYoIScsIENBQ0hFRF9QUk9DLCAnKXsnLFxuICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBwcm9nQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShcbiAgICAgICAgICAgIGVtaXRCYXRjaER5bmFtaWNTaGFkZXJCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpO30nLFxuICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTBbJywgQkFUQ0hfSUQsICddLCcsIEJBVENIX0lELCAnKTsnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy51c2VWQU8pIHtcbiAgICAgICAgaWYgKGFyZ3MuZHJhd1ZBTykge1xuICAgICAgICAgIGlmIChpc0lubmVyRGVmbihhcmdzLmRyYXdWQU8pKSB7XG4gICAgICAgICAgICAvLyB2YW8gaXMgYSBwcm9wXG4gICAgICAgICAgICBpbm5lcihlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgYXJncy5kcmF3VkFPLmFwcGVuZChlbnYsIGlubmVyKSwgJyk7JylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmFvIGlzIGludmFyaWFudFxuICAgICAgICAgICAgb3V0ZXIoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBvdXRlciksICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNjb3BlZCB2YW8gYmluZGluZ1xuICAgICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTygnLCBlbnYuc2hhcmVkLnZhbywgJy50YXJnZXRWQU8pOycpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIG91dGVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIGlubmVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzSW5uZXJEZWZuKVxuICAgICAgfVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgaW5uZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzSW5uZXJEZWZuKVxuICAgICAgZW1pdERyYXcoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEJhdGNoUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIGJhdGNoID0gZW52LnByb2MoJ2JhdGNoJywgMilcbiAgICBlbnYuYmF0Y2hJZCA9ICcwJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGJhdGNoKVxuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGNvbnRleHQgdmFyaWFibGVzIGRlcGVuZCBvbiBwcm9wc1xuICAgIHZhciBjb250ZXh0RHluYW1pYyA9IGZhbHNlXG4gICAgdmFyIG5lZWRzQ29udGV4dCA9IHRydWVcbiAgICBPYmplY3Qua2V5cyhhcmdzLmNvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gY29udGV4dER5bmFtaWMgfHwgYXJncy5jb250ZXh0W25hbWVdLnByb3BEZXBcbiAgICB9KVxuICAgIGlmICghY29udGV4dER5bmFtaWMpIHtcbiAgICAgIGVtaXRDb250ZXh0KGVudiwgYmF0Y2gsIGFyZ3MuY29udGV4dClcbiAgICAgIG5lZWRzQ29udGV4dCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZnJhbWVidWZmZXIgc3RhdGUgYWZmZWN0cyBmcmFtZWJ1ZmZlcldpZHRoL2hlaWdodCBjb250ZXh0IHZhcnNcbiAgICB2YXIgZnJhbWVidWZmZXIgPSBhcmdzLmZyYW1lYnVmZmVyXG4gICAgdmFyIG5lZWRzRnJhbWVidWZmZXIgPSBmYWxzZVxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKGZyYW1lYnVmZmVyLnByb3BEZXApIHtcbiAgICAgICAgY29udGV4dER5bmFtaWMgPSBuZWVkc0ZyYW1lYnVmZmVyID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChmcmFtZWJ1ZmZlci5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB7XG4gICAgICAgIG5lZWRzRnJhbWVidWZmZXIgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIW5lZWRzRnJhbWVidWZmZXIpIHtcbiAgICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBmcmFtZWJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBudWxsKVxuICAgIH1cblxuICAgIC8vIHZpZXdwb3J0IGlzIHdlaXJkIGJlY2F1c2UgaXQgY2FuIGFmZmVjdCBjb250ZXh0IHZhcnNcbiAgICBpZiAoYXJncy5zdGF0ZS52aWV3cG9ydCAmJiBhcmdzLnN0YXRlLnZpZXdwb3J0LnByb3BEZXApIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKGRlZm4uY29udGV4dERlcCAmJiBjb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwXG4gICAgfVxuXG4gICAgLy8gc2V0IHdlYmdsIG9wdGlvbnNcbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgYmF0Y2gsIGFyZ3MpXG4gICAgZW1pdFNldE9wdGlvbnMoZW52LCBiYXRjaCwgYXJncy5zdGF0ZSwgZnVuY3Rpb24gKGRlZm4pIHtcbiAgICAgIHJldHVybiAhaXNJbm5lckRlZm4oZGVmbilcbiAgICB9KVxuXG4gICAgaWYgKCFhcmdzLnByb2ZpbGUgfHwgIWlzSW5uZXJEZWZuKGFyZ3MucHJvZmlsZSkpIHtcbiAgICAgIGVtaXRQcm9maWxlKGVudiwgYmF0Y2gsIGFyZ3MsIGZhbHNlLCAnYTEnKVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlc2UgdmFsdWVzIHRvIGFyZ3Mgc28gdGhhdCB0aGUgYmF0Y2ggYm9keSByb3V0aW5lIGNhbiB1c2UgdGhlbVxuICAgIGFyZ3MuY29udGV4dERlcCA9IGNvbnRleHREeW5hbWljXG4gICAgYXJncy5uZWVkc0NvbnRleHQgPSBuZWVkc0NvbnRleHRcbiAgICBhcmdzLm5lZWRzRnJhbWVidWZmZXIgPSBuZWVkc0ZyYW1lYnVmZmVyXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgc2hhZGVyIGlzIGR5bmFtaWNcbiAgICB2YXIgcHJvZ0RlZm4gPSBhcmdzLnNoYWRlci5wcm9nVmFyXG4gICAgaWYgKChwcm9nRGVmbi5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB8fCBwcm9nRGVmbi5wcm9wRGVwKSB7XG4gICAgICBlbWl0QmF0Y2hCb2R5KFxuICAgICAgICBlbnYsXG4gICAgICAgIGJhdGNoLFxuICAgICAgICBhcmdzLFxuICAgICAgICBudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgUFJPR1JBTSA9IHByb2dEZWZuLmFwcGVuZChlbnYsIGJhdGNoKVxuICAgICAgYmF0Y2goZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIFBST0dSQU0sICcucHJvZ3JhbSk7JylcbiAgICAgIGlmIChhcmdzLnNoYWRlci5wcm9ncmFtKSB7XG4gICAgICAgIGVtaXRCYXRjaEJvZHkoXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgYXJncy5zaGFkZXIucHJvZ3JhbSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICB2YXIgYmF0Y2hDYWNoZSA9IGVudi5nbG9iYWwuZGVmKCd7fScpXG4gICAgICAgIHZhciBQUk9HX0lEID0gYmF0Y2guZGVmKFBST0dSQU0sICcuaWQnKVxuICAgICAgICB2YXIgQ0FDSEVEX1BST0MgPSBiYXRjaC5kZWYoYmF0Y2hDYWNoZSwgJ1snLCBQUk9HX0lELCAnXScpXG4gICAgICAgIGJhdGNoKFxuICAgICAgICAgIGVudi5jb25kKENBQ0hFRF9QUk9DKVxuICAgICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwLGExKTsnKVxuICAgICAgICAgICAgLmVsc2UoXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnPScsIGJhdGNoQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0QmF0Y2hCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpOycsXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCxhMSk7JykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGJhdGNoKGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTQ09QRSBDT01NQU5EXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW1pdFNjb3BlUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ3Njb3BlJywgMylcbiAgICBlbnYuYmF0Y2hJZCA9ICdhMidcblxuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuXG4gICAgZW1pdENvbnRleHQoZW52LCBzY29wZSwgYXJncy5jb250ZXh0KVxuXG4gICAgaWYgKGFyZ3MuZnJhbWVidWZmZXIpIHtcbiAgICAgIGFyZ3MuZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfVxuXG4gICAgc29ydFN0YXRlKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGFyZ3Muc3RhdGVbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICBzY29wZS5zZXQoZW52Lm5leHRbbmFtZV0sICdbJyArIGkgKyAnXScsIHYpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLm5leHQsICcuJyArIG5hbWUsIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIHNjb3BlLCBhcmdzLCB0cnVlLCB0cnVlKVxuXG4gICAgO1tTX0VMRU1FTlRTLCBTX09GRlNFVCwgU19DT1VOVCwgU19JTlNUQU5DRVMsIFNfUFJJTUlUSVZFXS5mb3JFYWNoKFxuICAgICAgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICB2YXIgdmFyaWFibGUgPSBhcmdzLmRyYXdbb3B0XVxuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuc2V0KHNoYXJlZC5kcmF3LCAnLicgKyBvcHQsICcnICsgdmFyaWFibGUuYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MudW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJncy51bmlmb3Jtc1tvcHRdLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gJ1snICsgdmFsdWUuam9pbigpICsgJ10nXG4gICAgICB9XG4gICAgICBzY29wZS5zZXQoXG4gICAgICAgIHNoYXJlZC51bmlmb3JtcyxcbiAgICAgICAgJ1snICsgc3RyaW5nU3RvcmUuaWQob3B0KSArICddJyxcbiAgICAgICAgdmFsdWUpXG4gICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IGFyZ3MuYXR0cmlidXRlc1tuYW1lXS5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHNjb3BlLnNldChzY29wZUF0dHJpYiwgJy4nICsgcHJvcCwgcmVjb3JkW3Byb3BdKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGFyZ3Muc2NvcGVWQU8pIHtcbiAgICAgIHNjb3BlLnNldChzaGFyZWQudmFvLCAnLnRhcmdldFZBTycsIGFyZ3Muc2NvcGVWQU8uYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVTaGFkZXIgKG5hbWUpIHtcbiAgICAgIHZhciBzaGFkZXIgPSBhcmdzLnNoYWRlcltuYW1lXVxuICAgICAgaWYgKHNoYWRlcikge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLnNoYWRlciwgJy4nICsgbmFtZSwgc2hhZGVyLmFwcGVuZChlbnYsIHNjb3BlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2F2ZVNoYWRlcihTX1ZFUlQpXG4gICAgc2F2ZVNoYWRlcihTX0ZSQUcpXG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT10cnVlOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcuZGlydHk9dHJ1ZTsnKVxuICAgIH1cblxuICAgIHNjb3BlKCdhMSgnLCBlbnYuc2hhcmVkLmNvbnRleHQsICcsYTAsJywgZW52LmJhdGNoSWQsICcpOycpXG4gIH1cblxuICBmdW5jdGlvbiBpc0R5bmFtaWNPYmplY3QgKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5TGlrZShvYmplY3QpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyhvYmplY3RbcHJvcHNbaV1dKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGF0T2JqZWN0IChlbnYsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgICBpZiAoIW9iamVjdCB8fCAhaXNEeW5hbWljT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBnbG9iYWxzID0gZW52Lmdsb2JhbFxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIHZhciB0aGlzRGVwID0gZmFsc2VcbiAgICB2YXIgY29udGV4dERlcCA9IGZhbHNlXG4gICAgdmFyIHByb3BEZXAgPSBmYWxzZVxuICAgIHZhciBvYmplY3RSZWYgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSA9IGR5bmFtaWMudW5ib3godmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHMgPSBjcmVhdGVEeW5hbWljRGVjbCh2YWx1ZSwgbnVsbClcbiAgICAgICAgdGhpc0RlcCA9IHRoaXNEZXAgfHwgZGVwcy50aGlzRGVwXG4gICAgICAgIHByb3BEZXAgPSBwcm9wRGVwIHx8IGRlcHMucHJvcERlcFxuICAgICAgICBjb250ZXh0RGVwID0gY29udGV4dERlcCB8fCBkZXBzLmNvbnRleHREZXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHMob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBnbG9iYWxzKHZhbHVlKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgZ2xvYmFscygnXCInLCB2YWx1ZSwgJ1wiJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBnbG9iYWxzKCdbJywgdmFsdWUuam9pbigpLCAnXScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnbG9iYWxzKGVudi5saW5rKHZhbHVlKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFscygnOycpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIGFwcGVuZEJsb2NrIChlbnYsIGJsb2NrKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgICBpZiAoIWR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBlbnYuaW52b2tlKGJsb2NrLCB2YWx1ZSlcbiAgICAgICAgYmxvY2sob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nLCByZWYsICc7JylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb3B0aW9ucy5keW5hbWljW25hbWVdID0gbmV3IGR5bmFtaWMuRHluYW1pY1ZhcmlhYmxlKERZTl9USFVOSywge1xuICAgICAgdGhpc0RlcDogdGhpc0RlcCxcbiAgICAgIGNvbnRleHREZXA6IGNvbnRleHREZXAsXG4gICAgICBwcm9wRGVwOiBwcm9wRGVwLFxuICAgICAgcmVmOiBvYmplY3RSZWYsXG4gICAgICBhcHBlbmQ6IGFwcGVuZEJsb2NrXG4gICAgfSlcbiAgICBkZWxldGUgb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTUFJTiBEUkFXIENPTU1BTkRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBjb21waWxlQ29tbWFuZCAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIHN0YXRzKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG5cbiAgICAvLyBsaW5rIHN0YXRzLCBzbyB0aGF0IHdlIGNhbiBlYXNpbHkgYWNjZXNzIGl0IGluIHRoZSBwcm9ncmFtLlxuICAgIGVudi5zdGF0cyA9IGVudi5saW5rKHN0YXRzKVxuXG4gICAgLy8gc3BsYXQgb3B0aW9ucyBhbmQgYXR0cmlidXRlcyB0byBhbGxvdyBmb3IgZHluYW1pYyBuZXN0ZWQgcHJvcGVydGllc1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuc3RhdGljKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHNwbGF0T2JqZWN0KGVudiwgYXR0cmlidXRlcywga2V5KVxuICAgIH0pXG4gICAgTkVTVEVEX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgc3BsYXRPYmplY3QoZW52LCBvcHRpb25zLCBuYW1lKVxuICAgIH0pXG5cbiAgICB2YXIgYXJncyA9IHBhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zLCBjb250ZXh0LCBlbnYpXG5cbiAgICBlbWl0RHJhd1Byb2MoZW52LCBhcmdzKVxuICAgIGVtaXRTY29wZVByb2MoZW52LCBhcmdzKVxuICAgIGVtaXRCYXRjaFByb2MoZW52LCBhcmdzKVxuXG4gICAgcmV0dXJuIGV4dGVuZChlbnYuY29tcGlsZSgpLCB7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3Muc2hhZGVyLnByb2dyYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUE9MTCAvIFJFRlJFU0hcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4ge1xuICAgIG5leHQ6IG5leHRTdGF0ZSxcbiAgICBjdXJyZW50OiBjdXJyZW50U3RhdGUsXG4gICAgcHJvY3M6IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KClcbiAgICAgIHZhciBwb2xsID0gZW52LnByb2MoJ3BvbGwnKVxuICAgICAgdmFyIHJlZnJlc2ggPSBlbnYucHJvYygncmVmcmVzaCcpXG4gICAgICB2YXIgY29tbW9uID0gZW52LmJsb2NrKClcbiAgICAgIHBvbGwoY29tbW9uKVxuICAgICAgcmVmcmVzaChjb21tb24pXG5cbiAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICAgIHZhciBORVhUX1NUQVRFID0gc2hhcmVkLm5leHRcbiAgICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcblxuICAgICAgY29tbW9uKENVUlJFTlRfU1RBVEUsICcuZGlydHk9ZmFsc2U7JylcblxuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIHBvbGwpXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgcmVmcmVzaCwgbnVsbCwgdHJ1ZSlcblxuICAgICAgLy8gUmVmcmVzaCB1cGRhdGVzIGFsbCBhdHRyaWJ1dGUgc3RhdGUgY2hhbmdlc1xuICAgICAgdmFyIElOU1RBTkNJTkdcbiAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICAgIElOU1RBTkNJTkcgPSBlbnYubGluayhleHRJbnN0YW5jaW5nKVxuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdmVydGV4IGFycmF5IGJpbmRpbmdzXG4gICAgICBpZiAoZXh0ZW5zaW9ucy5vZXNfdmVydGV4X2FycmF5X29iamVjdCkge1xuICAgICAgICByZWZyZXNoKGVudi5saW5rKGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3QpLCAnLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTsnKVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdHMubWF4QXR0cmlidXRlczsgKytpKSB7XG4gICAgICAgIHZhciBCSU5ESU5HID0gcmVmcmVzaC5kZWYoc2hhcmVkLmF0dHJpYnV0ZXMsICdbJywgaSwgJ10nKVxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKEJJTkRJTkcsICcuYnVmZmVyJylcbiAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgIEdMLCAnLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcuYmluZEJ1ZmZlcignLFxuICAgICAgICAgIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5idWZmZXIuYnVmZmVyKTsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYlBvaW50ZXIoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplLCcsXG4gICAgICAgICAgQklORElORywgJy50eXBlLCcsXG4gICAgICAgICAgQklORElORywgJy5ub3JtYWxpemVkLCcsXG4gICAgICAgICAgQklORElORywgJy5zdHJpZGUsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLm9mZnNldCk7J1xuICAgICAgICApLmVsc2UoXG4gICAgICAgICAgR0wsICcuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliNGYoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy54LCcsXG4gICAgICAgICAgQklORElORywgJy55LCcsXG4gICAgICAgICAgQklORElORywgJy56LCcsXG4gICAgICAgICAgQklORElORywgJy53KTsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuYnVmZmVyPW51bGw7JylcbiAgICAgICAgcmVmcmVzaChpZnRlKVxuICAgICAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgICAgIHJlZnJlc2goXG4gICAgICAgICAgICBJTlNUQU5DSU5HLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLFxuICAgICAgICAgICAgaSwgJywnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWZyZXNoKFxuICAgICAgICBlbnYuc2hhcmVkLnZhbywgJy5jdXJyZW50VkFPPW51bGw7JyxcbiAgICAgICAgZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcblxuICAgICAgT2JqZWN0LmtleXMoR0xfRkxBR1MpLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdmFyIGNhcCA9IEdMX0ZMQUdTW2ZsYWddXG4gICAgICAgIHZhciBORVhUID0gY29tbW9uLmRlZihORVhUX1NUQVRFLCAnLicsIGZsYWcpXG4gICAgICAgIHZhciBibG9jayA9IGVudi5ibG9jaygpXG4gICAgICAgIGJsb2NrKCdpZignLCBORVhULCAnKXsnLFxuICAgICAgICAgIEdMLCAnLmVuYWJsZSgnLCBjYXAsICcpfWVsc2V7JyxcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlKCcsIGNhcCwgJyl9JyxcbiAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIGZsYWcsICc9JywgTkVYVCwgJzsnKVxuICAgICAgICByZWZyZXNoKGJsb2NrKVxuICAgICAgICBwb2xsKFxuICAgICAgICAgICdpZignLCBORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBmbGFnLCAnKXsnLFxuICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICd9JylcbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IEdMX1ZBUklBQkxFU1tuYW1lXVxuICAgICAgICB2YXIgaW5pdCA9IGN1cnJlbnRTdGF0ZVtuYW1lXVxuICAgICAgICB2YXIgTkVYVCwgQ1VSUkVOVFxuICAgICAgICB2YXIgYmxvY2sgPSBlbnYuYmxvY2soKVxuICAgICAgICBibG9jayhHTCwgJy4nLCBmdW5jLCAnKCcpXG4gICAgICAgIGlmIChpc0FycmF5TGlrZShpbml0KSkge1xuICAgICAgICAgIHZhciBuID0gaW5pdC5sZW5ndGhcbiAgICAgICAgICBORVhUID0gZW52Lmdsb2JhbC5kZWYoTkVYVF9TVEFURSwgJy4nLCBuYW1lKVxuICAgICAgICAgIENVUlJFTlQgPSBlbnYuZ2xvYmFsLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBORVhUICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSksICcpOycsXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyBORVhUICsgJ1snICsgaSArICddOydcbiAgICAgICAgICAgIH0pLmpvaW4oJycpKVxuICAgICAgICAgIHBvbGwoXG4gICAgICAgICAgICAnaWYoJywgbG9vcChuLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gTkVYVCArICdbJyArIGkgKyAnXSE9PScgKyBDVVJSRU5UICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSkuam9pbignfHwnKSwgJyl7JyxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE5FWFQgPSBjb21tb24uZGVmKE5FWFRfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgICAgICBDVVJSRU5UID0gY29tbW9uLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBORVhULCAnKTsnLFxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBuYW1lLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgICBwb2xsKFxuICAgICAgICAgICAgJ2lmKCcsIE5FWFQsICchPT0nLCBDVVJSRU5ULCAnKXsnLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAnfScpXG4gICAgICAgIH1cbiAgICAgICAgcmVmcmVzaChibG9jaylcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBlbnYuY29tcGlsZSgpXG4gICAgfSkoKSxcbiAgICBjb21waWxlOiBjb21waWxlQ29tbWFuZFxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXRzICgpIHtcbiAgcmV0dXJuIHtcbiAgICB2YW9Db3VudDogMCxcbiAgICBidWZmZXJDb3VudDogMCxcbiAgICBlbGVtZW50c0NvdW50OiAwLFxuICAgIGZyYW1lYnVmZmVyQ291bnQ6IDAsXG4gICAgc2hhZGVyQ291bnQ6IDAsXG4gICAgdGV4dHVyZUNvdW50OiAwLFxuICAgIGN1YmVDb3VudDogMCxcbiAgICByZW5kZXJidWZmZXJDb3VudDogMCxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IDBcbiAgfVxufVxuXG52YXIgR0xfUVVFUllfUkVTVUxUX0VYVCA9IDB4ODg2NlxudmFyIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUID0gMHg4ODY3XG52YXIgR0xfVElNRV9FTEFQU0VEX0VYVCA9IDB4ODhCRlxuXG52YXIgY3JlYXRlVGltZXIgPSBmdW5jdGlvbiAoZ2wsIGV4dGVuc2lvbnMpIHtcbiAgaWYgKCFleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBRVUVSWSBQT09MIEJFR0lOXG4gIHZhciBxdWVyeVBvb2wgPSBbXVxuICBmdW5jdGlvbiBhbGxvY1F1ZXJ5ICgpIHtcbiAgICByZXR1cm4gcXVlcnlQb29sLnBvcCgpIHx8IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmNyZWF0ZVF1ZXJ5RVhUKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUXVlcnkgKHF1ZXJ5KSB7XG4gICAgcXVlcnlQb29sLnB1c2gocXVlcnkpXG4gIH1cbiAgLy8gUVVFUlkgUE9PTCBFTkRcblxuICB2YXIgcGVuZGluZ1F1ZXJpZXMgPSBbXVxuICBmdW5jdGlvbiBiZWdpblF1ZXJ5IChzdGF0cykge1xuICAgIHZhciBxdWVyeSA9IGFsbG9jUXVlcnkoKVxuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmJlZ2luUXVlcnlFWFQoR0xfVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpXG4gICAgcGVuZGluZ1F1ZXJpZXMucHVzaChxdWVyeSlcbiAgICBwdXNoU2NvcGVTdGF0cyhwZW5kaW5nUXVlcmllcy5sZW5ndGggLSAxLCBwZW5kaW5nUXVlcmllcy5sZW5ndGgsIHN0YXRzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUXVlcnkgKCkge1xuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmVuZFF1ZXJ5RVhUKEdMX1RJTUVfRUxBUFNFRF9FWFQpXG4gIH1cblxuICAvL1xuICAvLyBQZW5kaW5nIHN0YXRzIHBvb2wuXG4gIC8vXG4gIGZ1bmN0aW9uIFBlbmRpbmdTdGF0cyAoKSB7XG4gICAgdGhpcy5zdGFydFF1ZXJ5SW5kZXggPSAtMVxuICAgIHRoaXMuZW5kUXVlcnlJbmRleCA9IC0xXG4gICAgdGhpcy5zdW0gPSAwXG4gICAgdGhpcy5zdGF0cyA9IG51bGxcbiAgfVxuICB2YXIgcGVuZGluZ1N0YXRzUG9vbCA9IFtdXG4gIGZ1bmN0aW9uIGFsbG9jUGVuZGluZ1N0YXRzICgpIHtcbiAgICByZXR1cm4gcGVuZGluZ1N0YXRzUG9vbC5wb3AoKSB8fCBuZXcgUGVuZGluZ1N0YXRzKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUGVuZGluZ1N0YXRzIChwZW5kaW5nU3RhdHMpIHtcbiAgICBwZW5kaW5nU3RhdHNQb29sLnB1c2gocGVuZGluZ1N0YXRzKVxuICB9XG4gIC8vIFBlbmRpbmcgc3RhdHMgcG9vbCBlbmRcblxuICB2YXIgcGVuZGluZ1N0YXRzID0gW11cbiAgZnVuY3Rpb24gcHVzaFNjb3BlU3RhdHMgKHN0YXJ0LCBlbmQsIHN0YXRzKSB7XG4gICAgdmFyIHBzID0gYWxsb2NQZW5kaW5nU3RhdHMoKVxuICAgIHBzLnN0YXJ0UXVlcnlJbmRleCA9IHN0YXJ0XG4gICAgcHMuZW5kUXVlcnlJbmRleCA9IGVuZFxuICAgIHBzLnN1bSA9IDBcbiAgICBwcy5zdGF0cyA9IHN0YXRzXG4gICAgcGVuZGluZ1N0YXRzLnB1c2gocHMpXG4gIH1cblxuICAvLyB3ZSBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZyYW1lLFxuICAvLyBpbiBvcmRlciB0byB1cGRhdGUgZ3B1VGltZVxuICB2YXIgdGltZVN1bSA9IFtdXG4gIHZhciBxdWVyeVB0ciA9IFtdXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdmFyIHB0ciwgaVxuXG4gICAgdmFyIG4gPSBwZW5kaW5nUXVlcmllcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gUmVzZXJ2ZSBzcGFjZVxuICAgIHF1ZXJ5UHRyLmxlbmd0aCA9IE1hdGgubWF4KHF1ZXJ5UHRyLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bS5sZW5ndGggPSBNYXRoLm1heCh0aW1lU3VtLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bVswXSA9IDBcbiAgICBxdWVyeVB0clswXSA9IDBcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyB0aW1lciBxdWVyaWVzXG4gICAgdmFyIHF1ZXJ5VGltZSA9IDBcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdRdWVyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcXVlcnkgPSBwZW5kaW5nUXVlcmllc1tpXVxuICAgICAgaWYgKGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCkpIHtcbiAgICAgICAgcXVlcnlUaW1lICs9IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfRVhUKVxuICAgICAgICBmcmVlUXVlcnkocXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nUXVlcmllc1twdHIrK10gPSBxdWVyeVxuICAgICAgfVxuICAgICAgdGltZVN1bVtpICsgMV0gPSBxdWVyeVRpbWVcbiAgICAgIHF1ZXJ5UHRyW2kgKyAxXSA9IHB0clxuICAgIH1cbiAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSBwdHJcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyBzdGF0IHF1ZXJpZXNcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdTdGF0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN0YXRzID0gcGVuZGluZ1N0YXRzW2ldXG4gICAgICB2YXIgc3RhcnQgPSBzdGF0cy5zdGFydFF1ZXJ5SW5kZXhcbiAgICAgIHZhciBlbmQgPSBzdGF0cy5lbmRRdWVyeUluZGV4XG4gICAgICBzdGF0cy5zdW0gKz0gdGltZVN1bVtlbmRdIC0gdGltZVN1bVtzdGFydF1cbiAgICAgIHZhciBzdGFydFB0ciA9IHF1ZXJ5UHRyW3N0YXJ0XVxuICAgICAgdmFyIGVuZFB0ciA9IHF1ZXJ5UHRyW2VuZF1cbiAgICAgIGlmIChlbmRQdHIgPT09IHN0YXJ0UHRyKSB7XG4gICAgICAgIHN0YXRzLnN0YXRzLmdwdVRpbWUgKz0gc3RhdHMuc3VtIC8gMWU2XG4gICAgICAgIGZyZWVQZW5kaW5nU3RhdHMoc3RhdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0cy5zdGFydFF1ZXJ5SW5kZXggPSBzdGFydFB0clxuICAgICAgICBzdGF0cy5lbmRRdWVyeUluZGV4ID0gZW5kUHRyXG4gICAgICAgIHBlbmRpbmdTdGF0c1twdHIrK10gPSBzdGF0c1xuICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nU3RhdHMubGVuZ3RoID0gcHRyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luUXVlcnk6IGJlZ2luUXVlcnksXG4gICAgZW5kUXVlcnk6IGVuZFF1ZXJ5LFxuICAgIHB1c2hTY29wZVN0YXRzOiBwdXNoU2NvcGVTdGF0cyxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBnZXROdW1QZW5kaW5nUXVlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdRdWVyaWVzLmxlbmd0aFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXJ5UG9vbC5wdXNoLmFwcGx5KHF1ZXJ5UG9vbCwgcGVuZGluZ1F1ZXJpZXMpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5UG9vbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeS5kZWxldGVRdWVyeUVYVChxdWVyeVBvb2xbaV0pXG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSAwXG4gICAgICBxdWVyeVBvb2wubGVuZ3RoID0gMFxuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoID0gMFxuICAgICAgcXVlcnlQb29sLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cbn1cblxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQgPSAxNjM4NFxudmFyIEdMX0RFUFRIX0JVRkZFUl9CSVQgPSAyNTZcbnZhciBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgPSAxMDI0XG5cbnZhciBHTF9BUlJBWV9CVUZGRVIgPSAzNDk2MlxuXG52YXIgQ09OVEVYVF9MT1NUX0VWRU5UID0gJ3dlYmdsY29udGV4dGxvc3QnXG52YXIgQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCA9ICd3ZWJnbGNvbnRleHRyZXN0b3JlZCdcblxudmFyIERZTl9QUk9QID0gMVxudmFyIERZTl9DT05URVhUID0gMlxudmFyIERZTl9TVEFURSA9IDNcblxuZnVuY3Rpb24gZmluZCAoaGF5c3RhY2ssIG5lZWRsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiB3cmFwUkVHTCAoYXJncykge1xuICB2YXIgY29uZmlnID0gcGFyc2VBcmdzKGFyZ3MpXG4gIGlmICghY29uZmlnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBnbCA9IGNvbmZpZy5nbFxuICB2YXIgZ2xBdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKVxuICB2YXIgY29udGV4dExvc3QgPSBnbC5pc0NvbnRleHRMb3N0KClcblxuICB2YXIgZXh0ZW5zaW9uU3RhdGUgPSBjcmVhdGVFeHRlbnNpb25DYWNoZShnbCwgY29uZmlnKVxuICBpZiAoIWV4dGVuc2lvblN0YXRlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBzdHJpbmdTdG9yZSA9IGNyZWF0ZVN0cmluZ1N0b3JlKClcbiAgdmFyIHN0YXRzJCQxID0gc3RhdHMoKVxuICB2YXIgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvblN0YXRlLmV4dGVuc2lvbnNcbiAgdmFyIHRpbWVyID0gY3JlYXRlVGltZXIoZ2wsIGV4dGVuc2lvbnMpXG5cbiAgdmFyIFNUQVJUX1RJTUUgPSBjbG9jaygpXG4gIHZhciBXSURUSCA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aFxuICB2YXIgSEVJR0hUID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuXG4gIHZhciBjb250ZXh0U3RhdGUgPSB7XG4gICAgdGljazogMCxcbiAgICB0aW1lOiAwLFxuICAgIHZpZXdwb3J0V2lkdGg6IFdJRFRILFxuICAgIHZpZXdwb3J0SGVpZ2h0OiBIRUlHSFQsXG4gICAgZnJhbWVidWZmZXJXaWR0aDogV0lEVEgsXG4gICAgZnJhbWVidWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBkcmF3aW5nQnVmZmVyV2lkdGg6IFdJRFRILFxuICAgIGRyYXdpbmdCdWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpb1xuICB9XG4gIHZhciB1bmlmb3JtU3RhdGUgPSB7fVxuICB2YXIgZHJhd1N0YXRlID0ge1xuICAgIGVsZW1lbnRzOiBudWxsLFxuICAgIHByaW1pdGl2ZTogNCwgLy8gR0xfVFJJQU5HTEVTXG4gICAgY291bnQ6IC0xLFxuICAgIG9mZnNldDogMCxcbiAgICBpbnN0YW5jZXM6IC0xXG4gIH1cblxuICB2YXIgbGltaXRzID0gd3JhcExpbWl0cyhnbCwgZXh0ZW5zaW9ucylcbiAgdmFyIGJ1ZmZlclN0YXRlID0gd3JhcEJ1ZmZlclN0YXRlKFxuICAgIGdsLFxuICAgIHN0YXRzJCQxLFxuICAgIGNvbmZpZyxcbiAgICBkZXN0cm95QnVmZmVyKVxuICB2YXIgYXR0cmlidXRlU3RhdGUgPSB3cmFwQXR0cmlidXRlU3RhdGUoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgc3RhdHMkJDEsXG4gICAgYnVmZmVyU3RhdGUpXG4gIGZ1bmN0aW9uIGRlc3Ryb3lCdWZmZXIgKGJ1ZmZlcikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVTdGF0ZS5kZXN0cm95QnVmZmVyKGJ1ZmZlcilcbiAgfVxuICB2YXIgZWxlbWVudFN0YXRlID0gd3JhcEVsZW1lbnRzU3RhdGUoZ2wsIGV4dGVuc2lvbnMsIGJ1ZmZlclN0YXRlLCBzdGF0cyQkMSlcbiAgdmFyIHNoYWRlclN0YXRlID0gd3JhcFNoYWRlclN0YXRlKGdsLCBzdHJpbmdTdG9yZSwgc3RhdHMkJDEsIGNvbmZpZylcbiAgdmFyIHRleHR1cmVTdGF0ZSA9IGNyZWF0ZVRleHR1cmVTZXQoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgZnVuY3Rpb24gKCkgeyBjb3JlLnByb2NzLnBvbGwoKSB9LFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBzdGF0cyQkMSxcbiAgICBjb25maWcpXG4gIHZhciByZW5kZXJidWZmZXJTdGF0ZSA9IHdyYXBSZW5kZXJidWZmZXJzKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzJCQxLCBjb25maWcpXG4gIHZhciBmcmFtZWJ1ZmZlclN0YXRlID0gd3JhcEZCT1N0YXRlKFxuICAgIGdsLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgbGltaXRzLFxuICAgIHRleHR1cmVTdGF0ZSxcbiAgICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgICBzdGF0cyQkMSlcbiAgdmFyIGNvcmUgPSByZWdsQ29yZShcbiAgICBnbCxcbiAgICBzdHJpbmdTdG9yZSxcbiAgICBleHRlbnNpb25zLFxuICAgIGxpbWl0cyxcbiAgICBidWZmZXJTdGF0ZSxcbiAgICBlbGVtZW50U3RhdGUsXG4gICAgdGV4dHVyZVN0YXRlLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgdW5pZm9ybVN0YXRlLFxuICAgIGF0dHJpYnV0ZVN0YXRlLFxuICAgIHNoYWRlclN0YXRlLFxuICAgIGRyYXdTdGF0ZSxcbiAgICBjb250ZXh0U3RhdGUsXG4gICAgdGltZXIsXG4gICAgY29uZmlnKVxuICB2YXIgcmVhZFBpeGVscyA9IHdyYXBSZWFkUGl4ZWxzKFxuICAgIGdsLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgY29yZS5wcm9jcy5wb2xsLFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBnbEF0dHJpYnV0ZXMsIGV4dGVuc2lvbnMsIGxpbWl0cylcblxuICB2YXIgbmV4dFN0YXRlID0gY29yZS5uZXh0XG4gIHZhciBjYW52YXMgPSBnbC5jYW52YXNcblxuICB2YXIgcmFmQ2FsbGJhY2tzID0gW11cbiAgdmFyIGxvc3NDYWxsYmFja3MgPSBbXVxuICB2YXIgcmVzdG9yZUNhbGxiYWNrcyA9IFtdXG4gIHZhciBkZXN0cm95Q2FsbGJhY2tzID0gW2NvbmZpZy5vbkRlc3Ryb3ldXG5cbiAgdmFyIGFjdGl2ZVJBRiA9IG51bGxcbiAgZnVuY3Rpb24gaGFuZGxlUkFGICgpIHtcbiAgICBpZiAocmFmQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzY2hlZHVsZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRilcblxuICAgIC8vIHBvbGwgZm9yIGNoYW5nZXNcbiAgICBwb2xsKClcblxuICAgIC8vIGZpcmUgYSBjYWxsYmFjayBmb3IgYWxsIHBlbmRpbmcgcmFmc1xuICAgIGZvciAodmFyIGkgPSByYWZDYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjYiA9IHJhZkNhbGxiYWNrc1tpXVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKGNvbnRleHRTdGF0ZSwgbnVsbCwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmbHVzaCBhbGwgcGVuZGluZyB3ZWJnbCBjYWxsc1xuICAgIGdsLmZsdXNoKClcblxuICAgIC8vIHBvbGwgR1BVIHRpbWVycyAqYWZ0ZXIqIGdsLmZsdXNoIHNvIHdlIGRvbid0IGRlbGF5IGNvbW1hbmQgZGlzcGF0Y2hcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRSQUYgKCkge1xuICAgIGlmICghYWN0aXZlUkFGICYmIHJhZkNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBhY3RpdmVSQUYgPSByYWYubmV4dChoYW5kbGVSQUYpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFJBRiAoKSB7XG4gICAgaWYgKGFjdGl2ZVJBRikge1xuICAgICAgcmFmLmNhbmNlbChoYW5kbGVSQUYpXG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gc2V0IGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSB0cnVlXG5cbiAgICAvLyBwYXVzZSByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZVxuICAgIHN0b3BSQUYoKVxuXG4gICAgLy8gbG9zZSBjb250ZXh0XG4gICAgbG9zc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0UmVzdG9yZWQgKGV2ZW50KSB7XG4gICAgLy8gY2xlYXIgZXJyb3IgY29kZVxuICAgIGdsLmdldEVycm9yKClcblxuICAgIC8vIGNsZWFyIGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSBmYWxzZVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGV4dGVuc2lvblN0YXRlLnJlc3RvcmUoKVxuICAgIHNoYWRlclN0YXRlLnJlc3RvcmUoKVxuICAgIGJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIHRleHR1cmVTdGF0ZS5yZXN0b3JlKClcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5yZXN0b3JlKClcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIGF0dHJpYnV0ZVN0YXRlLnJlc3RvcmUoKVxuICAgIGlmICh0aW1lcikge1xuICAgICAgdGltZXIucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG5cbiAgICAvLyByZXN0YXJ0IFJBRlxuICAgIHN0YXJ0UkFGKClcblxuICAgIC8vIHJlc3RvcmUgY29udGV4dFxuICAgIHJlc3RvcmVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNhbnZhcykge1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MsIGZhbHNlKVxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICByYWZDYWxsYmFja3MubGVuZ3RoID0gMFxuICAgIHN0b3BSQUYoKVxuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OVEVYVF9MT1NUX0VWRU5ULCBoYW5kbGVDb250ZXh0TG9zcylcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZClcbiAgICB9XG5cbiAgICBzaGFkZXJTdGF0ZS5jbGVhcigpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgcmVuZGVyYnVmZmVyU3RhdGUuY2xlYXIoKVxuICAgIHRleHR1cmVTdGF0ZS5jbGVhcigpXG4gICAgZWxlbWVudFN0YXRlLmNsZWFyKClcbiAgICBidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgYXR0cmlidXRlU3RhdGUuY2xlYXIoKVxuXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci5jbGVhcigpXG4gICAgfVxuXG4gICAgZGVzdHJveUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlUHJvY2VkdXJlIChvcHRpb25zKSB7XG4gICAgY2hlY2skMSghIW9wdGlvbnMsICdpbnZhbGlkIGFyZ3MgdG8gcmVnbCh7Li4ufSknKVxuICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJncyB0byByZWdsKHsuLi59KScpXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuTmVzdGVkT3B0aW9ucyAob3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IGV4dGVuZCh7fSwgb3B0aW9ucylcbiAgICAgIGRlbGV0ZSByZXN1bHQudW5pZm9ybXNcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXR0cmlidXRlc1xuICAgICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0XG4gICAgICBkZWxldGUgcmVzdWx0LnZhb1xuXG4gICAgICBpZiAoJ3N0ZW5jaWwnIGluIHJlc3VsdCAmJiByZXN1bHQuc3RlbmNpbC5vcCkge1xuICAgICAgICByZXN1bHQuc3RlbmNpbC5vcEJhY2sgPSByZXN1bHQuc3RlbmNpbC5vcEZyb250ID0gcmVzdWx0LnN0ZW5jaWwub3BcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zdGVuY2lsLm9wXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlc3VsdCkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHJlc3VsdFtuYW1lXVxuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbbmFtZV1cbiAgICAgICAgICBPYmplY3Qua2V5cyhjaGlsZCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWUgKyAnLicgKyBwcm9wXSA9IGNoaWxkW3Byb3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVyZ2UoJ2JsZW5kJylcbiAgICAgIG1lcmdlKCdkZXB0aCcpXG4gICAgICBtZXJnZSgnY3VsbCcpXG4gICAgICBtZXJnZSgnc3RlbmNpbCcpXG4gICAgICBtZXJnZSgncG9seWdvbk9mZnNldCcpXG4gICAgICBtZXJnZSgnc2Npc3NvcicpXG4gICAgICBtZXJnZSgnc2FtcGxlJylcblxuICAgICAgaWYgKCd2YW8nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LnZhbyA9IG9wdGlvbnMudmFvXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXBhcmF0ZUR5bmFtaWMgKG9iamVjdCwgdXNlQXJyYXlzKSB7XG4gICAgICB2YXIgc3RhdGljSXRlbXMgPSB7fVxuICAgICAgdmFyIGR5bmFtaWNJdGVtcyA9IHt9XG4gICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rbb3B0aW9uXVxuICAgICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XG4gICAgICAgICAgZHluYW1pY0l0ZW1zW29wdGlvbl0gPSBkeW5hbWljLnVuYm94KHZhbHVlLCBvcHRpb24pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodXNlQXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICBkeW5hbWljSXRlbXNbb3B0aW9uXSA9IGR5bmFtaWMudW5ib3godmFsdWUsIG9wdGlvbilcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpY0l0ZW1zW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGR5bmFtaWNJdGVtcyxcbiAgICAgICAgc3RhdGljOiBzdGF0aWNJdGVtc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyZWF0IGNvbnRleHQgdmFyaWFibGVzIHNlcGFyYXRlIGZyb20gb3RoZXIgZHluYW1pYyB2YXJpYWJsZXNcbiAgICB2YXIgY29udGV4dCA9IHNlcGFyYXRlRHluYW1pYyhvcHRpb25zLmNvbnRleHQgfHwge30sIHRydWUpXG4gICAgdmFyIHVuaWZvcm1zID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMudW5pZm9ybXMgfHwge30sIHRydWUpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9LCBmYWxzZSlcbiAgICB2YXIgb3B0cyA9IHNlcGFyYXRlRHluYW1pYyhmbGF0dGVuTmVzdGVkT3B0aW9ucyhvcHRpb25zKSwgZmFsc2UpXG5cbiAgICB2YXIgc3RhdHMkJDEgPSB7XG4gICAgICBncHVUaW1lOiAwLjAsXG4gICAgICBjcHVUaW1lOiAwLjAsXG4gICAgICBjb3VudDogMFxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGNvcmUuY29tcGlsZShvcHRzLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgc3RhdHMkJDEpXG5cbiAgICB2YXIgZHJhdyA9IGNvbXBpbGVkLmRyYXdcbiAgICB2YXIgYmF0Y2ggPSBjb21waWxlZC5iYXRjaFxuICAgIHZhciBzY29wZSA9IGNvbXBpbGVkLnNjb3BlXG5cbiAgICAvLyBGSVhNRTogd2Ugc2hvdWxkIG1vZGlmeSBjb2RlIGdlbmVyYXRpb24gZm9yIGJhdGNoIGNvbW1hbmRzIHNvIHRoaXNcbiAgICAvLyBpc24ndCBuZWNlc3NhcnlcbiAgICB2YXIgRU1QVFlfQVJSQVkgPSBbXVxuICAgIGZ1bmN0aW9uIHJlc2VydmUgKGNvdW50KSB7XG4gICAgICB3aGlsZSAoRU1QVFlfQVJSQVkubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgRU1QVFlfQVJSQVkucHVzaChudWxsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUkVHTENvbW1hbmQgKGFyZ3MsIGJvZHkpIHtcbiAgICAgIHZhciBpXG4gICAgICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBhcmdzLCAwKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3M7ICsraSkge1xuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBib2R5LCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNjb3BlLmNhbGwodGhpcywgYXJnc1tpXSwgYm9keSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmNhbGwodGhpcywgYXJncywgYm9keSwgMClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGFyZ3MgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgcmVzZXJ2ZShhcmdzIHwgMCksIGFyZ3MgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgYXJncywgYXJncy5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkcmF3LmNhbGwodGhpcywgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kKFJFR0xDb21tYW5kLCB7XG4gICAgICBzdGF0czogc3RhdHMkJDEsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBpbGVkLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2V0RkJPID0gZnJhbWVidWZmZXJTdGF0ZS5zZXRGQk8gPSBjb21waWxlUHJvY2VkdXJlKHtcbiAgICBmcmFtZWJ1ZmZlcjogZHluYW1pYy5kZWZpbmUuY2FsbChudWxsLCBEWU5fUFJPUCwgJ2ZyYW1lYnVmZmVyJylcbiAgfSlcblxuICBmdW5jdGlvbiBjbGVhckltcGwgKF8sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xlYXJGbGFncyA9IDBcbiAgICBjb3JlLnByb2NzLnBvbGwoKVxuXG4gICAgdmFyIGMgPSBvcHRpb25zLmNvbG9yXG4gICAgaWYgKGMpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoK2NbMF0gfHwgMCwgK2NbMV0gfHwgMCwgK2NbMl0gfHwgMCwgK2NbM10gfHwgMClcbiAgICAgIGNsZWFyRmxhZ3MgfD0gR0xfQ09MT1JfQlVGRkVSX0JJVFxuICAgIH1cbiAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICBnbC5jbGVhckRlcHRoKCtvcHRpb25zLmRlcHRoKVxuICAgICAgY2xlYXJGbGFncyB8PSBHTF9ERVBUSF9CVUZGRVJfQklUXG4gICAgfVxuICAgIGlmICgnc3RlbmNpbCcgaW4gb3B0aW9ucykge1xuICAgICAgZ2wuY2xlYXJTdGVuY2lsKG9wdGlvbnMuc3RlbmNpbCB8IDApXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX1NURU5DSUxfQlVGRkVSX0JJVFxuICAgIH1cblxuICAgIGNoZWNrJDEoISFjbGVhckZsYWdzLCAnY2FsbGVkIHJlZ2wuY2xlYXIgd2l0aCBubyBidWZmZXIgc3BlY2lmaWVkJylcbiAgICBnbC5jbGVhcihjbGVhckZsYWdzKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIgKG9wdGlvbnMpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG4gICAgICAncmVnbC5jbGVhcigpIHRha2VzIGFuIG9iamVjdCBhcyBpbnB1dCcpXG4gICAgaWYgKCdmcmFtZWJ1ZmZlcicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuZnJhbWVidWZmZXIgJiZcbiAgICAgICAgICBvcHRpb25zLmZyYW1lYnVmZmVyX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXJDdWJlJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgIHNldEZCTyhleHRlbmQoe1xuICAgICAgICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXIuZmFjZXNbaV1cbiAgICAgICAgICB9LCBvcHRpb25zKSwgY2xlYXJJbXBsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRGQk8ob3B0aW9ucywgY2xlYXJJbXBsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhckltcGwobnVsbCwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcmFtZSAoY2IpIHtcbiAgICBjaGVjayQxLnR5cGUoY2IsICdmdW5jdGlvbicsICdyZWdsLmZyYW1lKCkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICByYWZDYWxsYmFja3MucHVzaChjYilcblxuICAgIGZ1bmN0aW9uIGNhbmNlbCAoKSB7XG4gICAgICAvLyBGSVhNRTogIHNob3VsZCB3ZSBjaGVjayBzb21ldGhpbmcgb3RoZXIgdGhhbiBlcXVhbHMgY2IgaGVyZT9cbiAgICAgIC8vIHdoYXQgaWYgYSB1c2VyIGNhbGxzIGZyYW1lIHR3aWNlIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suLi5cbiAgICAgIC8vXG4gICAgICB2YXIgaSA9IGZpbmQocmFmQ2FsbGJhY2tzLCBjYilcbiAgICAgIGNoZWNrJDEoaSA+PSAwLCAnY2Fubm90IGNhbmNlbCBhIGZyYW1lIHR3aWNlJylcbiAgICAgIGZ1bmN0aW9uIHBlbmRpbmdDYW5jZWwgKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kKHJhZkNhbGxiYWNrcywgcGVuZGluZ0NhbmNlbClcbiAgICAgICAgcmFmQ2FsbGJhY2tzW2luZGV4XSA9IHJhZkNhbGxiYWNrc1tyYWZDYWxsYmFja3MubGVuZ3RoIC0gMV1cbiAgICAgICAgcmFmQ2FsbGJhY2tzLmxlbmd0aCAtPSAxXG4gICAgICAgIGlmIChyYWZDYWxsYmFja3MubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBzdG9wUkFGKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFmQ2FsbGJhY2tzW2ldID0gcGVuZGluZ0NhbmNlbFxuICAgIH1cblxuICAgIHN0YXJ0UkFGKClcblxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGNhbmNlbFxuICAgIH1cbiAgfVxuXG4gIC8vIHBvbGwgdmlld3BvcnRcbiAgZnVuY3Rpb24gcG9sbFZpZXdwb3J0ICgpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBuZXh0U3RhdGUudmlld3BvcnRcbiAgICB2YXIgc2Npc3NvckJveCA9IG5leHRTdGF0ZS5zY2lzc29yX2JveFxuICAgIHZpZXdwb3J0WzBdID0gdmlld3BvcnRbMV0gPSBzY2lzc29yQm94WzBdID0gc2Npc3NvckJveFsxXSA9IDBcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZnJhbWVidWZmZXJXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZHJhd2luZ0J1ZmZlcldpZHRoID1cbiAgICAgIHZpZXdwb3J0WzJdID1cbiAgICAgIHNjaXNzb3JCb3hbMl0gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGhcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRIZWlnaHQgPVxuICAgICAgY29udGV4dFN0YXRlLmZyYW1lYnVmZmVySGVpZ2h0ID1cbiAgICAgIGNvbnRleHRTdGF0ZS5kcmF3aW5nQnVmZmVySGVpZ2h0ID1cbiAgICAgIHZpZXdwb3J0WzNdID1cbiAgICAgIHNjaXNzb3JCb3hbM10gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0XG4gIH1cblxuICBmdW5jdGlvbiBwb2xsICgpIHtcbiAgICBjb250ZXh0U3RhdGUudGljayArPSAxXG4gICAgY29udGV4dFN0YXRlLnRpbWUgPSBub3coKVxuICAgIHBvbGxWaWV3cG9ydCgpXG4gICAgY29yZS5wcm9jcy5wb2xsKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgIHRleHR1cmVTdGF0ZS5yZWZyZXNoKClcbiAgICBwb2xsVmlld3BvcnQoKVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci51cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgcmV0dXJuIChjbG9jaygpIC0gU1RBUlRfVElNRSkgLyAxMDAwLjBcbiAgfVxuXG4gIHJlZnJlc2goKVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyIChldmVudCwgY2FsbGJhY2spIHtcbiAgICBjaGVjayQxLnR5cGUoY2FsbGJhY2ssICdmdW5jdGlvbicsICdsaXN0ZW5lciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuXG4gICAgdmFyIGNhbGxiYWNrc1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgcmV0dXJuIGZyYW1lKGNhbGxiYWNrKVxuICAgICAgY2FzZSAnbG9zdCc6XG4gICAgICAgIGNhbGxiYWNrcyA9IGxvc3NDYWxsYmFja3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Jlc3RvcmUnOlxuICAgICAgICBjYWxsYmFja3MgPSByZXN0b3JlQ2FsbGJhY2tzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgY2FsbGJhY2tzID0gZGVzdHJveUNhbGxiYWNrc1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBldmVudCwgbXVzdCBiZSBvbmUgb2YgZnJhbWUsbG9zdCxyZXN0b3JlLGRlc3Ryb3knKVxuICAgIH1cblxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2ldID0gY2FsbGJhY2tzW2NhbGxiYWNrcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgY2FsbGJhY2tzLnBvcCgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcmVnbCA9IGV4dGVuZChjb21waWxlUHJvY2VkdXJlLCB7XG4gICAgLy8gQ2xlYXIgY3VycmVudCBGQk9cbiAgICBjbGVhcjogY2xlYXIsXG5cbiAgICAvLyBTaG9ydCBjdXRzIGZvciBkeW5hbWljIHZhcmlhYmxlc1xuICAgIHByb3A6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1BST1ApLFxuICAgIGNvbnRleHQ6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX0NPTlRFWFQpLFxuICAgIHRoaXM6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1NUQVRFKSxcblxuICAgIC8vIGV4ZWN1dGVzIGFuIGVtcHR5IGRyYXcgY29tbWFuZFxuICAgIGRyYXc6IGNvbXBpbGVQcm9jZWR1cmUoe30pLFxuXG4gICAgLy8gUmVzb3VyY2VzXG4gICAgYnVmZmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGJ1ZmZlclN0YXRlLmNyZWF0ZShvcHRpb25zLCBHTF9BUlJBWV9CVUZGRVIsIGZhbHNlLCBmYWxzZSlcbiAgICB9LFxuICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRTdGF0ZS5jcmVhdGUob3B0aW9ucywgZmFsc2UpXG4gICAgfSxcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQsXG4gICAgY3ViZTogdGV4dHVyZVN0YXRlLmNyZWF0ZUN1YmUsXG4gICAgcmVuZGVyYnVmZmVyOiByZW5kZXJidWZmZXJTdGF0ZS5jcmVhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUuY3JlYXRlLFxuICAgIGZyYW1lYnVmZmVyQ3ViZTogZnJhbWVidWZmZXJTdGF0ZS5jcmVhdGVDdWJlLFxuICAgIHZhbzogYXR0cmlidXRlU3RhdGUuY3JlYXRlVkFPLFxuXG4gICAgLy8gRXhwb3NlIGNvbnRleHQgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXM6IGdsQXR0cmlidXRlcyxcblxuICAgIC8vIEZyYW1lIHJlbmRlcmluZ1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBvbjogYWRkTGlzdGVuZXIsXG5cbiAgICAvLyBTeXN0ZW0gbGltaXRzXG4gICAgbGltaXRzOiBsaW1pdHMsXG4gICAgaGFzRXh0ZW5zaW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YobmFtZS50b0xvd2VyQ2FzZSgpKSA+PSAwXG4gICAgfSxcblxuICAgIC8vIFJlYWQgcGl4ZWxzXG4gICAgcmVhZDogcmVhZFBpeGVscyxcblxuICAgIC8vIERlc3Ryb3kgcmVnbCBhbmQgYWxsIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAgZGVzdHJveTogZGVzdHJveSxcblxuICAgIC8vIERpcmVjdCBHTCBzdGF0ZSBtYW5pcHVsYXRpb25cbiAgICBfZ2w6IGdsLFxuICAgIF9yZWZyZXNoOiByZWZyZXNoLFxuXG4gICAgcG9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbCgpXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgdGltZXIudXBkYXRlKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ3VycmVudCB0aW1lXG4gICAgbm93OiBub3csXG5cbiAgICAvLyByZWdsIFN0YXRpc3RpY3MgSW5mb3JtYXRpb25cbiAgICBzdGF0czogc3RhdHMkJDFcbiAgfSlcblxuICBjb25maWcub25Eb25lKG51bGwsIHJlZ2wpXG5cbiAgcmV0dXJuIHJlZ2xcbn1cblxucmV0dXJuIHdyYXBSRUdMO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnbC5qcy5tYXBcbiIsIm1vZHVsZS5leHBvcnRzID1cbiAgZ2xvYmFsLnBlcmZvcm1hbmNlICYmXG4gIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gIH0gOiBEYXRlLm5vdyB8fCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZVxuICB9XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG52YXIgcm9idXN0RGlmZiA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VidHJhY3RcIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcblxudmFyIE5VTV9FWFBBTkQgPSA2XG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uKG4pIHtcbiAgdmFyIGZuID1cbiAgICBuID09PSAzID8gaW5TcGhlcmUzIDpcbiAgICBuID09PSA0ID8gaW5TcGhlcmU0IDpcbiAgICBuID09PSA1ID8gaW5TcGhlcmU1IDogaW5TcGhlcmU2O1xuXG4gIHJldHVybiBmbihyb2J1c3RTdW0sIHJvYnVzdERpZmYsIHR3b1Byb2R1Y3QsIHJvYnVzdFNjYWxlKVxufVxuXG5mdW5jdGlvbiBpblNwaGVyZTAoKSB7IHJldHVybiAwIH1cbmZ1bmN0aW9uIGluU3BoZXJlMSgpIHsgcmV0dXJuIDAgfVxuZnVuY3Rpb24gaW5TcGhlcmUyKCkgeyByZXR1cm4gMCB9XG5cbmZ1bmN0aW9uIGluU3BoZXJlMyhzdW0sIGRpZmYsIHByb2QsIHNjYWxlKSB7XG4gIGZ1bmN0aW9uIGV4YWN0SW5TcGhlcmUzKG0wLCBtMSwgbTIpIHtcbiAgICB2YXIgdzAgPSBwcm9kKG0wWzBdLCBtMFswXSlcbiAgICB2YXIgdzBtMSA9IHNjYWxlKHcwLCBtMVswXSlcbiAgICB2YXIgdzBtMiA9IHNjYWxlKHcwLCBtMlswXSlcbiAgICB2YXIgdzEgPSBwcm9kKG0xWzBdLCBtMVswXSlcbiAgICB2YXIgdzFtMCA9IHNjYWxlKHcxLCBtMFswXSlcbiAgICB2YXIgdzFtMiA9IHNjYWxlKHcxLCBtMlswXSlcbiAgICB2YXIgdzIgPSBwcm9kKG0yWzBdLCBtMlswXSlcbiAgICB2YXIgdzJtMCA9IHNjYWxlKHcyLCBtMFswXSlcbiAgICB2YXIgdzJtMSA9IHNjYWxlKHcyLCBtMVswXSlcbiAgICB2YXIgcCA9IHN1bShkaWZmKHcybTEsIHcxbTIpLCBkaWZmKHcxbTAsIHcwbTEpKVxuICAgIHZhciBuID0gZGlmZih3Mm0wLCB3MG0yKVxuICAgIHZhciBkID0gZGlmZihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxuICByZXR1cm4gZXhhY3RJblNwaGVyZTNcbn1cblxuZnVuY3Rpb24gaW5TcGhlcmU0KHN1bSwgZGlmZiwgcHJvZCwgc2NhbGUpIHtcbiAgZnVuY3Rpb24gZXhhY3RJblNwaGVyZTQobTAsIG0xLCBtMiwgbTMpIHtcbiAgICB2YXIgdzAgPSBzdW0ocHJvZChtMFswXSwgbTBbMF0pLCBwcm9kKG0wWzFdLCBtMFsxXSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcxID0gc3VtKHByb2QobTFbMF0sIG0xWzBdKSwgcHJvZChtMVsxXSwgbTFbMV0pKVxuICAgIHZhciB3MW0wID0gc2NhbGUodzEsIG0wWzBdKVxuICAgIHZhciB3MW0yID0gc2NhbGUodzEsIG0yWzBdKVxuICAgIHZhciB3MW0zID0gc2NhbGUodzEsIG0zWzBdKVxuICAgIHZhciB3MiA9IHN1bShwcm9kKG0yWzBdLCBtMlswXSksIHByb2QobTJbMV0sIG0yWzFdKSlcbiAgICB2YXIgdzJtMCA9IHNjYWxlKHcyLCBtMFswXSlcbiAgICB2YXIgdzJtMSA9IHNjYWxlKHcyLCBtMVswXSlcbiAgICB2YXIgdzJtMyA9IHNjYWxlKHcyLCBtM1swXSlcbiAgICB2YXIgdzMgPSBzdW0ocHJvZChtM1swXSwgbTNbMF0pLCBwcm9kKG0zWzFdLCBtM1sxXSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHAgPSBzdW0oc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCBzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSkpXG4gICAgdmFyIGQgPSBkaWZmKHAsIG4pXG4gICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXVxuICB9XG4gIHJldHVybiBleGFjdEluU3BoZXJlNFxufVxuXG5cbmZ1bmN0aW9uIGluU3BoZXJlNShzdW0sIGRpZmYsIHByb2QsIHNjYWxlKSB7XG4gIGZ1bmN0aW9uIGV4YWN0SW5TcGhlcmU1KG0wLCBtMSwgbTIsIG0zLCBtNCkge1xuICAgIHZhciB3MCA9IHN1bShwcm9kKG0wWzBdLCBtMFswXSksIHN1bShwcm9kKG0wWzFdLCBtMFsxXSksIHByb2QobTBbMl0sIG0wWzJdKSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcwbTQgPSBzY2FsZSh3MCwgbTRbMF0pXG4gICAgdmFyIHcxID0gc3VtKHByb2QobTFbMF0sIG0xWzBdKSwgc3VtKHByb2QobTFbMV0sIG0xWzFdKSwgcHJvZChtMVsyXSwgbTFbMl0pKSlcbiAgICB2YXIgdzFtMCA9IHNjYWxlKHcxLCBtMFswXSlcbiAgICB2YXIgdzFtMiA9IHNjYWxlKHcxLCBtMlswXSlcbiAgICB2YXIgdzFtMyA9IHNjYWxlKHcxLCBtM1swXSlcbiAgICB2YXIgdzFtNCA9IHNjYWxlKHcxLCBtNFswXSlcbiAgICB2YXIgdzIgPSBzdW0ocHJvZChtMlswXSwgbTJbMF0pLCBzdW0ocHJvZChtMlsxXSwgbTJbMV0pLCBwcm9kKG0yWzJdLCBtMlsyXSkpKVxuICAgIHZhciB3Mm0wID0gc2NhbGUodzIsIG0wWzBdKVxuICAgIHZhciB3Mm0xID0gc2NhbGUodzIsIG0xWzBdKVxuICAgIHZhciB3Mm0zID0gc2NhbGUodzIsIG0zWzBdKVxuICAgIHZhciB3Mm00ID0gc2NhbGUodzIsIG00WzBdKVxuICAgIHZhciB3MyA9IHN1bShwcm9kKG0zWzBdLCBtM1swXSksIHN1bShwcm9kKG0zWzFdLCBtM1sxXSksIHByb2QobTNbMl0sIG0zWzJdKSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHczbTQgPSBzY2FsZSh3MywgbTRbMF0pXG4gICAgdmFyIHc0ID0gc3VtKHByb2QobTRbMF0sIG00WzBdKSwgc3VtKHByb2QobTRbMV0sIG00WzFdKSwgcHJvZChtNFsyXSwgbTRbMl0pKSlcbiAgICB2YXIgdzRtMCA9IHNjYWxlKHc0LCBtMFswXSlcbiAgICB2YXIgdzRtMSA9IHNjYWxlKHc0LCBtMVswXSlcbiAgICB2YXIgdzRtMiA9IHNjYWxlKHc0LCBtMlswXSlcbiAgICB2YXIgdzRtMyA9IHNjYWxlKHc0LCBtM1swXSlcbiAgICB2YXIgcCA9IHN1bShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCAtbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0zWzJdKSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCAtbTRbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNFsxXSkpKSwgLW0xWzJdKSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0zWzJdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBtMFsyXSkpKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW0xWzJdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tM1syXSkpKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNFsyXSkpKSlcbiAgICB2YXIgZCA9IGRpZmYocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cblxuICAgIHJldHVybiBleGFjdEluU3BoZXJlNVxufVxuXG5mdW5jdGlvbiBpblNwaGVyZTYoc3VtLCBkaWZmLCBwcm9kLCBzY2FsZSkge1xuICBmdW5jdGlvbiBleGFjdEluU3BoZXJlNihtMCwgbTEsIG0yLCBtMywgbTQsIG01KSB7XG4gICAgdmFyIHcwID0gc3VtKHN1bShwcm9kKG0wWzBdLCBtMFswXSksIHByb2QobTBbMV0sIG0wWzFdKSksIHN1bShwcm9kKG0wWzJdLCBtMFsyXSksIHByb2QobTBbM10sIG0wWzNdKSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcwbTQgPSBzY2FsZSh3MCwgbTRbMF0pXG4gICAgdmFyIHcwbTUgPSBzY2FsZSh3MCwgbTVbMF0pXG4gICAgdmFyIHcxID0gc3VtKHN1bShwcm9kKG0xWzBdLCBtMVswXSksIHByb2QobTFbMV0sIG0xWzFdKSksIHN1bShwcm9kKG0xWzJdLCBtMVsyXSksIHByb2QobTFbM10sIG0xWzNdKSkpXG4gICAgdmFyIHcxbTAgPSBzY2FsZSh3MSwgbTBbMF0pXG4gICAgdmFyIHcxbTIgPSBzY2FsZSh3MSwgbTJbMF0pXG4gICAgdmFyIHcxbTMgPSBzY2FsZSh3MSwgbTNbMF0pXG4gICAgdmFyIHcxbTQgPSBzY2FsZSh3MSwgbTRbMF0pXG4gICAgdmFyIHcxbTUgPSBzY2FsZSh3MSwgbTVbMF0pXG4gICAgdmFyIHcyID0gc3VtKHN1bShwcm9kKG0yWzBdLCBtMlswXSksIHByb2QobTJbMV0sIG0yWzFdKSksIHN1bShwcm9kKG0yWzJdLCBtMlsyXSksIHByb2QobTJbM10sIG0yWzNdKSkpXG4gICAgdmFyIHcybTAgPSBzY2FsZSh3MiwgbTBbMF0pXG4gICAgdmFyIHcybTEgPSBzY2FsZSh3MiwgbTFbMF0pXG4gICAgdmFyIHcybTMgPSBzY2FsZSh3MiwgbTNbMF0pXG4gICAgdmFyIHcybTQgPSBzY2FsZSh3MiwgbTRbMF0pXG4gICAgdmFyIHcybTUgPSBzY2FsZSh3MiwgbTVbMF0pXG4gICAgdmFyIHczID0gc3VtKHN1bShwcm9kKG0zWzBdLCBtM1swXSksIHByb2QobTNbMV0sIG0zWzFdKSksIHN1bShwcm9kKG0zWzJdLCBtM1syXSksIHByb2QobTNbM10sIG0zWzNdKSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHczbTQgPSBzY2FsZSh3MywgbTRbMF0pXG4gICAgdmFyIHczbTUgPSBzY2FsZSh3MywgbTVbMF0pXG4gICAgdmFyIHc0ID0gc3VtKHN1bShwcm9kKG00WzBdLCBtNFswXSksIHByb2QobTRbMV0sIG00WzFdKSksIHN1bShwcm9kKG00WzJdLCBtNFsyXSksIHByb2QobTRbM10sIG00WzNdKSkpXG4gICAgdmFyIHc0bTAgPSBzY2FsZSh3NCwgbTBbMF0pXG4gICAgdmFyIHc0bTEgPSBzY2FsZSh3NCwgbTFbMF0pXG4gICAgdmFyIHc0bTIgPSBzY2FsZSh3NCwgbTJbMF0pXG4gICAgdmFyIHc0bTMgPSBzY2FsZSh3NCwgbTNbMF0pXG4gICAgdmFyIHc0bTUgPSBzY2FsZSh3NCwgbTVbMF0pXG4gICAgdmFyIHc1ID0gc3VtKHN1bShwcm9kKG01WzBdLCBtNVswXSksIHByb2QobTVbMV0sIG01WzFdKSksIHN1bShwcm9kKG01WzJdLCBtNVsyXSksIHByb2QobTVbM10sIG01WzNdKSkpXG4gICAgdmFyIHc1bTAgPSBzY2FsZSh3NSwgbTBbMF0pXG4gICAgdmFyIHc1bTEgPSBzY2FsZSh3NSwgbTFbMF0pXG4gICAgdmFyIHc1bTIgPSBzY2FsZSh3NSwgbTJbMF0pXG4gICAgdmFyIHc1bTMgPSBzY2FsZSh3NSwgbTNbMF0pXG4gICAgdmFyIHc1bTQgPSBzY2FsZSh3NSwgbTRbMF0pXG4gICAgdmFyIHAgPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtMVszXSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTJbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtM1szXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCAtbTRbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtNVszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0xWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTBbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTFbM10pKSkpLCBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtM1szXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCAtbTVbMl0pKSksIC1tNFszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTVbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCBtMFszXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCAtbTFbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCBtMlszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNVsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNVsyXSkpKSwgLW0zWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tM1syXSkpKSwgbTVbM10pKSkpKVxuICAgIHZhciBuID0gc3VtKHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTBbM10pLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgLW0yWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTNbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNVsyXSkpKSwgLW00WzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTVbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCAtbTVbMl0pKSksIG0wWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgLW0xWzNdKSkpKSwgc3VtKHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTJbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW01WzJdKSkpLCAtbTRbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTRbMl0pKSksIG01WzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0xWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTBbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgLW0xWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTJbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTRbMl0pKSksIC1tM1szXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTNbMl0pKSksIG00WzNdKSkpKSlcbiAgICB2YXIgZCA9IGRpZmYocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cbiAgcmV0dXJuIGV4YWN0SW5TcGhlcmU2XG59XG5cbnZhciBDQUNIRUQgPSBbXG4gIGluU3BoZXJlMCxcbiAgaW5TcGhlcmUxLFxuICBpblNwaGVyZTJcbl1cblxuZnVuY3Rpb24gc2xvd0luU3BoZXJlKGFyZ3MpIHtcbiAgdmFyIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdXG4gIGlmKCFwcm9jKSB7XG4gICAgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF0gPSBvcmllbnRhdGlvbihhcmdzLmxlbmd0aClcbiAgfVxuICByZXR1cm4gcHJvYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIHByb2Moc2xvdywgbzAsIG8xLCBvMiwgbzMsIG80LCBvNSwgbzYpIHtcbiAgZnVuY3Rpb24gdGVzdEluU3BoZXJlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBvMihhMCwgYTEpXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBvMyhhMCwgYTEsIGEyKVxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbzQoYTAsIGExLCBhMiwgYTMpXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBvNShhMCwgYTEsIGEyLCBhMywgYTQpXG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBvNihhMCwgYTEsIGEyLCBhMywgYTQsIGE1KVxuICAgIH1cblxuICAgIHZhciBzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3cocylcbiAgfVxuICByZXR1cm4gdGVzdEluU3BoZXJlXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW5TcGhlcmVUZXN0KCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93SW5TcGhlcmVdLmNvbmNhdChDQUNIRUQpKVxuICBmb3IodmFyIGk9MDsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbaV0gPSBDQUNIRURbaV1cbiAgfVxufVxuXG5nZW5lcmF0ZUluU3BoZXJlVGVzdCgpIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKFwidHdvLXByb2R1Y3RcIilcbnZhciByb2J1c3RTdW0gPSByZXF1aXJlKFwicm9idXN0LXN1bVwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxudmFyIHJvYnVzdFN1YnRyYWN0ID0gcmVxdWlyZShcInJvYnVzdC1zdWJ0cmFjdFwiKVxuXG52YXIgTlVNX0VYUEFORCA9IDVcblxudmFyIEVQU0lMT04gICAgID0gMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNlxudmFyIEVSUkJPVU5EMyAgID0gKDMuMCArIDE2LjAgKiBFUFNJTE9OKSAqIEVQU0lMT05cbnZhciBFUlJCT1VORDQgICA9ICg3LjAgKyA1Ni4wICogRVBTSUxPTikgKiBFUFNJTE9OXG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uXzMoc3VtLCBwcm9kLCBzY2FsZSwgc3ViKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmllbnRhdGlvbjNFeGFjdChtMCwgbTEsIG0yKSB7XG4gICAgdmFyIHAgPSBzdW0oc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpKVxuICAgIHZhciBuID0gc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSlcbiAgICB2YXIgZCA9IHN1YihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbl80KHN1bSwgcHJvZCwgc2NhbGUsIHN1Yikge1xuICByZXR1cm4gZnVuY3Rpb24gb3JpZW50YXRpb240RXhhY3QobTAsIG0xLCBtMiwgbTMpIHtcbiAgICB2YXIgcCA9IHN1bShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0xWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTNbMl0pKSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtM1syXSkpKSlcbiAgICB2YXIgbiA9IHN1bShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtMlsyXSkpKSlcbiAgICB2YXIgZCA9IHN1YihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbl81KHN1bSwgcHJvZCwgc2NhbGUsIHN1Yikge1xuICByZXR1cm4gZnVuY3Rpb24gb3JpZW50YXRpb241RXhhY3QobTAsIG0xLCBtMiwgbTMsIG00KSB7XG4gICAgdmFyIHAgPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTNbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0zWzBdKSksIG0yWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCAtbTNbMl0pLCBzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTRbMl0pKSksIG0xWzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCBtNFsyXSkpKSwgLW0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG00WzJdKSkpLCBtM1szXSkpKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtM1syXSkpKSwgLW00WzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCBtNFsyXSkpKSwgbTBbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTNbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0zWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTNbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTBbMF0pKSwgbTRbMl0pKSksIC1tMVszXSkpKSksIHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG00WzJdKSkpLCBtM1szXSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIC1tNFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtM1syXSkpKSwgbTBbM10pKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIC1tMVszXSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIG0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0yWzJdKSkpLCAtbTNbM10pKSkpKVxuICAgIHZhciBuID0gc3VtKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0zWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtM1swXSkpLCBtMlsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTJbMF0pKSwgLW0zWzJdKSwgc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG00WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgLW0yWzNdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTRbMl0pKSksIG0zWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMlswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTBbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSksIG0zWzJdKSkpLCAtbTRbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG00WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTJbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgLW0xWzNdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTRbMl0pKSksIG0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0yWzJdKSkpLCAtbTRbM10pKSkpXG4gICAgdmFyIGQgPSBzdWIocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cbn1cblxuZnVuY3Rpb24gb3JpZW50YXRpb24obikge1xuICB2YXIgZm4gPVxuICAgIG4gPT09IDMgPyBvcmllbnRhdGlvbl8zIDpcbiAgICBuID09PSA0ID8gb3JpZW50YXRpb25fNCA6IG9yaWVudGF0aW9uXzVcblxuICByZXR1cm4gZm4ocm9idXN0U3VtLCB0d29Qcm9kdWN0LCByb2J1c3RTY2FsZSwgcm9idXN0U3VidHJhY3QpXG59XG5cbnZhciBvcmllbnRhdGlvbjNFeGFjdCA9IG9yaWVudGF0aW9uKDMpXG52YXIgb3JpZW50YXRpb240RXhhY3QgPSBvcmllbnRhdGlvbig0KVxuXG52YXIgQ0FDSEVEID0gW1xuICBmdW5jdGlvbiBvcmllbnRhdGlvbjAoKSB7IHJldHVybiAwIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMSgpIHsgcmV0dXJuIDAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24yKGEsIGIpIHtcbiAgICByZXR1cm4gYlswXSAtIGFbMF1cbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24zKGEsIGIsIGMpIHtcbiAgICB2YXIgbCA9IChhWzFdIC0gY1sxXSkgKiAoYlswXSAtIGNbMF0pXG4gICAgdmFyIHIgPSAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBjWzFdKVxuICAgIHZhciBkZXQgPSBsIC0gclxuICAgIHZhciBzXG4gICAgaWYobCA+IDApIHtcbiAgICAgIGlmKHIgPD0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gbCArIHJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYobCA8IDApIHtcbiAgICAgIGlmKHIgPj0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gLShsICsgcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICB2YXIgdG9sID0gRVJSQk9VTkQzICogc1xuICAgIGlmKGRldCA+PSB0b2wgfHwgZGV0IDw9IC10b2wpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uM0V4YWN0KGEsIGIsIGMpXG4gIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uNChhLGIsYyxkKSB7XG4gICAgdmFyIGFkeCA9IGFbMF0gLSBkWzBdXG4gICAgdmFyIGJkeCA9IGJbMF0gLSBkWzBdXG4gICAgdmFyIGNkeCA9IGNbMF0gLSBkWzBdXG4gICAgdmFyIGFkeSA9IGFbMV0gLSBkWzFdXG4gICAgdmFyIGJkeSA9IGJbMV0gLSBkWzFdXG4gICAgdmFyIGNkeSA9IGNbMV0gLSBkWzFdXG4gICAgdmFyIGFkeiA9IGFbMl0gLSBkWzJdXG4gICAgdmFyIGJkeiA9IGJbMl0gLSBkWzJdXG4gICAgdmFyIGNkeiA9IGNbMl0gLSBkWzJdXG4gICAgdmFyIGJkeGNkeSA9IGJkeCAqIGNkeVxuICAgIHZhciBjZHhiZHkgPSBjZHggKiBiZHlcbiAgICB2YXIgY2R4YWR5ID0gY2R4ICogYWR5XG4gICAgdmFyIGFkeGNkeSA9IGFkeCAqIGNkeVxuICAgIHZhciBhZHhiZHkgPSBhZHggKiBiZHlcbiAgICB2YXIgYmR4YWR5ID0gYmR4ICogYWR5XG4gICAgdmFyIGRldCA9IGFkeiAqIChiZHhjZHkgLSBjZHhiZHkpXG4gICAgICAgICAgICArIGJkeiAqIChjZHhhZHkgLSBhZHhjZHkpXG4gICAgICAgICAgICArIGNkeiAqIChhZHhiZHkgLSBiZHhhZHkpXG4gICAgdmFyIHBlcm1hbmVudCA9IChNYXRoLmFicyhiZHhjZHkpICsgTWF0aC5hYnMoY2R4YmR5KSkgKiBNYXRoLmFicyhhZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhjZHhhZHkpICsgTWF0aC5hYnMoYWR4Y2R5KSkgKiBNYXRoLmFicyhiZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhhZHhiZHkpICsgTWF0aC5hYnMoYmR4YWR5KSkgKiBNYXRoLmFicyhjZHopXG4gICAgdmFyIHRvbCA9IEVSUkJPVU5ENCAqIHBlcm1hbmVudFxuICAgIGlmICgoZGV0ID4gdG9sKSB8fCAoLWRldCA+IHRvbCkpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uNEV4YWN0KGEsYixjLGQpXG4gIH1cbl1cblxuZnVuY3Rpb24gc2xvd09yaWVudChhcmdzKSB7XG4gIHZhciBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXVxuICBpZighcHJvYykge1xuICAgIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdID0gb3JpZW50YXRpb24oYXJncy5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHByb2MuYXBwbHkodW5kZWZpbmVkLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBwcm9jIChzbG93LCBvMCwgbzEsIG8yLCBvMywgbzQsIG81KSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPcmllbnRhdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBvMihhMCwgYTEpXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBvMyhhMCwgYTEsIGEyKVxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbzQoYTAsIGExLCBhMiwgYTMpXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBvNShhMCwgYTEsIGEyLCBhMywgYTQpXG4gICAgfVxuXG4gICAgdmFyIHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICByZXR1cm4gc2xvdyhzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IHByb2MuYXBwbHkodW5kZWZpbmVkLCBbc2xvd09yaWVudF0uY29uY2F0KENBQ0hFRCkpXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBtb2R1bGUuZXhwb3J0c1tpXSA9IENBQ0hFRFtpXVxuICB9XG59XG5cbmdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSByb2J1c3RQcm9kdWN0XG5cbmZ1bmN0aW9uIHJvYnVzdFByb2R1Y3QoYSwgYikge1xuICBpZihhLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByb2J1c3RTY2FsZShiLCBhWzBdKVxuICB9XG4gIGlmKGIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJvYnVzdFNjYWxlKGEsIGJbMF0pXG4gIH1cbiAgaWYoYS5sZW5ndGggPT09IDAgfHwgYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzBdXG4gIH1cbiAgdmFyIHIgPSBbMF1cbiAgaWYoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHIgPSByb2J1c3RTdW0ociwgcm9idXN0U2NhbGUoYiwgYVtpXSkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcih2YXIgaT0wOyBpPGIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHIgPSByb2J1c3RTdW0ociwgcm9idXN0U2NhbGUoYSwgYltpXSkpXG4gICAgfSAgICBcbiAgfVxuICByZXR1cm4gclxufSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgdHdvU3VtID0gcmVxdWlyZShcInR3by1zdW1cIilcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FsZUxpbmVhckV4cGFuc2lvblxuXG5mdW5jdGlvbiBzY2FsZUxpbmVhckV4cGFuc2lvbihlLCBzY2FsZSkge1xuICB2YXIgbiA9IGUubGVuZ3RoXG4gIGlmKG4gPT09IDEpIHtcbiAgICB2YXIgdHMgPSB0d29Qcm9kdWN0KGVbMF0sIHNjYWxlKVxuICAgIGlmKHRzWzBdKSB7XG4gICAgICByZXR1cm4gdHNcbiAgICB9XG4gICAgcmV0dXJuIFsgdHNbMV0gXVxuICB9XG4gIHZhciBnID0gbmV3IEFycmF5KDIgKiBuKVxuICB2YXIgcSA9IFswLjEsIDAuMV1cbiAgdmFyIHQgPSBbMC4xLCAwLjFdXG4gIHZhciBjb3VudCA9IDBcbiAgdHdvUHJvZHVjdChlWzBdLCBzY2FsZSwgcSlcbiAgaWYocVswXSkge1xuICAgIGdbY291bnQrK10gPSBxWzBdXG4gIH1cbiAgZm9yKHZhciBpPTE7IGk8bjsgKytpKSB7XG4gICAgdHdvUHJvZHVjdChlW2ldLCBzY2FsZSwgdClcbiAgICB2YXIgcHEgPSBxWzFdXG4gICAgdHdvU3VtKHBxLCB0WzBdLCBxKVxuICAgIGlmKHFbMF0pIHtcbiAgICAgIGdbY291bnQrK10gPSBxWzBdXG4gICAgfVxuICAgIHZhciBhID0gdFsxXVxuICAgIHZhciBiID0gcVsxXVxuICAgIHZhciB4ID0gYSArIGJcbiAgICB2YXIgYnYgPSB4IC0gYVxuICAgIHZhciB5ID0gYiAtIGJ2XG4gICAgcVsxXSA9IHhcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgfVxuICBpZihxWzFdKSB7XG4gICAgZ1tjb3VudCsrXSA9IHFbMV1cbiAgfVxuICBpZihjb3VudCA9PT0gMCkge1xuICAgIGdbY291bnQrK10gPSAwLjBcbiAgfVxuICBnLmxlbmd0aCA9IGNvdW50XG4gIHJldHVybiBnXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBzZWdtZW50c0ludGVyc2VjdFxuXG52YXIgb3JpZW50ID0gcmVxdWlyZShcInJvYnVzdC1vcmllbnRhdGlvblwiKVszXVxuXG5mdW5jdGlvbiBjaGVja0NvbGxpbmVhcihhMCwgYTEsIGIwLCBiMSkge1xuXG4gIGZvcih2YXIgZD0wOyBkPDI7ICsrZCkge1xuICAgIHZhciB4MCA9IGEwW2RdXG4gICAgdmFyIHkwID0gYTFbZF1cbiAgICB2YXIgbDAgPSBNYXRoLm1pbih4MCwgeTApXG4gICAgdmFyIGgwID0gTWF0aC5tYXgoeDAsIHkwKSAgICBcblxuICAgIHZhciB4MSA9IGIwW2RdXG4gICAgdmFyIHkxID0gYjFbZF1cbiAgICB2YXIgbDEgPSBNYXRoLm1pbih4MSwgeTEpXG4gICAgdmFyIGgxID0gTWF0aC5tYXgoeDEsIHkxKSAgICBcblxuICAgIGlmKGgxIDwgbDAgfHwgaDAgPCBsMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc2VnbWVudHNJbnRlcnNlY3QoYTAsIGExLCBiMCwgYjEpIHtcbiAgdmFyIHgwID0gb3JpZW50KGEwLCBiMCwgYjEpXG4gIHZhciB5MCA9IG9yaWVudChhMSwgYjAsIGIxKVxuICBpZigoeDAgPiAwICYmIHkwID4gMCkgfHwgKHgwIDwgMCAmJiB5MCA8IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgeDEgPSBvcmllbnQoYjAsIGEwLCBhMSlcbiAgdmFyIHkxID0gb3JpZW50KGIxLCBhMCwgYTEpXG4gIGlmKCh4MSA+IDAgJiYgeTEgPiAwKSB8fCAoeDEgPCAwICYmIHkxIDwgMCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vQ2hlY2sgZm9yIGRlZ2VuZXJhdGUgY29sbGluZWFyIGNhc2VcbiAgaWYoeDAgPT09IDAgJiYgeTAgPT09IDAgJiYgeDEgPT09IDAgJiYgeTEgPT09IDApIHtcbiAgICByZXR1cm4gY2hlY2tDb2xsaW5lYXIoYTAsIGExLCBiMCwgYjEpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcm9idXN0U3VidHJhY3RcblxuLy9FYXN5IGNhc2U6IEFkZCB0d28gc2NhbGFyc1xuZnVuY3Rpb24gc2NhbGFyU2NhbGFyKGEsIGIpIHtcbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgYXYgPSB4IC0gYnZcbiAgdmFyIGJyID0gYiAtIGJ2XG4gIHZhciBhciA9IGEgLSBhdlxuICB2YXIgeSA9IGFyICsgYnJcbiAgaWYoeSkge1xuICAgIHJldHVybiBbeSwgeF1cbiAgfVxuICByZXR1cm4gW3hdXG59XG5cbmZ1bmN0aW9uIHJvYnVzdFN1YnRyYWN0KGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCAtZlswXSlcbiAgfVxuICB2YXIgbiA9IG5lICsgbmZcbiAgdmFyIGcgPSBuZXcgQXJyYXkobilcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgZXB0ciA9IDBcbiAgdmFyIGZwdHIgPSAwXG4gIHZhciBhYnMgPSBNYXRoLmFic1xuICB2YXIgZWkgPSBlW2VwdHJdXG4gIHZhciBlYSA9IGFicyhlaSlcbiAgdmFyIGZpID0gLWZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgeSA9IGIgLSBidlxuICB2YXIgcTAgPSB5XG4gIHZhciBxMSA9IHhcbiAgdmFyIF94LCBfYnYsIF9hdiwgX2JyLCBfYXJcbiAgd2hpbGUoZXB0ciA8IG5lICYmIGZwdHIgPCBuZikge1xuICAgIGlmKGVhIDwgZmEpIHtcbiAgICAgIGEgPSBlaVxuICAgICAgZXB0ciArPSAxXG4gICAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICAgIGVhID0gYWJzKGVpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gZmlcbiAgICAgIGZwdHIgKz0gMVxuICAgICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhckV4cGFuc2lvblN1bVxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gbGluZWFyRXhwYW5zaW9uU3VtKGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCBmWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSBmW2ZwdHJdXG4gIHZhciBmYSA9IGFicyhmaSlcbiAgdmFyIGEsIGJcbiAgaWYoZWEgPCBmYSkge1xuICAgIGIgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYiA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICAgIGZhID0gYWJzKGZpKVxuICAgICAgfVxuICAgIH1cbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gIH1cbiAgd2hpbGUoZXB0ciA8IG5lKSB7XG4gICAgYSA9IGVpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgfVxuICB9XG4gIHdoaWxlKGZwdHIgPCBuZikge1xuICAgIGEgPSBmaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9IFxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gIGlmKHggPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmKHggPiAwKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDAuMFxufSIsIlwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uRmluZDtcblxuZnVuY3Rpb24gVW5pb25GaW5kKGNvdW50KSB7XG4gIHRoaXMucm9vdHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICB0aGlzLnJhbmtzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgXG4gIGZvcih2YXIgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICB0aGlzLnJvb3RzW2ldID0gaTtcbiAgICB0aGlzLnJhbmtzW2ldID0gMDtcbiAgfVxufVxuXG5VbmlvbkZpbmQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb290cy5sZW5ndGg7XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUubWFrZVNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IHRoaXMucm9vdHMubGVuZ3RoO1xuICB0aGlzLnJvb3RzLnB1c2gobik7XG4gIHRoaXMucmFua3MucHVzaCgwKTtcbiAgcmV0dXJuIG47XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHJvb3RzID0gdGhpcy5yb290cztcbiAgd2hpbGUocm9vdHNbeF0gIT09IHgpIHtcbiAgICB2YXIgeSA9IHJvb3RzW3hdO1xuICAgIHJvb3RzW3hdID0gcm9vdHNbeV07XG4gICAgeCA9IHk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHhyID0gdGhpcy5maW5kKHgpXG4gICAgLCB5ciA9IHRoaXMuZmluZCh5KTtcbiAgaWYoeHIgPT09IHlyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByYW5rcyA9IHRoaXMucmFua3NcbiAgICAsIHJvb3RzID0gdGhpcy5yb290c1xuICAgICwgeGQgICAgPSByYW5rc1t4cl1cbiAgICAsIHlkICAgID0gcmFua3NbeXJdO1xuICBpZih4ZCA8IHlkKSB7XG4gICAgcm9vdHNbeHJdID0geXI7XG4gIH0gZWxzZSBpZih5ZCA8IHhkKSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gICAgKytyYW5rc1t4cl07XG4gIH1cbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbnZhciBiaXRzICAgICAgPSByZXF1aXJlKFwiYml0LXR3aWRkbGVcIilcbiAgLCBVbmlvbkZpbmQgPSByZXF1aXJlKFwidW5pb24tZmluZFwiKVxuXG4vL1JldHVybnMgdGhlIGRpbWVuc2lvbiBvZiBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gZGltZW5zaW9uKGNlbGxzKSB7XG4gIHZhciBkID0gMFxuICAgICwgbWF4ID0gTWF0aC5tYXhcbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgZCA9IG1heChkLCBjZWxsc1tpXS5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGQtMVxufVxuZXhwb3J0cy5kaW1lbnNpb24gPSBkaW1lbnNpb25cblxuLy9Db3VudHMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiBmYWNlc1xuZnVuY3Rpb24gY291bnRWZXJ0aWNlcyhjZWxscykge1xuICB2YXIgdmMgPSAtMVxuICAgICwgbWF4ID0gTWF0aC5tYXhcbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLCBqbD1jLmxlbmd0aDsgajxqbDsgKytqKSB7XG4gICAgICB2YyA9IG1heCh2YywgY1tqXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZjKzFcbn1cbmV4cG9ydHMuY291bnRWZXJ0aWNlcyA9IGNvdW50VmVydGljZXNcblxuLy9SZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGNlbGxzXG5mdW5jdGlvbiBjbG9uZUNlbGxzKGNlbGxzKSB7XG4gIHZhciBuY2VsbHMgPSBuZXcgQXJyYXkoY2VsbHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBuY2VsbHNbaV0gPSBjZWxsc1tpXS5zbGljZSgwKVxuICB9XG4gIHJldHVybiBuY2VsbHNcbn1cbmV4cG9ydHMuY2xvbmVDZWxscyA9IGNsb25lQ2VsbHNcblxuLy9SYW5rcyBhIHBhaXIgb2YgY2VsbHMgdXAgdG8gcGVybXV0YXRpb25cbmZ1bmN0aW9uIGNvbXBhcmVDZWxscyhhLCBiKSB7XG4gIHZhciBuID0gYS5sZW5ndGhcbiAgICAsIHQgPSBhLmxlbmd0aCAtIGIubGVuZ3RoXG4gICAgLCBtaW4gPSBNYXRoLm1pblxuICBpZih0KSB7XG4gICAgcmV0dXJuIHRcbiAgfVxuICBzd2l0Y2gobikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICBjYXNlIDI6XG4gICAgICB2YXIgZCA9IGFbMF0rYVsxXS1iWzBdLWJbMV1cbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW4oYVswXSxhWzFdKSAtIG1pbihiWzBdLGJbMV0pXG4gICAgY2FzZSAzOlxuICAgICAgdmFyIGwxID0gYVswXSthWzFdXG4gICAgICAgICwgbTEgPSBiWzBdK2JbMV1cbiAgICAgIGQgPSBsMSthWzJdIC0gKG0xK2JbMl0pXG4gICAgICBpZihkKSB7XG4gICAgICAgIHJldHVybiBkXG4gICAgICB9XG4gICAgICB2YXIgbDAgPSBtaW4oYVswXSwgYVsxXSlcbiAgICAgICAgLCBtMCA9IG1pbihiWzBdLCBiWzFdKVxuICAgICAgICAsIGQgID0gbWluKGwwLCBhWzJdKSAtIG1pbihtMCwgYlsyXSlcbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW4obDArYVsyXSwgbDEpIC0gbWluKG0wK2JbMl0sIG0xKVxuICAgIFxuICAgIC8vVE9ETzogTWF5YmUgb3B0aW1pemUgbj00IGFzIHdlbGw/XG4gICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBhcyA9IGEuc2xpY2UoMClcbiAgICAgIGFzLnNvcnQoKVxuICAgICAgdmFyIGJzID0gYi5zbGljZSgwKVxuICAgICAgYnMuc29ydCgpXG4gICAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgICAgdCA9IGFzW2ldIC0gYnNbaV1cbiAgICAgICAgaWYodCkge1xuICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gIH1cbn1cbmV4cG9ydHMuY29tcGFyZUNlbGxzID0gY29tcGFyZUNlbGxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVaaXBwZWQoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUNlbGxzKGFbMF0sIGJbMF0pXG59XG5cbi8vUHV0cyBhIGNlbGwgY29tcGxleCBpbnRvIG5vcm1hbCBvcmRlciBmb3IgdGhlIHB1cnBvc2VzIG9mIGZpbmRDZWxsIHF1ZXJpZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZShjZWxscywgYXR0cikge1xuICBpZihhdHRyKSB7XG4gICAgdmFyIGxlbiA9IGNlbGxzLmxlbmd0aFxuICAgIHZhciB6aXBwZWQgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgKytpKSB7XG4gICAgICB6aXBwZWRbaV0gPSBbY2VsbHNbaV0sIGF0dHJbaV1dXG4gICAgfVxuICAgIHppcHBlZC5zb3J0KGNvbXBhcmVaaXBwZWQpXG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgIGNlbGxzW2ldID0gemlwcGVkW2ldWzBdXG4gICAgICBhdHRyW2ldID0gemlwcGVkW2ldWzFdXG4gICAgfVxuICAgIHJldHVybiBjZWxsc1xuICB9IGVsc2Uge1xuICAgIGNlbGxzLnNvcnQoY29tcGFyZUNlbGxzKVxuICAgIHJldHVybiBjZWxsc1xuICB9XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZVxuXG4vL1JlbW92ZXMgYWxsIGR1cGxpY2F0ZSBjZWxscyBpbiB0aGUgY29tcGxleFxuZnVuY3Rpb24gdW5pcXVlKGNlbGxzKSB7XG4gIGlmKGNlbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICB2YXIgYSA9IGNlbGxzW2ldXG4gICAgaWYoY29tcGFyZUNlbGxzKGEsIGNlbGxzW2ktMV0pKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNlbGxzW3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgY2VsbHMubGVuZ3RoID0gcHRyXG4gIHJldHVybiBjZWxsc1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5cbi8vRmluZHMgYSBjZWxsIGluIGEgbm9ybWFsaXplZCBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGZpbmRDZWxsKGNlbGxzLCBjKSB7XG4gIHZhciBsbyA9IDBcbiAgICAsIGhpID0gY2VsbHMubGVuZ3RoLTFcbiAgICAsIHIgID0gLTFcbiAgd2hpbGUgKGxvIDw9IGhpKSB7XG4gICAgdmFyIG1pZCA9IChsbyArIGhpKSA+PiAxXG4gICAgICAsIHMgICA9IGNvbXBhcmVDZWxscyhjZWxsc1ttaWRdLCBjKVxuICAgIGlmKHMgPD0gMCkge1xuICAgICAgaWYocyA9PT0gMCkge1xuICAgICAgICByID0gbWlkXG4gICAgICB9XG4gICAgICBsbyA9IG1pZCArIDFcbiAgICB9IGVsc2UgaWYocyA+IDApIHtcbiAgICAgIGhpID0gbWlkIC0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuZXhwb3J0cy5maW5kQ2VsbCA9IGZpbmRDZWxsO1xuXG4vL0J1aWxkcyBhbiBpbmRleCBmb3IgYW4gbi1jZWxsLiAgVGhpcyBpcyBtb3JlIGdlbmVyYWwgdGhhbiBkdWFsLCBidXQgbGVzcyBlZmZpY2llbnRcbmZ1bmN0aW9uIGluY2lkZW5jZShmcm9tX2NlbGxzLCB0b19jZWxscykge1xuICB2YXIgaW5kZXggPSBuZXcgQXJyYXkoZnJvbV9jZWxscy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wLCBpbD1pbmRleC5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIGluZGV4W2ldID0gW11cbiAgfVxuICB2YXIgYiA9IFtdXG4gIGZvcih2YXIgaT0wLCBuPXRvX2NlbGxzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYyA9IHRvX2NlbGxzW2ldXG4gICAgdmFyIGNsID0gYy5sZW5ndGhcbiAgICBmb3IodmFyIGs9MSwga249KDE8PGNsKTsgazxrbjsgKytrKSB7XG4gICAgICBiLmxlbmd0aCA9IGJpdHMucG9wQ291bnQoaylcbiAgICAgIHZhciBsID0gMFxuICAgICAgZm9yKHZhciBqPTA7IGo8Y2w7ICsraikge1xuICAgICAgICBpZihrICYgKDE8PGopKSB7XG4gICAgICAgICAgYltsKytdID0gY1tqXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaWR4PWZpbmRDZWxsKGZyb21fY2VsbHMsIGIpXG4gICAgICBpZihpZHggPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgIGluZGV4W2lkeCsrXS5wdXNoKGkpXG4gICAgICAgIGlmKGlkeCA+PSBmcm9tX2NlbGxzLmxlbmd0aCB8fCBjb21wYXJlQ2VsbHMoZnJvbV9jZWxsc1tpZHhdLCBiKSAhPT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4XG59XG5leHBvcnRzLmluY2lkZW5jZSA9IGluY2lkZW5jZVxuXG4vL0NvbXB1dGVzIHRoZSBkdWFsIG9mIHRoZSBtZXNoLiAgVGhpcyBpcyBiYXNpY2FsbHkgYW4gb3B0aW1pemVkIHZlcnNpb24gb2YgYnVpbGRJbmRleCBmb3IgdGhlIHNpdHVhdGlvbiB3aGVyZSBmcm9tX2NlbGxzIGlzIGp1c3QgdGhlIGxpc3Qgb2YgdmVydGljZXNcbmZ1bmN0aW9uIGR1YWwoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICBpZighdmVydGV4X2NvdW50KSB7XG4gICAgcmV0dXJuIGluY2lkZW5jZSh1bmlxdWUoc2tlbGV0b24oY2VsbHMsIDApKSwgY2VsbHMsIDApXG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh2ZXJ0ZXhfY291bnQpXG4gIGZvcih2YXIgaT0wOyBpPHZlcnRleF9jb3VudDsgKytpKSB7XG4gICAgcmVzW2ldID0gW11cbiAgfVxuICBmb3IodmFyIGk9MCwgbGVuPWNlbGxzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCwgY2w9Yy5sZW5ndGg7IGo8Y2w7ICsraikge1xuICAgICAgcmVzW2Nbal1dLnB1c2goaSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZXhwb3J0cy5kdWFsID0gZHVhbFxuXG4vL0VudW1lcmF0ZXMgYWxsIGNlbGxzIGluIHRoZSBjb21wbGV4XG5mdW5jdGlvbiBleHBsb2RlKGNlbGxzKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgICAsIGNsID0gYy5sZW5ndGh8MFxuICAgIGZvcih2YXIgaj0xLCBqbD0oMTw8Y2wpOyBqPGpsOyArK2opIHtcbiAgICAgIHZhciBiID0gW11cbiAgICAgIGZvcih2YXIgaz0wOyBrPGNsOyArK2spIHtcbiAgICAgICAgaWYoKGogPj4+IGspICYgMSkge1xuICAgICAgICAgIGIucHVzaChjW2tdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHJlc3VsdClcbn1cbmV4cG9ydHMuZXhwbG9kZSA9IGV4cGxvZGVcblxuLy9FbnVtZXJhdGVzIGFsbCBvZiB0aGUgbi1jZWxscyBvZiBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gc2tlbGV0b24oY2VsbHMsIG4pIHtcbiAgaWYobiA8IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gW11cbiAgICAsIGswICAgICA9ICgxPDwobisxKSktMVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGs9azA7IGs8KDE8PGMubGVuZ3RoKTsgaz1iaXRzLm5leHRDb21iaW5hdGlvbihrKSkge1xuICAgICAgdmFyIGIgPSBuZXcgQXJyYXkobisxKVxuICAgICAgICAsIGwgPSAwXG4gICAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmKGsgJiAoMTw8aikpIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2pdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzdWx0KVxufVxuZXhwb3J0cy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4vL0NvbXB1dGVzIHRoZSBib3VuZGFyeSBvZiBhbGwgY2VsbHMsIGRvZXMgbm90IHJlbW92ZSBkdXBsaWNhdGVzXG5mdW5jdGlvbiBib3VuZGFyeShjZWxscykge1xuICB2YXIgcmVzID0gW11cbiAgZm9yKHZhciBpPTAsaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsY2w9Yy5sZW5ndGg7IGo8Y2w7ICsraikge1xuICAgICAgdmFyIGIgPSBuZXcgQXJyYXkoYy5sZW5ndGgtMSlcbiAgICAgIGZvcih2YXIgaz0wLCBsPTA7IGs8Y2w7ICsraykge1xuICAgICAgICBpZihrICE9PSBqKSB7XG4gICAgICAgICAgYltsKytdID0gY1trXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMucHVzaChiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHJlcylcbn1cbmV4cG9ydHMuYm91bmRhcnkgPSBib3VuZGFyeTtcblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBkZW5zZSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHNfZGVuc2UoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICB2YXIgbGFiZWxzID0gbmV3IFVuaW9uRmluZCh2ZXJ0ZXhfY291bnQpXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgIGZvcih2YXIgaz1qKzE7IGs8Yy5sZW5ndGg7ICsraykge1xuICAgICAgICBsYWJlbHMubGluayhjW2pdLCBjW2tdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgY29tcG9uZW50cyA9IFtdXG4gICAgLCBjb21wb25lbnRfbGFiZWxzID0gbGFiZWxzLnJhbmtzXG4gIGZvcih2YXIgaT0wOyBpPGNvbXBvbmVudF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb21wb25lbnRfbGFiZWxzW2ldID0gLTFcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsID0gbGFiZWxzLmZpbmQoY2VsbHNbaV1bMF0pXG4gICAgaWYoY29tcG9uZW50X2xhYmVsc1tsXSA8IDApIHtcbiAgICAgIGNvbXBvbmVudF9sYWJlbHNbbF0gPSBjb21wb25lbnRzLmxlbmd0aFxuICAgICAgY29tcG9uZW50cy5wdXNoKFtjZWxsc1tpXS5zbGljZSgwKV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50X2xhYmVsc1tsXV0ucHVzaChjZWxsc1tpXS5zbGljZSgwKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBzcGFyc2UgZ3JhcGhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHNfc3BhcnNlKGNlbGxzKSB7XG4gIHZhciB2ZXJ0aWNlcyAgPSB1bmlxdWUobm9ybWFsaXplKHNrZWxldG9uKGNlbGxzLCAwKSkpXG4gICAgLCBsYWJlbHMgICAgPSBuZXcgVW5pb25GaW5kKHZlcnRpY2VzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIHZqID0gZmluZENlbGwodmVydGljZXMsIFtjW2pdXSlcbiAgICAgIGZvcih2YXIgaz1qKzE7IGs8Yy5sZW5ndGg7ICsraykge1xuICAgICAgICBsYWJlbHMubGluayh2aiwgZmluZENlbGwodmVydGljZXMsIFtjW2tdXSkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjb21wb25lbnRzICAgICAgICA9IFtdXG4gICAgLCBjb21wb25lbnRfbGFiZWxzICA9IGxhYmVscy5yYW5rc1xuICBmb3IodmFyIGk9MDsgaTxjb21wb25lbnRfbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgY29tcG9uZW50X2xhYmVsc1tpXSA9IC0xXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbCA9IGxhYmVscy5maW5kKGZpbmRDZWxsKHZlcnRpY2VzLCBbY2VsbHNbaV1bMF1dKSk7XG4gICAgaWYoY29tcG9uZW50X2xhYmVsc1tsXSA8IDApIHtcbiAgICAgIGNvbXBvbmVudF9sYWJlbHNbbF0gPSBjb21wb25lbnRzLmxlbmd0aFxuICAgICAgY29tcG9uZW50cy5wdXNoKFtjZWxsc1tpXS5zbGljZSgwKV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50X2xhYmVsc1tsXV0ucHVzaChjZWxsc1tpXS5zbGljZSgwKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHMoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICBpZih2ZXJ0ZXhfY291bnQpIHtcbiAgICByZXR1cm4gY29ubmVjdGVkQ29tcG9uZW50c19kZW5zZShjZWxscywgdmVydGV4X2NvdW50KVxuICB9XG4gIHJldHVybiBjb25uZWN0ZWRDb21wb25lbnRzX3NwYXJzZShjZWxscylcbn1cbmV4cG9ydHMuY29ubmVjdGVkQ29tcG9uZW50cyA9IGNvbm5lY3RlZENvbXBvbmVudHNcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnlQb2x5Z29uXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgc2MgPSByZXF1aXJlKFwic2ltcGxpY2lhbC1jb21wbGV4XCIpXG5cbmZ1bmN0aW9uIGVycm9yV2VpZ2h0KGJhc2UsIGEsIGIpIHtcbiAgdmFyIGFyZWEgPSBNYXRoLmFicyhvcmllbnQoYmFzZSwgYSwgYikpXG4gIHZhciBwZXJpbSA9IE1hdGguc3FydChNYXRoLnBvdyhhWzBdIC0gYlswXSwgMikgKyBNYXRoLnBvdyhhWzFdLWJbMV0sIDIpKVxuICByZXR1cm4gYXJlYSAvIHBlcmltXG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5UG9seWdvbihjZWxscywgcG9zaXRpb25zLCBtaW5BcmVhKSB7XG5cbiAgdmFyIG4gPSBwb3NpdGlvbnMubGVuZ3RoXG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgaW52ID0gbmV3IEFycmF5KG4pXG4gIHZhciBvdXR2ID0gbmV3IEFycmF5KG4pXG4gIHZhciB3ZWlnaHRzID0gbmV3IEFycmF5KG4pXG4gIHZhciBkZWFkID0gbmV3IEFycmF5KG4pXG4gIFxuICAvL0luaXRpYWxpemUgdGFibGVzXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGludltpXSA9IG91dHZbaV0gPSAtMVxuICAgIHdlaWdodHNbaV0gPSBJbmZpbml0eVxuICAgIGRlYWRbaV0gPSBmYWxzZVxuICB9XG5cbiAgLy9Db21wdXRlIG5laWdoYm9yc1xuICBmb3IodmFyIGk9MDsgaTxuYzsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGlmKGMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgZ3JhcGhcIilcbiAgICB9XG4gICAgdmFyIHMgPSBjWzFdXG4gICAgdmFyIHQgPSBjWzBdXG4gICAgaWYob3V0dlt0XSAhPT0gLTEpIHtcbiAgICAgIG91dHZbdF0gPSAtMlxuICAgIH0gZWxzZSB7XG4gICAgICBvdXR2W3RdID0gc1xuICAgIH1cbiAgICBpZihpbnZbc10gIT09IC0xKSB7XG4gICAgICBpbnZbc10gPSAtMlxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZbc10gPSB0XG4gICAgfVxuICB9XG5cbiAgLy9VcGRhdGVzIHRoZSB3ZWlnaHQgZm9yIHZlcnRleCBpXG4gIGZ1bmN0aW9uIGNvbXB1dGVXZWlnaHQoaSkge1xuICAgIGlmKGRlYWRbaV0pIHtcbiAgICAgIHJldHVybiBJbmZpbml0eVxuICAgIH1cbiAgICAvL1RPRE86IENoZWNrIHRoYXQgdGhlIGxpbmUgc2VnbWVudCBkb2Vzbid0IGNyb3NzIG9uY2Ugc2ltcGxpZmllZFxuICAgIHZhciBzID0gaW52W2ldXG4gICAgdmFyIHQgPSBvdXR2W2ldXG4gICAgaWYoKHM8MCkgfHwgKHQ8MCkpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3JXZWlnaHQocG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbc10sIHBvc2l0aW9uc1t0XSlcbiAgICB9XG4gIH1cblxuICAvL1N3YXBzIHR3byBub2RlcyBvbiB0aGUgaGVhcCAoaSxqKSBhcmUgdGhlIGluZGV4IG9mIHRoZSBub2Rlc1xuICBmdW5jdGlvbiBoZWFwU3dhcChpLGopIHtcbiAgICB2YXIgYSA9IGhlYXBbaV1cbiAgICB2YXIgYiA9IGhlYXBbal1cbiAgICBoZWFwW2ldID0gYlxuICAgIGhlYXBbal0gPSBhXG4gICAgaW5kZXhbYV0gPSBqXG4gICAgaW5kZXhbYl0gPSBpXG4gIH1cblxuICAvL1JldHVybnMgdGhlIHdlaWdodCBvZiBub2RlIGkgb24gdGhlIGhlYXBcbiAgZnVuY3Rpb24gaGVhcFdlaWdodChpKSB7XG4gICAgcmV0dXJuIHdlaWdodHNbaGVhcFtpXV1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYXBQYXJlbnQoaSkge1xuICAgIGlmKGkgJiAxKSB7XG4gICAgICByZXR1cm4gKGkgLSAxKSA+PiAxXG4gICAgfVxuICAgIHJldHVybiAoaSA+PiAxKSAtIDFcbiAgfVxuXG4gIC8vQnViYmxlIGVsZW1lbnQgaSBkb3duIHRoZSBoZWFwXG4gIGZ1bmN0aW9uIGhlYXBEb3duKGkpIHtcbiAgICB2YXIgdyA9IGhlYXBXZWlnaHQoaSlcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB2YXIgdHcgPSB3XG4gICAgICB2YXIgbGVmdCAgPSAyKmkgKyAxXG4gICAgICB2YXIgcmlnaHQgPSAyKihpICsgMSlcbiAgICAgIHZhciBuZXh0ID0gaVxuICAgICAgaWYobGVmdCA8IGhlYXBDb3VudCkge1xuICAgICAgICB2YXIgbHcgPSBoZWFwV2VpZ2h0KGxlZnQpXG4gICAgICAgIGlmKGx3IDwgdHcpIHtcbiAgICAgICAgICBuZXh0ID0gbGVmdFxuICAgICAgICAgIHR3ID0gbHdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYocmlnaHQgPCBoZWFwQ291bnQpIHtcbiAgICAgICAgdmFyIHJ3ID0gaGVhcFdlaWdodChyaWdodClcbiAgICAgICAgaWYocncgPCB0dykge1xuICAgICAgICAgIG5leHQgPSByaWdodFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihuZXh0ID09PSBpKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgICBoZWFwU3dhcChpLCBuZXh0KVxuICAgICAgaSA9IG5leHQgICAgICBcbiAgICB9XG4gIH1cblxuICAvL0J1YmJsZXMgZWxlbWVudCBpIHVwIHRoZSBoZWFwXG4gIGZ1bmN0aW9uIGhlYXBVcChpKSB7XG4gICAgdmFyIHcgPSBoZWFwV2VpZ2h0KGkpXG4gICAgd2hpbGUoaSA+IDApIHtcbiAgICAgIHZhciBwYXJlbnQgPSBoZWFwUGFyZW50KGkpXG4gICAgICBpZihwYXJlbnQgPj0gMCkge1xuICAgICAgICB2YXIgcHcgPSBoZWFwV2VpZ2h0KHBhcmVudClcbiAgICAgICAgaWYodyA8IHB3KSB7XG4gICAgICAgICAgaGVhcFN3YXAoaSwgcGFyZW50KVxuICAgICAgICAgIGkgPSBwYXJlbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIC8vUG9wIG1pbmltdW0gZWxlbWVudFxuICBmdW5jdGlvbiBoZWFwUG9wKCkge1xuICAgIGlmKGhlYXBDb3VudCA+IDApIHtcbiAgICAgIHZhciBoZWFkID0gaGVhcFswXVxuICAgICAgaGVhcFN3YXAoMCwgaGVhcENvdW50LTEpXG4gICAgICBoZWFwQ291bnQgLT0gMVxuICAgICAgaGVhcERvd24oMClcbiAgICAgIHJldHVybiBoZWFkXG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLy9VcGRhdGUgaGVhcCBpdGVtIGlcbiAgZnVuY3Rpb24gaGVhcFVwZGF0ZShpLCB3KSB7XG4gICAgdmFyIGEgPSBoZWFwW2ldXG4gICAgaWYod2VpZ2h0c1thXSA9PT0gdykge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gICAgd2VpZ2h0c1thXSA9IC1JbmZpbml0eVxuICAgIGhlYXBVcChpKVxuICAgIGhlYXBQb3AoKVxuICAgIHdlaWdodHNbYV0gPSB3XG4gICAgaGVhcENvdW50ICs9IDFcbiAgICByZXR1cm4gaGVhcFVwKGhlYXBDb3VudC0xKVxuICB9XG5cbiAgLy9LaWxscyBhIHZlcnRleCAoYXNzdW1lIHZlcnRleCBhbHJlYWR5IHJlbW92ZWQgZnJvbSBoZWFwKVxuICBmdW5jdGlvbiBraWxsKGkpIHtcbiAgICBpZihkZWFkW2ldKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy9LaWxsIHZlcnRleFxuICAgIGRlYWRbaV0gPSB0cnVlXG4gICAgLy9GaXh1cCB0b3BvbG9neVxuICAgIHZhciBzID0gaW52W2ldXG4gICAgdmFyIHQgPSBvdXR2W2ldXG4gICAgaWYoaW52W3RdID49IDApIHtcbiAgICAgIGludlt0XSA9IHNcbiAgICB9XG4gICAgaWYob3V0dltzXSA+PSAwKSB7XG4gICAgICBvdXR2W3NdID0gdFxuICAgIH1cblxuICAgIC8vVXBkYXRlIHdlaWdodHMgb24gcyBhbmQgdFxuICAgIGlmKGluZGV4W3NdID49IDApIHtcbiAgICAgIGhlYXBVcGRhdGUoaW5kZXhbc10sIGNvbXB1dGVXZWlnaHQocykpXG4gICAgfVxuICAgIGlmKGluZGV4W3RdID49IDApIHtcbiAgICAgIGhlYXBVcGRhdGUoaW5kZXhbdF0sIGNvbXB1dGVXZWlnaHQodCkpXG4gICAgfVxuICB9XG5cbiAgLy9Jbml0aWFsaXplIHdlaWdodHMgYW5kIGhlYXBcbiAgdmFyIGhlYXAgPSBbXVxuICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIHcgPSB3ZWlnaHRzW2ldID0gY29tcHV0ZVdlaWdodChpKVxuICAgIGlmKHcgPCBJbmZpbml0eSkge1xuICAgICAgaW5kZXhbaV0gPSBoZWFwLmxlbmd0aFxuICAgICAgaGVhcC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4W2ldID0gLTFcbiAgICB9XG4gIH1cbiAgdmFyIGhlYXBDb3VudCA9IGhlYXAubGVuZ3RoXG4gIGZvcih2YXIgaT1oZWFwQ291bnQ+PjE7IGk+PTA7IC0taSkge1xuICAgIGhlYXBEb3duKGkpXG4gIH1cbiAgXG4gIC8vS2lsbCB2ZXJ0aWNlc1xuICB3aGlsZSh0cnVlKSB7XG4gICAgdmFyIGhtaW4gPSBoZWFwUG9wKClcbiAgICBpZigoaG1pbiA8IDApIHx8ICh3ZWlnaHRzW2htaW5dID4gbWluQXJlYSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGtpbGwoaG1pbilcbiAgfVxuXG4gIC8vQnVpbGQgY29sbGFwc2VkIHZlcnRleCB0YWJsZVxuICB2YXIgbnBvc2l0aW9ucyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGlmKCFkZWFkW2ldKSB7XG4gICAgICBpbmRleFtpXSA9IG5wb3NpdGlvbnMubGVuZ3RoXG4gICAgICBucG9zaXRpb25zLnB1c2gocG9zaXRpb25zW2ldLnNsaWNlKCkpXG4gICAgfVxuICB9XG4gIHZhciBudiA9IG5wb3NpdGlvbnMubGVuZ3RoXG5cbiAgZnVuY3Rpb24gdG9ydG9pc2VIYXJlKHNlcSwgc3RhcnQpIHtcbiAgICBpZihzZXFbc3RhcnRdIDwgMCkge1xuICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgfVxuICAgIHZhciB0ID0gc3RhcnRcbiAgICB2YXIgaCA9IHN0YXJ0XG4gICAgZG8ge1xuICAgICAgLy9XYWxrIHR3byBzdGVwcyB3aXRoIGhcbiAgICAgIHZhciBuaCA9IHNlcVtoXVxuICAgICAgaWYoIWRlYWRbaF0gfHwgbmggPCAwIHx8IG5oID09PSBoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBoID0gbmhcbiAgICAgIG5oID0gc2VxW2hdXG4gICAgICBpZighZGVhZFtoXSB8fCBuaCA8IDAgfHwgbmggPT09IGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGggPSBuaFxuXG4gICAgICAvL1dhbGsgb25lIHN0ZXAgd2l0aCB0XG4gICAgICB0ID0gc2VxW3RdXG4gICAgfSB3aGlsZSh0ICE9PSBoKVxuICAgIC8vQ29tcHJlc3MgY3ljbGVzXG4gICAgZm9yKHZhciB2PXN0YXJ0OyB2IT09aDsgdiA9IHNlcVt2XSkge1xuICAgICAgc2VxW3ZdID0gaFxuICAgIH1cbiAgICByZXR1cm4gaFxuICB9XG5cbiAgdmFyIG5jZWxscyA9IFtdXG4gIGNlbGxzLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgIHZhciB0aW4gPSB0b3J0b2lzZUhhcmUoaW52LCBjWzBdKVxuICAgIHZhciB0b3V0ID0gdG9ydG9pc2VIYXJlKG91dHYsIGNbMV0pXG4gICAgaWYodGluID49IDAgJiYgdG91dCA+PSAwICYmIHRpbiAhPT0gdG91dCkge1xuICAgICAgdmFyIGNpbiA9IGluZGV4W3Rpbl1cbiAgICAgIHZhciBjb3V0ID0gaW5kZXhbdG91dF1cbiAgICAgIGlmKGNpbiAhPT0gY291dCkge1xuICAgICAgICBuY2VsbHMucHVzaChbIGNpbiwgY291dCBdKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAvL05vcm1hbGl6ZSByZXN1bHRcbiAgc2MudW5pcXVlKHNjLm5vcm1hbGl6ZShuY2VsbHMpKVxuXG4gIC8vUmV0dXJuIGZpbmFsIGxpc3Qgb2YgY2VsbHNcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbnM6IG5wb3NpdGlvbnMsXG4gICAgZWRnZXM6IG5jZWxsc1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlclNlZ21lbnRzXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG5cbmZ1bmN0aW9uIGhvcml6b250YWxPcmRlcihhLCBiKSB7XG4gIHZhciBibCwgYnJcbiAgaWYoYlswXVswXSA8IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMF1cbiAgICBiciA9IGJbMV1cbiAgfSBlbHNlIGlmKGJbMF1bMF0gPiBiWzFdWzBdKSB7XG4gICAgYmwgPSBiWzFdXG4gICAgYnIgPSBiWzBdXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFsbyA9IE1hdGgubWluKGFbMF1bMV0sIGFbMV1bMV0pXG4gICAgdmFyIGFoaSA9IE1hdGgubWF4KGFbMF1bMV0sIGFbMV1bMV0pXG4gICAgdmFyIGJsbyA9IE1hdGgubWluKGJbMF1bMV0sIGJbMV1bMV0pXG4gICAgdmFyIGJoaSA9IE1hdGgubWF4KGJbMF1bMV0sIGJbMV1bMV0pXG4gICAgaWYoYWhpIDwgYmxvKSB7XG4gICAgICByZXR1cm4gYWhpIC0gYmxvXG4gICAgfVxuICAgIGlmKGFsbyA+IGJoaSkge1xuICAgICAgcmV0dXJuIGFsbyAtIGJoaVxuICAgIH1cbiAgICByZXR1cm4gYWhpIC0gYmhpXG4gIH1cbiAgdmFyIGFsLCBhclxuICBpZihhWzBdWzFdIDwgYVsxXVsxXSkge1xuICAgIGFsID0gYVswXVxuICAgIGFyID0gYVsxXVxuICB9IGVsc2Uge1xuICAgIGFsID0gYVsxXVxuICAgIGFyID0gYVswXVxuICB9XG4gIHZhciBkID0gb3JpZW50KGJyLCBibCwgYWwpXG4gIGlmKGQpIHtcbiAgICByZXR1cm4gZFxuICB9XG4gIGQgPSBvcmllbnQoYnIsIGJsLCBhcilcbiAgaWYoZCkge1xuICAgIHJldHVybiBkXG4gIH1cbiAgcmV0dXJuIGFyIC0gYnJcbn1cblxuZnVuY3Rpb24gb3JkZXJTZWdtZW50cyhiLCBhKSB7XG4gIHZhciBhbCwgYXJcbiAgaWYoYVswXVswXSA8IGFbMV1bMF0pIHtcbiAgICBhbCA9IGFbMF1cbiAgICBhciA9IGFbMV1cbiAgfSBlbHNlIGlmKGFbMF1bMF0gPiBhWzFdWzBdKSB7XG4gICAgYWwgPSBhWzFdXG4gICAgYXIgPSBhWzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxPcmRlcihhLCBiKVxuICB9XG4gIHZhciBibCwgYnJcbiAgaWYoYlswXVswXSA8IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMF1cbiAgICBiciA9IGJbMV1cbiAgfSBlbHNlIGlmKGJbMF1bMF0gPiBiWzFdWzBdKSB7XG4gICAgYmwgPSBiWzFdXG4gICAgYnIgPSBiWzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC1ob3Jpem9udGFsT3JkZXIoYiwgYSlcbiAgfVxuICB2YXIgZDEgPSBvcmllbnQoYWwsIGFyLCBicilcbiAgdmFyIGQyID0gb3JpZW50KGFsLCBhciwgYmwpXG4gIGlmKGQxIDwgMCkge1xuICAgIGlmKGQyIDw9IDApIHtcbiAgICAgIHJldHVybiBkMVxuICAgIH1cbiAgfSBlbHNlIGlmKGQxID4gMCkge1xuICAgIGlmKGQyID49IDApIHtcbiAgICAgIHJldHVybiBkMVxuICAgIH1cbiAgfSBlbHNlIGlmKGQyKSB7XG4gICAgcmV0dXJuIGQyXG4gIH1cbiAgZDEgPSBvcmllbnQoYnIsIGJsLCBhcilcbiAgZDIgPSBvcmllbnQoYnIsIGJsLCBhbClcbiAgaWYoZDEgPCAwKSB7XG4gICAgaWYoZDIgPD0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDEgPiAwKSB7XG4gICAgaWYoZDIgPj0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDIpIHtcbiAgICByZXR1cm4gZDJcbiAgfVxuICByZXR1cm4gYXJbMF0gLSBiclswXVxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2xhYkRlY29tcG9zaXRpb25cblxudmFyIGJvdW5kcyA9IHJlcXVpcmUoXCJiaW5hcnktc2VhcmNoLWJvdW5kc1wiKVxudmFyIGNyZWF0ZVJCVHJlZSA9IHJlcXVpcmUoXCJmdW5jdGlvbmFsLXJlZC1ibGFjay10cmVlXCIpXG52YXIgb3JpZW50ID0gcmVxdWlyZShcInJvYnVzdC1vcmllbnRhdGlvblwiKVxudmFyIG9yZGVyU2VnbWVudHMgPSByZXF1aXJlKFwiLi9saWIvb3JkZXItc2VnbWVudHNcIilcblxuZnVuY3Rpb24gU2xhYkRlY29tcG9zaXRpb24oc2xhYnMsIGNvb3JkaW5hdGVzLCBob3Jpem9udGFsKSB7XG4gIHRoaXMuc2xhYnMgPSBzbGFic1xuICB0aGlzLmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXNcbiAgdGhpcy5ob3Jpem9udGFsID0gaG9yaXpvbnRhbFxufVxuXG52YXIgcHJvdG8gPSBTbGFiRGVjb21wb3NpdGlvbi5wcm90b3R5cGVcblxuZnVuY3Rpb24gY29tcGFyZUhvcml6b250YWwoZSwgeSkge1xuICByZXR1cm4gZS55IC0geVxufVxuXG5mdW5jdGlvbiBzZWFyY2hCdWNrZXQocm9vdCwgcCkge1xuICB2YXIgbGFzdE5vZGUgPSBudWxsXG4gIHdoaWxlKHJvb3QpIHtcbiAgICB2YXIgc2VnID0gcm9vdC5rZXlcbiAgICB2YXIgbCwgclxuICAgIGlmKHNlZ1swXVswXSA8IHNlZ1sxXVswXSkge1xuICAgICAgbCA9IHNlZ1swXVxuICAgICAgciA9IHNlZ1sxXVxuICAgIH0gZWxzZSB7XG4gICAgICBsID0gc2VnWzFdXG4gICAgICByID0gc2VnWzBdXG4gICAgfVxuICAgIHZhciBvID0gb3JpZW50KGwsIHIsIHApXG4gICAgaWYobyA8IDApIHtcbiAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICB9IGVsc2UgaWYobyA+IDApIHtcbiAgICAgIGlmKHBbMF0gIT09IHNlZ1sxXVswXSkge1xuICAgICAgICBsYXN0Tm9kZSA9IHJvb3RcbiAgICAgICAgcm9vdCA9IHJvb3QucmlnaHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWFyY2hCdWNrZXQocm9vdC5yaWdodCwgcClcbiAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocFswXSAhPT0gc2VnWzFdWzBdKSB7XG4gICAgICAgIHJldHVybiByb290XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsID0gc2VhcmNoQnVja2V0KHJvb3QucmlnaHQsIHApXG4gICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfVxuICAgICAgICByb290ID0gcm9vdC5sZWZ0XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXN0Tm9kZVxufVxuXG5wcm90by5jYXN0VXAgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBidWNrZXQgPSBib3VuZHMubGUodGhpcy5jb29yZGluYXRlcywgcFswXSlcbiAgaWYoYnVja2V0IDwgMCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciByb290ID0gdGhpcy5zbGFic1tidWNrZXRdXG4gIHZhciBoaXROb2RlID0gc2VhcmNoQnVja2V0KHRoaXMuc2xhYnNbYnVja2V0XSwgcClcbiAgdmFyIGxhc3RIaXQgPSAtMVxuICBpZihoaXROb2RlKSB7XG4gICAgbGFzdEhpdCA9IGhpdE5vZGUudmFsdWVcbiAgfVxuICAvL0VkZ2UgY2FzZTogbmVlZCB0byBoYW5kbGUgaG9yaXpvbnRhbCBzZWdtZW50cyAoc3Vja3MpXG4gIGlmKHRoaXMuY29vcmRpbmF0ZXNbYnVja2V0XSA9PT0gcFswXSkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IG51bGxcbiAgICBpZihoaXROb2RlKSB7XG4gICAgICBsYXN0U2VnbWVudCA9IGhpdE5vZGUua2V5XG4gICAgfVxuICAgIGlmKGJ1Y2tldCA+IDApIHtcbiAgICAgIHZhciBvdGhlckhpdE5vZGUgPSBzZWFyY2hCdWNrZXQodGhpcy5zbGFic1tidWNrZXQtMV0sIHApXG4gICAgICBpZihvdGhlckhpdE5vZGUpIHtcbiAgICAgICAgaWYobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICBpZihvcmRlclNlZ21lbnRzKG90aGVySGl0Tm9kZS5rZXksIGxhc3RTZWdtZW50KSA+IDApIHtcbiAgICAgICAgICAgIGxhc3RTZWdtZW50ID0gb3RoZXJIaXROb2RlLmtleVxuICAgICAgICAgICAgbGFzdEhpdCA9IG90aGVySGl0Tm9kZS52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0SGl0ID0gb3RoZXJIaXROb2RlLnZhbHVlXG4gICAgICAgICAgbGFzdFNlZ21lbnQgPSBvdGhlckhpdE5vZGUua2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3Jpem9udGFsW2J1Y2tldF1cbiAgICBpZihob3Jpei5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaGJ1Y2tldCA9IGJvdW5kcy5nZShob3JpeiwgcFsxXSwgY29tcGFyZUhvcml6b250YWwpXG4gICAgICBpZihoYnVja2V0IDwgaG9yaXoubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlID0gaG9yaXpbaGJ1Y2tldF1cbiAgICAgICAgaWYocFsxXSA9PT0gZS55KSB7XG4gICAgICAgICAgaWYoZS5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmluZGV4XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlKGhidWNrZXQgPCBob3Jpei5sZW5ndGgtMSAmJiBob3JpeltoYnVja2V0KzFdLnkgPT09IHBbMV0pIHtcbiAgICAgICAgICAgICAgaGJ1Y2tldCA9IGhidWNrZXQrMVxuICAgICAgICAgICAgICBlID0gaG9yaXpbaGJ1Y2tldF1cbiAgICAgICAgICAgICAgaWYoZS5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihlLnkgPT09IHBbMV0gJiYgIWUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgaGJ1Y2tldCA9IGhidWNrZXQrMVxuICAgICAgICAgICAgICBpZihoYnVja2V0ID49IGhvcml6Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0SGl0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZSA9IGhvcml6W2hidWNrZXRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQ2hlY2sgaWYgZSBpcyBhYm92ZS9iZWxvdyBsYXN0IHNlZ21lbnRcbiAgICAgICAgaWYoZS5zdGFydCkge1xuICAgICAgICAgIGlmKGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgbyA9IG9yaWVudChsYXN0U2VnbWVudFswXSwgbGFzdFNlZ21lbnRbMV0sIFtwWzBdLCBlLnldKVxuICAgICAgICAgICAgaWYobGFzdFNlZ21lbnRbMF1bMF0gPiBsYXN0U2VnbWVudFsxXVswXSkge1xuICAgICAgICAgICAgICBvID0gLW9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG8gPiAwKSB7XG4gICAgICAgICAgICAgIGxhc3RIaXQgPSBlLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RIaXQgPSBlLmluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZS55ICE9PSBwWzFdKSB7XG4gICAgICAgICAgbGFzdEhpdCA9IGUuaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGFzdEhpdFxufVxuXG5mdW5jdGlvbiBJbnRlcnZhbFNlZ21lbnQoeSwgaW5kZXgsIHN0YXJ0LCBjbG9zZWQpIHtcbiAgdGhpcy55ID0geVxuICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgdGhpcy5zdGFydCA9IHN0YXJ0XG4gIHRoaXMuY2xvc2VkID0gY2xvc2VkXG59XG5cbmZ1bmN0aW9uIEV2ZW50KHgsIHNlZ21lbnQsIGNyZWF0ZSwgaW5kZXgpIHtcbiAgdGhpcy54ID0geFxuICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50XG4gIHRoaXMuY3JlYXRlID0gY3JlYXRlXG4gIHRoaXMuaW5kZXggPSBpbmRleFxufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNsYWJEZWNvbXBvc2l0aW9uKHNlZ21lbnRzKSB7XG4gIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aFxuICB2YXIgbnVtRXZlbnRzID0gMiAqIG51bVNlZ21lbnRzXG4gIHZhciBldmVudHMgPSBuZXcgQXJyYXkobnVtRXZlbnRzKVxuICBmb3IodmFyIGk9MDsgaTxudW1TZWdtZW50czsgKytpKSB7XG4gICAgdmFyIHMgPSBzZWdtZW50c1tpXVxuICAgIHZhciBmID0gc1swXVswXSA8IHNbMV1bMF1cbiAgICBldmVudHNbMippXSA9IG5ldyBFdmVudChzWzBdWzBdLCBzLCBmLCBpKVxuICAgIGV2ZW50c1syKmkrMV0gPSBuZXcgRXZlbnQoc1sxXVswXSwgcywgIWYsIGkpXG4gIH1cbiAgZXZlbnRzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGQgPSBhLnggLSBiLnhcbiAgICBpZihkKSB7XG4gICAgICByZXR1cm4gZFxuICAgIH1cbiAgICBkID0gYS5jcmVhdGUgLSBiLmNyZWF0ZVxuICAgIGlmKGQpIHtcbiAgICAgIHJldHVybiBkXG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihhLnNlZ21lbnRbMF1bMV0sIGEuc2VnbWVudFsxXVsxXSkgLSBNYXRoLm1pbihiLnNlZ21lbnRbMF1bMV0sIGIuc2VnbWVudFsxXVsxXSlcbiAgfSlcbiAgdmFyIHRyZWUgPSBjcmVhdGVSQlRyZWUob3JkZXJTZWdtZW50cylcbiAgdmFyIHNsYWJzID0gW11cbiAgdmFyIGxpbmVzID0gW11cbiAgdmFyIGhvcml6b250YWwgPSBbXVxuICB2YXIgbGFzdFggPSAtSW5maW5pdHlcbiAgZm9yKHZhciBpPTA7IGk8bnVtRXZlbnRzOyApIHtcbiAgICB2YXIgeCA9IGV2ZW50c1tpXS54XG4gICAgdmFyIGhvcml6ID0gW11cbiAgICB3aGlsZShpIDwgbnVtRXZlbnRzKSB7XG4gICAgICB2YXIgZSA9IGV2ZW50c1tpXVxuICAgICAgaWYoZS54ICE9PSB4KSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpICs9IDFcbiAgICAgIGlmKGUuc2VnbWVudFswXVswXSA9PT0gZS54ICYmIGUuc2VnbWVudFsxXVswXSA9PT0gZS54KSB7XG4gICAgICAgIGlmKGUuY3JlYXRlKSB7XG4gICAgICAgICAgaWYoZS5zZWdtZW50WzBdWzFdIDwgZS5zZWdtZW50WzFdWzFdKSB7XG4gICAgICAgICAgICBob3Jpei5wdXNoKG5ldyBJbnRlcnZhbFNlZ21lbnQoXG4gICAgICAgICAgICAgICAgZS5zZWdtZW50WzBdWzFdLFxuICAgICAgICAgICAgICAgIGUuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlKSlcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMV1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMV1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGZhbHNlKSlcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMF1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB0cnVlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGUuY3JlYXRlKSB7XG4gICAgICAgICAgdHJlZSA9IHRyZWUuaW5zZXJ0KGUuc2VnbWVudCwgZS5pbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmVlID0gdHJlZS5yZW1vdmUoZS5zZWdtZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNsYWJzLnB1c2godHJlZS5yb290KVxuICAgIGxpbmVzLnB1c2goeClcbiAgICBob3Jpem9udGFsLnB1c2goaG9yaXopXG4gIH1cbiAgcmV0dXJuIG5ldyBTbGFiRGVjb21wb3NpdGlvbihzbGFicywgbGluZXMsIGhvcml6b250YWwpXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBzdXJmYWNlTmV0c1xuXG52YXIgZ2VuZXJhdGVDb250b3VyRXh0cmFjdG9yID0gcmVxdWlyZShcIm5kYXJyYXktZXh0cmFjdC1jb250b3VyXCIpXG52YXIgdHJpYW5ndWxhdGVDdWJlID0gcmVxdWlyZShcInRyaWFuZ3VsYXRlLWh5cGVyY3ViZVwiKVxudmFyIHplcm9Dcm9zc2luZ3MgPSByZXF1aXJlKFwiemVyby1jcm9zc2luZ3NcIilcblxuZnVuY3Rpb24gYnVpbGRTdXJmYWNlTmV0cyhvcmRlciwgZHR5cGUpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0JztcIl1cbiAgdmFyIGZ1bmNOYW1lID0gXCJzdXJmYWNlTmV0c1wiICsgb3JkZXIuam9pbihcIl9cIikgKyBcImRcIiArIGR0eXBlXG5cbiAgLy9Db250b3VyIGV4dHJhY3Rpb24gZnVuY3Rpb25cbiAgY29kZS5wdXNoKFxuICAgIFwidmFyIGNvbnRvdXI9Z2VuQ29udG91cih7XCIsXG4gICAgICBcIm9yZGVyOltcIiwgb3JkZXIuam9pbigpLCBcIl0sXCIsXG4gICAgICBcInNjYWxhckFyZ3VtZW50czogMyxcIixcbiAgICAgIFwicGhhc2U6ZnVuY3Rpb24gcGhhc2VGdW5jKHAsYSxiLGMpIHsgcmV0dXJuIChwID4gYyl8MCB9LFwiKVxuICBpZihkdHlwZSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICBjb2RlLnB1c2goXCJnZXR0ZXJzOlswXSxcIilcbiAgfVxuXG4gIC8vR2VuZXJhdGUgdmVydGV4IGZ1bmN0aW9uXG4gIHZhciBjdWJlQXJncyA9IFtdXG4gIHZhciBleHRyYUFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGN1YmVBcmdzLnB1c2goXCJkXCIgKyBpKVxuICAgIGV4dHJhQXJncy5wdXNoKFwiZFwiICsgaSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgY3ViZUFyZ3MucHVzaChcInZcIiArIGkpXG4gICAgZXh0cmFBcmdzLnB1c2goXCJ2XCIgKyBpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICBjdWJlQXJncy5wdXNoKFwicFwiICsgaSlcbiAgICBleHRyYUFyZ3MucHVzaChcInBcIiArIGkpXG4gIH1cbiAgY3ViZUFyZ3MucHVzaChcImFcIiwgXCJiXCIsIFwiY1wiKVxuICBleHRyYUFyZ3MucHVzaChcImFcIiwgXCJjXCIpXG4gIGNvZGUucHVzaChcInZlcnRleDpmdW5jdGlvbiB2ZXJ0ZXhGdW5jKFwiLCBjdWJlQXJncy5qb2luKCksIFwiKXtcIilcbiAgLy9NYXNrIGFyZ3MgdG9nZXRoZXJcbiAgdmFyIG1hc2tTdHIgPSBbXVxuICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgbWFza1N0ci5wdXNoKFwiKHBcIiArIGkgKyBcIjw8XCIgKyBpICsgXCIpXCIpXG4gIH1cbiAgLy9HZW5lcmF0ZSB2YXJpYWJsZXMgYW5kIGdpZ2FudG8gc3dpdGNoIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJ2YXIgbT0oXCIsIG1hc2tTdHIuam9pbihcIitcIiksIFwiKXwwO2lmKG09PT0wfHxtPT09XCIsICgxPDwoMTw8ZGltZW5zaW9uKSktMSwgXCIpe3JldHVybn1cIilcbiAgdmFyIGV4dHJhRnVuY3MgPSBbXVxuICB2YXIgY3VycmVudEZ1bmMgPSBbXVxuICBpZigxPDwoMTw8ZGltZW5zaW9uKSA8PSAxMjgpIHtcbiAgICBjb2RlLnB1c2goXCJzd2l0Y2gobSl7XCIpXG4gICAgY3VycmVudEZ1bmMgPSBjb2RlXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwic3dpdGNoKG0+Pj43KXtcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTwxPDwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgaWYoMTw8KDE8PGRpbWVuc2lvbikgPiAxMjgpIHtcbiAgICAgIGlmKChpJTEyOCk9PT0wKSB7XG4gICAgICAgIGlmKGV4dHJhRnVuY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnRGdW5jLnB1c2goXCJ9fVwiKVxuICAgICAgICB9XG4gICAgICAgIHZhciBlZk5hbWUgPSBcInZFeHRyYVwiICsgZXh0cmFGdW5jcy5sZW5ndGhcbiAgICAgICAgY29kZS5wdXNoKFwiY2FzZSBcIiwgKGk+Pj43KSwgXCI6XCIsIGVmTmFtZSwgXCIobSYweDdmLFwiLCBleHRyYUFyZ3Muam9pbigpLCBcIik7YnJlYWs7XCIpXG4gICAgICAgIGN1cnJlbnRGdW5jID0gW1xuICAgICAgICAgIFwiZnVuY3Rpb24gXCIsIGVmTmFtZSwgXCIobSxcIiwgZXh0cmFBcmdzLmpvaW4oKSwgXCIpe3N3aXRjaChtKXtcIlxuICAgICAgICBdXG4gICAgICAgIGV4dHJhRnVuY3MucHVzaChjdXJyZW50RnVuYylcbiAgICAgIH0gIFxuICAgIH1cbiAgICBjdXJyZW50RnVuYy5wdXNoKFwiY2FzZSBcIiwgKGkmMHg3ZiksIFwiOlwiKVxuICAgIHZhciBjcm9zc2luZ3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIHZhciBkZW5vbXMgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIHZhciBjcm9zc2luZ0NvdW50ID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICB2YXIgYmlhcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgdmFyIHRvdGFsQ3Jvc3NpbmdzID0gMFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBjcm9zc2luZ3Nbal0gPSBbXVxuICAgICAgZGVub21zW2pdID0gW11cbiAgICAgIGNyb3NzaW5nQ291bnRbal0gPSAwXG4gICAgICBiaWFzW2pdID0gMFxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgICB2YXIgdSA9IGogXiAoMTw8aylcbiAgICAgICAgaWYodSA+IGopIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmKCEoaSYoMTw8dSkpICE9PSAhKGkmKDE8PGopKSkge1xuICAgICAgICAgIHZhciBzaWduID0gMVxuICAgICAgICAgIGlmKGkmKDE8PHUpKSB7XG4gICAgICAgICAgICBkZW5vbXNba10ucHVzaChcInZcIiArIHUgKyBcIi12XCIgKyBqKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZW5vbXNba10ucHVzaChcInZcIiArIGogKyBcIi12XCIgKyB1KVxuICAgICAgICAgICAgc2lnbiA9IC1zaWduXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHNpZ24gPCAwKSB7XG4gICAgICAgICAgICBjcm9zc2luZ3Nba10ucHVzaChcIi12XCIgKyBqICsgXCItdlwiICsgdSlcbiAgICAgICAgICAgIGNyb3NzaW5nQ291bnRba10gKz0gMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcm9zc2luZ3Nba10ucHVzaChcInZcIiArIGogKyBcIit2XCIgKyB1KVxuICAgICAgICAgICAgY3Jvc3NpbmdDb3VudFtrXSAtPSAyICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsQ3Jvc3NpbmdzICs9IDFcbiAgICAgICAgICBmb3IodmFyIGw9MDsgbDxkaW1lbnNpb247ICsrbCkge1xuICAgICAgICAgICAgaWYobCA9PT0gaykge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodSYoMTw8bCkpIHtcbiAgICAgICAgICAgICAgYmlhc1tsXSArPSAxXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaWFzW2xdIC09IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZlcnRleFN0ciA9IFtdXG4gICAgZm9yKHZhciBrPTA7IGs8ZGltZW5zaW9uOyArK2spIHtcbiAgICAgIGlmKGNyb3NzaW5nc1trXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmVydGV4U3RyLnB1c2goXCJkXCIgKyBrICsgXCItMC41XCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY1N0ciA9IFwiXCJcbiAgICAgICAgaWYoY3Jvc3NpbmdDb3VudFtrXSA8IDApIHtcbiAgICAgICAgICBjU3RyID0gY3Jvc3NpbmdDb3VudFtrXSArIFwiKmNcIlxuICAgICAgICB9IGVsc2UgaWYoY3Jvc3NpbmdDb3VudFtrXSA+IDApIHtcbiAgICAgICAgICBjU3RyID0gXCIrXCIgKyBjcm9zc2luZ0NvdW50W2tdICsgXCIqY1wiXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlaWdodCA9IDAuNSAqIChjcm9zc2luZ3Nba10ubGVuZ3RoIC8gdG90YWxDcm9zc2luZ3MpXG4gICAgICAgIHZhciBzaGlmdCA9IDAuNSArIDAuNSAqIChiaWFzW2tdIC8gdG90YWxDcm9zc2luZ3MpXG4gICAgICAgIHZlcnRleFN0ci5wdXNoKFwiZFwiICsgayArIFwiLVwiICsgc2hpZnQgKyBcIi1cIiArIHdlaWdodCArIFwiKihcIiArIGNyb3NzaW5nc1trXS5qb2luKFwiK1wiKSArIGNTdHIgKyBcIikvKFwiICsgZGVub21zW2tdLmpvaW4oXCIrXCIpICsgXCIpXCIpXG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50RnVuYy5wdXNoKFwiYS5wdXNoKFtcIiwgdmVydGV4U3RyLmpvaW4oKSwgXCJdKTtcIixcbiAgICAgIFwiYnJlYWs7XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifX0sXCIpXG4gIGlmKGV4dHJhRnVuY3MubGVuZ3RoID4gMCkge1xuICAgIGN1cnJlbnRGdW5jLnB1c2goXCJ9fVwiKVxuICB9XG5cbiAgLy9DcmVhdGUgZmFjZSBmdW5jdGlvblxuICB2YXIgZmFjZUFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTwoMTw8KGRpbWVuc2lvbi0xKSk7ICsraSkge1xuICAgIGZhY2VBcmdzLnB1c2goXCJ2XCIgKyBpKVxuICB9XG4gIGZhY2VBcmdzLnB1c2goXCJjMFwiLCBcImMxXCIsIFwicDBcIiwgXCJwMVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiKVxuICBjb2RlLnB1c2goXCJjZWxsOmZ1bmN0aW9uIGNlbGxGdW5jKFwiLCBmYWNlQXJncy5qb2luKCksIFwiKXtcIilcblxuICB2YXIgZmFjZXRzID0gdHJpYW5ndWxhdGVDdWJlKGRpbWVuc2lvbi0xKVxuICBjb2RlLnB1c2goXCJpZihwMCl7Yi5wdXNoKFwiLFxuICAgIGZhY2V0cy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIFwiW1wiICsgZi5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gXCJ2XCIgKyB2XG4gICAgICB9KSArIFwiXVwiXG4gICAgfSkuam9pbigpLCBcIil9ZWxzZXtiLnB1c2goXCIsXG4gICAgZmFjZXRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgZSA9IGYuc2xpY2UoKVxuICAgICAgZS5yZXZlcnNlKClcbiAgICAgIHJldHVybiBcIltcIiArIGUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwidlwiICsgdlxuICAgICAgfSkgKyBcIl1cIlxuICAgIH0pLmpvaW4oKSxcbiAgICBcIil9fX0pO2Z1bmN0aW9uIFwiLCBmdW5jTmFtZSwgXCIoYXJyYXksbGV2ZWwpe3ZhciB2ZXJ0cz1bXSxjZWxscz1bXTtjb250b3VyKGFycmF5LHZlcnRzLGNlbGxzLGxldmVsKTtyZXR1cm4ge3Bvc2l0aW9uczp2ZXJ0cyxjZWxsczpjZWxsc307fSByZXR1cm4gXCIsIGZ1bmNOYW1lLCBcIjtcIilcblxuICBmb3IodmFyIGk9MDsgaTxleHRyYUZ1bmNzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKGV4dHJhRnVuY3NbaV0uam9pbihcIlwiKSlcbiAgfVxuXG4gIC8vQ29tcGlsZSBhbmQgbGlua1xuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcImdlbkNvbnRvdXJcIiwgY29kZS5qb2luKFwiXCIpKVxuICByZXR1cm4gcHJvYyhnZW5lcmF0ZUNvbnRvdXJFeHRyYWN0b3IpXG59XG5cbi8vMUQgY2FzZTogTmVlZCB0byBoYW5kbGUgc3BlY2lhbGx5XG5mdW5jdGlvbiBtZXNoMUQoYXJyYXksIGxldmVsKSB7XG4gIHZhciB6YyA9IHplcm9Dcm9zc2luZ3MoYXJyYXksIGxldmVsKVxuICB2YXIgbiA9IHpjLmxlbmd0aFxuICB2YXIgbnBvcyA9IG5ldyBBcnJheShuKVxuICB2YXIgbmNlbCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICBucG9zW2ldID0gWyB6Y1tpXSBdXG4gICAgbmNlbFtpXSA9IFsgaSBdXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbnM6IG5wb3MsXG4gICAgY2VsbHM6IG5jZWxcbiAgfVxufVxuXG52YXIgQ0FDSEUgPSB7fVxuXG5mdW5jdGlvbiBzdXJmYWNlTmV0cyhhcnJheSxsZXZlbCkge1xuICBpZihhcnJheS5kaW1lbnNpb24gPD0gMCkge1xuICAgIHJldHVybiB7IHBvc2l0aW9uczogW10sIGNlbGxzOiBbXSB9XG4gIH0gZWxzZSBpZihhcnJheS5kaW1lbnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbWVzaDFEKGFycmF5LCBsZXZlbClcbiAgfVxuICB2YXIgdHlwZXNpZyA9IGFycmF5Lm9yZGVyLmpvaW4oKSArIFwiLVwiICsgYXJyYXkuZHR5cGVcbiAgdmFyIHByb2MgPSBDQUNIRVt0eXBlc2lnXVxuICB2YXIgbGV2ZWwgPSAoK2xldmVsKSB8fCAwLjBcbiAgaWYoIXByb2MpIHtcbiAgICBwcm9jID0gQ0FDSEVbdHlwZXNpZ10gPSBidWlsZFN1cmZhY2VOZXRzKGFycmF5Lm9yZGVyLCBhcnJheS5kdHlwZSlcbiAgfVxuICByZXR1cm4gcHJvYyhhcnJheSxsZXZlbClcbn0iLCJleHBvcnQgY29uc3QgUkVWSVNJT04gPSAnMTU2JztcblxuZXhwb3J0IGNvbnN0IE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmV4cG9ydCBjb25zdCBUT1VDSCA9IHsgUk9UQVRFOiAwLCBQQU46IDEsIERPTExZX1BBTjogMiwgRE9MTFlfUk9UQVRFOiAzIH07XG5leHBvcnQgY29uc3QgQ3VsbEZhY2VOb25lID0gMDtcbmV4cG9ydCBjb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnQgPSAyO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnRCYWNrID0gMztcbmV4cG9ydCBjb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5leHBvcnQgY29uc3QgUENGU2hhZG93TWFwID0gMTtcbmV4cG9ydCBjb25zdCBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcbmV4cG9ydCBjb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuZXhwb3J0IGNvbnN0IEZyb250U2lkZSA9IDA7XG5leHBvcnQgY29uc3QgQmFja1NpZGUgPSAxO1xuZXhwb3J0IGNvbnN0IERvdWJsZVNpZGUgPSAyO1xuZXhwb3J0IGNvbnN0IFR3b1Bhc3NEb3VibGVTaWRlID0gMjsgLy8gcjE0OVxuZXhwb3J0IGNvbnN0IE5vQmxlbmRpbmcgPSAwO1xuZXhwb3J0IGNvbnN0IE5vcm1hbEJsZW5kaW5nID0gMTtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbmV4cG9ydCBjb25zdCBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbmV4cG9ydCBjb25zdCBNdWx0aXBseUJsZW5kaW5nID0gNDtcbmV4cG9ydCBjb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5leHBvcnQgY29uc3QgQWRkRXF1YXRpb24gPSAxMDA7XG5leHBvcnQgY29uc3QgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbmV4cG9ydCBjb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbmV4cG9ydCBjb25zdCBNaW5FcXVhdGlvbiA9IDEwMztcbmV4cG9ydCBjb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcbmV4cG9ydCBjb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuZXhwb3J0IGNvbnN0IE9uZUZhY3RvciA9IDIwMTtcbmV4cG9ydCBjb25zdCBTcmNDb2xvckZhY3RvciA9IDIwMjtcbmV4cG9ydCBjb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhRmFjdG9yID0gMjA0O1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5leHBvcnQgY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5leHBvcnQgY29uc3QgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbmV4cG9ydCBjb25zdCBEc3RDb2xvckZhY3RvciA9IDIwODtcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5leHBvcnQgY29uc3QgTmV2ZXJEZXB0aCA9IDA7XG5leHBvcnQgY29uc3QgQWx3YXlzRGVwdGggPSAxO1xuZXhwb3J0IGNvbnN0IExlc3NEZXB0aCA9IDI7XG5leHBvcnQgY29uc3QgTGVzc0VxdWFsRGVwdGggPSAzO1xuZXhwb3J0IGNvbnN0IEVxdWFsRGVwdGggPSA0O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmV4cG9ydCBjb25zdCBHcmVhdGVyRGVwdGggPSA2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xuZXhwb3J0IGNvbnN0IE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmV4cG9ydCBjb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuZXhwb3J0IGNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XG5leHBvcnQgY29uc3QgTm9Ub25lTWFwcGluZyA9IDA7XG5leHBvcnQgY29uc3QgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xuZXhwb3J0IGNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuZXhwb3J0IGNvbnN0IENpbmVvblRvbmVNYXBwaW5nID0gMztcbmV4cG9ydCBjb25zdCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xuZXhwb3J0IGNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcblxuZXhwb3J0IGNvbnN0IFVWTWFwcGluZyA9IDMwMDtcbmV4cG9ydCBjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5leHBvcnQgY29uc3QgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuZXhwb3J0IGNvbnN0IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuZXhwb3J0IGNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmV4cG9ydCBjb25zdCBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcbmV4cG9ydCBjb25zdCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbmV4cG9ydCBjb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IExpbmVhckZpbHRlciA9IDEwMDY7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyID0gMTAwODtcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuZXhwb3J0IGNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcbmV4cG9ydCBjb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcbmV4cG9ydCBjb25zdCBJbnRUeXBlID0gMTAxMztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuZXhwb3J0IGNvbnN0IEZsb2F0VHlwZSA9IDEwMTU7XG5leHBvcnQgY29uc3QgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG5leHBvcnQgY29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XG5leHBvcnQgY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuZXhwb3J0IGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuZXhwb3J0IGNvbnN0IEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG5leHBvcnQgY29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuZXhwb3J0IGNvbnN0IERlcHRoRm9ybWF0ID0gMTAyNjtcbmV4cG9ydCBjb25zdCBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xuZXhwb3J0IGNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5leHBvcnQgY29uc3QgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XG5leHBvcnQgY29uc3QgUkdGb3JtYXQgPSAxMDMwO1xuZXhwb3J0IGNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5leHBvcnQgY29uc3QgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xuXG5leHBvcnQgY29uc3QgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NjtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAzMzc3OTtcbmV4cG9ydCBjb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuZXhwb3J0IGNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDI7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5leHBvcnQgY29uc3QgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5leHBvcnQgY29uc3QgUkdCX0VUQzJfRm9ybWF0ID0gMzc0OTI7XG5leHBvcnQgY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNHg0X0Zvcm1hdCA9IDM3ODA4O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ181eDRfRm9ybWF0ID0gMzc4MDk7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNng1X0Zvcm1hdCA9IDM3ODExO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ182eDZfRm9ybWF0ID0gMzc4MTI7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg2X0Zvcm1hdCA9IDM3ODE0O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDhfRm9ybWF0ID0gMzc4MTU7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gMzc4MTg7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSAzNzgyMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gMzc4MjE7XG5leHBvcnQgY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuZXhwb3J0IGNvbnN0IFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQgPSAzNjQ5NDtcbmV4cG9ydCBjb25zdCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQgPSAzNjQ5NTtcbmV4cG9ydCBjb25zdCBSRURfUkdUQzFfRm9ybWF0ID0gMzYyODM7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4NDtcbmV4cG9ydCBjb25zdCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ID0gMzYyODU7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NjtcbmV4cG9ydCBjb25zdCBMb29wT25jZSA9IDIyMDA7XG5leHBvcnQgY29uc3QgTG9vcFJlcGVhdCA9IDIyMDE7XG5leHBvcnQgY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5leHBvcnQgY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuZXhwb3J0IGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuZXhwb3J0IGNvbnN0IFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5leHBvcnQgY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5leHBvcnQgY29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSA9IDI1MDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIExpbmVhclNSR0JDb2xvclNwYWNlIG9yIE5vQ29sb3JTcGFjZSBpbiB0aHJlZS5qcyByMTUyKy4gKi9cbmV4cG9ydCBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIFNSR0JDb2xvclNwYWNlIGluIHRocmVlLmpzIHIxNTIrLiAqL1xuZXhwb3J0IGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5leHBvcnQgY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuZXhwb3J0IGNvbnN0IFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xuZXhwb3J0IGNvbnN0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5leHBvcnQgY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXG4vLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cbmV4cG9ydCBjb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcbmV4cG9ydCBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbmV4cG9ydCBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG5leHBvcnQgY29uc3QgRGlzcGxheVAzQ29sb3JTcGFjZSA9ICdkaXNwbGF5LXAzJztcbmV4cG9ydCBjb25zdCBMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlID0gJ2Rpc3BsYXktcDMtbGluZWFyJztcblxuZXhwb3J0IGNvbnN0IFplcm9TdGVuY2lsT3AgPSAwO1xuZXhwb3J0IGNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuZXhwb3J0IGNvbnN0IFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuZXhwb3J0IGNvbnN0IEluY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODI7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcbmV4cG9ydCBjb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU2O1xuZXhwb3J0IGNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cbmV4cG9ydCBjb25zdCBOZXZlclN0ZW5jaWxGdW5jID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcbmV4cG9ydCBjb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcbmV4cG9ydCBjb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuXG5leHBvcnQgY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NDb21wYXJlID0gNTEzO1xuZXhwb3J0IGNvbnN0IEVxdWFsQ29tcGFyZSA9IDUxNDtcbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJDb21wYXJlID0gNTE2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsQ29tcGFyZSA9IDUxNztcbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c0NvbXBhcmUgPSA1MTk7XG5cbmV4cG9ydCBjb25zdCBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcbmV4cG9ydCBjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5leHBvcnQgY29uc3QgU3RyZWFtRHJhd1VzYWdlID0gMzUwNDA7XG5leHBvcnQgY29uc3QgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5leHBvcnQgY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuZXhwb3J0IGNvbnN0IFN0cmVhbVJlYWRVc2FnZSA9IDM1MDQxO1xuZXhwb3J0IGNvbnN0IFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuZXhwb3J0IGNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmV4cG9ydCBjb25zdCBTdHJlYW1Db3B5VXNhZ2UgPSAzNTA0MjtcblxuZXhwb3J0IGNvbnN0IEdMU0wxID0gJzEwMCc7XG5leHBvcnQgY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuZXhwb3J0IGNvbnN0IF9TUkdCQUZvcm1hdCA9IDEwMzU7IC8vIGZhbGxiYWNrIGZvciBXZWJHTCAxXG5cbmV4cG9ydCBjb25zdCBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gPSAyMDAwO1xuZXhwb3J0IGNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IGRlbm9ybWFsaXplLCBub3JtYWxpemUgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UsIEZsb2F0VHlwZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBmcm9tSGFsZkZsb2F0LCB0b0hhbGZGbG9hdCB9IGZyb20gJy4uL2V4dHJhcy9EYXRhVXRpbHMuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5cbmNsYXNzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCA9IGZhbHNlICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblx0XHR0aGlzLmdwdVR5cGUgPSBGbG9hdFR5cGU7XG5cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdH1cblxuXHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9XG5cblx0c2V0VXNhZ2UoIHZhbHVlICkge1xuXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IHNvdXJjZS5ncHVUeXBlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGlmICggdGhpcy5pdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3RvcjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMi5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZKCBpLCBfdmVjdG9yMi54LCBfdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXg0KCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdC8vIE1hdGNoaW5nIEJ1ZmZlckF0dHJpYnV0ZSBjb25zdHJ1Y3RvciwgZG8gbm90IG5vcm1hbGl6ZSB0aGUgYXJyYXkuXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQgKSB7XG5cblx0XHRsZXQgdmFsdWUgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBkZW5vcm1hbGl6ZSggdmFsdWUsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgY29tcG9uZW50LCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRZKCBpbmRleCApIHtcblxuXHRcdGxldCB5ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gZGVub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB3O1xuXG5cdH1cblxuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWSggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaVyggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblx0XHRcdHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0YXJyYXk6IEFycmF5LmZyb20oIHRoaXMuYXJyYXkgKSxcblx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCB0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UgKSBkYXRhLnVzYWdlID0gdGhpcy51c2FnZTtcblx0XHRpZiAoIHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0gMSApIGRhdGEudXBkYXRlUmFuZ2UgPSB0aGlzLnVwZGF0ZVJhbmdlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbi8vXG5cbmNsYXNzIEludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHR0aGlzLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gZGVub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB4O1xuXG5cdH1cblxuXHRzZXRYKCBpbmRleCwgeCApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFkoIGluZGV4ICkge1xuXG5cdFx0bGV0IHkgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WiggaW5kZXggKSB7XG5cblx0XHRsZXQgeiA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBkZW5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHc7XG5cblx0fVxuXG5cdHNldFcoIGluZGV4LCB3ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHRvSGFsZkZsb2F0KCB6ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuY2xhc3MgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8vXG5cbmV4cG9ydCB7XG5cdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckF0dHJpYnV0ZVxufTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4vT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBhcnJheU5lZWRzVWludDMyIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX29iaiA9IC8qQF9fUFVSRV9fKi8gbmV3IE9iamVjdDNEKCk7XG5jb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9ib3hNb3JwaFRhcmdldHMgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0J1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX2lkICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0Z2V0SW5kZXgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblxuXHR9XG5cblx0c2V0SW5kZXgoIGluZGV4ICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kZXggKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEF0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9XG5cblx0c2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWxldGVBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aGFzQXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdICE9PSB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGFkZEdyb3VwKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggPSAwICkge1xuXG5cdFx0dGhpcy5ncm91cHMucHVzaCgge1xuXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNsZWFyR3JvdXBzKCkge1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR9XG5cblx0c2V0RHJhd1JhbmdlKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvc2l0aW9uLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0YW5nZW50ID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cblx0XHRpZiAoIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGFuZ2VudC50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR0YW5nZW50Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdF9tMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHRfbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRfb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9vYmoubWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VudGVyKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBfb2Zmc2V0ICkubmVnYXRlKCk7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggX29mZnNldC54LCBfb2Zmc2V0LnksIF9vZmZzZXQueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCBcIm1lc2guZnJ1c3R1bUN1bGxlZFwiIHRvIFwiZmFsc2VcIi4nLCB0aGlzICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0KFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWluLCBfYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gubWF4ICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5taW4gKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5tYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQoIG5ldyBWZWN0b3IzKCksIEluZmluaXR5ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRfYm94TW9ycGhUYXJnZXRzLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggX2JveC5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCBfYm94Lm1heCwgX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1pbiApO1xuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94LmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaiApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yLmFkZCggX29mZnNldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVUYW5nZW50cygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcblx0XHQvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuXHRcdGlmICggaW5kZXggPT09IG51bGwgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy51diA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXHRcdGNvbnN0IHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG5cblx0XHRjb25zdCBuVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdGlmICggdGhpcy5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNCAqIG5WZXJ0aWNlcyApLCA0ICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoICd0YW5nZW50JyApLmFycmF5O1xuXG5cdFx0Y29uc3QgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBuVmVydGljZXM7IGkgKysgKSB7XG5cblx0XHRcdHRhbjFbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkMgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRcdHNkaXIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dGRpciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cdFx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG5cdFx0XHR1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG5cdFx0XHR1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG5cdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cblx0XHRcdHZCLnN1YiggdkEgKTtcblx0XHRcdHZDLnN1YiggdkEgKTtcblxuXHRcdFx0dXZCLnN1YiggdXZBICk7XG5cdFx0XHR1dkMuc3ViKCB1dkEgKTtcblxuXHRcdFx0Y29uc3QgciA9IDEuMCAvICggdXZCLnggKiB1dkMueSAtIHV2Qy54ICogdXZCLnkgKTtcblxuXHRcdFx0Ly8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cblx0XHRcdGlmICggISBpc0Zpbml0ZSggciApICkgcmV0dXJuO1xuXG5cdFx0XHRzZGlyLmNvcHkoIHZCICkubXVsdGlwbHlTY2FsYXIoIHV2Qy55ICkuYWRkU2NhbGVkVmVjdG9yKCB2QywgLSB1dkIueSApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cdFx0XHR0ZGlyLmNvcHkoIHZDICkubXVsdGlwbHlTY2FsYXIoIHV2Qi54ICkuYWRkU2NhbGVkVmVjdG9yKCB2QiwgLSB1dkMueCApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYiBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRncm91cHMgPSBbIHtcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdFx0fSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoXG5cdFx0XHRcdFx0aW5kaWNlc1sgaiArIDAgXSxcblx0XHRcdFx0XHRpbmRpY2VzWyBqICsgMSBdLFxuXHRcdFx0XHRcdGluZGljZXNbIGogKyAyIF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSwgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksIG4yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdGNvbnN0IHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0Y29uc3QgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRzWyB2ICogNCBdID0gdG1wLng7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDIgXSA9IHRtcC56O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kaWNlc1sgaiArIDAgXSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGljZXNbIGogKyAxIF0gKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0aWYgKCBwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsZXQgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XG5cblx0XHRcdGlmICggbm9ybWFsQXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiAzICksIDMgKTtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFsQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpLCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBuQSA9IG5ldyBWZWN0b3IzKCksIG5CID0gbmV3IFZlY3RvcjMoKSwgbkMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdkEgPSBpbmRleC5nZXRYKCBpICsgMCApO1xuXHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCB2QyA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkEgKTtcblx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkMgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0bkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QSApO1xuXHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRuQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZDICk7XG5cblx0XHRcdFx0XHRuQS5hZGQoIGNiICk7XG5cdFx0XHRcdFx0bkIuYWRkKCBjYiApO1xuXHRcdFx0XHRcdG5DLmFkZCggY2IgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZBLCBuQS54LCBuQS55LCBuQS56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkIsIG5CLngsIG5CLnksIG5CLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QywgbkMueCwgbkMueSwgbkMueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAwICk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxICk7XG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAyICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAwLCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDEsIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMiwgY2IueCwgY2IueSwgY2IueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0bm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0bm9ybWFsaXplTm9ybWFscygpIHtcblxuXHRcdGNvbnN0IG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCBpICk7XG5cblx0XHRcdF92ZWN0b3Iubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvTm9uSW5kZXhlZCgpIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRcdFx0Y29uc3QgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGljZXMgKTtcblxuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2goIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG1vcnBoQXJyYXk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcblxuXHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0gYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRsZXQgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRtb3JwaEF0dHJpYnV0ZXNbIGtleSBdID0gYXJyYXk7XG5cblx0XHRcdFx0aGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNNb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcblx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdC8vIHJlc2V0XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcblxuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdC8vIG5hbWVcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0Ly8gaW5kZXhcblxuXHRcdGNvbnN0IGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdH1cblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgYm94XG5cblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyByYW5nZVxuXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdC8vIHVzZXIgZGF0YVxuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHNvdXJjZS51c2VyRGF0YTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH07XG4iLCIvKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH07XG4iLCJjbGFzcyBMYXllcnMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdHNldCggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xuXG5cdH1cblxuXHRlbmFibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHR9XG5cblx0ZW5hYmxlQWxsKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XG5cblx0fVxuXG5cdHRvZ2dsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRkaXNhYmxlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XG5cblx0fVxuXG5cdGRpc2FibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAwO1xuXG5cdH1cblxuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHRpc0VuYWJsZWQoIGNoYW5uZWwgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IExheWVycyB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcbmltcG9ydCB7IExheWVycyB9IGZyb20gJy4vTGF5ZXJzLmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxubGV0IF9vYmplY3QzRElkID0gMDtcblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ExID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NjYWxlID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xuXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnVwID0gT2JqZWN0M0QuREVGQVVMVF9VUC5jbG9uZSgpO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0Y29uc3Qgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdFx0cXVhdGVybmlvbi5fb25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdH0sXG5cdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cblx0XHRcdH0sXG5cdFx0XHRzY2FsZToge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdFx0fSxcblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdFx0fSxcblx0XHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fVxuXG5cdHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeUF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfekF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdGxvY2FsVG9Xb3JsZCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XG5cblx0fVxuXG5cdGxvb2tBdCggeCwgeSwgeiApIHtcblxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHRfdGFyZ2V0LmNvcHkoIHggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90YXJnZXQuc2V0KCB4LCB5LCB6ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ICkge1xuXG5cdFx0XHRfbTEubG9va0F0KCBfcG9zaXRpb24sIF90YXJnZXQsIHRoaXMudXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF90YXJnZXQsIF9wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0X20xLmV4dHJhY3RSb3RhdGlvbiggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRfcTEuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExLmludmVydCgpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFkZCggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX3JlbW92ZWRFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZUZyb21QYXJlbnQoKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRwYXJlbnQucmVtb3ZlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xlYXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIC4uLiB0aGlzLmNoaWxkcmVuICk7XG5cblx0fVxuXG5cdGF0dGFjaCggb2JqZWN0ICkge1xuXG5cdFx0Ly8gYWRkcyBvYmplY3QgYXMgYSBjaGlsZCBvZiB0aGlzLCB3aGlsZSBtYWludGFpbmluZyB0aGUgb2JqZWN0J3Mgd29ybGQgdHJhbnNmb3JtXG5cblx0XHQvLyBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHNjZW5lIGdyYXBocyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgbm9kZXMocylcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0XHRfbTEubXVsdGlwbHkoIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG5cdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5SWQoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlOYW1lKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRnZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXN1bHQucHVzaCggdGhpcyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZFJlc3VsdCA9IHRoaXMuY2hpbGRyZW5bIGkgXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBjaGlsZFJlc3VsdC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIGNoaWxkUmVzdWx0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGdldFdvcmxkUG9zaXRpb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHRnZXRXb3JsZFF1YXRlcm5pb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCB0YXJnZXQsIF9zY2FsZSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggZVsgOCBdLCBlWyA5IF0sIGVbIDEwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0cmF5Y2FzdCggLyogcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICovICkge31cblxuXHR0cmF2ZXJzZSggY2FsbGJhY2sgKSB7XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICkge1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xuXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGZvcmNlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjaGlsZC51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVXb3JsZE1hdHJpeCggdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4gKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggdXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50Lm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGNvbnN0IG91dHB1dCA9IHt9O1xuXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge30sXG5cdFx0XHRcdHNoYXBlczoge30sXG5cdFx0XHRcdHNrZWxldG9uczoge30sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IHt9LFxuXHRcdFx0XHRub2Rlczoge31cblx0XHRcdH07XG5cblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSApIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICkgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXHRcdG9iamVjdC51cCA9IHRoaXMudXAudG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRpZiAoIHRoaXMuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QudHlwZSA9ICdJbnN0YW5jZWRNZXNoJztcblx0XHRcdG9iamVjdC5jb3VudCA9IHRoaXMuY291bnQ7XG5cdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSB0aGlzLmluc3RhbmNlTWF0cml4LnRvSlNPTigpO1xuXHRcdFx0aWYgKCB0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSBvYmplY3QuaW5zdGFuY2VDb2xvciA9IHRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSAmJiB0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uICk7XG5cblx0XHRcdFx0b2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuYW5pbWF0aW9ucyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdGlmICggYW5pbWF0aW9ucy5sZW5ndGggPiAwICkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSBzb3VyY2Uucm90YXRpb24ub3JkZXI7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cblx0XHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG5cdFx0dGhpcy5hbmltYXRpb25zID0gc291cmNlLmFuaW1hdGlvbnMuc2xpY2UoKTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5PYmplY3QzRC5ERUZBVUxUX1VQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUgPSB0cnVlO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfV09STERfQVVUT19VUERBVEUgPSB0cnVlO1xuXG5leHBvcnQgeyBPYmplY3QzRCB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbi8vIEZhc3QgSGFsZiBGbG9hdCBDb252ZXJzaW9ucywgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuXG5jb25zdCBfdGFibGVzID0gLypAX19QVVJFX18qLyBfZ2VuZXJhdGVUYWJsZXMoKTtcblxuZnVuY3Rpb24gX2dlbmVyYXRlVGFibGVzKCkge1xuXG5cdC8vIGZsb2F0MzIgdG8gZmxvYXQxNiBoZWxwZXJzXG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCA0ICk7XG5cdGNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRjb25zdCB1aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXHRjb25zdCBzaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA1MTIgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyNTY7ICsrIGkgKSB7XG5cblx0XHRjb25zdCBlID0gaSAtIDEyNztcblxuXHRcdC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcblxuXHRcdGlmICggZSA8IC0gMjcgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwMDAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgLSAxNCApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDA0MDAgPj4gKCAtIGUgLSAxNCApO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggMHgwNDAwID4+ICggLSBlIC0gMTQgKSApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gLSBlIC0gMTtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gLSBlIC0gMTtcblxuXHRcdFx0Ly8gbm9ybWFsIG51bWJlclxuXG5cdFx0fSBlbHNlIGlmICggZSA8PSAxNSApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAoIGUgKyAxNSApIDw8IDEwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggKCBlICsgMTUgKSA8PCAxMCApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0XHQvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgMTI4ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XG5cblx0XHRcdC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcblxuXHRjb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCAyMDQ4ICk7XG5cdGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cdGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA2NCApO1xuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDEwMjQ7ICsrIGkgKSB7XG5cblx0XHRsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcblxuXHRcdC8vIG5vcm1hbGl6ZWRcblx0XHR3aGlsZSAoICggbSAmIDB4MDA4MDAwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0bSA8PD0gMTtcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG5cblx0XHR9XG5cblx0XHRtICY9IH4gMHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXHRcdGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuXHRcdG1hbnRpc3NhVGFibGVbIGkgXSA9IG0gfCBlO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDEwMjQ7IGkgPCAyMDQ4OyArKyBpICkge1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gMHgzODAwMDAwMCArICggKCBpIC0gMTAyNCApIDw8IDEzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDMxOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gaSA8PCAyMztcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgMzEgXSA9IDB4NDc4MDAwMDA7XG5cdGV4cG9uZW50VGFibGVbIDMyIF0gPSAweDgwMDAwMDAwO1xuXG5cdGZvciAoIGxldCBpID0gMzM7IGkgPCA2MzsgKysgaSApIHtcblxuXHRcdGV4cG9uZW50VGFibGVbIGkgXSA9IDB4ODAwMDAwMDAgKyAoICggaSAtIDMyICkgPDwgMjMgKTtcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgNjMgXSA9IDB4Yzc4MDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgNjQ7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGkgIT09IDMyICkge1xuXG5cdFx0XHRvZmZzZXRUYWJsZVsgaSBdID0gMTAyNDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRmbG9hdFZpZXc6IGZsb2F0Vmlldyxcblx0XHR1aW50MzJWaWV3OiB1aW50MzJWaWV3LFxuXHRcdGJhc2VUYWJsZTogYmFzZVRhYmxlLFxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG5cdFx0bWFudGlzc2FUYWJsZTogbWFudGlzc2FUYWJsZSxcblx0XHRleHBvbmVudFRhYmxlOiBleHBvbmVudFRhYmxlLFxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxuXHR9O1xuXG59XG5cbi8vIGZsb2F0MzIgdG8gZmxvYXQxNlxuXG5mdW5jdGlvbiB0b0hhbGZGbG9hdCggdmFsICkge1xuXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcblxuXHR2YWwgPSBjbGFtcCggdmFsLCAtIDY1NTA0LCA2NTUwNCApO1xuXG5cdF90YWJsZXMuZmxvYXRWaWV3WyAwIF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbIDAgXTtcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVsgZSBdICsgKCAoIGYgJiAweDAwN2ZmZmZmICkgPj4gX3RhYmxlcy5zaGlmdFRhYmxlWyBlIF0gKTtcblxufVxuXG4vLyBmbG9hdDE2IHRvIGZsb2F0MzJcblxuZnVuY3Rpb24gZnJvbUhhbGZGbG9hdCggdmFsICkge1xuXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XG5cdF90YWJsZXMudWludDMyVmlld1sgMCBdID0gX3RhYmxlcy5tYW50aXNzYVRhYmxlWyBfdGFibGVzLm9mZnNldFRhYmxlWyBtIF0gKyAoIHZhbCAmIDB4M2ZmICkgXSArIF90YWJsZXMuZXhwb25lbnRUYWJsZVsgbSBdO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbIDAgXTtcblxufVxuXG5jb25zdCBEYXRhVXRpbHMgPSB7XG5cdHRvSGFsZkZsb2F0OiB0b0hhbGZGbG9hdCxcblx0ZnJvbUhhbGZGbG9hdDogZnJvbUhhbGZGbG9hdCxcbn07XG5cbmV4cG9ydCB7XG5cdHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0LFxuXHREYXRhVXRpbHNcbn07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgQm94MyB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiA9IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICksIG1heCA9IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICkgKSB7XG5cblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0KCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3Rvci5mcm9tQXJyYXkoIGFycmF5LCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSA9IGZhbHNlICkge1xuXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2JveC5jb3B5KCBvYmplY3QuYm91bmRpbmdCb3ggKTtcblx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy51bmlvbiggX2JveCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIHByZWNpc2UgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkgKS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2JveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXHRcdFx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHRoaXMudW5pb24oIF9ib3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeU9iamVjdCggY2hpbGRyZW5bIGkgXSwgcHJlY2lzZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cblx0fVxuXG5cdGNvbnRhaW5zQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmXG5cdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblxuXHR9XG5cblx0Z2V0UGFyYW1ldGVyKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXG5cdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcblx0XHQpO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcblx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIF92ZWN0b3IgKTtcblxuXHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdHJldHVybiBfdmVjdG9yLmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0dGhpcy5nZXRDZW50ZXIoIF9jZW50ZXIgKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgX2NlbnRlciApO1xuXG5cdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0X3YwLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmEsIF9jZW50ZXIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgX2NlbnRlciApO1xuXHRcdF92Mi5zdWJWZWN0b3JzKCB0cmlhbmdsZS5jLCBfY2VudGVyICk7XG5cblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcblx0XHRfZjAuc3ViVmVjdG9ycyggX3YxLCBfdjAgKTtcblx0XHRfZjEuc3ViVmVjdG9ycyggX3YyLCBfdjEgKTtcblx0XHRfZjIuc3ViVmVjdG9ycyggX3YwLCBfdjIgKTtcblxuXHRcdC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXHRcdGxldCBheGVzID0gW1xuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcblx0XHRcdF9mMC56LCAwLCAtIF9mMC54LCBfZjEueiwgMCwgLSBfZjEueCwgX2YyLnosIDAsIC0gX2YyLngsXG5cdFx0XHQtIF9mMC55LCBfZjAueCwgMCwgLSBfZjEueSwgX2YxLngsIDAsIC0gX2YyLnksIF9mMi54LCAwXG5cdFx0XTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHVzZSBhbHJlYWR5IGV4aXN0aW5nIHRyaWFuZ2xlIGVkZ2UgdmVjdG9ycyBoZXJlXG5cdFx0X3RyaWFuZ2xlTm9ybWFsLmNyb3NzVmVjdG9ycyggX2YwLCBfZjEgKTtcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XG5cblx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciApLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0fVxuXG5cdGdldEJvdW5kaW5nU3BoZXJlKCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmdldENlbnRlciggdGFyZ2V0LmNlbnRlciApO1xuXG5cdFx0XHR0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKCBfdmVjdG9yICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRpbnRlcnNlY3QoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG5cdFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCwgdGhlIHJlc3VsdCBpcyBmdWxseSBlbXB0eSwgbm90IHNsaWdodGx5IGVtcHR5IHdpdGggbm9uLWluZi8raW5mIHZhbHVlcyB0aGF0IHdpbGwgY2F1c2Ugc3Vic2VxdWVuY2UgaW50ZXJzZWN0cyB0byBlcnJvbmVvdXNseSByZXR1cm4gdmFsaWQgdmFsdWVzLlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuXHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0X3BvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdF9wb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcblx0XHRfcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0X3BvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdF9wb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcblx0XHRfcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0X3BvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdF9wb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcblxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggX3BvaW50cyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcG9pbnRzID0gW1xuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKVxuXTtcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcblxuLy8gdHJpYW5nbGUgY2VudGVyZWQgdmVydGljZXNcblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblxuY29uc3QgX2YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfY2VudGVyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2V4dGVudHMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGVOb3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVzdEF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMsIHYwLCB2MSwgdjIsIGV4dGVudHMgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcblxuXHRcdF90ZXN0QXhpcy5mcm9tQXJyYXkoIGF4ZXMsIGkgKTtcblx0XHQvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuXHRcdGNvbnN0IHIgPSBleHRlbnRzLnggKiBNYXRoLmFicyggX3Rlc3RBeGlzLnggKSArIGV4dGVudHMueSAqIE1hdGguYWJzKCBfdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIF90ZXN0QXhpcy56ICk7XG5cdFx0Ly8gcHJvamVjdCBhbGwgMyB2ZXJ0aWNlcyBvZiB0aGUgdHJpYW5nbGUgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgcDAgPSB2MC5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAxID0gdjEuZG90KCBfdGVzdEF4aXMgKTtcblx0XHRjb25zdCBwMiA9IHYyLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Ly8gYWN0dWFsIHRlc3QsIGJhc2ljYWxseSBzZWUgaWYgZWl0aGVyIG9mIHRoZSBtb3N0IGV4dHJlbWUgb2YgdGhlIHRyaWFuZ2xlIHBvaW50cyBpbnRlcnNlY3RzIHJcblx0XHRpZiAoIE1hdGgubWF4KCAtIE1hdGgubWF4KCBwMCwgcDEsIHAyICksIE1hdGgubWluKCBwMCwgcDEsIHAyICkgKSA+IHIgKSB7XG5cblx0XHRcdC8vIHBvaW50cyBvZiB0aGUgcHJvamVjdGVkIHRyaWFuZ2xlIGFyZSBvdXRzaWRlIHRoZSBwcm9qZWN0ZWQgaGFsZi1sZW5ndGggb2YgdGhlIGFhYmJcblx0XHRcdC8vIHRoZSBheGlzIGlzIHNlcGFyYXRpbmcgYW5kIHdlIGNhbiBleGl0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbmV4cG9ydCB7IEJveDMgfTtcbiIsImltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyICk7XG5cblx0fVxuXG5cdHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fVxuXG5cdGVxdWFscyggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fb3JkZXI7XG5cblx0fVxuXG59XG5cbkV1bGVyLkRFRkFVTFRfT1JERVIgPSAnWFlaJztcblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsImNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcztcblxuXHQvLyBNdWxiZXJyeTMyIGdlbmVyYXRvclxuXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcblxuXHR0ID0gTWF0aC5pbXVsKCB0IF4gdCA+Pj4gMTUsIHQgfCAxICk7XG5cblx0dCBePSB0ICsgTWF0aC5pbXVsKCB0IF4gdCA+Pj4gNywgdCB8IDYxICk7XG5cblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgTWF0aFV0aWxzID0ge1xuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59O1xuXG5leHBvcnQge1xuXHRERUcyUkFELFxuXHRSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQsXG5cdGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG8sXG5cdG1hcExpbmVhcixcblx0aW52ZXJzZUxlcnAsXG5cdGxlcnAsXG5cdGRhbXAsXG5cdHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXAsXG5cdHJhbmRJbnQsXG5cdHJhbmRGbG9hdCxcblx0cmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb20sXG5cdGRlZ1RvUmFkLFxuXHRyYWRUb0RlZyxcblx0aXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3byxcblx0Zmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemUsXG5cdGRlbm9ybWFsaXplLFxuXHRNYXRoVXRpbHNcbn07XG4iLCJjbGFzcyBNYXRyaXgzIHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLFxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcblx0XHRcdG4xMyA9IHRlWyA2IF0sIG4yMyA9IHRlWyA3IF0sIG4zMyA9IHRlWyA4IF0sXG5cblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcblxuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGUoIHRoZXRhICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVRyYW5zbGF0aW9uKCB0eCwgdHkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGZvciAyRCBUcmFuc2Zvcm1zXG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCB4LnksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIHksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCxcblx0XHRcdDAsIHksIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vXG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbTMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDMgfTtcbiIsImltcG9ydCB7IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgTWF0cml4NCB7XG5cblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdE1hdHJpeDQucHJvdG90eXBlLmlzTWF0cml4NCA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRdO1xuXG5cdFx0aWYgKCBuMTEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sIDAsXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWCA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuXHRcdGNvbnN0IGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0Y29uc3QgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCBfemVybywgcSwgX29uZSApO1xuXG5cdH1cblxuXHRsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XG5cdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcblx0XHRjb25zdCBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHRjb25zdCBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0Y29uc3QgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZXRlcm1pbmFudCgpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuXHRcdGNvbnN0IG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuXHRcdGNvbnN0IG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHRjb25zdCBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdG40MSAqIChcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0KSArXG5cdFx0XHRuNDIgKiAoXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQzICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40NCAqIChcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0KVxuXG5cdFx0KTtcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGxldCB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UG9zaXRpb24oIHgsIHksIHogKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLCBuNDEgPSB0ZVsgMyBdLFxuXHRcdFx0bjEyID0gdGVbIDQgXSwgbjIyID0gdGVbIDUgXSwgbjMyID0gdGVbIDYgXSwgbjQyID0gdGVbIDcgXSxcblx0XHRcdG4xMyA9IHRlWyA4IF0sIG4yMyA9IHRlWyA5IF0sIG4zMyA9IHRlWyAxMCBdLCBuNDMgPSB0ZVsgMTEgXSxcblx0XHRcdG4xNCA9IHRlWyAxMiBdLCBuMjQgPSB0ZVsgMTMgXSwgbjM0ID0gdGVbIDE0IF0sIG40NCA9IHRlWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHRjb25zdCBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDMgXSA9ICggbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDEyIF0gPSB0MTQgKiBkZXRJbnY7XG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTUgXSA9ICggbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHYgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXhTY2FsZU9uQXhpcygpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdGNvbnN0IHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cblx0fVxuXG5cdG1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgueCxcblx0XHRcdFx0MCwgMSwgMCwgeC55LFxuXHRcdFx0XHQwLCAwLCAxLCB4LnosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25YKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHQwLCBzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25ZKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtIHMsIDAsIGMsIDAsXG5cdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25aKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHRjb25zdCB0ID0gMSAtIGM7XG5cdFx0Y29uc3QgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHRjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNoZWFyKCB4eSwgeHosIHl4LCB5eiwgengsIHp5ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHl4LCB6eCwgMCxcblx0XHRcdHh5LCAxLCB6eSwgMCxcblx0XHRcdHh6LCB5eiwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgeCA9IHF1YXRlcm5pb24uX3gsIHkgPSBxdWF0ZXJuaW9uLl95LCB6ID0gcXVhdGVybmlvbi5feiwgdyA9IHF1YXRlcm5pb24uX3c7XG5cdFx0Y29uc3QgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0Y29uc3QgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6Mjtcblx0XHRjb25zdCB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuXHRcdGNvbnN0IHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHRjb25zdCBzeCA9IHNjYWxlLngsIHN5ID0gc2NhbGUueSwgc3ogPSBzY2FsZS56O1xuXG5cdFx0dGVbIDAgXSA9ICggMSAtICggeXkgKyB6eiApICkgKiBzeDtcblx0XHR0ZVsgMSBdID0gKCB4eSArIHd6ICkgKiBzeDtcblx0XHR0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xuXHRcdHRlWyA1IF0gPSAoIDEgLSAoIHh4ICsgenogKSApICogc3k7XG5cdFx0dGVbIDYgXSA9ICggeXogKyB3eCApICogc3k7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gKCB4eiArIHd5ICkgKiBzejtcblx0XHR0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcblx0XHR0ZVsgMTAgXSA9ICggMSAtICggeHggKyB5eSApICkgKiBzejtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IHBvc2l0aW9uLng7XG5cdFx0dGVbIDEzIF0gPSBwb3NpdGlvbi55O1xuXHRcdHRlWyAxNCBdID0gcG9zaXRpb24uejtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRsZXQgc3ggPSBfdjEuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0aWYgKCBkZXQgPCAwICkgc3ggPSAtIHN4O1xuXG5cdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXHRcdF9tMS5jb3B5KCB0aGlzICk7XG5cblx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRjb25zdCBpbnZTWSA9IDEgLyBzeTtcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuXHRcdF9tMS5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRfbTEuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRsZXQgYywgZDtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSAyICogZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7IFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7IFx0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcbmNvbnN0IF9vbmUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5jb25zdCBfeCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF95ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ogPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbmNsYXNzIFF1YXRlcm5pb24ge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdHRoaXMuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdH1cblxuXHRzdGF0aWMgc2xlcnBGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdGxldCB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG5cdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRpZiAoIHQgPT09IDAgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzE7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcblxuXHRcdFx0bGV0IHMgPSAxIC0gdDtcblx0XHRcdGNvbnN0IGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0eTAgKj0gZjtcblx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0dzAgKj0gZjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG5cdH1cblxuXHRzdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxICkge1xuXG5cdFx0Y29uc3QgeDAgPSBzcmMwWyBzcmNPZmZzZXQwIF07XG5cdFx0Y29uc3QgeTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdO1xuXHRcdGNvbnN0IHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXTtcblx0XHRjb25zdCB3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgXTtcblx0XHRjb25zdCB5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF07XG5cdFx0Y29uc3QgejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdO1xuXHRcdGNvbnN0IHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MCAqIHcxICsgdzAgKiB4MSArIHkwICogejEgLSB6MCAqIHkxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowICogdzEgKyB3MCAqIHoxICsgeDAgKiB5MSAtIHkwICogeDE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MCAqIHcxIC0geDAgKiB4MSAtIHkwICogeTEgLSB6MCAqIHoxO1xuXG5cdFx0cmV0dXJuIGRzdDtcblxuXHR9XG5cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9XG5cblx0c2V0IHkoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHooKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9XG5cblx0c2V0IHooIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9XG5cblx0c2V0IHcoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cblx0Y29weSggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUV1bGVyKCBldWxlciwgdXBkYXRlICkge1xuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdGNvbnN0IGMxID0gY29zKCB4IC8gMiApO1xuXHRcdGNvbnN0IGMyID0gY29zKCB5IC8gMiApO1xuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0Y29uc3QgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XG5cdFx0Y29uc3QgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0bGV0IHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHQvLyB2RnJvbSBhbmQgdlRvIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIE1hdGhVdGlscy5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0Ly8gRGVyaXZlZCBmcm9tIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcblx0XHQvLyBOb3RlLCB0aGlzIHNvdXJjZSB1c2VzIHcsIHgsIHksIHogb3JkZXJpbmcsXG5cdFx0Ly8gc28gd2Ugc3dhcCB0aGUgb3JkZXIgYmVsb3cuXG5cblx0XHRjb25zdCB1MSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3Qgc3FydDF1MSA9IE1hdGguc3FydCggMSAtIHUxICk7XG5cdFx0Y29uc3Qgc3FydHUxID0gTWF0aC5zcXJ0KCB1MSApO1xuXG5cdFx0Y29uc3QgdTIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cblx0XHRjb25zdCB1MyA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzLnNldChcblx0XHRcdHNxcnQxdTEgKiBNYXRoLmNvcyggdTIgKSxcblx0XHRcdHNxcnR1MSAqIE1hdGguc2luKCB1MyApLFxuXHRcdFx0c3FydHUxICogTWF0aC5jb3MoIHUzICksXG5cdFx0XHRzcXJ0MXUxICogTWF0aC5zaW4oIHUyICksXG5cdFx0KTtcblxuXHR9XG5cblx0ZXF1YWxzKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KCk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fdztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4vQm94My5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BoZXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xuXG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0fVxuXG5cdHNldCggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG5cdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2JveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNwaGVyZSApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDwgMCApO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHR0aGlzLnJhZGl1cyA9IC0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Y29uc3QgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNQbGFuZSggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH1cblxuXHRjbGFtcFBvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0dGFyZ2V0LmNvcHkoIHBvaW50ICk7XG5cblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0dGFyZ2V0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0Ly8gRW1wdHkgc3BoZXJlIHByb2R1Y2VzIGVtcHR5IGJvdW5kaW5nIGJveFxuXHRcdFx0dGFyZ2V0Lm1ha2VFbXB0eSgpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuXHRcdHRhcmdldC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdF92MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5jZW50ZXIgKTtcblxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxLmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgbWluaW1hbCBzcGhlcmVcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCBsZW5ndGhTcSApO1xuXG5cdFx0XHRjb25zdCBkZWx0YSA9ICggbGVuZ3RoIC0gdGhpcy5yYWRpdXMgKSAqIDAuNTtcblxuXHRcdFx0dGhpcy5jZW50ZXIuYWRkU2NhbGVkVmVjdG9yKCBfdjEsIGRlbHRhIC8gbGVuZ3RoICk7XG5cblx0XHRcdHRoaXMucmFkaXVzICs9IGRlbHRhO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBzcGhlcmUgKSB7XG5cblx0XHRpZiAoIHNwaGVyZS5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBzcGhlcmUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY2VudGVyLmVxdWFscyggc3BoZXJlLmNlbnRlciApID09PSB0cnVlICkge1xuXG5cdFx0XHQgdGhpcy5yYWRpdXMgPSBNYXRoLm1heCggdGhpcy5yYWRpdXMsIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF92Mi5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuYWRkKCBfdjIgKSApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyZSB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgVmVjdG9yMiB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCApIHtcblxuXHRcdFZlY3RvcjIucHJvdG90eXBlLmlzVmVjdG9yMiA9IHRydWU7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcblxuXHRcdHJldHVybiB0aGlzLng7XG5cblx0fVxuXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnggPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnk7XG5cblx0fVxuXG5cdHNldCBoZWlnaHQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy55ID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldCggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZSggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcblxuXHR9XG5cblx0Zmxvb3IoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZWlsKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnRydW5jKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnRydW5jKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH1cblxuXHRjcm9zcyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdGFuZ2xlKCkge1xuXG5cdFx0Ly8gY29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXNcblxuXHRcdGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMiggLSB0aGlzLnksIC0gdGhpcy54ICkgKyBNYXRoLlBJO1xuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXG5cdH1cblxuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIE1hdGhVdGlscy5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH1cblxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcblxuXHR9XG5cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVBcm91bmQoIGNlbnRlciwgYW5nbGUgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHRjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZlY3RvcjIgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcblxuY2xhc3MgVmVjdG9yMyB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAgKSB7XG5cblx0XHRWZWN0b3IzLnByb3RvdHlwZS5pc1ZlY3RvcjMgPSB0cnVlO1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFgoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFkoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseUV1bGVyKCBldWxlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMoIG0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0Y29uc3QgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC50cnVuYyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IgKTtcblxuXHR9XG5cblx0cmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdH1cblxuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWwoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9XG5cblx0c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKSB7XG5cblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDEyIF07XG5cdFx0dGhpcy55ID0gZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhTY2FsZSggbSApIHtcblxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4M0NvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRzZXRGcm9tRXVsZXIoIGUgKSB7XG5cblx0XHR0aGlzLnggPSBlLl94O1xuXHRcdHRoaXMueSA9IGUuX3k7XG5cdFx0dGhpcy56ID0gZS5fejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ29sb3IoIGMgKSB7XG5cblx0XHR0aGlzLnggPSBjLnI7XG5cdFx0dGhpcy55ID0gYy5nO1xuXHRcdHRoaXMueiA9IGMuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbURpcmVjdGlvbigpIHtcblxuXHRcdC8vIERlcml2ZWQgZnJvbSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXG5cdFx0Y29uc3QgdSA9ICggTWF0aC5yYW5kb20oKSAtIDAuNSApICogMjtcblx0XHRjb25zdCB0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnNxcnQoIDEgLSB1ICoqIDIgKTtcblxuXHRcdHRoaXMueCA9IGYgKiBNYXRoLmNvcyggdCApO1xuXHRcdHRoaXMueSA9IGYgKiBNYXRoLnNpbiggdCApO1xuXHRcdHRoaXMueiA9IHU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5leHBvcnQgeyBWZWN0b3IzIH07XG4iLCJmdW5jdGlvbiBhcnJheU1pbiggYXJyYXkgKSB7XG5cblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gSW5maW5pdHk7XG5cblx0bGV0IG1pbiA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA8IG1pbiApIG1pbiA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtaW47XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlNYXgoIGFycmF5ICkge1xuXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIC0gSW5maW5pdHk7XG5cblx0bGV0IG1heCA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+IG1heCApIG1heCA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtYXg7XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlOZWVkc1VpbnQzMiggYXJyYXkgKSB7XG5cblx0Ly8gYXNzdW1lcyBsYXJnZXIgdmFsdWVzIHVzdWFsbHkgb24gbGFzdFxuXG5cdGZvciAoIGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLSBpICkge1xuXG5cdFx0aWYgKCBhcnJheVsgaSBdID49IDY1NTM1ICkgcmV0dXJuIHRydWU7IC8vIGFjY291bnQgZm9yIFBSSU1JVElWRV9SRVNUQVJUX0ZJWEVEX0lOREVYLCAjMjQ1NjVcblxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmNvbnN0IFRZUEVEX0FSUkFZUyA9IHtcblx0SW50OEFycmF5OiBJbnQ4QXJyYXksXG5cdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcblx0SW50MTZBcnJheTogSW50MTZBcnJheSxcblx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuXHRVaW50MzJBcnJheTogVWludDMyQXJyYXksXG5cdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxufTtcblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheSggdHlwZSwgYnVmZmVyICkge1xuXG5cdHJldHVybiBuZXcgVFlQRURfQVJSQVlTWyB0eXBlIF0oIGJ1ZmZlciApO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyggbmFtZSApIHtcblxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xuXG5cdGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblx0Y2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRyZXR1cm4gY2FudmFzO1xuXG59XG5cbmNvbnN0IF9jYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuT25jZSggbWVzc2FnZSApIHtcblxuXHRpZiAoIG1lc3NhZ2UgaW4gX2NhY2hlICkgcmV0dXJuO1xuXG5cdF9jYWNoZVsgbWVzc2FnZSBdID0gdHJ1ZTtcblxuXHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblxufVxuXG5leHBvcnQgeyBhcnJheU1pbiwgYXJyYXlNYXgsIGFycmF5TmVlZHNVaW50MzIsIGdldFR5cGVkQXJyYXksIGNyZWF0ZUVsZW1lbnROUywgY3JlYXRlQ2FudmFzRWxlbWVudCwgd2Fybk9uY2UgfTtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHJpYW5ndWxhdGVDdWJlXG5cbnZhciBwZXJtID0gcmVxdWlyZShcInBlcm11dGF0aW9uLXJhbmtcIilcbnZhciBzZ24gPSByZXF1aXJlKFwicGVybXV0YXRpb24tcGFyaXR5XCIpXG52YXIgZ2FtbWEgPSByZXF1aXJlKFwiZ2FtbWFcIilcblxuZnVuY3Rpb24gdHJpYW5ndWxhdGVDdWJlKGRpbWVuc2lvbikge1xuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgcmV0dXJuIFsgXVxuICB9XG4gIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBbIFswXSBdXG4gIH1cbiAgdmFyIGRmYWN0b3JpYWwgPSBNYXRoLnJvdW5kKGdhbW1hKGRpbWVuc2lvbisxKSl8MFxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTA7IGk8ZGZhY3RvcmlhbDsgKytpKSB7XG4gICAgdmFyIHAgPSBwZXJtLnVucmFuayhkaW1lbnNpb24sIGkpXG4gICAgdmFyIGNlbGwgPSBbIDAgXVxuICAgIHZhciB2ID0gMFxuICAgIGZvcih2YXIgaj0wOyBqPHAubGVuZ3RoOyArK2opIHtcbiAgICAgIHYgKz0gKDE8PHBbal0pXG4gICAgICBjZWxsLnB1c2godilcbiAgICB9XG4gICAgaWYoc2duKHApIDwgMSkge1xuICAgICAgY2VsbFswXSA9IHZcbiAgICAgIGNlbGxbZGltZW5zaW9uXSA9IDBcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goY2VsbClcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSB0d29Qcm9kdWN0XG5cbnZhciBTUExJVFRFUiA9ICsoTWF0aC5wb3coMiwgMjcpICsgMS4wKVxuXG5mdW5jdGlvbiB0d29Qcm9kdWN0KGEsIGIsIHJlc3VsdCkge1xuICB2YXIgeCA9IGEgKiBiXG5cbiAgdmFyIGMgPSBTUExJVFRFUiAqIGFcbiAgdmFyIGFiaWcgPSBjIC0gYVxuICB2YXIgYWhpID0gYyAtIGFiaWdcbiAgdmFyIGFsbyA9IGEgLSBhaGlcblxuICB2YXIgZCA9IFNQTElUVEVSICogYlxuICB2YXIgYmJpZyA9IGQgLSBiXG4gIHZhciBiaGkgPSBkIC0gYmJpZ1xuICB2YXIgYmxvID0gYiAtIGJoaVxuXG4gIHZhciBlcnIxID0geCAtIChhaGkgKiBiaGkpXG4gIHZhciBlcnIyID0gZXJyMSAtIChhbG8gKiBiaGkpXG4gIHZhciBlcnIzID0gZXJyMiAtIChhaGkgKiBibG8pXG5cbiAgdmFyIHkgPSBhbG8gKiBibG8gLSBlcnIzXG5cbiAgaWYocmVzdWx0KSB7XG4gICAgcmVzdWx0WzBdID0geVxuICAgIHJlc3VsdFsxXSA9IHhcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gWyB5LCB4IF1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RUd29TdW1cblxuZnVuY3Rpb24gZmFzdFR3b1N1bShhLCBiLCByZXN1bHQpIHtcblx0dmFyIHggPSBhICsgYlxuXHR2YXIgYnYgPSB4IC0gYVxuXHR2YXIgYXYgPSB4IC0gYnZcblx0dmFyIGJyID0gYiAtIGJ2XG5cdHZhciBhciA9IGEgLSBhdlxuXHRpZihyZXN1bHQpIHtcblx0XHRyZXN1bHRbMF0gPSBhciArIGJyXG5cdFx0cmVzdWx0WzFdID0geFxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXHRyZXR1cm4gW2FyK2JyLCB4XVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQklHVUlOVDY0IDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCSUdJTlQ2NCAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICAgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ1VpbnQ2NCA9ICh0eXBlb2YgQmlnVWludDY0QXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ0ludDY0ID0gKHR5cGVvZiBCaWdJbnQ2NEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJJR1VJTlQ2NCkge1xuICBQT09MLkJJR1VJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQklHSU5UNjQpIHtcbiAgUE9PTC5CSUdJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUJpZ1VpbnQ2NCA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUJpZ0ludDY0ID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2JpZ2ludDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0JpZ0ludDY0KG4pXG4gICAgICBjYXNlICdiaWd1aW50NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jQmlnVWludDY0KG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jQmlnVWludDY0KG4pIHtcbiAgaWYoaGFzQmlnVWludDY0KSB7XG4gICAgcmV0dXJuIG5ldyBCaWdVaW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ1VpbnQ2NCA9IG1hbGxvY0JpZ1VpbnQ2NFxuXG5mdW5jdGlvbiBtYWxsb2NCaWdJbnQ2NChuKSB7XG4gIGlmIChoYXNCaWdJbnQ2NCkge1xuICAgIHJldHVybiBuZXcgQmlnSW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ0ludDY0ID0gbWFsbG9jQmlnSW50NjRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5CSUdVSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuQklHSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbkZpbmQ7XG5cbmZ1bmN0aW9uIFVuaW9uRmluZChjb3VudCkge1xuICB0aGlzLnJvb3RzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgdGhpcy5yYW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIFxuICBmb3IodmFyIGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgdGhpcy5yb290c1tpXSA9IGk7XG4gICAgdGhpcy5yYW5rc1tpXSA9IDA7XG4gIH1cbn1cblxudmFyIHByb3RvID0gVW5pb25GaW5kLnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgXCJnZXRcIjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdHMubGVuZ3RoXG4gIH1cbn0pXG5cbnByb3RvLm1ha2VTZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSB0aGlzLnJvb3RzLmxlbmd0aDtcbiAgdGhpcy5yb290cy5wdXNoKG4pO1xuICB0aGlzLnJhbmtzLnB1c2goMCk7XG4gIHJldHVybiBuO1xufVxuXG5wcm90by5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeDAgPSB4XG4gIHZhciByb290cyA9IHRoaXMucm9vdHM7XG4gIHdoaWxlKHJvb3RzW3hdICE9PSB4KSB7XG4gICAgeCA9IHJvb3RzW3hdXG4gIH1cbiAgd2hpbGUocm9vdHNbeDBdICE9PSB4KSB7XG4gICAgdmFyIHkgPSByb290c1t4MF1cbiAgICByb290c1t4MF0gPSB4XG4gICAgeDAgPSB5XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbnByb3RvLmxpbmsgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB4ciA9IHRoaXMuZmluZCh4KVxuICAgICwgeXIgPSB0aGlzLmZpbmQoeSk7XG4gIGlmKHhyID09PSB5cikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmFua3MgPSB0aGlzLnJhbmtzXG4gICAgLCByb290cyA9IHRoaXMucm9vdHNcbiAgICAsIHhkICAgID0gcmFua3NbeHJdXG4gICAgLCB5ZCAgICA9IHJhbmtzW3lyXTtcbiAgaWYoeGQgPCB5ZCkge1xuICAgIHJvb3RzW3hyXSA9IHlyO1xuICB9IGVsc2UgaWYoeWQgPCB4ZCkge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICAgICsrcmFua3NbeHJdO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUZXh0XG5cbnZhciB2ZWN0b3JpemVUZXh0ID0gcmVxdWlyZShcIi4vbGliL3Z0ZXh0XCIpXG52YXIgZGVmYXVsdENhbnZhcyA9IG51bGxcbnZhciBkZWZhdWx0Q29udGV4dCA9IG51bGxcblxuaWYodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkZWZhdWx0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgZGVmYXVsdENhbnZhcy53aWR0aCA9IDgxOTJcbiAgZGVmYXVsdENhbnZhcy5oZWlnaHQgPSAxMDI0XG4gIGRlZmF1bHRDb250ZXh0ID0gZGVmYXVsdENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dChzdHIsIG9wdGlvbnMpIHtcbiAgaWYoKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB8fCAob3B0aW9ucyA9PT0gbnVsbCkpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuICByZXR1cm4gdmVjdG9yaXplVGV4dChcbiAgICBzdHIsXG4gICAgb3B0aW9ucy5jYW52YXMgfHwgZGVmYXVsdENhbnZhcyxcbiAgICBvcHRpb25zLmNvbnRleHQgfHwgZGVmYXVsdENvbnRleHQsXG4gICAgb3B0aW9ucylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdmVjdG9yaXplVGV4dFxubW9kdWxlLmV4cG9ydHMucHJvY2Vzc1BpeGVscyA9IHByb2Nlc3NQaXhlbHNcblxudmFyIHN1cmZhY2VOZXRzID0gcmVxdWlyZSgnc3VyZmFjZS1uZXRzJylcbnZhciBuZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKCdzaW1wbGlmeS1wbGFuYXItZ3JhcGgnKVxudmFyIGNsZWFuUFNMRyA9IHJlcXVpcmUoJ2NsZWFuLXBzbGcnKVxudmFyIGNkdDJkID0gcmVxdWlyZSgnY2R0MmQnKVxudmFyIHRvUG9seWdvbkNyYXBweSA9IHJlcXVpcmUoJ3BsYW5hci1ncmFwaC10by1wb2x5bGluZScpXG5cbnZhciBUQUdfYm9sZCA9IFwiYlwiXG52YXIgQ0hSX2JvbGQgPSAnYnwnXG5cbnZhciBUQUdfaXRhbGljID0gXCJpXCJcbnZhciBDSFJfaXRhbGljID0gJ2l8J1xuXG52YXIgVEFHX3N1cGVyID0gXCJzdXBcIlxudmFyIENIUl9zdXBlcjAgPSAnKydcbnZhciBDSFJfc3VwZXIgPSAnKzEnXG5cbnZhciBUQUdfc3ViID0gXCJzdWJcIlxudmFyIENIUl9zdWIwID0gJy0nXG52YXIgQ0hSX3N1YiA9ICctMSdcblxuZnVuY3Rpb24gcGFyc2VUYWcodGFnLCBUQUdfQ0hSLCBzdHIsIG1hcCkge1xuXG4gIHZhciBvcG5UYWcgPSAgXCI8XCIgICsgdGFnICsgXCI+XCJcbiAgdmFyIGNsc1RhZyA9ICBcIjwvXCIgKyB0YWcgKyBcIj5cIlxuXG4gIHZhciBuT1BOID0gb3BuVGFnLmxlbmd0aFxuICB2YXIgbkNMUyA9IGNsc1RhZy5sZW5ndGhcblxuICB2YXIgaXNSZWN1cnNpdmUgPSAoVEFHX0NIUlswXSA9PT0gQ0hSX3N1cGVyMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKFRBR19DSFJbMF0gPT09IENIUl9zdWIwKTtcblxuICB2YXIgYSA9IDBcbiAgdmFyIGIgPSAtbkNMU1xuICB3aGlsZSAoYSA+IC0xKSB7XG4gICAgYSA9IHN0ci5pbmRleE9mKG9wblRhZywgYSlcbiAgICBpZihhID09PSAtMSkgYnJlYWtcblxuICAgIGIgPSBzdHIuaW5kZXhPZihjbHNUYWcsIGEgKyBuT1BOKVxuICAgIGlmKGIgPT09IC0xKSBicmVha1xuXG4gICAgaWYoYiA8PSBhKSBicmVha1xuXG4gICAgZm9yKHZhciBpID0gYTsgaSA8IGIgKyBuQ0xTOyArK2kpe1xuICAgICAgaWYoKGkgPCBhICsgbk9QTikgfHwgKGkgPj0gYikpIHtcbiAgICAgICAgbWFwW2ldID0gbnVsbFxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIGkpICsgXCIgXCIgKyBzdHIuc3Vic3RyKGkgKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYobWFwW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IG1hcFtpXS5pbmRleE9mKFRBR19DSFJbMF0pXG4gICAgICAgICAgaWYocG9zID09PSAtMSkge1xuICAgICAgICAgICAgbWFwW2ldICs9IFRBR19DSFJcbiAgICAgICAgICB9IGVsc2UgeyAvLyBpLmUuIHRvIGhhbmRsZSBtdWx0aXBsZSBzdWIvc3VwZXItc2NyaXB0c1xuICAgICAgICAgICAgaWYoaXNSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgLy8gaS5lIHRvIGluY3JlYXNlIHRoZSBzdWIvc3VwIG51bWJlclxuICAgICAgICAgICAgICBtYXBbaV0gPSBtYXBbaV0uc3Vic3RyKDAsIHBvcyArIDEpICsgKDEgKyBwYXJzZUludChtYXBbaV1bcG9zICsgMV0pKSArIG1hcFtpXS5zdWJzdHIocG9zICsgMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBhICsgbk9QTlxuICAgIHZhciByZW1haW5pbmdTdHIgPSBzdHIuc3Vic3RyKHN0YXJ0LCBiIC0gc3RhcnQpXG5cbiAgICB2YXIgYyA9IHJlbWFpbmluZ1N0ci5pbmRleE9mKG9wblRhZylcbiAgICBpZihjICE9PSAtMSkgYSA9IGNcbiAgICBlbHNlIGEgPSBiICsgbkNMU1xuICB9XG5cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3NpdGlvbnMocG9zaXRpb25zLCBvcHRpb25zLCBzaXplKSB7XG4gIHZhciBhbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduIHx8IFwic3RhcnRcIlxuICB2YXIgYmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZSB8fCBcImFscGhhYmV0aWNcIlxuXG4gIHZhciBsbyA9IFsxPDwzMCwgMTw8MzBdXG4gIHZhciBoaSA9IFswLDBdXG4gIHZhciBuID0gcG9zaXRpb25zLmxlbmd0aFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPDI7ICsraikge1xuICAgICAgbG9bal0gPSBNYXRoLm1pbihsb1tqXSwgcFtqXSl8MFxuICAgICAgaGlbal0gPSBNYXRoLm1heChoaVtqXSwgcFtqXSl8MFxuICAgIH1cbiAgfVxuXG4gIHZhciB4U2hpZnQgPSAwXG4gIHN3aXRjaChhbGlnbikge1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHhTaGlmdCA9IC0wLjUgKiAobG9bMF0gKyBoaVswXSlcbiAgICBicmVha1xuXG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgeFNoaWZ0ID0gLWhpWzBdXG4gICAgYnJlYWtcblxuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICB4U2hpZnQgPSAtbG9bMF1cbiAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInZlY3Rvcml6ZS10ZXh0OiBVbnJlY29nbml6ZWQgdGV4dEFsaWduOiAnXCIgKyBhbGlnbiArIFwiJ1wiKVxuICB9XG5cbiAgdmFyIHlTaGlmdCA9IDBcbiAgc3dpdGNoKGJhc2VsaW5lKSB7XG4gICAgY2FzZSBcImhhbmdpbmdcIjpcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICB5U2hpZnQgPSAtbG9bMV1cbiAgICBicmVha1xuXG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgeVNoaWZ0ID0gLTAuNSAqIChsb1sxXSArIGhpWzFdKVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiYWxwaGFiZXRpY1wiOlxuICAgIGNhc2UgXCJpZGVvZ3JhcGhpY1wiOlxuICAgICAgeVNoaWZ0ID0gLTMgKiBzaXplXG4gICAgYnJlYWtcblxuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHlTaGlmdCA9IC1oaVsxXVxuICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVjdG9yaXplLXRleHQ6IFVucmVjb2dpbml6ZWQgdGV4dEJhc2VsaW5lOiAnXCIgKyBiYXNlbGluZSArIFwiJ1wiKVxuICB9XG5cbiAgdmFyIHNjYWxlID0gMS4wIC8gc2l6ZVxuICBpZihcImxpbmVIZWlnaHRcIiBpbiBvcHRpb25zKSB7XG4gICAgc2NhbGUgKj0gK29wdGlvbnMubGluZUhlaWdodFxuICB9IGVsc2UgaWYoXCJ3aWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICBzY2FsZSA9IG9wdGlvbnMud2lkdGggLyAoaGlbMF0gLSBsb1swXSlcbiAgfSBlbHNlIGlmKFwiaGVpZ2h0XCIgaW4gb3B0aW9ucykge1xuICAgIHNjYWxlID0gb3B0aW9ucy5oZWlnaHQgLyAoaGlbMV0gLSBsb1sxXSlcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gWyBzY2FsZSAqIChwWzBdICsgeFNoaWZ0KSwgc2NhbGUgKiAocFsxXSArIHlTaGlmdCkgXVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRQaXhlbHMoY2FudmFzLCBjb250ZXh0LCByYXdTdHJpbmcsIGZvbnRTaXplLCBsaW5lU3BhY2luZywgc3R5bGV0YWdzKSB7XG5cbiAgcmF3U3RyaW5nID0gcmF3U3RyaW5nLnJlcGxhY2UoL1xcbi9nLCAnJykgLy8gZG9uJ3QgYWNjZXB0IFxcbiBpbiB0aGUgaW5wdXRcblxuICBpZihzdHlsZXRhZ3MuYnJlYWtsaW5lcyA9PT0gdHJ1ZSkge1xuICAgIHJhd1N0cmluZyA9IHJhd1N0cmluZy5yZXBsYWNlKC9cXDxiclxcPi9nLCAnXFxuJykgLy8gcmVwbGFjZSA8YnI+IHRhZ3Mgd2l0aCBcXG4gaW4gdGhlIHN0cmluZ1xuICB9IGVsc2Uge1xuICAgIHJhd1N0cmluZyA9IHJhd1N0cmluZy5yZXBsYWNlKC9cXDxiclxcPi9nLCAnICcpIC8vIGRvbid0IGFjY2VwdCA8YnI+IHRhZ3MgaW4gdGhlIGlucHV0IGFuZCByZXBsYWNlIHdpdGggc3BhY2UgaW4gdGhpcyBjYXNlXG4gIH1cblxuICB2YXIgYWN0aXZlU3R5bGUgPSBcIlwiXG4gIHZhciBtYXAgPSBbXVxuICBmb3IoaiA9IDA7IGogPCByYXdTdHJpbmcubGVuZ3RoOyArK2opIHtcbiAgICBtYXBbal0gPSBhY3RpdmVTdHlsZVxuICB9XG5cbiAgaWYoc3R5bGV0YWdzLmJvbGRzID09PSB0cnVlKSBtYXAgPSBwYXJzZVRhZyhUQUdfYm9sZCwgQ0hSX2JvbGQsIHJhd1N0cmluZywgbWFwKVxuICBpZihzdHlsZXRhZ3MuaXRhbGljcyA9PT0gdHJ1ZSkgbWFwID0gcGFyc2VUYWcoVEFHX2l0YWxpYywgQ0hSX2l0YWxpYywgcmF3U3RyaW5nLCBtYXApXG4gIGlmKHN0eWxldGFncy5zdXBlcnNjcmlwdHMgPT09IHRydWUpIG1hcCA9IHBhcnNlVGFnKFRBR19zdXBlciwgQ0hSX3N1cGVyLCByYXdTdHJpbmcsIG1hcClcbiAgaWYoc3R5bGV0YWdzLnN1YnNjcmlwdHMgPT09IHRydWUpIG1hcCA9IHBhcnNlVGFnKFRBR19zdWIsIENIUl9zdWIsIHJhd1N0cmluZywgbWFwKVxuXG4gIHZhciBhbGxTdHlsZXMgPSBbXVxuICB2YXIgcGxhaW5UZXh0ID0gXCJcIlxuICBmb3IoaiA9IDA7IGogPCByYXdTdHJpbmcubGVuZ3RoOyArK2opIHtcbiAgICBpZihtYXBbal0gIT09IG51bGwpIHtcbiAgICAgIHBsYWluVGV4dCArPSByYXdTdHJpbmdbal1cbiAgICAgIGFsbFN0eWxlcy5wdXNoKG1hcFtqXSlcbiAgICB9XG4gIH1cblxuICB2YXIgYWxsVGV4dHMgPSBwbGFpblRleHQuc3BsaXQoJ1xcbicpXG5cbiAgdmFyIG51bWJlck9mTGluZXMgPSBhbGxUZXh0cy5sZW5ndGhcbiAgdmFyIGxpbmVIZWlnaHQgPSBNYXRoLnJvdW5kKGxpbmVTcGFjaW5nICogZm9udFNpemUpXG4gIHZhciBvZmZzZXRYID0gZm9udFNpemVcbiAgdmFyIG9mZnNldFkgPSBmb250U2l6ZSAqIDJcbiAgdmFyIG1heFdpZHRoID0gMFxuICB2YXIgbWluSGVpZ2h0ID0gbnVtYmVyT2ZMaW5lcyAqIGxpbmVIZWlnaHQgKyBvZmZzZXRZXG5cbiAgaWYoY2FudmFzLmhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBtaW5IZWlnaHRcbiAgfVxuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjMDAwXCJcbiAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmZmZcIlxuICB2YXIgaSwgaiwgeFBvcywgeVBvcywgelBvc1xuICB2YXIgbkRvbmUgPSAwXG5cbiAgdmFyIGJ1ZmZlciA9IFwiXCJcbiAgZnVuY3Rpb24gd3JpdGVCdWZmZXIoKSB7XG4gICAgaWYoYnVmZmVyICE9PSBcIlwiKSB7XG4gICAgICB2YXIgZGVsdGEgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGJ1ZmZlcikud2lkdGhcblxuICAgICAgY29udGV4dC5maWxsVGV4dChidWZmZXIsIG9mZnNldFggKyB4UG9zLCBvZmZzZXRZICsgeVBvcylcbiAgICAgIHhQb3MgKz0gZGVsdGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0Rm9udFNpemUoKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBNYXRoLnJvdW5kKHpQb3MpICsgXCJweCBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVN0eWxlKG9sZFN0eWxlLCBuZXdTdHlsZSkge1xuICAgIHZhciBjdHhGb250ID0gXCJcIiArIGNvbnRleHQuZm9udDtcblxuICAgIGlmKHN0eWxldGFncy5zdWJzY3JpcHRzID09PSB0cnVlKSB7XG4gICAgICB2YXIgb2xkSW5kZXhfU3ViID0gb2xkU3R5bGUuaW5kZXhPZihDSFJfc3ViMCk7XG4gICAgICB2YXIgbmV3SW5kZXhfU3ViID0gbmV3U3R5bGUuaW5kZXhPZihDSFJfc3ViMCk7XG5cbiAgICAgIHZhciBvbGRTdWIgPSAob2xkSW5kZXhfU3ViID4gLTEpID8gcGFyc2VJbnQob2xkU3R5bGVbMSArIG9sZEluZGV4X1N1Yl0pIDogMDtcbiAgICAgIHZhciBuZXdTdWIgPSAobmV3SW5kZXhfU3ViID4gLTEpID8gcGFyc2VJbnQobmV3U3R5bGVbMSArIG5ld0luZGV4X1N1Yl0pIDogMDtcblxuICAgICAgaWYob2xkU3ViICE9PSBuZXdTdWIpIHtcbiAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShnZXRUZXh0Rm9udFNpemUoKSwgXCI/cHggXCIpXG4gICAgICAgIHpQb3MgKj0gTWF0aC5wb3coMC43NSwgKG5ld1N1YiAtIG9sZFN1YikpXG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCI/cHggXCIsIGdldFRleHRGb250U2l6ZSgpKVxuICAgICAgfVxuICAgICAgeVBvcyArPSAwLjI1ICogbGluZUhlaWdodCAqIChuZXdTdWIgLSBvbGRTdWIpO1xuICAgIH1cblxuICAgIGlmKHN0eWxldGFncy5zdXBlcnNjcmlwdHMgPT09IHRydWUpIHtcbiAgICAgIHZhciBvbGRJbmRleF9TdXBlciA9IG9sZFN0eWxlLmluZGV4T2YoQ0hSX3N1cGVyMCk7XG4gICAgICB2YXIgbmV3SW5kZXhfU3VwZXIgPSBuZXdTdHlsZS5pbmRleE9mKENIUl9zdXBlcjApO1xuXG4gICAgICB2YXIgb2xkU3VwZXIgPSAob2xkSW5kZXhfU3VwZXIgPiAtMSkgPyBwYXJzZUludChvbGRTdHlsZVsxICsgb2xkSW5kZXhfU3VwZXJdKSA6IDA7XG4gICAgICB2YXIgbmV3U3VwZXIgPSAobmV3SW5kZXhfU3VwZXIgPiAtMSkgPyBwYXJzZUludChuZXdTdHlsZVsxICsgbmV3SW5kZXhfU3VwZXJdKSA6IDA7XG5cbiAgICAgIGlmKG9sZFN1cGVyICE9PSBuZXdTdXBlcikge1xuICAgICAgICBjdHhGb250ID0gY3R4Rm9udC5yZXBsYWNlKGdldFRleHRGb250U2l6ZSgpLCBcIj9weCBcIilcbiAgICAgICAgelBvcyAqPSBNYXRoLnBvdygwLjc1LCAobmV3U3VwZXIgLSBvbGRTdXBlcikpXG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCI/cHggXCIsIGdldFRleHRGb250U2l6ZSgpKVxuICAgICAgfVxuICAgICAgeVBvcyAtPSAwLjI1ICogbGluZUhlaWdodCAqIChuZXdTdXBlciAtIG9sZFN1cGVyKTtcbiAgICB9XG5cbiAgICBpZihzdHlsZXRhZ3MuYm9sZHMgPT09IHRydWUpIHtcbiAgICAgIHZhciB3YXNCb2xkID0gKG9sZFN0eWxlLmluZGV4T2YoQ0hSX2JvbGQpID4gLTEpXG4gICAgICB2YXIgaXNfQm9sZCA9IChuZXdTdHlsZS5pbmRleE9mKENIUl9ib2xkKSA+IC0xKVxuXG4gICAgICBpZighd2FzQm9sZCAmJiBpc19Cb2xkKSB7XG4gICAgICAgIGlmKHdhc0l0YWxpYykge1xuICAgICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCJpdGFsaWMgXCIsIFwiaXRhbGljIGJvbGQgXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4Rm9udCA9IFwiYm9sZCBcIiArIGN0eEZvbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYod2FzQm9sZCAmJiAhaXNfQm9sZCkge1xuICAgICAgICBjdHhGb250ID0gY3R4Rm9udC5yZXBsYWNlKFwiYm9sZCBcIiwgJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoc3R5bGV0YWdzLml0YWxpY3MgPT09IHRydWUpIHtcbiAgICAgIHZhciB3YXNJdGFsaWMgPSAob2xkU3R5bGUuaW5kZXhPZihDSFJfaXRhbGljKSA+IC0xKVxuICAgICAgdmFyIGlzX0l0YWxpYyA9IChuZXdTdHlsZS5pbmRleE9mKENIUl9pdGFsaWMpID4gLTEpXG5cbiAgICAgIGlmKCF3YXNJdGFsaWMgJiYgaXNfSXRhbGljKSB7XG4gICAgICAgIGN0eEZvbnQgPSBcIml0YWxpYyBcIiArIGN0eEZvbnRcbiAgICAgIH1cbiAgICAgIGlmKHdhc0l0YWxpYyAmJiAhaXNfSXRhbGljKSB7XG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCJpdGFsaWMgXCIsICcnKVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSBjdHhGb250XG4gIH1cblxuICBmb3IoaSA9IDA7IGkgPCBudW1iZXJPZkxpbmVzOyArK2kpIHtcbiAgICB2YXIgdHh0ID0gYWxsVGV4dHNbaV0gKyAnXFxuJ1xuICAgIHhQb3MgPSAwXG4gICAgeVBvcyA9IGkgKiBsaW5lSGVpZ2h0XG4gICAgelBvcyA9IGZvbnRTaXplXG5cbiAgICBidWZmZXIgPSBcIlwiXG4gICAgXG4gICAgZm9yKGogPSAwOyBqIDwgdHh0Lmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgc3R5bGUgPSAoaiArIG5Eb25lIDwgYWxsU3R5bGVzLmxlbmd0aCkgPyBhbGxTdHlsZXNbaiArIG5Eb25lXSA6IGFsbFN0eWxlc1thbGxTdHlsZXMubGVuZ3RoIC0gMV1cbiAgICAgIGlmKGFjdGl2ZVN0eWxlID09PSBzdHlsZSkge1xuICAgICAgICBidWZmZXIgKz0gdHh0W2pdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUJ1ZmZlcigpXG4gICAgICAgIGJ1ZmZlciA9IHR4dFtqXVxuXG4gICAgICAgIGlmKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGFuZ2VTdHlsZShhY3RpdmVTdHlsZSwgc3R5bGUpXG4gICAgICAgICAgYWN0aXZlU3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKClcblxuICAgIG5Eb25lICs9IHR4dC5sZW5ndGhcblxuICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQoeFBvcyArIDIgKiBvZmZzZXRYKSB8IDBcbiAgICBpZihtYXhXaWR0aCA8IHdpZHRoKSBtYXhXaWR0aCA9IHdpZHRoXG4gIH1cblxuICAvL0N1dCBwaXhlbHMgZnJvbSBpbWFnZVxuICB2YXIgeEN1dCA9IG1heFdpZHRoXG4gIHZhciB5Q3V0ID0gb2Zmc2V0WSArIGxpbmVIZWlnaHQgKiBudW1iZXJPZkxpbmVzXG4gIHZhciBwaXhlbHMgPSBuZGFycmF5KGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHhDdXQsIHlDdXQpLmRhdGEsIFt5Q3V0LCB4Q3V0LCA0XSlcbiAgcmV0dXJuIHBpeGVscy5waWNrKC0xLCAtMSwgMCkudHJhbnNwb3NlKDEsIDApXG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXIocGl4ZWxzLCBkb1NpbXBsaWZ5KSB7XG4gIHZhciBjb250b3VyID0gc3VyZmFjZU5ldHMocGl4ZWxzLCAxMjgpXG4gIGlmKGRvU2ltcGxpZnkpIHtcbiAgICByZXR1cm4gc2ltcGxpZnkoY29udG91ci5jZWxscywgY29udG91ci5wb3NpdGlvbnMsIDAuMjUpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlZGdlczogY29udG91ci5jZWxscyxcbiAgICBwb3NpdGlvbnM6IGNvbnRvdXIucG9zaXRpb25zXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1BpeGVsc0ltcGwocGl4ZWxzLCBvcHRpb25zLCBzaXplLCBzaW1wbGlmeSkge1xuICAvL0V4dHJhY3QgY29udG91clxuICB2YXIgY29udG91ciA9IGdldENvbnRvdXIocGl4ZWxzLCBzaW1wbGlmeSlcblxuICAvL0FwcGx5IHdhcnAgdG8gcG9zaXRpb25zXG4gIHZhciBwb3NpdGlvbnMgPSB0cmFuc2Zvcm1Qb3NpdGlvbnMoY29udG91ci5wb3NpdGlvbnMsIG9wdGlvbnMsIHNpemUpXG4gIHZhciBlZGdlcyAgICAgPSBjb250b3VyLmVkZ2VzXG4gIHZhciBmbGlwID0gXCJjY3dcIiA9PT0gb3B0aW9ucy5vcmllbnRhdGlvblxuXG4gIC8vQ2xlYW4gdXAgdGhlIFBTTEcsIHJlc29sdmUgc2VsZiBpbnRlcnNlY3Rpb25zLCBldGMuXG4gIGNsZWFuUFNMRyhwb3NpdGlvbnMsIGVkZ2VzKVxuXG4gIC8vSWYgdHJpYW5ndWxhdGUgZmxhZyBwYXNzZWQsIHRyaWFuZ3VsYXRlIHRoZSByZXN1bHRcbiAgaWYob3B0aW9ucy5wb2x5Z29ucyB8fCBvcHRpb25zLnBvbHlnb24gfHwgb3B0aW9ucy5wb2x5bGluZSkge1xuICAgIHZhciByZXN1bHQgPSB0b1BvbHlnb25DcmFwcHkoZWRnZXMsIHBvc2l0aW9ucylcbiAgICB2YXIgbnJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHQubGVuZ3RoKVxuICAgIGZvcih2YXIgaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxvb3BzID0gcmVzdWx0W2ldXG4gICAgICB2YXIgbmxvb3BzID0gbmV3IEFycmF5KGxvb3BzLmxlbmd0aClcbiAgICAgIGZvcih2YXIgaj0wOyBqPGxvb3BzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBsb29wID0gbG9vcHNbal1cbiAgICAgICAgdmFyIG5sb29wID0gbmV3IEFycmF5KGxvb3AubGVuZ3RoKVxuICAgICAgICBmb3IodmFyIGs9MDsgazxsb29wLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgbmxvb3Bba10gPSBwb3NpdGlvbnNbbG9vcFtrXV0uc2xpY2UoKVxuICAgICAgICB9XG4gICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICBubG9vcC5yZXZlcnNlKClcbiAgICAgICAgfVxuICAgICAgICBubG9vcHNbal0gPSBubG9vcFxuICAgICAgfVxuICAgICAgbnJlc3VsdFtpXSA9IG5sb29wc1xuICAgIH1cbiAgICByZXR1cm4gbnJlc3VsdFxuICB9IGVsc2UgaWYob3B0aW9ucy50cmlhbmdsZXMgfHwgb3B0aW9ucy50cmlhbmd1bGF0ZSB8fCBvcHRpb25zLnRyaWFuZ2xlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbGxzOiBjZHQyZChwb3NpdGlvbnMsIGVkZ2VzLCB7XG4gICAgICAgIGRlbGF1bmF5OiBmYWxzZSxcbiAgICAgICAgZXh0ZXJpb3I6IGZhbHNlLFxuICAgICAgICBpbnRlcmlvcjogdHJ1ZVxuICAgICAgfSksXG4gICAgICBwb3NpdGlvbnM6IHBvc2l0aW9uc1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRnZXM6ICAgICBlZGdlcyxcbiAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQaXhlbHMocGl4ZWxzLCBvcHRpb25zLCBzaXplKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3NQaXhlbHNJbXBsKHBpeGVscywgb3B0aW9ucywgc2l6ZSwgdHJ1ZSlcbiAgfSBjYXRjaChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzUGl4ZWxzSW1wbChwaXhlbHMsIG9wdGlvbnMsIHNpemUsIGZhbHNlKVxuICB9IGNhdGNoKGUpIHt9XG4gIGlmKG9wdGlvbnMucG9seWdvbnMgfHwgb3B0aW9ucy5wb2x5bGluZSB8fCBvcHRpb25zLnBvbHlnb24pIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBpZihvcHRpb25zLnRyaWFuZ2xlcyB8fCBvcHRpb25zLnRyaWFuZ3VsYXRlIHx8IG9wdGlvbnMudHJpYW5nbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2VsbHM6IFtdLFxuICAgICAgcG9zaXRpb25zOiBbXVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVkZ2VzOiBbXSxcbiAgICBwb3NpdGlvbnM6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gdmVjdG9yaXplVGV4dChzdHIsIGNhbnZhcywgY29udGV4dCwgb3B0aW9ucykge1xuICB2YXIgc2l6ZSA9IDY0XG4gIHZhciBsaW5lU3BhY2luZyA9IDEuMjVcbiAgdmFyIHN0eWxldGFncyA9IHtcbiAgICBicmVha2xpbmVzOiBmYWxzZSxcbiAgICBib2xkczogZmFsc2UsXG4gICAgaXRhbGljczogZmFsc2UsXG4gICAgc3Vic2NyaXB0czogZmFsc2UsXG4gICAgc3VwZXJzY3JpcHRzOiBmYWxzZVxuICB9XG5cbiAgaWYob3B0aW9ucykge1xuXG4gICAgaWYob3B0aW9ucy5zaXplICYmXG4gICAgICAgb3B0aW9ucy5zaXplID4gMCkgc2l6ZSA9XG4gICAgICAgb3B0aW9ucy5zaXplXG5cbiAgICBpZihvcHRpb25zLmxpbmVTcGFjaW5nICYmXG4gICAgICAgb3B0aW9ucy5saW5lU3BhY2luZyA+IDApIGxpbmVTcGFjaW5nID1cbiAgICAgICBvcHRpb25zLmxpbmVTcGFjaW5nXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJyZWFrbGluZXMpIHN0eWxldGFncy5icmVha2xpbmVzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5icmVha2xpbmVzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJvbGRzKSBzdHlsZXRhZ3MuYm9sZHMgPVxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJvbGRzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLml0YWxpY3MpIHN0eWxldGFncy5pdGFsaWNzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5pdGFsaWNzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLnN1YnNjcmlwdHMpIHN0eWxldGFncy5zdWJzY3JpcHRzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5zdWJzY3JpcHRzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLnN1cGVyc2NyaXB0cykgc3R5bGV0YWdzLnN1cGVyc2NyaXB0cyA9XG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3Muc3VwZXJzY3JpcHRzID8gdHJ1ZSA6IGZhbHNlXG4gIH1cblxuICBjb250ZXh0LmZvbnQgPSBbXG4gICAgb3B0aW9ucy5mb250U3R5bGUsXG4gICAgb3B0aW9ucy5mb250VmFyaWFudCxcbiAgICBvcHRpb25zLmZvbnRXZWlnaHQsXG4gICAgc2l6ZSArIFwicHhcIixcbiAgICBvcHRpb25zLmZvbnRcbiAgXS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkfSkuam9pbihcIiBcIilcbiAgY29udGV4dC50ZXh0QWxpZ24gPSBcInN0YXJ0XCJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIlxuICBjb250ZXh0LmRpcmVjdGlvbiA9IFwibHRyXCJcblxuICB2YXIgcGl4ZWxzID0gZ2V0UGl4ZWxzKGNhbnZhcywgY29udGV4dCwgc3RyLCBzaXplLCBsaW5lU3BhY2luZywgc3R5bGV0YWdzKVxuXG4gIHJldHVybiBwcm9jZXNzUGl4ZWxzKHBpeGVscywgb3B0aW9ucywgc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnY3dpc2UtY29tcGlsZXInKSh7XG4gICAgYXJnczogWydhcnJheScsIHtcbiAgICAgICAgb2Zmc2V0OiBbMV0sXG4gICAgICAgIGFycmF5OiAwXG4gICAgfSwgJ3NjYWxhcicsICdzY2FsYXInLCAnaW5kZXgnXSxcbiAgICBwcmU6IHtcbiAgICAgICAgXCJib2R5XCI6IFwie31cIixcbiAgICAgICAgXCJhcmdzXCI6IFtdLFxuICAgICAgICBcInRoaXNWYXJzXCI6IFtdLFxuICAgICAgICBcImxvY2FsVmFyc1wiOiBbXVxuICAgIH0sXG4gICAgcG9zdDoge1xuICAgICAgICBcImJvZHlcIjogXCJ7fVwiLFxuICAgICAgICBcImFyZ3NcIjogW10sXG4gICAgICAgIFwidGhpc1ZhcnNcIjogW10sXG4gICAgICAgIFwibG9jYWxWYXJzXCI6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICAgIFwiYm9keVwiOiBcIntcXG4gICAgICAgIHZhciBfaW5saW5lXzFfZGEgPSBfaW5saW5lXzFfYXJnMF8gLSBfaW5saW5lXzFfYXJnM19cXG4gICAgICAgIHZhciBfaW5saW5lXzFfZGIgPSBfaW5saW5lXzFfYXJnMV8gLSBfaW5saW5lXzFfYXJnM19cXG4gICAgICAgIGlmKChfaW5saW5lXzFfZGEgPj0gMCkgIT09IChfaW5saW5lXzFfZGIgPj0gMCkpIHtcXG4gICAgICAgICAgX2lubGluZV8xX2FyZzJfLnB1c2goX2lubGluZV8xX2FyZzRfWzBdICsgMC41ICsgMC41ICogKF9pbmxpbmVfMV9kYSArIF9pbmxpbmVfMV9kYikgLyAoX2lubGluZV8xX2RhIC0gX2lubGluZV8xX2RiKSlcXG4gICAgICAgIH1cXG4gICAgICB9XCIsXG4gICAgICAgIFwiYXJnc1wiOiBbe1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzBfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzFfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzJfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzNfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzRfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfV0sXG4gICAgICAgIFwidGhpc1ZhcnNcIjogW10sXG4gICAgICAgIFwibG9jYWxWYXJzXCI6IFtcIl9pbmxpbmVfMV9kYVwiLCBcIl9pbmxpbmVfMV9kYlwiXVxuICAgIH0sXG4gICAgZnVuY05hbWU6ICd6ZXJvQ3Jvc3NpbmdzJ1xufSlcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFplcm9Dcm9zc2luZ3NcblxudmFyIGNvcmUgPSByZXF1aXJlKFwiLi9saWIvemMtY29yZVwiKVxuXG5mdW5jdGlvbiBmaW5kWmVyb0Nyb3NzaW5ncyhhcnJheSwgbGV2ZWwpIHtcbiAgdmFyIGNyb3NzID0gW11cbiAgbGV2ZWwgPSArbGV2ZWwgfHwgMC4wXG4gIGNvcmUoYXJyYXkuaGkoYXJyYXkuc2hhcGVbMF0tMSksIGNyb3NzLCBsZXZlbClcbiAgcmV0dXJuIGNyb3NzXG59IiwiLy8gaGFuZGxlcyBjb2RlIGV2YWx1YXRpb24gYW5kIGF0dGFjaGluZyByZWxldmFudCBvYmplY3RzIHRvIGdsb2JhbCBhbmQgZXZhbHVhdGlvbiBjb250ZXh0c1xuXG5pbXBvcnQgU2FuZGJveCBmcm9tICcuL2xpYi9zYW5kYm94LmpzJ1xuaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG5cbmNsYXNzIEV2YWxTYW5kYm94IHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBtYWtlR2xvYmFsLCB1c2VyUHJvcHMgPSBbXSkge1xuICAgIHRoaXMubWFrZUdsb2JhbCA9IG1ha2VHbG9iYWxcbiAgICB0aGlzLnNhbmRib3ggPSBTYW5kYm94KHBhcmVudClcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgIHZhciBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMocGFyZW50KVxuICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHRoaXMuYWRkKHByb3BlcnR5KSlcbiAgICB0aGlzLnVzZXJQcm9wcyA9IHVzZXJQcm9wc1xuICB9XG5cbiAgYWRkKG5hbWUpIHtcbiAgICBpZih0aGlzLm1ha2VHbG9iYWwpIHdpbmRvd1tuYW1lXSA9IHRoaXMucGFyZW50W25hbWVdXG4gICAgLy8gdGhpcy5zYW5kYm94LmFkZFRvQ29udGV4dChuYW1lLCBgcGFyZW50LiR7bmFtZX1gKVxuICB9XG5cbi8vIHNldHMgb24gd2luZG93IGFzIHdlbGwgYXMgc3ludGggb2JqZWN0IGlmIGdsb2JhbCAobm90IG5lZWRlZCBmb3Igb2JqZWN0cywgd2hpY2ggY2FuIGJlIHNldCBkaXJlY3RseSlcblxuICBzZXQocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYodGhpcy5tYWtlR2xvYmFsKSB7XG4gICAgICB3aW5kb3dbcHJvcGVydHldID0gdmFsdWVcbiAgICB9XG4gICAgdGhpcy5wYXJlbnRbcHJvcGVydHldID0gdmFsdWVcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgaWYodGhpcy5tYWtlR2xvYmFsKSB7XG4gICAgICB0aGlzLnVzZXJQcm9wcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICB0aGlzLnBhcmVudFtwcm9wZXJ0eV0gPSB3aW5kb3dbcHJvcGVydHldXG4gICAgICB9KVxuICAgICAgLy8gIHRoaXMucGFyZW50LnNwZWVkID0gd2luZG93LnNwZWVkXG4gICAgfSBlbHNlIHtcblxuICAgIH1cbiAgfVxuXG4gIGV2YWwoY29kZSkge1xuICAgIHRoaXMuc2FuZGJveC5ldmFsKGNvZGUpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZhbFNhbmRib3hcbiIsImltcG9ydCBhcnJheVV0aWxzIGZyb20gJy4vbGliL2FycmF5LXV0aWxzLmpzJ1xuaW1wb3J0IHtnZXRMb29rdXB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbi8vIFtXSVBdIGhvdyB0byB0cmVhdCBkaWZmZXJlbnQgZGltZW5zaW9ucyAoPylcbmNvbnN0IERFRkFVTFRfQ09OVkVSU0lPTlMgPSB7XG4gIGZsb2F0OiB7XG4gICAgJ3ZlYzQnOiB7IG5hbWU6ICdzdW0nLCBhcmdzOiBbWzEsIDEsIDEsIDFdXSB9LFxuICAgICd2ZWMyJzogeyBuYW1lOiAnc3VtJywgYXJnczogW1sxLCAxXV0gfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxBcnJheVdpdGhEZWZhdWx0cyhhcnIsIGxlbikge1xuICAvLyBmaWxsIHRoZSBhcnJheSB3aXRoIGRlZmF1bHQgdmFsdWVzIGlmIGl0J3MgdG9vIHNob3J0XG4gIHdoaWxlIChhcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDMpIHsgLy8gcHVzaCBhIDEgYXMgdGhlIGRlZmF1bHQgZm9yIC5hIGluIHZlYzRcbiAgICAgIGFyci5wdXNoKDEuMClcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyLnB1c2goMC4wKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLnNsaWNlKDAsIGxlbilcbn1cblxuY29uc3QgZW5zdXJlX2RlY2ltYWxfZG90ID0gKHZhbCkgPT4ge1xuICB2YWwgPSB2YWwudG9TdHJpbmcoKVxuICBpZiAodmFsLmluZGV4T2YoJy4nKSA8IDApIHtcbiAgICB2YWwgKz0gJy4nXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0QXJndW1lbnRzKHRyYW5zZm9ybSwgc3RhcnRJbmRleCwgc3ludGhDb250ZXh0KSB7XG4gIGNvbnN0IGRlZmF1bHRBcmdzID0gdHJhbnNmb3JtLnRyYW5zZm9ybS5pbnB1dHNcbiAgY29uc3QgdXNlckFyZ3MgPSB0cmFuc2Zvcm0udXNlckFyZ3NcbiAgY29uc3QgeyBnZW5lcmF0b3JzIH0gPSB0cmFuc2Zvcm0uc3ludGhcbiAgY29uc3QgeyBzcmMgfSA9IGdlbmVyYXRvcnMgLy8gZGVwZW5kcyBvbiBzeW50aCBoYXZpbmcgc3JjKCkgZnVuY3Rpb25cbiAgcmV0dXJuIGRlZmF1bHRBcmdzLm1hcCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdHlwZWRBcmcgPSB7XG4gICAgICB2YWx1ZTogaW5wdXQuZGVmYXVsdCxcbiAgICAgIHR5cGU6IGlucHV0LnR5cGUsIC8vXG4gICAgICBpc1VuaWZvcm06IGZhbHNlLFxuICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgIHZlY0xlbjogMFxuICAgICAgLy8gIGdlbmVyYXRlR2xzbDogbnVsbCAvLyBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgZ2xzbFxuICAgIH1cblxuICAgIGlmICh0eXBlZEFyZy50eXBlID09PSAnZmxvYXQnKSB0eXBlZEFyZy52YWx1ZSA9IGVuc3VyZV9kZWNpbWFsX2RvdChpbnB1dC5kZWZhdWx0KVxuICAgIGlmIChpbnB1dC50eXBlLnN0YXJ0c1dpdGgoJ3ZlYycpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eXBlZEFyZy52ZWNMZW4gPSBOdW1iZXIucGFyc2VJbnQoaW5wdXQudHlwZS5zdWJzdHIoMykpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBkZXRlcm1pbmluZyBsZW5ndGggb2YgdmVjdG9yIGlucHV0IHR5cGUgJHtpbnB1dC50eXBlfSAoJHtpbnB1dC5uYW1lfSlgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHVzZXIgaGFzIGlucHV0IHNvbWV0aGluZyBmb3IgdGhpcyBhcmd1bWVudFxuICAgIGlmICh1c2VyQXJncy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgdHlwZWRBcmcudmFsdWUgPSB1c2VyQXJnc1tpbmRleF07XG4gICAgICBpZiAodHlwZW9mIHR5cGVkQXJnLnZhbHVlID09PSAnZnVuY3Rpb24nICYmICF0eXBlZEFyZy52YWx1ZS5fdGV4dHVyZSAmJiAhdHlwZWRBcmcudmFsdWUuX2ZyYW1lYnVmZmVyKSB7XG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0eXBlZEFyZy52YWx1ZSwgaW5wdXQpO1xuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHR5cGVkQXJnLnZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSkgeyAvLyB0b2RvOiBtYXliZSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0gZ2V0QXJyYXlWYWx1ZSh0eXBlZEFyZy52YWx1ZSwgaW5wdXQsIHR5cGVkQXJnLnZlY0xlbilcbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gdHJ1ZVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0SW5kZXggPCAwKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlZEFyZy52YWx1ZSAmJiB0eXBlZEFyZy52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsX3RyYW5zZm9ybSA9IHR5cGVkQXJnLnZhbHVlLnRyYW5zZm9ybXNbdHlwZWRBcmcudmFsdWUudHJhbnNmb3Jtcy5sZW5ndGggLSAxXVxuXG4gICAgICAgIGlmIChmaW5hbF90cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xfcmV0dXJuX3R5cGUgIT09IGlucHV0LnR5cGUpIHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0cyA9IERFRkFVTFRfQ09OVkVSU0lPTlNbaW5wdXQudHlwZV1cbiAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdF9kZWYgPSBkZWZhdWx0c1tmaW5hbF90cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xfcmV0dXJuX3R5cGVdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRfZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3MgfSA9IGRlZmF1bHRfZGVmXG4gICAgICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gdHlwZWRBcmcudmFsdWVbbmFtZV0oLi4uYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICh0eXBlZEFyZy50eXBlID09PSAnZmxvYXQnICYmIHR5cGVvZiB0eXBlZEFyZy52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBlbnN1cmVfZGVjaW1hbF9kb3QodHlwZWRBcmcudmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVkQXJnLnR5cGUuc3RhcnRzV2l0aCgndmVjJykgJiYgdHlwZW9mIHR5cGVkQXJnLnZhbHVlICE9PSAnZnVuY3Rpb24nICYmICF0eXBlZEFyZy52YWx1ZS5nZXRUZXh0dXJlKSB7XG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGZhbHNlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGVkQXJnLnZhbHVlKSB8fCB0eXBlZEFyZy52YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB0eXBlZEFyZy52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAvLyB0b2RvOiBhY2NlcHQgc21hbGxlciBhcnJheXM/XG4gICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBgJHt0eXBlZEFyZy50eXBlfSgke3R5cGVkQXJnLnZhbHVlLm1hcChlbnN1cmVfZGVjaW1hbF9kb3QpLmpvaW4oJywgJyl9KWBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHlwZWRBcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQodHlwZWRBcmcudHlwZS5zdWJzdHIoLTEpKTtcbiAgICAgICAgICBjb25zdCBhcnIgPSBBcnJheShsZW5ndGgpLmZpbGwodHlwZWRBcmcudmFsdWUpO1xuICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gYCR7dHlwZWRBcmcudHlwZX0oJHthcnIubWFwKGVuc3VyZV9kZWNpbWFsX2RvdCkuam9pbignLCAnKX0pYFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnR5cGUgPT09ICdzYW1wbGVyMkQnKSB7XG4gICAgICAgIC8vIHR5cGVkQXJnLnRleCA9IHR5cGVkQXJnLnZhbHVlXG4gICAgICAgIHZhciB4ID0gdHlwZWRBcmcudmFsdWVcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSB4LmdldFRleHR1cmUgPyAoKSA9PiAoeC5nZXRUZXh0dXJlKCkpIDogeFxuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBwYXNzaW5nIGluIGEgdGV4dHVyZSByZWZlcmVuY2UsIHdoZW4gZnVuY3Rpb24gYXNrcyBmb3IgdmVjNCwgY29udmVydCB0byB2ZWM0XG4gICAgICAgIGlmICh0eXBlZEFyZy52YWx1ZS5nZXRUZXh0dXJlIHx8IHR5cGVkQXJnLnZhbHVlLl90ZXh0dXJlKSB7XG4gICAgICAgICAgdmFyIHgxID0gdHlwZWRBcmcudmFsdWVcbiAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IHNyYyh4MSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZ2V0TG9va3VwW2lucHV0LnR5cGVdO1xuICAgICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBzcmMoeDEpW2dldHRlcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRwIHVuaWZvcm0gYXJyYXkgaWYgaXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGFzcyBpbiBhIGRpZmZlcmVudCB2YWx1ZSBvbiBlYWNoIHJlbmRlciBmcmFtZSxcbiAgICAgIC8vIG9yIGEgdGV4dHVyZS8gZXh0ZXJuYWwgc291cmNlXG5cbiAgICAgIGlmIChpbnB1dC5pc1VuaWZvcm0pIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGlucHV0LmlzVW5pZm9ybTtcbiAgICAgIGlmICh0eXBlZEFyZy5pc1VuaWZvcm0pIHtcbiAgICAgICAgdHlwZWRBcmcubmFtZSArPSBzdGFydEluZGV4XG4gICAgICAgIC8vICBzaGFkZXJQYXJhbXMudW5pZm9ybXMucHVzaCh0eXBlZEFyZylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVkQXJnXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsdWUsIGlucHV0KSB7XG4gIC8vIGlmICh0eXBlZEFyZy52ZWNMZW4gPiAwKSB7IC8vIGV4cGVjdGVkIGlucHV0IGlzIGEgdmVjdG9yLCBub3QgYSBzY2FsYXJcbiAgLy8gICAgdHlwZWRBcmcudmFsdWUgPSAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IChmaWxsQXJyYXlXaXRoRGVmYXVsdHModXNlckFyZ3NbaW5kZXhdKHByb3BzKSwgdHlwZWRBcmcudmVjTGVuKSlcbiAgLy8gfSBlbHNlIHtcbiAgcmV0dXJuIChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZShwcm9wcylcbiAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgbnVtYmVyJywgdmFsdWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQuZGVmYXVsdFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignRVJST1InLCBlKVxuICAgICAgcmV0dXJuIGlucHV0LmRlZmF1bHRcbiAgICB9XG4gIH1cbiAgLy8gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlWYWx1ZSh2YWx1ZSwgaW5wdXQsIHZlY0xlbiA9IDApIHtcbiAgLy8gICBpZiAodHlwZWRBcmcudmVjTGVuID4gMCkgeyAvLyBleHBlY3RlZCBpbnB1dCBpcyBhIHZlY3Rvciwgbm90IGEgc2NhbGFyXG4gIC8vICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gIC8vICAgICB0eXBlZEFyZy52YWx1ZSA9IGZpbGxBcnJheVdpdGhEZWZhdWx0cyh0eXBlZEFyZy52YWx1ZSwgdHlwZWRBcmcudmVjTGVuKVxuICAvLyAgfSBlbHNlIHtcbiAgLy8gIGNvbnNvbGUubG9nKFwiaXMgQXJyYXlcIilcbiAgLy8gZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBhcmUgbm90IGEgbnVtYmVyXG4gIC8vIGNvbnN0IGZpbHRlcmVkQXJyYXkgPSB1c2VyQXJnc1tpbmRleF0uZmlsdGVyKCh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAvLyB0eXBlZEFyZy52YWx1ZSA9IChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4gYXJyYXlVdGlscy5nZXRWYWx1ZShmaWx0ZXJlZEFycmF5KShwcm9wcylcbiAgaWYgKHZlY0xlbikge1xuICAgIHJldHVybiAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5KHZlY0xlbik7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dmVjTGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBpbnB1dC5kZWZhdWx0ID8gaW5wdXQuZGVmYXVsdC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBpbnB1dC5kZWZhdWx0W2ldIDogaW5wdXQuZGVmYXVsdCA6IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IGdldEZ1bmN0aW9uVmFsdWUodiwge2RlZmF1bHQ6IGRlZmF1bHRWYWx1ZX0pKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gYXJyYXlVdGlscy5nZXRWYWx1ZSh2KShwcm9wcylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4gYXJyYXlVdGlscy5nZXRWYWx1ZSh2YWx1ZSkocHJvcHMpXG4gIH1cbn0iLCJpbXBvcnQgZm9ybWF0QXJndW1lbnRzIGZyb20gJy4vZm9ybWF0LWFyZ3VtZW50cy5qcydcbmltcG9ydCB7dHlwZUxvb2t1cCwgZ2V0TG9va3VwLCBnZXRUeXBlTG9va3VwLCBjYXN0VHlwZSwgcmVwbGFjZUdlblR5cGV9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbi8vIGNvbnZlcnRzIGEgdHJlZSBvZiBqYXZhc2NyaXB0IGZ1bmN0aW9ucyB0byBhIHNoYWRlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiBnZW5lcmF0ZVBhcmFtcyhjcmVhdGVQYXJhbXMoKSwgc291cmNlLCBzb3VyY2UudHJhbnNmb3Jtcylcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgdW5pZm9ybXM6IFtdLCAvLyBsaXN0IG9mIHVuaWZvcm1zIHVzZWQgaW4gc2hhZGVyXG4gICAgZ2xzbEZ1bmN0aW9uczogW10sIC8vIGxpc3Qgb2YgZnVuY3Rpb25zIHVzZWQgaW4gc2hhZGVyXG4gICAgZnJhZ0NvbG9yOiAnJyxcbiAgICBwb3NpdGlvbjogJycsXG4gIH0sIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGFyYW1zKHNoYWRlclBhcmFtcywgc291cmNlLCB0cmFuc2Zvcm1zKSB7XG4gIGlmICghc2hhZGVyUGFyYW1zLmZyYWdDb2xvcikge1xuICAgIHNoYWRlclBhcmFtcy5mcmFnQ29sb3IgPSBnZW5lcmF0ZUdsc2woc291cmNlLCB0cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKCdzdCcsICd2ZWM0JywgMS4wKVxuICB9XG4gIGlmICghc2hhZGVyUGFyYW1zLnBvc2l0aW9uICYmICFzaGFkZXJQYXJhbXMuY29tYmluZSkge1xuICAgIHNoYWRlclBhcmFtcy5wb3NpdGlvbiA9IGdlbmVyYXRlR2xzbChzb3VyY2UsIHRyYW5zZm9ybXMuZmlsdGVyKCh0cikgPT4ge1xuICAgICAgcmV0dXJuIHRyLnRyYW5zZm9ybS50eXBlICE9PSAnY29tYmluZSc7XG4gICAgfSksIHNoYWRlclBhcmFtcykoJ3N0JywgJ3ZlYzQnLCAxLjApIC8vIHRvZG86IHNob3VsZCBiZSB2ZWMzXG4gIH1cbiAgLy8gcmVtb3ZlIHVuaWZvcm1zIHdpdGggZHVwbGljYXRlIG5hbWVzXG4gIGlmIChzaGFkZXJQYXJhbXMudW5pZm9ybXMpIHtcbiAgICBsZXQgdW5pZm9ybXMgPSB7fVxuICAgIHNoYWRlclBhcmFtcy51bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtKSA9PiB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybSlcbiAgICBzaGFkZXJQYXJhbXMudW5pZm9ybXMgPSBPYmplY3QudmFsdWVzKHVuaWZvcm1zKVxuICB9XG4gIHJldHVybiBzaGFkZXJQYXJhbXNcbn1cblxuLy8gcmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHNoYWRlciBzdHJpbmcgZnJvbSBvYmplY3QgY29udGFpbmluZyBmdW5jdGlvbnMgYW5kIHVzZXIgYXJndW1lbnRzLiBPcmRlciBvZiBmdW5jdGlvbnMgaW4gc3RyaW5nIGRlcGVuZHMgb24gdHlwZSBvZiBmdW5jdGlvblxuLy8gdG8gZG86IGltcHJvdmUgdmFyaWFibGUgbmFtZXNcbmZ1bmN0aW9uIGdlbmVyYXRlR2xzbCAoc291cmNlLCB0cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpIHtcbiAgLy8gdHJhbnNmb3JtIGZ1bmN0aW9uIHRoYXQgb3V0cHV0cyBhIHNoYWRlciBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBnbF9GcmFnQ29sb3JcbiAgY29uc3QgZW1wdHkgPSAoKSA9PiAnJztcbiAgdmFyIGZyYWdDb2xvciA9IGVtcHR5XG4gIHRyYW5zZm9ybXMubWFwKCh0cmFuc2Zvcm0sIGkpID0+IHtcbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnZ2VuVHlwZScpIHtcbiAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm0gPSByZXBsYWNlR2VuVHlwZSh0cmFuc2Zvcm0udHJhbnNmb3JtLCBpID8gJ2NvbG9yJyA6ICdjb29yZCcpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnZ2xzbCcpIHtcbiAgICAgIGZyYWdDb2xvciA9ICgpID0+IHRyYW5zZm9ybS51c2VyQXJnc1swXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ3ZlcnQnICYmICFzb3VyY2UuZ2VvbWV0cnkpIHtcbiAgICAgIHNvdXJjZS5zZXRHZW9tZXRyeSh0cmFuc2Zvcm0udXNlckFyZ3NbMF0pO1xuICAgICAgdHJhbnNmb3JtLnVzZXJBcmdzID0gdHJhbnNmb3JtLnVzZXJBcmdzLnNsaWNlKDEpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRzID0gZm9ybWF0QXJndW1lbnRzKHRyYW5zZm9ybSwgc2hhZGVyUGFyYW1zLnVuaWZvcm1zLmxlbmd0aClcblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYoaW5wdXQuaXNVbmlmb3JtKSBzaGFkZXJQYXJhbXMudW5pZm9ybXMucHVzaChpbnB1dClcbiAgICB9KVxuXG4gICAgLy8gYWRkIG5ldyBnbHNsIGZ1bmN0aW9uIHRvIHJ1bm5pbmcgbGlzdCBvZiBmdW5jdGlvbnNcbiAgICBpZighY29udGFpbnModHJhbnNmb3JtLCBzaGFkZXJQYXJhbXMuZ2xzbEZ1bmN0aW9ucykpIHNoYWRlclBhcmFtcy5nbHNsRnVuY3Rpb25zLnB1c2godHJhbnNmb3JtKVxuXG4gICAgLy8gY3VycmVudCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBmcmFnIGNvbG9yIHNoYWRlciBjb2RlXG4gICAgdmFyIGYwID0gZnJhZ0NvbG9yXG4gICAgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ3NyYycgfHwgdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAndmVydCcpIHtcbiAgICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke3NoYWRlclN0cmluZyh1diwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ2Nvb3JkJykge1xuICAgICAgZnJhZ0NvbG9yID0gZjAgPT09IGVtcHR5XG4gICAgICAgID8gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICA6ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2YwKGAke3NoYWRlclN0cmluZyh1diwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgJ3ZlYzInKX1gLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29sb3InKSB7XG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiAgYCR7c2hhZGVyU3RyaW5nKGAke2YwKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb21iaW5lJykge1xuICAgICAgLy8gY29tYmluaW5nIHR3byBnZW5lcmF0ZWQgc2hhZGVyIHN0cmluZ3MgKGkuZS4gZm9yIGJsZW5kLCBtdWx0LCBhZGQgZnVudGlvbnMpXG4gICAgICBpZiAoc291cmNlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQgfHwgKGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3JtcyAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgc2hhZGVyUGFyYW1zLCB7XG4gICAgICAgICAgZnJhZ0NvbG9yOiBmcmFnQ29sb3IoJ3N0JywgJ3ZlYzQnLCAxLjApIHx8ICd2ZWM0KDApJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2hhZGVyUGFyYW1zLCBjcmVhdGVQYXJhbXMoe1xuICAgICAgICAgIGdsc2xGdW5jdGlvbnM6IFt0cmFuc2Zvcm1dLFxuICAgICAgICAgIGNvbWJpbmU6IHRydWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdHJhbnMgPSBzb3VyY2UudHJhbnNmb3Jtcy5zbGljZSgwLCBzb3VyY2UudHJhbnNmb3Jtcy5pbmRleE9mKHRyYW5zZm9ybSkpO1xuICAgICAgICBzb3VyY2UucGFzc2VzLnVuc2hpZnQoc291cmNlLmNyZWF0ZVBhc3MoZ2VuZXJhdGVQYXJhbXMocGFyYW1zLCBzb3VyY2UsIHRyYW5zKSwge2ZyYW1lYnVmZmVyOiBzb3VyY2Uub3V0cHV0LnRlbXBbMF19KSk7XG4gICAgICAgIGNvbnN0IHRlbXAwID0gc3JjKHNvdXJjZS5vdXRwdXQudGVtcFswXSk7XG4gICAgICAgIGYwID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKHRlbXAwLCB0ZW1wMC50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgfVxuICAgICAgdmFyIGYxO1xuICAgICAgaWYgKGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAoaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQgfHwgc291cmNlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQpIHtcbiAgICAgICAgICBpbnB1dHNbMF0udmFsdWUub3V0cHV0ID0gc291cmNlLm91dHB1dDtcbiAgICAgICAgICBzb3VyY2UucGFzc2VzLnVuc2hpZnQoLi4uaW5wdXRzWzBdLnZhbHVlLmNvbXBpbGUoe2ZyYW1lYnVmZmVyOiBzb3VyY2Uub3V0cHV0LnRlbXBbMV19KSk7XG4gICAgICAgICAgY29uc3QgdGVtcDEgPSBzcmMoc291cmNlLm91dHB1dC50ZW1wWzFdKTtcbiAgICAgICAgICBmMSA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2dlbmVyYXRlR2xzbCh0ZW1wMSwgdGVtcDEudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSh1diwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmMSA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2dlbmVyYXRlR2xzbChpbnB1dHNbMF0udmFsdWUsIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZjEgPSAoaW5wdXRzWzBdLmlzVW5pZm9ybSA/ICgpID0+IGlucHV0c1swXS5uYW1lIDogKCkgPT4gaW5wdXRzWzBdLnZhbHVlKVxuICAgICAgfVxuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKGAke2YwKHV2LCAndmVjNCcpfSwgJHtmMSh1diwgJ3ZlYzQnKX1gLCB0cmFuc2Zvcm0sIGlucHV0cy5zbGljZSgxKSwgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29tYmluZUNvb3JkJykge1xuICAgICAgLy8gY29tYmluaW5nIHR3byBnZW5lcmF0ZWQgc2hhZGVyIHN0cmluZ3MgKGkuZS4gZm9yIG1vZHVsYXRlIGZ1bmN0aW9ucylcbiAgICAgIHZhciBmMSA9IGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1xuICAgICAgICAgID8gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0c1swXS52YWx1ZSwgaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgICAgOiAoaW5wdXRzWzBdLmlzVW5pZm9ybSA/ICgpID0+IGlucHV0c1swXS5uYW1lIDogKCkgPT4gaW5wdXRzWzBdLnZhbHVlKVxuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7ZjAoYCR7c2hhZGVyU3RyaW5nKGAke3V2fSwgJHtmMSh1diwgJ3ZlYzQnKX1gLCB0cmFuc2Zvcm0sIGlucHV0cy5zbGljZSgxKSwgc2hhZGVyUGFyYW1zLCAndmVjMicpfWAsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdubyBzdXBwb3J0IGZvciB0eXBlOiAnICsgdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlKVxuICAgIH1cbiAgfSlcbiAgaWYgKHNvdXJjZS5nZXR0ZXIpIHtcbiAgICB2YXIgZjIgPSBmcmFnQ29sb3JcbiAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBjYXN0VHlwZShmMih1diwgcmV0dXJuVHlwZSwgYWxwaGEpICsgYC4ke3NvdXJjZS5nZXR0ZXJ9YCwgZ2V0VHlwZUxvb2t1cFtzb3VyY2UuZ2V0dGVyXSwgcmV0dXJuVHlwZSwgMS4wKVxuICB9XG4gIHJldHVybiBmcmFnQ29sb3Jcbn1cblxuLy8gYXNzZW1ibGVzIGEgc2hhZGVyIHN0cmluZyBjb250YWluaW5nIHRoZSBhcmd1bWVudHMgYW5kIHRoZSBmdW5jdGlvbiBuYW1lLCBpLmUuICdvc2ModXYsIGZyZXF1ZW5jeSknXG5mdW5jdGlvbiBzaGFkZXJTdHJpbmcgKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSA9IDAuMCkge1xuICBjb25zdCBzdHIgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5pc1VuaWZvcm0pIHtcbiAgICAgIHJldHVybiBpbnB1dC5uYW1lXG4gICAgfSBlbHNlIGlmIChpbnB1dC52YWx1ZSAmJiBpbnB1dC52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAvLyB0aGlzIGJ5IGRlZmluaXRpb24gbmVlZHMgdG8gYmUgYSBnZW5lcmF0b3IsIGhlbmNlIHdlIHN0YXJ0IHdpdGggJ3N0JyBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgZ2VuZXJhdGluZyB0aGUgZ2xzbCBmcmFnbWVudFxuICAgICAgaWYgKCFpbnB1dC52YWx1ZS5nZXR0ZXIgJiYgdHlwZUxvb2t1cFtpbnB1dC52YWx1ZS50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS50eXBlXSAhPT0gaW5wdXQudHlwZSkge1xuICAgICAgICAvLyB0b2RvOiBhZGQgZ2V0dGVyIG9ubHkgaWYgaW5wdXQudHlwZSBpcyBsYXJnZXJcbiAgICAgICAgaW5wdXQudmFsdWUuZ2V0dGVyID0gZ2V0TG9va3VwW2lucHV0LnR5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke2dlbmVyYXRlR2xzbChpbnB1dC52YWx1ZSwgaW5wdXQudmFsdWUudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSgnc3QnLCBpbnB1dC50eXBlKX1gXG4gICAgfVxuICAgIHJldHVybiBpbnB1dC52YWx1ZVxuICB9KS5yZWR1Y2UoKHAsIGMpID0+IGAke3B9LCAke2N9YCwgJycpXG5cbiAgdmFyIGZ1bmMgPSBgJHt0cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xOYW1lfSgke3V2fSR7c3RyfSlgXG4gIHJldHVybiBjYXN0VHlwZShmdW5jLCB0eXBlTG9va3VwW3RyYW5zZm9ybS50cmFuc2Zvcm0udHlwZV0ucmV0dXJuVHlwZSwgcmV0dXJuVHlwZSwgYWxwaGEpO1xufVxuXG4vLyBjaGVjayB3aGV0aGVyIGFycmF5XG5mdW5jdGlvbiBjb250YWlucyhvYmplY3QsIGFycikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICBpZihvYmplY3QubmFtZSA9PSBhcnJbaV0ubmFtZSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5cbiIsImltcG9ydCBHbHNsU291cmNlIGZyb20gJy4vZ2xzbC1zb3VyY2UuanMnXG5pbXBvcnQgZ2xzbEZ1bmN0aW9ucyBmcm9tICcuL2dsc2wvZ2xzbC1mdW5jdGlvbnMuanMnXG5pbXBvcnQgdmVydEZ1bmN0aW9ucyBmcm9tICcuL2dsc2wvdmVydC1mdW5jdGlvbnMuanMnXG5pbXBvcnQge3R5cGVMb29rdXAsIHByb2Nlc3NHbHNsfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXG5jbGFzcyBHZW5lcmF0b3JGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICAgIGRlZmF1bHRVbmlmb3JtcyxcbiAgICAgIGRlZmF1bHRPdXRwdXQsXG4gICAgICBleHRlbmRUcmFuc2Zvcm1zID0gW10sXG4gICAgICBjaGFuZ2VMaXN0ZW5lciA9ICgoKSA9PiB7fSlcbiAgICB9ID0ge31cbiAgICApIHtcbiAgICB0aGlzLmRlZmF1bHRPdXRwdXQgPSBkZWZhdWx0T3V0cHV0XG4gICAgdGhpcy5kZWZhdWx0VW5pZm9ybXMgPSBkZWZhdWx0VW5pZm9ybXNcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gY2hhbmdlTGlzdGVuZXJcbiAgICB0aGlzLmV4dGVuZFRyYW5zZm9ybXMgPSBleHRlbmRUcmFuc2Zvcm1zXG4gICAgdGhpcy5nZW5lcmF0b3JzID0ge31cbiAgICB0aGlzLnV0aWxzID0ge31cbiAgICB0aGlzLmluaXQoKVxuICB9XG4gIGluaXQgKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGdsc2xGdW5jdGlvbnMoKVxuICAgIHRoaXMuZ2xzbFRyYW5zZm9ybXMgPSB7fVxuICAgIHRoaXMuZ2VuZXJhdG9ycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuZ2VuZXJhdG9ycykucmVkdWNlKChwcmV2LCBbbWV0aG9kLCB0cmFuc2Zvcm1dKSA9PiB7XG4gICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyKHt0eXBlOiAncmVtb3ZlJywgc3ludGg6IHRoaXMsIG1ldGhvZH0pXG4gICAgICByZXR1cm4gcHJldlxuICAgIH0sIHt9KVxuXG4gICAgdGhpcy5zb3VyY2VDbGFzcyA9ICgoKSA9PiB7XG4gICAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBHbHNsU291cmNlIHtcbiAgICAgIH1cbiAgICB9KSgpXG5cbiAgICAvLyBhZGQgdXNlciBkZWZpbmllZCB0cmFuc2Zvcm1zXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5leHRlbmRUcmFuc2Zvcm1zKSkge1xuICAgICAgZnVuY3Rpb25zLmNvbmNhdCh0aGlzLmV4dGVuZFRyYW5zZm9ybXMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5leHRlbmRUcmFuc2Zvcm1zID09PSAnb2JqZWN0JyAmJiB0aGlzLmV4dGVuZFRyYW5zZm9ybXMudHlwZSkge1xuICAgICAgZnVuY3Rpb25zLnB1c2godGhpcy5leHRlbmRUcmFuc2Zvcm1zKVxuICAgIH1cblxuICAgIGZ1bmN0aW9ucy5tYXAoKHRyYW5zZm9ybSkgPT4gdGhpcy5zZXRGdW5jdGlvbih0cmFuc2Zvcm0pKVxuXG4gICAgY29uc3QgZnVuY3Rpb25zMiA9IHZlcnRGdW5jdGlvbnModGhpcy5nZW5lcmF0b3JzKTsgLy8gc2FuZGJveCBpcyBub3QgcmVhZHkgYXQgdGhpcyBtb21lbnQgeWV0XG4gICAgZnVuY3Rpb25zMi5tYXAoKHRyYW5zZm9ybSkgPT4gdGhpcy5zZXRGdW5jdGlvbih0cmFuc2Zvcm0pKVxuIH1cblxuIF9hZGRNZXRob2QgKG1ldGhvZCwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB0aGlzLmdsc2xUcmFuc2Zvcm1zW21ldGhvZF0gPSB0cmFuc2Zvcm1cbiAgICBsZXQgcmV0dmFsID0gdW5kZWZpbmVkXG4gICAgaWYgKFsnc3JjJywgJ2Nvb3JkJywgJ2dlblR5cGUnLCAndmVydCcsICdnbHNsJ10uaW5kZXhPZih0cmFuc2Zvcm0udHlwZSkgPiAtMSkge1xuICAgICAgY29uc3QgZnVuYyA9ICguLi5hcmdzKSA9PiBuZXcgdGhpcy5zb3VyY2VDbGFzcyh7XG4gICAgICAgIG5hbWU6IG1ldGhvZCxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIHVzZXJBcmdzOiBhcmdzLFxuICAgICAgICBkZWZhdWx0T3V0cHV0OiB0aGlzLmRlZmF1bHRPdXRwdXQsXG4gICAgICAgIGRlZmF1bHRVbmlmb3JtczogdGhpcy5kZWZhdWx0VW5pZm9ybXMsXG4gICAgICAgIHN5bnRoOiBzZWxmLFxuICAgICAgICB1dGlsczogdGhpcy51dGlscyxcbiAgICAgIH0pXG4gICAgICB0aGlzLmdlbmVyYXRvcnNbbWV0aG9kXSA9IGZ1bmNcbiAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIoe3R5cGU6ICdhZGQnLCBzeW50aDogdGhpcywgbWV0aG9kfSlcbiAgICAgIHJldHZhbCA9IGZ1bmNcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBpZiAodHJhbnNmb3JtLnR5cGUgIT09ICdzcmMnICYmIHRyYW5zZm9ybS50eXBlICE9PSAndmVydCcpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2goe25hbWU6IG1ldGhvZCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sIHVzZXJBcmdzOiBhcmdzLCBzeW50aDogc2VsZn0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGB0cmFuc2Zvcm0gJHt0cmFuc2Zvcm0ubmFtZX0gbm90IGFsbG93ZWQgYWZ0ZXIgJHt0aGlzLnRyYW5zZm9ybXNbdGhpcy50cmFuc2Zvcm1zLmxlbmd0aC0xXS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbFxuICB9XG5cbiAgc2V0RnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gdG9kbzogcmVtb3ZlIHV0aWxzIGFuZCBpbnN0ZWFkIG1hbmFnZSBmdW5jdGlvbiBkZXBlbmRlbmNpZXNcbiAgICBpZiAob2JqLnR5cGUgPT09ICd1dGlsJykgdGhpcy51dGlsc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgdmFyIHByb2Nlc3NlZEdsc2wgPSBwcm9jZXNzRnVuY3Rpb24ob2JqKVxuICAgIGlmKHByb2Nlc3NlZEdsc2wpIHRoaXMuX2FkZE1ldGhvZChvYmoubmFtZSwgcHJvY2Vzc2VkR2xzbClcbiAgfVxufVxuXG4vLyBleHBlY3RzIGdsc2wgb2YgZm9ybWF0XG4vLyB7XG4vLyAgIG5hbWU6ICdvc2MnLCAvLyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFjY2VzcyBmdW5jdGlvbiBhcyB3ZWxsIGFzIHdpdGhpbiBnbHNsXG4vLyAgIHR5cGU6ICdzcmMnLCAvLyBjYW4gYmUgc3JjOiB2ZWM0KHZlYzIgX3N0KSwgY29vcmQ6IHZlYzIodmVjMiBfc3QpLCBjb2xvcjogdmVjNCh2ZWM0IF9jMCksIGNvbWJpbmU6IHZlYzQodmVjNCBfYzAsIHZlYzQgX2MxKSwgY29tYmluZUNvb3JkOiB2ZWMyKHZlYzIgX3N0LCB2ZWM0IF9jMClcbi8vICAgaW5wdXRzOiBbXG4vLyAgICAge1xuLy8gICAgICAgbmFtZTogJ2ZyZXEnLFxuLy8gICAgICAgdHlwZTogJ2Zsb2F0JywgLy8gJ2Zsb2F0JyAgIC8vLCAndGV4dHVyZScsICd2ZWM0J1xuLy8gICAgICAgZGVmYXVsdDogMC4yXG4vLyAgICAgfSxcbi8vICAgICB7XG4vLyAgICAgICAgICAgbmFtZTogJ3N5bmMnLFxuLy8gICAgICAgICAgIHR5cGU6ICdmbG9hdCcsXG4vLyAgICAgICAgICAgZGVmYXVsdDogMC4xXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBuYW1lOiAnb2Zmc2V0Jyxcbi8vICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuLy8gICAgICAgICAgIGRlZmF1bHQ6IDAuMFxuLy8gICAgICAgICB9XG4vLyAgIF0sXG4gICAvLyAgZ2xzbDogYFxuICAgLy8gICAgdmVjMiBzdCA9IF9zdDtcbiAgIC8vICAgIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAvLyAgICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcSkqMC41ICsgMC41O1xuICAgLy8gICAgZmxvYXQgYiA9IHNpbigoc3QueCtvZmZzZXQvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAvLyAgICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuICAgLy8gYFxuLy8gfVxuXG4vLyAvLyBnZW5lcmF0ZXMgZ2xzbCBmdW5jdGlvbjpcbi8vIGB2ZWM0IG9zYyh2ZWMyIF9zdCwgZmxvYXQgZnJlcSwgZmxvYXQgc3luYywgZmxvYXQgb2Zmc2V0KXtcbi8vICB2ZWMyIHN0ID0gX3N0O1xuLy8gIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4vLyAgZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbi8vICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbi8vICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuLy8gfWBcblxuZnVuY3Rpb24gcHJvY2Vzc0Z1bmN0aW9uKG9iaikge1xuICBvYmouZ2xzbE5hbWUgfHwgKG9iai5nbHNsTmFtZSA9IG9iai5uYW1lKTtcbiAgaWYgKG9iai50eXBlID09PSAnZ2xzbCcgfHwgb2JqLnR5cGUgPT09ICdnZW5UeXBlJykgcmV0dXJuIG9iajtcbiAgZWxzZSBpZiAob2JqLnR5cGUgPT09ICd1dGlsJykge1xuICAgIHJldHVybiBwcm9jZXNzR2xzbChvYmosIG9iai5yZXR1cm5UeXBlKTtcbiAgfVxuICBsZXQgdCA9IHR5cGVMb29rdXBbb2JqLnR5cGVdXG4gIGlmKHQpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dsc2wob2JqLCB0LnJldHVyblR5cGUsIHQuYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKGB0eXBlICR7b2JqLnR5cGV9IG5vdCByZWNvZ25pemVkYCwgb2JqKVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VuZXJhdG9yRmFjdG9yeVxuIiwiaW1wb3J0IGdlbmVyYXRlR2xzbCBmcm9tICcuL2dlbmVyYXRlLWdsc2wuanMnXG5pbXBvcnQgdXRpbGl0eUdsc2wgZnJvbSAnLi9nbHNsL3V0aWxpdHktZnVuY3Rpb25zLmpzJ1xuaW1wb3J0IHZlY3Rvcml6ZVRleHQgZnJvbSAndmVjdG9yaXplLXRleHQnO1xuaW1wb3J0IHtyZXBsYWNlR2VuVHlwZX0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblxudmFyIEdsc2xTb3VyY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHRoaXMudHJhbnNmb3JtcyA9IFtdXG4gIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG9iailcbiAgdGhpcy5kZWZhdWx0T3V0cHV0ID0gb2JqLmRlZmF1bHRPdXRwdXRcbiAgdGhpcy5vdXRwdXQgPSBudWxsXG4gIHRoaXMuc3ludGggPSBvYmouc3ludGhcbiAgdGhpcy50eXBlID0gJ0dsc2xTb3VyY2UnXG4gIHRoaXMuZGVmYXVsdFVuaWZvcm1zID0gb2JqLmRlZmF1bHRVbmlmb3Jtc1xuICB0aGlzLnV0aWxzID0gT2JqZWN0LmFzc2lnbih7fSwgdXRpbGl0eUdsc2wsIG9iai51dGlscyk7XG4gIHRoaXMuYmxlbmRNb2RlID0gdHlwZW9mKG9iai50cmFuc2Zvcm0uYmxlbmRNb2RlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvYmoudHJhbnNmb3JtLmJsZW5kTW9kZSA6IGZhbHNlO1xuICB0aGlzLmxpbmVXaWR0aCA9IG9iai50cmFuc2Zvcm0ubGluZVdpZHRoIHx8IDE7XG4gIHRoaXMuX3ZpZXdwb3J0ID0ge307XG4gIHJldHVybiB0aGlzXG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmFkZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmopICB7XG4gIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG9iailcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUub3V0ID0gZnVuY3Rpb24gKF9vdXRwdXQpIHtcbiAgdmFyIG91dHB1dCA9IF9vdXRwdXQgfHwgdGhpcy5kZWZhdWx0T3V0cHV0XG4gIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICB2YXIgZ2xzbCA9IHRoaXMuY29tcGlsZSgpXG4gIHRoaXMuc3ludGguY3VycmVudEZ1bmN0aW9ucyA9IFtdXG4gIGlmKG91dHB1dCkgdHJ5e1xuICAgIG91dHB1dC5yZW5kZXIoZ2xzbClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZygnc2hhZGVyIGNvdWxkIG5vdCBjb21waWxlJywgZXJyb3IpXG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnRleCA9IGZ1bmN0aW9uKF9vdXRwdXQsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIXRoaXMub3V0cHV0KSB7XG4gICAgdGhpcy5vdXQoX291dHB1dCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMub3V0cHV0LnJlbmRlclRleHR1cmUob3B0aW9ucyk7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIHRoaXMucGFzc2VzID0gW11cbiAgdGhpcy5wYXNzZXMucHVzaCh0aGlzLmNyZWF0ZVBhc3MoZ2VuZXJhdGVHbHNsKHRoaXMpLCBvcHRpb25zKSlcbiAgcmV0dXJuIHRoaXMucGFzc2VzXG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBzaGFkZXJJbmZvID0gZ2VuZXJhdGVHbHNsKHRoaXMpXG4gICAgdmFyIHVuaWZvcm1zID0ge31cbiAgICBzaGFkZXJJbmZvLnVuaWZvcm1zLmZvckVhY2goKHVuaWZvcm0pID0+IHsgdW5pZm9ybXNbdW5pZm9ybS5uYW1lXSA9IHVuaWZvcm0udmFsdWUgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc2hhZGVySW5mbyxcbiAgICAgIHV0aWxpdHlHbHNsOiB0aGlzLnV0aWxzLFxuICAgICAgLy8gdG9kbzogYWRkIHN1cHBvcnQgZm9yIGdlbmVyYXRlZCB2ZXJ0ZXggc2hhZGVyXG4gICAgICB2ZXJ0OiB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQsXG4gICAgICAvLyB0b2RvOiBkaWZmZXJzIGZyb20gY29tcGlsZVxuICAgICAgYXR0cmlidXRlczogdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS5hdHRyaWJ1dGVzLFxuICAgICAgLy8gdG9kbzogZGlmZmVycyBmcm9tIGNvbXBpbGVcbiAgICAgIGF0dHJpYnV0ZXNDb3VudDogdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS5hdHRyaWJ1dGVzQ291bnQsXG4gICAgICBwcmltaXRpdmU6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0ucHJpbWl0aXZlLFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3JtcylcbiAgICB9O1xuICB9XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmNyZWF0ZVBhc3MgPSBmdW5jdGlvbihzaGFkZXJJbmZvLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIHVuaWZvcm1zID0ge31cbiAgc2hhZGVySW5mby51bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtKSA9PiB7IHVuaWZvcm1zW3VuaWZvcm0ubmFtZV0gPSB1bmlmb3JtLnZhbHVlIH0pXG5cbiAgaWYgKHNoYWRlckluZm8uY29tYmluZSkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0OiBHbHNsU291cmNlLmNvbXBpbGVWZXJ0KHRoaXMuZGVmYXVsdE91dHB1dC5wcmVjaXNpb24sIGZhbHNlLCB7XG4gICAgICAgIGdsc2xOYW1lOiAnY29tYmluZScsXG4gICAgICB9LCBzaGFkZXJJbmZvKSxcbiAgICAgIHVzZXJBcmdzOiB0aGlzLnRyYW5zZm9ybXNbMF0udXNlckFyZ3MsXG4gICAgICAvLyB0b2RvOiBmaXggb3IgZGVsZXRlXG4gICAgICAvLyBibGVuZE1vZGU6IHRoaXMuYmxlbmRNb2RlLFxuICAgICAgbGluZVdpZHRoOiB0aGlzLmxpbmVXaWR0aCxcbiAgICAgIGZyYWc6IEdsc2xTb3VyY2UuY29tcGlsZUZyYWcodGhpcy5kZWZhdWx0T3V0cHV0LnByZWNpc2lvbiwgc2hhZGVySW5mbywgdGhpcy51dGlscyksXG4gICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0VW5pZm9ybXMsIHVuaWZvcm1zKSxcbiAgICAgIHZpZXdwb3J0OiB0aGlzLl92aWV3cG9ydCxcbiAgICAgIGNsZWFyOiB0aGlzLmNsZWFyLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCB0cnVlLCB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICBwcmltaXRpdmU6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0ucHJpbWl0aXZlLFxuICAgIHVzZXJBcmdzOiB0aGlzLnRyYW5zZm9ybXNbMF0udXNlckFyZ3MsXG4gICAgZ2VvbWV0cnk6IHRoaXMuZ2VvbWV0cnksXG4gICAgYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcbiAgICBsaW5lV2lkdGg6IHRoaXMubGluZVdpZHRoLFxuICAgIGZyYWc6IEdsc2xTb3VyY2UuY29tcGlsZUZyYWcodGhpcy5kZWZhdWx0T3V0cHV0LnByZWNpc2lvbiwgc2hhZGVySW5mbywgdGhpcy51dGlscyksXG4gICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3JtcyksXG4gICAgdmlld3BvcnQ6IHRoaXMuX3ZpZXdwb3J0LFxuICAgIGNsZWFyOiB0aGlzLmNsZWFyLFxuICB9LCBvcHRpb25zKVxufVxuXG5HbHNsU291cmNlLmNvbXBpbGVIZWFkZXIgPSBmdW5jdGlvbihwcmVjaXNpb24sIHVuaWZvcm1zID0ge30sIHV0aWxzID0ge30pIHtcbiAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBmbG9hdDtcbiAgJHtPYmplY3QudmFsdWVzKHVuaWZvcm1zKS5tYXAoKHVuaWZvcm0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHVuaWZvcm0udHlwZVxuICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKSB7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtLm5hbWV9O2BcbiAgfSkuam9pbignJyl9XG4gIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gIHZhcnlpbmcgdmVjMyB2cG9zaXRpb247XG4gIHZhcnlpbmcgdmVjMiB2dXY7XG4gIHZhcnlpbmcgdmVjMyB2bm9ybWFsO1xuICB1bmlmb3JtIHNhbXBsZXIyRCBwcmV2QnVmZmVyO1xuICBcbiAgJHtPYmplY3QudmFsdWVzKHV0aWxzKS5tYXAoKHRyYW5zZm9ybSkgPT4ge1xuICAgIC8vICBjb25zb2xlLmxvZyh0cmFuc2Zvcm0uZ2xzbClcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHt0cmFuc2Zvcm0uZ2xzbH1cbiAgICAgICAgICBgXG4gIH0pLmpvaW4oJycpfVxuICBgXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZUZyYWcgPSBmdW5jdGlvbihwcmVjaXNpb24sIHNoYWRlckluZm8sIHV0aWxzKSB7XG4gIGNvbnN0IGhlYWRlciA9IHRoaXMuY29tcGlsZUhlYWRlcihwcmVjaXNpb24sIHNoYWRlckluZm8udW5pZm9ybXMsIHV0aWxzKTtcbiAgcmV0dXJuIGhlYWRlciArIGBcbiAgXG4gICR7c2hhZGVySW5mby5nbHNsRnVuY3Rpb25zLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7dHJhbnNmb3JtLnRyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgfSkuam9pbignJyl9XG5cbiAgdm9pZCBtYWluICgpIHtcbiAgICB2ZWM0IGMgPSB2ZWM0KDEsIDAsIDAsIDEpO1xuICAgIC8vdmVjMiBzdCA9IGdsX0ZyYWdDb29yZC54eS9yZXNvbHV0aW9uLnh5O1xuICAgIHZlYzIgc3QgPSB2dXY7XG4gICAgZ2xfRnJhZ0NvbG9yID0gJHtzaGFkZXJJbmZvLmZyYWdDb2xvcn07XG4gIH1cbiAgYFxufVxuXG5HbHNsU291cmNlLmNvbXBpbGVWZXJ0ID0gZnVuY3Rpb24ocHJlY2lzaW9uLCB1c2VDYW1lcmEsIHRyYW5zZm9ybSwgc2hhZGVySW5mbywgdXRpbHMpIHtcbiAgY29uc3QgdXNlVVYgPSB0eXBlb2YodHJhbnNmb3JtLnVzZVVWKSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHRyYW5zZm9ybS51c2VVVlxuICAgIDogKCF0cmFuc2Zvcm0ucHJpbWl0aXZlIHx8IFsncG9pbnRzJywgJ2xpbmVzJywgJ2xpbmUgc3RyaXAnLCAnbGluZSBsb29wJ10uaW5kZXhPZih0cmFuc2Zvcm0ucHJpbWl0aXZlKSA9PT0gLTEpO1xuICBjb25zdCB1c2VOb3JtYWwgPSB0eXBlb2YodHJhbnNmb3JtLnVzZU5vcm1hbCkgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHRyYW5zZm9ybS51c2VOb3JtYWxcbiAgICAgIDogdHJhbnNmb3JtLnR5cGUgPT09ICd2ZXJ0JyAmJiAoIXRyYW5zZm9ybS5wcmltaXRpdmUgfHwgWydwb2ludHMnLCAnbGluZXMnLCAnbGluZSBzdHJpcCcsICdsaW5lIGxvb3AnXS5pbmRleE9mKHRyYW5zZm9ybS5wcmltaXRpdmUpID09PSAtMSlcblxuICBsZXQgdmVydEhlYWRlciA9IGBcbiAgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBmbG9hdDtcbiAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb24sIHZpZXc7XG4gIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICAke3VzZVVWID8gJ2F0dHJpYnV0ZSB2ZWMyIHV2OycgOiAnJ31cbiAgJHt1c2VOb3JtYWwgPyAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycgOiAnJ31cbiAgdmFyeWluZyB2ZWMzIHZwb3NpdGlvbjtcbiAgdmFyeWluZyB2ZWMyIHZ1djtcbiAgdmFyeWluZyB2ZWMzIHZub3JtYWw7XG4gIGBcbiAgbGV0IHZlcnRGbiA9IGBcbiAgdm9pZCAke3RyYW5zZm9ybS5nbHNsTmFtZX0oKSB7XG4gICAgdnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZ2xfUG9zaXRpb24gPSAke3VzZUNhbWVyYSA/ICdwcm9qZWN0aW9uICogdmlldyAqICcgOiAnJ312ZWM0KHBvc2l0aW9uLCAxLjApO1xuICB9IFxuICBgXG4gIGxldCB2ZXJ0Q2FsbCA9IGAke3RyYW5zZm9ybS5nbHNsTmFtZX0oKTtgO1xuICBpZiAodHJhbnNmb3JtLnZlcnQpIHtcbiAgICB2ZXJ0SGVhZGVyID0gdGhpcy5jb21waWxlSGVhZGVyKHByZWNpc2lvbiwgc2hhZGVySW5mby51bmlmb3JtcywgdXRpbHMpICsgYFxuICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uLCB2aWV3O1xuICAgIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICAgICR7dXNlVVYgPyAnYXR0cmlidXRlIHZlYzIgdXY7JyA6ICcnfVxuICAgICR7dXNlTm9ybWFsID8gJ2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnIDogJyd9XG4gICAgXG4gICAgJHtzaGFkZXJJbmZvLmdsc2xGdW5jdGlvbnMubWFwKCh0cmFucykgPT4ge1xuICAgICAgaWYgKHRyYW5zLnRyYW5zZm9ybS5uYW1lICE9PSB0cmFuc2Zvcm0ubmFtZSkge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHt0cmFucy50cmFuc2Zvcm0uZ2xzbH1cbiAgICAgICAgICBgXG4gICAgICB9XG4gICAgfSkuam9pbignJyl9XG4gICAgYFxuICAgIHZlcnRGbiA9IHRyYW5zZm9ybS52ZXJ0O1xuICAgIHZlcnRDYWxsID0gYFxuICAgICR7dXNlVVYgPyAndmVjMiBzdCA9IHV2OycgOiAndmVjMiBzdCA9IHBvc2l0aW9uLnh5Oyd9XG4gICAgdnBvc2l0aW9uID0gJHtzaGFkZXJJbmZvLnBvc2l0aW9ufS54eXo7XG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogdmlldyAqIHZlYzQodnBvc2l0aW9uLCAxLjApO1xuICAgIGA7XG4gIH1cblxuICByZXR1cm4gdmVydEhlYWRlciArIGBcbiAgICBcbiAgJHt2ZXJ0Rm59XG5cbiAgdm9pZCBtYWluICgpIHtcbiAgICAke3VzZVVWID8gJ3Z1diA9IHV2OycgOiAnJ31cbiAgICAke3VzZU5vcm1hbCA/ICd2bm9ybWFsID0gbm9ybWFsOycgOiAnJ31cbiAgICAke3ZlcnRDYWxsfVxuICB9YFxufVxuXG4vLyB0b2RvOiBtYWtlIGh5ZHJhLXN5bnRoIGZ1bmN0aW9uXG5HbHNsU291cmNlLnByb3RvdHlwZS5zZXRCbGVuZCA9IGZ1bmN0aW9uKGJsZW5kTW9kZSA9IHRydWUpIHtcbiAgdGhpcy5ibGVuZE1vZGUgPSBibGVuZE1vZGU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5zZXRMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lV2lkdGgpIHtcbiAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIHJldHVybiB0aGlzO1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGNvbnN0IGlzR2VvbWV0cnkgPSAodikgPT4gKHYuaXNCdWZmZXJHZW9tZXRyeSB8fCAodi5wb3NpdGlvbnMgJiYgdi5lZGdlcykpO1xuICBjb25zdCBpc0NsYXNzID0gKHYpID0+IHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nICYmIC9eXFxzKmNsYXNzXFxzKy8udGVzdCh2LnRvU3RyaW5nKCkpO1xuICBpZiAoIWlucHV0KSBpbnB1dCA9IFtdO1xuICBpZiAoIWlzR2VvbWV0cnkoaW5wdXQpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgaW5wdXQgPSBbaW5wdXRdO1xuICAgIGlmIChpc0NsYXNzKHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uZ2VvbWV0cnkpKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS5nZW9tZXRyeSA9PT0gR3JpZEdlb21ldHJ5ICYmIHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0ucHJpbWl0aXZlICYmIHR5cGVvZihpbnB1dFswXSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlucHV0LnVuc2hpZnQodGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS5wcmltaXRpdmUpO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBuZXcgKHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkgPT09IHZlY3Rvcml6ZVRleHQgJiYgaW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlucHV0LnB1c2goe1xuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAvLyBmb250OiAnYXJpYWwnLFxuICAgICAgICAgIC8vIHRyaWFuZ2xlczogdHJ1ZSwgLy8gdG9kbzogbWFrZSBpdCB3b3JrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5nZW9tZXRyeSA9IGlucHV0O1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgdGhpcy5fdmlld3BvcnQgPSB7eCwgeSwgdywgaH07XG4gIHJldHVybiB0aGlzO1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5zZXRBdXRvQ2xlYXIgPSBmdW5jdGlvbihhbW91bnQgPSAxLjAsIG9wdGlvbnMgPSB7fSkge1xuICB0aGlzLmNsZWFyID0ge1xuICAgIGFtb3VudCxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuc3QgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHNvdXJjZS50cmFuc2Zvcm1zLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ2dlblR5cGUnKSB7XG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtID0gcmVwbGFjZUdlblR5cGUodHJhbnNmb3JtLnRyYW5zZm9ybSwgJ2Nvb3JkJylcbiAgICB9XG4gICAgc2VsZi50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5jb25zdCBnbHNsUHJvcHMgPSBbJ3gnLCAneScsICd6JywgJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5JywgJ3h5eicsICd4eXp3J107XG5nbHNsUHJvcHMubWFwKChwcm9wKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHNsU291cmNlLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcHJvcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgR2xzbFNvdXJjZVxuIiwiaW1wb3J0IHtCdWZmZXJHZW9tZXRyeX0gZnJvbSBcInRocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5XCI7XG5pbXBvcnQge0Zsb2F0MzJCdWZmZXJBdHRyaWJ1dGV9IGZyb20gXCJ0aHJlZS9zcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGVcIjtcblxuY2xhc3MgR3JpZEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSAnR3JpZEdlb21ldHJ5JztcblxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBwcmltaXRpdmU6IHR5cGUsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZlcnRpY2VzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50cyc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgfHwgKGhlaWdodCA9IDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGsrMSkgLyAzICUgd2lkdGggLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoTWF0aC5mbG9vcigoay0xKSAvIDMgLyB3aWR0aCkrMC41KSAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpbmVzJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoIHx8ICh3aWR0aCA9IDApO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSAyICogKHdpZHRoICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrIDwgKHdpZHRoICogNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrKzMpIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGspIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoaysyKSAvIDYgJSBoZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGstMSkgLyA2ICUgaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGluZSBzdHJpcCc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxMCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IHx8IChoZWlnaHQgPSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlZCA9IHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IHdpbGwgYmUgTmFOIHdoZW4gcG9pbnRzWzBdID09IDFcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogbWluaW11bSAyIHBvaW50cz9cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrJTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGsgLyAzICUgd2lkdGggLyAod2lkdGgtY2xvc2VkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGstMSkgLyAzIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaW5lIGxvb3AnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGggfHwgKHdpZHRoID0gMTApO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrIC8gMyAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChrLTEpIC8gMyAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBpbnZhbGlkIEdyaWRHZW9tZXRyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IHsgR3JpZEdlb21ldHJ5IH07IiwiLypcbkZvcm1hdCBmb3IgYWRkaW5nIGZ1bmN0aW9ucyB0byBoeWRyYS4gRm9yIGVhY2ggZW50cnkgaW4gdGhpcyBmaWxlLCBoeWRyYSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBhIGdsc2wgZnVuY3Rpb24gYW5kIGphdmFzY3JpcHQgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBuYW1lLiBZb3UgY2FuIGFsc28gYXNzIGZ1bmN0aW9ucyBkeW5hbWljYWxseSB1c2luZyBzZXRGdW5jdGlvbihvYmplY3QpLlxuXG57XG4gIG5hbWU6ICdvc2MnLCAvLyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFjY2VzcyBmdW5jdGlvbiBpbiBqcyBhcyB3ZWxsIGFzIGluIGdsc2xcbiAgdHlwZTogJ3NyYycsIC8vIGNhbiBiZSAnc3JjJywgJ2NvbG9yJywgJ2NvbWJpbmUnLCAnY29tYmluZUNvb3JkcycuIHNlZSBiZWxvdyBmb3IgbW9yZSBpbmZvXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmcmVxJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIGRlZmF1bHQ6IDAuMFxuICAgIH1cbiAgXSxcbiAgICBnbHNsOiBgXG4gICAgICB2ZWMyIHN0ID0gX3N0O1xuICAgICAgZmxvYXQgciA9IHNpbigoc3QueC1vZmZzZXQqMi9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4gICAgICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7XG4gICBgXG59XG5cbi8vIFRoZSBhYm92ZSBjb2RlIGdlbmVyYXRlcyB0aGUgZ2xzbCBmdW5jdGlvbjpcbmB2ZWM0IG9zYyh2ZWMyIF9zdCwgZmxvYXQgZnJlcSwgZmxvYXQgc3luYywgZmxvYXQgb2Zmc2V0KXtcbiB2ZWMyIHN0ID0gX3N0O1xuIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbiBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xufWBcblxuXG5UeXBlcyBhbmQgZGVmYXVsdCBhcmd1bWVudHMgZm9yIGh5ZHJhIGZ1bmN0aW9ucy5cblRoZSB2YWx1ZSBpbiB0aGUgJ3R5cGUnIGZpZWxkIGxldHMgdGhlIHBhcnNlciBrbm93IHdoaWNoIHR5cGUgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgYXMgd2VsbCBhcyBkZWZhdWx0IGFyZ3VtZW50cy5cblxuY29uc3QgdHlwZXMgPSB7XG4gICdzcmMnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29sb3InOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjNCBfYzAnXVxuICB9LFxuICAnY29tYmluZSc6IHtcbiAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgYXJnczogWyd2ZWM0IF9jMCcsICd2ZWM0IF9jMSddXG4gIH0sXG4gICdjb21iaW5lQ29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnLCAndmVjNCBfYzAnXVxuICB9XG59XG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IFtcbiAge1xuICBuYW1lOiAnbm9pc2UnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNCh2ZWMzKF9ub2lzZSh2ZWMzKF9zdCpzY2FsZSwgb2Zmc2V0KnRpbWUpKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3Zvcm9ub2knLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdibGVuZGluZycsXG4gICAgICBkZWZhdWx0OiAwLjMsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzMgY29sb3IgPSB2ZWMzKC4wKTtcbiAgIC8vIFNjYWxlXG4gICBfc3QgKj0gc2NhbGU7XG4gICAvLyBUaWxlIHRoZSBzcGFjZVxuICAgdmVjMiBpX3N0ID0gZmxvb3IoX3N0KTtcbiAgIHZlYzIgZl9zdCA9IGZyYWN0KF9zdCk7XG4gICBmbG9hdCBtX2Rpc3QgPSAxMC47ICAvLyBtaW5pbXVuIGRpc3RhbmNlXG4gICB2ZWMyIG1fcG9pbnQ7ICAgICAgICAvLyBtaW5pbXVtIHBvaW50XG4gICBmb3IgKGludCBqPS0xOyBqPD0xOyBqKysgKSB7XG4gICBmb3IgKGludCBpPS0xOyBpPD0xOyBpKysgKSB7XG4gICB2ZWMyIG5laWdoYm9yID0gdmVjMihmbG9hdChpKSxmbG9hdChqKSk7XG4gICB2ZWMyIHAgPSBpX3N0ICsgbmVpZ2hib3I7XG4gICB2ZWMyIHBvaW50ID0gZnJhY3Qoc2luKHZlYzIoZG90KHAsdmVjMigxMjcuMSwzMTEuNykpLGRvdChwLHZlYzIoMjY5LjUsMTgzLjMpKSkpKjQzNzU4LjU0NTMpO1xuICAgcG9pbnQgPSAwLjUgKyAwLjUqc2luKHRpbWUqc3BlZWQgKyA2LjI4MzEqcG9pbnQpO1xuICAgdmVjMiBkaWZmID0gbmVpZ2hib3IgKyBwb2ludCAtIGZfc3Q7XG4gICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpO1xuICAgaWYoIGRpc3QgPCBtX2Rpc3QgKSB7XG4gICBtX2Rpc3QgPSBkaXN0O1xuICAgbV9wb2ludCA9IHBvaW50O1xuICAgfVxuICAgfVxuICAgfVxuICAgLy8gQXNzaWduIGEgY29sb3IgdXNpbmcgdGhlIGNsb3Nlc3QgcG9pbnQgcG9zaXRpb25cbiAgIGNvbG9yICs9IGRvdChtX3BvaW50LHZlYzIoLjMsLjYpKTtcbiAgIGNvbG9yICo9IDEuMCAtIGJsZW5kaW5nKm1fZGlzdDtcbiAgIHJldHVybiB2ZWM0KGNvbG9yLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdvc2MnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdmcmVxdWVuY3knLFxuICAgICAgZGVmYXVsdDogNjAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3luYycsXG4gICAgICBkZWZhdWx0OiAwLjEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3Q7XG4gICBmbG9hdCByID0gc2luKChzdC54LW9mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcXVlbmN5KSowLjUgKyAwLjU7XG4gICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdzaGFwZScsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NpZGVzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzbW9vdGhpbmcnLFxuICAgICAgZGVmYXVsdDogMC4wMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIDIuIC0gMS47XG4gICAvLyBBbmdsZSBhbmQgcmFkaXVzIGZyb20gdGhlIGN1cnJlbnQgcGl4ZWxcbiAgIGZsb2F0IGEgPSBhdGFuKHN0Lngsc3QueSkrMy4xNDE2O1xuICAgZmxvYXQgciA9ICgyLiozLjE0MTYpL3NpZGVzO1xuICAgZmxvYXQgZCA9IGNvcyhmbG9vciguNSthL3IpKnItYSkqbGVuZ3RoKHN0KTtcbiAgIHJldHVybiB2ZWM0KHZlYzMoMS4wLXNtb290aHN0ZXAocmFkaXVzLHJhZGl1cyArIHNtb290aGluZyArIDAuMDAwMDAwMSxkKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ2dyYWRpZW50JyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX3N0LCBzaW4odGltZSpzcGVlZCksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3NyYycsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgIG5hbWU6ICd0ZXgnLFxuICAgICAgZGVmYXVsdDogTmFOLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eS92ZWMyKDEyODAuLCA3MjAuKTtcbiAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCBmcmFjdChfc3QpKTtgXG59LFxue1xuICBuYW1lOiAnc29saWQnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAgeyB0eXBlOiAnZmxvYXQnLCBuYW1lOiAncicsIGRlZmF1bHQ6IDAgfSxcbiAgICB7IHR5cGU6ICdmbG9hdCcsIG5hbWU6ICdnJywgZGVmYXVsdDogMCB9LFxuICAgIHsgdHlwZTogJ2Zsb2F0JywgbmFtZTogJ2InLCBkZWZhdWx0OiAwIH0sXG4gICAgeyB0eXBlOiAnZmxvYXQnLCBuYW1lOiAnYScsIGRlZmF1bHQ6IDEsfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIGEpO2Bcbn0sXG57XG4gICAgbmFtZTogJ3NvbGlkMycsXG4gICAgdHlwZTogJ3NyYycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHsgdHlwZTogJ3ZlYzMnLCBuYW1lOiAncmdiJywgZGVmYXVsdDogMCB9LFxuICAgICAgICB7IHR5cGU6ICdmbG9hdCcsIG5hbWU6ICdhJywgZGVmYXVsdDogMSx9XG4gICAgXSxcbiAgICBnbHNsOlxuICAgICAgICBgICAgcmV0dXJuIHZlYzQocmdiLCBhKTtgXG59LFxue1xuICBuYW1lOiAncm90YXRlJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgIHZlYzIgeHkgPSBfc3QgLSB2ZWMyKDAuNSk7XG4gICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgZmxvYXQgYW5nID0gYW5nbGUgKiAoMy4xNDE1OTI2NTM1ODk3OTMgLyAxODAuMCk7XG4gICBhbmcgPSBhbmcgKyBzcGVlZCAqdGltZTtcbiAgIHh5ID0gbWF0Mihjb3MoYW5nKSwtc2luKGFuZyksIHNpbihhbmcpLGNvcyhhbmcpKSp4eTtcbiAgIHh5ICs9IDAuNTtcbiAgIHJldHVybiB4eTtgXG59LFxue1xuICBuYW1lOiAnc2NhbGUnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAneE11bHQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd5TXVsdCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgIHh5Kj0oMS4wL3ZlYzIoYW1vdW50KnhNdWx0LCBhbW91bnQqeU11bHQpKTtcbiAgIHh5Kz12ZWMyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgcmV0dXJuIHh5O1xuICAgYFxufSxcbntcbiAgbmFtZTogJ3BpeGVsYXRlJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdwaXhlbFgnLFxuICAgICAgZGVmYXVsdDogMjAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncGl4ZWxZJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gdmVjMihwaXhlbFgsIHBpeGVsWSk7XG4gICByZXR1cm4gKGZsb29yKF9zdCAqIHh5KSArIDAuNSkveHk7YFxufSxcbntcbiAgbmFtZTogJ3Bvc3Rlcml6ZScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYmlucycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2dhbW1hJyxcbiAgICAgIGRlZmF1bHQ6IDAuNixcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCBjMiA9IHBvdyhfYzAsIHZlYzQoZ2FtbWEpKTtcbiAgIGMyICo9IHZlYzQoYmlucyk7XG4gICBjMiA9IGZsb29yKGMyKTtcbiAgIGMyLz0gdmVjNChiaW5zKTtcbiAgIGMyID0gcG93KGMyLCB2ZWM0KDEuMC9nYW1tYSkpO1xuICAgcmV0dXJuIHZlYzQoYzIueHl6LCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ3NoaWZ0JyxcbiAgdHlwZTogJ2dlblR5cGUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAndmVjNCcsXG4gICAgICBuYW1lOiAndmFsJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzQgYzIgPSB2ZWM0KF9jMCk7XG4gICBjMiA9IGZyYWN0KGMyICsgdmFsKTtcbiAgIHJldHVybiBjMjtgXG59LFxue1xuICBuYW1lOiAncmVwZWF0JyxcbiAgdHlwZTogJ2dlblR5cGUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAndmVjMycsXG4gICAgICBuYW1lOiAncmVwZWF0JyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAndmVjMycsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMzIGMyID0gX2MwLnJnYiAqIHJlcGVhdDtcbiAgIGMyICs9IHN0ZXAoMS4sIG1vZChjMiwyLjApKSAqIG9mZnNldDtcbiAgIHJldHVybiB2ZWM0KGZyYWN0KGMyKSwgX2MwLmEpO2AsXG4gIGNvb3JkOiB7XG4gICAgICBpbnB1dHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2ZWMyJyxcbiAgICAgICAgICAgICAgbmFtZTogJ3JlcGVhdCcsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IDMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2ZWMyJyxcbiAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBnbHNsOlxuICAgICAgICAgIGAgdmVjMiBzdCA9IF9zdCAqIHJlcGVhdDtcbiAgICAgICAgICAgIHN0ICs9IHN0ZXAoMS4sIG1vZChzdCwyLjApKSAqIG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBmcmFjdChzdCk7YCxcbiAgfVxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUmVwZWF0JyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwZWF0WCcsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcGVhdFknLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXRYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXRZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwZWF0WCwgcmVwZWF0WSk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpICsgX2MwLnIgKiBvZmZzZXRYO1xuICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKSArIF9jMC5nICogb2Zmc2V0WTtcbiAgIHJldHVybiBmcmFjdChzdCk7YFxufSxcbntcbiAgbmFtZTogJ3JlcGVhdFgnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcHMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwcywgMS4wKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKSogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSZXBlYXRYJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgKiB2ZWMyKHJlcHMsIDEuMCk7XG4gICAvLyAgZmxvYXQgZiA9ICBtb2QoX3N0LnksMi4wKTtcbiAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSkgKyBfYzAuciAqIG9mZnNldDtcbiAgIHJldHVybiBmcmFjdChzdCk7YFxufSxcbntcbiAgbmFtZTogJ3JlcGVhdFknLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcHMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIoMS4wLCByZXBzKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueCArPSBzdGVwKDEuLCBtb2Qoc3QueSwyLjApKSogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSZXBlYXRZJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgKiB2ZWMyKHJlcHMsIDEuMCk7XG4gICAvLyAgZmxvYXQgZiA9ICBtb2QoX3N0LnksMi4wKTtcbiAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSkgKyBfYzAuciAqIG9mZnNldDtcbiAgIHJldHVybiBmcmFjdChzdCk7YFxufSxcbntcbiAgbmFtZTogJ2thbGVpZCcsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnblNpZGVzJyxcbiAgICAgIGRlZmF1bHQ6IDQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3Q7XG4gICBzdCAtPSAwLjU7XG4gICBmbG9hdCByID0gbGVuZ3RoKHN0KTtcbiAgIGZsb2F0IGEgPSBhdGFuKHN0LnksIHN0LngpO1xuICAgZmxvYXQgcGkgPSAyLiozLjE0MTY7XG4gICBhID0gbW9kKGEscGkvblNpZGVzKTtcbiAgIGEgPSBhYnMoYS1waS9uU2lkZXMvMi4pO1xuICAgcmV0dXJuIHIqdmVjMihjb3MoYSksIHNpbihhKSk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlS2FsZWlkJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnblNpZGVzJyxcbiAgICAgIGRlZmF1bHQ6IDQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgLSAwLjU7XG4gICBmbG9hdCByID0gbGVuZ3RoKHN0KTtcbiAgIGZsb2F0IGEgPSBhdGFuKHN0LnksIHN0LngpO1xuICAgZmxvYXQgcGkgPSAyLiozLjE0MTY7XG4gICBhID0gbW9kKGEscGkvblNpZGVzKTtcbiAgIGEgPSBhYnMoYS1waS9uU2lkZXMvMi4pO1xuICAgcmV0dXJuIChfYzAucityKSp2ZWMyKGNvcyhhKSwgc2luKGEpKTtgXG59LFxue1xuICBuYW1lOiAnc2Nyb2xsJyxcbiAgdHlwZTogJ2dlblR5cGUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAndmVjMycsXG4gICAgICBuYW1lOiAnc2Nyb2xsJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICd2ZWMzJyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG4gIF0sXG4gIGdsc2w6XG5gXG4gICBfYzAucmdiICs9IHNjcm9sbCArIHRpbWUqc3BlZWQ7XG4gICByZXR1cm4gdmVjNChmcmFjdChfYzAucmdiKSwgX2MwLmEpO2AsXG4gIGNvb3JkOiB7XG4gICAgICBpbnB1dHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2ZWMyJyxcbiAgICAgICAgICAgICAgbmFtZTogJ3Njcm9sbCcsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3ZlYzInLFxuICAgICAgICAgICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZ2xzbDpcbiAgICAgICAgICBgXG4gICAgICAgIF9zdC54eSArPSBzY3JvbGwgKyB0aW1lKnNwZWVkO1xuICAgICAgICByZXR1cm4gZnJhY3QoX3N0KTtgLFxuICB9XG59LFxue1xuICBuYW1lOiAnc2Nyb2xsWCcsXG4gIHR5cGU6ICdnZW5UeXBlJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfYzAueCArPSBzY3JvbGxYICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiB2ZWM0KGZyYWN0KF9jMC54KSwgX2MwLnksIF9jMC56LCBfYzAuYSk7YCxcbiAgY29vcmQ6IHtcbiAgICAgIGdsc2w6XG4gICAgICBgICAgX3N0LnggKz0gc2Nyb2xsWCArIHRpbWUqc3BlZWQ7XG4gICAgICAgICAgcmV0dXJuIGZyYWN0KF9zdCk7YCxcbiAgfVxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2Nyb2xsWCcsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9zdC54ICs9IF9jMC5yKnNjcm9sbFggKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ3Njcm9sbFknLFxuICB0eXBlOiAnZ2VuVHlwZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2Nyb2xsWScsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9jMC55ICs9IHNjcm9sbFkgKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIHZlYzQoX2MwLngsIGZyYWN0KF9jMC55KSwgX2MwLnosIF9jMC5hKTtgLFxuICBjb29yZDoge1xuICAgICAgZ2xzbDpcbiAgICAgIGAgICBfc3QueSArPSBzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgICAgICAgICByZXR1cm4gZnJhY3QoX3N0KTtgXG4gIH1cbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVNjcm9sbFknLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueSArPSBfYzAucipzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdhZGQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiAoX2MwK19jMSkqYW1vdW50ICsgX2MwKigxLjAtYW1vdW50KTtgXG59LFxue1xuICBuYW1lOiAnc3ViJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gKF9jMC1fYzEpKmFtb3VudCArIF9jMCooMS4wLWFtb3VudCk7YFxufSxcbntcbiAgbmFtZTogJ2xheWVyJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcblxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KG1peChfYzAucmdiLCBfYzEucmdiLCBfYzEuYSksIGNsYW1wKF9jMC5hICsgX2MxLmEsIDAuMCwgMS4wKSk7YFxufSxcbntcbiAgbmFtZTogJ2JsZW5kJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpK19jMSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ211bHQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpKyhfYzAqX2MxKSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ2RpZmYnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoYWJzKF9jMC5yZ2ItX2MxLnJnYiksIG1heChfYzAuYSwgX2MxLmEpKTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgcmV0dXJuIGZyYWN0KHN0KyhfYzAueHktMC41KSphbW91bnQpO1xuICAgcmV0dXJuIF9zdCArIF9jMC54eSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2NhbGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgeHkqPSgxLjAvdmVjMihvZmZzZXQgKyBtdWx0aXBsZSpfYzAuciwgb2Zmc2V0ICsgbXVsdGlwbGUqX2MwLmcpKTtcbiAgIHh5Kz12ZWMyKDAuNSk7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUGl4ZWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiB4eSA9IHZlYzIob2Zmc2V0ICsgX2MwLngqbXVsdGlwbGUsIG9mZnNldCArIF9jMC55Km11bHRpcGxlKTtcbiAgIHJldHVybiAoZmxvb3IoX3N0ICogeHkpICsgMC41KS94eTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSb3RhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgZmxvYXQgYW5nbGUgPSBvZmZzZXQgKyBfYzAueCAqIG11bHRpcGxlO1xuICAgeHkgPSBtYXQyKGNvcyhhbmdsZSksLXNpbihhbmdsZSksIHNpbihhbmdsZSksY29zKGFuZ2xlKSkqeHk7XG4gICB4eSArPSAwLjU7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlSHVlJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfc3QgKyAodmVjMihfYzAuZyAtIF9jMC5yLCBfYzAuYiAtIF9jMC5nKSAqIGFtb3VudCAqIDEuMC9yZXNvbHV0aW9uKTtgXG59LFxue1xuICBuYW1lOiAnaW52ZXJ0JyxcbiAgdHlwZTogJ2dlblR5cGUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDogYHJldHVybiB2ZWM0KCgxLjAtX2MwLnJnYikqYW1vdW50ICsgX2MwLnJnYiooMS4wLWFtb3VudCksIF9jMC5hKTtgLFxuICBjb29yZDoge1xuICAgICAgZ2xzbDogYHJldHVybiAoMS4wLV9zdCkqYW1vdW50ICsgX3N0KigxLjAtYW1vdW50KTtgLFxuICB9LFxufSxcbntcbiAgbmFtZTogJ2NvbnRyYXN0JyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMS42LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMgPSAoX2MwLXZlYzQoMC41KSkqdmVjNChhbW91bnQpICsgdmVjNCgwLjUpO1xuICAgcmV0dXJuIHZlYzQoYy5yZ2IsIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnYnJpZ2h0bmVzcycsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDAuNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLnJnYiArIHZlYzMoYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdtYXNrJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcblxuICBdLFxuICBnbHNsOlxuICBgICAgZmxvYXQgYSA9IF9sdW1pbmFuY2UoX2MxLnJnYik7XG4gIHJldHVybiB2ZWM0KF9jMC5yZ2IqYSwgYSpfYzAuYSk7YFxufSxcblxue1xuICBuYW1lOiAnbHVtYScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndGhyZXNob2xkJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd0b2xlcmFuY2UnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBmbG9hdCBhID0gc21vb3Roc3RlcCh0aHJlc2hvbGQtKHRvbGVyYW5jZSswLjAwMDAwMDEpLCB0aHJlc2hvbGQrKHRvbGVyYW5jZSswLjAwMDAwMDEpLCBfbHVtaW5hbmNlKF9jMC5yZ2IpKTtcbiAgIHJldHVybiB2ZWM0KF9jMC5yZ2IqYSwgYSk7YFxufSxcbntcbiAgbmFtZTogJ3RocmVzaCcsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndGhyZXNob2xkJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd0b2xlcmFuY2UnLFxuICAgICAgZGVmYXVsdDogMC4wNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQodmVjMyhzbW9vdGhzdGVwKHRocmVzaG9sZC0odG9sZXJhbmNlKzAuMDAwMDAwMSksIHRocmVzaG9sZCsodG9sZXJhbmNlKzAuMDAwMDAwMSksIF9sdW1pbmFuY2UoX2MwLnJnYikpKSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb2xvcicsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncicsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2cnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMgPSB2ZWM0KHIsIGcsIGIsIGEpO1xuICAgdmVjNCBwb3MgPSBzdGVwKDAuMCwgYyk7IC8vIGRldGVjdCB3aGV0aGVyIG5lZ2F0aXZlXG4gICAvLyBpZiA+IDAsIHJldHVybiByICogX2MwXG4gICAvLyBpZiA8IDAgcmV0dXJuICgxLjAtcikgKiBfYzBcbiAgIHJldHVybiB2ZWM0KG1peCgoMS4wLV9jMCkqYWJzKGMpLCBjKl9jMCwgcG9zKSk7YFxufSxcbntcbiAgbmFtZTogJ3NhdHVyYXRlJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMixcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcbiAgIHZlYzMgaW50ZW5zaXR5ID0gdmVjMyhkb3QoX2MwLnJnYiwgVykpO1xuICAgcmV0dXJuIHZlYzQobWl4KGludGVuc2l0eSwgX2MwLnJnYiwgYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdodWUnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2h1ZScsXG4gICAgICBkZWZhdWx0OiAwLjQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzMgYyA9IF9yZ2JUb0hzdihfYzAucmdiKTtcbiAgIGMuciArPSBodWU7XG4gICAvLyAgYy5yID0gZnJhY3QoYy5yKTtcbiAgIHJldHVybiB2ZWM0KF9oc3ZUb1JnYihjKSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb2xvcmFtYScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDAuMDA1LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMzIGMgPSBfcmdiVG9Ic3YoX2MwLnJnYik7XG4gICBjICs9IHZlYzMoYW1vdW50KTtcbiAgIGMgPSBfaHN2VG9SZ2IoYyk7XG4gICBjID0gZnJhY3QoYyk7XG4gICByZXR1cm4gdmVjNChjLCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ3ByZXYnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG5cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdGV4dHVyZTJEKHByZXZCdWZmZXIsIGZyYWN0KF9zdCkpO2Bcbn0sXG57XG4gIG5hbWU6ICdzdW0nLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAndmVjNCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCB2ID0gX2MwICogcztcbiAgIHJldHVybiB2LnIgKyB2LmcgKyB2LmIgKyB2LmE7XG4gICB9XG4gICBmbG9hdCBzdW0odmVjMiBfc3QsIHZlYzQgcykgeyAvLyB2ZWM0IGlzIG5vdCBhIHR5cG8sIGJlY2F1c2UgYXJndW1lbnQgdHlwZSBpcyBub3Qgb3ZlcmxvYWRlZFxuICAgdmVjMiB2ID0gX3N0Lnh5ICogcy54eTtcbiAgIHJldHVybiB2LnggKyB2Lnk7YFxufSxcbntcbiAgbmFtZTogJ3InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5yICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG57XG4gIG5hbWU6ICdnJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuZyAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICBuYW1lOiAnYicsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLmIgKiBzY2FsZSArIG9mZnNldCk7YFxufSxcbntcbiAgbmFtZTogJ2EnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5hICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG4vLyB0b2RvOiBtYWtlIHRoZXNlIGdlblR5cGVcbi8vIHRvZG86IHRoZSBxdWVzdGlvbiBpcyBzaG91bGQgZ2VuVHlwZSBiZWhhdmUgbGlrZSBjb29yZCBvciBsaWtlIGNvbG9yLCB3aGVuIHBpcGVkP1xue1xuICAgIG5hbWU6ICdtYXAnLFxuICAgIHR5cGU6ICdnZW5UeXBlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICAge25hbWU6ICdzdGFydDEnLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IE5hTn0sXG4gICAgICAgIHtuYW1lOiAnc3RvcDEnLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IE5hTn0sXG4gICAgICAgIHtuYW1lOiAnc3RhcnQyJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAwfSxcbiAgICAgICAge25hbWU6ICdzdG9wMicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgXSxcbiAgICBnbHNsOiBgcmV0dXJuIChfYzAgLSBzdGFydDEpIC8gKHN0b3AxIC0gc3RhcnQxKSAqIChzdG9wMiAtIHN0YXJ0MikgKyBzdGFydDI7YCxcbiAgICBjb29yZDoge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnc3RhcnQxJywgdHlwZTogJ3ZlYzInLCBkZWZhdWx0OiBOYU59LFxuICAgICAgICAgICAge25hbWU6ICdzdG9wMScsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogTmFOfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc3RhcnQyJywgdHlwZTogJ3ZlYzInLCBkZWZhdWx0OiAwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc3RvcDInLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIChfc3QgLSBzdGFydDEpIC8gKHN0b3AxIC0gc3RhcnQxKSAqIChzdG9wMiAtIHN0YXJ0MikgKyBzdGFydDI7YCxcbiAgICB9LFxufSxcbntcbiAgICBuYW1lOiAnc2luJyxcbiAgICBnbHNsTmFtZTogJ19zaW4nLFxuICAgIHR5cGU6ICdnZW5UeXBlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICAge25hbWU6ICdmcmVxJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiAxLjB9LFxuICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogMS4wfSxcbiAgICBdLFxuICAgIGdsc2w6IGByZXR1cm4gdmVjNChzaW4oX2MwLnJnYiAqIFRXT19QSSAqIGZyZXEpICogYW1wLCBfYzAuYSk7YCxcbiAgICBjb29yZDoge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZnJlcScsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogMS4wfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ3ZlYzInLCBkZWZhdWx0OiAwLjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIHNpbihfc3QgKiBUV09fUEkgKiBmcmVxKSAqIGFtcDtgLFxuICAgIH0sXG59LFxue1xuICAgIG5hbWU6ICdjb3MnLFxuICAgIGdsc2xOYW1lOiAnX2NvcycsXG4gICAgdHlwZTogJ2dlblR5cGUnLFxuICAgIGlucHV0czogW1xuICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IDF9LFxuICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogMX0sXG4gICAgXSxcbiAgICBnbHNsOiBgcmV0dXJuIHZlYzQoY29zKF9jMC5yZ2IgKiBUV09fUEkgKiBmcmVxKSAqIGFtcCwgX2MwLmEpO2AsXG4gICAgY29vcmQ6IHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gY29zKF9zdCAqIFRXT19QSSAqIGZyZXEpICogYW1wO2AsXG4gICAgfSxcbn0sXG57XG4gICAgbmFtZTogJ3RhbicsXG4gICAgZ2xzbE5hbWU6ICdfdGFuJyxcbiAgICB0eXBlOiAnZ2VuVHlwZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtuYW1lOiAnZnJlcScsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogMX0sXG4gICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiAxLjB9LFxuICAgIF0sXG4gICAgZ2xzbDogYHJldHVybiB2ZWM0KHRhbihfYzAucmdiICogUEkgKiBmcmVxKSAqIGFtcCwgX2MwLmEpO2AsXG4gICAgY29vcmQ6IHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxufSxcbntcbiAgICBuYW1lOiAnYXRhbicsXG4gICAgZ2xzbE5hbWU6ICdfYXRhbicsXG4gICAgdHlwZTogJ2dlblR5cGUnLFxuICAgIGlucHV0czogW1xuICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IDF9LFxuICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogMX0sXG4gICAgXSxcbiAgICBnbHNsOiBgcmV0dXJuIHZlYzQoYXRhbihfYzAucmdiICogUEkgKiBmcmVxKSAqIGFtcCwgX2MwLmEpO2AsXG4gICAgY29vcmQ6IHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAndmVjMicsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gYXRhbihfc3QgKiBQSSAqIGZyZXEpICogYW1wO2AsXG4gICAgfSxcbn0sXG57XG4gICAgbmFtZTogJ3BvdycsXG4gICAgZ2xzbE5hbWU6ICdfcG93JyxcbiAgICB0eXBlOiAnZ2VuVHlwZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtuYW1lOiAncG93ZXInLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IDJ9LFxuICAgIF0sXG4gICAgZ2xzbDogYHJldHVybiB2ZWM0KHBvdyhfYzAucmdiLCBwb3dlciksIF9jMC5hKTtgLFxuICAgIGNvb3JkOiB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3dlcicsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogMn0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gcG93KF9zdCwgcG93ZXIpO2BcbiAgICB9LFxufSxcbntcbiAgICBuYW1lOiAnc2Nyb2xsWicsXG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICAgIG5hbWU6ICdzY3JvbGxaJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICB9XG4gICAgXSxcbiAgICBnbHNsOlxuICAgIGAgICBfYzAueSArPSBzY3JvbGxaICsgdGltZSpzcGVlZDtcbiAgICAgICAgcmV0dXJuIGZyYWN0KF9jMCk7YCxcbn0sXG57XG4gICAgbmFtZTogJ2dsc2wnLFxuICAgIHR5cGU6ICdnbHNsJyxcbiAgICBpbnB1dHM6IFtdLFxuICAgIGdsc2w6IGBgLFxufSxcbl1cbiIsIi8vIGZ1bmN0aW9ucyB0aGF0IGFyZSBvbmx5IHVzZWQgd2l0aGluIG90aGVyIGZ1bmN0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9waToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTVgLFxuICB9LFxuICBfdHdvcGk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYCNkZWZpbmUgVFdPX1BJIDYuMjgzMTg1MzA3MTc5NTg2YCxcbiAgfSxcbiAgX2x1bWluYW5jZToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgZmxvYXQgX2x1bWluYW5jZSh2ZWMzIHJnYil7XG4gICAgICBjb25zdCB2ZWMzIFcgPSB2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpO1xuICAgICAgcmV0dXJuIGRvdChyZ2IsIFcpO1xuICAgIH1gXG4gIH0sXG4gIF9wZXJtdXRlOiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGB2ZWM0IF9wZXJtdXRlKHZlYzQgeCl7cmV0dXJuIG1vZCgoKHgqMzQuMCkrMS4wKSp4LCAyODkuMCk7fWBcbiAgfSxcbiAgX21vZDI4OToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgXG52ZWMzIF9tb2QyODkodmVjMyB4KVxue1xuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xufVxuXG52ZWM0IF9tb2QyODkodmVjNCB4KVxue1xuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xufVxuYFxuICB9LFxuICBfdGF5bG9ySW52U3FydDoge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgdmVjNCBfdGF5bG9ySW52U3FydCh2ZWM0IHIpe3JldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7fWBcbiAgfSxcbiAgLy9cdFNpbXBsZXggM0QgTm9pc2VcbiAgLy9cdGJ5IElhbiBNY0V3YW4sIEFzaGltYSBBcnRzXG4gIF9ub2lzZToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgXG4gIGZsb2F0IF9ub2lzZSh2ZWMzIHYpe1xuICAgIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcbiAgICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xuXG4gIC8vIEZpcnN0IGNvcm5lclxuICAgIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSApO1xuICAgIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XG5cbiAgLy8gT3RoZXIgY29ybmVyc1xuICAgIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xuICAgIHZlYzMgbCA9IDEuMCAtIGc7XG4gICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XG4gICAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XG5cbiAgICAvLyAgeDAgPSB4MCAtIDAuICsgMC4wICogQ1xuICAgIHZlYzMgeDEgPSB4MCAtIGkxICsgMS4wICogQy54eHg7XG4gICAgdmVjMyB4MiA9IHgwIC0gaTIgKyAyLjAgKiBDLnh4eDtcbiAgICB2ZWMzIHgzID0geDAgLSAxLiArIDMuMCAqIEMueHh4O1xuXG4gIC8vIFBlcm11dGF0aW9uc1xuICAgIGkgPSBtb2QoaSwgMjg5LjAgKTtcbiAgICB2ZWM0IHAgPSBfcGVybXV0ZSggX3Blcm11dGUoIF9wZXJtdXRlKFxuICAgICAgICAgICAgICAgaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKVxuICAgICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxuICAgICAgICAgICAgICsgaS54ICsgdmVjNCgwLjAsIGkxLngsIGkyLngsIDEuMCApKTtcblxuICAvLyBHcmFkaWVudHNcbiAgLy8gKCBOKk4gcG9pbnRzIHVuaWZvcm1seSBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLilcbiAgICBmbG9hdCBuXyA9IDEuMC83LjA7IC8vIE49N1xuICAgIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xuXG4gICAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqbnMueik7ICAvLyAgbW9kKHAsTipOKVxuXG4gICAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcbiAgICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXG5cbiAgICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XG4gICAgdmVjNCB5ID0geV8gKm5zLnggKyBucy55eXl5O1xuICAgIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcblxuICAgIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XG4gICAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcblxuICAgIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xuICAgIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xuICAgIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xuXG4gICAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xuICAgIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcblxuICAgIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XG4gICAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcbiAgICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xuICAgIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XG5cbiAgLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXG4gICAgdmVjNCBub3JtID0gX3RheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xuICAgIHAwICo9IG5vcm0ueDtcbiAgICBwMSAqPSBub3JtLnk7XG4gICAgcDIgKj0gbm9ybS56O1xuICAgIHAzICo9IG5vcm0udztcblxuICAvLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcbiAgICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcbiAgICBtID0gbSAqIG07XG4gICAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcbiAgfVxuICAgIGBcbiAgfSxcblxuICBfcmdiVG9Ic3Y6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzMgX3JnYlRvSHN2KHZlYzMgYyl7XG4gICAgICAgICAgICB2ZWM0IEsgPSB2ZWM0KDAuMCwgLTEuMCAvIDMuMCwgMi4wIC8gMy4wLCAtMS4wKTtcbiAgICAgICAgICAgIHZlYzQgcCA9IG1peCh2ZWM0KGMuYmcsIEsud3opLCB2ZWM0KGMuZ2IsIEsueHkpLCBzdGVwKGMuYiwgYy5nKSk7XG4gICAgICAgICAgICB2ZWM0IHEgPSBtaXgodmVjNChwLnh5dywgYy5yKSwgdmVjNChjLnIsIHAueXp4KSwgc3RlcChwLngsIGMucikpO1xuXG4gICAgICAgICAgICBmbG9hdCBkID0gcS54IC0gbWluKHEudywgcS55KTtcbiAgICAgICAgICAgIGZsb2F0IGUgPSAxLjBlLTEwO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzMoYWJzKHEueiArIChxLncgLSBxLnkpIC8gKDYuMCAqIGQgKyBlKSksIGQgLyAocS54ICsgZSksIHEueCk7XG4gICAgICAgIH1gXG4gIH0sXG4gIF9oc3ZUb1JnYjoge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgdmVjMyBfaHN2VG9SZ2IodmVjMyBjKXtcbiAgICAgICAgdmVjNCBLID0gdmVjNCgxLjAsIDIuMCAvIDMuMCwgMS4wIC8gMy4wLCAzLjApO1xuICAgICAgICB2ZWMzIHAgPSBhYnMoZnJhY3QoYy54eHggKyBLLnh5eikgKiA2LjAgLSBLLnd3dyk7XG4gICAgICAgIHJldHVybiBjLnogKiBtaXgoSy54eHgsIGNsYW1wKHAgLSBLLnh4eCwgMC4wLCAxLjApLCBjLnkpO1xuICAgIH1gXG4gIH1cbn1cbiIsImltcG9ydCBnbHNsIGZyb20gJ2dsc2xpZnknXG5pbXBvcnQge0dyaWRHZW9tZXRyeX0gZnJvbSBcIi4vZ2VvbWV0cmllcy9HcmlkR2VvbWV0cnkuanNcIjtcbmltcG9ydCB2ZWN0b3JpemVUZXh0IGZyb20gXCJ2ZWN0b3JpemUtdGV4dFwiO1xuXG5jb25zdCBwb2ludHNWZXJ0ID0gZ2xzbChcIi4vc2hhZGVycy9wb2ludHMudmVydFwiKTtcbmNvbnN0IGxpbmVzVmVydCA9IGdsc2woXCIuL3NoYWRlcnMvbGluZXMudmVydFwiKTtcbmNvbnN0IGxpbmVzdHJpcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL2xpbmVzdHJpcC52ZXJ0XCIpO1xuY29uc3QgbGluZWxvb3BWZXJ0ID0gZ2xzbChcIi4vc2hhZGVycy9saW5lbG9vcC52ZXJ0XCIpO1xuXG5jb25zdCBkb3RzRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvZG90cy5mcmFnXCIpO1xuY29uc3Qgc3F1YXJlc0ZyYWcgPSBnbHNsKFwiLi9zaGFkZXJzL3NxdWFyZXMuZnJhZ1wiKTtcbmNvbnN0IGxpbmVzRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvbGluZXMuZnJhZ1wiKTtcbmNvbnN0IGxpbmVzdHJpcEZyYWcgPSBnbHNsKFwiLi9zaGFkZXJzL2xpbmVzdHJpcC5mcmFnXCIpO1xuY29uc3QgbGluZWxvb3BGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9saW5lbG9vcC5mcmFnXCIpO1xuXG4vLyB0b2RvOiByZXNwZWN0IG1ha2VHbG9iYWw/XG5PYmplY3QuYXNzaWduKHdpbmRvdywge0dyaWRHZW9tZXRyeSwgdmVjdG9yaXplVGV4dH0pO1xuXG5leHBvcnQgZGVmYXVsdCAoaHkpID0+IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdkb3RzJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBoeS5ncmFkaWVudCgpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc2l6ZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdmYWRlJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wMjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBkb3RzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnc3F1YXJlcycsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuZ3JhZGllbnQoKX0sXG4gICAgICAgICAgICB7bmFtZTogJ3NpemUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdmYWRlJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wMjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBzcXVhcmVzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbGluZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVzRnJhZyxcbiAgICAgICAgdmVydDogbGluZXNWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdsaW5lcycsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdsaW5lc3RyaXAnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LnNvbGlkKGh5Lm5vaXNlKDEpLngsIGh5Lm5vaXNlKDIpLnksIGh5Lm5vaXNlKDMpLnopLm1hcCgtMSwxLDAsMSl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVzdHJpcEZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzdHJpcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgc3RyaXAnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbGluZWxvb3AnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LnNvbGlkKGh5Lm5vaXNlKDEpLngsIGh5Lm5vaXNlKDIpLnksIGh5Lm5vaXNlKDMpLnopLm1hcCgtMSwxLDAsMSl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVsb29wRnJhZyxcbiAgICAgICAgdmVydDogbGluZWxvb3BWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdsaW5lIGxvb3AnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICBnZW9tZXRyeTogdmVjdG9yaXplVGV4dCxcbiAgICAgICAgdXNlVVY6IGZhbHNlLFxuICAgICAgICB1c2VOb3JtYWw6IGZhbHNlLFxuICAgIH0sXG5dO1xuIiwiaW1wb3J0IFdlYmNhbSBmcm9tICcuL2xpYi93ZWJjYW0uanMnXG5pbXBvcnQgU2NyZWVuIGZyb20gJy4vbGliL3NjcmVlbm1lZGlhLmpzJ1xuXG5jbGFzcyBIeWRyYVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yICh7IHJlZ2wsIHdpZHRoLCBoZWlnaHQsIHBiLCBsYWJlbCA9IFwiXCJ9KSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsXG4gICAgdGhpcy5yZWdsID0gcmVnbFxuICAgIHRoaXMuc3JjID0gbnVsbFxuICAgIHRoaXMuZHluYW1pYyA9IHRydWVcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoe1xuICAgICAgLy8gIHNoYXBlOiBbd2lkdGgsIGhlaWdodF1cbiAgICAgIHNoYXBlOiBbIDEsIDEgXVxuICAgIH0pXG4gICAgdGhpcy5wYiA9IHBiXG4gIH1cblxuICBpbml0IChvcHRzLCBwYXJhbXMpIHtcbiAgICBpZiAoJ3NyYycgaW4gb3B0cykge1xuICAgICAgdGhpcy5zcmMgPSBvcHRzLnNyY1xuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXMgfSlcbiAgICB9XG4gICAgaWYgKCdkeW5hbWljJyBpbiBvcHRzKSB0aGlzLmR5bmFtaWMgPSBvcHRzLmR5bmFtaWNcbiAgfVxuXG4gIGluaXRDYW0gKGluZGV4LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIFdlYmNhbShpbmRleClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgc2VsZi5zcmMgPSByZXNwb25zZS52aWRlb1xuICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygnY291bGQgbm90IGdldCBjYW1lcmEnLCBlcnIpKVxuICB9XG5cbiAgaW5pdFZpZGVvICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgLy8gY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCB2aWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgdmlkLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICB2aWQuYXV0b3BsYXkgPSB0cnVlXG4gICAgdmlkLmxvb3AgPSB0cnVlXG4gICAgdmlkLm11dGVkID0gdHJ1ZSAvLyBtdXRlIGluIG9yZGVyIHRvIGxvYWQgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3Qgb25sb2FkID0gdmlkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNyYyA9IHZpZFxuICAgICAgdmlkLnBsYXkoKVxuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgdGhpcy5keW5hbWljID0gdHJ1ZVxuICAgIH0pXG4gICAgdmlkLnNyYyA9IHVybFxuICB9XG5cbiAgaW5pdEltYWdlICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgIGltZy5zcmMgPSB1cmxcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zcmMgPSBpbWdcbiAgICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlXG4gICAgICB0aGlzLnRleCA9IHRoaXMucmVnbC50ZXh0dXJlKHsgZGF0YTogdGhpcy5zcmMsIC4uLnBhcmFtc30pXG4gICAgfVxuICB9XG5cbiAgaW5pdFN0cmVhbSAoc3RyZWFtTmFtZSwgcGFyYW1zKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKFwiaW5pdGluZyBzdHJlYW0hXCIsIHN0cmVhbU5hbWUpXG4gICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgaWYgKHN0cmVhbU5hbWUgJiYgdGhpcy5wYikge1xuICAgICAgdGhpcy5wYi5pbml0U291cmNlKHN0cmVhbU5hbWUpXG5cbiAgICAgIHRoaXMucGIub24oJ2dvdCB2aWRlbycsIGZ1bmN0aW9uIChuaWNrLCB2aWRlbykge1xuICAgICAgICBpZiAobmljayA9PT0gc3RyZWFtTmFtZSkge1xuICAgICAgICAgIHNlbGYuc3JjID0gdmlkZW9cbiAgICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgc2VsZi50ZXggPSBzZWxmLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHNlbGYuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGluZGV4IG9ubHkgcmVsZXZhbnQgaW4gYXRvbS1oeWRyYSArIGRlc2t0b3AgYXBwc1xuICBpbml0U2NyZWVuIChpbmRleCA9IDAsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgU2NyZWVuKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBzZWxmLnNyYyA9IHJlc3BvbnNlLnZpZGVvXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zfSlcbiAgICAgICAgc2VsZi5keW5hbWljID0gdHJ1ZVxuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJyZWNlaXZlZCBzY3JlZW4gaW5wdXRcIilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKCdjb3VsZCBub3QgZ2V0IHNjcmVlbicsIGVycikpXG4gIH1cblxuICByZXNpemUgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNyYyAmJiB0aGlzLnNyYy5zcmNPYmplY3QpIHtcbiAgICAgIGlmICh0aGlzLnNyYy5zcmNPYmplY3QuZ2V0VHJhY2tzKSB7XG4gICAgICAgIHRoaXMuc3JjLnNyY09iamVjdC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcmMgPSBudWxsXG4gICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IHNoYXBlOiBbIDEsIDEgXSB9KVxuICB9XG5cbiAgdGljayAodGltZSkge1xuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnNyYywgdGhpcy50ZXgud2lkdGgsIHRoaXMudGV4LmhlaWdodClcbiAgICBpZiAodGhpcy5zcmMgIT09IG51bGwgJiYgdGhpcy5keW5hbWljID09PSB0cnVlKSB7XG4gICAgICBpZiAodGhpcy5zcmMudmlkZW9XaWR0aCAmJiB0aGlzLnNyYy52aWRlb1dpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICB0aGlzLnNyYy52aWRlb1dpZHRoLFxuICAgICAgICAgIHRoaXMuc3JjLnZpZGVvSGVpZ2h0LFxuICAgICAgICAgIHRoaXMudGV4LndpZHRoLFxuICAgICAgICAgIHRoaXMudGV4LmhlaWdodFxuICAgICAgICApXG4gICAgICAgIHRoaXMudGV4LnJlc2l6ZSh0aGlzLnNyYy52aWRlb1dpZHRoLCB0aGlzLnNyYy52aWRlb0hlaWdodClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3JjLndpZHRoICYmIHRoaXMuc3JjLndpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICB0aGlzLnRleC5yZXNpemUodGhpcy5zcmMud2lkdGgsIHRoaXMuc3JjLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXguc3ViaW1hZ2UodGhpcy5zcmMpXG4gICAgfVxuICB9XG5cbiAgZ2V0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSHlkcmFTb3VyY2VcbiIsIlxuaW1wb3J0IE91dHB1dCBmcm9tICcuL291dHB1dC5qcydcbmltcG9ydCBsb29wIGZyb20gJ3JhZi1sb29wJ1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuL2h5ZHJhLXNvdXJjZS5qcydcbmltcG9ydCBNb3VzZVRvb2xzIGZyb20gJy4vbGliL21vdXNlLmpzJ1xuaW1wb3J0IEF1ZGlvIGZyb20gJy4vbGliL2F1ZGlvLmpzJ1xuaW1wb3J0IFZpZFJlY29yZGVyIGZyb20gJy4vbGliL3ZpZGVvLXJlY29yZGVyLmpzJ1xuaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG4vLyBpbXBvcnQgc3RydWRlbCBmcm9tICcuL2xpYi9zdHJ1ZGVsLmpzJ1xuaW1wb3J0IFNhbmRib3ggZnJvbSAnLi9ldmFsLXNhbmRib3guanMnXG5pbXBvcnQgR2VuZXJhdG9yIGZyb20gJy4vZ2VuZXJhdG9yLWZhY3RvcnkuanMnXG5pbXBvcnQgcmVnbCBmcm9tICdyZWdsJ1xuLy8gY29uc3Qgd2luZG93ID0gZ2xvYmFsLndpbmRvd1xuXG5cblxuY29uc3QgTW91c2UgPSBNb3VzZVRvb2xzKClcbi8vIHRvIGRvOiBhZGQgYWJpbGl0eSB0byBwYXNzIGluIGNlcnRhaW4gdW5pZm9ybXMgYW5kIHRyYW5zZm9ybXNcbmNsYXNzIEh5ZHJhUmVuZGVyZXIge1xuXG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcGIgPSBudWxsLFxuICAgIHdpZHRoID0gMTI4MCxcbiAgICBoZWlnaHQgPSA3MjAsXG4gICAgbnVtU291cmNlcyA9IDQsXG4gICAgbnVtT3V0cHV0cyA9IDQsXG4gICAgbWFrZUdsb2JhbCA9IHRydWUsXG4gICAgYXV0b0xvb3AgPSB0cnVlLFxuICAgIGRldGVjdEF1ZGlvID0gdHJ1ZSxcbiAgICBlbmFibGVTdHJlYW1DYXB0dXJlID0gdHJ1ZSxcbiAgICBjYW52YXMsXG4gICAgcHJlY2lzaW9uLFxuICAgIGV4dGVuZFRyYW5zZm9ybXMgPSB7fSAvLyBhZGQgeW91ciBvd24gZnVuY3Rpb25zIG9uIGluaXRcbiAgfSA9IHt9KSB7XG5cbiAgICBBcnJheVV0aWxzLmluaXQoKVxuXG4gICAgdGhpcy5wYiA9IHBiXG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMucmVuZGVyQWxsID0gZmFsc2VcbiAgICB0aGlzLmRldGVjdEF1ZGlvID0gZGV0ZWN0QXVkaW9cblxuICAgIHRoaXMuX2luaXRDYW52YXMoY2FudmFzKVxuXG4gICAgLy9nbG9iYWwud2luZG93LnRlc3QgPSAnaGknXG4gICAgLy8gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIG1hZGUgYXZhaWxhYmxlIG9uIHRoZSBnbG9iYWwgY29udGV4dCBhbmQgZHVyaW5nIGxvY2FsIGV2YWx1YXRpb25cbiAgICB0aGlzLnN5bnRoID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIGJwbTogMzAsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBmcHM6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIGZwczogMFxuICAgICAgfSxcbiAgICAgIHNwZWVkOiAxLFxuICAgICAgbW91c2U6IE1vdXNlLFxuICAgICAgcmVuZGVyOiB0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSxcbiAgICAgIHNldFJlc29sdXRpb246IHRoaXMuc2V0UmVzb2x1dGlvbi5iaW5kKHRoaXMpLFxuICAgICAgdXBkYXRlOiAoZHQpID0+IHt9LC8vIHVzZXIgZGVmaW5lZCB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGh1c2g6IHRoaXMuaHVzaC5iaW5kKHRoaXMpLFxuICAgICAgdGljazogdGhpcy50aWNrLmJpbmQodGhpcylcbiAgICB9XG5cbiAgICBpZiAobWFrZUdsb2JhbCkge1xuICAgICAgd2luZG93LmxvYWRTY3JpcHQgPSB0aGlzLmxvYWRTY3JpcHRcbiAgICAgIHdpbmRvdy5nZXRDb2RlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhkZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLmdldCgnY29kZScpKSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUgPSAwXG4gICAgdGhpcy5fdGltZSA9IDAgLy8gZm9yIGludGVybmFsIHVzZSwgb25seSB0byB1c2UgZm9yIGRlY2lkaW5nIHdoZW4gdG8gcmVuZGVyIGZyYW1lc1xuXG4gICAgLy8gb25seSBhbGxvdyB2YWxpZCBwcmVjaXNpb24gb3B0aW9uc1xuICAgIGxldCBwcmVjaXNpb25PcHRpb25zID0gWydsb3dwJywnbWVkaXVtcCcsJ2hpZ2hwJ11cbiAgICBpZihwcmVjaXNpb24gJiYgcHJlY2lzaW9uT3B0aW9ucy5pbmNsdWRlcyhwcmVjaXNpb24udG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uLnRvTG93ZXJDYXNlKClcbiAgICAgIC8vXG4gICAgICAvLyBpZighcHJlY2lzaW9uVmFsaWQpe1xuICAgICAgLy8gICBjb25zb2xlLndhcm4oJ1toeWRyYS1zeW50aCB3YXJuaW5nXVxcbkNvbnN0cnVjdG9yIHdhcyBwcm92aWRlZCBhbiBpbnZhbGlkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiB2YWx1ZSBvZiBcIicgKyBwcmVjaXNpb24gKyAnXCIuIFVzaW5nIGRlZmF1bHQgdmFsdWUgb2YgXCJtZWRpdW1wXCIgaW5zdGVhZC4nKVxuICAgICAgLy8gfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaXNJT1MgPVxuICAgICgvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIHx8XG4gICAgICAobmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpKSAmJlxuICAgICF3aW5kb3cuTVNTdHJlYW07XG4gICAgICB0aGlzLnByZWNpc2lvbiA9IGlzSU9TID8gJ2hpZ2hwJyA6ICdtZWRpdW1wJ1xuICAgIH1cblxuXG5cbiAgICB0aGlzLmV4dGVuZFRyYW5zZm9ybXMgPSBleHRlbmRUcmFuc2Zvcm1zXG5cbiAgICAvLyBib29sZWFuIHRvIHN0b3JlIHdoZW4gdG8gc2F2ZSBzY3JlZW5zaG90XG4gICAgdGhpcy5zYXZlRnJhbWUgPSBmYWxzZVxuXG4gICAgLy8gaWYgc3RyZWFtIGNhcHR1cmUgaXMgZW5hYmxlZCwgdGhpcyBvYmplY3QgY29udGFpbnMgdGhlIGNhcHR1cmUgc3RyZWFtXG4gICAgdGhpcy5jYXB0dXJlU3RyZWFtID0gbnVsbFxuXG4gICAgdGhpcy5nZW5lcmF0b3IgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX2luaXRSZWdsKClcbiAgICB0aGlzLl9pbml0T3V0cHV0cyhudW1PdXRwdXRzKVxuICAgIHRoaXMuX2luaXRTb3VyY2VzKG51bVNvdXJjZXMpXG4gICAgdGhpcy5fZ2VuZXJhdGVHbHNsVHJhbnNmb3JtcygpXG5cbiAgICB0aGlzLnN5bnRoLnNjcmVlbmNhcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2F2ZUZyYW1lID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChlbmFibGVTdHJlYW1DYXB0dXJlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmNhcHR1cmVTdHJlYW0gPSB0aGlzLmNhbnZhcy5jYXB0dXJlU3RyZWFtKDI1KVxuICAgICAgICAvLyB0byBkbzogZW5hYmxlIGNhcHR1cmUgc3RyZWFtIG9mIHNwZWNpZmljIHNvdXJjZXMgYW5kIG91dHB1dHNcbiAgICAgICAgdGhpcy5zeW50aC52aWRSZWNvcmRlciA9IG5ldyBWaWRSZWNvcmRlcih0aGlzLmNhcHR1cmVTdHJlYW0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW2h5ZHJhLXN5bnRoIHdhcm5pbmddXFxubmV3IE1lZGlhU291cmNlKCkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgb24gaU9TLicpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkZXRlY3RBdWRpbykgdGhpcy5faW5pdEF1ZGlvKClcblxuICAgIGlmKGF1dG9Mb29wKSBsb29wKHRoaXMudGljay5iaW5kKHRoaXMpKS5zdGFydCgpXG5cbiAgICAvLyBmaW5hbCBhcmd1bWVudCBpcyBwcm9wZXJ0aWVzIHRoYXQgdGhlIHVzZXIgY2FuIHNldCwgYWxsIG90aGVycyBhcmUgdHJlYXRlZCBhcyByZWFkLW9ubHlcbiAgICB0aGlzLnNhbmRib3ggPSBuZXcgU2FuZGJveCh0aGlzLnN5bnRoLCBtYWtlR2xvYmFsLCBbJ3NwZWVkJywgJ3VwZGF0ZScsICdicG0nLCAnZnBzJ10pXG4gIH1cblxuICBldmFsKGNvZGUpIHtcbiAgICB0aGlzLnNhbmRib3guZXZhbChjb2RlKVxuICB9XG5cbiAgZ2V0U2NyZWVuSW1hZ2UoY2FsbGJhY2spIHtcbiAgICB0aGlzLmltYWdlQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuc2F2ZUZyYW1lID0gdHJ1ZVxuICB9XG5cbiAgaHVzaCgpIHtcbiAgICB0aGlzLnMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBzb3VyY2UuY2xlYXIoKVxuICAgIH0pXG4gICAgdGhpcy5vLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgdGhpcy5zeW50aC5zb2xpZCgwLCAwLCAwLCAwKS5vdXQob3V0cHV0KVxuICAgIH0pXG4gICAgdGhpcy5zeW50aC5yZW5kZXIodGhpcy5vWzBdKVxuICAgIC8vIHRoaXMuc3ludGgudXBkYXRlID0gKGR0KSA9PiB7fVxuICAgIHRoaXMuc2FuZGJveC5zZXQoJ3VwZGF0ZScsIChkdCkgPT4ge30pXG4gIH1cblxuICBsb2FkU2NyaXB0KHVybCA9IFwiXCIsIG9uY2UgPSB0cnVlKSB7XG4gICBjb25zdCBzZWxmID0gdGhpcyB8fCB3aW5kb3c7XG4gICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgIGlmIChvbmNlKSB7XG4gICAgICAgc2VsZi5sb2FkZWRTY3JpcHRzIHx8IChzZWxmLmxvYWRlZFNjcmlwdHMgPSB7fSk7XG4gICAgICAgaWYgKHNlbGYubG9hZGVkU2NyaXB0c1t1cmxdKSB7XG4gICAgICAgICByZXMoKTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgY29uc29sZS5sb2coYGxvYWRlZCBzY3JpcHQgJHt1cmx9YCk7XG4gICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgIHNlbGYubG9hZGVkU2NyaXB0c1t1cmxdID0gdHJ1ZTtcbiAgICAgICB9XG4gICAgICAgcmVzKCk7XG4gICAgIH07XG4gICAgIHNjcmlwdC5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgIGNvbnNvbGUubG9nKGBlcnJvciBsb2FkaW5nIHNjcmlwdCAke3VybH1gLCBcImxvZy1lcnJvclwiKTtcbiAgICAgICByZXMoKVxuICAgICB9O1xuICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICB9KTtcbiAgIHJldHVybiBwO1xuIH1cblxuICBzZXRSZXNvbHV0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgLy8gIGNvbnNvbGUubG9nKHdpZHRoLCBoZWlnaHQpXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aFxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvLyA/XG4gICAgdGhpcy5zYW5kYm94LnNldCgnd2lkdGgnLCB3aWR0aClcbiAgICB0aGlzLnNhbmRib3guc2V0KCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgdGhpcy5vLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgb3V0cHV0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH0pXG4gICAgdGhpcy5zLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgc291cmNlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH0pXG4gICAgdGhpcy5yZWdsLl9yZWZyZXNoKClcbiAgICAgY29uc29sZS5sb2codGhpcy5jYW52YXMud2lkdGgpXG4gIH1cblxuICBjYW52YXNUb0ltYWdlIChjYWxsYmFjaykge1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICBhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcblxuICAgIGxldCBkID0gbmV3IERhdGUoKVxuICAgIGEuZG93bmxvYWQgPSBgaHlkcmEtJHtkLmdldEZ1bGxZZWFyKCl9LSR7ZC5nZXRNb250aCgpICsgMX0tJHtkLmdldERhdGUoKX0tJHtkLmdldEhvdXJzKCl9LiR7ZC5nZXRNaW51dGVzKCl9LiR7ZC5nZXRTZWNvbmRzKCl9LnBuZ2BcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5jYW52YXMudG9CbG9iKCAoYmxvYikgPT4ge1xuICAgICAgICBpZihzZWxmLmltYWdlQ2FsbGJhY2spe1xuICAgICAgICAgIHNlbGYuaW1hZ2VDYWxsYmFjayhibG9iKVxuICAgICAgICAgIGRlbGV0ZSBzZWxmLmltYWdlQ2FsbGJhY2tcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgICAgY29uc29sZS5sb2coYS5ocmVmKVxuICAgICAgICAgIGEuY2xpY2soKVxuICAgICAgICB9XG4gICAgfSwgJ2ltYWdlL3BuZycpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoYS5ocmVmKTtcbiAgICB9LCAzMDApO1xuICB9XG5cbiAgX2luaXRBdWRpbyAoKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXNcbiAgICB0aGlzLnN5bnRoLmEgPSBuZXcgQXVkaW8oe1xuICAgICAgbnVtQmluczogNCxcbiAgICAgIHBhcmVudEVsOiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlXG4gICAgICAvLyBjaGFuZ2VMaXN0ZW5lcjogKHthdWRpb30pID0+IHtcbiAgICAgIC8vICAgdGhhdC5hID0gYXVkaW8uYmlucy5tYXAoKF8sIGluZGV4KSA9PlxuICAgICAgLy8gICAgIChzY2FsZSA9IDEsIG9mZnNldCA9IDApID0+ICgpID0+IChhdWRpby5mZnRbaW5kZXhdICogc2NhbGUgKyBvZmZzZXQpXG4gICAgICAvLyAgIClcbiAgICAgIC8vXG4gICAgICAvLyAgIGlmICh0aGF0Lm1ha2VHbG9iYWwpIHtcbiAgICAgIC8vICAgICB0aGF0LmEuZm9yRWFjaCgoYSwgaW5kZXgpID0+IHtcbiAgICAgIC8vICAgICAgIGNvbnN0IGFuYW1lID0gYGEke2luZGV4fWBcbiAgICAgIC8vICAgICAgIHdpbmRvd1thbmFtZV0gPSBhXG4gICAgICAvLyAgICAgfSlcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgIH0pXG4gIH1cblxuICAvLyBjcmVhdGUgbWFpbiBvdXRwdXQgY2FudmFzIGFuZCBhZGQgdG8gc2NyZWVuXG4gIF9pbml0Q2FudmFzIChjYW52YXMpIHtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xuICAgICAgdGhpcy53aWR0aCA9IGNhbnZhcy53aWR0aFxuICAgICAgdGhpcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aFxuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHRcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJ3BpeGVsYXRlZCdcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpXG4gICAgfVxuICB9XG5cbiAgX2luaXRSZWdsICgpIHtcbiAgICB0aGlzLnJlZ2wgPSByZWdsKHtcbiAgICAvLyAgcHJvZmlsZTogdHJ1ZSxcbiAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgb3B0aW9uYWxFeHRlbnNpb25zOiBbXG4gICAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0JyxcbiAgICAgICAgJ29lc190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyxcbiAgICAgICAgJ29lc190ZXh0dXJlX2Zsb2F0JyxcbiAgICAgICAgJ29lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcidcbiAgICAgXVxuICAgfSlcblxuICAgIC8vIFRoaXMgY2xlYXJzIHRoZSBjb2xvciBidWZmZXIgdG8gYmxhY2sgYW5kIHRoZSBkZXB0aCBidWZmZXIgdG8gMVxuICAgIHRoaXMucmVnbC5jbGVhcih7XG4gICAgICBjb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyQWxsID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgxO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDM7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzIgc3QgPSB2ZWMyKDEuMCAtIHV2LngsIHV2LnkpO1xuICAgICAgICBzdCo9IHZlYzIoMik7XG4gICAgICAgIHZlYzIgcSA9IGZsb29yKHN0KS54eSoodmVjMigyLjAsIDEuMCkpO1xuICAgICAgICBpbnQgcXVhZCA9IGludChxLngpICsgaW50KHEueSk7XG4gICAgICAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSk7XG4gICAgICAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSk7XG4gICAgICAgIHN0ID0gZnJhY3Qoc3QpO1xuICAgICAgICBpZihxdWFkPT0wKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgc3QpO1xuICAgICAgICB9IGVsc2UgaWYocXVhZD09MSl7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDEsIHN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkPT0yKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4Miwgc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgzLCBzdCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgdGV4MTogdGhpcy5yZWdsLnByb3AoJ3RleDEnKSxcbiAgICAgICAgdGV4MjogdGhpcy5yZWdsLnByb3AoJ3RleDInKSxcbiAgICAgICAgdGV4MzogdGhpcy5yZWdsLnByb3AoJ3RleDMnKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyRmJvID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDAsIHZlYzIoMS4wIC0gdXYueCwgdXYueSkpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZWdsLnByb3AoJ3Jlc29sdXRpb24nKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcbiAgfVxuXG4gIF9pbml0T3V0cHV0cyAobnVtT3V0cHV0cykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5vID0gKEFycmF5KG51bU91dHB1dHMpKS5maWxsKCkubWFwKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBvID0gbmV3IE91dHB1dChpbmRleCwgdGhpcylcbiAgICAgIHNlbGYuc3ludGhbJ28nK2luZGV4XSA9IG9cbiAgICAgIHJldHVybiBvXG4gICAgfSlcblxuICAgIC8vIHNldCBkZWZhdWx0IG91dHB1dFxuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vWzBdXG4gIH1cblxuICBfaW5pdFNvdXJjZXMgKG51bVNvdXJjZXMpIHtcbiAgICB0aGlzLnMgPSBbXVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspIHtcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKGkpXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU291cmNlIChpKSB7XG4gICAgbGV0IHMgPSBuZXcgU291cmNlKHtyZWdsOiB0aGlzLnJlZ2wsIHBiOiB0aGlzLnBiLCB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCwgbGFiZWw6IGBzJHtpfWB9KVxuICAgIHRoaXMuc3ludGhbJ3MnICsgdGhpcy5zLmxlbmd0aF0gPSBzXG4gICAgdGhpcy5zLnB1c2gocylcbiAgICByZXR1cm4gc1xuICB9XG5cbiAgX2dlbmVyYXRlR2xzbFRyYW5zZm9ybXMgKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gbmV3IEdlbmVyYXRvcih7XG4gICAgICBkZWZhdWx0T3V0cHV0OiB0aGlzLm9bMF0sXG4gICAgICBkZWZhdWx0VW5pZm9ybXM6IHRoaXMub1swXS51bmlmb3JtcyxcbiAgICAgIGV4dGVuZFRyYW5zZm9ybXM6IHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyxcbiAgICAgIGNoYW5nZUxpc3RlbmVyOiAoe3R5cGUsIG1ldGhvZCwgc3ludGh9KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBzZWxmLnN5bnRoW21ldGhvZF0gPSBzeW50aC5nZW5lcmF0b3JzW21ldGhvZF1cbiAgICAgICAgICAgIGlmKHNlbGYuc2FuZGJveCkgc2VsZi5zYW5kYm94LmFkZChtZXRob2QpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgLy8gd2hhdCB0byBkbyBoZXJlPyBkYW5nZXJvdXNseSBkZWxldGluZyB3aW5kb3cgbWV0aG9kc1xuICAgICAgICAgICAgLy9kZWxldGUgd2luZG93W21ldGhvZF1cbiAgICAgICAgICB9XG4gICAgICAvLyAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zeW50aC5zZXRGdW5jdGlvbiA9IHRoaXMuZ2VuZXJhdG9yLnNldEZ1bmN0aW9uLmJpbmQodGhpcy5nZW5lcmF0b3IpXG4gIH1cblxuICBfcmVuZGVyIChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dFxuICAgICAgdGhpcy5pc1JlbmRlcmluZ0FsbCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmdBbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3JlbmRlck91dCAoaSkge1xuICAgIHRoaXMub1tpXS50aWNrKHtcbiAgICAgIHRpbWU6IHRoaXMuc3ludGgudGltZSxcbiAgICAgIG1vdXNlOiB0aGlzLnN5bnRoLm1vdXNlLFxuICAgICAgYnBtOiB0aGlzLnN5bnRoLmJwbSxcbiAgICAgIHJlc29sdXRpb246IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XVxuICAgIH0pXG4gIH1cblxuICAvLyBkdCBpbiBtc1xuICB0aWNrIChkdCwgdW5pZm9ybXMpIHtcbiAgICB0aGlzLnNhbmRib3gudGljaygpXG4gICAgaWYodGhpcy5kZXRlY3RBdWRpbyA9PT0gdHJ1ZSkgdGhpcy5zeW50aC5hLnRpY2soKVxuICAvLyAgbGV0IHVwZGF0ZUludGVydmFsID0gMTAwMC90aGlzLnN5bnRoLmZwcyAvLyBtc1xuICAgIHRoaXMuc2FuZGJveC5zZXQoJ3RpbWUnLCB0aGlzLnN5bnRoLnRpbWUgKz0gZHQgKiAwLjAwMSAqIHRoaXMuc3ludGguc3BlZWQpXG4gICAgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlICs9IGR0XG4gICAgaWYoIXRoaXMuc3ludGguZnBzIHx8IHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA+PSAxMDAwL3RoaXMuc3ludGguZnBzKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKDEwMDAvdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlKVxuICAgICAgdGhpcy5zeW50aC5zdGF0cy5mcHMgPSBNYXRoLmNlaWwoMTAwMC90aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpXG4gICAgICBpZih0aGlzLnN5bnRoLnVwZGF0ZSkge1xuICAgICAgICB0cnkgeyB0aGlzLnN5bnRoLnVwZGF0ZSh0aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSkgfVxuICAgICAgfVxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnN5bnRoLnNwZWVkLCB0aGlzLnN5bnRoLnRpbWUpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNbaV0udGljayh0aGlzLnN5bnRoLnRpbWUpXG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuby5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW5kZXJPdXQoaSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0FsbCkge1xuICAgICAgICB0aGlzLnJlbmRlckFsbCh7XG4gICAgICAgICAgdGV4MDogdGhpcy5vWzBdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICB0ZXgxOiB0aGlzLm9bMV0uZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHRleDI6IHRoaXMub1syXS5nZXRDdXJyZW50KCksXG4gICAgICAgICAgdGV4MzogdGhpcy5vWzNdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJGYm8oe1xuICAgICAgICAgIHRleDA6IHRoaXMub3V0cHV0LmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA9IDBcbiAgICB9XG4gICAgaWYodGhpcy5zYXZlRnJhbWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2FudmFzVG9JbWFnZSgpXG4gICAgICB0aGlzLnNhdmVGcmFtZSA9IGZhbHNlXG4gICAgfVxuICAvLyAgdGhpcy5yZWdsLnBvbGwoKVxuICB9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBIeWRyYVJlbmRlcmVyXG4iLCJpbXBvcnQgU3ludGggZnJvbSAnLi9oeWRyYS1zeW50aC5qcydcbi8vaW1wb3J0IFNoYWRlckdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc2hhZGVyLWdlbmVyYXRvci5qcycpXG4vLyBhbGVydCgnaGknKVxuLy8gZXhwb3J0IGRlZmF1bHQgU3ludGhcbm1vZHVsZS5leHBvcnRzID0gU3ludGhcbiIsIi8vIFdJUCB1dGlscyBmb3Igd29ya2luZyB3aXRoIGFycmF5c1xuLy8gUG9zc2libHkgc2hvdWxkIGJlIGludGVncmF0ZWQgd2l0aCBsZm8gZXh0ZW5zaW9uLCBldGMuXG4vLyB0byBkbzogdHJhbnNmb3JtIHRpbWUgcmF0aGVyIHRoYW4gYXJyYXkgdmFsdWVzLCBzaW1pbGFyIHRvIHdvcmtpbmcgd2l0aCBjb29yZGluYXRlcyBpbiBoeWRyYVxuXG5pbXBvcnQgZWFzaW5nIGZyb20gJy4vZWFzaW5nLWZ1bmN0aW9ucy5qcydcblxudmFyIG1hcCA9IChudW0sIGluX21pbiwgaW5fbWF4LCBvdXRfbWluLCBvdXRfbWF4KSA9PiB7XG4gIHJldHVybiAobnVtIC0gaW5fbWluKSAqIChvdXRfbWF4IC0gb3V0X21pbikgLyAoaW5fbWF4IC0gaW5fbWluKSArIG91dF9taW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogKCkgPT4ge1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZhc3QgPSBmdW5jdGlvbihzcGVlZCA9IDEpIHtcbiAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnNtb290aCA9IGZ1bmN0aW9uKHNtb290aCA9IDEpIHtcbiAgICAgIHRoaXMuX3Ntb290aCA9IHNtb290aFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGVhc2UgPSAnbGluZWFyJykge1xuICAgICAgaWYgKHR5cGVvZiBlYXNlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzZVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWFzaW5nW2Vhc2VdKXtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzaW5nW2Vhc2VdXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbihvZmZzZXQgPSAwLjUpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldCUxLjBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLmJvdW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgdGhpcy5tb2RpZmllcnMuYm91bmNlID0gdHJ1ZVxuICAgIC8vICAgcmV0dXJuIHRoaXNcbiAgICAvLyB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24obG93ID0gMCwgaGlnaCA9MSkge1xuICAgICAgbGV0IGxvd2VzdCA9IE1hdGgubWluKC4uLnRoaXMpXG4gICAgICBsZXQgaGlnaGVzdCA9ICBNYXRoLm1heCguLi50aGlzKVxuICAgICAgdmFyIG5ld0FyciA9IHRoaXMubWFwKChudW0pID0+IG1hcChudW0sIGxvd2VzdCwgaGlnaGVzdCwgbG93LCBoaWdoKSlcbiAgICAgIG5ld0Fyci5fc3BlZWQgPSB0aGlzLl9zcGVlZFxuICAgICAgbmV3QXJyLl9zbW9vdGggPSB0aGlzLl9zbW9vdGhcbiAgICAgIG5ld0Fyci5fZWFzZSA9IHRoaXMuX2Vhc2VcbiAgICAgIHJldHVybiBuZXdBcnJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmFsdWU6IChhcnIgPSBbXSkgPT4gKHt0aW1lLCBicG19KSA9PntcbiAgICBsZXQgc3BlZWQgPSBhcnIuX3NwZWVkID8gYXJyLl9zcGVlZCA6IDFcbiAgICBsZXQgc21vb3RoID0gYXJyLl9zbW9vdGggPyBhcnIuX3Ntb290aCA6IDBcbiAgICBsZXQgaW5kZXggPSB0aW1lICogc3BlZWQgKiAoYnBtIC8gNjApICsgKGFyci5fb2Zmc2V0IHx8IDApXG5cbiAgICBpZiAoc21vb3RoIT09MCkge1xuICAgICAgbGV0IGVhc2UgPSBhcnIuX2Vhc2UgPyBhcnIuX2Vhc2UgOiBlYXNpbmdbJ2xpbmVhciddXG4gICAgICBsZXQgX2luZGV4ID0gaW5kZXggLSAoc21vb3RoIC8gMilcbiAgICAgIGxldCBjdXJyVmFsdWUgPSBhcnJbTWF0aC5mbG9vcihfaW5kZXggJSAoYXJyLmxlbmd0aCkpXVxuICAgICAgbGV0IG5leHRWYWx1ZSA9IGFycltNYXRoLmZsb29yKChfaW5kZXggKyAxKSAlIChhcnIubGVuZ3RoKSldXG4gICAgICBsZXQgdCA9IE1hdGgubWluKChfaW5kZXglMSkvc21vb3RoLDEpXG4gICAgICByZXR1cm4gZWFzZSh0KSAqIChuZXh0VmFsdWUgLSBjdXJyVmFsdWUpICsgY3VyclZhbHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGFycltNYXRoLmZsb29yKGluZGV4ICUgKGFyci5sZW5ndGgpKV1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBNZXlkYSBmcm9tICdtZXlkYSdcblxuY2xhc3MgQXVkaW8ge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIG51bUJpbnMgPSA0LFxuICAgIGN1dG9mZiA9IDIsXG4gICAgc21vb3RoID0gMC40LFxuICAgIG1heCA9IDE1LFxuICAgIHNjYWxlID0gMTAsXG4gICAgaXNEcmF3aW5nID0gZmFsc2UsXG4gICAgcGFyZW50RWwgPSBkb2N1bWVudC5ib2R5XG4gIH0pIHtcbiAgICB0aGlzLnZvbCA9IDBcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMuY3V0b2ZmID0gY3V0b2ZmXG4gICAgdGhpcy5zbW9vdGggPSBzbW9vdGhcbiAgICB0aGlzLnNldEJpbnMobnVtQmlucylcblxuICAgIC8vIGJlYXQgZGV0ZWN0aW9uIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS90aGVyZXdhc2FndXkvcDUtbXVzaWMtdml6L2Jsb2IvZ2gtcGFnZXMvZGVtb3MvMDFkX2JlYXRfZGV0ZWN0X2FtcGxpdHVkZS9za2V0Y2guanNcbiAgICB0aGlzLmJlYXQgPSB7XG4gICAgICBob2xkRnJhbWVzOiAyMCxcbiAgICAgIHRocmVzaG9sZDogNDAsXG4gICAgICBfY3V0b2ZmOiAwLCAvLyBhZGFwdGl2ZSBiYXNlZCBvbiBzb3VuZCBzdGF0ZVxuICAgICAgZGVjYXk6IDAuOTgsXG4gICAgICBfZnJhbWVzU2luY2VCZWF0OiAwIC8vIGtlZXBzIHRyYWNrIG9mIGZyYW1lc1xuICAgIH1cblxuICAgIHRoaXMub25CZWF0ID0gKCkgPT4ge1xuICAgIC8vICBjb25zb2xlLmxvZyhcImJlYXRcIilcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAxMDBcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSA4MFxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDBweFwiXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCI4MHB4XCJcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9ICcwcHgnXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gJzBweCdcbiAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcblxuICAgIHRoaXMuaXNEcmF3aW5nID0gaXNEcmF3aW5nXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlPVwiI0RGRkZGRlwiXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGU9XCIjMGZmXCJcbiAgICB0aGlzLmN0eC5saW5lV2lkdGg9MC41XG4gICAgaWYod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOiBmYWxzZSwgYXVkaW86IHRydWV9KVxuICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgLy8gIGNvbnNvbGUubG9nKCdnb3QgbWljIHN0cmVhbScsIHN0cmVhbSlcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICAgIC8vICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgICAgbGV0IGF1ZGlvX3N0cmVhbSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG5cbiAgICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMubWV5ZGEgPSBNZXlkYS5jcmVhdGVNZXlkYUFuYWx5emVyKHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBzb3VyY2U6IGF1ZGlvX3N0cmVhbSxcbiAgICAgICAgICBmZWF0dXJlRXh0cmFjdG9yczogW1xuICAgICAgICAgICAgJ2xvdWRuZXNzJyxcbiAgICAgICAgICAgIC8vICAncGVyY2VwdHVhbFNwcmVhZCcsXG4gICAgICAgICAgICAvLyAgJ3BlcmNlcHR1YWxTaGFycG5lc3MnLFxuICAgICAgICAgICAgLy8gICdzcGVjdHJhbENlbnRyb2lkJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coJ0VSUk9SJywgZXJyKSlcbiAgICB9XG4gIH1cblxuICBkZXRlY3RCZWF0IChsZXZlbCkge1xuICAgIC8vY29uc29sZS5sb2cobGV2ZWwsICAgdGhpcy5iZWF0Ll9jdXRvZmYpXG4gICAgaWYgKGxldmVsID4gdGhpcy5iZWF0Ll9jdXRvZmYgJiYgbGV2ZWwgPiB0aGlzLmJlYXQudGhyZXNob2xkKSB7XG4gICAgICB0aGlzLm9uQmVhdCgpXG4gICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IGxldmVsICoxLjJcbiAgICAgIHRoaXMuYmVhdC5fZnJhbWVzU2luY2VCZWF0ID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5iZWF0Ll9mcmFtZXNTaW5jZUJlYXQgPD0gdGhpcy5iZWF0LmhvbGRGcmFtZXMpe1xuICAgICAgICB0aGlzLmJlYXQuX2ZyYW1lc1NpbmNlQmVhdCArKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmVhdC5fY3V0b2ZmICo9IHRoaXMuYmVhdC5kZWNheVxuICAgICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IE1hdGgubWF4KCAgdGhpcy5iZWF0Ll9jdXRvZmYsIHRoaXMuYmVhdC50aHJlc2hvbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICBpZih0aGlzLm1leWRhKXtcbiAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5tZXlkYS5nZXQoKVxuICAgICBpZihmZWF0dXJlcyAmJiBmZWF0dXJlcyAhPT0gbnVsbCl7XG4gICAgICAgdGhpcy52b2wgPSBmZWF0dXJlcy5sb3VkbmVzcy50b3RhbFxuICAgICAgIHRoaXMuZGV0ZWN0QmVhdCh0aGlzLnZvbClcbiAgICAgICAvLyByZWR1Y2UgbG91ZG5lc3MgYXJyYXkgdG8gbnVtYmVyIG9mIGJpbnNcbiAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlO1xuICAgICAgIGxldCBzcGFjaW5nID0gTWF0aC5mbG9vcihmZWF0dXJlcy5sb3VkbmVzcy5zcGVjaWZpYy5sZW5ndGgvdGhpcy5iaW5zLmxlbmd0aClcbiAgICAgICB0aGlzLnByZXZCaW5zID0gdGhpcy5iaW5zLnNsaWNlKDApXG4gICAgICAgdGhpcy5iaW5zID0gdGhpcy5iaW5zLm1hcCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmxvdWRuZXNzLnNwZWNpZmljLnNsaWNlKGluZGV4ICogc3BhY2luZywgKGluZGV4ICsgMSkqc3BhY2luZykucmVkdWNlKHJlZHVjZXIpXG4gICAgICAgfSkubWFwKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAvLyBtYXAgdG8gc3BlY2lmaWVkIHJhbmdlXG5cbiAgICAgICAgLy8gcmV0dXJuIChiaW4gKiAoMS4wIC0gdGhpcy5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNtb290aClcbiAgICAgICAgICByZXR1cm4gKGJpbiAqICgxLjAgLSB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpXG4gICAgICAgfSlcbiAgICAgICAvLyB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICAgIC8vIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgLy8gdGhpcy5jdHgubW92ZVRvKGluZGV4KnNwYWNpbmcsIHkpXG4gICAgICAgLy8gdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICAgIC8vIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgICAgLy9cbiAgICAgICAvLyB2YXIgeU1heCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKih0aGlzLnNldHRpbmdzW2luZGV4XS5zY2FsZSArIHRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZilcbiAgICAgICB0aGlzLmZmdCA9IHRoaXMuYmlucy5tYXAoKGJpbiwgaW5kZXgpID0+IChcbiAgICAgICAgLy8gTWF0aC5tYXgoMCwgKGJpbiAtIHRoaXMuY3V0b2ZmKSAvICh0aGlzLm1heCAtIHRoaXMuY3V0b2ZmKSlcbiAgICAgICAgIE1hdGgubWF4KDAsIChiaW4gLSB0aGlzLnNldHRpbmdzW2luZGV4XS5jdXRvZmYpL3RoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlKVxuICAgICAgICkpXG4gICAgICAgaWYodGhpcy5pc0RyYXdpbmcpIHRoaXMuZHJhdygpXG4gICAgIH1cbiAgIH1cbiAgfVxuXG4gIHNldEN1dG9mZiAoY3V0b2ZmKSB7XG4gICAgdGhpcy5jdXRvZmYgPSBjdXRvZmZcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5jdXRvZmYgPSBjdXRvZmZcbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG4gIH1cblxuICBzZXRTbW9vdGggKHNtb290aCkge1xuICAgIHRoaXMuc21vb3RoID0gc21vb3RoXG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MubWFwKChlbCkgPT4ge1xuICAgICAgZWwuc21vb3RoID0gc21vb3RoXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0QmlucyAobnVtQmlucykge1xuICAgIHRoaXMuYmlucyA9IEFycmF5KG51bUJpbnMpLmZpbGwoMClcbiAgICB0aGlzLnByZXZCaW5zID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuZmZ0ID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuc2V0dGluZ3MgPSBBcnJheShudW1CaW5zKS5maWxsKDApLm1hcCgoKSA9PiAoe1xuICAgICAgY3V0b2ZmOiB0aGlzLmN1dG9mZixcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgc21vb3RoOiB0aGlzLnNtb290aFxuICAgIH0pKVxuICAgIC8vIHRvIGRvOiB3aGF0IHRvIGRvIGluIG5vbi1nbG9iYWwgbW9kZT9cbiAgICB0aGlzLmJpbnMuZm9yRWFjaCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgd2luZG93WydhJyArIGluZGV4XSA9IChzY2FsZSA9IDEsIG9mZnNldCA9IDApID0+ICgpID0+IChhLmZmdFtpbmRleF0gKiBzY2FsZSArIG9mZnNldClcbiAgICB9KVxuICAvLyAgY29uc29sZS5sb2codGhpcy5zZXR0aW5ncylcbiAgfVxuXG4gIHNldFNjYWxlKHNjYWxlKXtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5zY2FsZSA9IHNjYWxlXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0TWF4KG1heCkge1xuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgY29uc29sZS5sb2coJ3NldCBtYXggaXMgZGVwcmVjYXRlZCcpXG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IHRydWVcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gIH1cblxuICBkcmF3ICgpIHtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB2YXIgc3BhY2luZyA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5iaW5zLmxlbmd0aFxuICAgIHZhciBzY2FsZSA9IHRoaXMuY2FudmFzLmhlaWdodCAvICh0aGlzLm1heCAqIDIpXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLmJpbnMpXG4gICAgdGhpcy5iaW5zLmZvckVhY2goKGJpbiwgaW5kZXgpID0+IHtcblxuICAgICAgdmFyIGhlaWdodCA9IGJpbiAqIHNjYWxlXG5cbiAgICAgdGhpcy5jdHguZmlsbFJlY3QoaW5kZXggKiBzcGFjaW5nLCB0aGlzLmNhbnZhcy5oZWlnaHQgLSBoZWlnaHQsIHNwYWNpbmcsIGhlaWdodClcblxuICAvLyAgIGNvbnNvbGUubG9nKHRoaXMuc2V0dGluZ3NbaW5kZXhdKVxuICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeSlcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuXG4gICAgIHZhciB5TWF4ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqKHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlICsgdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmKVxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeU1heClcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5TWF4KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuICAgIH0pXG5cblxuICAgIC8qdmFyIHkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLmN1dG9mZlxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHkpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgdmFyIHlNYXggPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLm1heFxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHlNYXgpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5TWF4KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpKi9cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1xuIiwiLy8gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCooMi10KSB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyAyKnQqdCA6IC0xKyg0LTIqdCkqdCB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKC0tdCkqdCp0KzEgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDQqdCp0KnQgOiAodC0xKSooMip0LTIpKigyKnQtMikrMSB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxLSgtLXQpKnQqdCp0IH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyA4KnQqdCp0KnQgOiAxLTgqKC0tdCkqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQqdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdCB9LFxuICAvLyBzaW4gc2hhcGVcbiAgc2luOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKDEgKyBNYXRoLnNpbihNYXRoLlBJKnQtTWF0aC5QSS8yKSkvMiB9XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1ldmVudFxuXG5jb25zdCBtb3VzZSA9IHt9XG5cbmZ1bmN0aW9uIG1vdXNlQnV0dG9ucyhldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYuYnV0dG9uc1xuICAgIH0gZWxzZSBpZignd2hpY2gnIGluIGV2KSB7XG4gICAgICB2YXIgYiA9IGV2LndoaWNoXG4gICAgICBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiA0XG4gICAgICB9IGVsc2UgaWYoYiA9PT0gMykge1xuICAgICAgICByZXR1cm4gMlxuICAgICAgfSBlbHNlIGlmKGIgPiAwKSB7XG4gICAgICAgIHJldHVybiAxPDwoYi0xKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZignYnV0dG9uJyBpbiBldikge1xuICAgICAgdmFyIGIgPSBldi5idXR0b25cbiAgICAgIGlmKGIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDRcbiAgICAgIH0gZWxzZSBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgICB9IGVsc2UgaWYoYiA+PSAwKSB7XG4gICAgICAgIHJldHVybiAxPDxiXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS5idXR0b25zID0gbW91c2VCdXR0b25zXG5cbmZ1bmN0aW9uIG1vdXNlRWxlbWVudChldikge1xuICByZXR1cm4gZXYudGFyZ2V0IHx8IGV2LnNyY0VsZW1lbnQgfHwgd2luZG93XG59XG5tb3VzZS5lbGVtZW50ID0gbW91c2VFbGVtZW50XG5cbmZ1bmN0aW9uIG1vdXNlUmVsYXRpdmVYKGV2KSB7XG4gIGlmKHR5cGVvZiBldiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZigncGFnZVgnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYucGFnZVhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbm1vdXNlLnggPSBtb3VzZVJlbGF0aXZlWFxuXG5mdW5jdGlvbiBtb3VzZVJlbGF0aXZlWShldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ3BhZ2VZJyBpbiBldikge1xuICAgICAgcmV0dXJuIGV2LnBhZ2VZXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS55ID0gbW91c2VSZWxhdGl2ZVlcblxuZXhwb3J0IGRlZmF1bHQgbW91c2UiLCIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1jaGFuZ2VcblxuZXhwb3J0IGRlZmF1bHQgbW91c2VMaXN0ZW5cblxuaW1wb3J0IG1vdXNlIGZyb20gJy4vbW91c2UtZXZlbnQuanMnXG5cbmZ1bmN0aW9uIG1vdXNlTGlzdGVuIChlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBlbGVtZW50XG4gICAgZWxlbWVudCA9IHdpbmRvd1xuICB9XG5cbiAgdmFyIGJ1dHRvblN0YXRlID0gMFxuICB2YXIgeCA9IDBcbiAgdmFyIHkgPSAwXG4gIHZhciBtb2RzID0ge1xuICAgIHNoaWZ0OiBmYWxzZSxcbiAgICBhbHQ6IGZhbHNlLFxuICAgIGNvbnRyb2w6IGZhbHNlLFxuICAgIG1ldGE6IGZhbHNlXG4gIH1cbiAgdmFyIGF0dGFjaGVkID0gZmFsc2VcblxuICBmdW5jdGlvbiB1cGRhdGVNb2RzIChldikge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2VcbiAgICBpZiAoJ2FsdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LmFsdEtleSAhPT0gbW9kcy5hbHRcbiAgICAgIG1vZHMuYWx0ID0gISFldi5hbHRLZXlcbiAgICB9XG4gICAgaWYgKCdzaGlmdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LnNoaWZ0S2V5ICE9PSBtb2RzLnNoaWZ0XG4gICAgICBtb2RzLnNoaWZ0ID0gISFldi5zaGlmdEtleVxuICAgIH1cbiAgICBpZiAoJ2N0cmxLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5jdHJsS2V5ICE9PSBtb2RzLmNvbnRyb2xcbiAgICAgIG1vZHMuY29udHJvbCA9ICEhZXYuY3RybEtleVxuICAgIH1cbiAgICBpZiAoJ21ldGFLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5tZXRhS2V5ICE9PSBtb2RzLm1ldGFcbiAgICAgIG1vZHMubWV0YSA9ICEhZXYubWV0YUtleVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZFxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG5leHRCdXR0b25zLCBldikge1xuICAgIHZhciBuZXh0WCA9IG1vdXNlLngoZXYpXG4gICAgdmFyIG5leHRZID0gbW91c2UueShldilcbiAgICBpZiAoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICBuZXh0QnV0dG9ucyA9IGV2LmJ1dHRvbnMgfCAwXG4gICAgfVxuICAgIGlmIChuZXh0QnV0dG9ucyAhPT0gYnV0dG9uU3RhdGUgfHxcbiAgICAgIG5leHRYICE9PSB4IHx8XG4gICAgICBuZXh0WSAhPT0geSB8fFxuICAgICAgdXBkYXRlTW9kcyhldikpIHtcbiAgICAgIGJ1dHRvblN0YXRlID0gbmV4dEJ1dHRvbnMgfCAwXG4gICAgICB4ID0gbmV4dFggfHwgMFxuICAgICAgeSA9IG5leHRZIHx8IDBcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1dHRvblN0YXRlLCB4LCB5LCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGUgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoMCwgZXYpXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCbHVyICgpIHtcbiAgICBpZiAoYnV0dG9uU3RhdGUgfHxcbiAgICAgIHggfHxcbiAgICAgIHkgfHxcbiAgICAgIG1vZHMuc2hpZnQgfHxcbiAgICAgIG1vZHMuYWx0IHx8XG4gICAgICBtb2RzLm1ldGEgfHxcbiAgICAgIG1vZHMuY29udHJvbCkge1xuICAgICAgeCA9IHkgPSAwXG4gICAgICBidXR0b25TdGF0ZSA9IDBcbiAgICAgIG1vZHMuc2hpZnQgPSBtb2RzLmFsdCA9IG1vZHMuY29udHJvbCA9IG1vZHMubWV0YSA9IGZhbHNlXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygwLCAwLCAwLCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vZHMgKGV2KSB7XG4gICAgaWYgKHVwZGF0ZU1vZHMoZXYpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidXR0b25TdGF0ZSwgeCwgeSwgbW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUgKGV2KSB7XG4gICAgaWYgKG1vdXNlLmJ1dHRvbnMoZXYpID09PSAwKSB7XG4gICAgICBoYW5kbGVFdmVudCgwLCBldilcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUsIGV2KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93biAoZXYpIHtcbiAgICBoYW5kbGVFdmVudChidXR0b25TdGF0ZSB8IG1vdXNlLmJ1dHRvbnMoZXYpLCBldilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUgJiB+bW91c2UuYnV0dG9ucyhldiksIGV2KVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXJzICgpIHtcbiAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IHRydWVcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgY2xlYXJTdGF0ZSlcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBoYW5kbGVNb2RzKVxuXG4gICAgaWYgKGVsZW1lbnQgIT09IHdpbmRvdykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hMaXN0ZW5lcnMgKCkge1xuICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IGZhbHNlXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSlcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcClcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGNsZWFyU3RhdGUpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGNsZWFyU3RhdGUpXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZU1vZHMpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcblxuICAgIGlmIChlbGVtZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cilcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZU1vZHMpXG4gICAgfVxuICB9XG5cbiAgLy8gQXR0YWNoIGxpc3RlbmVyc1xuICBhdHRhY2hMaXN0ZW5lcnMoKVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzdWx0LCB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdHRhY2hlZCB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGF0dGFjaExpc3RlbmVycygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWNoTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIGJ1dHRvbnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnV0dG9uU3RhdGUgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geCB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB5IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBtb2RzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHMgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiLy8gYXR0ZW1wdCBjdXN0b20gZXZhbHVhdGlvbiBzYW5kYm94IGZvciBoeWRyYSBmdW5jdGlvbnNcbi8vIGZvciBub3csIGp1c3QgYXZvaWRzIHBvbGx1dGluZyB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuLy8gc2hvdWxkIHByb2JhYmx5IGJlIHJlcGxhY2VkIHdpdGggYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWVcblxuZXhwb3J0IGRlZmF1bHQgKHBhcmVudCkgPT4ge1xuICB2YXIgaW5pdGlhbENvZGUgPSBgYFxuXG4gIHZhciBzYW5kYm94ID0gY3JlYXRlU2FuZGJveChpbml0aWFsQ29kZSlcblxuICB2YXIgYWRkVG9Db250ZXh0ID0gKG5hbWUsIG9iamVjdCkgPT4ge1xuICAgIGluaXRpYWxDb2RlICs9IGBcbiAgICAgIHZhciAke25hbWV9ID0gJHtvYmplY3R9XG4gICAgYFxuICAgIHNhbmRib3ggPSBjcmVhdGVTYW5kYm94KGluaXRpYWxDb2RlKVxuICB9XG5cblxuICByZXR1cm4ge1xuICAgIGFkZFRvQ29udGV4dDogYWRkVG9Db250ZXh0LFxuICAgIGV2YWw6IChjb2RlKSA9PiBzYW5kYm94LmV2YWwoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNhbmRib3ggKGluaXRpYWwpIHtcbiAgICBnbG9iYWxUaGlzLmV2YWwoaW5pdGlhbClcbiAgICAvLyBvcHRpb25hbCBwYXJhbXNcbiAgICB2YXIgbG9jYWxFdmFsID0gZnVuY3Rpb24gKGNvZGUpICB7XG4gICAgICBnbG9iYWxUaGlzLmV2YWwoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBUEkvZGF0YSBmb3IgZW5kLXVzZXJcbiAgICByZXR1cm4ge1xuICAgICAgZXZhbDogbG9jYWxFdmFsXG4gICAgfVxuICB9XG59XG4iLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyAgYXN5bmMgZnVuY3Rpb24gc3RhcnRDYXB0dXJlKGRpc3BsYXlNZWRpYU9wdGlvbnMpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShvcHRpb25zKS50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtXG4gICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpXG4gICAgICAgIHJlc29sdmUoe3ZpZGVvOiB2aWRlb30pXG4gICAgICB9KVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHJlamVjdChlcnIpKVxuICB9KVxufVxuIiwiY2xhc3MgVmlkZW9SZWNvcmRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKVxuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG5cbiAgICAvLyB0ZXN0aW5nIHVzaW5nIGEgcmVjb3JkaW5nIGFzIGlucHV0XG4gICAgdGhpcy5vdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgdGhpcy5vdXRwdXQuYXV0b3BsYXkgPSB0cnVlXG4gICAgdGhpcy5vdXRwdXQubG9vcCA9IHRydWVcblxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIHRoaXMubWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdNZWRpYVNvdXJjZSBvcGVuZWQnKTtcbiAgICAgIHNlbGYuc291cmNlQnVmZmVyID0gc2VsZi5tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOFwiJyk7XG4gICAgICBjb25zb2xlLmxvZygnU291cmNlIGJ1ZmZlcjogJywgc291cmNlQnVmZmVyKTtcbiAgICB9KVxuICB9XG5cbiAgc3RhcnQoKSB7XG4gIC8vICBsZXQgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm0nfTtcblxuLy8gICBsZXQgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm07Y29kZWNzPWgyNjQnfTtcbiAgIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibTtjb2RlY3M9dnA5J307XG5cbiAgICB0aGlzLnJlY29yZGVkQmxvYnMgPSBbXVxuICAgIHRyeSB7XG4gICAgIHRoaXMubWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUwKSB7XG4gICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gY3JlYXRlIE1lZGlhUmVjb3JkZXIgd2l0aCBvcHRpb25zIE9iamVjdDogJywgZTApXG4gICAgIHRyeSB7XG4gICAgICAgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm0sY29kZWNzPXZwOSd9XG4gICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgIH0gY2F0Y2ggKGUxKSB7XG4gICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBjcmVhdGUgTWVkaWFSZWNvcmRlciB3aXRoIG9wdGlvbnMgT2JqZWN0OiAnLCBlMSlcbiAgICAgICB0cnkge1xuICAgICAgICAgb3B0aW9ucyA9ICd2aWRlby92cDgnIC8vIENocm9tZSA0N1xuICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgIGFsZXJ0KCdNZWRpYVJlY29yZGVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblxcbicgK1xuICAgICAgICAgICAnVHJ5IEZpcmVmb3ggMjkgb3IgbGF0ZXIsIG9yIENocm9tZSA0NyBvciBsYXRlciwgJyArXG4gICAgICAgICAgICd3aXRoIEVuYWJsZSBleHBlcmltZW50YWwgV2ViIFBsYXRmb3JtIGZlYXR1cmVzIGVuYWJsZWQgZnJvbSBjaHJvbWU6Ly9mbGFncy4nKVxuICAgICAgICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIHdoaWxlIGNyZWF0aW5nIE1lZGlhUmVjb3JkZXI6JywgZTIpXG4gICAgICAgICByZXR1cm5cbiAgICAgICB9XG4gICAgIH1cbiAgIH1cbiAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIE1lZGlhUmVjb3JkZXInLCB0aGlzLm1lZGlhUmVjb3JkZXIsICd3aXRoIG9wdGlvbnMnLCBvcHRpb25zKTtcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5vbnN0b3AgPSB0aGlzLl9oYW5kbGVTdG9wLmJpbmQodGhpcylcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSB0aGlzLl9oYW5kbGVEYXRhQXZhaWxhYmxlLmJpbmQodGhpcylcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5zdGFydCgxMDApIC8vIGNvbGxlY3QgMTAwbXMgb2YgZGF0YVxuICAgY29uc29sZS5sb2coJ01lZGlhUmVjb3JkZXIgc3RhcnRlZCcsIHRoaXMubWVkaWFSZWNvcmRlcilcbiB9XG5cbiAgXG4gICBzdG9wKCl7XG4gICAgIHRoaXMubWVkaWFSZWNvcmRlci5zdG9wKClcbiAgIH1cblxuIF9oYW5kbGVTdG9wKCkge1xuICAgLy9jb25zdCBzdXBlckJ1ZmZlciA9IG5ldyBCbG9iKHJlY29yZGVkQmxvYnMsIHt0eXBlOiAndmlkZW8vd2VibSd9KVxuICAgLy8gY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkZWRCbG9icywge3R5cGU6ICd2aWRlby93ZWJtO2NvZGVjcz1oMjY0J30pXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLnJlY29yZGVkQmxvYnMsIHt0eXBlOiB0aGlzLm1lZGlhUmVjb3JkZXIubWltZVR5cGV9KVxuICAgY29uc3QgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgIHRoaXMub3V0cHV0LnNyYyA9IHVybFxuXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGEuaHJlZiA9IHVybFxuICAgIGxldCBkID0gbmV3IERhdGUoKVxuICAgIGEuZG93bmxvYWQgPSBgaHlkcmEtJHtkLmdldEZ1bGxZZWFyKCl9LSR7ZC5nZXRNb250aCgpICsgMX0tJHtkLmdldERhdGUoKX0tJHtkLmdldEhvdXJzKCl9LiR7ZC5nZXRNaW51dGVzKCl9LiR7ZC5nZXRTZWNvbmRzKCl9LndlYm1gXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKVxuICAgIGEuY2xpY2soKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgfSwgMzAwKTtcbiAgfVxuXG4gIF9oYW5kbGVEYXRhQXZhaWxhYmxlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5zaXplID4gMCkge1xuICAgICAgdGhpcy5yZWNvcmRlZEJsb2JzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvUmVjb3JkZXJcbiIsIi8vY29uc3QgZW51bWVyYXRlRGV2aWNlcyA9IHJlcXVpcmUoJ2VudW1lcmF0ZS1kZXZpY2VzJylcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKVxuICAgIC50aGVuKGRldmljZXMgPT4gZGV2aWNlcy5maWx0ZXIoZGV2aWNlcyA9PiBkZXZpY2VzLmtpbmQgPT09ICd2aWRlb2lucHV0JykpXG4gICAgLnRoZW4oY2FtZXJhcyA9PiB7XG4gICAgICBsZXQgY29uc3RyYWludHMgPSB7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IHRydWV9XG4gICAgICBpZiAoY2FtZXJhc1tkZXZpY2VJZF0pIHtcbiAgICAgICAgY29uc3RyYWludHNbJ3ZpZGVvJ10gPSB7XG4gICAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGNhbWVyYXNbZGV2aWNlSWRdLmRldmljZUlkIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vICBjb25zb2xlLmxvZyhjYW1lcmFzKVxuICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICB9KVxuICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAnJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAnJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJylcbiAgICAgIC8vICB2aWRlby5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pXG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgIHZpZGVvLnBsYXkoKS50aGVuKCgpID0+IHJlc29sdmUoe3ZpZGVvOiB2aWRlb30pKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKVxufVxuIiwiaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiZ2wtbWF0NFwiO1xuaW1wb3J0IEdsc2xTb3VyY2UgZnJvbSBcIi4vZ2xzbC1zb3VyY2UuanNcIjtcblxudmFyIE91dHB1dCA9IGZ1bmN0aW9uIChpbmRleCwgc3ludGgpIHtcbiAgdGhpcy5pZCA9IGluZGV4O1xuICB0aGlzLnN5bnRoID0gc3ludGg7XG4gIHRoaXMud2lkdGggPSBzeW50aC53aWR0aFxuICB0aGlzLmhlaWdodCA9IHN5bnRoLmhlaWdodFxuICB0aGlzLnJlZ2wgPSBzeW50aC5yZWdsXG4gIHRoaXMucHJlY2lzaW9uID0gc3ludGgucHJlY2lzaW9uXG4gIHRoaXMubGFiZWwgPSBgbyR7aW5kZXh9YFxuICB0aGlzLnBvc2l0aW9uQnVmZmVyID0gdGhpcy5yZWdsLmJ1ZmZlcihbXG4gICAgWy01LCAtMSwgMF0sXG4gICAgWy0xLCAtNSwgMF0sXG4gICAgWzMsIDMsIDBdXG4gIF0pXG4gIHRoaXMudXZCdWZmZXIgPSB0aGlzLnJlZ2wuYnVmZmVyKFtcbiAgICBbLTIsIDBdLFxuICAgIFswLCAtMl0sXG4gICAgWzIsIDJdXG4gIF0pXG5cbiAgdGhpcy5kcmF3ID0gW11cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5waW5nUG9uZ0luZGV4ID0gMFxuXG4gIHRoaXMuaW5pdEZib3MoKTtcblxuICB0aGlzLmNvcHlQYXNzID0gdGhpcy5yZWdsKHtcbiAgICBmcmFnOiBgXG4gICAgICBwcmVjaXNpb24gJHt0aGlzLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdXY7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdXYpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICB2ZXJ0OiBgXG4gICAgICBwcmVjaXNpb24gJHt0aGlzLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICBhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdXYgPSBwb3NpdGlvbjtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDIuMCAqIHBvc2l0aW9uIC0gMS4wLCAwLCAxKTtcbiAgICAgIH1gLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIFstMiwgMF0sXG4gICAgICAgIFswLCAtMl0sXG4gICAgICAgIFsyLCAyXVxuICAgICAgXVxuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHRleDA6IHRoaXMucmVnbC5wcm9wKCd0ZXgwJyksXG4gICAgfSxcbiAgICBjb3VudDogMyxcbiAgICBkZXB0aDogeyBlbmFibGU6IGZhbHNlIH0sXG4gICAgZnJhbWVidWZmZXI6ICgpID0+IHRoaXMuZ2V0VGV4dHVyZSgpLFxuICB9KVxufVxuXG5PdXRwdXQucHJvdG90eXBlLl9pbml0RmJvID0gZnVuY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7Y29sb3IsIC4uLmZiT3B0aW9uc30gPSBvcHRpb25zO1xuICBjb2xvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgIG1hZzogJ25lYXJlc3QnLFxuICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgZm9ybWF0OiAncmdiYSdcbiAgfSwgY29sb3IgfHwge30pO1xuICBmYk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBkZXB0aFN0ZW5jaWw6IGZhbHNlLFxuICB9LCBmYk9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5yZWdsLmZyYW1lYnVmZmVyKHtcbiAgICBjb2xvcjogdGhpcy5yZWdsLnRleHR1cmUoY29sb3IpLFxuICAgIC4uLmZiT3B0aW9ucyxcbiAgfSlcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5pbml0RmJvcyA9IGZ1bmN0aW9uKG9wdGlvbnMgPSB7fSkge1xuICAvLyBmb3IgZWFjaCBvdXRwdXQsIGNyZWF0ZSB0d28gZmJvcyBmb3IgcGluZ3BvbmdpbmdcbiAgdGhpcy5mYm9zID0gKEFycmF5KDIpKS5maWxsKCkubWFwKCgpID0+IHRoaXMuX2luaXRGYm8ob3B0aW9ucykpXG5cbiAgLy8gZm9yIGVhY2ggb3V0cHV0LCBjcmVhdGUgdHdvIHRlbXAgYnVmZmVyc1xuICB0aGlzLnRlbXAgPSAoQXJyYXkoMikpLmZpbGwoKS5tYXAoKCkgPT4gdGhpcy5faW5pdEZibyhvcHRpb25zKSlcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5pbml0RmxvYXQgPSBmdW5jdGlvbihvcHRpb25zID0ge30pIHtcbiAgbGV0IHtjb2xvciwgLi4uZmJPcHRpb25zfSA9IG9wdGlvbnM7XG4gIGNvbG9yID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdHlwZTogdGhpcy5yZWdsLmhhc0V4dGVuc2lvbignb2VzX3RleHR1cmVfZmxvYXQnKSA/ICdmbG9hdCcgOiB0aGlzLnJlZ2wuaGFzRXh0ZW5zaW9uKCdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0JyA/ICdoYWxmIGZsb2F0JyA6ICd1aW50OCcpLFxuICB9LCBjb2xvciB8fCB7fSk7XG4gIHRoaXMuaW5pdEZib3MoT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIC4uLmZiT3B0aW9ucyxcbiAgfSkpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgdGhpcy5mYm9zLmZvckVhY2goKGZibykgPT4ge1xuICAgIGZiby5yZXNpemUod2lkdGgsIGhlaWdodClcbiAgfSlcbiAgdGhpcy50ZW1wLmZvckVhY2goKHRtcCkgPT4ge1xuICAgIHRtcC5yZXNpemUod2lkdGgsIGhlaWdodClcbiAgfSlcbn1cblxuXG5PdXRwdXQucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZib3NbdGhpcy5waW5nUG9uZ0luZGV4XVxufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICB2YXIgaW5kZXggPSB0aGlzLnBpbmdQb25nSW5kZXggPyAwIDogMVxuICByZXR1cm4gdGhpcy5mYm9zW2luZGV4XVxufVxuXG5PdXRwdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbkJ1ZmZlcixcbiAgICB1djogdGhpcy51dkJ1ZmZlcixcbiAgfVxuICB0aGlzLnVuaWZvcm1zID0ge1xuICAgIHRpbWU6IHRoaXMucmVnbC5wcm9wKCd0aW1lJyksXG4gICAgcmVzb2x1dGlvbjogdGhpcy5yZWdsLnByb3AoJ3Jlc29sdXRpb24nKSxcbiAgfVxuXG4gIHRoaXMuaW5pdENhbWVyYSgpO1xuXG4gIHJldHVybiB0aGlzXG59XG5cbk91dHB1dC5wcm90b3R5cGUuaW5pdENhbWVyYSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jYW1lcmEgPSB0aGlzLnJlZ2woe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHByb2plY3Rpb246IG1hdDQuaWRlbnRpdHkoW10pLFxuICAgICAgdmlldzogbWF0NC5pZGVudGl0eShbXSksXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdmlldzogdGhpcy5yZWdsLmNvbnRleHQoJ3ZpZXcnKSxcbiAgICAgIHByb2plY3Rpb246IHRoaXMucmVnbC5jb250ZXh0KCdwcm9qZWN0aW9uJylcbiAgICB9XG4gIH0pO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmNhbWVyYSA9IGZ1bmN0aW9uKGV5ZSwgdGFyZ2V0ID0gWzAsMCwwXSwgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBmb3Z5OiBNYXRoLlBJIC8gNCxcbiAgICBuZWFyOiAwLjEsXG4gICAgZmFyOiAxMDAwLjAsXG4gIH0sIG9wdGlvbnMpO1xuICB0aGlzLmV5ZSA9IGV5ZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIGlmIChleWUgJiYgdGFyZ2V0KSB7XG4gICAgdGhpcy5fY2FtZXJhID0gdGhpcy5yZWdsKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgcHJvamVjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAncGVyc3BlY3RpdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0NC5wZXJzcGVjdGl2ZShbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvdnksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hc3BlY3QgfHwgKGNvbnRleHQudmlld3BvcnRXaWR0aCAvIGNvbnRleHQudmlld3BvcnRIZWlnaHQpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubmVhcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZhcilcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0NC5vcnRobyhbXSwgLTEuMCwgMS4wLCAtMS4wLCAxLjAsIG9wdGlvbnMubmVhciwgb3B0aW9ucy5mYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmlldzogZnVuY3Rpb24gKGNvbnRleHQsIHByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdDQubG9va0F0KFtdLFxuICAgICAgICAgICAgICBwcm9wcy5leWUsXG4gICAgICAgICAgICAgIHByb3BzLnRhcmdldCxcbiAgICAgICAgICAgICAgWzAsIDEsIDBdKVxuICAgICAgICB9LFxuICAgICAgICBleWU6IHRoaXMucmVnbC5wcm9wKCdleWUnKSxcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB2aWV3OiB0aGlzLnJlZ2wuY29udGV4dCgndmlldycpLFxuICAgICAgICBwcm9qZWN0aW9uOiB0aGlzLnJlZ2wuY29udGV4dCgncHJvamVjdGlvbicpLFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuaW5pdENhbWVyYSgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLnBlcnNwZWN0aXZlID0gZnVuY3Rpb24oZXllLCB0YXJnZXQgPSBbMCwwLDBdLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3R5cGU6ICdwZXJzcGVjdGl2ZSd9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuY2FtZXJhKGV5ZSwgdGFyZ2V0LCBvcHRpb25zKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5vcnRobyA9IGZ1bmN0aW9uKGV5ZSwgdGFyZ2V0ID0gWzAsMCwwXSwgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt0eXBlOiAnb3J0aG8nfSwgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLmNhbWVyYShleWUsIHRhcmdldCwgb3B0aW9ucyk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhc3Nlcykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvLyBlbnN1cmUgYm90aCBmYm8ncyBoYXZlIGxhc3QgZnJhbWVcbiAgdGhpcy5jb3B5UGFzcyh7XG4gICAgdGV4MDogdGhpcy5nZXRDdXJyZW50KCksXG4gIH0pO1xuICBzZWxmLmRyYXcgPSBbXTtcbiAgc2VsZi5wYXNzZXMgPSBwYXNzZXM7XG4gIGxldCBjbGVhciA9IGZhbHNlO1xuICBmb3IgKGxldCBpPTA7IGk8cGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhc3Nlc1tpXS5jbGVhcikge1xuICAgICAgY2xlYXIgPSBwYXNzZXNbaV0uY2xlYXI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNsZWFyKSB7XG4gICAgaWYgKGNsZWFyLmFtb3VudCA+PSAxKSB7XG4gICAgICBzZWxmLmRyYXcucHVzaCguLi50aGlzLmNsZWFyKGZhbHNlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5kcmF3LnB1c2godGhpcy5mYWRlKHtub3c6IGZhbHNlLCAuLi5jbGVhcn0pKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaT0wOyBpPHBhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXNzID0gcGFzc2VzW2ldXG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIGVsZW1lbnRzLCBwcmltaXRpdmV9ID0gdGhpcy5nZXRBdHRyaWJ1dGVzKHBhc3MucHJpbWl0aXZlLCBwYXNzLmdlb21ldHJ5KTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZ2V0VW5pZm9ybXMocGFzcy51bmlmb3Jtcyk7XG4gICAgY29uc3QgYmxlbmQgPSB0aGlzLmdldEJsZW5kKHBhc3MuYmxlbmRNb2RlKTtcbiAgICBjb25zdCBkcmF3ID0gc2VsZi5yZWdsKHtcbiAgICAgIGZyYWc6IHBhc3MuZnJhZyxcbiAgICAgIHZlcnQ6IHBhc3MudmVydCxcbiAgICAgIHZpZXdwb3J0OiB0eXBlb2YocGFzcy52aWV3cG9ydC54KSAhPT0gJ3VuZGVmaW5lZCcgPyB7XG4gICAgICAgIHg6IHBhc3Mudmlld3BvcnQueCAqIHRoaXMuZmJvc1swXS53aWR0aCxcbiAgICAgICAgeTogcGFzcy52aWV3cG9ydC55ICogdGhpcy5mYm9zWzBdLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHBhc3Mudmlld3BvcnQudyAqIHRoaXMuZmJvc1swXS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXNzLnZpZXdwb3J0LmggKiB0aGlzLmZib3NbMF0uaGVpZ2h0LFxuICAgICAgfSA6IHt9LFxuICAgICAgY3VsbDoge1xuICAgICAgICBlbmFibGU6ICEhcGFzcy5nZW9tZXRyeSxcbiAgICAgICAgZmFjZTogJ2JhY2snXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHByaW1pdGl2ZSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgY291bnQ6IHR5cGVvZihlbGVtZW50cykgPT09ICdudW1iZXInID8gZWxlbWVudHMgOiBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlbGVtZW50czogdHlwZW9mKGVsZW1lbnRzKSA9PT0gJ251bWJlcicgPyBudWxsIDogZWxlbWVudHMsXG4gICAgICBibGVuZCxcbiAgICAgIGxpbmVXaWR0aDogcGFzcy5saW5lV2lkdGgsXG4gICAgICBmcmFtZWJ1ZmZlcjogcGFzcy5mcmFtZWJ1ZmZlciB8fCAoKCkgPT4ge1xuICAgICAgICBzZWxmLnBpbmdQb25nSW5kZXggPSBzZWxmLnBpbmdQb25nSW5kZXggPyAwIDogMVxuICAgICAgICByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleF1cbiAgICAgIH0pLFxuICAgIH0pXG4gICAgc2VsZi5kcmF3LnB1c2goZHJhdylcbiAgfVxufVxuXG5PdXRwdXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24obm93ID0gdHJ1ZSkge1xuICBjb25zdCByZXN1bHQgPSBbdGhpcy5mYm9zWzBdLCB0aGlzLmZib3NbMV0sIHRoaXMudGVtcFswXSwgdGhpcy50ZW1wWzFdXS5tYXAoKGZibykgPT4ge1xuICAgIGNvbnN0IGNsZWFyID0gKCkgPT4gdGhpcy5yZWdsLmNsZWFyKHtcbiAgICAgIGNvbG9yOiBbMCwgMCwgMCwgMF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogZmJvLFxuICAgIH0pO1xuICAgIGlmIChub3cpIGNsZWFyKCk7XG4gICAgZWxzZSByZXR1cm4gY2xlYXI7XG4gIH0pO1xuICBpZiAobm93KSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBsZXQgYW1vdW50ID0gb3B0aW9ucztcbiAgbGV0IGNhbWVyYSA9IGZhbHNlO1xuICBsZXQgbm93ID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAoe2Ftb3VudCwgY2FtZXJhfSA9IG9wdGlvbnMpO1xuICAgIG5vdyA9IHR5cGVvZihvcHRpb25zLm5vdykgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMubm93O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAvLyB0b2RvOiBkbyB3ZSBuZWVkIHRvIGZhZGUgYWxzbyB0ZW1wIGJ1ZmZlcnM/XG4gIGNvbnN0IGZhZGUgPSBzZWxmLnJlZ2woe1xuICAgIGZyYWc6IGBcbiAgICAgICAgICBwcmVjaXNpb24gJHtzZWxmLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICAgICAgdmFyeWluZyB2ZWMyIHZ1djtcbiAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBwcmV2QnVmZmVyO1xuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIHZlYzQgY29sb3IgPSBtaXgodGV4dHVyZTJEKHByZXZCdWZmZXIsIHZ1diksIHZlYzQoMCksICR7YW1vdW50fSk7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLnByZWNpc2lvbiwgY2FtZXJhLCB7IGdsc2xOYW1lOiAnY2xlYXInIH0pLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGYuYXR0cmlidXRlcyxcbiAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBwcmV2QnVmZmVyOiAoKSA9PiAgeyByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleF0gfSxcbiAgICB9LCB0aGlzLnVuaWZvcm1zKSxcbiAgICBjb3VudDogMyxcbiAgICAvLyBuZXh0IGZyYW1lYnVmZmVyXG4gICAgZnJhbWVidWZmZXI6ICgpID0+IHtcbiAgICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4ID8gMCA6IDFdXG4gICAgfVxuICB9KTtcbiAgaWYgKG5vdykgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmYWRlO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwcmltaXRpdmUsIGdlb21ldHJ5KSB7XG4gIGxldCBlbGVtZW50cyA9IDM7XG4gIGxldCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICBpZiAoZ2VvbWV0cnkpIHtcbiAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpIHtcbiAgICAgIE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4gYXR0cmlidXRlc1trZXldID0gZ2VvbWV0cnkuYXR0cmlidXRlc1trZXldLmFycmF5KTtcbiAgICAgIGVsZW1lbnRzID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICBwcmltaXRpdmUgfHwgKHByaW1pdGl2ZSA9IGdlb21ldHJ5LnBhcmFtZXRlcnMucHJpbWl0aXZlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkucG9zaXRpb25zICYmIChnZW9tZXRyeS5lZGdlcyB8fCBnZW9tZXRyeS5jZWxscykpIHtcbiAgICAgIGF0dHJpYnV0ZXMucG9zaXRpb24gPSBbXTsgLy8gdG9kbzogc2hvdWxkIGJlIEZsb2F0MzJBcnJheVxuICAgICAgZ2VvbWV0cnkucG9zaXRpb25zLm1hcCgodiwgaykgPT4gYXR0cmlidXRlcy5wb3NpdGlvbi5wdXNoKHZbMF0sIHZbMV0sIDApKTtcbiAgICAgIGVsZW1lbnRzID0gZ2VvbWV0cnkuZWRnZXMgPyBnZW9tZXRyeS5lZGdlcyA6IGdlb21ldHJ5LmNlbGxzO1xuICAgICAgcHJpbWl0aXZlID0gZ2VvbWV0cnkuZWRnZXMgPyAnbGluZXMnIDogJ3RyaWFuZ2xlcyc7XG4gICAgfVxuICB9XG4gIHByaW1pdGl2ZSB8fCAocHJpbWl0aXZlID0gJ3RyaWFuZ2xlcycpO1xuICByZXR1cm4ge2F0dHJpYnV0ZXMsIGVsZW1lbnRzLCBwcmltaXRpdmV9O1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldFVuaWZvcm1zID0gZnVuY3Rpb24odW5pZm9ybXMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih1bmlmb3JtcywgeyBwcmV2QnVmZmVyOiAgKCkgPT4gIHtcbiAgICAvLyB0b2RvOiBjaGFuZ2VkLCBvcmlnaW5hbGx5OlxuICAgIC8vIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XVxuICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4ID8gMCA6IDFdXG4gICAgfVxuICB9KVxuICByZXR1cm4gT2JqZWN0LmtleXModW5pZm9ybXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IHR5cGVvZih1bmlmb3Jtc1trZXldKSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHVuaWZvcm1zW2tleV0pIDogdW5pZm9ybXNba2V5XTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0QmxlbmQgPSBmdW5jdGlvbihibGVuZE1vZGUpIHtcbiAgbGV0IGZ1bmM7XG4gIHN3aXRjaCAoYmxlbmRNb2RlKSB7XG4gICAgY2FzZSAnY3VzdG9tJzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ2N1c3RvbScsICAvLyBEZWZpbmUgeW91ciBjdXN0b20gYmxlbmRpbmcgZnVuY3Rpb24gaGVyZVxuICAgICAgICBkc3RSR0I6ICdjdXN0b20nLFxuICAgICAgICBzcmNBbHBoYTogJ2N1c3RvbScsXG4gICAgICAgIGRzdEFscGhhOiAnY3VzdG9tJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvdmVybGF5JzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ2RzdCBjb2xvcicsXG4gICAgICAgIGRzdFJHQjogJ29uZSBtaW51cyBzcmMgY29sb3InLFxuICAgICAgICBzcmNBbHBoYTogJ2RzdCBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAnb25lIG1pbnVzIHNyYyBhbHBoYScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ29uZSBtaW51cyBkc3QgY29sb3InLFxuICAgICAgICBkc3RSR0I6ICdvbmUnLFxuICAgICAgICBzcmNBbHBoYTogJ29uZSBtaW51cyBkc3QgYWxwaGEnLFxuICAgICAgICBkc3RBbHBoYTogJ29uZScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnZHN0IGNvbG9yJyxcbiAgICAgICAgZHN0UkdCOiAnemVybycsXG4gICAgICAgIHNyY0FscGhhOiAnZHN0IGFscGhhJyxcbiAgICAgICAgZHN0QWxwaGE6ICd6ZXJvJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZGQnOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnb25lJyxcbiAgICAgICAgZHN0UkdCOiAnb25lJyxcbiAgICAgICAgc3JjQWxwaGE6ICdvbmUnLFxuICAgICAgICBkc3RBbHBoYTogJ29uZScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWxwaGEnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdzcmMgYWxwaGEnLFxuICAgICAgICBzcmNBbHBoYTogMSxcbiAgICAgICAgZHN0UkdCOiAnb25lIG1pbnVzIHNyYyBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAxXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmFibGU6IGJsZW5kTW9kZSA/ICh0eXBlb2YoYmxlbmRNb2RlKSA9PT0gJ3N0cmluZycgPyBibGVuZE1vZGUgIT09ICdkaXNhYmxlZCcgOiBibGVuZE1vZGUpIDogZmFsc2UsXG4gICAgZnVuYyxcbiAgfTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIGNvbnN0IGRvRHJhdyA9ICgpID0+IHRoaXMuZHJhdy5tYXAoKGZuKSA9PiBmbihwcm9wcykpO1xuICB0aGlzLl9jYW1lcmEoe1xuICAgIGV5ZTogdGhpcy5leWUsXG4gICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgfSwgZnVuY3Rpb24oKSB7XG4gICAgZG9EcmF3KCk7XG4gIH0pO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLnJlbmRlclRleHR1cmUgPSBmdW5jdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IHRoaXMucGluZ1BvbmdJbmRleCA/IDAgOiAxO1xuICBjb25zdCBvcmlnaW5hbCA9IHRoaXMuZmJvcztcbiAgdGhpcy5pbml0RmJvcyh7Y29sb3I6IG9wdGlvbnN9KTtcbiAgdGhpcy5zeW50aC5fcmVuZGVyT3V0KHRoaXMuaWQpO1xuICBjb25zdCBjb2xvclRleCA9IHRoaXMuZmJvc1t0aGlzLnBpbmdQb25nSW5kZXhdLmNvbG9yO1xuICB0aGlzLmZib3MgPSBvcmlnaW5hbDtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY29sb3JUZXgpID8gY29sb3JUZXhbMF0gOiBjb2xvclRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgT3V0cHV0XG4iLCJjb25zdCB0eXBlTG9va3VwID0ge1xuICAgICdzcmMnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICAgICAgYXJnczogWyd2ZWMyIF9zdCddXG4gICAgfSxcbiAgICAndmVydCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgICB9LFxuICAgICdjb29yZCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgICB9LFxuICAgICdjb2xvcic6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzQgX2MwJ11cbiAgICB9LFxuICAgICdjb21iaW5lJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgICAgIGFyZ3M6IFsndmVjNCBfYzAnLCAndmVjNCBfYzEnXVxuICAgIH0sXG4gICAgJ2NvbWJpbmVDb29yZCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0JywgJ3ZlYzQgX2MwJ11cbiAgICB9XG59XG5cbmNvbnN0IGdldExvb2t1cCA9IHtmbG9hdDogJ3gnLCB2ZWMyOiAneHknLCB2ZWMzOiAneHl6JywgdmVjNDogJ3h5encnfTtcblxuY29uc3QgZ2V0VHlwZUxvb2t1cCA9IHtcbiAgICB4OiAnZmxvYXQnLCB5OiAnZmxvYXQnLCB6OiAnZmxvYXQnLFxuICAgIHh5OiAndmVjMicsIHl4OiAndmVjMicsXG4gICAgeHl6OiAndmVjMycsIHh6eTogJ3ZlYzMnLCB5eng6ICd2ZWMzJywgeXh6OiAndmVjMycsIHp4eTogJ3ZlYzMnLCB6eXg6ICd2ZWMzJyxcbiAgICB4eXp3OiAndmVjNCcsXG59O1xuXG5jb25zdCBjYXN0VHlwZSA9IChmdW5jLCBmcm9tVHlwZSwgdG9UeXBlLCBhbHBoYSA9IDAuMCkgPT4ge1xuICAgIGxldCBmcm9tTGVuID0gZnJvbVR5cGUuc3Vic3RyaW5nKDMpO1xuICAgIGxldCB0b0xlbiA9IHRvVHlwZS5zdWJzdHJpbmcoMyk7XG4gICAgY29uc3Qgbm9uVmVjID0ge2Zsb2F0OiAxLCBzYW1wbGVyMkQ6IDR9O1xuICAgIE9iamVjdC5rZXlzKG5vblZlYykubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmIChmcm9tVHlwZSA9PT0gdCkgZnJvbUxlbiA9IG5vblZlY1t0XTtcbiAgICAgICAgaWYgKHRvVHlwZSA9PT0gdCkgdG9MZW4gPSBub25WZWNbdF07XG4gICAgfSk7XG4gICAgaWYgKGZyb21MZW4gPCB0b0xlbikge1xuICAgICAgICBsZXQgZGlmZiA9IHRvTGVuIC0gZnJvbUxlbjtcbiAgICAgICAgbGV0IGxhc3QgPSAnJztcbiAgICAgICAgaWYgKHRvVHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICAgICAgICBkaWZmIC09IDE7XG4gICAgICAgICAgICBsYXN0ID0gJywgJythbHBoYTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jID0gYHZlYyR7dG9MZW59KCR7ZnVuY30keycsIDAuMCcucmVwZWF0KGRpZmYpfSR7bGFzdH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHbHNsKG9iaiwgcmV0dXJuVHlwZSwgYXJncyA9IFtdKSB7XG4gICAgbGV0IGJhc2VBcmdzID0gYXJncy5tYXAoKGFyZykgPT4gYXJnKS5qb2luKFwiLCBcIilcbiAgICBsZXQgY3VzdG9tQXJncyA9IChvYmouaW5wdXRzIHx8IChvYmouaW5wdXRzID0gW10pKS5tYXAoKGlucHV0KSA9PiBgJHtpbnB1dC50eXBlfSAke2lucHV0Lm5hbWV9YCkuam9pbignLCAnKVxuICAgIGxldCBhbGxBcmdzID0gYCR7YmFzZUFyZ3N9JHtjdXN0b21BcmdzLmxlbmd0aCA+IDAgPyAnLCAnKyBjdXN0b21BcmdzOiAnJ31gXG5cbiAgICBjb25zdCBmdW5jID0gYCR7cmV0dXJuVHlwZSB8fCAnJ30gJHtvYmouZ2xzbE5hbWV9KCR7YWxsQXJnc31gO1xuICAgIGNvbnN0IGZpeE9yV3JhcCA9IChnbHNsKSA9PiB7XG4gICAgICAgIGlmIChnbHNsLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoZ2xzbC5pbmRleE9mKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWApID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xzbC5yZXBsYWNlKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWAsIGZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5wcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByaW1pdGl2ZUZuID0gb2JqLnByaW1pdGl2ZS5zcGxpdChcIiBcIikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsc2wuaW5kZXhPZihwcmltaXRpdmVGbikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsc2wucmVwbGFjZShgJHtyZXR1cm5UeXBlfSAke3ByaW1pdGl2ZUZufSgke2FsbEFyZ3N9YCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgJHtmdW5jfSkge1xuICAgICAgJHtnbHNsfVxuICB9XG5gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbHNsO1xuICAgIH1cbiAgICBvYmouZ2xzbCA9IGZpeE9yV3JhcChvYmouZ2xzbCk7XG4gICAgaWYgKG9iai52ZXJ0KSB7XG4gICAgICAgIG9iai52ZXJ0ID0gZml4T3JXcmFwKG9iai52ZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgZXh0cmEgaW5wdXQgdG8gYmVnaW5uaW5nIGZvciBiYWNrd2FyZCBjb21iYXRpYmlsaXR5IEB0b2RvIHVwZGF0ZSBjb21waWxlciBzbyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICBpZihvYmoudHlwZSA9PT0gJ2NvbWJpbmUnIHx8IG9iai50eXBlID09PSAnY29tYmluZUNvb3JkJykgb2JqLmlucHV0cy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgdHlwZTogJ3ZlYzQnXG4gICAgfSlcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHJldHVyblR5cGUgfSlcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUdlblR5cGUodHJhbnNmb3JtLCB0b1R5cGUpIHtcbiAgICBjb25zdCB0ID0gdHlwZUxvb2t1cFt0b1R5cGVdO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHRvVHlwZSA9PT0gJ2Nvb3JkJykge1xuICAgICAgICByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybS5jb29yZCwge1xuICAgICAgICAgICAgdHlwZTogdG9UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGNvbG9yXG4gICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHRyYW5zZm9ybSwge1xuICAgICAgICAgICAgdHlwZTogdG9UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NHbHNsKHJlc3VsdCwgdC5yZXR1cm5UeXBlLCB0LmFyZ3MpO1xufVxuXG5leHBvcnQgeyB0eXBlTG9va3VwLCBnZXRMb29rdXAsIGdldFR5cGVMb29rdXAsIGNhc3RUeXBlLCBwcm9jZXNzR2xzbCwgcmVwbGFjZUdlblR5cGUgfTsiXX0=
