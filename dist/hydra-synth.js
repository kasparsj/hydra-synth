(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hydra = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],2:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],3:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],4:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],5:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],6:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],7:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],8:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],9:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],10:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],11:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],12:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],13:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],14:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],15:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],16:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],17:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":2,"./clone":3,"./copy":4,"./create":5,"./determinant":6,"./fromQuat":7,"./fromRotation":8,"./fromRotationTranslation":9,"./fromScaling":10,"./fromTranslation":11,"./fromXRotation":12,"./fromYRotation":13,"./fromZRotation":14,"./frustum":15,"./identity":16,"./invert":18,"./lookAt":19,"./multiply":20,"./ortho":21,"./perspective":22,"./perspectiveFromFieldOfView":23,"./rotate":24,"./rotateX":25,"./rotateY":26,"./rotateZ":27,"./scale":28,"./str":29,"./translate":30,"./transpose":31}],18:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],19:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":16}],20:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],21:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],22:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],23:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],24:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],25:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],26:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],27:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],28:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],29:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],30:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],31:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],32:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],33:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],34:[function(require,module,exports){
!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(r="undefined"!=typeof globalThis?globalThis:r||self).Meyda=t()}(this,(function(){"use strict";function r(r,t,e){if(e||2===arguments.length)for(var a,n=0,o=t.length;n<o;n++)!a&&n in t||(a||(a=Array.prototype.slice.call(t,0,n)),a[n]=t[n]);return r.concat(a||Array.prototype.slice.call(t))}var t=Object.freeze({__proto__:null,blackman:function(r){for(var t=new Float32Array(r),e=2*Math.PI/(r-1),a=2*e,n=0;n<r/2;n++)t[n]=.42-.5*Math.cos(n*e)+.08*Math.cos(n*a);for(n=Math.ceil(r/2);n>0;n--)t[r-n]=t[n-1];return t},sine:function(r){for(var t=Math.PI/(r-1),e=new Float32Array(r),a=0;a<r;a++)e[a]=Math.sin(t*a);return e},hanning:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.5-.5*Math.cos(2*Math.PI*e/(r-1));return t},hamming:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.54-.46*Math.cos(2*Math.PI*(e/r-1));return t}}),e={};function a(r){for(;r%2==0&&r>1;)r/=2;return 1===r}function n(r,a){if("rect"!==a){if(""!==a&&a||(a="hanning"),e[a]||(e[a]={}),!e[a][r.length])try{e[a][r.length]=t[a](r.length)}catch(r){throw new Error("Invalid windowing function")}r=function(r,t){for(var e=[],a=0;a<Math.min(r.length,t.length);a++)e[a]=r[a]*t[a];return e}(r,e[a][r.length])}return r}function o(r,t,e){for(var a=new Float32Array(r),n=0;n<a.length;n++)a[n]=n*t/e,a[n]=13*Math.atan(a[n]/1315.8)+3.5*Math.atan(Math.pow(a[n]/7518,2));return a}function i(r){return Float32Array.from(r)}function u(r){return 1125*Math.log(1+r/700)}function f(r,t,e){for(var a,n=new Float32Array(r+2),o=new Float32Array(r+2),i=t/2,f=u(0),c=(u(i)-f)/(r+1),l=new Array(r+2),s=0;s<n.length;s++)n[s]=s*c,o[s]=(a=n[s],700*(Math.exp(a/1125)-1)),l[s]=Math.floor((e+1)*o[s]/t);for(var m=new Array(r),p=0;p<m.length;p++){m[p]=new Array(e/2+1).fill(0);for(s=l[p];s<l[p+1];s++)m[p][s]=(s-l[p])/(l[p+1]-l[p]);for(s=l[p+1];s<l[p+2];s++)m[p][s]=(l[p+2]-s)/(l[p+2]-l[p+1])}return m}function c(t,e,a,n,o,i,u){void 0===n&&(n=5),void 0===o&&(o=2),void 0===i&&(i=!0),void 0===u&&(u=440);var f=Math.floor(a/2)+1,c=new Array(a).fill(0).map((function(r,n){return t*function(r,t){return Math.log2(16*r/t)}(e*n/a,u)}));c[0]=c[1]-1.5*t;var l,s,m,p=c.slice(1).map((function(r,t){return Math.max(r-c[t])}),1).concat([1]),h=Math.round(t/2),g=new Array(t).fill(0).map((function(r,e){return c.map((function(r){return(10*t+h+r-e)%t-h}))})),w=g.map((function(r,t){return r.map((function(r,e){return Math.exp(-.5*Math.pow(2*g[t][e]/p[e],2))}))}));if(s=(l=w)[0].map((function(){return 0})),m=l.reduce((function(r,t){return t.forEach((function(t,e){r[e]+=Math.pow(t,2)})),r}),s).map(Math.sqrt),w=l.map((function(r,t){return r.map((function(r,t){return r/(m[t]||1)}))})),o){var v=c.map((function(r){return Math.exp(-.5*Math.pow((r/t-n)/o,2))}));w=w.map((function(r){return r.map((function(r,t){return r*v[t]}))}))}return i&&(w=r(r([],w.slice(3),!0),w.slice(0,3),!0)),w.map((function(r){return r.slice(0,f)}))}function l(r,t){for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.pow(n,r)*Math.abs(t[n]),a+=t[n];return e/a}function s(r){var t=r.ampSpectrum,e=r.barkScale,a=r.numberOfBarkBands,n=void 0===a?24:a;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;var o=n,i=new Float32Array(o),u=0,f=t,c=new Int32Array(o+1);c[0]=0;for(var l=e[f.length-1]/o,s=1,m=0;m<f.length;m++)for(;e[m]>l;)c[s++]=m,l=s*e[f.length-1]/o;c[o]=f.length-1;for(m=0;m<o;m++){for(var p=0,h=c[m];h<c[m+1];h++)p+=f[h];i[m]=Math.pow(p,.23)}for(m=0;m<i.length;m++)u+=i[m];return{specific:i,total:u}}function m(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=new Float32Array(t.length),a=0;a<e.length;a++)e[a]=Math.pow(t[a],2);return e}function p(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.bufferSize;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate melBands");if("object"!=typeof e)throw new TypeError("Valid melFilterBank is required to generate melBands");for(var n=m({ampSpectrum:t}),o=e.length,i=Array(o),u=new Float32Array(o),f=0;f<u.length;f++){i[f]=new Float32Array(a/2),u[f]=0;for(var c=0;c<a/2;c++)i[f][c]=e[f][c]*n[c],u[f]+=i[f][c];u[f]=Math.log(u[f]+1)}return Array.prototype.slice.call(u)}function h(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var g={exports:{}},w=null;var v=function(r,t){var e=r.length;return t=t||2,w&&w[e]||function(r){(w=w||{})[r]=new Array(r*r);for(var t=Math.PI/r,e=0;e<r;e++)for(var a=0;a<r;a++)w[r][a+e*r]=Math.cos(t*(a+.5)*e)}(e),r.map((function(){return 0})).map((function(a,n){return t*r.reduce((function(r,t,a,o){return r+t*w[e][a+n*e]}),0)}))};!function(r){r.exports=v}(g);var d=h(g.exports);var y=Object.freeze({__proto__:null,buffer:function(r){return r.signal},rms:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(t[a],2);return e/=t.length,e=Math.sqrt(e)},energy:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(Math.abs(t[a]),2);return e},complexSpectrum:function(r){return r.complexSpectrum},spectralSlope:function(r){var t=r.ampSpectrum,e=r.sampleRate,a=r.bufferSize;if("object"!=typeof t)throw new TypeError;for(var n=0,o=0,i=new Float32Array(t.length),u=0,f=0,c=0;c<t.length;c++){n+=t[c];var l=c*e/a;i[c]=l,u+=l*l,o+=l,f+=l*t[c]}return(t.length*f-o*n)/(n*(u-Math.pow(o,2)))},spectralCentroid:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return l(1,t)},spectralRolloff:function(r){var t=r.ampSpectrum,e=r.sampleRate;if("object"!=typeof t)throw new TypeError;for(var a=t,n=e/(2*(a.length-1)),o=0,i=0;i<a.length;i++)o+=a[i];for(var u=.99*o,f=a.length-1;o>u&&f>=0;)o-=a[f],--f;return(f+1)*n},spectralFlatness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.log(t[n]),a+=t[n];return Math.exp(e/t.length)*t.length/a},spectralSpread:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return Math.sqrt(l(2,t)-Math.pow(l(1,t),2))},spectralSkewness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=l(1,t),a=l(2,t),n=l(3,t);return(2*Math.pow(e,3)-3*e*a+n)/Math.pow(Math.sqrt(a-Math.pow(e,2)),3)},spectralKurtosis:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=t,a=l(1,e),n=l(2,e),o=l(3,e),i=l(4,e);return(-3*Math.pow(a,4)+6*a*n-4*a*o+i)/Math.pow(Math.sqrt(n-Math.pow(a,2)),4)},amplitudeSpectrum:function(r){return r.ampSpectrum},zcr:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=1;a<t.length;a++)(t[a-1]>=0&&t[a]<0||t[a-1]<0&&t[a]>=0)&&e++;return e},loudness:s,perceptualSpread:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=0,a=0;a<t.specific.length;a++)t.specific[a]>e&&(e=t.specific[a]);return Math.pow((t.total-e)/t.total,2)},perceptualSharpness:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=t.specific,a=0,n=0;n<e.length;n++)a+=n<15?(n+1)*e[n+1]:.066*Math.exp(.171*(n+1));return a*=.11/t.total},powerSpectrum:m,mfcc:function(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.numberOfMFCCCoefficients,n=r.bufferSize,o=Math.min(40,Math.max(1,a||13));if(e.length<o)throw new Error("Insufficient filter bank for requested number of coefficients");var i=p({ampSpectrum:t,melFilterBank:e,bufferSize:n});return d(i).slice(0,o)},chroma:function(r){var t=r.ampSpectrum,e=r.chromaFilterBank;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate chroma");if("object"!=typeof e)throw new TypeError("Valid chromaFilterBank is required to generate chroma");var a=e.map((function(r,e){return t.reduce((function(t,e,a){return t+e*r[a]}),0)})),n=Math.max.apply(Math,a);return n?a.map((function(r){return r/n})):a},spectralFlux:function(r){var t=r.signal,e=r.previousSignal,a=r.bufferSize;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;for(var n=0,o=-a/2;o<t.length/2-1;o++)x=Math.abs(t[o])-Math.abs(e[o]),n+=(x+Math.abs(x))/2;return n},spectralCrest:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=0,a=-1/0;return t.forEach((function(r){e+=Math.pow(r,2),a=r>a?r:a})),e/=t.length,e=Math.sqrt(e),a/e},melBands:p});function S(r){if(Array.isArray(r)){for(var t=0,e=Array(r.length);t<r.length;t++)e[t]=r[t];return e}return Array.from(r)}var _={},b={},M={bitReverseArray:function(r){if(void 0===_[r]){for(var t=(r-1).toString(2).length,e="0".repeat(t),a={},n=0;n<r;n++){var o=n.toString(2);o=e.substr(o.length)+o,o=[].concat(S(o)).reverse().join(""),a[n]=parseInt(o,2)}_[r]=a}return _[r]},multiply:function(r,t){return{real:r.real*t.real-r.imag*t.imag,imag:r.real*t.imag+r.imag*t.real}},add:function(r,t){return{real:r.real+t.real,imag:r.imag+t.imag}},subtract:function(r,t){return{real:r.real-t.real,imag:r.imag-t.imag}},euler:function(r,t){var e=-2*Math.PI*r/t;return{real:Math.cos(e),imag:Math.sin(e)}},conj:function(r){return r.imag*=-1,r},constructComplexArray:function(r){var t={};t.real=void 0===r.real?r.slice():r.real.slice();var e=t.real.length;return void 0===b[e]&&(b[e]=Array.apply(null,Array(e)).map(Number.prototype.valueOf,0)),t.imag=b[e].slice(),t}},F=function(r){var t={};void 0===r.real||void 0===r.imag?t=M.constructComplexArray(r):(t.real=r.real.slice(),t.imag=r.imag.slice());var e=t.real.length,a=Math.log2(e);if(Math.round(a)!=a)throw new Error("Input size must be a power of 2.");if(t.real.length!=t.imag.length)throw new Error("Real and imaginary components must have the same length.");for(var n=M.bitReverseArray(e),o={real:[],imag:[]},i=0;i<e;i++)o.real[n[i]]=t.real[i],o.imag[n[i]]=t.imag[i];for(var u=0;u<e;u++)t.real[u]=o.real[u],t.imag[u]=o.imag[u];for(var f=1;f<=a;f++)for(var c=Math.pow(2,f),l=0;l<c/2;l++)for(var s=M.euler(l,c),m=0;m<e/c;m++){var p=c*m+l,h=c*m+l+c/2,g={real:t.real[p],imag:t.imag[p]},w={real:t.real[h],imag:t.imag[h]},v=M.multiply(s,w),d=M.subtract(g,v);t.real[h]=d.real,t.imag[h]=d.imag;var y=M.add(v,g);t.real[p]=y.real,t.imag[p]=y.imag}return t},A=F,E=function(){function r(r,t){var e=this;if(this._m=t,!r.audioContext)throw this._m.errors.noAC;if(r.bufferSize&&!a(r.bufferSize))throw this._m._errors.notPow2;if(!r.source)throw this._m._errors.noSource;this._m.audioContext=r.audioContext,this._m.bufferSize=r.bufferSize||this._m.bufferSize||256,this._m.hopSize=r.hopSize||this._m.hopSize||this._m.bufferSize,this._m.sampleRate=r.sampleRate||this._m.audioContext.sampleRate||44100,this._m.callback=r.callback,this._m.windowingFunction=r.windowingFunction||"hanning",this._m.featureExtractors=y,this._m.EXTRACTION_STARTED=r.startImmediately||!1,this._m.channel="number"==typeof r.channel?r.channel:0,this._m.inputs=r.inputs||1,this._m.outputs=r.outputs||1,this._m.numberOfMFCCCoefficients=r.numberOfMFCCCoefficients||this._m.numberOfMFCCCoefficients||13,this._m.numberOfBarkBands=r.numberOfBarkBands||this._m.numberOfBarkBands||24,this._m.spn=this._m.audioContext.createScriptProcessor(this._m.bufferSize,this._m.inputs,this._m.outputs),this._m.spn.connect(this._m.audioContext.destination),this._m._featuresToExtract=r.featureExtractors||[],this._m.barkScale=o(this._m.bufferSize,this._m.sampleRate,this._m.bufferSize),this._m.melFilterBank=f(Math.max(this._m.melBands,this._m.numberOfMFCCCoefficients),this._m.sampleRate,this._m.bufferSize),this._m.inputData=null,this._m.previousInputData=null,this._m.frame=null,this._m.previousFrame=null,this.setSource(r.source),this._m.spn.onaudioprocess=function(r){var t;null!==e._m.inputData&&(e._m.previousInputData=e._m.inputData),e._m.inputData=r.inputBuffer.getChannelData(e._m.channel),e._m.previousInputData?((t=new Float32Array(e._m.previousInputData.length+e._m.inputData.length-e._m.hopSize)).set(e._m.previousInputData.slice(e._m.hopSize)),t.set(e._m.inputData,e._m.previousInputData.length-e._m.hopSize)):t=e._m.inputData,function(r,t,e){if(r.length<t)throw new Error("Buffer is too short for frame length");if(e<1)throw new Error("Hop length cannot be less that 1");if(t<1)throw new Error("Frame length cannot be less that 1");var a=1+Math.floor((r.length-t)/e);return new Array(a).fill(0).map((function(a,n){return r.slice(n*e,n*e+t)}))}(t,e._m.bufferSize,e._m.hopSize).forEach((function(r){e._m.frame=r;var t=e._m.extract(e._m._featuresToExtract,e._m.frame,e._m.previousFrame);"function"==typeof e._m.callback&&e._m.EXTRACTION_STARTED&&e._m.callback(t),e._m.previousFrame=e._m.frame}))}}return r.prototype.start=function(r){this._m._featuresToExtract=r||this._m._featuresToExtract,this._m.EXTRACTION_STARTED=!0},r.prototype.stop=function(){this._m.EXTRACTION_STARTED=!1},r.prototype.setSource=function(r){this._m.source&&this._m.source.disconnect(this._m.spn),this._m.source=r,this._m.source.connect(this._m.spn)},r.prototype.setChannel=function(r){r<=this._m.inputs?this._m.channel=r:console.error("Channel ".concat(r," does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r," when instantiating the MeydaAnalyzer"))},r.prototype.get=function(r){return this._m.inputData?this._m.extract(r||this._m._featuresToExtract,this._m.inputData,this._m.previousInputData):null},r}(),C={audioContext:null,spn:null,bufferSize:512,sampleRate:44100,melBands:26,chromaBands:12,callback:null,windowingFunction:"hanning",featureExtractors:y,EXTRACTION_STARTED:!1,numberOfMFCCCoefficients:13,numberOfBarkBands:24,_featuresToExtract:[],windowing:n,_errors:{notPow2:new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"),featureUndef:new Error("Meyda: No features defined."),invalidFeatureFmt:new Error("Meyda: Invalid feature format"),invalidInput:new Error("Meyda: Invalid input."),noAC:new Error("Meyda: No AudioContext specified."),noSource:new Error("Meyda: No source node specified.")},createMeydaAnalyzer:function(r){return new E(r,Object.assign({},C))},listAvailableFeatureExtractors:function(){return Object.keys(this.featureExtractors)},extract:function(r,t,e){var n=this;if(!t)throw this._errors.invalidInput;if("object"!=typeof t)throw this._errors.invalidInput;if(!r)throw this._errors.featureUndef;if(!a(t.length))throw this._errors.notPow2;void 0!==this.barkScale&&this.barkScale.length==this.bufferSize||(this.barkScale=o(this.bufferSize,this.sampleRate,this.bufferSize)),void 0!==this.melFilterBank&&this.barkScale.length==this.bufferSize&&this.melFilterBank.length==this.melBands||(this.melFilterBank=f(Math.max(this.melBands,this.numberOfMFCCCoefficients),this.sampleRate,this.bufferSize)),void 0!==this.chromaFilterBank&&this.chromaFilterBank.length==this.chromaBands||(this.chromaFilterBank=c(this.chromaBands,this.sampleRate,this.bufferSize)),"buffer"in t&&void 0===t.buffer?this.signal=i(t):this.signal=t;var u=k(t,this.windowingFunction,this.bufferSize);if(this.signal=u.windowedSignal,this.complexSpectrum=u.complexSpectrum,this.ampSpectrum=u.ampSpectrum,e){var l=k(e,this.windowingFunction,this.bufferSize);this.previousSignal=l.windowedSignal,this.previousComplexSpectrum=l.complexSpectrum,this.previousAmpSpectrum=l.ampSpectrum}var s=function(r){return n.featureExtractors[r]({ampSpectrum:n.ampSpectrum,chromaFilterBank:n.chromaFilterBank,complexSpectrum:n.complexSpectrum,signal:n.signal,bufferSize:n.bufferSize,sampleRate:n.sampleRate,barkScale:n.barkScale,melFilterBank:n.melFilterBank,previousSignal:n.previousSignal,previousAmpSpectrum:n.previousAmpSpectrum,previousComplexSpectrum:n.previousComplexSpectrum,numberOfMFCCCoefficients:n.numberOfMFCCCoefficients,numberOfBarkBands:n.numberOfBarkBands})};if("object"==typeof r)return r.reduce((function(r,t){var e;return Object.assign({},r,((e={})[t]=s(t),e))}),{});if("string"==typeof r)return s(r);throw this._errors.invalidFeatureFmt}},k=function(r,t,e){var a={};void 0===r.buffer?a.signal=i(r):a.signal=r,a.windowedSignal=n(a.signal,t),a.complexSpectrum=A(a.windowedSignal),a.ampSpectrum=new Float32Array(e/2);for(var o=0;o<e/2;o++)a.ampSpectrum[o]=Math.sqrt(Math.pow(a.complexSpectrum.real[o],2)+Math.pow(a.complexSpectrum.imag[o],2));return a};return"undefined"!=typeof window&&(window.Meyda=C),C}));


},{}],35:[function(require,module,exports){
(function (process){(function (){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this)}).call(this,require('_process'))

},{"_process":36}],36:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],37:[function(require,module,exports){
var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter
var now = require('right-now')
var raf = require('raf')

module.exports = Engine
function Engine(fn) {
    if (!(this instanceof Engine)) 
        return new Engine(fn)
    this.running = false
    this.last = now()
    this._frame = 0
    this._tick = this.tick.bind(this)

    if (fn)
        this.on('tick', fn)
}

inherits(Engine, EventEmitter)

Engine.prototype.start = function() {
    if (this.running) 
        return
    this.running = true
    this.last = now()
    this._frame = raf(this._tick)
    return this
}

Engine.prototype.stop = function() {
    this.running = false
    if (this._frame !== 0)
        raf.cancel(this._frame)
    this._frame = 0
    return this
}

Engine.prototype.tick = function() {
    this._frame = raf(this._tick)
    var time = now()
    var dt = time - this.last
    this.emit('tick', dt)
    this.last = time
}
},{"events":1,"inherits":33,"raf":38,"right-now":40}],38:[function(require,module,exports){
(function (global){(function (){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":35}],39:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.createREGL = factory());
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map((y, i) => unbox(y, path + '[' + i + ']')))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
    extend(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])

      if (!limits.npotTextureCube) {
        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
      }

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              if (colorTexture) {
                check$1.oneOf(
                  options.colorFormat, colorTextureFormats,
                  'invalid color format for texture')
              } else {
                check$1.oneOf(
                  options.colorFormat, colorRenderbufferFormats,
                  'invalid color format for renderbuffer')
              }
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = this
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (attributes) {
      check$1(Array.isArray(attributes), 'arguments to vertex array constructor must be an array')
      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0
      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      if (extensions.oes_texture_float) {
        check$1(
          type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
          'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

        if (type === GL_FLOAT$7) {
          check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
        }
      } else {
        check$1(
          type === GL_UNSIGNED_BYTE$7,
          'Reading from a framebuffer is only allowed for the type \'uint8\'')
      }
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        if (isBufferArgs(elements)) {
          elements = elementState.getElements(elementState.create(elements, true))
        } else if (elements) {
          elements = elementState.getElements(elements)
          check$1.command(elements, 'invalid elements', env.commandStr)
        }
        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      }

      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset && elements) {
        return createStaticDecl(function (env, scope) {
          env.OFFSET = '0'
          return 0
        })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      }
      return null
    }

    return {
      elements: elements,
      primitive: parsePrimitive(),
      count: parseVertCount(),
      instances: parseParam(S_INSTANCES, false),
      offset: OFFSET
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            if ('divisor' in value) {
              check$1.command(divisor === 0 || extInstancing,
                'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
              check$1.command(divisor >= 0,
                'invalid divisor for attribute "' + attribute + '"', env.commandStr)
            }

            check$1.optional(function () {
              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseVAO (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic
    if (S_VAO in staticOptions) {
      var vao = staticOptions[S_VAO]
      if (vao !== null && attributeState.getVAO(vao) === null) {
        vao = attributeState.createVAO(vao)
      }
      return createStaticDecl(function (env) {
        return env.link(attributeState.getVAO(vao))
      })
    } else if (S_VAO in dynamicOptions) {
      var dyn = dynamicOptions[S_VAO]
      return createDynamicDecl(dyn, function (env, scope) {
        var vaoRef = env.invoke(scope, dyn)
        return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
      })
    }
    return null
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = parseVAO(options, env)
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO(staticBindings))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      scope(GL, '.uniform', infix, '(', LOCATION, ',')
      if (infix.charAt(0) === 'M') {
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
      } else if (unroll > 1) {
        scope(loop(unroll, function (i) {
          return Array.isArray(VALUE) ? VALUE[i] : VALUE + '[' + i + ']'
        }))
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        scope(VALUE)
      }
      scope(');')
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
      } else {
        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS)
      }
      if (ELEMENTS) {
        scope(
          'if(' + ELEMENTS + ')' +
          GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements)

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    })
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()
    attributeState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));


},{}],40:[function(require,module,exports){
(function (global){(function (){
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LinearDisplayP3ColorSpace = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.FrontSide = exports.FloatType = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DisplayP3ColorSpace = exports.DepthStencilFormat = exports.DepthFormat = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.ByteType = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.sRGBEncoding = exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WebGPUCoordinateSystem = exports.WebGLCoordinateSystem = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UVMapping = exports.TwoPassDoubleSide = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.ShortType = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = void 0;
const REVISION = '156';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const TwoPassDoubleSide = 2; // r149

exports.TwoPassDoubleSide = TwoPassDoubleSide;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const RGB_BPTC_SIGNED_Format = 36494;
exports.RGB_BPTC_SIGNED_Format = RGB_BPTC_SIGNED_Format;
const RGB_BPTC_UNSIGNED_Format = 36495;
exports.RGB_BPTC_UNSIGNED_Format = RGB_BPTC_UNSIGNED_Format;
const RED_RGTC1_Format = 36283;
exports.RED_RGTC1_Format = RED_RGTC1_Format;
const SIGNED_RED_RGTC1_Format = 36284;
exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
const RED_GREEN_RGTC2_Format = 36285;
exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */

exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
/** @deprecated Use SRGBColorSpace in three.js r152+. */

exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const NoColorSpace = '';
exports.NoColorSpace = NoColorSpace;
const SRGBColorSpace = 'srgb';
exports.SRGBColorSpace = SRGBColorSpace;
const LinearSRGBColorSpace = 'srgb-linear';
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
const DisplayP3ColorSpace = 'display-p3';
exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
const LinearDisplayP3ColorSpace = 'display-p3-linear';
exports.LinearDisplayP3ColorSpace = LinearDisplayP3ColorSpace;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const NeverCompare = 512;
exports.NeverCompare = NeverCompare;
const LessCompare = 513;
exports.LessCompare = LessCompare;
const EqualCompare = 514;
exports.EqualCompare = EqualCompare;
const LessEqualCompare = 515;
exports.LessEqualCompare = LessEqualCompare;
const GreaterCompare = 516;
exports.GreaterCompare = GreaterCompare;
const NotEqualCompare = 517;
exports.NotEqualCompare = NotEqualCompare;
const GreaterEqualCompare = 518;
exports.GreaterEqualCompare = GreaterEqualCompare;
const AlwaysCompare = 519;
exports.AlwaysCompare = AlwaysCompare;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';
exports.GLSL3 = GLSL3;
const _SRGBAFormat = 1035; // fallback for WebGL 1

exports._SRGBAFormat = _SRGBAFormat;
const WebGLCoordinateSystem = 2000;
exports.WebGLCoordinateSystem = WebGLCoordinateSystem;
const WebGPUCoordinateSystem = 2001;
exports.WebGPUCoordinateSystem = WebGPUCoordinateSystem;

},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.BufferAttribute = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _MathUtils = require("../math/MathUtils.js");

var _constants = require("../constants.js");

var _DataUtils = require("../extras/DataUtils.js");

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _vector2 = /*@__PURE__*/new _Vector2.Vector2();

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = _constants.StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.gpuType = _constants.FloatType;
    this.version = 0;
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  copyArray(array) {
    this.array.set(array);
    return this;
  }

  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);

        _vector2.applyMatrix3(m);

        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector.fromBufferAttribute(this, i);

        _vector.applyMatrix3(m);

        this.setXYZ(i, _vector.x, _vector.y, _vector.z);
      }
    }

    return this;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyMatrix4(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyNormalMatrix(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.transformDirection(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  set(value, offset = 0) {
    // Matching BufferAttribute constructor, do not normalize the array.
    this.array.set(value, offset);
    return this;
  }

  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = (0, _MathUtils.denormalize)(value, this.array);
    return value;
  }

  setComponent(index, component, value) {
    if (this.normalized) value = (0, _MathUtils.normalize)(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }

  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }

  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }

  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }

  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }

  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== '') data.name = this.name;
    if (this.usage !== _constants.StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }

} //


exports.BufferAttribute = BufferAttribute;

class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }

}

exports.Int8BufferAttribute = Int8BufferAttribute;

class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }

}

exports.Uint8BufferAttribute = Uint8BufferAttribute;

class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }

}

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }

}

exports.Int16BufferAttribute = Int16BufferAttribute;

class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Uint16BufferAttribute = Uint16BufferAttribute;

class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }

}

exports.Int32BufferAttribute = Int32BufferAttribute;

class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }

}

exports.Uint32BufferAttribute = Uint32BufferAttribute;

class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }

  getX(index) {
    let x = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize]);
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = (0, _DataUtils.toHalfFloat)(x);
    return this;
  }

  getY(index) {
    let y = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  getZ(index) {
    let z = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  getW(index) {
    let w = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    this.array[index + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

}

exports.Float16BufferAttribute = Float16BufferAttribute;

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }

}

exports.Float32BufferAttribute = Float32BufferAttribute;

class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }

} //


exports.Float64BufferAttribute = Float64BufferAttribute;

},{"../constants.js":41,"../extras/DataUtils.js":47,"../math/MathUtils.js":50,"../math/Vector2.js":55,"../math/Vector3.js":56}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferGeometry = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _Box = require("../math/Box3.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _BufferAttribute = require("./BufferAttribute.js");

var _Sphere = require("../math/Sphere.js");

var _Object3D = require("./Object3D.js");

var _Matrix = require("../math/Matrix4.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _utils = require("../utils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _id = 0;

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _obj = /*@__PURE__*/new _Object3D.Object3D();

const _offset = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new _Box.Box3();

const _boxMorphTargets = /*@__PURE__*/new _Box.Box3();

const _vector = /*@__PURE__*/new _Vector.Vector3();

class BufferGeometry extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, 'id', {
      value: _id++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new ((0, _utils.arrayNeedsUint32)(index) ? _BufferAttribute.Uint32BufferAttribute : _BufferAttribute.Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }

  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }

  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  }

  clearGroups() {
    this.groups = [];
  }

  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }

  applyMatrix4(matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new _Matrix2.Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  }

  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  }

  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }

  setFromPoints(points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(position, 3));
    return this;
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new _Box.Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new _Vector.Vector3(-Infinity, -Infinity, -Infinity), new _Vector.Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(this.boundingBox.min, _box.min);

            this.boundingBox.expandByPoint(_vector);

            _vector.addVectors(this.boundingBox.max, _box.max);

            this.boundingBox.expandByPoint(_vector);
          } else {
            this.boundingBox.expandByPoint(_box.min);
            this.boundingBox.expandByPoint(_box.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new _Sphere.Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new _Vector.Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(_box.min, _boxMorphTargets.min);

            _box.expandByPoint(_vector);

            _vector.addVectors(_box.max, _boxMorphTargets.max);

            _box.expandByPoint(_vector);
          } else {
            _box.expandByPoint(_boxMorphTargets.min);

            _box.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }

  computeTangents() {
    const index = this.index;
    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;

    if (this.hasAttribute('tangent') === false) {
      this.setAttribute('tangent', new _BufferAttribute.BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    const tangents = this.getAttribute('tangent').array;
    const tan1 = [],
          tan2 = [];

    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new _Vector.Vector3();
      tan2[i] = new _Vector.Vector3();
    }

    const vA = new _Vector.Vector3(),
          vB = new _Vector.Vector3(),
          vC = new _Vector.Vector3(),
          uvA = new _Vector2.Vector2(),
          uvB = new _Vector2.Vector2(),
          uvC = new _Vector2.Vector2(),
          sdir = new _Vector.Vector3(),
          tdir = new _Vector.Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    let groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    const tmp = new _Vector.Vector3(),
          tmp2 = new _Vector.Vector3();
    const n = new _Vector.Vector3(),
          n2 = new _Vector.Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }

  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new _BufferAttribute.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new _Vector.Vector3(),
            pB = new _Vector.Vector3(),
            pC = new _Vector.Vector3();
      const nA = new _Vector.Vector3(),
            nB = new _Vector.Vector3(),
            nC = new _Vector.Vector3();
      const cb = new _Vector.Vector3(),
            ab = new _Vector.Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }

  normalizeNormals() {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector.fromBufferAttribute(normals, i);

      _vector.normalize();

      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
  }

  toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices[i] * itemSize;
        }

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new _BufferAttribute.BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.BufferGeometry = BufferGeometry;

},{"../math/Box3.js":48,"../math/MathUtils.js":50,"../math/Matrix3.js":51,"../math/Matrix4.js":52,"../math/Sphere.js":54,"../math/Vector2.js":55,"../math/Vector3.js":56,"../utils.js":57,"./BufferAttribute.js":42,"./EventDispatcher.js":44,"./Object3D.js":46}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventDispatcher = void 0;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  hasEventListener(type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }

      event.target = null;
    }
  }

}

exports.EventDispatcher = EventDispatcher;

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layers = void 0;

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }

}

exports.Layers = Layers;

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Object3D = void 0;

var _Quaternion = require("../math/Quaternion.js");

var _Vector = require("../math/Vector3.js");

var _Matrix = require("../math/Matrix4.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _Euler = require("../math/Euler.js");

var _Layers = require("./Layers.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _object3DId = 0;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _q1 = /*@__PURE__*/new _Quaternion.Quaternion();

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _target = /*@__PURE__*/new _Vector.Vector3();

const _position = /*@__PURE__*/new _Vector.Vector3();

const _scale = /*@__PURE__*/new _Vector.Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

const _xAxis = /*@__PURE__*/new _Vector.Vector3(1, 0, 0);

const _yAxis = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);

const _zAxis = /*@__PURE__*/new _Vector.Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

class Object3D extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new _Vector.Vector3();
    const rotation = new _Euler.Euler();
    const quaternion = new _Quaternion.Quaternion();
    const scale = new _Vector.Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new _Matrix.Matrix4()
      },
      normalMatrix: {
        value: new _Matrix2.Matrix3()
      }
    });
    this.matrix = new _Matrix.Matrix4();
    this.matrixWorld = new _Matrix.Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

    this.layers = new _Layers.Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }

  onBeforeRender() {}

  onAfterRender() {}

  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }

  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }

  setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  }

  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }

  setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  }

  setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  }

  rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  }

  rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  }

  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }

  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }

  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }

  translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1.multiplyScalar(distance));
    return this;
  }

  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }

  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }

  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }

  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }

  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  }

  lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1);

    if (parent) {
      _m1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1);

      this.quaternion.premultiply(_q1.invert());
    }
  }

  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  }

  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  }

  removeFromParent() {
    const parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  }

  clear() {
    return this.remove(...this.children);
  }

  attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
    this.updateWorldMatrix(true, false);

    _m1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }

  getObjectById(id) {
    return this.getObjectByProperty('id', id);
  }

  getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  }

  getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  }

  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value) result.push(this);

    for (let i = 0, l = this.children.length; i < l; i++) {
      const childResult = this.children[i].getObjectsByProperty(name, value);

      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }

    return result;
  }

  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }

  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  }

  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  }

  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }

  raycast() {}

  traverse(callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }

  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }

  traverseAncestors(callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }

  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }

  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];

      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }

  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];

        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }

  toJSON(meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }

      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  }

  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }

  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }

}

exports.Object3D = Object3D;
Object3D.DEFAULT_UP = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

},{"../math/Euler.js":49,"../math/MathUtils.js":50,"../math/Matrix3.js":51,"../math/Matrix4.js":52,"../math/Quaternion.js":53,"../math/Vector3.js":56,"./EventDispatcher.js":44,"./Layers.js":45}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataUtils = void 0;
exports.fromHalfFloat = fromHalfFloat;
exports.toHalfFloat = toHalfFloat;

var _MathUtils = require("../math/MathUtils.js");

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
const _tables = /*@__PURE__*/_generateTables();

function _generateTables() {
  // float32 to float16 helpers
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);

  for (let i = 0; i < 256; ++i) {
    const e = i - 127; // very small number (0, -0)

    if (e < -27) {
      baseTable[i] = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // small number (denorm)
    } else if (e < -14) {
      baseTable[i] = 0x0400 >> -e - 14;
      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
      shiftTable[i] = -e - 1;
      shiftTable[i | 0x100] = -e - 1; // normal number
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
    } else if (e < 128) {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
    } else {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;
    }
  } // float16 to float32 helpers


  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);

  for (let i = 1; i < 1024; ++i) {
    let m = i << 13; // zero pad mantissa bits

    let e = 0; // zero exponent
    // normalized

    while ((m & 0x00800000) === 0) {
      m <<= 1;
      e -= 0x00800000; // decrement exponent
    }

    m &= ~0x00800000; // clear leading 1 bit

    e += 0x38800000; // adjust bias

    mantissaTable[i] = m | e;
  }

  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
  }

  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }

  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;

  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 0x80000000 + (i - 32 << 23);
  }

  exponentTable[63] = 0xc7800000;

  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }

  return {
    floatView: floatView,
    uint32View: uint32View,
    baseTable: baseTable,
    shiftTable: shiftTable,
    mantissaTable: mantissaTable,
    exponentTable: exponentTable,
    offsetTable: offsetTable
  };
} // float32 to float16


function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
  val = (0, _MathUtils.clamp)(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 0x1ff;
  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
} // float16 to float32


function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}

const DataUtils = {
  toHalfFloat: toHalfFloat,
  fromHalfFloat: fromHalfFloat
};
exports.DataUtils = DataUtils;

},{"../math/MathUtils.js":50}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box3 = void 0;

var _Vector = require("./Vector3.js");

class Box3 {
  constructor(min = new _Vector.Vector3(+Infinity, +Infinity, +Infinity), max = new _Vector.Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    this.makeEmpty();

    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector.fromArray(array, i));
    }

    return this;
  }

  setFromBufferAttribute(attribute) {
    this.makeEmpty();

    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector.fromBufferAttribute(attribute, i));
    }

    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object, precise = false) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);

    if (object.boundingBox !== undefined) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }

      _box.copy(object.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    } else {
      const geometry = object.geometry;

      if (geometry !== undefined) {
        if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
          const position = geometry.attributes.position;

          for (let i = 0, l = position.count; i < l; i++) {
            _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }

          _box.copy(geometry.boundingBox);

          _box.applyMatrix4(object.matrixWorld);

          this.union(_box);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1, _v0);

    _f1.subVectors(_v2, _v1);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }

  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    return this.clampPoint(point, _vector).distanceTo(point);
  }

  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector).length() * 0.5;
    }

    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;
const _points = [/*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3()];

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new Box3(); // triangle centered vertices


const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3(); // triangle edge vectors


const _f0 = /*@__PURE__*/new _Vector.Vector3();

const _f1 = /*@__PURE__*/new _Vector.Vector3();

const _f2 = /*@__PURE__*/new _Vector.Vector3();

const _center = /*@__PURE__*/new _Vector.Vector3();

const _extents = /*@__PURE__*/new _Vector.Vector3();

const _triangleNormal = /*@__PURE__*/new _Vector.Vector3();

const _testAxis = /*@__PURE__*/new _Vector.Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the separating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }

  return true;
}

},{"./Vector3.js":56}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Euler = void 0;

var _Quaternion = require("./Quaternion.js");

var _Matrix = require("./Matrix4.js");

var _MathUtils = require("./MathUtils.js");

const _matrix = /*@__PURE__*/new _Matrix.Matrix4();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order = this._order, update = true) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    switch (order) {
      case 'XYZ':
        this._y = Math.asin((0, _MathUtils.clamp)(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-(0, _MathUtils.clamp)(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin((0, _MathUtils.clamp)(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-(0, _MathUtils.clamp)(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin((0, _MathUtils.clamp)(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-(0, _MathUtils.clamp)(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion.setFromEuler(this);

    return this.setFromQuaternion(_quaternion, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }

}

exports.Euler = Euler;
Euler.DEFAULT_ORDER = 'XYZ';

},{"./MathUtils.js":50,"./Matrix4.js":52,"./Quaternion.js":53}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RAD2DEG = exports.MathUtils = exports.DEG2RAD = void 0;
exports.ceilPowerOfTwo = ceilPowerOfTwo;
exports.clamp = clamp;
exports.damp = damp;
exports.degToRad = degToRad;
exports.denormalize = denormalize;
exports.euclideanModulo = euclideanModulo;
exports.floorPowerOfTwo = floorPowerOfTwo;
exports.generateUUID = generateUUID;
exports.inverseLerp = inverseLerp;
exports.isPowerOfTwo = isPowerOfTwo;
exports.lerp = lerp;
exports.mapLinear = mapLinear;
exports.normalize = normalize;
exports.pingpong = pingpong;
exports.radToDeg = radToDeg;
exports.randFloat = randFloat;
exports.randFloatSpread = randFloatSpread;
exports.randInt = randInt;
exports.seededRandom = seededRandom;
exports.setQuaternionFromProperEuler = setQuaternionFromProperEuler;
exports.smootherstep = smootherstep;
exports.smoothstep = smoothstep;
const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
exports.DEG2RAD = DEG2RAD;
const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

exports.RAD2DEG = RAD2DEG;

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.

  return uuid.toLowerCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s; // Mulberry32 generator

  let t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return value / 4294967295.0;

    case Uint16Array:
      return value / 65535.0;

    case Uint8Array:
      return value / 255.0;

    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);

    case Int16Array:
      return Math.max(value / 32767.0, -1.0);

    case Int8Array:
      return Math.max(value / 127.0, -1.0);

    default:
      throw new Error('Invalid component type.');
  }
}

function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return Math.round(value * 4294967295.0);

    case Uint16Array:
      return Math.round(value * 65535.0);

    case Uint8Array:
      return Math.round(value * 255.0);

    case Int32Array:
      return Math.round(value * 2147483647.0);

    case Int16Array:
      return Math.round(value * 32767.0);

    case Int8Array:
      return Math.round(value * 127.0);

    default:
      throw new Error('Invalid component type.');
  }
}

const MathUtils = {
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize
};
exports.MathUtils = MathUtils;

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix3 = void 0;

class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  invert() {
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  } //


  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }

  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }

  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  } // for 2D Transforms


  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
    }

    return this;
  }

  makeRotation(theta) {
    // counterclockwise
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y) {
    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  } //


  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

}

exports.Matrix3 = Matrix3;

const _m3 = /*@__PURE__*/new Matrix3();

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix4 = void 0;

var _constants = require("../constants.js");

var _Vector = require("./Vector3.js");

class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }

    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1.set(te[0], te[1], te[2]).length();

    const sy = _v1.set(te[4], te[5], te[6]).length();

    const sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _m1 = /*@__PURE__*/new Matrix4();

const _zero = /*@__PURE__*/new _Vector.Vector3(0, 0, 0);

const _one = /*@__PURE__*/new _Vector.Vector3(1, 1, 1);

const _x = /*@__PURE__*/new _Vector.Vector3();

const _y = /*@__PURE__*/new _Vector.Vector3();

const _z = /*@__PURE__*/new _Vector.Vector3();

},{"../constants.js":41,"./Vector3.js":56}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quaternion = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }

    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }

  random() {
    // Derived from http://planning.cs.uiuc.edu/node198.html
    // Note, this source uses w, x, y, z ordering,
    // so we swap the order below.
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  toJSON() {
    return this.toArray();
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }

}

exports.Quaternion = Quaternion;

},{"./MathUtils.js":50}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sphere = void 0;

var _Box = require("./Box3.js");

var _Vector = require("./Vector3.js");

const _box = /*@__PURE__*/new _Box.Box3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

class Sphere {
  constructor(center = new _Vector.Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }

    _v1.subVectors(point, this.center);

    const lengthSq = _v1.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      // calculate the minimal sphere
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1, delta / length);
      this.radius += delta;
    }

    return this;
  }

  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }

    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }

    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);

      this.expandByPoint(_v1.copy(sphere.center).add(_v2));
      this.expandByPoint(_v1.copy(sphere.center).sub(_v2));
    }

    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Sphere = Sphere;

},{"./Box3.js":48,"./Vector3.js":56}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector2 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }

}

exports.Vector2 = Vector2;

},{"./MathUtils.js":50}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector3 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

var _Quaternion = require("./Quaternion.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v) {
    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }

  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

  randomDirection() {
    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }

}

exports.Vector3 = Vector3;

const _vector = /*@__PURE__*/new Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

},{"./MathUtils.js":50,"./Quaternion.js":53}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMax = arrayMax;
exports.arrayMin = arrayMin;
exports.arrayNeedsUint32 = arrayNeedsUint32;
exports.createCanvasElement = createCanvasElement;
exports.createElementNS = createElementNS;
exports.getTypedArray = getTypedArray;
exports.warnOnce = warnOnce;

function arrayMin(array) {
  if (array.length === 0) return Infinity;
  let min = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] < min) min = array[i];
  }

  return min;
}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

function arrayNeedsUint32(array) {
  // assumes larger values usually on last
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }

  return false;
}

const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function createCanvasElement() {
  const canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}

const _cache = {};

function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sandbox = _interopRequireDefault(require("./lib/sandbox.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// handles code evaluation and attaching relevant objects to global and evaluation contexts
class EvalSandbox {
  constructor(parent, makeGlobal, userProps = []) {
    this.makeGlobal = makeGlobal;
    this.sandbox = (0, _sandbox.default)(parent);
    this.parent = parent;
    var properties = Object.keys(parent);
    properties.forEach(property => this.add(property));
    this.userProps = userProps;
  }

  add(name) {
    if (this.makeGlobal) window[name] = this.parent[name];
    this.sandbox.addToContext(name, `parent.${name}`);
  } // sets on window as well as synth object if global (not needed for objects, which can be set directly)


  set(property, value) {
    if (this.makeGlobal) {
      window[property] = value;
    }

    this.parent[property] = value;
  }

  tick() {
    if (this.makeGlobal) {
      this.userProps.forEach(property => {
        this.parent[property] = window[property];
      }); //  this.parent.speed = window.speed
    } else {}
  }

  eval(code) {
    this.sandbox.eval(code);
  }

}

var _default = EvalSandbox;
exports.default = _default;

},{"./lib/array-utils.js":70,"./lib/sandbox.js":75}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatArguments;

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [WIP] how to treat different dimensions (?)
const DEFAULT_CONVERSIONS = {
  float: {
    'vec4': {
      name: 'sum',
      args: [[1, 1, 1, 1]]
    },
    'vec2': {
      name: 'sum',
      args: [[1, 1]]
    }
  }
};

function fillArrayWithDefaults(arr, len) {
  // fill the array with default values if it's too short
  while (arr.length < len) {
    if (arr.length === 3) {
      // push a 1 as the default for .a in vec4
      arr.push(1.0);
    } else {
      arr.push(0.0);
    }
  }

  return arr.slice(0, len);
}

const ensure_decimal_dot = val => {
  val = val.toString();

  if (val.indexOf('.') < 0) {
    val += '.';
  }

  return val;
};

function formatArguments(transform, startIndex, synthContext) {
  const defaultArgs = transform.transform.inputs;
  const userArgs = transform.userArgs;
  const {
    generators
  } = transform.synth;
  const {
    src
  } = generators; // depends on synth having src() function

  return defaultArgs.map((input, index) => {
    const typedArg = {
      value: input.default,
      type: input.type,
      //
      isUniform: false,
      name: input.name,
      vecLen: 0 //  generateGlsl: null // function for creating glsl

    };
    if (typedArg.type === 'float') typedArg.value = ensure_decimal_dot(input.default);

    if (input.type.startsWith('vec')) {
      try {
        typedArg.vecLen = Number.parseInt(input.type.substr(3));
      } catch (e) {
        console.log(`Error determining length of vector input type ${input.type} (${input.name})`);
      }
    } // if user has input something for this argument


    if (userArgs.length > index) {
      typedArg.value = userArgs[index];

      if (typeof typedArg.value === 'function' && typedArg.value.name !== 'reglTexture2D' && typedArg.value.name !== 'reglFramebuffer') {
        typedArg.value = getFunctionValue(typedArg.value, input);
        typedArg.isUniform = true;
      } else if (typedArg.value.constructor === Array) {
        typedArg.value = getArrayValue(typedArg.value, input, typedArg.vecLen);
        typedArg.isUniform = true; // }
      }
    }

    if (startIndex < 0) {} else {
      if (typedArg.value && typedArg.value.transforms) {
        const final_transform = typedArg.value.transforms[typedArg.value.transforms.length - 1];

        if (final_transform.transform.glsl_return_type !== input.type) {
          const defaults = DEFAULT_CONVERSIONS[input.type];

          if (typeof defaults !== 'undefined') {
            const default_def = defaults[final_transform.transform.glsl_return_type];

            if (typeof default_def !== 'undefined') {
              const {
                name,
                args
              } = default_def;
              typedArg.value = typedArg.value[name](...args);
            }
          }
        }

        typedArg.isUniform = false;
      } else if (typedArg.type === 'float' && typeof typedArg.value === 'number') {
        typedArg.value = ensure_decimal_dot(typedArg.value);
      } else if (typedArg.type.startsWith('vec') && typeof typedArg.value !== 'function' && !typedArg.value.getTexture) {
        typedArg.isUniform = false;

        if (Array.isArray(typedArg.value) || typedArg.value instanceof Float32Array || typedArg.value instanceof Uint8Array) {
          // todo: accept smaller arrays?
          typedArg.value = `${typedArg.type}(${typedArg.value.map(ensure_decimal_dot).join(', ')})`;
        } else if (typeof typedArg.value === 'number') {
          const length = parseInt(typedArg.type.substr(-1));
          const arr = Array(length).fill(typedArg.value);
          typedArg.value = `${typedArg.type}(${arr.map(ensure_decimal_dot).join(', ')})`;
        }
      } else if (input.type === 'sampler2D') {
        // typedArg.tex = typedArg.value
        var x = typedArg.value;
        typedArg.value = x.getTexture ? () => x.getTexture() : x;
        typedArg.isUniform = true;
      } else {
        // if passing in a texture reference, when function asks for vec4, convert to vec4
        if (typedArg.value.getTexture || typedArg.value.name === 'reglTexture2D') {
          var x1 = typedArg.value;

          if (input.type === 'vec4') {
            typedArg.value = src(x1);
          } else {
            let getter = _types.getLookup[input.type];
            typedArg.value = src(x1)[getter];
          }

          typedArg.isUniform = false;
        }
      } // add tp uniform array if is a function that will pass in a different value on each render frame,
      // or a texture/ external source


      if (input.isUniform) typedArg.isUniform = input.isUniform;

      if (typedArg.isUniform) {
        typedArg.name += startIndex; //  shaderParams.uniforms.push(typedArg)
      }
    }

    return typedArg;
  });
}

function getFunctionValue(value, input) {
  // if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //    typedArg.value = (context, props, batchId) => (fillArrayWithDefaults(userArgs[index](props), typedArg.vecLen))
  // } else {
  return (context, props, batchId) => {
    try {
      const val = value(props);

      if (typeof val === 'number') {
        return val;
      } else {
        console.warn('function does not return a number', value);
      }

      return input.default;
    } catch (e) {
      console.warn('ERROR', e);
      return input.default;
    }
  }; //  }
}

function getArrayValue(value, input, vecLen = 0) {
  //   if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //     typedArg.isUniform = true
  //     typedArg.value = fillArrayWithDefaults(typedArg.value, typedArg.vecLen)
  //  } else {
  //  console.log("is Array")
  // filter out values that are not a number
  // const filteredArray = userArgs[index].filter((val) => typeof val === 'number')
  // typedArg.value = (context, props, batchId) => arrayUtils.getValue(filteredArray)(props)
  if (vecLen) {
    return (context, props, batchId) => {
      const values = Array(vecLen);

      for (let i = 0; i < vecLen; i++) {
        const v = value[i];
        const defaultValue = input.default ? input.default.constructor === Array ? input.default[i] : input.default : 0;

        if (typeof v === 'function') {
          values[i] = getFunctionValue(v, {
            default: defaultValue
          })(context, props, batchId);
        } else if (Array.isArray(v)) {
          values[i] = _arrayUtils.default.getValue(v)(props);
        } else if (typeof v !== 'undefined') {
          values[i] = v;
        } else {
          values[i] = defaultValue;
        }
      }

      return values;
    };
  } else {
    return (context, props, batchId) => _arrayUtils.default.getValue(value)(props);
  }
}

},{"./lib/array-utils.js":70,"./types.js":80}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatArguments = _interopRequireDefault(require("./format-arguments.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// converts a tree of javascript functions to a shader
function _default(source) {
  return generateParams(createParams(), source, source.transforms);
}

function createParams(options = {}) {
  return Object.assign({
    uniforms: [],
    // list of uniforms used in shader
    glslFunctions: [],
    // list of functions used in shader
    fragColor: '',
    position: ''
  }, options);
}

function generateParams(shaderParams, source, transforms) {
  if (!shaderParams.fragColor) {
    shaderParams.fragColor = generateGlsl(source, transforms, shaderParams, _types.typeLookup['src'].returnType)('st', 'vec4', 1.0);
  }

  if (!shaderParams.position && !shaderParams.combine) {
    shaderParams.position = generateGlsl(source, transforms.filter(tr => {
      return tr.transform.type !== 'combine' && tr.transform.type !== 'clear';
    }), shaderParams, _types.typeLookup['src'].returnType)('st', 'vec4', 1.0);
  } // remove uniforms with duplicate names


  if (shaderParams.uniforms) {
    let uniforms = {};
    shaderParams.uniforms.forEach(uniform => uniforms[uniform.name] = uniform);
    shaderParams.uniforms = Object.values(uniforms);
  }

  return shaderParams;
} // recursive function for generating shader string from object containing functions and user arguments. Order of functions in string depends on type of function
// to do: improve variable names


function generateGlsl(source, transforms, shaderParams) {
  // transform function that outputs a shader string corresponding to gl_FragColor
  const empty = () => '';

  var fragColor = empty;
  transforms.map((transform, i) => {
    if (transform.transform.type === 'vert' && !source.geometry) {
      source.setGeometry(transform.userArgs[0]);
      transform.userArgs = transform.userArgs.slice(1);
    }

    var inputs = (0, _formatArguments.default)(transform, shaderParams.uniforms.length);

    if (transform.transform.type === 'clear') {
      source.passes.unshift({
        clear: transform.transform.name,
        userArgs: inputs.map(i => i.value)
      });
      return;
    }

    inputs.forEach(input => {
      if (input.isUniform) shaderParams.uniforms.push(input);
    }); // add new glsl function to running list of functions

    if (!contains(transform, shaderParams.glslFunctions)) shaderParams.glslFunctions.push(transform); // current function for generating frag color shader code

    var f0 = fragColor;

    if (transform.transform.type === 'src' || transform.transform.type === 'vert') {
      fragColor = (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'coord') {
      fragColor = f0 === empty ? (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}` : (uv, returnType, alpha) => `${f0(`${shaderString(uv, transform, inputs, shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else if (transform.transform.type === 'color') {
      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}`, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combine') {
      // combining two generated shader strings (i.e. for blend, mult, add funtions)
      if (source.transforms[0].transform.vert || inputs[0].value && inputs[0].value.transforms && inputs[0].value.transforms[0].transform.vert) {
        const params = Object.assign({}, shaderParams, {
          fragColor: fragColor('st', 'vec4', 1.0) || 'vec4(0)'
        });
        Object.assign(shaderParams, createParams({
          glslFunctions: [transform],
          combine: true
        }));
        const trans = source.transforms.slice(0, source.transforms.indexOf(transform));
        source.passes.unshift(source.createPass(generateParams(params, source, trans), {
          framebuffer: source.output.temp[0]
        }));
        const temp0 = src(source.output.temp[0]);

        f0 = (uv, returnType, alpha) => `${generateGlsl(temp0, temp0.transforms, shaderParams)(uv, returnType, alpha)}`;
      }

      var f1;

      if (inputs[0].value && inputs[0].value.transforms) {
        if (inputs[0].value.transforms[0].transform.vert || source.transforms[0].transform.vert) {
          inputs[0].value.output = source.output;
          source.passes.unshift(...inputs[0].value.glsl({
            framebuffer: source.output.temp[1]
          }));
          const temp1 = src(source.output.temp[1]);

          f1 = (uv, returnType, alpha) => `${generateGlsl(temp1, temp1.transforms, shaderParams)(uv, returnType, alpha)}`;
        } else {
          f1 = (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}`;
        }
      } else {
        f1 = inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;
      }

      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combineCoord') {
      // combining two generated shader strings (i.e. for modulate functions)
      var f1 = inputs[0].value && inputs[0].value.transforms ? (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}` : inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;

      fragColor = (uv, returnType, alpha) => `${f0(`${shaderString(`${uv}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else {
      console.warn('no support for type: ' + transform.transform.type);
    }
  });

  if (source.getter) {
    var f2 = fragColor;

    fragColor = (uv, returnType, alpha) => (0, _types.castType)(f2(uv, returnType, alpha) + `.${source.getter}`, _types.getTypeLookup[source.getter], returnType, 1.0);
  }

  return fragColor;
} // assembles a shader string containing the arguments and the function name, i.e. 'osc(uv, frequency)'


function shaderString(uv, transform, inputs, shaderParams, returnType, alpha = 0.0) {
  const str = inputs.map(input => {
    if (input.isUniform) {
      return input.name;
    } else if (input.value && input.value.transforms) {
      // this by definition needs to be a generator, hence we start with 'st' as the initial value for generating the glsl fragment
      if (!input.value.getter && _types.typeLookup[input.value.transforms[0].transform.type] !== input.type) {
        // todo: add getter only if input.type is larger
        input.value.getter = _types.getLookup[input.type];
      }

      return `${generateGlsl(input.value, input.value.transforms, shaderParams)('st', input.type)}`;
    }

    return input.value;
  }).reduce((p, c) => `${p}, ${c}`, '');
  var func = `${transform.transform.glslName}(${uv}${str})`;
  return (0, _types.castType)(func, _types.typeLookup[transform.transform.type].returnType, returnType, alpha);
} // check whether array


function contains(object, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (object.name == arr[i].name) return true;
  }

  return false;
}

},{"./format-arguments.js":59,"./types.js":80}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

var _glslFunctions = _interopRequireDefault(require("./glsl/glsl-functions.js"));

var _vertFunctions = _interopRequireDefault(require("./glsl/vert-functions.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GeneratorFactory {
  constructor({
    defaultUniforms,
    defaultOutput,
    extendTransforms = [],
    changeListener = () => {}
  } = {}) {
    this.defaultOutput = defaultOutput;
    this.defaultUniforms = defaultUniforms;
    this.changeListener = changeListener;
    this.extendTransforms = extendTransforms;
    this.generators = {};
    this.utils = {};
    this.init();
  }

  init() {
    const functions = (0, _glslFunctions.default)();
    this.glslTransforms = {};
    this.generators = Object.entries(this.generators).reduce((prev, [method, transform]) => {
      this.changeListener({
        type: 'remove',
        synth: this,
        method
      });
      return prev;
    }, {});

    this.sourceClass = (() => {
      return class extends _glslSource.default {};
    })(); // add user definied transforms


    if (Array.isArray(this.extendTransforms)) {
      functions.concat(this.extendTransforms);
    } else if (typeof this.extendTransforms === 'object' && this.extendTransforms.type) {
      functions.push(this.extendTransforms);
    }

    functions.map(transform => this.setFunction(transform));
    const functions2 = (0, _vertFunctions.default)(this.generators); // sandbox is not ready at this moment yet

    functions2.map(transform => this.setFunction(transform));
  }

  _addMethod(method, transform) {
    const self = this;
    this.glslTransforms[method] = transform;
    let retval = undefined;

    if (['src', 'coord', 'clear', 'vert'].indexOf(transform.type) > -1) {
      const func = (...args) => new this.sourceClass({
        name: method,
        transform: transform,
        userArgs: args,
        defaultOutput: this.defaultOutput,
        defaultUniforms: this.defaultUniforms,
        synth: self,
        utils: this.utils
      });

      this.generators[method] = func;
      this.changeListener({
        type: 'add',
        synth: this,
        method
      });
      retval = func;
    }

    this.sourceClass.prototype[method] = function (...args) {
      const prevTransform = this.transforms[this.transforms.length - 1].transform;

      if (prevTransform.type === 'clear' || transform.type !== 'src' && transform.type !== 'vert') {
        this.transforms.push({
          name: method,
          transform: transform,
          userArgs: args,
          synth: self
        });
      } else {
        console.error(`transform ${transform.name} not allowed after ${prevTransform.name}`);
      }

      return this;
    };

    return retval;
  }

  setFunction(obj) {
    // todo: remove utils and instead manage function dependencies
    if (obj.type === 'util') this.utils[obj.name] = obj;
    var processedGlsl = processFunction(obj);
    if (processedGlsl) this._addMethod(obj.name, processedGlsl);
  }

} // expects glsl of format
// {
//   name: 'osc', // name that will be used to access function as well as within glsl
//   type: 'src', // can be src: vec4(vec2 _st), coord: vec2(vec2 _st), color: vec4(vec4 _c0), combine: vec4(vec4 _c0, vec4 _c1), combineCoord: vec2(vec2 _st, vec4 _c0)
//   inputs: [
//     {
//       name: 'freq',
//       type: 'float', // 'float'   //, 'texture', 'vec4'
//       default: 0.2
//     },
//     {
//           name: 'sync',
//           type: 'float',
//           default: 0.1
//         },
//         {
//           name: 'offset',
//           type: 'float',
//           default: 0.0
//         }
//   ],
//  glsl: `
//    vec2 st = _st;
//    float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//    float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//    float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//    return vec4(r, g, b, 1.0);
// `
// }
// // generates glsl function:
// `vec4 osc(vec2 _st, float freq, float sync, float offset){
//  vec2 st = _st;
//  float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//  float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//  float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//  return vec4(r, g, b, 1.0);
// }`


function processFunction(obj) {
  obj.glslName || (obj.glslName = obj.name);
  if (obj.type === 'clear') return obj;else if (obj.type === 'util') {
    return processGlsl(obj, obj.returnType);
  }
  let t = _types.typeLookup[obj.type];

  if (t) {
    return processGlsl(obj, t.returnType, t.args);
  } else {
    console.warn(`type ${obj.type} not recognized`, obj);
  }
}

function processGlsl(obj, returnType, args = []) {
  let baseArgs = args.map(arg => arg).join(", ");
  let customArgs = (obj.inputs || (obj.inputs = [])).map(input => `${input.type} ${input.name}`).join(', ');
  let allArgs = `${baseArgs}${customArgs.length > 0 ? ', ' + customArgs : ''}`;
  const func = `${returnType || ''} ${obj.glslName}(${allArgs}`;

  const fixOrWrap = glsl => {
    if (glsl.indexOf(func) === -1) {
      if (glsl.indexOf(`${returnType} main(${allArgs}`) > -1) {
        return glsl.replace(`${returnType} main(${allArgs}`, func);
      } else {
        if (obj.primitive) {
          let primitiveFn = obj.primitive.split(" ").join("");

          if (glsl.indexOf(primitiveFn) > -1) {
            return glsl.replace(`${returnType} ${primitiveFn}(${allArgs}`, func);
          }
        }

        if (returnType) {
          return `
  ${func}) {
      ${glsl}
  }
`;
        }
      }
    }

    return glsl;
  };

  obj.glsl = fixOrWrap(obj.glsl);

  if (obj.vert) {
    obj.vert = fixOrWrap(obj.vert);
  } // add extra input to beginning for backward combatibility @todo update compiler so this is no longer necessary


  if (obj.type === 'combine' || obj.type === 'combineCoord') obj.inputs.unshift({
    name: 'color',
    type: 'vec4'
  });
  return Object.assign({}, obj, {
    returnType
  });
}

var _default = GeneratorFactory;
exports.default = _default;

},{"./glsl-source.js":62,"./glsl/glsl-functions.js":64,"./glsl/vert-functions.js":66,"./types.js":80}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BufferGeometry = require("three/src/core/BufferGeometry.js");

var _generateGlsl = _interopRequireDefault(require("./generate-glsl.js"));

var _utilityFunctions = _interopRequireDefault(require("./glsl/utility-functions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GlslSource = function (obj) {
  this.transforms = [];
  this.transforms.push(obj);
  this.defaultOutput = obj.defaultOutput;
  this.output = null;
  this.synth = obj.synth;
  this.type = 'GlslSource';
  this.defaultUniforms = obj.defaultUniforms;
  this.utils = Object.assign({}, _utilityFunctions.default, obj.utils);
  this.blendMode = typeof obj.transform.blendMode !== 'undefined' ? obj.transform.blendMode : false;
  this.lineWidth = obj.transform.lineWidth || 1;
  this._viewport = {};
  return this;
};

GlslSource.prototype.addTransform = function (obj) {
  this.transforms.push(obj);
};

GlslSource.prototype.out = function (_output) {
  var output = _output || this.defaultOutput;
  this.output = output;
  var glsl = this.glsl();
  this.synth.currentFunctions = [];
  if (output) try {
    output.render(glsl);
  } catch (error) {
    console.log('shader could not compile', error);
  }
  return this;
};

GlslSource.prototype.tex = function (_output) {
  if (!this.output) {
    this.out(_output);
  }

  return this.output.renderTexture();
};

GlslSource.prototype.glsl = function (options = {}) {
  this.passes = [];
  this.passes.push(this.createPass((0, _generateGlsl.default)(this), options));
  return this.passes;
};

GlslSource.prototype.getInfo = function () {
  if (this.transforms.length > 0) {
    var shaderInfo = (0, _generateGlsl.default)(this);
    var uniforms = {};
    shaderInfo.uniforms.forEach(uniform => {
      uniforms[uniform.name] = uniform.value;
    });
    return {
      shaderInfo,
      utilityGlsl: this.utils,
      // todo: differs from compile
      vert: this.transforms[0].transform.vert,
      // todo: differs from compile
      attributes: this.transforms[0].transform.attributes,
      // todo: differs from compile
      attributesCount: this.transforms[0].transform.attributesCount,
      primitive: this.transforms[0].transform.primitive,
      uniforms: Object.assign({}, this.defaultUniforms, uniforms)
    };
  }
};

GlslSource.prototype.createPass = function (shaderInfo, options = {}) {
  var uniforms = {};
  shaderInfo.uniforms.forEach(uniform => {
    uniforms[uniform.name] = uniform.value;
  });

  if (shaderInfo.combine) {
    return {
      vert: GlslSource.compileVert(this.defaultOutput.precision, false, {
        glslName: 'combine'
      }, shaderInfo),
      userArgs: this.transforms[0].userArgs,
      // todo: fix or delete
      // blendMode: this.blendMode,
      lineWidth: this.lineWidth,
      frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
      uniforms: Object.assign({}, this.defaultUniforms, uniforms),
      viewport: this._viewport
    };
  }

  const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
  return Object.assign({
    vert: GlslSource.compileVert(this.defaultOutput.precision, true, vertTransform.transform, shaderInfo, this.utils),
    primitive: vertTransform.transform.primitive,
    userArgs: vertTransform.userArgs,
    geometry: this.geometry,
    blendMode: this.blendMode,
    lineWidth: this.lineWidth,
    frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
    uniforms: Object.assign({}, this.defaultUniforms, uniforms),
    viewport: this._viewport
  }, options);
};

GlslSource.compileHeader = function (precision, uniforms = {}, utils = {}) {
  return `
  precision ${precision} float;
  ${Object.values(uniforms).map(uniform => {
    let type = uniform.type;

    switch (uniform.type) {
      case 'texture':
        type = 'sampler2D';
        break;
    }

    return `
      uniform ${type} ${uniform.name};`;
  }).join('')}
  uniform float time;
  uniform vec2 resolution;
  varying vec2 vuv;
  uniform sampler2D prevBuffer;
  
  ${Object.values(utils).map(transform => {
    //  console.log(transform.glsl)
    return `
            ${transform.glsl}
          `;
  }).join('')}
  `;
};

GlslSource.compileFrag = function (precision, shaderInfo, utils) {
  const header = this.compileHeader(precision, shaderInfo.uniforms, utils);
  return header + `
  
  ${shaderInfo.glslFunctions.map(transform => {
    return `
            ${transform.transform.glsl}
          `;
  }).join('')}

  void main () {
    vec4 c = vec4(1, 0, 0, 1);
    //vec2 st = gl_FragCoord.xy/resolution.xy;
    vec2 st = vuv;
    gl_FragColor = ${shaderInfo.fragColor};
  }
  `;
};

GlslSource.compileVert = function (precision, useCamera, transform, shaderInfo, utils) {
  const useUV = typeof transform.useUV !== 'undefined' ? transform.useUV : ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1;
  let vertHeader = `
  precision ${precision} float;
  uniform mat4 projection, view;
  attribute vec3 position;
  ${useUV ? 'attribute vec2 uv;' : ''}
  varying vec2 vuv;
  `;
  let vertFn = `
  void ${transform.glslName}() {
    gl_Position = ${useCamera ? 'projection * view * ' : ''}vec4(position, 1.0);
  } 
  `;
  let vertCall = `${transform.glslName}();`;

  if (transform.vert) {
    vertHeader = this.compileHeader(precision, shaderInfo.uniforms, utils) + `
    uniform mat4 projection, view;
    attribute vec3 position;
    ${useUV ? 'attribute vec2 uv;' : ''}
    attribute vec3 normal;
    
    ${shaderInfo.glslFunctions.map(trans => {
      if (trans.transform.name !== transform.name) {
        return `
            ${trans.transform.glsl}
          `;
      }
    }).join('')}
    `;
    vertFn = transform.vert;
    vertCall = `
    ${useUV ? 'vec2 st = uv;' : 'vec2 st = position.xy;'}
    vec4 pos = ${shaderInfo.position};
    gl_Position = projection * view * pos;
    `;
  }

  return vertHeader + `
    
  ${vertFn}

  void main () {
    ${useUV ? 'vuv = uv;' : ''}
    ${vertCall}
  }`;
}; // todo: make hydra-synth function


GlslSource.prototype.setBlend = function (blendMode = true) {
  this.blendMode = blendMode;
  return this;
};

GlslSource.prototype.setLineWidth = function (lineWidth) {
  this.lineWidth = lineWidth;
  return this;
};

GlslSource.prototype.setGeometry = function (input) {
  if (!input) input = [];

  if (!(input instanceof _BufferGeometry.BufferGeometry || input.isBufferGeometry)) {
    const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
    if (!Array.isArray(input)) input = [input];

    if (vertTransform.transform.geometry === GridGeometry && vertTransform.transform.primitive && typeof input[0] !== 'string') {
      input.unshift(vertTransform.transform.primitive);
    }

    input = new vertTransform.transform.geometry(...input);
  }

  this.geometry = input;
};

GlslSource.prototype.viewport = function (x, y, w, h) {
  this._viewport = {
    x,
    y,
    w,
    h
  };
  return this;
};

const glslProps = ['x', 'y', 'z', 'xy', 'xz', 'yx', 'yz', 'zx', 'zy', 'xyz', 'xyzw'];
glslProps.map(prop => {
  Object.defineProperty(GlslSource.prototype, prop, {
    get() {
      this.getter = prop;
      return this;
    }

  });
});
var _default = GlslSource;
exports.default = _default;

},{"./generate-glsl.js":60,"./glsl/utility-functions.js":65,"three/src/core/BufferGeometry.js":43}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridGeometry = void 0;

var _BufferGeometry = require("three/src/core/BufferGeometry");

var _BufferAttribute = require("three/src/core/BufferAttribute");

class GridGeometry extends _BufferGeometry.BufferGeometry {
  constructor(type, width, height, options) {
    super();
    this.type = 'GridGeometry';
    this.parameters = {
      primitive: type,
      width: width,
      height: height,
      options: options
    };
    let vertices;

    switch (type) {
      case 'points':
        {
          width || (width = 1);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return (k + 1) / 3 % width / width;

              case 1:
                return (Math.floor((k - 1) / 3 / width) + 0.5) / height;

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'lines':
        {
          width || (width = 1);
          height || (height = 1);
          const count = 2 * (width + height);
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            if (k < width * 6) {
              switch (k % 6) {
                case 0:
                  return (k + 3) / 6 % width / width;

                case 1:
                  return 0.0001;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return k / 6 % width / width;

                case 4:
                  return 0.9999;
              }
            } else {
              switch (k % 6) {
                case 0:
                  return 0.0001;

                case 1:
                  return (k + 2) / 6 % height / height;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return 0.9999;

                case 4:
                  return (k - 1) / 6 % height / height;
              }
            }
          });
          break;
        }

      case 'line strip':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          const closed = typeof options === 'undefined' ? true : options;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            // todo: will be NaN when points[0] == 1
            // todo: minimum 2 points?
            switch (k % 3) {
              case 0:
                return k / 3 % width / (width - closed);

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'line loop':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return k / 3 % width / width;

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      default:
        console.error(`invalid GridGeometry type: ${type}`);
        break;
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
  }

}

exports.GridGeometry = GridGeometry;

},{"three/src/core/BufferAttribute":42,"three/src/core/BufferGeometry":43}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
Format for adding functions to hydra. For each entry in this file, hydra automatically generates a glsl function and javascript function with the same name. You can also ass functions dynamically using setFunction(object).

{
  name: 'osc', // name that will be used to access function in js as well as in glsl
  type: 'src', // can be 'src', 'color', 'combine', 'combineCoords'. see below for more info
  inputs: [
    {
      name: 'freq',
      type: 'float',
      default: 0.2
    },
    {
      name: 'sync',
      type: 'float',
      default: 0.1
    },
    {
      name: 'offset',
      type: 'float',
      default: 0.0
    }
  ],
    glsl: `
      vec2 st = _st;
      float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
      float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
      float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
      return vec4(r, g, b, 1.0);
   `
}

// The above code generates the glsl function:
`vec4 osc(vec2 _st, float freq, float sync, float offset){
 vec2 st = _st;
 float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
 float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
 float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
 return vec4(r, g, b, 1.0);
}`


Types and default arguments for hydra functions.
The value in the 'type' field lets the parser know which type the function will be returned as well as default arguments.

const types = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
}

*/
var _default = () => [{
  name: 'clear',
  type: 'clear',
  inputs: [],
  glsl: ``
}, {
  name: 'fade',
  type: 'clear',
  inputs: [{
    name: 'amount',
    type: 'float',
    default: '0.01'
  }, {
    name: 'camera',
    type: 'bool',
    default: false
  }],
  glsl: ``
}, {
  name: 'noise',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 0.1
  }],
  glsl: `   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);`
}, {
  name: 'voronoi',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 5
  }, {
    type: 'float',
    name: 'speed',
    default: 0.3
  }, {
    type: 'float',
    name: 'blending',
    default: 0.3
  }],
  glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
}, {
  name: 'osc',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'frequency',
    default: 60
  }, {
    type: 'float',
    name: 'sync',
    default: 0.1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
}, {
  name: 'shape',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'sides',
    default: 3
  }, {
    type: 'float',
    name: 'radius',
    default: 0.3
  }, {
    type: 'float',
    name: 'smoothing',
    default: 0.01
  }],
  glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
}, {
  name: 'gradient',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   return vec4(_st, sin(time*speed), 1.0);`
}, {
  name: 'src',
  type: 'src',
  inputs: [{
    type: 'sampler2D',
    name: 'tex',
    default: NaN
  }],
  glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
}, {
  name: 'solid',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   return vec4(r, g, b, a);`
}, {
  name: 'rotate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'angle',
    default: 10
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `  vec2 xy = _st - vec2(0.5);
   // Convert degrees to radians
   float ang = angle * (3.141592653589793 / 180.0);
   ang = ang + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'scale',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.5
  }, {
    type: 'float',
    name: 'xMult',
    default: 1
  }, {
    type: 'float',
    name: 'yMult',
    default: 1
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
}, {
  name: 'pixelate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'pixelX',
    default: 20
  }, {
    type: 'float',
    name: 'pixelY',
    default: 20
  }],
  glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'posterize',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'bins',
    default: 3
  }, {
    type: 'float',
    name: 'gamma',
    default: 0.6
  }],
  glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
}, {
  name: 'shift',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0.5
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 0
  }],
  glsl: `   vec4 c2 = vec4(_c0);
   c2.r = fract(c2.r + r);
   c2.g = fract(c2.g + g);
   c2.b = fract(c2.b + b);
   c2.a = fract(c2.a + a);
   return vec4(c2.rgba);`
}, {
  name: 'repeat',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) * offsetX;
   st.y += step(1., mod(st.x,2.0)) * offsetY;
   return fract(st);`
}, {
  name: 'modulateRepeat',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
}, {
  name: 'repeatX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'repeatY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'kaleid',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
}, {
  name: 'modulateKaleid',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
}, {
  name: 'scroll',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speedX',
    default: 0
  }, {
    type: 'float',
    name: 'speedY',
    default: 0
  }],
  glsl: `
   _st.x += scrollX + time*speedX;
   _st.y += scrollY + time*speedY;
   return fract(_st);`
}, {
  name: 'scrollX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'scrollY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'add',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0+_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'sub',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0-_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'layer',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));`
}, {
  name: 'blend',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.5
  }],
  glsl: `   return _c0*(1.0-amount)+_c1*amount;`
}, {
  name: 'mult',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _c0*(1.0-amount)+(_c0*_c1)*amount;`
}, {
  name: 'diff',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));`
}, {
  name: 'modulate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.1
  }],
  glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
}, {
  name: 'modulateScale',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 1
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
}, {
  name: 'modulatePixelate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 3
  }],
  glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'modulateRotate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'modulateHue',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);`
}, {
  name: 'invert',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);`
}, {
  name: 'contrast',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.6
  }],
  glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
}, {
  name: 'brightness',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.4
  }],
  glsl: `   return vec4(_c0.rgb + vec3(amount), _c0.a);`
}, {
  name: 'mask',
  type: 'combine',
  inputs: [],
  glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
}, {
  name: 'luma',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.1
  }],
  glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
}, {
  name: 'thresh',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.04
  }],
  glsl: `   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);`
}, {
  name: 'color',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 1
  }, {
    type: 'float',
    name: 'g',
    default: 1
  }, {
    type: 'float',
    name: 'b',
    default: 1
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
}, {
  name: 'saturate',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 2
  }],
  glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
}, {
  name: 'hue',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'hue',
    default: 0.4
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
}, {
  name: 'colorama',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.005
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
}, {
  name: 'prev',
  type: 'src',
  inputs: [],
  glsl: `   return texture2D(prevBuffer, fract(_st));`
}, {
  name: 'sum',
  type: 'color',
  inputs: [{
    type: 'vec4',
    name: 'scale',
    default: 1
  }],
  glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
}, {
  name: 'r',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.r * scale + offset);`
}, {
  name: 'g',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.g * scale + offset);`
}, {
  name: 'b',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.b * scale + offset);`
}, {
  name: 'a',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.a * scale + offset);`
}, {
  name: 'map',
  type: 'color',
  inputs: [{
    name: 'start1',
    type: 'float',
    default: NaN
  }, {
    name: 'stop1',
    type: 'float',
    default: NaN
  }, {
    name: 'start2',
    type: 'float',
    default: 0
  }, {
    name: 'stop2',
    type: 'float',
    default: 1
  }],
  glsl: `return (_c0 - start1) / (stop1 - start1) * (stop2 - start2) + start2;`
}, // todo: make these type: 'util' so they are type agnostic?
{
  name: 'sin',
  glslName: '_sin',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return sin(_st * TWO_PI * freq) * amp;`
}, {
  name: 'cos',
  glslName: '_cos',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return cos(_st * TWO_PI * freq) * amp;`
}, {
  name: 'tan',
  glslName: '_tan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return tan(_st * PI * freq) * amp;`
}, {
  name: 'atan',
  glslName: '_atan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return atan(_st * PI * freq) * amp;`
}, {
  name: 'pow',
  glslName: '_pow',
  type: 'coord',
  inputs: [{
    name: 'power',
    type: 'vec2',
    default: 2
  }],
  glsl: `return pow(_st, power);`
}];

exports.default = _default;

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// functions that are only used within other functions
var _default = {
  _pi: {
    type: 'util',
    glsl: `#define PI 3.1415926535897932384626433832795`
  },
  _twopi: {
    type: 'util',
    glsl: `#define TWO_PI 6.283185307179586`
  },
  _luminance: {
    type: 'util',
    glsl: `float _luminance(vec3 rgb){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      return dot(rgb, W);
    }`
  },
  _permute: {
    type: 'util',
    glsl: `vec4 _permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}`
  },
  _mod289: {
    type: 'util',
    glsl: `
vec3 _mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 _mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}
`
  },
  _taylorInvSqrt: {
    type: 'util',
    glsl: `vec4 _taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}`
  },
  //	Simplex 3D Noise
  //	by Ian McEwan, Ashima Arts
  _noise: {
    type: 'util',
    glsl: `
  float _noise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = _permute( _permute( _permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
    `
  },
  _rgbToHsv: {
    type: 'util',
    glsl: `vec3 _rgbToHsv(vec3 c){
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }`
  },
  _hsvToRgb: {
    type: 'util',
    glsl: `vec3 _hsvToRgb(vec3 c){
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }`
  }
};
exports.default = _default;

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GridGeometry = require("./geometries/GridGeometry.js");

const glsl = require("glslify");

const dotsFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 dots(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist = 0.5;\n    outColor.a = (1.0 - smoothstep(maxDist - fade, maxDist, dist)) * outColor.a;\n    if (outColor.a <= 0.0 || dist >= maxDist) {\n        discard;\n    }\n    return outColor;\n}"]);
const pointsVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_POINTS\nvec4 points(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vPos = pos;\n    vSize = size;\n    vColor = color;\n    gl_PointSize = vSize;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const squaresFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 squares(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist;\n    // todo: need to be based on angle\n    //maxDist = length(vec2(0.5, 0.5));\n    //outColor.a = 1.0 - smoothstep(maxDist - fade, maxDist, dist);\n    return outColor;\n}"]);
const linesFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    return outColor;\n}"]);
const linesVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_LINES\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linestripFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const linestripVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - position.x);\n    vColor.a = vColor.a * ceil(position.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const lineloopFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const lineloopVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
Object.assign(window, {
  GridGeometry: _GridGeometry.GridGeometry
});

var _default = hy => [{
  name: 'dots',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 10
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: dotsFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'squares',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 1
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: squaresFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'lines',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: linesFrag,
  vert: linesVert,
  primitive: 'lines',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'linestrip',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: linestripFrag,
  vert: linestripVert,
  primitive: 'line strip',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'lineloop',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: lineloopFrag,
  vert: lineloopVert,
  primitive: 'line loop',
  geometry: _GridGeometry.GridGeometry
}];

exports.default = _default;

},{"./geometries/GridGeometry.js":63,"glslify":32}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _webcam = _interopRequireDefault(require("./lib/webcam.js"));

var _screenmedia = _interopRequireDefault(require("./lib/screenmedia.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HydraSource {
  constructor({
    regl,
    width,
    height,
    pb,
    label = ""
  }) {
    this.label = label;
    this.regl = regl;
    this.src = null;
    this.dynamic = true;
    this.width = width;
    this.height = height;
    this.tex = this.regl.texture({
      //  shape: [width, height]
      shape: [1, 1]
    });
    this.pb = pb;
  }

  init(opts, params) {
    if ('src' in opts) {
      this.src = opts.src;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    }

    if ('dynamic' in opts) this.dynamic = opts.dynamic;
  }

  initCam(index, params) {
    const self = this;
    (0, _webcam.default)(index).then(response => {
      self.src = response.video;
      self.dynamic = true;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
    }).catch(err => console.log('could not get camera', err));
  }

  initVideo(url = '', params) {
    // const self = this
    const vid = document.createElement('video');
    vid.crossOrigin = 'anonymous';
    vid.autoplay = true;
    vid.loop = true;
    vid.muted = true; // mute in order to load without user interaction

    const onload = vid.addEventListener('loadeddata', () => {
      this.src = vid;
      vid.play();
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
      this.dynamic = true;
    });
    vid.src = url;
  }

  initImage(url = '', params) {
    const img = document.createElement('img');
    img.crossOrigin = 'anonymous';
    img.src = url;

    img.onload = () => {
      this.src = img;
      this.dynamic = false;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    };
  }

  initStream(streamName, params) {
    //  console.log("initing stream!", streamName)
    let self = this;

    if (streamName && this.pb) {
      this.pb.initSource(streamName);
      this.pb.on('got video', function (nick, video) {
        if (nick === streamName) {
          self.src = video;
          self.dynamic = true;
          self.tex = self.regl.texture({
            data: self.src,
            ...params
          });
        }
      });
    }
  } // index only relevant in atom-hydra + desktop apps


  initScreen(index = 0, params) {
    const self = this;
    (0, _screenmedia.default)().then(function (response) {
      self.src = response.video;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
      self.dynamic = true; //  console.log("received screen input")
    }).catch(err => console.log('could not get screen', err));
  }

  resize(width, height) {
    this.width = width;
    this.height = height;
  }

  clear() {
    if (this.src && this.src.srcObject) {
      if (this.src.srcObject.getTracks) {
        this.src.srcObject.getTracks().forEach(track => track.stop());
      }
    }

    this.src = null;
    this.tex = this.regl.texture({
      shape: [1, 1]
    });
  }

  tick(time) {
    //  console.log(this.src, this.tex.width, this.tex.height)
    if (this.src !== null && this.dynamic === true) {
      if (this.src.videoWidth && this.src.videoWidth !== this.tex.width) {
        console.log(this.src.videoWidth, this.src.videoHeight, this.tex.width, this.tex.height);
        this.tex.resize(this.src.videoWidth, this.src.videoHeight);
      }

      if (this.src.width && this.src.width !== this.tex.width) {
        this.tex.resize(this.src.width, this.src.height);
      }

      this.tex.subimage(this.src);
    }
  }

  getTexture() {
    return this.tex;
  }

}

var _default = HydraSource;
exports.default = _default;

},{"./lib/screenmedia.js":76,"./lib/webcam.js":78}],68:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _output = _interopRequireDefault(require("./output.js"));

var _rafLoop = _interopRequireDefault(require("raf-loop"));

var _hydraSource = _interopRequireDefault(require("./hydra-source.js"));

var _mouse = _interopRequireDefault(require("./lib/mouse.js"));

var _audio = _interopRequireDefault(require("./lib/audio.js"));

var _videoRecorder = _interopRequireDefault(require("./lib/video-recorder.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _evalSandbox = _interopRequireDefault(require("./eval-sandbox.js"));

var _generatorFactory = _interopRequireDefault(require("./generator-factory.js"));

var _regl = _interopRequireDefault(require("regl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import strudel from './lib/strudel.js'
// const window = global.window
const Mouse = (0, _mouse.default)(); // to do: add ability to pass in certain uniforms and transforms

class HydraRenderer {
  constructor({
    pb = null,
    width = 1280,
    height = 720,
    numSources = 4,
    numOutputs = 4,
    makeGlobal = true,
    autoLoop = true,
    detectAudio = true,
    enableStreamCapture = true,
    canvas,
    precision,
    extendTransforms = {} // add your own functions on init

  } = {}) {
    _arrayUtils.default.init();

    this.pb = pb;
    this.width = width;
    this.height = height;
    this.renderAll = false;
    this.detectAudio = detectAudio;

    this._initCanvas(canvas);

    global.window.test = 'hi'; // object that contains all properties that will be made available on the global context and during local evaluation

    this.synth = {
      time: 0,
      bpm: 30,
      width: this.width,
      height: this.height,
      fps: undefined,
      stats: {
        fps: 0
      },
      speed: 1,
      mouse: Mouse,
      render: this._render.bind(this),
      setResolution: this.setResolution.bind(this),
      update: dt => {},
      // user defined update function
      hush: this.hush.bind(this),
      tick: this.tick.bind(this)
    };
    if (makeGlobal) window.loadScript = this.loadScript;
    this.timeSinceLastUpdate = 0;
    this._time = 0; // for internal use, only to use for deciding when to render frames
    // only allow valid precision options

    let precisionOptions = ['lowp', 'mediump', 'highp'];

    if (precision && precisionOptions.includes(precision.toLowerCase())) {
      this.precision = precision.toLowerCase(); //
      // if(!precisionValid){
      //   console.warn('[hydra-synth warning]\nConstructor was provided an invalid floating point precision value of "' + precision + '". Using default value of "mediump" instead.')
      // }
    } else {
      let isIOS = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream;
      this.precision = isIOS ? 'highp' : 'mediump';
    }

    this.extendTransforms = extendTransforms; // boolean to store when to save screenshot

    this.saveFrame = false; // if stream capture is enabled, this object contains the capture stream

    this.captureStream = null;
    this.generator = undefined;

    this._initRegl();

    this._initOutputs(numOutputs);

    this._initSources(numSources);

    this._generateGlslTransforms();

    this.synth.screencap = () => {
      this.saveFrame = true;
    };

    if (enableStreamCapture) {
      try {
        this.captureStream = this.canvas.captureStream(25); // to do: enable capture stream of specific sources and outputs

        this.synth.vidRecorder = new _videoRecorder.default(this.captureStream);
      } catch (e) {
        console.warn('[hydra-synth warning]\nnew MediaSource() is not currently supported on iOS.');
        console.error(e);
      }
    }

    if (detectAudio) this._initAudio();
    if (autoLoop) (0, _rafLoop.default)(this.tick.bind(this)).start(); // final argument is properties that the user can set, all others are treated as read-only

    this.sandbox = new _evalSandbox.default(this.synth, makeGlobal, ['speed', 'update', 'bpm', 'fps']);
  }

  eval(code) {
    this.sandbox.eval(code);
  }

  getScreenImage(callback) {
    this.imageCallback = callback;
    this.saveFrame = true;
  }

  hush() {
    this.s.forEach(source => {
      source.clear();
    });
    this.o.forEach(output => {
      this.synth.solid(0, 0, 0, 0).out(output);
    });
    this.synth.render(this.o[0]); // this.synth.update = (dt) => {}

    this.sandbox.set('update', dt => {});
  }

  loadScript(url = "", once = true) {
    const self = this || window;
    const p = new Promise((res, rej) => {
      if (once) {
        self.loadedScripts || (self.loadedScripts = {});

        if (self.loadedScripts[url]) {
          res();
          return;
        }
      }

      var script = document.createElement("script");

      script.onload = function () {
        console.log(`loaded script ${url}`);

        if (once) {
          self.loadedScripts[url] = true;
        }

        res();
      };

      script.onerror = err => {
        console.log(`error loading script ${url}`, "log-error");
        res();
      };

      script.src = url;
      document.head.appendChild(script);
    });
    return p;
  }

  setResolution(width, height) {
    //  console.log(width, height)
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width; // is this necessary?

    this.height = height; // ?

    this.sandbox.set('width', width);
    this.sandbox.set('height', height);
    this.o.forEach(output => {
      output.resize(width, height);
    });
    this.s.forEach(source => {
      source.resize(width, height);
    });

    this.regl._refresh();

    console.log(this.canvas.width);
  }

  canvasToImage(callback) {
    const a = document.createElement('a');
    a.style.display = 'none';
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.png`;
    document.body.appendChild(a);
    var self = this;
    this.canvas.toBlob(blob => {
      if (self.imageCallback) {
        self.imageCallback(blob);
        delete self.imageCallback;
      } else {
        a.href = URL.createObjectURL(blob);
        console.log(a.href);
        a.click();
      }
    }, 'image/png');
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(a.href);
    }, 300);
  }

  _initAudio() {
    const that = this;
    this.synth.a = new _audio.default({
      numBins: 4,
      parentEl: this.canvas.parentNode // changeListener: ({audio}) => {
      //   that.a = audio.bins.map((_, index) =>
      //     (scale = 1, offset = 0) => () => (audio.fft[index] * scale + offset)
      //   )
      //
      //   if (that.makeGlobal) {
      //     that.a.forEach((a, index) => {
      //       const aname = `a${index}`
      //       window[aname] = a
      //     })
      //   }
      // }

    });
  } // create main output canvas and add to screen


  _initCanvas(canvas) {
    if (canvas) {
      this.canvas = canvas;
      this.width = canvas.width;
      this.height = canvas.height;
    } else {
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.canvas.style.imageRendering = 'pixelated';
      document.body.appendChild(this.canvas);
    }
  }

  _initRegl() {
    this.regl = (0, _regl.default)({
      //  profile: true,
      canvas: this.canvas,
      pixelRatio: 1 //,
      // extensions: [
      //   'oes_texture_half_float',
      //   'oes_texture_half_float_linear'
      // ],
      // optionalExtensions: [
      //   'oes_texture_float',
      //   'oes_texture_float_linear'
      //]

    }); // This clears the color buffer to black and the depth buffer to 1

    this.regl.clear({
      color: [0, 0, 0, 1]
    });
    this.renderAll = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;
      uniform sampler2D tex1;
      uniform sampler2D tex2;
      uniform sampler2D tex3;

      void main () {
        vec2 st = vec2(1.0 - uv.x, uv.y);
        st*= vec2(2);
        vec2 q = floor(st).xy*(vec2(2.0, 1.0));
        int quad = int(q.x) + int(q.y);
        st.x += step(1., mod(st.y,2.0));
        st.y += step(1., mod(st.x,2.0));
        st = fract(st);
        if(quad==0){
          gl_FragColor = texture2D(tex0, st);
        } else if(quad==1){
          gl_FragColor = texture2D(tex1, st);
        } else if (quad==2){
          gl_FragColor = texture2D(tex2, st);
        } else {
          gl_FragColor = texture2D(tex3, st);
        }

      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        tex1: this.regl.prop('tex1'),
        tex2: this.regl.prop('tex2'),
        tex3: this.regl.prop('tex3')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
    this.renderFbo = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform vec2 resolution;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, vec2(1.0 - uv.x, uv.y));
      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        resolution: this.regl.prop('resolution')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
  }

  _initOutputs(numOutputs) {
    const self = this;
    this.o = Array(numOutputs).fill().map((el, index) => {
      var o = new _output.default(index, this);
      self.synth['o' + index] = o;
      return o;
    }); // set default output

    this.output = this.o[0];
  }

  _initSources(numSources) {
    this.s = [];

    for (var i = 0; i < numSources; i++) {
      this.createSource(i);
    }
  }

  createSource(i) {
    let s = new _hydraSource.default({
      regl: this.regl,
      pb: this.pb,
      width: this.width,
      height: this.height,
      label: `s${i}`
    });
    this.synth['s' + this.s.length] = s;
    this.s.push(s);
    return s;
  }

  _generateGlslTransforms() {
    var self = this;
    this.generator = new _generatorFactory.default({
      defaultOutput: this.o[0],
      defaultUniforms: this.o[0].uniforms,
      extendTransforms: this.extendTransforms,
      changeListener: ({
        type,
        method,
        synth
      }) => {
        if (type === 'add') {
          self.synth[method] = synth.generators[method];
          if (self.sandbox) self.sandbox.add(method);
        } else if (type === 'remove') {// what to do here? dangerously deleting window methods
          //delete window[method]
        } //  }

      }
    });
    this.synth.setFunction = this.generator.setFunction.bind(this.generator);
  }

  _render(output) {
    if (output) {
      this.output = output;
      this.isRenderingAll = false;
    } else {
      this.isRenderingAll = true;
    }
  }

  _renderOut(i) {
    this.o[i].tick({
      time: this.synth.time,
      mouse: this.synth.mouse,
      bpm: this.synth.bpm,
      resolution: [this.canvas.width, this.canvas.height]
    });
  } // dt in ms


  tick(dt, uniforms) {
    this.sandbox.tick();
    if (this.detectAudio === true) this.synth.a.tick(); //  let updateInterval = 1000/this.synth.fps // ms

    this.sandbox.set('time', this.synth.time += dt * 0.001 * this.synth.speed);
    this.timeSinceLastUpdate += dt;

    if (!this.synth.fps || this.timeSinceLastUpdate >= 1000 / this.synth.fps) {
      //  console.log(1000/this.timeSinceLastUpdate)
      this.synth.stats.fps = Math.ceil(1000 / this.timeSinceLastUpdate);

      if (this.synth.update) {
        try {
          this.synth.update(this.timeSinceLastUpdate);
        } catch (e) {
          console.log(e);
        }
      } //  console.log(this.synth.speed, this.synth.time)


      for (let i = 0; i < this.s.length; i++) {
        this.s[i].tick(this.synth.time);
      } //  console.log(this.canvas.width, this.canvas.height)


      for (let i = 0; i < this.o.length; i++) {
        this._renderOut(i);
      }

      if (this.isRenderingAll) {
        this.renderAll({
          tex0: this.o[0].getCurrent(),
          tex1: this.o[1].getCurrent(),
          tex2: this.o[2].getCurrent(),
          tex3: this.o[3].getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      } else {
        this.renderFbo({
          tex0: this.output.getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      }

      this.timeSinceLastUpdate = 0;
    }

    if (this.saveFrame === true) {
      this.canvasToImage();
      this.saveFrame = false;
    } //  this.regl.poll()

  }

}

var _default = HydraRenderer;
exports.default = _default;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./eval-sandbox.js":58,"./generator-factory.js":61,"./hydra-source.js":67,"./lib/array-utils.js":70,"./lib/audio.js":71,"./lib/mouse.js":74,"./lib/video-recorder.js":77,"./output.js":79,"raf-loop":37,"regl":39}],69:[function(require,module,exports){
"use strict";

var _hydraSynth = _interopRequireDefault(require("./hydra-synth.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import ShaderGenerator = require('./shader-generator.js')
// alert('hi')
// export default Synth
module.exports = _hydraSynth.default;

},{"./hydra-synth.js":68}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _easingFunctions = _interopRequireDefault(require("./easing-functions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// WIP utils for working with arrays
// Possibly should be integrated with lfo extension, etc.
// to do: transform time rather than array values, similar to working with coordinates in hydra
var map = (num, in_min, in_max, out_min, out_max) => {
  return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};

var _default = {
  init: () => {
    Array.prototype.fast = function (speed = 1) {
      this._speed = speed;
      return this;
    };

    Array.prototype.smooth = function (smooth = 1) {
      this._smooth = smooth;
      return this;
    };

    Array.prototype.ease = function (ease = 'linear') {
      if (typeof ease == 'function') {
        this._smooth = 1;
        this._ease = ease;
      } else if (_easingFunctions.default[ease]) {
        this._smooth = 1;
        this._ease = _easingFunctions.default[ease];
      }

      return this;
    };

    Array.prototype.offset = function (offset = 0.5) {
      this._offset = offset % 1.0;
      return this;
    }; // Array.prototype.bounce = function() {
    //   this.modifiers.bounce = true
    //   return this
    // }


    Array.prototype.fit = function (low = 0, high = 1) {
      let lowest = Math.min(...this);
      let highest = Math.max(...this);
      var newArr = this.map(num => map(num, lowest, highest, low, high));
      newArr._speed = this._speed;
      newArr._smooth = this._smooth;
      newArr._ease = this._ease;
      return newArr;
    };
  },
  getValue: (arr = []) => ({
    time,
    bpm
  }) => {
    let speed = arr._speed ? arr._speed : 1;
    let smooth = arr._smooth ? arr._smooth : 0;
    let index = time * speed * (bpm / 60) + (arr._offset || 0);

    if (smooth !== 0) {
      let ease = arr._ease ? arr._ease : _easingFunctions.default['linear'];

      let _index = index - smooth / 2;

      let currValue = arr[Math.floor(_index % arr.length)];
      let nextValue = arr[Math.floor((_index + 1) % arr.length)];
      let t = Math.min(_index % 1 / smooth, 1);
      return ease(t) * (nextValue - currValue) + currValue;
    } else {
      return arr[Math.floor(index % arr.length)];
    }
  }
};
exports.default = _default;

},{"./easing-functions.js":72}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _meyda = _interopRequireDefault(require("meyda"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Audio {
  constructor({
    numBins = 4,
    cutoff = 2,
    smooth = 0.4,
    max = 15,
    scale = 10,
    isDrawing = false,
    parentEl = document.body
  }) {
    this.vol = 0;
    this.scale = scale;
    this.max = max;
    this.cutoff = cutoff;
    this.smooth = smooth;
    this.setBins(numBins); // beat detection from: https://github.com/therewasaguy/p5-music-viz/blob/gh-pages/demos/01d_beat_detect_amplitude/sketch.js

    this.beat = {
      holdFrames: 20,
      threshold: 40,
      _cutoff: 0,
      // adaptive based on sound state
      decay: 0.98,
      _framesSinceBeat: 0 // keeps track of frames

    };

    this.onBeat = () => {//  console.log("beat")
    };

    this.canvas = document.createElement('canvas');
    this.canvas.width = 100;
    this.canvas.height = 80;
    this.canvas.style.width = "100px";
    this.canvas.style.height = "80px";
    this.canvas.style.position = 'absolute';
    this.canvas.style.right = '0px';
    this.canvas.style.bottom = '0px';
    parentEl.appendChild(this.canvas);
    this.isDrawing = isDrawing;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.fillStyle = "#DFFFFF";
    this.ctx.strokeStyle = "#0ff";
    this.ctx.lineWidth = 0.5;

    if (window.navigator.mediaDevices) {
      window.navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      }).then(stream => {
        //  console.log('got mic stream', stream)
        this.stream = stream;
        this.context = new AudioContext(); //  this.context = new AudioContext()

        let audio_stream = this.context.createMediaStreamSource(stream); //  console.log(this.context)

        this.meyda = _meyda.default.createMeydaAnalyzer({
          audioContext: this.context,
          source: audio_stream,
          featureExtractors: ['loudness' //  'perceptualSpread',
          //  'perceptualSharpness',
          //  'spectralCentroid'
          ]
        });
      }).catch(err => console.log('ERROR', err));
    }
  }

  detectBeat(level) {
    //console.log(level,   this.beat._cutoff)
    if (level > this.beat._cutoff && level > this.beat.threshold) {
      this.onBeat();
      this.beat._cutoff = level * 1.2;
      this.beat._framesSinceBeat = 0;
    } else {
      if (this.beat._framesSinceBeat <= this.beat.holdFrames) {
        this.beat._framesSinceBeat++;
      } else {
        this.beat._cutoff *= this.beat.decay;
        this.beat._cutoff = Math.max(this.beat._cutoff, this.beat.threshold);
      }
    }
  }

  tick() {
    if (this.meyda) {
      var features = this.meyda.get();

      if (features && features !== null) {
        this.vol = features.loudness.total;
        this.detectBeat(this.vol); // reduce loudness array to number of bins

        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        let spacing = Math.floor(features.loudness.specific.length / this.bins.length);
        this.prevBins = this.bins.slice(0);
        this.bins = this.bins.map((bin, index) => {
          return features.loudness.specific.slice(index * spacing, (index + 1) * spacing).reduce(reducer);
        }).map((bin, index) => {
          // map to specified range
          // return (bin * (1.0 - this.smooth) + this.prevBins[index] * this.smooth)
          return bin * (1.0 - this.settings[index].smooth) + this.prevBins[index] * this.settings[index].smooth;
        }); // var y = this.canvas.height - scale*this.settings[index].cutoff
        // this.ctx.beginPath()
        // this.ctx.moveTo(index*spacing, y)
        // this.ctx.lineTo((index+1)*spacing, y)
        // this.ctx.stroke()
        //
        // var yMax = this.canvas.height - scale*(this.settings[index].scale + this.settings[index].cutoff)

        this.fft = this.bins.map((bin, index) => // Math.max(0, (bin - this.cutoff) / (this.max - this.cutoff))
        Math.max(0, (bin - this.settings[index].cutoff) / this.settings[index].scale));
        if (this.isDrawing) this.draw();
      }
    }
  }

  setCutoff(cutoff) {
    this.cutoff = cutoff;
    this.settings = this.settings.map(el => {
      el.cutoff = cutoff;
      return el;
    });
  }

  setSmooth(smooth) {
    this.smooth = smooth;
    this.settings = this.settings.map(el => {
      el.smooth = smooth;
      return el;
    });
  }

  setBins(numBins) {
    this.bins = Array(numBins).fill(0);
    this.prevBins = Array(numBins).fill(0);
    this.fft = Array(numBins).fill(0);
    this.settings = Array(numBins).fill(0).map(() => ({
      cutoff: this.cutoff,
      scale: this.scale,
      smooth: this.smooth
    })); // to do: what to do in non-global mode?

    this.bins.forEach((bin, index) => {
      window['a' + index] = (scale = 1, offset = 0) => () => a.fft[index] * scale + offset;
    }); //  console.log(this.settings)
  }

  setScale(scale) {
    this.scale = scale;
    this.settings = this.settings.map(el => {
      el.scale = scale;
      return el;
    });
  }

  setMax(max) {
    this.max = max;
    console.log('set max is deprecated');
  }

  hide() {
    this.isDrawing = false;
    this.canvas.style.display = 'none';
  }

  show() {
    this.isDrawing = true;
    this.canvas.style.display = 'block';
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    var spacing = this.canvas.width / this.bins.length;
    var scale = this.canvas.height / (this.max * 2); //  console.log(this.bins)

    this.bins.forEach((bin, index) => {
      var height = bin * scale;
      this.ctx.fillRect(index * spacing, this.canvas.height - height, spacing, height); //   console.log(this.settings[index])

      var y = this.canvas.height - scale * this.settings[index].cutoff;
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, y);
      this.ctx.lineTo((index + 1) * spacing, y);
      this.ctx.stroke();
      var yMax = this.canvas.height - scale * (this.settings[index].scale + this.settings[index].cutoff);
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, yMax);
      this.ctx.lineTo((index + 1) * spacing, yMax);
      this.ctx.stroke();
    });
    /*var y = this.canvas.height - scale*this.cutoff
    this.ctx.beginPath()
    this.ctx.moveTo(0, y)
    this.ctx.lineTo(this.canvas.width, y)
    this.ctx.stroke()
    var yMax = this.canvas.height - scale*this.max
    this.ctx.beginPath()
    this.ctx.moveTo(0, yMax)
    this.ctx.lineTo(this.canvas.width, yMax)
    this.ctx.stroke()*/
  }

}

var _default = Audio;
exports.default = _default;

},{"meyda":34}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// from https://gist.github.com/gre/1650294
var _default = {
  // no easing, no acceleration
  linear: function (t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function (t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  },
  // sin shape
  sin: function (t) {
    return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;
  }
};
exports.default = _default;

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// https://github.com/mikolalysenko/mouse-event
const mouse = {};

function mouseButtons(ev) {
  if (typeof ev === 'object') {
    if ('buttons' in ev) {
      return ev.buttons;
    } else if ('which' in ev) {
      var b = ev.which;

      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ('button' in ev) {
      var b = ev.button;

      if (b === 1) {
        return 4;
      } else if (b === 2) {
        return 2;
      } else if (b >= 0) {
        return 1 << b;
      }
    }
  }

  return 0;
}

mouse.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window;
}

mouse.element = mouseElement;

function mouseRelativeX(ev) {
  if (typeof ev === 'object') {
    if ('pageX' in ev) {
      return ev.pageX;
    }
  }

  return 0;
}

mouse.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if (typeof ev === 'object') {
    if ('pageY' in ev) {
      return ev.pageY;
    }
  }

  return 0;
}

mouse.y = mouseRelativeY;
var _default = mouse;
exports.default = _default;

},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mouseEvent = _interopRequireDefault(require("./mouse-event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://github.com/mikolalysenko/mouse-change
var _default = mouseListen;
exports.default = _default;

function mouseListen(element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods(ev) {
    var changed = false;

    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }

    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }

    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }

    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }

    return changed;
  }

  function handleEvent(nextButtons, ev) {
    var nextX = _mouseEvent.default.x(ev);

    var nextY = _mouseEvent.default.y(ev);

    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }

    if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState(ev) {
    handleEvent(0, ev);
  }

  function handleBlur() {
    if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods(ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove(ev) {
    if (_mouseEvent.default.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown(ev) {
    handleEvent(buttonState | _mouseEvent.default.buttons(ev), ev);
  }

  function handleMouseUp(ev) {
    handleEvent(buttonState & ~_mouseEvent.default.buttons(ev), ev);
  }

  function attachListeners() {
    if (attached) {
      return;
    }

    attached = true;
    element.addEventListener('mousemove', handleMouseMove);
    element.addEventListener('mousedown', handleMouseDown);
    element.addEventListener('mouseup', handleMouseUp);
    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);
    element.addEventListener('blur', handleBlur);
    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);
      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners() {
    if (!attached) {
      return;
    }

    attached = false;
    element.removeEventListener('mousemove', handleMouseMove);
    element.removeEventListener('mousedown', handleMouseDown);
    element.removeEventListener('mouseup', handleMouseUp);
    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);
    element.removeEventListener('blur', handleBlur);
    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  } // Attach listeners


  attachListeners();
  var result = {
    element: element
  };
  Object.defineProperties(result, {
    enabled: {
      get: function () {
        return attached;
      },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () {
        return buttonState;
      },
      enumerable: true
    },
    x: {
      get: function () {
        return x;
      },
      enumerable: true
    },
    y: {
      get: function () {
        return y;
      },
      enumerable: true
    },
    mods: {
      get: function () {
        return mods;
      },
      enumerable: true
    }
  });
  return result;
}

},{"./mouse-event.js":73}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// attempt custom evaluation sandbox for hydra functions
// for now, just avoids polluting the global namespace
// should probably be replaced with an abstract syntax tree
var _default = parent => {
  var initialCode = ``;
  var sandbox = createSandbox(initialCode);

  var addToContext = (name, object) => {
    initialCode += `
      var ${name} = ${object}
    `;
    sandbox = createSandbox(initialCode);
  };

  return {
    addToContext: addToContext,
    eval: code => sandbox.eval(code)
  };

  function createSandbox(initial) {
    eval(initial); // optional params

    var localEval = function (code) {
      eval(code);
    }; // API/data for end-user


    return {
      eval: localEval
    };
  }
};

exports.default = _default;

},{}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(options) {
  return new Promise(function (resolve, reject) {
    //  async function startCapture(displayMediaOptions) {
    navigator.mediaDevices.getDisplayMedia(options).then(stream => {
      const video = document.createElement('video');
      video.srcObject = stream;
      video.addEventListener('loadedmetadata', () => {
        video.play();
        resolve({
          video: video
        });
      });
    }).catch(err => reject(err));
  });
}

},{}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class VideoRecorder {
  constructor(stream) {
    this.mediaSource = new MediaSource();
    this.stream = stream; // testing using a recording as input

    this.output = document.createElement('video');
    this.output.autoplay = true;
    this.output.loop = true;
    let self = this;
    this.mediaSource.addEventListener('sourceopen', () => {
      console.log('MediaSource opened');
      self.sourceBuffer = self.mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      console.log('Source buffer: ', sourceBuffer);
    });
  }

  start() {
    //  let options = {mimeType: 'video/webm'};
    //   let options = {mimeType: 'video/webm;codecs=h264'};
    let options = {
      mimeType: 'video/webm;codecs=vp9'
    };
    this.recordedBlobs = [];

    try {
      this.mediaRecorder = new MediaRecorder(this.stream, options);
    } catch (e0) {
      console.log('Unable to create MediaRecorder with options Object: ', e0);

      try {
        options = {
          mimeType: 'video/webm,codecs=vp9'
        };
        this.mediaRecorder = new MediaRecorder(this.stream, options);
      } catch (e1) {
        console.log('Unable to create MediaRecorder with options Object: ', e1);

        try {
          options = 'video/vp8'; // Chrome 47

          this.mediaRecorder = new MediaRecorder(this.stream, options);
        } catch (e2) {
          alert('MediaRecorder is not supported by this browser.\n\n' + 'Try Firefox 29 or later, or Chrome 47 or later, ' + 'with Enable experimental Web Platform features enabled from chrome://flags.');
          console.error('Exception while creating MediaRecorder:', e2);
          return;
        }
      }
    }

    console.log('Created MediaRecorder', this.mediaRecorder, 'with options', options);
    this.mediaRecorder.onstop = this._handleStop.bind(this);
    this.mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this.mediaRecorder.start(100); // collect 100ms of data

    console.log('MediaRecorder started', this.mediaRecorder);
  }

  stop() {
    this.mediaRecorder.stop();
  }

  _handleStop() {
    //const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'})
    // const blob = new Blob(this.recordedBlobs, {type: 'video/webm;codecs=h264'})
    const blob = new Blob(this.recordedBlobs, {
      type: this.mediaRecorder.mimeType
    });
    const url = window.URL.createObjectURL(blob);
    this.output.src = url;
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.webm`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 300);
  }

  _handleDataAvailable(event) {
    if (event.data && event.data.size > 0) {
      this.recordedBlobs.push(event.data);
    }
  }

}

var _default = VideoRecorder;
exports.default = _default;

},{}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

//const enumerateDevices = require('enumerate-devices')
function _default(deviceId) {
  return navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(devices => devices.kind === 'videoinput')).then(cameras => {
    let constraints = {
      audio: false,
      video: true
    };

    if (cameras[deviceId]) {
      constraints['video'] = {
        deviceId: {
          exact: cameras[deviceId].deviceId
        }
      };
    } //  console.log(cameras)


    return window.navigator.mediaDevices.getUserMedia(constraints);
  }).then(stream => {
    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.setAttribute('playsinline', ''); //  video.src = window.URL.createObjectURL(stream)

    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.addEventListener('loadedmetadata', () => {
        video.play().then(() => resolve({
          video: video
        }));
      });
    });
  }).catch(console.log.bind(console));
}

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var mat4 = _interopRequireWildcard(require("gl-mat4"));

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Output = function (index, synth) {
  this.id = index;
  this.synth = synth;
  this.width = synth.width;
  this.height = synth.height;
  this.regl = synth.regl;
  this.precision = synth.precision;
  this.label = `o${index}`;
  this.positionBuffer = this.regl.buffer([[-5, -1, 0], [-1, -5, 0], [3, 3, 0]]);
  this.uvBuffer = this.regl.buffer([[-2, 0], [0, -2], [2, 2]]);
  this.draw = [];
  this.init();
  this.pingPongIndex = 0; // for each output, create two fbos for pingponging

  this.fbos = Array(2).fill().map(() => this._initFbo()); // for each output, create two temp buffers

  this.temp = Array(2).fill().map(() => this._initFbo());
  this.copyPass = this.regl({
    frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, uv);
      }
      `,
    vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(2.0 * position - 1.0, 0, 1);
      }`,
    attributes: {
      position: [[-2, 0], [0, -2], [2, 2]]
    },
    uniforms: {
      tex0: this.regl.prop('tex0')
    },
    count: 3,
    depth: {
      enable: false
    },
    framebuffer: () => this.getTexture()
  });
};

Output.prototype._initFbo = function () {
  return this.regl.framebuffer({
    color: this.regl.texture({
      mag: 'nearest',
      width: this.width,
      height: this.height,
      format: 'rgba'
    }),
    depthStencil: false
  });
};

Output.prototype.resize = function (width, height) {
  this.width = width;
  this.height = height;
  this.fbos.forEach(fbo => {
    fbo.resize(width, height);
  });
  this.temp.forEach(tmp => {
    tmp.resize(width, height);
  });
};

Output.prototype.getCurrent = function () {
  return this.fbos[this.pingPongIndex];
};

Output.prototype.getTexture = function () {
  var index = this.pingPongIndex ? 0 : 1;
  return this.fbos[index];
};

Output.prototype.init = function () {
  this.attributes = {
    position: this.positionBuffer,
    uv: this.uvBuffer
  };
  this.uniforms = {
    time: this.regl.prop('time'),
    resolution: this.regl.prop('resolution')
  };
  this.initCamera();
  return this;
};

Output.prototype.initCamera = function () {
  this._camera = this.regl({
    context: {
      projection: mat4.identity([]),
      view: mat4.identity([])
    },
    uniforms: {
      view: this.regl.context('view'),
      projection: this.regl.context('projection')
    }
  });
};

Output.prototype.camera = function (eye, target, options = {}) {
  options = Object.assign({
    fovy: Math.PI / 4,
    near: 0.1,
    far: 1000.0
  }, options);
  this.eye = eye;
  this.target = target;

  if (eye && target) {
    this._camera = this.regl({
      context: {
        projection: function (context) {
          if (options.type === 'perspective') {
            return mat4.perspective([], options.fovy, options.aspect || context.viewportWidth / context.viewportHeight, options.near, options.far);
          } else {
            return mat4.ortho([], -1.0, 1.0, -1.0, 1.0, options.near, options.far);
          }
        },
        view: function (context, props) {
          return mat4.lookAt([], props.eye, props.target, [0, 1, 0]);
        },
        eye: this.regl.prop('eye')
      },
      uniforms: {
        view: this.regl.context('view'),
        projection: this.regl.context('projection')
      }
    });
  } else {
    this.initCamera();
  }

  return this;
};

Output.prototype.perspective = function (eye, target, options = {}) {
  options = Object.assign({
    type: 'perspective'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.ortho = function (eye, target, options = {}) {
  options = Object.assign({
    type: 'ortho'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.render = function (passes) {
  const self = this; // ensure both fbo's have last frame

  this.copyPass({
    tex0: this.getCurrent()
  });
  self.draw = [];

  for (let i = 0; i < passes.length; i++) {
    let pass = passes[i];

    if (pass.clear) {
      switch (pass.clear) {
        case 'clear':
          self.draw.push(...this.clear(false));
          break;

        case 'fade':
          {
            const opt = typeof pass.userArgs[0] === 'object' ? pass.userArgs[0] : {
              amount: pass.userArgs[0]
            };
            opt.now = false;
            self.draw.push(this.fade(opt));
            break;
          }

        default:
          console.warn(`unrecognized clear: ${pass.clear}(${pass.userArgs.join(", ")})`);
          break;
      }

      continue;
    }

    const {
      attributes,
      elements,
      primitive
    } = this.getAttributes(pass.primitive, pass.geometry);
    const uniforms = this.getUniforms(pass.uniforms);
    const blend = this.getBlend(pass.blendMode);
    const draw = self.regl({
      frag: pass.frag,
      vert: pass.vert,
      viewport: typeof pass.viewport.x !== 'undefined' ? {
        x: pass.viewport.x * this.fbos[0].width,
        y: pass.viewport.y * this.fbos[0].height,
        width: pass.viewport.w * this.fbos[0].width,
        height: pass.viewport.h * this.fbos[0].height
      } : {},
      cull: {
        enable: !!pass.geometry,
        face: 'back'
      },
      attributes,
      primitive,
      uniforms,
      count: typeof elements === 'number' ? elements : elements.length,
      elements: typeof elements === 'number' ? null : elements,
      blend,
      lineWidth: pass.lineWidth,
      framebuffer: pass.framebuffer || (() => {
        self.pingPongIndex = self.pingPongIndex ? 0 : 1;
        return self.fbos[self.pingPongIndex];
      })
    });
    self.draw.push(draw);
  }
};

Output.prototype.clear = function (now = true) {
  const result = [this.fbos[0], this.fbos[1], this.temp[0], this.temp[1]].map(fbo => {
    const clear = () => this.regl.clear({
      color: [0, 0, 0, 0],
      framebuffer: fbo
    });

    if (now) clear();else return clear;
  });
  if (now) return this;
  return result;
};

Output.prototype.fade = function (options) {
  let amount = options;
  let camera = false;
  let now = true;

  if (typeof options === 'object') {
    ({
      amount,
      camera
    } = options);
    now = typeof options.now === 'undefined' ? true : options.now;
  }

  const self = this; // todo: do we need to fade also temp buffers?

  const fade = self.regl({
    frag: `
          precision ${self.precision} float;
          varying vec2 vuv;
          uniform sampler2D prevBuffer;
          void main() {
            vec4 color = mix(texture2D(prevBuffer, vuv), vec4(0), ${amount});
            gl_FragColor = color;
          }
        `,
    vert: _glslSource.default.compileVert(this.precision, camera, {
      glslName: 'clear'
    }),
    attributes: self.attributes,
    primitive: 'triangles',
    uniforms: Object.assign({}, {
      prevBuffer: () => {
        return self.fbos[self.pingPongIndex];
      }
    }, this.uniforms),
    count: 3,
    // next framebuffer
    framebuffer: () => {
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  if (now) return this;
  return fade;
};

Output.prototype.getAttributes = function (primitive, geometry) {
  let elements = 3;
  let attributes = this.attributes;

  if (geometry) {
    attributes = {};
    Object.keys(geometry.attributes).forEach(key => attributes[key] = geometry.attributes[key].array);
    elements = geometry.index ? geometry.index.array : geometry.attributes.position.count;
    primitive || (primitive = geometry.parameters.primitive);
  }

  primitive || (primitive = 'triangles');
  return {
    attributes,
    elements,
    primitive
  };
};

Output.prototype.getUniforms = function (uniforms) {
  const self = this;
  uniforms = Object.assign(uniforms, {
    prevBuffer: () => {
      // todo: changed, originally:
      // return self.fbos[self.pingPongIndex]
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  return Object.keys(uniforms).reduce((acc, key) => {
    acc[key] = typeof uniforms[key] === 'string' ? parseFloat(uniforms[key]) : uniforms[key];
    return acc;
  }, {});
};

Output.prototype.getBlend = function (blendMode) {
  let func;

  switch (blendMode) {
    case 'custom':
      func = {
        srcRGB: 'custom',
        // Define your custom blending function here
        dstRGB: 'custom',
        srcAlpha: 'custom',
        dstAlpha: 'custom'
      };
      break;

    case 'overlay':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'one minus src color',
        srcAlpha: 'dst alpha',
        dstAlpha: 'one minus src alpha'
      };
      break;

    case 'screen':
      func = {
        srcRGB: 'one minus dst color',
        dstRGB: 'one',
        srcAlpha: 'one minus dst alpha',
        dstAlpha: 'one'
      };
      break;

    case 'multiply':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'zero',
        srcAlpha: 'dst alpha',
        dstAlpha: 'zero'
      };
      break;

    case 'add':
      func = {
        srcRGB: 'one',
        dstRGB: 'one',
        srcAlpha: 'one',
        dstAlpha: 'one'
      };
      break;

    case 'alpha':
    default:
      func = {
        srcRGB: 'src alpha',
        srcAlpha: 1,
        dstRGB: 'one minus src alpha',
        dstAlpha: 1
      };
      break;
  }

  return {
    enable: blendMode ? typeof blendMode === 'string' ? blendMode !== 'disabled' : blendMode : false,
    func
  };
};

Output.prototype.tick = function (props) {
  const doDraw = () => this.draw.map(fn => fn(props));

  this._camera({
    eye: this.eye,
    target: this.target
  }, function () {
    doDraw();
  });
};

Output.prototype.renderTexture = function () {
  this.synth._renderOut(this.id);

  const colorTex = this.fbos[this.pingPongIndex].color;
  this.fbos[this.pingPongIndex] = this._initFbo();
  return colorTex;
};

var _default = Output;
exports.default = _default;

},{"./glsl-source.js":62,"gl-mat4":17}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeLookup = exports.getTypeLookup = exports.getLookup = exports.castType = void 0;
const typeLookup = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'vert': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
};
exports.typeLookup = typeLookup;
const getLookup = {
  float: 'x',
  vec2: 'xy',
  vec3: 'xyz',
  vec4: 'xyzw'
};
exports.getLookup = getLookup;
const getTypeLookup = {
  x: 'float',
  y: 'float',
  z: 'float',
  xy: 'vec2',
  yx: 'vec2',
  xyz: 'vec3',
  xzy: 'vec3',
  yzx: 'vec3',
  yxz: 'vec3',
  zxy: 'vec3',
  zyx: 'vec3',
  xyzw: 'vec4'
};
exports.getTypeLookup = getTypeLookup;

const castType = (func, fromType, toType, alpha = 0.0) => {
  const fromLen = fromType === 'float' ? 1 : fromType.substring(3);
  const toLen = toType === 'float' ? 1 : toType.substring(3);

  if (fromLen < toLen) {
    let diff = toLen - fromLen;
    let last = '';

    if (toType === 'vec4') {
      diff -= 1;
      last = ', ' + alpha;
    }

    func = `vec${toLen}(${func}${', 0.0'.repeat(diff)}${last})`;
  }

  return func;
};

exports.castType = castType;

},{}]},{},[69])(69)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Fkam9pbnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NvcHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9kZXRlcm1pbmFudC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21RdWF0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tU2NhbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21YUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWVJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVpSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2ZydXN0dW0uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW52ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbG9va0F0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbXVsdGlwbHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9vcnRoby5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3BlcnNwZWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVYLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVouanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3N0ci5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3RyYW5zbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3RyYW5zcG9zZS5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9tZXlkYS9kaXN0L3dlYi9tZXlkYS5taW4uanMiLCJub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhZi1sb29wL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdsL2Rpc3QvcmVnbC5qcyIsIm5vZGVfbW9kdWxlcy9yaWdodC1ub3cvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9CdWZmZXJHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvTGF5ZXJzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL09iamVjdDNELmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvRGF0YVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0JveDMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvRXVsZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0aFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4NC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9RdWF0ZXJuaW9uLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1NwaGVyZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9WZWN0b3IyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1ZlY3RvcjMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL3V0aWxzLmpzIiwic3JjL2V2YWwtc2FuZGJveC5qcyIsInNyYy9mb3JtYXQtYXJndW1lbnRzLmpzIiwic3JjL2dlbmVyYXRlLWdsc2wuanMiLCJzcmMvZ2VuZXJhdG9yLWZhY3RvcnkuanMiLCJzcmMvZ2xzbC1zb3VyY2UuanMiLCJzcmMvZ2xzbC9nZW9tZXRyaWVzL0dyaWRHZW9tZXRyeS5qcyIsInNyYy9nbHNsL2dsc2wtZnVuY3Rpb25zLmpzIiwic3JjL2dsc2wvdXRpbGl0eS1mdW5jdGlvbnMuanMiLCJzcmMvZ2xzbC92ZXJ0LWZ1bmN0aW9ucy5qcyIsInNyYy9oeWRyYS1zb3VyY2UuanMiLCJzcmMvaHlkcmEtc3ludGguanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGliL2FycmF5LXV0aWxzLmpzIiwic3JjL2xpYi9hdWRpby5qcyIsInNyYy9saWIvZWFzaW5nLWZ1bmN0aW9ucy5qcyIsInNyYy9saWIvbW91c2UtZXZlbnQuanMiLCJzcmMvbGliL21vdXNlLmpzIiwic3JjL2xpYi9zYW5kYm94LmpzIiwic3JjL2xpYi9zY3JlZW5tZWRpYS5qcyIsInNyYy9saWIvdmlkZW8tcmVjb3JkZXIuanMiLCJzcmMvbGliL3dlYmNhbS5qcyIsInNyYy9vdXRwdXQuanMiLCJzcmMvdHlwZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzcrVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQTyxNQUFNLFFBQVEsR0FBRyxLQUFqQjs7QUFFQSxNQUFNLEtBQUssR0FBRztFQUFFLElBQUksRUFBRSxDQUFSO0VBQVcsTUFBTSxFQUFFLENBQW5CO0VBQXNCLEtBQUssRUFBRSxDQUE3QjtFQUFnQyxNQUFNLEVBQUUsQ0FBeEM7RUFBMkMsS0FBSyxFQUFFLENBQWxEO0VBQXFELEdBQUcsRUFBRTtBQUExRCxDQUFkOztBQUNBLE1BQU0sS0FBSyxHQUFHO0VBQUUsTUFBTSxFQUFFLENBQVY7RUFBYSxHQUFHLEVBQUUsQ0FBbEI7RUFBcUIsU0FBUyxFQUFFLENBQWhDO0VBQW1DLFlBQVksRUFBRTtBQUFqRCxDQUFkOztBQUNBLE1BQU0sWUFBWSxHQUFHLENBQXJCOztBQUNBLE1BQU0sWUFBWSxHQUFHLENBQXJCOztBQUNBLE1BQU0sYUFBYSxHQUFHLENBQXRCOztBQUNBLE1BQU0saUJBQWlCLEdBQUcsQ0FBMUI7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsQ0FBdkI7O0FBQ0EsTUFBTSxZQUFZLEdBQUcsQ0FBckI7O0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxDQUF6Qjs7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFyQjs7QUFDQSxNQUFNLFNBQVMsR0FBRyxDQUFsQjs7QUFDQSxNQUFNLFFBQVEsR0FBRyxDQUFqQjs7QUFDQSxNQUFNLFVBQVUsR0FBRyxDQUFuQjs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLENBQTFCLEMsQ0FBNkI7OztBQUM3QixNQUFNLFVBQVUsR0FBRyxDQUFuQjs7QUFDQSxNQUFNLGNBQWMsR0FBRyxDQUF2Qjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLENBQXpCOztBQUNBLE1BQU0sbUJBQW1CLEdBQUcsQ0FBNUI7O0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxDQUF6Qjs7QUFDQSxNQUFNLGNBQWMsR0FBRyxDQUF2Qjs7QUFDQSxNQUFNLFdBQVcsR0FBRyxHQUFwQjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLEdBQXpCOztBQUNBLE1BQU0sdUJBQXVCLEdBQUcsR0FBaEM7O0FBQ0EsTUFBTSxXQUFXLEdBQUcsR0FBcEI7O0FBQ0EsTUFBTSxXQUFXLEdBQUcsR0FBcEI7O0FBQ0EsTUFBTSxVQUFVLEdBQUcsR0FBbkI7O0FBQ0EsTUFBTSxTQUFTLEdBQUcsR0FBbEI7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsR0FBdkI7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxHQUEvQjs7QUFDQSxNQUFNLGNBQWMsR0FBRyxHQUF2Qjs7QUFDQSxNQUFNLHNCQUFzQixHQUFHLEdBQS9COztBQUNBLE1BQU0sY0FBYyxHQUFHLEdBQXZCOztBQUNBLE1BQU0sc0JBQXNCLEdBQUcsR0FBL0I7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsR0FBdkI7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxHQUEvQjs7QUFDQSxNQUFNLHNCQUFzQixHQUFHLEdBQS9COztBQUNBLE1BQU0sVUFBVSxHQUFHLENBQW5COztBQUNBLE1BQU0sV0FBVyxHQUFHLENBQXBCOztBQUNBLE1BQU0sU0FBUyxHQUFHLENBQWxCOztBQUNBLE1BQU0sY0FBYyxHQUFHLENBQXZCOztBQUNBLE1BQU0sVUFBVSxHQUFHLENBQW5COztBQUNBLE1BQU0saUJBQWlCLEdBQUcsQ0FBMUI7O0FBQ0EsTUFBTSxZQUFZLEdBQUcsQ0FBckI7O0FBQ0EsTUFBTSxhQUFhLEdBQUcsQ0FBdEI7O0FBQ0EsTUFBTSxpQkFBaUIsR0FBRyxDQUExQjs7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFyQjs7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFyQjs7QUFDQSxNQUFNLGFBQWEsR0FBRyxDQUF0Qjs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLENBQTFCOztBQUNBLE1BQU0sbUJBQW1CLEdBQUcsQ0FBNUI7O0FBQ0EsTUFBTSxpQkFBaUIsR0FBRyxDQUExQjs7QUFDQSxNQUFNLHFCQUFxQixHQUFHLENBQTlCOztBQUNBLE1BQU0saUJBQWlCLEdBQUcsQ0FBMUI7O0FBRUEsTUFBTSxTQUFTLEdBQUcsR0FBbEI7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxHQUE5Qjs7QUFDQSxNQUFNLHFCQUFxQixHQUFHLEdBQTlCOztBQUNBLE1BQU0sZ0NBQWdDLEdBQUcsR0FBekM7O0FBQ0EsTUFBTSxnQ0FBZ0MsR0FBRyxHQUF6Qzs7QUFDQSxNQUFNLHVCQUF1QixHQUFHLEdBQWhDOztBQUNBLE1BQU0sY0FBYyxHQUFHLElBQXZCOztBQUNBLE1BQU0sbUJBQW1CLEdBQUcsSUFBNUI7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxJQUEvQjs7QUFDQSxNQUFNLGFBQWEsR0FBRyxJQUF0Qjs7QUFDQSxNQUFNLDBCQUEwQixHQUFHLElBQW5DOztBQUNBLE1BQU0sMEJBQTBCLEdBQUcsSUFBbkM7O0FBQ0EsTUFBTSx5QkFBeUIsR0FBRyxJQUFsQzs7QUFDQSxNQUFNLHlCQUF5QixHQUFHLElBQWxDOztBQUNBLE1BQU0sWUFBWSxHQUFHLElBQXJCOztBQUNBLE1BQU0seUJBQXlCLEdBQUcsSUFBbEM7O0FBQ0EsTUFBTSx5QkFBeUIsR0FBRyxJQUFsQzs7QUFDQSxNQUFNLHdCQUF3QixHQUFHLElBQWpDOztBQUNBLE1BQU0sd0JBQXdCLEdBQUcsSUFBakM7O0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxJQUF6Qjs7QUFDQSxNQUFNLFFBQVEsR0FBRyxJQUFqQjs7QUFDQSxNQUFNLFNBQVMsR0FBRyxJQUFsQjs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLElBQTFCOztBQUNBLE1BQU0sT0FBTyxHQUFHLElBQWhCOztBQUNBLE1BQU0sZUFBZSxHQUFHLElBQXhCOztBQUNBLE1BQU0sU0FBUyxHQUFHLElBQWxCOztBQUNBLE1BQU0sYUFBYSxHQUFHLElBQXRCOztBQUNBLE1BQU0scUJBQXFCLEdBQUcsSUFBOUI7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxJQUE5Qjs7QUFDQSxNQUFNLGtCQUFrQixHQUFHLElBQTNCOztBQUNBLE1BQU0sV0FBVyxHQUFHLElBQXBCOztBQUNBLE1BQU0sVUFBVSxHQUFHLElBQW5COztBQUNBLE1BQU0sZUFBZSxHQUFHLElBQXhCOztBQUNBLE1BQU0sb0JBQW9CLEdBQUcsSUFBN0I7O0FBQ0EsTUFBTSxXQUFXLEdBQUcsSUFBcEI7O0FBQ0EsTUFBTSxrQkFBa0IsR0FBRyxJQUEzQjs7QUFDQSxNQUFNLFNBQVMsR0FBRyxJQUFsQjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLElBQXpCOztBQUNBLE1BQU0sUUFBUSxHQUFHLElBQWpCOztBQUNBLE1BQU0sZUFBZSxHQUFHLElBQXhCOztBQUNBLE1BQU0saUJBQWlCLEdBQUcsSUFBMUI7O0FBRUEsTUFBTSxvQkFBb0IsR0FBRyxLQUE3Qjs7QUFDQSxNQUFNLHFCQUFxQixHQUFHLEtBQTlCOztBQUNBLE1BQU0scUJBQXFCLEdBQUcsS0FBOUI7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxLQUE5Qjs7QUFDQSxNQUFNLHVCQUF1QixHQUFHLEtBQWhDOztBQUNBLE1BQU0sdUJBQXVCLEdBQUcsS0FBaEM7O0FBQ0EsTUFBTSx3QkFBd0IsR0FBRyxLQUFqQzs7QUFDQSxNQUFNLHdCQUF3QixHQUFHLEtBQWpDOztBQUNBLE1BQU0sZUFBZSxHQUFHLEtBQXhCOztBQUNBLE1BQU0sZUFBZSxHQUFHLEtBQXhCOztBQUNBLE1BQU0sb0JBQW9CLEdBQUcsS0FBN0I7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxLQUE3Qjs7QUFDQSxNQUFNLG9CQUFvQixHQUFHLEtBQTdCOztBQUNBLE1BQU0sb0JBQW9CLEdBQUcsS0FBN0I7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxLQUE3Qjs7QUFDQSxNQUFNLG9CQUFvQixHQUFHLEtBQTdCOztBQUNBLE1BQU0sb0JBQW9CLEdBQUcsS0FBN0I7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxLQUE3Qjs7QUFDQSxNQUFNLG9CQUFvQixHQUFHLEtBQTdCOztBQUNBLE1BQU0scUJBQXFCLEdBQUcsS0FBOUI7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxLQUE5Qjs7QUFDQSxNQUFNLHFCQUFxQixHQUFHLEtBQTlCOztBQUNBLE1BQU0sc0JBQXNCLEdBQUcsS0FBL0I7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxLQUEvQjs7QUFDQSxNQUFNLHNCQUFzQixHQUFHLEtBQS9COztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsS0FBekI7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxLQUEvQjs7QUFDQSxNQUFNLHdCQUF3QixHQUFHLEtBQWpDOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsS0FBekI7O0FBQ0EsTUFBTSx1QkFBdUIsR0FBRyxLQUFoQzs7QUFDQSxNQUFNLHNCQUFzQixHQUFHLEtBQS9COztBQUNBLE1BQU0sNkJBQTZCLEdBQUcsS0FBdEM7O0FBQ0EsTUFBTSxRQUFRLEdBQUcsSUFBakI7O0FBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBbkI7O0FBQ0EsTUFBTSxZQUFZLEdBQUcsSUFBckI7O0FBQ0EsTUFBTSxtQkFBbUIsR0FBRyxJQUE1Qjs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLElBQTFCOztBQUNBLE1BQU0saUJBQWlCLEdBQUcsSUFBMUI7O0FBQ0EsTUFBTSxtQkFBbUIsR0FBRyxJQUE1Qjs7QUFDQSxNQUFNLGVBQWUsR0FBRyxJQUF4Qjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLElBQXpCOztBQUNBLE1BQU0sd0JBQXdCLEdBQUcsSUFBakM7O0FBQ0EsTUFBTSwwQkFBMEIsR0FBRyxJQUFuQzs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLENBQTFCOztBQUNBLE1BQU0scUJBQXFCLEdBQUcsQ0FBOUI7O0FBQ0EsTUFBTSxtQkFBbUIsR0FBRyxDQUE1QjtBQUNQOzs7QUFDTyxNQUFNLGNBQWMsR0FBRyxJQUF2QjtBQUNQOzs7QUFDTyxNQUFNLFlBQVksR0FBRyxJQUFyQjs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLElBQTFCOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsSUFBekI7O0FBQ0EsTUFBTSxxQkFBcUIsR0FBRyxDQUE5Qjs7QUFDQSxNQUFNLG9CQUFvQixHQUFHLENBQTdCLEMsQ0FFUDs7O0FBQ08sTUFBTSxZQUFZLEdBQUcsRUFBckI7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsTUFBdkI7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxhQUE3Qjs7QUFDQSxNQUFNLG1CQUFtQixHQUFHLFlBQTVCOztBQUNBLE1BQU0seUJBQXlCLEdBQUcsbUJBQWxDOztBQUVBLE1BQU0sYUFBYSxHQUFHLENBQXRCOztBQUNBLE1BQU0sYUFBYSxHQUFHLElBQXRCOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsSUFBekI7O0FBQ0EsTUFBTSxrQkFBa0IsR0FBRyxJQUEzQjs7QUFDQSxNQUFNLGtCQUFrQixHQUFHLElBQTNCOztBQUNBLE1BQU0sc0JBQXNCLEdBQUcsS0FBL0I7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxLQUEvQjs7QUFDQSxNQUFNLGVBQWUsR0FBRyxJQUF4Qjs7QUFFQSxNQUFNLGdCQUFnQixHQUFHLEdBQXpCOztBQUNBLE1BQU0sZUFBZSxHQUFHLEdBQXhCOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsR0FBekI7O0FBQ0EsTUFBTSxvQkFBb0IsR0FBRyxHQUE3Qjs7QUFDQSxNQUFNLGtCQUFrQixHQUFHLEdBQTNCOztBQUNBLE1BQU0sbUJBQW1CLEdBQUcsR0FBNUI7O0FBQ0EsTUFBTSx1QkFBdUIsR0FBRyxHQUFoQzs7QUFDQSxNQUFNLGlCQUFpQixHQUFHLEdBQTFCOztBQUVBLE1BQU0sWUFBWSxHQUFHLEdBQXJCOztBQUNBLE1BQU0sV0FBVyxHQUFHLEdBQXBCOztBQUNBLE1BQU0sWUFBWSxHQUFHLEdBQXJCOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsR0FBekI7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsR0FBdkI7O0FBQ0EsTUFBTSxlQUFlLEdBQUcsR0FBeEI7O0FBQ0EsTUFBTSxtQkFBbUIsR0FBRyxHQUE1Qjs7QUFDQSxNQUFNLGFBQWEsR0FBRyxHQUF0Qjs7QUFFQSxNQUFNLGVBQWUsR0FBRyxLQUF4Qjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLEtBQXpCOztBQUNBLE1BQU0sZUFBZSxHQUFHLEtBQXhCOztBQUNBLE1BQU0sZUFBZSxHQUFHLEtBQXhCOztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsS0FBekI7O0FBQ0EsTUFBTSxlQUFlLEdBQUcsS0FBeEI7O0FBQ0EsTUFBTSxlQUFlLEdBQUcsS0FBeEI7O0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxLQUF6Qjs7QUFDQSxNQUFNLGVBQWUsR0FBRyxLQUF4Qjs7QUFFQSxNQUFNLEtBQUssR0FBRyxLQUFkOztBQUNBLE1BQU0sS0FBSyxHQUFHLFFBQWQ7O0FBRUEsTUFBTSxZQUFZLEdBQUcsSUFBckIsQyxDQUEyQjs7O0FBRTNCLE1BQU0scUJBQXFCLEdBQUcsSUFBOUI7O0FBQ0EsTUFBTSxzQkFBc0IsR0FBRyxJQUEvQjs7Ozs7Ozs7Ozs7QUMzTVA7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTSxPQUFPLEdBQUcsYUFBYyxJQUFJLGVBQUosRUFBOUI7O0FBQ0EsTUFBTSxRQUFRLEdBQUcsYUFBYyxJQUFJLGdCQUFKLEVBQS9COztBQUVBLE1BQU0sZUFBTixDQUFzQjtFQUVyQixXQUFXLENBQUUsS0FBRixFQUFTLFFBQVQsRUFBbUIsVUFBVSxHQUFHLEtBQWhDLEVBQXdDO0lBRWxELElBQUssS0FBSyxDQUFDLE9BQU4sQ0FBZSxLQUFmLENBQUwsRUFBOEI7TUFFN0IsTUFBTSxJQUFJLFNBQUosQ0FBZSx1REFBZixDQUFOO0lBRUE7O0lBRUQsS0FBSyxpQkFBTCxHQUF5QixJQUF6QjtJQUVBLEtBQUssSUFBTCxHQUFZLEVBQVo7SUFFQSxLQUFLLEtBQUwsR0FBYSxLQUFiO0lBQ0EsS0FBSyxRQUFMLEdBQWdCLFFBQWhCO0lBQ0EsS0FBSyxLQUFMLEdBQWEsS0FBSyxLQUFLLFNBQVYsR0FBc0IsS0FBSyxDQUFDLE1BQU4sR0FBZSxRQUFyQyxHQUFnRCxDQUE3RDtJQUNBLEtBQUssVUFBTCxHQUFrQixVQUFsQjtJQUVBLEtBQUssS0FBTCxHQUFhLDBCQUFiO0lBQ0EsS0FBSyxXQUFMLEdBQW1CO01BQUUsTUFBTSxFQUFFLENBQVY7TUFBYSxLQUFLLEVBQUUsQ0FBRTtJQUF0QixDQUFuQjtJQUNBLEtBQUssT0FBTCxHQUFlLG9CQUFmO0lBRUEsS0FBSyxPQUFMLEdBQWUsQ0FBZjtFQUVBOztFQUVELGdCQUFnQixHQUFHLENBQUU7O0VBRU4sSUFBWCxXQUFXLENBQUUsS0FBRixFQUFVO0lBRXhCLElBQUssS0FBSyxLQUFLLElBQWYsRUFBc0IsS0FBSyxPQUFMO0VBRXRCOztFQUVELFFBQVEsQ0FBRSxLQUFGLEVBQVU7SUFFakIsS0FBSyxLQUFMLEdBQWEsS0FBYjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELElBQUksQ0FBRSxNQUFGLEVBQVc7SUFFZCxLQUFLLElBQUwsR0FBWSxNQUFNLENBQUMsSUFBbkI7SUFDQSxLQUFLLEtBQUwsR0FBYSxJQUFJLE1BQU0sQ0FBQyxLQUFQLENBQWEsV0FBakIsQ0FBOEIsTUFBTSxDQUFDLEtBQXJDLENBQWI7SUFDQSxLQUFLLFFBQUwsR0FBZ0IsTUFBTSxDQUFDLFFBQXZCO0lBQ0EsS0FBSyxLQUFMLEdBQWEsTUFBTSxDQUFDLEtBQXBCO0lBQ0EsS0FBSyxVQUFMLEdBQWtCLE1BQU0sQ0FBQyxVQUF6QjtJQUVBLEtBQUssS0FBTCxHQUFhLE1BQU0sQ0FBQyxLQUFwQjtJQUNBLEtBQUssT0FBTCxHQUFlLE1BQU0sQ0FBQyxPQUF0QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELE1BQU0sQ0FBRSxNQUFGLEVBQVUsU0FBVixFQUFxQixNQUFyQixFQUE4QjtJQUVuQyxNQUFNLElBQUksS0FBSyxRQUFmO0lBQ0EsTUFBTSxJQUFJLFNBQVMsQ0FBQyxRQUFwQjs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxRQUExQixFQUFvQyxDQUFDLEdBQUcsQ0FBeEMsRUFBMkMsQ0FBQyxFQUE1QyxFQUFrRDtNQUVqRCxLQUFLLEtBQUwsQ0FBWSxNQUFNLEdBQUcsQ0FBckIsSUFBMkIsU0FBUyxDQUFDLEtBQVYsQ0FBaUIsTUFBTSxHQUFHLENBQTFCLENBQTNCO0lBRUE7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsU0FBUyxDQUFFLEtBQUYsRUFBVTtJQUVsQixLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLEtBQWhCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLENBQUYsRUFBTTtJQUVqQixJQUFLLEtBQUssUUFBTCxLQUFrQixDQUF2QixFQUEyQjtNQUUxQixLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxLQUExQixFQUFpQyxDQUFDLEdBQUcsQ0FBckMsRUFBd0MsQ0FBQyxFQUF6QyxFQUErQztRQUU5QyxRQUFRLENBQUMsbUJBQVQsQ0FBOEIsSUFBOUIsRUFBb0MsQ0FBcEM7O1FBQ0EsUUFBUSxDQUFDLFlBQVQsQ0FBdUIsQ0FBdkI7O1FBRUEsS0FBSyxLQUFMLENBQVksQ0FBWixFQUFlLFFBQVEsQ0FBQyxDQUF4QixFQUEyQixRQUFRLENBQUMsQ0FBcEM7TUFFQTtJQUVELENBWEQsTUFXTyxJQUFLLEtBQUssUUFBTCxLQUFrQixDQUF2QixFQUEyQjtNQUVqQyxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxLQUExQixFQUFpQyxDQUFDLEdBQUcsQ0FBckMsRUFBd0MsQ0FBQyxFQUF6QyxFQUErQztRQUU5QyxPQUFPLENBQUMsbUJBQVIsQ0FBNkIsSUFBN0IsRUFBbUMsQ0FBbkM7O1FBQ0EsT0FBTyxDQUFDLFlBQVIsQ0FBc0IsQ0FBdEI7O1FBRUEsS0FBSyxNQUFMLENBQWEsQ0FBYixFQUFnQixPQUFPLENBQUMsQ0FBeEIsRUFBMkIsT0FBTyxDQUFDLENBQW5DLEVBQXNDLE9BQU8sQ0FBQyxDQUE5QztNQUVBO0lBRUQ7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLENBQUYsRUFBTTtJQUVqQixLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxLQUExQixFQUFpQyxDQUFDLEdBQUcsQ0FBckMsRUFBd0MsQ0FBQyxFQUF6QyxFQUErQztNQUU5QyxPQUFPLENBQUMsbUJBQVIsQ0FBNkIsSUFBN0IsRUFBbUMsQ0FBbkM7O01BRUEsT0FBTyxDQUFDLFlBQVIsQ0FBc0IsQ0FBdEI7O01BRUEsS0FBSyxNQUFMLENBQWEsQ0FBYixFQUFnQixPQUFPLENBQUMsQ0FBeEIsRUFBMkIsT0FBTyxDQUFDLENBQW5DLEVBQXNDLE9BQU8sQ0FBQyxDQUE5QztJQUVBOztJQUVELE9BQU8sSUFBUDtFQUVBOztFQUVELGlCQUFpQixDQUFFLENBQUYsRUFBTTtJQUV0QixLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxLQUExQixFQUFpQyxDQUFDLEdBQUcsQ0FBckMsRUFBd0MsQ0FBQyxFQUF6QyxFQUErQztNQUU5QyxPQUFPLENBQUMsbUJBQVIsQ0FBNkIsSUFBN0IsRUFBbUMsQ0FBbkM7O01BRUEsT0FBTyxDQUFDLGlCQUFSLENBQTJCLENBQTNCOztNQUVBLEtBQUssTUFBTCxDQUFhLENBQWIsRUFBZ0IsT0FBTyxDQUFDLENBQXhCLEVBQTJCLE9BQU8sQ0FBQyxDQUFuQyxFQUFzQyxPQUFPLENBQUMsQ0FBOUM7SUFFQTs7SUFFRCxPQUFPLElBQVA7RUFFQTs7RUFFRCxrQkFBa0IsQ0FBRSxDQUFGLEVBQU07SUFFdkIsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLEtBQUssS0FBMUIsRUFBaUMsQ0FBQyxHQUFHLENBQXJDLEVBQXdDLENBQUMsRUFBekMsRUFBK0M7TUFFOUMsT0FBTyxDQUFDLG1CQUFSLENBQTZCLElBQTdCLEVBQW1DLENBQW5DOztNQUVBLE9BQU8sQ0FBQyxrQkFBUixDQUE0QixDQUE1Qjs7TUFFQSxLQUFLLE1BQUwsQ0FBYSxDQUFiLEVBQWdCLE9BQU8sQ0FBQyxDQUF4QixFQUEyQixPQUFPLENBQUMsQ0FBbkMsRUFBc0MsT0FBTyxDQUFDLENBQTlDO0lBRUE7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsR0FBRyxDQUFFLEtBQUYsRUFBUyxNQUFNLEdBQUcsQ0FBbEIsRUFBc0I7SUFFeEI7SUFDQSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLEtBQWhCLEVBQXVCLE1BQXZCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLEtBQUYsRUFBUyxTQUFULEVBQXFCO0lBRWhDLElBQUksS0FBSyxHQUFHLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxLQUFLLFFBQWIsR0FBd0IsU0FBcEMsQ0FBWjtJQUVBLElBQUssS0FBSyxVQUFWLEVBQXVCLEtBQUssR0FBRyxJQUFBLHNCQUFBLEVBQWEsS0FBYixFQUFvQixLQUFLLEtBQXpCLENBQVI7SUFFdkIsT0FBTyxLQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLEtBQUYsRUFBUyxTQUFULEVBQW9CLEtBQXBCLEVBQTRCO0lBRXZDLElBQUssS0FBSyxVQUFWLEVBQXVCLEtBQUssR0FBRyxJQUFBLG9CQUFBLEVBQVcsS0FBWCxFQUFrQixLQUFLLEtBQXZCLENBQVI7SUFFdkIsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBYixHQUF3QixTQUFwQyxJQUFrRCxLQUFsRDtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVU7SUFFYixJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUF6QixDQUFSO0lBRUEsSUFBSyxLQUFLLFVBQVYsRUFBdUIsQ0FBQyxHQUFHLElBQUEsc0JBQUEsRUFBYSxDQUFiLEVBQWdCLEtBQUssS0FBckIsQ0FBSjtJQUV2QixPQUFPLENBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsS0FBRixFQUFTLENBQVQsRUFBYTtJQUVoQixJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7SUFFdkIsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBekIsSUFBc0MsQ0FBdEM7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsS0FBRixFQUFVO0lBRWIsSUFBSSxDQUFDLEdBQUcsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBYixHQUF3QixDQUFwQyxDQUFSO0lBRUEsSUFBSyxLQUFLLFVBQVYsRUFBdUIsQ0FBQyxHQUFHLElBQUEsc0JBQUEsRUFBYSxDQUFiLEVBQWdCLEtBQUssS0FBckIsQ0FBSjtJQUV2QixPQUFPLENBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsS0FBRixFQUFTLENBQVQsRUFBYTtJQUVoQixJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7SUFFdkIsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBYixHQUF3QixDQUFwQyxJQUEwQyxDQUExQztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVU7SUFFYixJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUFiLEdBQXdCLENBQXBDLENBQVI7SUFFQSxJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxzQkFBQSxFQUFhLENBQWIsRUFBZ0IsS0FBSyxLQUFyQixDQUFKO0lBRXZCLE9BQU8sQ0FBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVMsQ0FBVCxFQUFhO0lBRWhCLElBQUssS0FBSyxVQUFWLEVBQXVCLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtJQUV2QixLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUFiLEdBQXdCLENBQXBDLElBQTBDLENBQTFDO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBVTtJQUViLElBQUksQ0FBQyxHQUFHLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxLQUFLLFFBQWIsR0FBd0IsQ0FBcEMsQ0FBUjtJQUVBLElBQUssS0FBSyxVQUFWLEVBQXVCLENBQUMsR0FBRyxJQUFBLHNCQUFBLEVBQWEsQ0FBYixFQUFnQixLQUFLLEtBQXJCLENBQUo7SUFFdkIsT0FBTyxDQUFQO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBUyxDQUFULEVBQWE7SUFFaEIsSUFBSyxLQUFLLFVBQVYsRUFBdUIsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO0lBRXZCLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxLQUFLLFFBQWIsR0FBd0IsQ0FBcEMsSUFBMEMsQ0FBMUM7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxLQUFLLENBQUUsS0FBRixFQUFTLENBQVQsRUFBWSxDQUFaLEVBQWdCO0lBRXBCLEtBQUssSUFBSSxLQUFLLFFBQWQ7O0lBRUEsSUFBSyxLQUFLLFVBQVYsRUFBdUI7TUFFdEIsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO01BQ0EsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO0lBRUE7O0lBRUQsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLENBQTFCO0lBQ0EsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLENBQTFCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsTUFBTSxDQUFFLEtBQUYsRUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWYsRUFBbUI7SUFFeEIsS0FBSyxJQUFJLEtBQUssUUFBZDs7SUFFQSxJQUFLLEtBQUssVUFBVixFQUF1QjtNQUV0QixDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7TUFDQSxDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7TUFDQSxDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7SUFFQTs7SUFFRCxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsQ0FBcEIsSUFBMEIsQ0FBMUI7SUFDQSxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsQ0FBcEIsSUFBMEIsQ0FBMUI7SUFDQSxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsQ0FBcEIsSUFBMEIsQ0FBMUI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxPQUFPLENBQUUsS0FBRixFQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFzQjtJQUU1QixLQUFLLElBQUksS0FBSyxRQUFkOztJQUVBLElBQUssS0FBSyxVQUFWLEVBQXVCO01BRXRCLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtNQUNBLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtNQUNBLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtNQUNBLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtJQUVBOztJQUVELEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixDQUExQjtJQUNBLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixDQUExQjtJQUNBLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixDQUExQjtJQUNBLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixDQUExQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELFFBQVEsQ0FBRSxRQUFGLEVBQWE7SUFFcEIsS0FBSyxnQkFBTCxHQUF3QixRQUF4QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELEtBQUssR0FBRztJQUVQLE9BQU8sSUFBSSxLQUFLLFdBQVQsQ0FBc0IsS0FBSyxLQUEzQixFQUFrQyxLQUFLLFFBQXZDLEVBQWtELElBQWxELENBQXdELElBQXhELENBQVA7RUFFQTs7RUFFRCxNQUFNLEdBQUc7SUFFUixNQUFNLElBQUksR0FBRztNQUNaLFFBQVEsRUFBRSxLQUFLLFFBREg7TUFFWixJQUFJLEVBQUUsS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixJQUZqQjtNQUdaLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBTixDQUFZLEtBQUssS0FBakIsQ0FISztNQUlaLFVBQVUsRUFBRSxLQUFLO0lBSkwsQ0FBYjtJQU9BLElBQUssS0FBSyxJQUFMLEtBQWMsRUFBbkIsRUFBd0IsSUFBSSxDQUFDLElBQUwsR0FBWSxLQUFLLElBQWpCO0lBQ3hCLElBQUssS0FBSyxLQUFMLEtBQWUsMEJBQXBCLEVBQXNDLElBQUksQ0FBQyxLQUFMLEdBQWEsS0FBSyxLQUFsQjtJQUN0QyxJQUFLLEtBQUssV0FBTCxDQUFpQixNQUFqQixLQUE0QixDQUE1QixJQUFpQyxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsS0FBMkIsQ0FBRSxDQUFuRSxFQUF1RSxJQUFJLENBQUMsV0FBTCxHQUFtQixLQUFLLFdBQXhCO0lBRXZFLE9BQU8sSUFBUDtFQUVBOztBQXJXb0IsQyxDQXlXdEI7Ozs7O0FBRUEsTUFBTSxtQkFBTixTQUFrQyxlQUFsQyxDQUFrRDtFQUVqRCxXQUFXLENBQUUsS0FBRixFQUFTLFFBQVQsRUFBbUIsVUFBbkIsRUFBZ0M7SUFFMUMsTUFBTyxJQUFJLFNBQUosQ0FBZSxLQUFmLENBQVAsRUFBK0IsUUFBL0IsRUFBeUMsVUFBekM7RUFFQTs7QUFOZ0Q7Ozs7QUFVbEQsTUFBTSxvQkFBTixTQUFtQyxlQUFuQyxDQUFtRDtFQUVsRCxXQUFXLENBQUUsS0FBRixFQUFTLFFBQVQsRUFBbUIsVUFBbkIsRUFBZ0M7SUFFMUMsTUFBTyxJQUFJLFVBQUosQ0FBZ0IsS0FBaEIsQ0FBUCxFQUFnQyxRQUFoQyxFQUEwQyxVQUExQztFQUVBOztBQU5pRDs7OztBQVVuRCxNQUFNLDJCQUFOLFNBQTBDLGVBQTFDLENBQTBEO0VBRXpELFdBQVcsQ0FBRSxLQUFGLEVBQVMsUUFBVCxFQUFtQixVQUFuQixFQUFnQztJQUUxQyxNQUFPLElBQUksaUJBQUosQ0FBdUIsS0FBdkIsQ0FBUCxFQUF1QyxRQUF2QyxFQUFpRCxVQUFqRDtFQUVBOztBQU53RDs7OztBQVUxRCxNQUFNLG9CQUFOLFNBQW1DLGVBQW5DLENBQW1EO0VBRWxELFdBQVcsQ0FBRSxLQUFGLEVBQVMsUUFBVCxFQUFtQixVQUFuQixFQUFnQztJQUUxQyxNQUFPLElBQUksVUFBSixDQUFnQixLQUFoQixDQUFQLEVBQWdDLFFBQWhDLEVBQTBDLFVBQTFDO0VBRUE7O0FBTmlEOzs7O0FBVW5ELE1BQU0scUJBQU4sU0FBb0MsZUFBcEMsQ0FBb0Q7RUFFbkQsV0FBVyxDQUFFLEtBQUYsRUFBUyxRQUFULEVBQW1CLFVBQW5CLEVBQWdDO0lBRTFDLE1BQU8sSUFBSSxXQUFKLENBQWlCLEtBQWpCLENBQVAsRUFBaUMsUUFBakMsRUFBMkMsVUFBM0M7RUFFQTs7QUFOa0Q7Ozs7QUFVcEQsTUFBTSxvQkFBTixTQUFtQyxlQUFuQyxDQUFtRDtFQUVsRCxXQUFXLENBQUUsS0FBRixFQUFTLFFBQVQsRUFBbUIsVUFBbkIsRUFBZ0M7SUFFMUMsTUFBTyxJQUFJLFVBQUosQ0FBZ0IsS0FBaEIsQ0FBUCxFQUFnQyxRQUFoQyxFQUEwQyxVQUExQztFQUVBOztBQU5pRDs7OztBQVVuRCxNQUFNLHFCQUFOLFNBQW9DLGVBQXBDLENBQW9EO0VBRW5ELFdBQVcsQ0FBRSxLQUFGLEVBQVMsUUFBVCxFQUFtQixVQUFuQixFQUFnQztJQUUxQyxNQUFPLElBQUksV0FBSixDQUFpQixLQUFqQixDQUFQLEVBQWlDLFFBQWpDLEVBQTJDLFVBQTNDO0VBRUE7O0FBTmtEOzs7O0FBVXBELE1BQU0sc0JBQU4sU0FBcUMsZUFBckMsQ0FBcUQ7RUFFcEQsV0FBVyxDQUFFLEtBQUYsRUFBUyxRQUFULEVBQW1CLFVBQW5CLEVBQWdDO0lBRTFDLE1BQU8sSUFBSSxXQUFKLENBQWlCLEtBQWpCLENBQVAsRUFBaUMsUUFBakMsRUFBMkMsVUFBM0M7SUFFQSxLQUFLLHdCQUFMLEdBQWdDLElBQWhDO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBVTtJQUViLElBQUksQ0FBQyxHQUFHLElBQUEsd0JBQUEsRUFBZSxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUF6QixDQUFmLENBQVI7SUFFQSxJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxzQkFBQSxFQUFhLENBQWIsRUFBZ0IsS0FBSyxLQUFyQixDQUFKO0lBRXZCLE9BQU8sQ0FBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVMsQ0FBVCxFQUFhO0lBRWhCLElBQUssS0FBSyxVQUFWLEVBQXVCLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtJQUV2QixLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUF6QixJQUFzQyxJQUFBLHNCQUFBLEVBQWEsQ0FBYixDQUF0QztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVU7SUFFYixJQUFJLENBQUMsR0FBRyxJQUFBLHdCQUFBLEVBQWUsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBYixHQUF3QixDQUFwQyxDQUFmLENBQVI7SUFFQSxJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxzQkFBQSxFQUFhLENBQWIsRUFBZ0IsS0FBSyxLQUFyQixDQUFKO0lBRXZCLE9BQU8sQ0FBUDtFQUVBOztFQUVELElBQUksQ0FBRSxLQUFGLEVBQVMsQ0FBVCxFQUFhO0lBRWhCLElBQUssS0FBSyxVQUFWLEVBQXVCLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtJQUV2QixLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUFiLEdBQXdCLENBQXBDLElBQTBDLElBQUEsc0JBQUEsRUFBYSxDQUFiLENBQTFDO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBVTtJQUViLElBQUksQ0FBQyxHQUFHLElBQUEsd0JBQUEsRUFBZSxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsS0FBSyxRQUFiLEdBQXdCLENBQXBDLENBQWYsQ0FBUjtJQUVBLElBQUssS0FBSyxVQUFWLEVBQXVCLENBQUMsR0FBRyxJQUFBLHNCQUFBLEVBQWEsQ0FBYixFQUFnQixLQUFLLEtBQXJCLENBQUo7SUFFdkIsT0FBTyxDQUFQO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBUyxDQUFULEVBQWE7SUFFaEIsSUFBSyxLQUFLLFVBQVYsRUFBdUIsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO0lBRXZCLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxLQUFLLFFBQWIsR0FBd0IsQ0FBcEMsSUFBMEMsSUFBQSxzQkFBQSxFQUFhLENBQWIsQ0FBMUM7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsS0FBRixFQUFVO0lBRWIsSUFBSSxDQUFDLEdBQUcsSUFBQSx3QkFBQSxFQUFlLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxLQUFLLFFBQWIsR0FBd0IsQ0FBcEMsQ0FBZixDQUFSO0lBRUEsSUFBSyxLQUFLLFVBQVYsRUFBdUIsQ0FBQyxHQUFHLElBQUEsc0JBQUEsRUFBYSxDQUFiLEVBQWdCLEtBQUssS0FBckIsQ0FBSjtJQUV2QixPQUFPLENBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsS0FBRixFQUFTLENBQVQsRUFBYTtJQUVoQixJQUFLLEtBQUssVUFBVixFQUF1QixDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7SUFFdkIsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLEtBQUssUUFBYixHQUF3QixDQUFwQyxJQUEwQyxJQUFBLHNCQUFBLEVBQWEsQ0FBYixDQUExQztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELEtBQUssQ0FBRSxLQUFGLEVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZ0I7SUFFcEIsS0FBSyxJQUFJLEtBQUssUUFBZDs7SUFFQSxJQUFLLEtBQUssVUFBVixFQUF1QjtNQUV0QixDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7TUFDQSxDQUFDLEdBQUcsSUFBQSxvQkFBQSxFQUFXLENBQVgsRUFBYyxLQUFLLEtBQW5CLENBQUo7SUFFQTs7SUFFRCxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsQ0FBcEIsSUFBMEIsSUFBQSxzQkFBQSxFQUFhLENBQWIsQ0FBMUI7SUFDQSxLQUFLLEtBQUwsQ0FBWSxLQUFLLEdBQUcsQ0FBcEIsSUFBMEIsSUFBQSxzQkFBQSxFQUFhLENBQWIsQ0FBMUI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxNQUFNLENBQUUsS0FBRixFQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFtQjtJQUV4QixLQUFLLElBQUksS0FBSyxRQUFkOztJQUVBLElBQUssS0FBSyxVQUFWLEVBQXVCO01BRXRCLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtNQUNBLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtNQUNBLENBQUMsR0FBRyxJQUFBLG9CQUFBLEVBQVcsQ0FBWCxFQUFjLEtBQUssS0FBbkIsQ0FBSjtJQUVBOztJQUVELEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixJQUFBLHNCQUFBLEVBQWEsQ0FBYixDQUExQjtJQUNBLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixJQUFBLHNCQUFBLEVBQWEsQ0FBYixDQUExQjtJQUNBLEtBQUssS0FBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixJQUEwQixJQUFBLHNCQUFBLEVBQWEsQ0FBYixDQUExQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELE9BQU8sQ0FBRSxLQUFGLEVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLENBQWxCLEVBQXNCO0lBRTVCLEtBQUssSUFBSSxLQUFLLFFBQWQ7O0lBRUEsSUFBSyxLQUFLLFVBQVYsRUFBdUI7TUFFdEIsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO01BQ0EsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO01BQ0EsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO01BQ0EsQ0FBQyxHQUFHLElBQUEsb0JBQUEsRUFBVyxDQUFYLEVBQWMsS0FBSyxLQUFuQixDQUFKO0lBRUE7O0lBRUQsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLElBQUEsc0JBQUEsRUFBYSxDQUFiLENBQTFCO0lBQ0EsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLElBQUEsc0JBQUEsRUFBYSxDQUFiLENBQTFCO0lBQ0EsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLElBQUEsc0JBQUEsRUFBYSxDQUFiLENBQTFCO0lBQ0EsS0FBSyxLQUFMLENBQVksS0FBSyxHQUFHLENBQXBCLElBQTBCLElBQUEsc0JBQUEsRUFBYSxDQUFiLENBQTFCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0FBcEptRDs7OztBQXlKckQsTUFBTSxzQkFBTixTQUFxQyxlQUFyQyxDQUFxRDtFQUVwRCxXQUFXLENBQUUsS0FBRixFQUFTLFFBQVQsRUFBbUIsVUFBbkIsRUFBZ0M7SUFFMUMsTUFBTyxJQUFJLFlBQUosQ0FBa0IsS0FBbEIsQ0FBUCxFQUFrQyxRQUFsQyxFQUE0QyxVQUE1QztFQUVBOztBQU5tRDs7OztBQVVyRCxNQUFNLHNCQUFOLFNBQXFDLGVBQXJDLENBQXFEO0VBRXBELFdBQVcsQ0FBRSxLQUFGLEVBQVMsUUFBVCxFQUFtQixVQUFuQixFQUFnQztJQUUxQyxNQUFPLElBQUksWUFBSixDQUFrQixLQUFsQixDQUFQLEVBQWtDLFFBQWxDLEVBQTRDLFVBQTVDO0VBRUE7O0FBTm1ELEMsQ0FVckQ7Ozs7Ozs7Ozs7Ozs7QUN2bUJBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxJQUFJLEdBQUcsR0FBRyxDQUFWOztBQUVBLE1BQU0sR0FBRyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTFCOztBQUNBLE1BQU0sSUFBSSxHQUFHLGFBQWMsSUFBSSxrQkFBSixFQUEzQjs7QUFDQSxNQUFNLE9BQU8sR0FBRyxhQUFjLElBQUksZUFBSixFQUE5Qjs7QUFDQSxNQUFNLElBQUksR0FBRyxhQUFjLElBQUksU0FBSixFQUEzQjs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLGFBQWMsSUFBSSxTQUFKLEVBQXZDOztBQUNBLE1BQU0sT0FBTyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTlCOztBQUVBLE1BQU0sY0FBTixTQUE2QixnQ0FBN0IsQ0FBNkM7RUFFNUMsV0FBVyxHQUFHO0lBRWI7SUFFQSxLQUFLLGdCQUFMLEdBQXdCLElBQXhCO0lBRUEsTUFBTSxDQUFDLGNBQVAsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBN0IsRUFBbUM7TUFBRSxLQUFLLEVBQUUsR0FBRztJQUFaLENBQW5DO0lBRUEsS0FBSyxJQUFMLEdBQVksU0FBUyxDQUFDLFlBQVYsRUFBWjtJQUVBLEtBQUssSUFBTCxHQUFZLEVBQVo7SUFDQSxLQUFLLElBQUwsR0FBWSxnQkFBWjtJQUVBLEtBQUssS0FBTCxHQUFhLElBQWI7SUFDQSxLQUFLLFVBQUwsR0FBa0IsRUFBbEI7SUFFQSxLQUFLLGVBQUwsR0FBdUIsRUFBdkI7SUFDQSxLQUFLLG9CQUFMLEdBQTRCLEtBQTVCO0lBRUEsS0FBSyxNQUFMLEdBQWMsRUFBZDtJQUVBLEtBQUssV0FBTCxHQUFtQixJQUFuQjtJQUNBLEtBQUssY0FBTCxHQUFzQixJQUF0QjtJQUVBLEtBQUssU0FBTCxHQUFpQjtNQUFFLEtBQUssRUFBRSxDQUFUO01BQVksS0FBSyxFQUFFO0lBQW5CLENBQWpCO0lBRUEsS0FBSyxRQUFMLEdBQWdCLEVBQWhCO0VBRUE7O0VBRUQsUUFBUSxHQUFHO0lBRVYsT0FBTyxLQUFLLEtBQVo7RUFFQTs7RUFFRCxRQUFRLENBQUUsS0FBRixFQUFVO0lBRWpCLElBQUssS0FBSyxDQUFDLE9BQU4sQ0FBZSxLQUFmLENBQUwsRUFBOEI7TUFFN0IsS0FBSyxLQUFMLEdBQWEsS0FBTSxJQUFBLHVCQUFBLEVBQWtCLEtBQWxCLElBQTRCLHNDQUE1QixHQUFvRCxzQ0FBMUQsRUFBbUYsS0FBbkYsRUFBMEYsQ0FBMUYsQ0FBYjtJQUVBLENBSkQsTUFJTztNQUVOLEtBQUssS0FBTCxHQUFhLEtBQWI7SUFFQTs7SUFFRCxPQUFPLElBQVA7RUFFQTs7RUFFRCxZQUFZLENBQUUsSUFBRixFQUFTO0lBRXBCLE9BQU8sS0FBSyxVQUFMLENBQWlCLElBQWpCLENBQVA7RUFFQTs7RUFFRCxZQUFZLENBQUUsSUFBRixFQUFRLFNBQVIsRUFBb0I7SUFFL0IsS0FBSyxVQUFMLENBQWlCLElBQWpCLElBQTBCLFNBQTFCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsZUFBZSxDQUFFLElBQUYsRUFBUztJQUV2QixPQUFPLEtBQUssVUFBTCxDQUFpQixJQUFqQixDQUFQO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLElBQUYsRUFBUztJQUVwQixPQUFPLEtBQUssVUFBTCxDQUFpQixJQUFqQixNQUE0QixTQUFuQztFQUVBOztFQUVELFFBQVEsQ0FBRSxLQUFGLEVBQVMsS0FBVCxFQUFnQixhQUFhLEdBQUcsQ0FBaEMsRUFBb0M7SUFFM0MsS0FBSyxNQUFMLENBQVksSUFBWixDQUFrQjtNQUVqQixLQUFLLEVBQUUsS0FGVTtNQUdqQixLQUFLLEVBQUUsS0FIVTtNQUlqQixhQUFhLEVBQUU7SUFKRSxDQUFsQjtFQVFBOztFQUVELFdBQVcsR0FBRztJQUViLEtBQUssTUFBTCxHQUFjLEVBQWQ7RUFFQTs7RUFFRCxZQUFZLENBQUUsS0FBRixFQUFTLEtBQVQsRUFBaUI7SUFFNUIsS0FBSyxTQUFMLENBQWUsS0FBZixHQUF1QixLQUF2QjtJQUNBLEtBQUssU0FBTCxDQUFlLEtBQWYsR0FBdUIsS0FBdkI7RUFFQTs7RUFFRCxZQUFZLENBQUUsTUFBRixFQUFXO0lBRXRCLE1BQU0sUUFBUSxHQUFHLEtBQUssVUFBTCxDQUFnQixRQUFqQzs7SUFFQSxJQUFLLFFBQVEsS0FBSyxTQUFsQixFQUE4QjtNQUU3QixRQUFRLENBQUMsWUFBVCxDQUF1QixNQUF2QjtNQUVBLFFBQVEsQ0FBQyxXQUFULEdBQXVCLElBQXZCO0lBRUE7O0lBRUQsTUFBTSxNQUFNLEdBQUcsS0FBSyxVQUFMLENBQWdCLE1BQS9COztJQUVBLElBQUssTUFBTSxLQUFLLFNBQWhCLEVBQTRCO01BRTNCLE1BQU0sWUFBWSxHQUFHLElBQUksZ0JBQUosR0FBYyxlQUFkLENBQStCLE1BQS9CLENBQXJCO01BRUEsTUFBTSxDQUFDLGlCQUFQLENBQTBCLFlBQTFCO01BRUEsTUFBTSxDQUFDLFdBQVAsR0FBcUIsSUFBckI7SUFFQTs7SUFFRCxNQUFNLE9BQU8sR0FBRyxLQUFLLFVBQUwsQ0FBZ0IsT0FBaEM7O0lBRUEsSUFBSyxPQUFPLEtBQUssU0FBakIsRUFBNkI7TUFFNUIsT0FBTyxDQUFDLGtCQUFSLENBQTRCLE1BQTVCO01BRUEsT0FBTyxDQUFDLFdBQVIsR0FBc0IsSUFBdEI7SUFFQTs7SUFFRCxJQUFLLEtBQUssV0FBTCxLQUFxQixJQUExQixFQUFpQztNQUVoQyxLQUFLLGtCQUFMO0lBRUE7O0lBRUQsSUFBSyxLQUFLLGNBQUwsS0FBd0IsSUFBN0IsRUFBb0M7TUFFbkMsS0FBSyxxQkFBTDtJQUVBOztJQUVELE9BQU8sSUFBUDtFQUVBOztFQUVELGVBQWUsQ0FBRSxDQUFGLEVBQU07SUFFcEIsR0FBRyxDQUFDLDBCQUFKLENBQWdDLENBQWhDOztJQUVBLEtBQUssWUFBTCxDQUFtQixHQUFuQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELE9BQU8sQ0FBRSxLQUFGLEVBQVU7SUFFaEI7SUFFQSxHQUFHLENBQUMsYUFBSixDQUFtQixLQUFuQjs7SUFFQSxLQUFLLFlBQUwsQ0FBbUIsR0FBbkI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxPQUFPLENBQUUsS0FBRixFQUFVO0lBRWhCO0lBRUEsR0FBRyxDQUFDLGFBQUosQ0FBbUIsS0FBbkI7O0lBRUEsS0FBSyxZQUFMLENBQW1CLEdBQW5CO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsT0FBTyxDQUFFLEtBQUYsRUFBVTtJQUVoQjtJQUVBLEdBQUcsQ0FBQyxhQUFKLENBQW1CLEtBQW5COztJQUVBLEtBQUssWUFBTCxDQUFtQixHQUFuQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELFNBQVMsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsRUFBWTtJQUVwQjtJQUVBLEdBQUcsQ0FBQyxlQUFKLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCLENBQTNCOztJQUVBLEtBQUssWUFBTCxDQUFtQixHQUFuQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELEtBQUssQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsRUFBWTtJQUVoQjtJQUVBLEdBQUcsQ0FBQyxTQUFKLENBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQixDQUFyQjs7SUFFQSxLQUFLLFlBQUwsQ0FBbUIsR0FBbkI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxNQUFNLENBQUUsTUFBRixFQUFXO0lBRWhCLElBQUksQ0FBQyxNQUFMLENBQWEsTUFBYjs7SUFFQSxJQUFJLENBQUMsWUFBTDs7SUFFQSxLQUFLLFlBQUwsQ0FBbUIsSUFBSSxDQUFDLE1BQXhCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsTUFBTSxHQUFHO0lBRVIsS0FBSyxrQkFBTDtJQUVBLEtBQUssV0FBTCxDQUFpQixTQUFqQixDQUE0QixPQUE1QixFQUFzQyxNQUF0QztJQUVBLEtBQUssU0FBTCxDQUFnQixPQUFPLENBQUMsQ0FBeEIsRUFBMkIsT0FBTyxDQUFDLENBQW5DLEVBQXNDLE9BQU8sQ0FBQyxDQUE5QztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELGFBQWEsQ0FBRSxNQUFGLEVBQVc7SUFFdkIsTUFBTSxRQUFRLEdBQUcsRUFBakI7O0lBRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsQ0FBeEMsRUFBMkMsQ0FBQyxFQUE1QyxFQUFrRDtNQUVqRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUUsQ0FBRixDQUFwQjtNQUNBLFFBQVEsQ0FBQyxJQUFULENBQWUsS0FBSyxDQUFDLENBQXJCLEVBQXdCLEtBQUssQ0FBQyxDQUE5QixFQUFpQyxLQUFLLENBQUMsQ0FBTixJQUFXLENBQTVDO0lBRUE7O0lBRUQsS0FBSyxZQUFMLENBQW1CLFVBQW5CLEVBQStCLElBQUksdUNBQUosQ0FBNEIsUUFBNUIsRUFBc0MsQ0FBdEMsQ0FBL0I7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxrQkFBa0IsR0FBRztJQUVwQixJQUFLLEtBQUssV0FBTCxLQUFxQixJQUExQixFQUFpQztNQUVoQyxLQUFLLFdBQUwsR0FBbUIsSUFBSSxTQUFKLEVBQW5CO0lBRUE7O0lBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxVQUFMLENBQWdCLFFBQWpDO0lBQ0EsTUFBTSx1QkFBdUIsR0FBRyxLQUFLLGVBQUwsQ0FBcUIsUUFBckQ7O0lBRUEsSUFBSyxRQUFRLElBQUksUUFBUSxDQUFDLG1CQUExQixFQUFnRDtNQUUvQyxPQUFPLENBQUMsS0FBUixDQUFlLGlKQUFmLEVBQWtLLElBQWxLO01BRUEsS0FBSyxXQUFMLENBQWlCLEdBQWpCLENBQ0MsSUFBSSxlQUFKLENBQWEsQ0FBRSxRQUFmLEVBQXlCLENBQUUsUUFBM0IsRUFBcUMsQ0FBRSxRQUF2QyxDQURELEVBRUMsSUFBSSxlQUFKLENBQWEsQ0FBRSxRQUFmLEVBQXlCLENBQUUsUUFBM0IsRUFBcUMsQ0FBRSxRQUF2QyxDQUZEO01BS0E7SUFFQTs7SUFFRCxJQUFLLFFBQVEsS0FBSyxTQUFsQixFQUE4QjtNQUU3QixLQUFLLFdBQUwsQ0FBaUIsc0JBQWpCLENBQXlDLFFBQXpDLEVBRjZCLENBSTdCOztNQUVBLElBQUssdUJBQUwsRUFBK0I7UUFFOUIsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLHVCQUF1QixDQUFDLE1BQTlDLEVBQXNELENBQUMsR0FBRyxFQUExRCxFQUE4RCxDQUFDLEVBQS9ELEVBQXFFO1VBRXBFLE1BQU0sY0FBYyxHQUFHLHVCQUF1QixDQUFFLENBQUYsQ0FBOUM7O1VBQ0EsSUFBSSxDQUFDLHNCQUFMLENBQTZCLGNBQTdCOztVQUVBLElBQUssS0FBSyxvQkFBVixFQUFpQztZQUVoQyxPQUFPLENBQUMsVUFBUixDQUFvQixLQUFLLFdBQUwsQ0FBaUIsR0FBckMsRUFBMEMsSUFBSSxDQUFDLEdBQS9DOztZQUNBLEtBQUssV0FBTCxDQUFpQixhQUFqQixDQUFnQyxPQUFoQzs7WUFFQSxPQUFPLENBQUMsVUFBUixDQUFvQixLQUFLLFdBQUwsQ0FBaUIsR0FBckMsRUFBMEMsSUFBSSxDQUFDLEdBQS9DOztZQUNBLEtBQUssV0FBTCxDQUFpQixhQUFqQixDQUFnQyxPQUFoQztVQUVBLENBUkQsTUFRTztZQUVOLEtBQUssV0FBTCxDQUFpQixhQUFqQixDQUFnQyxJQUFJLENBQUMsR0FBckM7WUFDQSxLQUFLLFdBQUwsQ0FBaUIsYUFBakIsQ0FBZ0MsSUFBSSxDQUFDLEdBQXJDO1VBRUE7UUFFRDtNQUVEO0lBRUQsQ0FoQ0QsTUFnQ087TUFFTixLQUFLLFdBQUwsQ0FBaUIsU0FBakI7SUFFQTs7SUFFRCxJQUFLLEtBQUssQ0FBRSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsQ0FBcUIsQ0FBdkIsQ0FBTCxJQUFtQyxLQUFLLENBQUUsS0FBSyxXQUFMLENBQWlCLEdBQWpCLENBQXFCLENBQXZCLENBQXhDLElBQXNFLEtBQUssQ0FBRSxLQUFLLFdBQUwsQ0FBaUIsR0FBakIsQ0FBcUIsQ0FBdkIsQ0FBaEYsRUFBNkc7TUFFNUcsT0FBTyxDQUFDLEtBQVIsQ0FBZSxxSUFBZixFQUFzSixJQUF0SjtJQUVBO0VBRUQ7O0VBRUQscUJBQXFCLEdBQUc7SUFFdkIsSUFBSyxLQUFLLGNBQUwsS0FBd0IsSUFBN0IsRUFBb0M7TUFFbkMsS0FBSyxjQUFMLEdBQXNCLElBQUksY0FBSixFQUF0QjtJQUVBOztJQUVELE1BQU0sUUFBUSxHQUFHLEtBQUssVUFBTCxDQUFnQixRQUFqQztJQUNBLE1BQU0sdUJBQXVCLEdBQUcsS0FBSyxlQUFMLENBQXFCLFFBQXJEOztJQUVBLElBQUssUUFBUSxJQUFJLFFBQVEsQ0FBQyxtQkFBMUIsRUFBZ0Q7TUFFL0MsT0FBTyxDQUFDLEtBQVIsQ0FBZSx1SkFBZixFQUF3SyxJQUF4SztNQUVBLEtBQUssY0FBTCxDQUFvQixHQUFwQixDQUF5QixJQUFJLGVBQUosRUFBekIsRUFBd0MsUUFBeEM7TUFFQTtJQUVBOztJQUVELElBQUssUUFBTCxFQUFnQjtNQUVmO01BRUEsTUFBTSxNQUFNLEdBQUcsS0FBSyxjQUFMLENBQW9CLE1BQW5DOztNQUVBLElBQUksQ0FBQyxzQkFBTCxDQUE2QixRQUE3QixFQU5lLENBUWY7OztNQUVBLElBQUssdUJBQUwsRUFBK0I7UUFFOUIsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLHVCQUF1QixDQUFDLE1BQTlDLEVBQXNELENBQUMsR0FBRyxFQUExRCxFQUE4RCxDQUFDLEVBQS9ELEVBQXFFO1VBRXBFLE1BQU0sY0FBYyxHQUFHLHVCQUF1QixDQUFFLENBQUYsQ0FBOUM7O1VBQ0EsZ0JBQWdCLENBQUMsc0JBQWpCLENBQXlDLGNBQXpDOztVQUVBLElBQUssS0FBSyxvQkFBVixFQUFpQztZQUVoQyxPQUFPLENBQUMsVUFBUixDQUFvQixJQUFJLENBQUMsR0FBekIsRUFBOEIsZ0JBQWdCLENBQUMsR0FBL0M7O1lBQ0EsSUFBSSxDQUFDLGFBQUwsQ0FBb0IsT0FBcEI7O1lBRUEsT0FBTyxDQUFDLFVBQVIsQ0FBb0IsSUFBSSxDQUFDLEdBQXpCLEVBQThCLGdCQUFnQixDQUFDLEdBQS9DOztZQUNBLElBQUksQ0FBQyxhQUFMLENBQW9CLE9BQXBCO1VBRUEsQ0FSRCxNQVFPO1lBRU4sSUFBSSxDQUFDLGFBQUwsQ0FBb0IsZ0JBQWdCLENBQUMsR0FBckM7O1lBQ0EsSUFBSSxDQUFDLGFBQUwsQ0FBb0IsZ0JBQWdCLENBQUMsR0FBckM7VUFFQTtRQUVEO01BRUQ7O01BRUQsSUFBSSxDQUFDLFNBQUwsQ0FBZ0IsTUFBaEIsRUFwQ2UsQ0FzQ2Y7TUFDQTs7O01BRUEsSUFBSSxXQUFXLEdBQUcsQ0FBbEI7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUEvQixFQUFzQyxDQUFDLEdBQUcsRUFBMUMsRUFBOEMsQ0FBQyxFQUEvQyxFQUFxRDtRQUVwRCxPQUFPLENBQUMsbUJBQVIsQ0FBNkIsUUFBN0IsRUFBdUMsQ0FBdkM7O1FBRUEsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVUsV0FBVixFQUF1QixNQUFNLENBQUMsaUJBQVAsQ0FBMEIsT0FBMUIsQ0FBdkIsQ0FBZDtNQUVBLENBakRjLENBbURmOzs7TUFFQSxJQUFLLHVCQUFMLEVBQStCO1FBRTlCLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyx1QkFBdUIsQ0FBQyxNQUE5QyxFQUFzRCxDQUFDLEdBQUcsRUFBMUQsRUFBOEQsQ0FBQyxFQUEvRCxFQUFxRTtVQUVwRSxNQUFNLGNBQWMsR0FBRyx1QkFBdUIsQ0FBRSxDQUFGLENBQTlDO1VBQ0EsTUFBTSxvQkFBb0IsR0FBRyxLQUFLLG9CQUFsQzs7VUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsY0FBYyxDQUFDLEtBQXJDLEVBQTRDLENBQUMsR0FBRyxFQUFoRCxFQUFvRCxDQUFDLEVBQXJELEVBQTJEO1lBRTFELE9BQU8sQ0FBQyxtQkFBUixDQUE2QixjQUE3QixFQUE2QyxDQUE3Qzs7WUFFQSxJQUFLLG9CQUFMLEVBQTRCO2NBRTNCLE9BQU8sQ0FBQyxtQkFBUixDQUE2QixRQUE3QixFQUF1QyxDQUF2Qzs7Y0FDQSxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWI7WUFFQTs7WUFFRCxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBVSxXQUFWLEVBQXVCLE1BQU0sQ0FBQyxpQkFBUCxDQUEwQixPQUExQixDQUF2QixDQUFkO1VBRUE7UUFFRDtNQUVEOztNQUVELEtBQUssY0FBTCxDQUFvQixNQUFwQixHQUE2QixJQUFJLENBQUMsSUFBTCxDQUFXLFdBQVgsQ0FBN0I7O01BRUEsSUFBSyxLQUFLLENBQUUsS0FBSyxjQUFMLENBQW9CLE1BQXRCLENBQVYsRUFBMkM7UUFFMUMsT0FBTyxDQUFDLEtBQVIsQ0FBZSw4SEFBZixFQUErSSxJQUEvSTtNQUVBO0lBRUQ7RUFFRDs7RUFFRCxlQUFlLEdBQUc7SUFFakIsTUFBTSxLQUFLLEdBQUcsS0FBSyxLQUFuQjtJQUNBLE1BQU0sVUFBVSxHQUFHLEtBQUssVUFBeEIsQ0FIaUIsQ0FLakI7SUFDQTs7SUFFQSxJQUFLLEtBQUssS0FBSyxJQUFWLElBQ0gsVUFBVSxDQUFDLFFBQVgsS0FBd0IsU0FEckIsSUFFSCxVQUFVLENBQUMsTUFBWCxLQUFzQixTQUZuQixJQUdILFVBQVUsQ0FBQyxFQUFYLEtBQWtCLFNBSHBCLEVBR2dDO01BRS9CLE9BQU8sQ0FBQyxLQUFSLENBQWUsOEdBQWY7TUFDQTtJQUVBOztJQUVELE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUF0QjtJQUNBLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxRQUFYLENBQW9CLEtBQXRDO0lBQ0EsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsS0FBbEM7SUFDQSxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsRUFBWCxDQUFjLEtBQTFCO0lBRUEsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQVYsR0FBbUIsQ0FBckM7O0lBRUEsSUFBSyxLQUFLLFlBQUwsQ0FBbUIsU0FBbkIsTUFBbUMsS0FBeEMsRUFBZ0Q7TUFFL0MsS0FBSyxZQUFMLENBQW1CLFNBQW5CLEVBQThCLElBQUksZ0NBQUosQ0FBcUIsSUFBSSxZQUFKLENBQWtCLElBQUksU0FBdEIsQ0FBckIsRUFBd0QsQ0FBeEQsQ0FBOUI7SUFFQTs7SUFFRCxNQUFNLFFBQVEsR0FBRyxLQUFLLFlBQUwsQ0FBbUIsU0FBbkIsRUFBK0IsS0FBaEQ7SUFFQSxNQUFNLElBQUksR0FBRyxFQUFiO0lBQUEsTUFBaUIsSUFBSSxHQUFHLEVBQXhCOztJQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsU0FBckIsRUFBZ0MsQ0FBQyxFQUFqQyxFQUF1QztNQUV0QyxJQUFJLENBQUUsQ0FBRixDQUFKLEdBQVksSUFBSSxlQUFKLEVBQVo7TUFDQSxJQUFJLENBQUUsQ0FBRixDQUFKLEdBQVksSUFBSSxlQUFKLEVBQVo7SUFFQTs7SUFFRCxNQUFNLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBWDtJQUFBLE1BQ0MsRUFBRSxHQUFHLElBQUksZUFBSixFQUROO0lBQUEsTUFFQyxFQUFFLEdBQUcsSUFBSSxlQUFKLEVBRk47SUFBQSxNQUlDLEdBQUcsR0FBRyxJQUFJLGdCQUFKLEVBSlA7SUFBQSxNQUtDLEdBQUcsR0FBRyxJQUFJLGdCQUFKLEVBTFA7SUFBQSxNQU1DLEdBQUcsR0FBRyxJQUFJLGdCQUFKLEVBTlA7SUFBQSxNQVFDLElBQUksR0FBRyxJQUFJLGVBQUosRUFSUjtJQUFBLE1BU0MsSUFBSSxHQUFHLElBQUksZUFBSixFQVRSOztJQVdBLFNBQVMsY0FBVCxDQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFtQztNQUVsQyxFQUFFLENBQUMsU0FBSCxDQUFjLFNBQWQsRUFBeUIsQ0FBQyxHQUFHLENBQTdCO01BQ0EsRUFBRSxDQUFDLFNBQUgsQ0FBYyxTQUFkLEVBQXlCLENBQUMsR0FBRyxDQUE3QjtNQUNBLEVBQUUsQ0FBQyxTQUFILENBQWMsU0FBZCxFQUF5QixDQUFDLEdBQUcsQ0FBN0I7TUFFQSxHQUFHLENBQUMsU0FBSixDQUFlLEdBQWYsRUFBb0IsQ0FBQyxHQUFHLENBQXhCO01BQ0EsR0FBRyxDQUFDLFNBQUosQ0FBZSxHQUFmLEVBQW9CLENBQUMsR0FBRyxDQUF4QjtNQUNBLEdBQUcsQ0FBQyxTQUFKLENBQWUsR0FBZixFQUFvQixDQUFDLEdBQUcsQ0FBeEI7TUFFQSxFQUFFLENBQUMsR0FBSCxDQUFRLEVBQVI7TUFDQSxFQUFFLENBQUMsR0FBSCxDQUFRLEVBQVI7TUFFQSxHQUFHLENBQUMsR0FBSixDQUFTLEdBQVQ7TUFDQSxHQUFHLENBQUMsR0FBSixDQUFTLEdBQVQ7TUFFQSxNQUFNLENBQUMsR0FBRyxPQUFRLEdBQUcsQ0FBQyxDQUFKLEdBQVEsR0FBRyxDQUFDLENBQVosR0FBZ0IsR0FBRyxDQUFDLENBQUosR0FBUSxHQUFHLENBQUMsQ0FBcEMsQ0FBVixDQWhCa0MsQ0FrQmxDOztNQUVBLElBQUssQ0FBRSxRQUFRLENBQUUsQ0FBRixDQUFmLEVBQXVCO01BRXZCLElBQUksQ0FBQyxJQUFMLENBQVcsRUFBWCxFQUFnQixjQUFoQixDQUFnQyxHQUFHLENBQUMsQ0FBcEMsRUFBd0MsZUFBeEMsQ0FBeUQsRUFBekQsRUFBNkQsQ0FBRSxHQUFHLENBQUMsQ0FBbkUsRUFBdUUsY0FBdkUsQ0FBdUYsQ0FBdkY7TUFDQSxJQUFJLENBQUMsSUFBTCxDQUFXLEVBQVgsRUFBZ0IsY0FBaEIsQ0FBZ0MsR0FBRyxDQUFDLENBQXBDLEVBQXdDLGVBQXhDLENBQXlELEVBQXpELEVBQTZELENBQUUsR0FBRyxDQUFDLENBQW5FLEVBQXVFLGNBQXZFLENBQXVGLENBQXZGO01BRUEsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO01BQ0EsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO01BQ0EsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO01BRUEsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO01BQ0EsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO01BQ0EsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVLEdBQVYsQ0FBZSxJQUFmO0lBRUE7O0lBRUQsSUFBSSxNQUFNLEdBQUcsS0FBSyxNQUFsQjs7SUFFQSxJQUFLLE1BQU0sQ0FBQyxNQUFQLEtBQWtCLENBQXZCLEVBQTJCO01BRTFCLE1BQU0sR0FBRyxDQUFFO1FBQ1YsS0FBSyxFQUFFLENBREc7UUFFVixLQUFLLEVBQUUsT0FBTyxDQUFDO01BRkwsQ0FBRixDQUFUO0lBS0E7O0lBRUQsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUE3QixFQUFxQyxDQUFDLEdBQUcsRUFBekMsRUFBNkMsRUFBRyxDQUFoRCxFQUFvRDtNQUVuRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUUsQ0FBRixDQUFwQjtNQUVBLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFwQjtNQUNBLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFwQjs7TUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLEtBQVIsRUFBZSxFQUFFLEdBQUcsS0FBSyxHQUFHLEtBQWxDLEVBQXlDLENBQUMsR0FBRyxFQUE3QyxFQUFpRCxDQUFDLElBQUksQ0FBdEQsRUFBMEQ7UUFFekQsY0FBYyxDQUNiLE9BQU8sQ0FBRSxDQUFDLEdBQUcsQ0FBTixDQURNLEVBRWIsT0FBTyxDQUFFLENBQUMsR0FBRyxDQUFOLENBRk0sRUFHYixPQUFPLENBQUUsQ0FBQyxHQUFHLENBQU4sQ0FITSxDQUFkO01BTUE7SUFFRDs7SUFFRCxNQUFNLEdBQUcsR0FBRyxJQUFJLGVBQUosRUFBWjtJQUFBLE1BQTJCLElBQUksR0FBRyxJQUFJLGVBQUosRUFBbEM7SUFDQSxNQUFNLENBQUMsR0FBRyxJQUFJLGVBQUosRUFBVjtJQUFBLE1BQXlCLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBOUI7O0lBRUEsU0FBUyxZQUFULENBQXVCLENBQXZCLEVBQTJCO01BRTFCLENBQUMsQ0FBQyxTQUFGLENBQWEsT0FBYixFQUFzQixDQUFDLEdBQUcsQ0FBMUI7TUFDQSxFQUFFLENBQUMsSUFBSCxDQUFTLENBQVQ7TUFFQSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUUsQ0FBRixDQUFkLENBTDBCLENBTzFCOztNQUVBLEdBQUcsQ0FBQyxJQUFKLENBQVUsQ0FBVjtNQUNBLEdBQUcsQ0FBQyxHQUFKLENBQVMsQ0FBQyxDQUFDLGNBQUYsQ0FBa0IsQ0FBQyxDQUFDLEdBQUYsQ0FBTyxDQUFQLENBQWxCLENBQVQsRUFBMEMsU0FBMUMsR0FWMEIsQ0FZMUI7O01BRUEsSUFBSSxDQUFDLFlBQUwsQ0FBbUIsRUFBbkIsRUFBdUIsQ0FBdkI7TUFDQSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFVLElBQUksQ0FBRSxDQUFGLENBQWQsQ0FBYjtNQUNBLE1BQU0sQ0FBQyxHQUFLLElBQUksR0FBRyxHQUFULEdBQWlCLENBQUUsR0FBbkIsR0FBeUIsR0FBbkM7TUFFQSxRQUFRLENBQUUsQ0FBQyxHQUFHLENBQU4sQ0FBUixHQUFvQixHQUFHLENBQUMsQ0FBeEI7TUFDQSxRQUFRLENBQUUsQ0FBQyxHQUFHLENBQUosR0FBUSxDQUFWLENBQVIsR0FBd0IsR0FBRyxDQUFDLENBQTVCO01BQ0EsUUFBUSxDQUFFLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBVixDQUFSLEdBQXdCLEdBQUcsQ0FBQyxDQUE1QjtNQUNBLFFBQVEsQ0FBRSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVYsQ0FBUixHQUF3QixDQUF4QjtJQUVBOztJQUVELEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBN0IsRUFBcUMsQ0FBQyxHQUFHLEVBQXpDLEVBQTZDLEVBQUcsQ0FBaEQsRUFBb0Q7TUFFbkQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFFLENBQUYsQ0FBcEI7TUFFQSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBcEI7TUFDQSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBcEI7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxLQUFSLEVBQWUsRUFBRSxHQUFHLEtBQUssR0FBRyxLQUFsQyxFQUF5QyxDQUFDLEdBQUcsRUFBN0MsRUFBaUQsQ0FBQyxJQUFJLENBQXRELEVBQTBEO1FBRXpELFlBQVksQ0FBRSxPQUFPLENBQUUsQ0FBQyxHQUFHLENBQU4sQ0FBVCxDQUFaO1FBQ0EsWUFBWSxDQUFFLE9BQU8sQ0FBRSxDQUFDLEdBQUcsQ0FBTixDQUFULENBQVo7UUFDQSxZQUFZLENBQUUsT0FBTyxDQUFFLENBQUMsR0FBRyxDQUFOLENBQVQsQ0FBWjtNQUVBO0lBRUQ7RUFFRDs7RUFFRCxvQkFBb0IsR0FBRztJQUV0QixNQUFNLEtBQUssR0FBRyxLQUFLLEtBQW5CO0lBQ0EsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLFlBQUwsQ0FBbUIsVUFBbkIsQ0FBMUI7O0lBRUEsSUFBSyxpQkFBaUIsS0FBSyxTQUEzQixFQUF1QztNQUV0QyxJQUFJLGVBQWUsR0FBRyxLQUFLLFlBQUwsQ0FBbUIsUUFBbkIsQ0FBdEI7O01BRUEsSUFBSyxlQUFlLEtBQUssU0FBekIsRUFBcUM7UUFFcEMsZUFBZSxHQUFHLElBQUksZ0NBQUosQ0FBcUIsSUFBSSxZQUFKLENBQWtCLGlCQUFpQixDQUFDLEtBQWxCLEdBQTBCLENBQTVDLENBQXJCLEVBQXNFLENBQXRFLENBQWxCO1FBQ0EsS0FBSyxZQUFMLENBQW1CLFFBQW5CLEVBQTZCLGVBQTdCO01BRUEsQ0FMRCxNQUtPO1FBRU47UUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsZUFBZSxDQUFDLEtBQXRDLEVBQTZDLENBQUMsR0FBRyxFQUFqRCxFQUFxRCxDQUFDLEVBQXRELEVBQTREO1VBRTNELGVBQWUsQ0FBQyxNQUFoQixDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQyxDQUFqQztRQUVBO01BRUQ7O01BRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxlQUFKLEVBQVg7TUFBQSxNQUEwQixFQUFFLEdBQUcsSUFBSSxlQUFKLEVBQS9CO01BQUEsTUFBOEMsRUFBRSxHQUFHLElBQUksZUFBSixFQUFuRDtNQUNBLE1BQU0sRUFBRSxHQUFHLElBQUksZUFBSixFQUFYO01BQUEsTUFBMEIsRUFBRSxHQUFHLElBQUksZUFBSixFQUEvQjtNQUFBLE1BQThDLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBbkQ7TUFDQSxNQUFNLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBWDtNQUFBLE1BQTBCLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBL0IsQ0F2QnNDLENBeUJ0Qzs7TUFFQSxJQUFLLEtBQUwsRUFBYTtRQUVaLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxLQUFLLENBQUMsS0FBNUIsRUFBbUMsQ0FBQyxHQUFHLEVBQXZDLEVBQTJDLENBQUMsSUFBSSxDQUFoRCxFQUFvRDtVQUVuRCxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBTixDQUFZLENBQUMsR0FBRyxDQUFoQixDQUFYO1VBQ0EsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FBWSxDQUFDLEdBQUcsQ0FBaEIsQ0FBWDtVQUNBLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxJQUFOLENBQVksQ0FBQyxHQUFHLENBQWhCLENBQVg7VUFFQSxFQUFFLENBQUMsbUJBQUgsQ0FBd0IsaUJBQXhCLEVBQTJDLEVBQTNDO1VBQ0EsRUFBRSxDQUFDLG1CQUFILENBQXdCLGlCQUF4QixFQUEyQyxFQUEzQztVQUNBLEVBQUUsQ0FBQyxtQkFBSCxDQUF3QixpQkFBeEIsRUFBMkMsRUFBM0M7VUFFQSxFQUFFLENBQUMsVUFBSCxDQUFlLEVBQWYsRUFBbUIsRUFBbkI7VUFDQSxFQUFFLENBQUMsVUFBSCxDQUFlLEVBQWYsRUFBbUIsRUFBbkI7VUFDQSxFQUFFLENBQUMsS0FBSCxDQUFVLEVBQVY7VUFFQSxFQUFFLENBQUMsbUJBQUgsQ0FBd0IsZUFBeEIsRUFBeUMsRUFBekM7VUFDQSxFQUFFLENBQUMsbUJBQUgsQ0FBd0IsZUFBeEIsRUFBeUMsRUFBekM7VUFDQSxFQUFFLENBQUMsbUJBQUgsQ0FBd0IsZUFBeEIsRUFBeUMsRUFBekM7VUFFQSxFQUFFLENBQUMsR0FBSCxDQUFRLEVBQVI7VUFDQSxFQUFFLENBQUMsR0FBSCxDQUFRLEVBQVI7VUFDQSxFQUFFLENBQUMsR0FBSCxDQUFRLEVBQVI7VUFFQSxlQUFlLENBQUMsTUFBaEIsQ0FBd0IsRUFBeEIsRUFBNEIsRUFBRSxDQUFDLENBQS9CLEVBQWtDLEVBQUUsQ0FBQyxDQUFyQyxFQUF3QyxFQUFFLENBQUMsQ0FBM0M7VUFDQSxlQUFlLENBQUMsTUFBaEIsQ0FBd0IsRUFBeEIsRUFBNEIsRUFBRSxDQUFDLENBQS9CLEVBQWtDLEVBQUUsQ0FBQyxDQUFyQyxFQUF3QyxFQUFFLENBQUMsQ0FBM0M7VUFDQSxlQUFlLENBQUMsTUFBaEIsQ0FBd0IsRUFBeEIsRUFBNEIsRUFBRSxDQUFDLENBQS9CLEVBQWtDLEVBQUUsQ0FBQyxDQUFyQyxFQUF3QyxFQUFFLENBQUMsQ0FBM0M7UUFFQTtNQUVELENBOUJELE1BOEJPO1FBRU47UUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsaUJBQWlCLENBQUMsS0FBeEMsRUFBK0MsQ0FBQyxHQUFHLEVBQW5ELEVBQXVELENBQUMsSUFBSSxDQUE1RCxFQUFnRTtVQUUvRCxFQUFFLENBQUMsbUJBQUgsQ0FBd0IsaUJBQXhCLEVBQTJDLENBQUMsR0FBRyxDQUEvQztVQUNBLEVBQUUsQ0FBQyxtQkFBSCxDQUF3QixpQkFBeEIsRUFBMkMsQ0FBQyxHQUFHLENBQS9DO1VBQ0EsRUFBRSxDQUFDLG1CQUFILENBQXdCLGlCQUF4QixFQUEyQyxDQUFDLEdBQUcsQ0FBL0M7VUFFQSxFQUFFLENBQUMsVUFBSCxDQUFlLEVBQWYsRUFBbUIsRUFBbkI7VUFDQSxFQUFFLENBQUMsVUFBSCxDQUFlLEVBQWYsRUFBbUIsRUFBbkI7VUFDQSxFQUFFLENBQUMsS0FBSCxDQUFVLEVBQVY7VUFFQSxlQUFlLENBQUMsTUFBaEIsQ0FBd0IsQ0FBQyxHQUFHLENBQTVCLEVBQStCLEVBQUUsQ0FBQyxDQUFsQyxFQUFxQyxFQUFFLENBQUMsQ0FBeEMsRUFBMkMsRUFBRSxDQUFDLENBQTlDO1VBQ0EsZUFBZSxDQUFDLE1BQWhCLENBQXdCLENBQUMsR0FBRyxDQUE1QixFQUErQixFQUFFLENBQUMsQ0FBbEMsRUFBcUMsRUFBRSxDQUFDLENBQXhDLEVBQTJDLEVBQUUsQ0FBQyxDQUE5QztVQUNBLGVBQWUsQ0FBQyxNQUFoQixDQUF3QixDQUFDLEdBQUcsQ0FBNUIsRUFBK0IsRUFBRSxDQUFDLENBQWxDLEVBQXFDLEVBQUUsQ0FBQyxDQUF4QyxFQUEyQyxFQUFFLENBQUMsQ0FBOUM7UUFFQTtNQUVEOztNQUVELEtBQUssZ0JBQUw7TUFFQSxlQUFlLENBQUMsV0FBaEIsR0FBOEIsSUFBOUI7SUFFQTtFQUVEOztFQUVELGdCQUFnQixHQUFHO0lBRWxCLE1BQU0sT0FBTyxHQUFHLEtBQUssVUFBTCxDQUFnQixNQUFoQzs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQTlCLEVBQXFDLENBQUMsR0FBRyxFQUF6QyxFQUE2QyxDQUFDLEVBQTlDLEVBQW9EO01BRW5ELE9BQU8sQ0FBQyxtQkFBUixDQUE2QixPQUE3QixFQUFzQyxDQUF0Qzs7TUFFQSxPQUFPLENBQUMsU0FBUjs7TUFFQSxPQUFPLENBQUMsTUFBUixDQUFnQixDQUFoQixFQUFtQixPQUFPLENBQUMsQ0FBM0IsRUFBOEIsT0FBTyxDQUFDLENBQXRDLEVBQXlDLE9BQU8sQ0FBQyxDQUFqRDtJQUVBO0VBRUQ7O0VBRUQsWUFBWSxHQUFHO0lBRWQsU0FBUyxzQkFBVCxDQUFpQyxTQUFqQyxFQUE0QyxPQUE1QyxFQUFzRDtNQUVyRCxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsS0FBeEI7TUFDQSxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsUUFBM0I7TUFDQSxNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsVUFBN0I7TUFFQSxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxXQUFWLENBQXVCLE9BQU8sQ0FBQyxNQUFSLEdBQWlCLFFBQXhDLENBQWY7TUFFQSxJQUFJLEtBQUssR0FBRyxDQUFaO01BQUEsSUFBZSxNQUFNLEdBQUcsQ0FBeEI7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUE3QixFQUFxQyxDQUFDLEdBQUcsQ0FBekMsRUFBNEMsQ0FBQyxFQUE3QyxFQUFtRDtRQUVsRCxJQUFLLFNBQVMsQ0FBQyw0QkFBZixFQUE4QztVQUU3QyxLQUFLLEdBQUcsT0FBTyxDQUFFLENBQUYsQ0FBUCxHQUFlLFNBQVMsQ0FBQyxJQUFWLENBQWUsTUFBOUIsR0FBdUMsU0FBUyxDQUFDLE1BQXpEO1FBRUEsQ0FKRCxNQUlPO1VBRU4sS0FBSyxHQUFHLE9BQU8sQ0FBRSxDQUFGLENBQVAsR0FBZSxRQUF2QjtRQUVBOztRQUVELEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsUUFBckIsRUFBK0IsQ0FBQyxFQUFoQyxFQUFzQztVQUVyQyxNQUFNLENBQUUsTUFBTSxFQUFSLENBQU4sR0FBc0IsS0FBSyxDQUFFLEtBQUssRUFBUCxDQUEzQjtRQUVBO01BRUQ7O01BRUQsT0FBTyxJQUFJLGdDQUFKLENBQXFCLE1BQXJCLEVBQTZCLFFBQTdCLEVBQXVDLFVBQXZDLENBQVA7SUFFQSxDQWxDYSxDQW9DZDs7O0lBRUEsSUFBSyxLQUFLLEtBQUwsS0FBZSxJQUFwQixFQUEyQjtNQUUxQixPQUFPLENBQUMsSUFBUixDQUFjLDZFQUFkO01BQ0EsT0FBTyxJQUFQO0lBRUE7O0lBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxjQUFKLEVBQWxCO0lBRUEsTUFBTSxPQUFPLEdBQUcsS0FBSyxLQUFMLENBQVcsS0FBM0I7SUFDQSxNQUFNLFVBQVUsR0FBRyxLQUFLLFVBQXhCLENBaERjLENBa0RkOztJQUVBLEtBQU0sTUFBTSxJQUFaLElBQW9CLFVBQXBCLEVBQWlDO01BRWhDLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBRSxJQUFGLENBQTVCO01BRUEsTUFBTSxZQUFZLEdBQUcsc0JBQXNCLENBQUUsU0FBRixFQUFhLE9BQWIsQ0FBM0M7TUFFQSxTQUFTLENBQUMsWUFBVixDQUF3QixJQUF4QixFQUE4QixZQUE5QjtJQUVBLENBNURhLENBOERkOzs7SUFFQSxNQUFNLGVBQWUsR0FBRyxLQUFLLGVBQTdCOztJQUVBLEtBQU0sTUFBTSxJQUFaLElBQW9CLGVBQXBCLEVBQXNDO01BRXJDLE1BQU0sVUFBVSxHQUFHLEVBQW5CO01BQ0EsTUFBTSxjQUFjLEdBQUcsZUFBZSxDQUFFLElBQUYsQ0FBdEMsQ0FIcUMsQ0FHVzs7TUFFaEQsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLGNBQWMsQ0FBQyxNQUFyQyxFQUE2QyxDQUFDLEdBQUcsRUFBakQsRUFBcUQsQ0FBQyxFQUF0RCxFQUE0RDtRQUUzRCxNQUFNLFNBQVMsR0FBRyxjQUFjLENBQUUsQ0FBRixDQUFoQztRQUVBLE1BQU0sWUFBWSxHQUFHLHNCQUFzQixDQUFFLFNBQUYsRUFBYSxPQUFiLENBQTNDO1FBRUEsVUFBVSxDQUFDLElBQVgsQ0FBaUIsWUFBakI7TUFFQTs7TUFFRCxTQUFTLENBQUMsZUFBVixDQUEyQixJQUEzQixJQUFvQyxVQUFwQztJQUVBOztJQUVELFNBQVMsQ0FBQyxvQkFBVixHQUFpQyxLQUFLLG9CQUF0QyxDQXJGYyxDQXVGZDs7SUFFQSxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCOztJQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBNUIsRUFBb0MsQ0FBQyxHQUFHLENBQXhDLEVBQTJDLENBQUMsRUFBNUMsRUFBa0Q7TUFFakQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFFLENBQUYsQ0FBcEI7TUFDQSxTQUFTLENBQUMsUUFBVixDQUFvQixLQUFLLENBQUMsS0FBMUIsRUFBaUMsS0FBSyxDQUFDLEtBQXZDLEVBQThDLEtBQUssQ0FBQyxhQUFwRDtJQUVBOztJQUVELE9BQU8sU0FBUDtFQUVBOztFQUVELE1BQU0sR0FBRztJQUVSLE1BQU0sSUFBSSxHQUFHO01BQ1osUUFBUSxFQUFFO1FBQ1QsT0FBTyxFQUFFLEdBREE7UUFFVCxJQUFJLEVBQUUsZ0JBRkc7UUFHVCxTQUFTLEVBQUU7TUFIRjtJQURFLENBQWIsQ0FGUSxDQVVSOztJQUVBLElBQUksQ0FBQyxJQUFMLEdBQVksS0FBSyxJQUFqQjtJQUNBLElBQUksQ0FBQyxJQUFMLEdBQVksS0FBSyxJQUFqQjtJQUNBLElBQUssS0FBSyxJQUFMLEtBQWMsRUFBbkIsRUFBd0IsSUFBSSxDQUFDLElBQUwsR0FBWSxLQUFLLElBQWpCO0lBQ3hCLElBQUssTUFBTSxDQUFDLElBQVAsQ0FBYSxLQUFLLFFBQWxCLEVBQTZCLE1BQTdCLEdBQXNDLENBQTNDLEVBQStDLElBQUksQ0FBQyxRQUFMLEdBQWdCLEtBQUssUUFBckI7O0lBRS9DLElBQUssS0FBSyxVQUFMLEtBQW9CLFNBQXpCLEVBQXFDO01BRXBDLE1BQU0sVUFBVSxHQUFHLEtBQUssVUFBeEI7O01BRUEsS0FBTSxNQUFNLEdBQVosSUFBbUIsVUFBbkIsRUFBZ0M7UUFFL0IsSUFBSyxVQUFVLENBQUUsR0FBRixDQUFWLEtBQXNCLFNBQTNCLEVBQXVDLElBQUksQ0FBRSxHQUFGLENBQUosR0FBYyxVQUFVLENBQUUsR0FBRixDQUF4QjtNQUV2Qzs7TUFFRCxPQUFPLElBQVA7SUFFQSxDQTdCTyxDQStCUjs7O0lBRUEsSUFBSSxDQUFDLElBQUwsR0FBWTtNQUFFLFVBQVUsRUFBRTtJQUFkLENBQVo7SUFFQSxNQUFNLEtBQUssR0FBRyxLQUFLLEtBQW5COztJQUVBLElBQUssS0FBSyxLQUFLLElBQWYsRUFBc0I7TUFFckIsSUFBSSxDQUFDLElBQUwsQ0FBVSxLQUFWLEdBQWtCO1FBQ2pCLElBQUksRUFBRSxLQUFLLENBQUMsS0FBTixDQUFZLFdBQVosQ0FBd0IsSUFEYjtRQUVqQixLQUFLLEVBQUUsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBNEIsS0FBSyxDQUFDLEtBQWxDO01BRlUsQ0FBbEI7SUFLQTs7SUFFRCxNQUFNLFVBQVUsR0FBRyxLQUFLLFVBQXhCOztJQUVBLEtBQU0sTUFBTSxHQUFaLElBQW1CLFVBQW5CLEVBQWdDO01BRS9CLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBRSxHQUFGLENBQTVCO01BRUEsSUFBSSxDQUFDLElBQUwsQ0FBVSxVQUFWLENBQXNCLEdBQXRCLElBQThCLFNBQVMsQ0FBQyxNQUFWLENBQWtCLElBQUksQ0FBQyxJQUF2QixDQUE5QjtJQUVBOztJQUVELE1BQU0sZUFBZSxHQUFHLEVBQXhCO0lBQ0EsSUFBSSxrQkFBa0IsR0FBRyxLQUF6Qjs7SUFFQSxLQUFNLE1BQU0sR0FBWixJQUFtQixLQUFLLGVBQXhCLEVBQTBDO01BRXpDLE1BQU0sY0FBYyxHQUFHLEtBQUssZUFBTCxDQUFzQixHQUF0QixDQUF2QjtNQUVBLE1BQU0sS0FBSyxHQUFHLEVBQWQ7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLGNBQWMsQ0FBQyxNQUFyQyxFQUE2QyxDQUFDLEdBQUcsRUFBakQsRUFBcUQsQ0FBQyxFQUF0RCxFQUE0RDtRQUUzRCxNQUFNLFNBQVMsR0FBRyxjQUFjLENBQUUsQ0FBRixDQUFoQztRQUVBLEtBQUssQ0FBQyxJQUFOLENBQVksU0FBUyxDQUFDLE1BQVYsQ0FBa0IsSUFBSSxDQUFDLElBQXZCLENBQVo7TUFFQTs7TUFFRCxJQUFLLEtBQUssQ0FBQyxNQUFOLEdBQWUsQ0FBcEIsRUFBd0I7UUFFdkIsZUFBZSxDQUFFLEdBQUYsQ0FBZixHQUF5QixLQUF6QjtRQUVBLGtCQUFrQixHQUFHLElBQXJCO01BRUE7SUFFRDs7SUFFRCxJQUFLLGtCQUFMLEVBQTBCO01BRXpCLElBQUksQ0FBQyxJQUFMLENBQVUsZUFBVixHQUE0QixlQUE1QjtNQUNBLElBQUksQ0FBQyxJQUFMLENBQVUsb0JBQVYsR0FBaUMsS0FBSyxvQkFBdEM7SUFFQTs7SUFFRCxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCOztJQUVBLElBQUssTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBckIsRUFBeUI7TUFFeEIsSUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFWLEdBQW1CLElBQUksQ0FBQyxLQUFMLENBQVksSUFBSSxDQUFDLFNBQUwsQ0FBZ0IsTUFBaEIsQ0FBWixDQUFuQjtJQUVBOztJQUVELE1BQU0sY0FBYyxHQUFHLEtBQUssY0FBNUI7O0lBRUEsSUFBSyxjQUFjLEtBQUssSUFBeEIsRUFBK0I7TUFFOUIsSUFBSSxDQUFDLElBQUwsQ0FBVSxjQUFWLEdBQTJCO1FBQzFCLE1BQU0sRUFBRSxjQUFjLENBQUMsTUFBZixDQUFzQixPQUF0QixFQURrQjtRQUUxQixNQUFNLEVBQUUsY0FBYyxDQUFDO01BRkcsQ0FBM0I7SUFLQTs7SUFFRCxPQUFPLElBQVA7RUFFQTs7RUFFRCxLQUFLLEdBQUc7SUFFUCxPQUFPLElBQUksS0FBSyxXQUFULEdBQXVCLElBQXZCLENBQTZCLElBQTdCLENBQVA7RUFFQTs7RUFFRCxJQUFJLENBQUUsTUFBRixFQUFXO0lBRWQ7SUFFQSxLQUFLLEtBQUwsR0FBYSxJQUFiO0lBQ0EsS0FBSyxVQUFMLEdBQWtCLEVBQWxCO0lBQ0EsS0FBSyxlQUFMLEdBQXVCLEVBQXZCO0lBQ0EsS0FBSyxNQUFMLEdBQWMsRUFBZDtJQUNBLEtBQUssV0FBTCxHQUFtQixJQUFuQjtJQUNBLEtBQUssY0FBTCxHQUFzQixJQUF0QixDQVRjLENBV2Q7O0lBRUEsTUFBTSxJQUFJLEdBQUcsRUFBYixDQWJjLENBZWQ7O0lBRUEsS0FBSyxJQUFMLEdBQVksTUFBTSxDQUFDLElBQW5CLENBakJjLENBbUJkOztJQUVBLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFyQjs7SUFFQSxJQUFLLEtBQUssS0FBSyxJQUFmLEVBQXNCO01BRXJCLEtBQUssUUFBTCxDQUFlLEtBQUssQ0FBQyxLQUFOLENBQWEsSUFBYixDQUFmO0lBRUEsQ0EzQmEsQ0E2QmQ7OztJQUVBLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUExQjs7SUFFQSxLQUFNLE1BQU0sSUFBWixJQUFvQixVQUFwQixFQUFpQztNQUVoQyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUUsSUFBRixDQUE1QjtNQUNBLEtBQUssWUFBTCxDQUFtQixJQUFuQixFQUF5QixTQUFTLENBQUMsS0FBVixDQUFpQixJQUFqQixDQUF6QjtJQUVBLENBdENhLENBd0NkOzs7SUFFQSxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBL0I7O0lBRUEsS0FBTSxNQUFNLElBQVosSUFBb0IsZUFBcEIsRUFBc0M7TUFFckMsTUFBTSxLQUFLLEdBQUcsRUFBZDtNQUNBLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBRSxJQUFGLENBQXRDLENBSHFDLENBR1c7O01BRWhELEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBcEMsRUFBNEMsQ0FBQyxHQUFHLENBQWhELEVBQW1ELENBQUMsRUFBcEQsRUFBMEQ7UUFFekQsS0FBSyxDQUFDLElBQU4sQ0FBWSxjQUFjLENBQUUsQ0FBRixDQUFkLENBQW9CLEtBQXBCLENBQTJCLElBQTNCLENBQVo7TUFFQTs7TUFFRCxLQUFLLGVBQUwsQ0FBc0IsSUFBdEIsSUFBK0IsS0FBL0I7SUFFQTs7SUFFRCxLQUFLLG9CQUFMLEdBQTRCLE1BQU0sQ0FBQyxvQkFBbkMsQ0EzRGMsQ0E2RGQ7O0lBRUEsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQXRCOztJQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBNUIsRUFBb0MsQ0FBQyxHQUFHLENBQXhDLEVBQTJDLENBQUMsRUFBNUMsRUFBa0Q7TUFFakQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFFLENBQUYsQ0FBcEI7TUFDQSxLQUFLLFFBQUwsQ0FBZSxLQUFLLENBQUMsS0FBckIsRUFBNEIsS0FBSyxDQUFDLEtBQWxDLEVBQXlDLEtBQUssQ0FBQyxhQUEvQztJQUVBLENBdEVhLENBd0VkOzs7SUFFQSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBM0I7O0lBRUEsSUFBSyxXQUFXLEtBQUssSUFBckIsRUFBNEI7TUFFM0IsS0FBSyxXQUFMLEdBQW1CLFdBQVcsQ0FBQyxLQUFaLEVBQW5CO0lBRUEsQ0FoRmEsQ0FrRmQ7OztJQUVBLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUE5Qjs7SUFFQSxJQUFLLGNBQWMsS0FBSyxJQUF4QixFQUErQjtNQUU5QixLQUFLLGNBQUwsR0FBc0IsY0FBYyxDQUFDLEtBQWYsRUFBdEI7SUFFQSxDQTFGYSxDQTRGZDs7O0lBRUEsS0FBSyxTQUFMLENBQWUsS0FBZixHQUF1QixNQUFNLENBQUMsU0FBUCxDQUFpQixLQUF4QztJQUNBLEtBQUssU0FBTCxDQUFlLEtBQWYsR0FBdUIsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsS0FBeEMsQ0EvRmMsQ0FpR2Q7O0lBRUEsS0FBSyxRQUFMLEdBQWdCLE1BQU0sQ0FBQyxRQUF2QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELE9BQU8sR0FBRztJQUVULEtBQUssYUFBTCxDQUFvQjtNQUFFLElBQUksRUFBRTtJQUFSLENBQXBCO0VBRUE7O0FBN2hDMkM7Ozs7Ozs7Ozs7OztBQ3JCN0M7QUFDQTtBQUNBO0FBRUEsTUFBTSxlQUFOLENBQXNCO0VBRXJCLGdCQUFnQixDQUFFLElBQUYsRUFBUSxRQUFSLEVBQW1CO0lBRWxDLElBQUssS0FBSyxVQUFMLEtBQW9CLFNBQXpCLEVBQXFDLEtBQUssVUFBTCxHQUFrQixFQUFsQjtJQUVyQyxNQUFNLFNBQVMsR0FBRyxLQUFLLFVBQXZCOztJQUVBLElBQUssU0FBUyxDQUFFLElBQUYsQ0FBVCxLQUFzQixTQUEzQixFQUF1QztNQUV0QyxTQUFTLENBQUUsSUFBRixDQUFULEdBQW9CLEVBQXBCO0lBRUE7O0lBRUQsSUFBSyxTQUFTLENBQUUsSUFBRixDQUFULENBQWtCLE9BQWxCLENBQTJCLFFBQTNCLE1BQTBDLENBQUUsQ0FBakQsRUFBcUQ7TUFFcEQsU0FBUyxDQUFFLElBQUYsQ0FBVCxDQUFrQixJQUFsQixDQUF3QixRQUF4QjtJQUVBO0VBRUQ7O0VBRUQsZ0JBQWdCLENBQUUsSUFBRixFQUFRLFFBQVIsRUFBbUI7SUFFbEMsSUFBSyxLQUFLLFVBQUwsS0FBb0IsU0FBekIsRUFBcUMsT0FBTyxLQUFQO0lBRXJDLE1BQU0sU0FBUyxHQUFHLEtBQUssVUFBdkI7SUFFQSxPQUFPLFNBQVMsQ0FBRSxJQUFGLENBQVQsS0FBc0IsU0FBdEIsSUFBbUMsU0FBUyxDQUFFLElBQUYsQ0FBVCxDQUFrQixPQUFsQixDQUEyQixRQUEzQixNQUEwQyxDQUFFLENBQXRGO0VBRUE7O0VBRUQsbUJBQW1CLENBQUUsSUFBRixFQUFRLFFBQVIsRUFBbUI7SUFFckMsSUFBSyxLQUFLLFVBQUwsS0FBb0IsU0FBekIsRUFBcUM7SUFFckMsTUFBTSxTQUFTLEdBQUcsS0FBSyxVQUF2QjtJQUNBLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBRSxJQUFGLENBQS9COztJQUVBLElBQUssYUFBYSxLQUFLLFNBQXZCLEVBQW1DO01BRWxDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxPQUFkLENBQXVCLFFBQXZCLENBQWQ7O01BRUEsSUFBSyxLQUFLLEtBQUssQ0FBRSxDQUFqQixFQUFxQjtRQUVwQixhQUFhLENBQUMsTUFBZCxDQUFzQixLQUF0QixFQUE2QixDQUE3QjtNQUVBO0lBRUQ7RUFFRDs7RUFFRCxhQUFhLENBQUUsS0FBRixFQUFVO0lBRXRCLElBQUssS0FBSyxVQUFMLEtBQW9CLFNBQXpCLEVBQXFDO0lBRXJDLE1BQU0sU0FBUyxHQUFHLEtBQUssVUFBdkI7SUFDQSxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUUsS0FBSyxDQUFDLElBQVIsQ0FBL0I7O0lBRUEsSUFBSyxhQUFhLEtBQUssU0FBdkIsRUFBbUM7TUFFbEMsS0FBSyxDQUFDLE1BQU4sR0FBZSxJQUFmLENBRmtDLENBSWxDOztNQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxLQUFkLENBQXFCLENBQXJCLENBQWQ7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUEzQixFQUFtQyxDQUFDLEdBQUcsQ0FBdkMsRUFBMEMsQ0FBQyxFQUEzQyxFQUFpRDtRQUVoRCxLQUFLLENBQUUsQ0FBRixDQUFMLENBQVcsSUFBWCxDQUFpQixJQUFqQixFQUF1QixLQUF2QjtNQUVBOztNQUVELEtBQUssQ0FBQyxNQUFOLEdBQWUsSUFBZjtJQUVBO0VBRUQ7O0FBN0VvQjs7Ozs7Ozs7Ozs7O0FDSnRCLE1BQU0sTUFBTixDQUFhO0VBRVosV0FBVyxHQUFHO0lBRWIsS0FBSyxJQUFMLEdBQVksSUFBSSxDQUFoQjtFQUVBOztFQUVELEdBQUcsQ0FBRSxPQUFGLEVBQVk7SUFFZCxLQUFLLElBQUwsR0FBWSxDQUFFLEtBQUssT0FBTCxHQUFlLENBQWpCLE1BQXlCLENBQXJDO0VBRUE7O0VBRUQsTUFBTSxDQUFFLE9BQUYsRUFBWTtJQUVqQixLQUFLLElBQUwsSUFBYSxLQUFLLE9BQUwsR0FBZSxDQUE1QjtFQUVBOztFQUVELFNBQVMsR0FBRztJQUVYLEtBQUssSUFBTCxHQUFZLGFBQWEsQ0FBekI7RUFFQTs7RUFFRCxNQUFNLENBQUUsT0FBRixFQUFZO0lBRWpCLEtBQUssSUFBTCxJQUFhLEtBQUssT0FBTCxHQUFlLENBQTVCO0VBRUE7O0VBRUQsT0FBTyxDQUFFLE9BQUYsRUFBWTtJQUVsQixLQUFLLElBQUwsSUFBYSxFQUFJLEtBQUssT0FBTCxHQUFlLENBQW5CLENBQWI7RUFFQTs7RUFFRCxVQUFVLEdBQUc7SUFFWixLQUFLLElBQUwsR0FBWSxDQUFaO0VBRUE7O0VBRUQsSUFBSSxDQUFFLE1BQUYsRUFBVztJQUVkLE9BQU8sQ0FBRSxLQUFLLElBQUwsR0FBWSxNQUFNLENBQUMsSUFBckIsTUFBZ0MsQ0FBdkM7RUFFQTs7RUFFRCxTQUFTLENBQUUsT0FBRixFQUFZO0lBRXBCLE9BQU8sQ0FBRSxLQUFLLElBQUwsSUFBYyxLQUFLLE9BQUwsR0FBZSxDQUE3QixDQUFGLE1BQXlDLENBQWhEO0VBRUE7O0FBdERXOzs7Ozs7Ozs7Ozs7QUNBYjs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxXQUFXLEdBQUcsQ0FBbEI7O0FBRUEsTUFBTSxHQUFHLEdBQUcsYUFBYyxJQUFJLGVBQUosRUFBMUI7O0FBQ0EsTUFBTSxHQUFHLEdBQUcsYUFBYyxJQUFJLHNCQUFKLEVBQTFCOztBQUNBLE1BQU0sR0FBRyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTFCOztBQUNBLE1BQU0sT0FBTyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTlCOztBQUVBLE1BQU0sU0FBUyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQWhDOztBQUNBLE1BQU0sTUFBTSxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTdCOztBQUNBLE1BQU0sV0FBVyxHQUFHLGFBQWMsSUFBSSxzQkFBSixFQUFsQzs7QUFFQSxNQUFNLE1BQU0sR0FBRyxhQUFjLElBQUksZUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBN0I7O0FBQ0EsTUFBTSxNQUFNLEdBQUcsYUFBYyxJQUFJLGVBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQTdCOztBQUNBLE1BQU0sTUFBTSxHQUFHLGFBQWMsSUFBSSxlQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUE3Qjs7QUFFQSxNQUFNLFdBQVcsR0FBRztFQUFFLElBQUksRUFBRTtBQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFhLEdBQUc7RUFBRSxJQUFJLEVBQUU7QUFBUixDQUF0Qjs7QUFFQSxNQUFNLFFBQU4sU0FBdUIsZ0NBQXZCLENBQXVDO0VBRXRDLFdBQVcsR0FBRztJQUViO0lBRUEsS0FBSyxVQUFMLEdBQWtCLElBQWxCO0lBRUEsTUFBTSxDQUFDLGNBQVAsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBN0IsRUFBbUM7TUFBRSxLQUFLLEVBQUUsV0FBVztJQUFwQixDQUFuQztJQUVBLEtBQUssSUFBTCxHQUFZLFNBQVMsQ0FBQyxZQUFWLEVBQVo7SUFFQSxLQUFLLElBQUwsR0FBWSxFQUFaO0lBQ0EsS0FBSyxJQUFMLEdBQVksVUFBWjtJQUVBLEtBQUssTUFBTCxHQUFjLElBQWQ7SUFDQSxLQUFLLFFBQUwsR0FBZ0IsRUFBaEI7SUFFQSxLQUFLLEVBQUwsR0FBVSxRQUFRLENBQUMsVUFBVCxDQUFvQixLQUFwQixFQUFWO0lBRUEsTUFBTSxRQUFRLEdBQUcsSUFBSSxlQUFKLEVBQWpCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsSUFBSSxZQUFKLEVBQWpCO0lBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxzQkFBSixFQUFuQjtJQUNBLE1BQU0sS0FBSyxHQUFHLElBQUksZUFBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBZDs7SUFFQSxTQUFTLGdCQUFULEdBQTRCO01BRTNCLFVBQVUsQ0FBQyxZQUFYLENBQXlCLFFBQXpCLEVBQW1DLEtBQW5DO0lBRUE7O0lBRUQsU0FBUyxrQkFBVCxHQUE4QjtNQUU3QixRQUFRLENBQUMsaUJBQVQsQ0FBNEIsVUFBNUIsRUFBd0MsU0FBeEMsRUFBbUQsS0FBbkQ7SUFFQTs7SUFFRCxRQUFRLENBQUMsU0FBVCxDQUFvQixnQkFBcEI7O0lBQ0EsVUFBVSxDQUFDLFNBQVgsQ0FBc0Isa0JBQXRCOztJQUVBLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixJQUF6QixFQUErQjtNQUM5QixRQUFRLEVBQUU7UUFDVCxZQUFZLEVBQUUsSUFETDtRQUVULFVBQVUsRUFBRSxJQUZIO1FBR1QsS0FBSyxFQUFFO01BSEUsQ0FEb0I7TUFNOUIsUUFBUSxFQUFFO1FBQ1QsWUFBWSxFQUFFLElBREw7UUFFVCxVQUFVLEVBQUUsSUFGSDtRQUdULEtBQUssRUFBRTtNQUhFLENBTm9CO01BVzlCLFVBQVUsRUFBRTtRQUNYLFlBQVksRUFBRSxJQURIO1FBRVgsVUFBVSxFQUFFLElBRkQ7UUFHWCxLQUFLLEVBQUU7TUFISSxDQVhrQjtNQWdCOUIsS0FBSyxFQUFFO1FBQ04sWUFBWSxFQUFFLElBRFI7UUFFTixVQUFVLEVBQUUsSUFGTjtRQUdOLEtBQUssRUFBRTtNQUhELENBaEJ1QjtNQXFCOUIsZUFBZSxFQUFFO1FBQ2hCLEtBQUssRUFBRSxJQUFJLGVBQUo7TUFEUyxDQXJCYTtNQXdCOUIsWUFBWSxFQUFFO1FBQ2IsS0FBSyxFQUFFLElBQUksZ0JBQUo7TUFETTtJQXhCZ0IsQ0FBL0I7SUE2QkEsS0FBSyxNQUFMLEdBQWMsSUFBSSxlQUFKLEVBQWQ7SUFDQSxLQUFLLFdBQUwsR0FBbUIsSUFBSSxlQUFKLEVBQW5CO0lBRUEsS0FBSyxnQkFBTCxHQUF3QixRQUFRLENBQUMsMEJBQWpDO0lBQ0EsS0FBSyxzQkFBTCxHQUE4QixLQUE5QjtJQUVBLEtBQUsscUJBQUwsR0FBNkIsUUFBUSxDQUFDLGdDQUF0QyxDQXpFYSxDQXlFMkQ7O0lBRXhFLEtBQUssTUFBTCxHQUFjLElBQUksY0FBSixFQUFkO0lBQ0EsS0FBSyxPQUFMLEdBQWUsSUFBZjtJQUVBLEtBQUssVUFBTCxHQUFrQixLQUFsQjtJQUNBLEtBQUssYUFBTCxHQUFxQixLQUFyQjtJQUVBLEtBQUssYUFBTCxHQUFxQixJQUFyQjtJQUNBLEtBQUssV0FBTCxHQUFtQixDQUFuQjtJQUVBLEtBQUssVUFBTCxHQUFrQixFQUFsQjtJQUVBLEtBQUssUUFBTCxHQUFnQixFQUFoQjtFQUVBOztFQUVELGNBQWMsR0FBNkQsQ0FBRTs7RUFFN0UsYUFBYSxHQUE2RCxDQUFFOztFQUU1RSxZQUFZLENBQUUsTUFBRixFQUFXO0lBRXRCLElBQUssS0FBSyxnQkFBVixFQUE2QixLQUFLLFlBQUw7SUFFN0IsS0FBSyxNQUFMLENBQVksV0FBWixDQUF5QixNQUF6QjtJQUVBLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBdUIsS0FBSyxRQUE1QixFQUFzQyxLQUFLLFVBQTNDLEVBQXVELEtBQUssS0FBNUQ7RUFFQTs7RUFFRCxlQUFlLENBQUUsQ0FBRixFQUFNO0lBRXBCLEtBQUssVUFBTCxDQUFnQixXQUFoQixDQUE2QixDQUE3QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELHdCQUF3QixDQUFFLElBQUYsRUFBUSxLQUFSLEVBQWdCO0lBRXZDO0lBRUEsS0FBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QztFQUVBOztFQUVELG9CQUFvQixDQUFFLEtBQUYsRUFBVTtJQUU3QixLQUFLLFVBQUwsQ0FBZ0IsWUFBaEIsQ0FBOEIsS0FBOUIsRUFBcUMsSUFBckM7RUFFQTs7RUFFRCxxQkFBcUIsQ0FBRSxDQUFGLEVBQU07SUFFMUI7SUFFQSxLQUFLLFVBQUwsQ0FBZ0IscUJBQWhCLENBQXVDLENBQXZDO0VBRUE7O0VBRUQseUJBQXlCLENBQUUsQ0FBRixFQUFNO0lBRTlCO0lBRUEsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXNCLENBQXRCO0VBRUE7O0VBRUQsWUFBWSxDQUFFLElBQUYsRUFBUSxLQUFSLEVBQWdCO0lBRTNCO0lBQ0E7SUFFQSxHQUFHLENBQUMsZ0JBQUosQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUI7O0lBRUEsS0FBSyxVQUFMLENBQWdCLFFBQWhCLENBQTBCLEdBQTFCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsaUJBQWlCLENBQUUsSUFBRixFQUFRLEtBQVIsRUFBZ0I7SUFFaEM7SUFDQTtJQUNBO0lBRUEsR0FBRyxDQUFDLGdCQUFKLENBQXNCLElBQXRCLEVBQTRCLEtBQTVCOztJQUVBLEtBQUssVUFBTCxDQUFnQixXQUFoQixDQUE2QixHQUE3QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELE9BQU8sQ0FBRSxLQUFGLEVBQVU7SUFFaEIsT0FBTyxLQUFLLFlBQUwsQ0FBbUIsTUFBbkIsRUFBMkIsS0FBM0IsQ0FBUDtFQUVBOztFQUVELE9BQU8sQ0FBRSxLQUFGLEVBQVU7SUFFaEIsT0FBTyxLQUFLLFlBQUwsQ0FBbUIsTUFBbkIsRUFBMkIsS0FBM0IsQ0FBUDtFQUVBOztFQUVELE9BQU8sQ0FBRSxLQUFGLEVBQVU7SUFFaEIsT0FBTyxLQUFLLFlBQUwsQ0FBbUIsTUFBbkIsRUFBMkIsS0FBM0IsQ0FBUDtFQUVBOztFQUVELGVBQWUsQ0FBRSxJQUFGLEVBQVEsUUFBUixFQUFtQjtJQUVqQztJQUNBO0lBRUEsR0FBRyxDQUFDLElBQUosQ0FBVSxJQUFWLEVBQWlCLGVBQWpCLENBQWtDLEtBQUssVUFBdkM7O0lBRUEsS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFtQixHQUFHLENBQUMsY0FBSixDQUFvQixRQUFwQixDQUFuQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELFVBQVUsQ0FBRSxRQUFGLEVBQWE7SUFFdEIsT0FBTyxLQUFLLGVBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsUUFBOUIsQ0FBUDtFQUVBOztFQUVELFVBQVUsQ0FBRSxRQUFGLEVBQWE7SUFFdEIsT0FBTyxLQUFLLGVBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsUUFBOUIsQ0FBUDtFQUVBOztFQUVELFVBQVUsQ0FBRSxRQUFGLEVBQWE7SUFFdEIsT0FBTyxLQUFLLGVBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsUUFBOUIsQ0FBUDtFQUVBOztFQUVELFlBQVksQ0FBRSxNQUFGLEVBQVc7SUFFdEIsS0FBSyxpQkFBTCxDQUF3QixJQUF4QixFQUE4QixLQUE5QjtJQUVBLE9BQU8sTUFBTSxDQUFDLFlBQVAsQ0FBcUIsS0FBSyxXQUExQixDQUFQO0VBRUE7O0VBRUQsWUFBWSxDQUFFLE1BQUYsRUFBVztJQUV0QixLQUFLLGlCQUFMLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0lBRUEsT0FBTyxNQUFNLENBQUMsWUFBUCxDQUFxQixHQUFHLENBQUMsSUFBSixDQUFVLEtBQUssV0FBZixFQUE2QixNQUE3QixFQUFyQixDQUFQO0VBRUE7O0VBRUQsTUFBTSxDQUFFLENBQUYsRUFBSyxDQUFMLEVBQVEsQ0FBUixFQUFZO0lBRWpCO0lBRUEsSUFBSyxDQUFDLENBQUMsU0FBUCxFQUFtQjtNQUVsQixPQUFPLENBQUMsSUFBUixDQUFjLENBQWQ7SUFFQSxDQUpELE1BSU87TUFFTixPQUFPLENBQUMsR0FBUixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkI7SUFFQTs7SUFFRCxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0lBRUEsS0FBSyxpQkFBTCxDQUF3QixJQUF4QixFQUE4QixLQUE5Qjs7SUFFQSxTQUFTLENBQUMscUJBQVYsQ0FBaUMsS0FBSyxXQUF0Qzs7SUFFQSxJQUFLLEtBQUssUUFBTCxJQUFpQixLQUFLLE9BQTNCLEVBQXFDO01BRXBDLEdBQUcsQ0FBQyxNQUFKLENBQVksU0FBWixFQUF1QixPQUF2QixFQUFnQyxLQUFLLEVBQXJDO0lBRUEsQ0FKRCxNQUlPO01BRU4sR0FBRyxDQUFDLE1BQUosQ0FBWSxPQUFaLEVBQXFCLFNBQXJCLEVBQWdDLEtBQUssRUFBckM7SUFFQTs7SUFFRCxLQUFLLFVBQUwsQ0FBZ0IscUJBQWhCLENBQXVDLEdBQXZDOztJQUVBLElBQUssTUFBTCxFQUFjO01BRWIsR0FBRyxDQUFDLGVBQUosQ0FBcUIsTUFBTSxDQUFDLFdBQTVCOztNQUNBLEdBQUcsQ0FBQyxxQkFBSixDQUEyQixHQUEzQjs7TUFDQSxLQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNkIsR0FBRyxDQUFDLE1BQUosRUFBN0I7SUFFQTtFQUVEOztFQUVELEdBQUcsQ0FBRSxNQUFGLEVBQVc7SUFFYixJQUFLLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXhCLEVBQTRCO01BRTNCLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQS9CLEVBQXVDLENBQUMsRUFBeEMsRUFBOEM7UUFFN0MsS0FBSyxHQUFMLENBQVUsU0FBUyxDQUFFLENBQUYsQ0FBbkI7TUFFQTs7TUFFRCxPQUFPLElBQVA7SUFFQTs7SUFFRCxJQUFLLE1BQU0sS0FBSyxJQUFoQixFQUF1QjtNQUV0QixPQUFPLENBQUMsS0FBUixDQUFlLGtFQUFmLEVBQW1GLE1BQW5GO01BQ0EsT0FBTyxJQUFQO0lBRUE7O0lBRUQsSUFBSyxNQUFNLElBQUksTUFBTSxDQUFDLFVBQXRCLEVBQW1DO01BRWxDLElBQUssTUFBTSxDQUFDLE1BQVAsS0FBa0IsSUFBdkIsRUFBOEI7UUFFN0IsTUFBTSxDQUFDLE1BQVAsQ0FBYyxNQUFkLENBQXNCLE1BQXRCO01BRUE7O01BRUQsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsSUFBaEI7TUFDQSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW9CLE1BQXBCO01BRUEsTUFBTSxDQUFDLGFBQVAsQ0FBc0IsV0FBdEI7SUFFQSxDQWJELE1BYU87TUFFTixPQUFPLENBQUMsS0FBUixDQUFlLCtEQUFmLEVBQWdGLE1BQWhGO0lBRUE7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsTUFBTSxDQUFFLE1BQUYsRUFBVztJQUVoQixJQUFLLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXhCLEVBQTRCO01BRTNCLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQS9CLEVBQXVDLENBQUMsRUFBeEMsRUFBOEM7UUFFN0MsS0FBSyxNQUFMLENBQWEsU0FBUyxDQUFFLENBQUYsQ0FBdEI7TUFFQTs7TUFFRCxPQUFPLElBQVA7SUFFQTs7SUFFRCxNQUFNLEtBQUssR0FBRyxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXVCLE1BQXZCLENBQWQ7O0lBRUEsSUFBSyxLQUFLLEtBQUssQ0FBRSxDQUFqQixFQUFxQjtNQUVwQixNQUFNLENBQUMsTUFBUCxHQUFnQixJQUFoQjtNQUNBLEtBQUssUUFBTCxDQUFjLE1BQWQsQ0FBc0IsS0FBdEIsRUFBNkIsQ0FBN0I7TUFFQSxNQUFNLENBQUMsYUFBUCxDQUFzQixhQUF0QjtJQUVBOztJQUVELE9BQU8sSUFBUDtFQUVBOztFQUVELGdCQUFnQixHQUFHO0lBRWxCLE1BQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7O0lBRUEsSUFBSyxNQUFNLEtBQUssSUFBaEIsRUFBdUI7TUFFdEIsTUFBTSxDQUFDLE1BQVAsQ0FBZSxJQUFmO0lBRUE7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsS0FBSyxHQUFHO0lBRVAsT0FBTyxLQUFLLE1BQUwsQ0FBYSxHQUFJLEtBQUssUUFBdEIsQ0FBUDtFQUVBOztFQUVELE1BQU0sQ0FBRSxNQUFGLEVBQVc7SUFFaEI7SUFFQTtJQUVBLEtBQUssaUJBQUwsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7O0lBRUEsR0FBRyxDQUFDLElBQUosQ0FBVSxLQUFLLFdBQWYsRUFBNkIsTUFBN0I7O0lBRUEsSUFBSyxNQUFNLENBQUMsTUFBUCxLQUFrQixJQUF2QixFQUE4QjtNQUU3QixNQUFNLENBQUMsTUFBUCxDQUFjLGlCQUFkLENBQWlDLElBQWpDLEVBQXVDLEtBQXZDOztNQUVBLEdBQUcsQ0FBQyxRQUFKLENBQWMsTUFBTSxDQUFDLE1BQVAsQ0FBYyxXQUE1QjtJQUVBOztJQUVELE1BQU0sQ0FBQyxZQUFQLENBQXFCLEdBQXJCO0lBRUEsS0FBSyxHQUFMLENBQVUsTUFBVjtJQUVBLE1BQU0sQ0FBQyxpQkFBUCxDQUEwQixLQUExQixFQUFpQyxJQUFqQztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELGFBQWEsQ0FBRSxFQUFGLEVBQU87SUFFbkIsT0FBTyxLQUFLLG1CQUFMLENBQTBCLElBQTFCLEVBQWdDLEVBQWhDLENBQVA7RUFFQTs7RUFFRCxlQUFlLENBQUUsSUFBRixFQUFTO0lBRXZCLE9BQU8sS0FBSyxtQkFBTCxDQUEwQixNQUExQixFQUFrQyxJQUFsQyxDQUFQO0VBRUE7O0VBRUQsbUJBQW1CLENBQUUsSUFBRixFQUFRLEtBQVIsRUFBZ0I7SUFFbEMsSUFBSyxLQUFNLElBQU4sTUFBaUIsS0FBdEIsRUFBOEIsT0FBTyxJQUFQOztJQUU5QixLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxRQUFMLENBQWMsTUFBbkMsRUFBMkMsQ0FBQyxHQUFHLENBQS9DLEVBQWtELENBQUMsRUFBbkQsRUFBeUQ7TUFFeEQsTUFBTSxLQUFLLEdBQUcsS0FBSyxRQUFMLENBQWUsQ0FBZixDQUFkO01BQ0EsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLG1CQUFOLENBQTJCLElBQTNCLEVBQWlDLEtBQWpDLENBQWY7O01BRUEsSUFBSyxNQUFNLEtBQUssU0FBaEIsRUFBNEI7UUFFM0IsT0FBTyxNQUFQO01BRUE7SUFFRDs7SUFFRCxPQUFPLFNBQVA7RUFFQTs7RUFFRCxvQkFBb0IsQ0FBRSxJQUFGLEVBQVEsS0FBUixFQUFnQjtJQUVuQyxJQUFJLE1BQU0sR0FBRyxFQUFiO0lBRUEsSUFBSyxLQUFNLElBQU4sTUFBaUIsS0FBdEIsRUFBOEIsTUFBTSxDQUFDLElBQVAsQ0FBYSxJQUFiOztJQUU5QixLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxRQUFMLENBQWMsTUFBbkMsRUFBMkMsQ0FBQyxHQUFHLENBQS9DLEVBQWtELENBQUMsRUFBbkQsRUFBeUQ7TUFFeEQsTUFBTSxXQUFXLEdBQUcsS0FBSyxRQUFMLENBQWUsQ0FBZixFQUFtQixvQkFBbkIsQ0FBeUMsSUFBekMsRUFBK0MsS0FBL0MsQ0FBcEI7O01BRUEsSUFBSyxXQUFXLENBQUMsTUFBWixHQUFxQixDQUExQixFQUE4QjtRQUU3QixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBZSxXQUFmLENBQVQ7TUFFQTtJQUVEOztJQUVELE9BQU8sTUFBUDtFQUVBOztFQUVELGdCQUFnQixDQUFFLE1BQUYsRUFBVztJQUUxQixLQUFLLGlCQUFMLENBQXdCLElBQXhCLEVBQThCLEtBQTlCO0lBRUEsT0FBTyxNQUFNLENBQUMscUJBQVAsQ0FBOEIsS0FBSyxXQUFuQyxDQUFQO0VBRUE7O0VBRUQsa0JBQWtCLENBQUUsTUFBRixFQUFXO0lBRTVCLEtBQUssaUJBQUwsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7SUFFQSxLQUFLLFdBQUwsQ0FBaUIsU0FBakIsQ0FBNEIsU0FBNUIsRUFBdUMsTUFBdkMsRUFBK0MsTUFBL0M7SUFFQSxPQUFPLE1BQVA7RUFFQTs7RUFFRCxhQUFhLENBQUUsTUFBRixFQUFXO0lBRXZCLEtBQUssaUJBQUwsQ0FBd0IsSUFBeEIsRUFBOEIsS0FBOUI7SUFFQSxLQUFLLFdBQUwsQ0FBaUIsU0FBakIsQ0FBNEIsU0FBNUIsRUFBdUMsV0FBdkMsRUFBb0QsTUFBcEQ7SUFFQSxPQUFPLE1BQVA7RUFFQTs7RUFFRCxpQkFBaUIsQ0FBRSxNQUFGLEVBQVc7SUFFM0IsS0FBSyxpQkFBTCxDQUF3QixJQUF4QixFQUE4QixLQUE5QjtJQUVBLE1BQU0sQ0FBQyxHQUFHLEtBQUssV0FBTCxDQUFpQixRQUEzQjtJQUVBLE9BQU8sTUFBTSxDQUFDLEdBQVAsQ0FBWSxDQUFDLENBQUUsQ0FBRixDQUFiLEVBQW9CLENBQUMsQ0FBRSxDQUFGLENBQXJCLEVBQTRCLENBQUMsQ0FBRSxFQUFGLENBQTdCLEVBQXNDLFNBQXRDLEVBQVA7RUFFQTs7RUFFRCxPQUFPLEdBQWdDLENBQUU7O0VBRXpDLFFBQVEsQ0FBRSxRQUFGLEVBQWE7SUFFcEIsUUFBUSxDQUFFLElBQUYsQ0FBUjtJQUVBLE1BQU0sUUFBUSxHQUFHLEtBQUssUUFBdEI7O0lBRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUE5QixFQUFzQyxDQUFDLEdBQUcsQ0FBMUMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFvRDtNQUVuRCxRQUFRLENBQUUsQ0FBRixDQUFSLENBQWMsUUFBZCxDQUF3QixRQUF4QjtJQUVBO0VBRUQ7O0VBRUQsZUFBZSxDQUFFLFFBQUYsRUFBYTtJQUUzQixJQUFLLEtBQUssT0FBTCxLQUFpQixLQUF0QixFQUE4QjtJQUU5QixRQUFRLENBQUUsSUFBRixDQUFSO0lBRUEsTUFBTSxRQUFRLEdBQUcsS0FBSyxRQUF0Qjs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQTlCLEVBQXNDLENBQUMsR0FBRyxDQUExQyxFQUE2QyxDQUFDLEVBQTlDLEVBQW9EO01BRW5ELFFBQVEsQ0FBRSxDQUFGLENBQVIsQ0FBYyxlQUFkLENBQStCLFFBQS9CO0lBRUE7RUFFRDs7RUFFRCxpQkFBaUIsQ0FBRSxRQUFGLEVBQWE7SUFFN0IsTUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjs7SUFFQSxJQUFLLE1BQU0sS0FBSyxJQUFoQixFQUF1QjtNQUV0QixRQUFRLENBQUUsTUFBRixDQUFSO01BRUEsTUFBTSxDQUFDLGlCQUFQLENBQTBCLFFBQTFCO0lBRUE7RUFFRDs7RUFFRCxZQUFZLEdBQUc7SUFFZCxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQXFCLEtBQUssUUFBMUIsRUFBb0MsS0FBSyxVQUF6QyxFQUFxRCxLQUFLLEtBQTFEO0lBRUEsS0FBSyxzQkFBTCxHQUE4QixJQUE5QjtFQUVBOztFQUVELGlCQUFpQixDQUFFLEtBQUYsRUFBVTtJQUUxQixJQUFLLEtBQUssZ0JBQVYsRUFBNkIsS0FBSyxZQUFMOztJQUU3QixJQUFLLEtBQUssc0JBQUwsSUFBK0IsS0FBcEMsRUFBNEM7TUFFM0MsSUFBSyxLQUFLLE1BQUwsS0FBZ0IsSUFBckIsRUFBNEI7UUFFM0IsS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQXVCLEtBQUssTUFBNUI7TUFFQSxDQUpELE1BSU87UUFFTixLQUFLLFdBQUwsQ0FBaUIsZ0JBQWpCLENBQW1DLEtBQUssTUFBTCxDQUFZLFdBQS9DLEVBQTRELEtBQUssTUFBakU7TUFFQTs7TUFFRCxLQUFLLHNCQUFMLEdBQThCLEtBQTlCO01BRUEsS0FBSyxHQUFHLElBQVI7SUFFQSxDQXBCeUIsQ0FzQjFCOzs7SUFFQSxNQUFNLFFBQVEsR0FBRyxLQUFLLFFBQXRCOztJQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBOUIsRUFBc0MsQ0FBQyxHQUFHLENBQTFDLEVBQTZDLENBQUMsRUFBOUMsRUFBb0Q7TUFFbkQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFFLENBQUYsQ0FBdEI7O01BRUEsSUFBSyxLQUFLLENBQUMscUJBQU4sS0FBZ0MsSUFBaEMsSUFBd0MsS0FBSyxLQUFLLElBQXZELEVBQThEO1FBRTdELEtBQUssQ0FBQyxpQkFBTixDQUF5QixLQUF6QjtNQUVBO0lBRUQ7RUFFRDs7RUFFRCxpQkFBaUIsQ0FBRSxhQUFGLEVBQWlCLGNBQWpCLEVBQWtDO0lBRWxELE1BQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7O0lBRUEsSUFBSyxhQUFhLEtBQUssSUFBbEIsSUFBMEIsTUFBTSxLQUFLLElBQXJDLElBQTZDLE1BQU0sQ0FBQyxxQkFBUCxLQUFpQyxJQUFuRixFQUEwRjtNQUV6RixNQUFNLENBQUMsaUJBQVAsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEM7SUFFQTs7SUFFRCxJQUFLLEtBQUssZ0JBQVYsRUFBNkIsS0FBSyxZQUFMOztJQUU3QixJQUFLLEtBQUssTUFBTCxLQUFnQixJQUFyQixFQUE0QjtNQUUzQixLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBdUIsS0FBSyxNQUE1QjtJQUVBLENBSkQsTUFJTztNQUVOLEtBQUssV0FBTCxDQUFpQixnQkFBakIsQ0FBbUMsS0FBSyxNQUFMLENBQVksV0FBL0MsRUFBNEQsS0FBSyxNQUFqRTtJQUVBLENBcEJpRCxDQXNCbEQ7OztJQUVBLElBQUssY0FBYyxLQUFLLElBQXhCLEVBQStCO01BRTlCLE1BQU0sUUFBUSxHQUFHLEtBQUssUUFBdEI7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUE5QixFQUFzQyxDQUFDLEdBQUcsQ0FBMUMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFvRDtRQUVuRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUUsQ0FBRixDQUF0Qjs7UUFFQSxJQUFLLEtBQUssQ0FBQyxxQkFBTixLQUFnQyxJQUFyQyxFQUE0QztVQUUzQyxLQUFLLENBQUMsaUJBQU4sQ0FBeUIsS0FBekIsRUFBZ0MsSUFBaEM7UUFFQTtNQUVEO0lBRUQ7RUFFRDs7RUFFRCxNQUFNLENBQUUsSUFBRixFQUFTO0lBRWQ7SUFDQSxNQUFNLFlBQVksR0FBSyxJQUFJLEtBQUssU0FBVCxJQUFzQixPQUFPLElBQVAsS0FBZ0IsUUFBN0Q7SUFFQSxNQUFNLE1BQU0sR0FBRyxFQUFmLENBTGMsQ0FPZDtJQUNBO0lBQ0E7O0lBQ0EsSUFBSyxZQUFMLEVBQW9CO01BRW5CO01BQ0EsSUFBSSxHQUFHO1FBQ04sVUFBVSxFQUFFLEVBRE47UUFFTixTQUFTLEVBQUUsRUFGTDtRQUdOLFFBQVEsRUFBRSxFQUhKO1FBSU4sTUFBTSxFQUFFLEVBSkY7UUFLTixNQUFNLEVBQUUsRUFMRjtRQU1OLFNBQVMsRUFBRSxFQU5MO1FBT04sVUFBVSxFQUFFLEVBUE47UUFRTixLQUFLLEVBQUU7TUFSRCxDQUFQO01BV0EsTUFBTSxDQUFDLFFBQVAsR0FBa0I7UUFDakIsT0FBTyxFQUFFLEdBRFE7UUFFakIsSUFBSSxFQUFFLFFBRlc7UUFHakIsU0FBUyxFQUFFO01BSE0sQ0FBbEI7SUFNQSxDQTlCYSxDQWdDZDs7O0lBRUEsTUFBTSxNQUFNLEdBQUcsRUFBZjtJQUVBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsS0FBSyxJQUFuQjtJQUNBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsS0FBSyxJQUFuQjtJQUVBLElBQUssS0FBSyxJQUFMLEtBQWMsRUFBbkIsRUFBd0IsTUFBTSxDQUFDLElBQVAsR0FBYyxLQUFLLElBQW5CO0lBQ3hCLElBQUssS0FBSyxVQUFMLEtBQW9CLElBQXpCLEVBQWdDLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLElBQXBCO0lBQ2hDLElBQUssS0FBSyxhQUFMLEtBQXVCLElBQTVCLEVBQW1DLE1BQU0sQ0FBQyxhQUFQLEdBQXVCLElBQXZCO0lBQ25DLElBQUssS0FBSyxPQUFMLEtBQWlCLEtBQXRCLEVBQThCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEtBQWpCO0lBQzlCLElBQUssS0FBSyxhQUFMLEtBQXVCLEtBQTVCLEVBQW9DLE1BQU0sQ0FBQyxhQUFQLEdBQXVCLEtBQXZCO0lBQ3BDLElBQUssS0FBSyxXQUFMLEtBQXFCLENBQTFCLEVBQThCLE1BQU0sQ0FBQyxXQUFQLEdBQXFCLEtBQUssV0FBMUI7SUFDOUIsSUFBSyxNQUFNLENBQUMsSUFBUCxDQUFhLEtBQUssUUFBbEIsRUFBNkIsTUFBN0IsR0FBc0MsQ0FBM0MsRUFBK0MsTUFBTSxDQUFDLFFBQVAsR0FBa0IsS0FBSyxRQUF2QjtJQUUvQyxNQUFNLENBQUMsTUFBUCxHQUFnQixLQUFLLE1BQUwsQ0FBWSxJQUE1QjtJQUNBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLEtBQUssTUFBTCxDQUFZLE9BQVosRUFBaEI7SUFDQSxNQUFNLENBQUMsRUFBUCxHQUFZLEtBQUssRUFBTCxDQUFRLE9BQVIsRUFBWjtJQUVBLElBQUssS0FBSyxnQkFBTCxLQUEwQixLQUEvQixFQUF1QyxNQUFNLENBQUMsZ0JBQVAsR0FBMEIsS0FBMUIsQ0FuRHpCLENBcURkOztJQUVBLElBQUssS0FBSyxlQUFWLEVBQTRCO01BRTNCLE1BQU0sQ0FBQyxJQUFQLEdBQWMsZUFBZDtNQUNBLE1BQU0sQ0FBQyxLQUFQLEdBQWUsS0FBSyxLQUFwQjtNQUNBLE1BQU0sQ0FBQyxjQUFQLEdBQXdCLEtBQUssY0FBTCxDQUFvQixNQUFwQixFQUF4QjtNQUNBLElBQUssS0FBSyxhQUFMLEtBQXVCLElBQTVCLEVBQW1DLE1BQU0sQ0FBQyxhQUFQLEdBQXVCLEtBQUssYUFBTCxDQUFtQixNQUFuQixFQUF2QjtJQUVuQyxDQTlEYSxDQWdFZDs7O0lBRUEsU0FBUyxTQUFULENBQW9CLE9BQXBCLEVBQTZCLE9BQTdCLEVBQXVDO01BRXRDLElBQUssT0FBTyxDQUFFLE9BQU8sQ0FBQyxJQUFWLENBQVAsS0FBNEIsU0FBakMsRUFBNkM7UUFFNUMsT0FBTyxDQUFFLE9BQU8sQ0FBQyxJQUFWLENBQVAsR0FBMEIsT0FBTyxDQUFDLE1BQVIsQ0FBZ0IsSUFBaEIsQ0FBMUI7TUFFQTs7TUFFRCxPQUFPLE9BQU8sQ0FBQyxJQUFmO0lBRUE7O0lBRUQsSUFBSyxLQUFLLE9BQVYsRUFBb0I7TUFFbkIsSUFBSyxLQUFLLFVBQVYsRUFBdUI7UUFFdEIsSUFBSyxLQUFLLFVBQUwsQ0FBZ0IsT0FBckIsRUFBK0I7VUFFOUIsTUFBTSxDQUFDLFVBQVAsR0FBb0IsS0FBSyxVQUFMLENBQWdCLE1BQWhCLEVBQXBCO1FBRUEsQ0FKRCxNQUlPLElBQUssS0FBSyxVQUFMLENBQWdCLFNBQXJCLEVBQWlDO1VBRXZDLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUF3QixJQUF4QixFQUErQixJQUFuRDtRQUVBO01BRUQ7O01BRUQsSUFBSyxLQUFLLFdBQUwsSUFBb0IsS0FBSyxXQUFMLENBQWlCLFNBQXJDLElBQWtELEtBQUssV0FBTCxDQUFpQixxQkFBakIsS0FBMkMsSUFBbEcsRUFBeUc7UUFFeEcsTUFBTSxDQUFDLFdBQVAsR0FBcUIsS0FBSyxXQUFMLENBQWlCLE1BQWpCLENBQXlCLElBQXpCLEVBQWdDLElBQXJEO01BRUE7SUFFRCxDQXRCRCxNQXNCTyxJQUFLLEtBQUssTUFBTCxJQUFlLEtBQUssTUFBcEIsSUFBOEIsS0FBSyxRQUF4QyxFQUFtRDtNQUV6RCxNQUFNLENBQUMsUUFBUCxHQUFrQixTQUFTLENBQUUsSUFBSSxDQUFDLFVBQVAsRUFBbUIsS0FBSyxRQUF4QixDQUEzQjtNQUVBLE1BQU0sVUFBVSxHQUFHLEtBQUssUUFBTCxDQUFjLFVBQWpDOztNQUVBLElBQUssVUFBVSxLQUFLLFNBQWYsSUFBNEIsVUFBVSxDQUFDLE1BQVgsS0FBc0IsU0FBdkQsRUFBbUU7UUFFbEUsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQTFCOztRQUVBLElBQUssS0FBSyxDQUFDLE9BQU4sQ0FBZSxNQUFmLENBQUwsRUFBK0I7VUFFOUIsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsQ0FBeEMsRUFBMkMsQ0FBQyxFQUE1QyxFQUFrRDtZQUVqRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUUsQ0FBRixDQUFwQjtZQUVBLFNBQVMsQ0FBRSxJQUFJLENBQUMsTUFBUCxFQUFlLEtBQWYsQ0FBVDtVQUVBO1FBRUQsQ0FWRCxNQVVPO1VBRU4sU0FBUyxDQUFFLElBQUksQ0FBQyxNQUFQLEVBQWUsTUFBZixDQUFUO1FBRUE7TUFFRDtJQUVEOztJQUVELElBQUssS0FBSyxhQUFWLEVBQTBCO01BRXpCLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLEtBQUssUUFBdkI7TUFDQSxNQUFNLENBQUMsVUFBUCxHQUFvQixLQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsRUFBcEI7O01BRUEsSUFBSyxLQUFLLFFBQUwsS0FBa0IsU0FBdkIsRUFBbUM7UUFFbEMsU0FBUyxDQUFFLElBQUksQ0FBQyxTQUFQLEVBQWtCLEtBQUssUUFBdkIsQ0FBVDtRQUVBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLEtBQUssUUFBTCxDQUFjLElBQWhDO01BRUE7SUFFRDs7SUFFRCxJQUFLLEtBQUssUUFBTCxLQUFrQixTQUF2QixFQUFtQztNQUVsQyxJQUFLLEtBQUssQ0FBQyxPQUFOLENBQWUsS0FBSyxRQUFwQixDQUFMLEVBQXNDO1FBRXJDLE1BQU0sS0FBSyxHQUFHLEVBQWQ7O1FBRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLEtBQUssUUFBTCxDQUFjLE1BQW5DLEVBQTJDLENBQUMsR0FBRyxDQUEvQyxFQUFrRCxDQUFDLEVBQW5ELEVBQXlEO1VBRXhELEtBQUssQ0FBQyxJQUFOLENBQVksU0FBUyxDQUFFLElBQUksQ0FBQyxTQUFQLEVBQWtCLEtBQUssUUFBTCxDQUFlLENBQWYsQ0FBbEIsQ0FBckI7UUFFQTs7UUFFRCxNQUFNLENBQUMsUUFBUCxHQUFrQixLQUFsQjtNQUVBLENBWkQsTUFZTztRQUVOLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLFNBQVMsQ0FBRSxJQUFJLENBQUMsU0FBUCxFQUFrQixLQUFLLFFBQXZCLENBQTNCO01BRUE7SUFFRCxDQXJLYSxDQXVLZDs7O0lBRUEsSUFBSyxLQUFLLFFBQUwsQ0FBYyxNQUFkLEdBQXVCLENBQTVCLEVBQWdDO01BRS9CLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLEVBQWxCOztNQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsS0FBSyxRQUFMLENBQWMsTUFBbkMsRUFBMkMsQ0FBQyxFQUE1QyxFQUFrRDtRQUVqRCxNQUFNLENBQUMsUUFBUCxDQUFnQixJQUFoQixDQUFzQixLQUFLLFFBQUwsQ0FBZSxDQUFmLEVBQW1CLE1BQW5CLENBQTJCLElBQTNCLEVBQWtDLE1BQXhEO01BRUE7SUFFRCxDQW5MYSxDQXFMZDs7O0lBRUEsSUFBSyxLQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsR0FBeUIsQ0FBOUIsRUFBa0M7TUFFakMsTUFBTSxDQUFDLFVBQVAsR0FBb0IsRUFBcEI7O01BRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxLQUFLLFVBQUwsQ0FBZ0IsTUFBckMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFvRDtRQUVuRCxNQUFNLFNBQVMsR0FBRyxLQUFLLFVBQUwsQ0FBaUIsQ0FBakIsQ0FBbEI7UUFFQSxNQUFNLENBQUMsVUFBUCxDQUFrQixJQUFsQixDQUF3QixTQUFTLENBQUUsSUFBSSxDQUFDLFVBQVAsRUFBbUIsU0FBbkIsQ0FBakM7TUFFQTtJQUVEOztJQUVELElBQUssWUFBTCxFQUFvQjtNQUVuQixNQUFNLFVBQVUsR0FBRyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUMsVUFBUCxDQUFuQztNQUNBLE1BQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFFLElBQUksQ0FBQyxTQUFQLENBQWxDO01BQ0EsTUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUUsSUFBSSxDQUFDLFFBQVAsQ0FBakM7TUFDQSxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUMsTUFBUCxDQUEvQjtNQUNBLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFFLElBQUksQ0FBQyxNQUFQLENBQS9CO01BQ0EsTUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUUsSUFBSSxDQUFDLFNBQVAsQ0FBbEM7TUFDQSxNQUFNLFVBQVUsR0FBRyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUMsVUFBUCxDQUFuQztNQUNBLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFFLElBQUksQ0FBQyxLQUFQLENBQTlCO01BRUEsSUFBSyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUF6QixFQUE2QixNQUFNLENBQUMsVUFBUCxHQUFvQixVQUFwQjtNQUM3QixJQUFLLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXhCLEVBQTRCLE1BQU0sQ0FBQyxTQUFQLEdBQW1CLFNBQW5CO01BQzVCLElBQUssUUFBUSxDQUFDLE1BQVQsR0FBa0IsQ0FBdkIsRUFBMkIsTUFBTSxDQUFDLFFBQVAsR0FBa0IsUUFBbEI7TUFDM0IsSUFBSyxNQUFNLENBQUMsTUFBUCxHQUFnQixDQUFyQixFQUF5QixNQUFNLENBQUMsTUFBUCxHQUFnQixNQUFoQjtNQUN6QixJQUFLLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLENBQXJCLEVBQXlCLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQWhCO01BQ3pCLElBQUssU0FBUyxDQUFDLE1BQVYsR0FBbUIsQ0FBeEIsRUFBNEIsTUFBTSxDQUFDLFNBQVAsR0FBbUIsU0FBbkI7TUFDNUIsSUFBSyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUF6QixFQUE2QixNQUFNLENBQUMsVUFBUCxHQUFvQixVQUFwQjtNQUM3QixJQUFLLEtBQUssQ0FBQyxNQUFOLEdBQWUsQ0FBcEIsRUFBd0IsTUFBTSxDQUFDLEtBQVAsR0FBZSxLQUFmO0lBRXhCOztJQUVELE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQWhCO0lBRUEsT0FBTyxNQUFQLENBN05jLENBK05kO0lBQ0E7SUFDQTs7SUFDQSxTQUFTLGdCQUFULENBQTJCLEtBQTNCLEVBQW1DO01BRWxDLE1BQU0sTUFBTSxHQUFHLEVBQWY7O01BQ0EsS0FBTSxNQUFNLEdBQVosSUFBbUIsS0FBbkIsRUFBMkI7UUFFMUIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFFLEdBQUYsQ0FBbEI7UUFDQSxPQUFPLElBQUksQ0FBQyxRQUFaO1FBQ0EsTUFBTSxDQUFDLElBQVAsQ0FBYSxJQUFiO01BRUE7O01BRUQsT0FBTyxNQUFQO0lBRUE7RUFFRDs7RUFFRCxLQUFLLENBQUUsU0FBRixFQUFjO0lBRWxCLE9BQU8sSUFBSSxLQUFLLFdBQVQsR0FBdUIsSUFBdkIsQ0FBNkIsSUFBN0IsRUFBbUMsU0FBbkMsQ0FBUDtFQUVBOztFQUVELElBQUksQ0FBRSxNQUFGLEVBQVUsU0FBUyxHQUFHLElBQXRCLEVBQTZCO0lBRWhDLEtBQUssSUFBTCxHQUFZLE1BQU0sQ0FBQyxJQUFuQjtJQUVBLEtBQUssRUFBTCxDQUFRLElBQVIsQ0FBYyxNQUFNLENBQUMsRUFBckI7SUFFQSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW9CLE1BQU0sQ0FBQyxRQUEzQjtJQUNBLEtBQUssUUFBTCxDQUFjLEtBQWQsR0FBc0IsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBdEM7SUFDQSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBc0IsTUFBTSxDQUFDLFVBQTdCO0lBQ0EsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFpQixNQUFNLENBQUMsS0FBeEI7SUFFQSxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWtCLE1BQU0sQ0FBQyxNQUF6QjtJQUNBLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUF1QixNQUFNLENBQUMsV0FBOUI7SUFFQSxLQUFLLGdCQUFMLEdBQXdCLE1BQU0sQ0FBQyxnQkFBL0I7SUFDQSxLQUFLLHNCQUFMLEdBQThCLE1BQU0sQ0FBQyxzQkFBckM7SUFFQSxLQUFLLHFCQUFMLEdBQTZCLE1BQU0sQ0FBQyxxQkFBcEM7SUFFQSxLQUFLLE1BQUwsQ0FBWSxJQUFaLEdBQW1CLE1BQU0sQ0FBQyxNQUFQLENBQWMsSUFBakM7SUFDQSxLQUFLLE9BQUwsR0FBZSxNQUFNLENBQUMsT0FBdEI7SUFFQSxLQUFLLFVBQUwsR0FBa0IsTUFBTSxDQUFDLFVBQXpCO0lBQ0EsS0FBSyxhQUFMLEdBQXFCLE1BQU0sQ0FBQyxhQUE1QjtJQUVBLEtBQUssYUFBTCxHQUFxQixNQUFNLENBQUMsYUFBNUI7SUFDQSxLQUFLLFdBQUwsR0FBbUIsTUFBTSxDQUFDLFdBQTFCO0lBRUEsS0FBSyxVQUFMLEdBQWtCLE1BQU0sQ0FBQyxVQUFQLENBQWtCLEtBQWxCLEVBQWxCO0lBRUEsS0FBSyxRQUFMLEdBQWdCLElBQUksQ0FBQyxLQUFMLENBQVksSUFBSSxDQUFDLFNBQUwsQ0FBZ0IsTUFBTSxDQUFDLFFBQXZCLENBQVosQ0FBaEI7O0lBRUEsSUFBSyxTQUFTLEtBQUssSUFBbkIsRUFBMEI7TUFFekIsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUCxDQUFnQixNQUFyQyxFQUE2QyxDQUFDLEVBQTlDLEVBQW9EO1FBRW5ELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFQLENBQWlCLENBQWpCLENBQWQ7UUFDQSxLQUFLLEdBQUwsQ0FBVSxLQUFLLENBQUMsS0FBTixFQUFWO01BRUE7SUFFRDs7SUFFRCxPQUFPLElBQVA7RUFFQTs7QUE1NUJxQzs7O0FBZzZCdkMsUUFBUSxDQUFDLFVBQVQsR0FBc0IsYUFBYyxJQUFJLGVBQUosQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQXBDO0FBQ0EsUUFBUSxDQUFDLDBCQUFULEdBQXNDLElBQXRDO0FBQ0EsUUFBUSxDQUFDLGdDQUFULEdBQTRDLElBQTVDOzs7Ozs7Ozs7Ozs7QUM3N0JBOztBQUVBO0FBRUEsTUFBTSxPQUFPLEdBQUcsYUFBYyxlQUFlLEVBQTdDOztBQUVBLFNBQVMsZUFBVCxHQUEyQjtFQUUxQjtFQUVBLE1BQU0sTUFBTSxHQUFHLElBQUksV0FBSixDQUFpQixDQUFqQixDQUFmO0VBQ0EsTUFBTSxTQUFTLEdBQUcsSUFBSSxZQUFKLENBQWtCLE1BQWxCLENBQWxCO0VBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxXQUFKLENBQWlCLE1BQWpCLENBQW5CO0VBRUEsTUFBTSxTQUFTLEdBQUcsSUFBSSxXQUFKLENBQWlCLEdBQWpCLENBQWxCO0VBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxXQUFKLENBQWlCLEdBQWpCLENBQW5COztFQUVBLEtBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsR0FBckIsRUFBMEIsRUFBRyxDQUE3QixFQUFpQztJQUVoQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBZCxDQUZnQyxDQUloQzs7SUFFQSxJQUFLLENBQUMsR0FBRyxDQUFFLEVBQVgsRUFBZ0I7TUFFZixTQUFTLENBQUUsQ0FBRixDQUFULEdBQWlCLE1BQWpCO01BQ0EsU0FBUyxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVQsR0FBeUIsTUFBekI7TUFDQSxVQUFVLENBQUUsQ0FBRixDQUFWLEdBQWtCLEVBQWxCO01BQ0EsVUFBVSxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVYsR0FBMEIsRUFBMUIsQ0FMZSxDQU9mO0lBRUEsQ0FURCxNQVNPLElBQUssQ0FBQyxHQUFHLENBQUUsRUFBWCxFQUFnQjtNQUV0QixTQUFTLENBQUUsQ0FBRixDQUFULEdBQWlCLFVBQVksQ0FBRSxDQUFGLEdBQU0sRUFBbkM7TUFDQSxTQUFTLENBQUUsQ0FBQyxHQUFHLEtBQU4sQ0FBVCxHQUEyQixVQUFZLENBQUUsQ0FBRixHQUFNLEVBQXBCLEdBQTZCLE1BQXREO01BQ0EsVUFBVSxDQUFFLENBQUYsQ0FBVixHQUFrQixDQUFFLENBQUYsR0FBTSxDQUF4QjtNQUNBLFVBQVUsQ0FBRSxDQUFDLEdBQUcsS0FBTixDQUFWLEdBQTBCLENBQUUsQ0FBRixHQUFNLENBQWhDLENBTHNCLENBT3RCO0lBRUEsQ0FUTSxNQVNBLElBQUssQ0FBQyxJQUFJLEVBQVYsRUFBZTtNQUVyQixTQUFTLENBQUUsQ0FBRixDQUFULEdBQW1CLENBQUMsR0FBRyxFQUFOLElBQWMsRUFBL0I7TUFDQSxTQUFTLENBQUUsQ0FBQyxHQUFHLEtBQU4sQ0FBVCxHQUE2QixDQUFDLEdBQUcsRUFBTixJQUFjLEVBQWhCLEdBQXVCLE1BQWhEO01BQ0EsVUFBVSxDQUFFLENBQUYsQ0FBVixHQUFrQixFQUFsQjtNQUNBLFVBQVUsQ0FBRSxDQUFDLEdBQUcsS0FBTixDQUFWLEdBQTBCLEVBQTFCLENBTHFCLENBT3JCO0lBRUEsQ0FUTSxNQVNBLElBQUssQ0FBQyxHQUFHLEdBQVQsRUFBZTtNQUVyQixTQUFTLENBQUUsQ0FBRixDQUFULEdBQWlCLE1BQWpCO01BQ0EsU0FBUyxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVQsR0FBeUIsTUFBekI7TUFDQSxVQUFVLENBQUUsQ0FBRixDQUFWLEdBQWtCLEVBQWxCO01BQ0EsVUFBVSxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVYsR0FBMEIsRUFBMUIsQ0FMcUIsQ0FPckI7SUFFQSxDQVRNLE1BU0E7TUFFTixTQUFTLENBQUUsQ0FBRixDQUFULEdBQWlCLE1BQWpCO01BQ0EsU0FBUyxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVQsR0FBeUIsTUFBekI7TUFDQSxVQUFVLENBQUUsQ0FBRixDQUFWLEdBQWtCLEVBQWxCO01BQ0EsVUFBVSxDQUFFLENBQUMsR0FBRyxLQUFOLENBQVYsR0FBMEIsRUFBMUI7SUFFQTtFQUVELENBOUR5QixDQWdFMUI7OztFQUVBLE1BQU0sYUFBYSxHQUFHLElBQUksV0FBSixDQUFpQixJQUFqQixDQUF0QjtFQUNBLE1BQU0sYUFBYSxHQUFHLElBQUksV0FBSixDQUFpQixFQUFqQixDQUF0QjtFQUNBLE1BQU0sV0FBVyxHQUFHLElBQUksV0FBSixDQUFpQixFQUFqQixDQUFwQjs7RUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQWQsRUFBaUIsQ0FBQyxHQUFHLElBQXJCLEVBQTJCLEVBQUcsQ0FBOUIsRUFBa0M7SUFFakMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQWIsQ0FGaUMsQ0FFaEI7O0lBQ2pCLElBQUksQ0FBQyxHQUFHLENBQVIsQ0FIaUMsQ0FHdEI7SUFFWDs7SUFDQSxPQUFRLENBQUUsQ0FBQyxHQUFHLFVBQU4sTUFBdUIsQ0FBL0IsRUFBbUM7TUFFbEMsQ0FBQyxLQUFLLENBQU47TUFDQSxDQUFDLElBQUksVUFBTCxDQUhrQyxDQUdqQjtJQUVqQjs7SUFFRCxDQUFDLElBQUksQ0FBRSxVQUFQLENBYmlDLENBYWQ7O0lBQ25CLENBQUMsSUFBSSxVQUFMLENBZGlDLENBY2hCOztJQUVqQixhQUFhLENBQUUsQ0FBRixDQUFiLEdBQXFCLENBQUMsR0FBRyxDQUF6QjtFQUVBOztFQUVELEtBQU0sSUFBSSxDQUFDLEdBQUcsSUFBZCxFQUFvQixDQUFDLEdBQUcsSUFBeEIsRUFBOEIsRUFBRyxDQUFqQyxFQUFxQztJQUVwQyxhQUFhLENBQUUsQ0FBRixDQUFiLEdBQXFCLGNBQWlCLENBQUMsR0FBRyxJQUFOLElBQWdCLEVBQS9CLENBQXJCO0VBRUE7O0VBRUQsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxFQUFyQixFQUF5QixFQUFHLENBQTVCLEVBQWdDO0lBRS9CLGFBQWEsQ0FBRSxDQUFGLENBQWIsR0FBcUIsQ0FBQyxJQUFJLEVBQTFCO0VBRUE7O0VBRUQsYUFBYSxDQUFFLEVBQUYsQ0FBYixHQUFzQixVQUF0QjtFQUNBLGFBQWEsQ0FBRSxFQUFGLENBQWIsR0FBc0IsVUFBdEI7O0VBRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxFQUFkLEVBQWtCLENBQUMsR0FBRyxFQUF0QixFQUEwQixFQUFHLENBQTdCLEVBQWlDO0lBRWhDLGFBQWEsQ0FBRSxDQUFGLENBQWIsR0FBcUIsY0FBaUIsQ0FBQyxHQUFHLEVBQU4sSUFBYyxFQUE3QixDQUFyQjtFQUVBOztFQUVELGFBQWEsQ0FBRSxFQUFGLENBQWIsR0FBc0IsVUFBdEI7O0VBRUEsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxFQUFyQixFQUF5QixFQUFHLENBQTVCLEVBQWdDO0lBRS9CLElBQUssQ0FBQyxLQUFLLEVBQVgsRUFBZ0I7TUFFZixXQUFXLENBQUUsQ0FBRixDQUFYLEdBQW1CLElBQW5CO0lBRUE7RUFFRDs7RUFFRCxPQUFPO0lBQ04sU0FBUyxFQUFFLFNBREw7SUFFTixVQUFVLEVBQUUsVUFGTjtJQUdOLFNBQVMsRUFBRSxTQUhMO0lBSU4sVUFBVSxFQUFFLFVBSk47SUFLTixhQUFhLEVBQUUsYUFMVDtJQU1OLGFBQWEsRUFBRSxhQU5UO0lBT04sV0FBVyxFQUFFO0VBUFAsQ0FBUDtBQVVBLEMsQ0FFRDs7O0FBRUEsU0FBUyxXQUFULENBQXNCLEdBQXRCLEVBQTRCO0VBRTNCLElBQUssSUFBSSxDQUFDLEdBQUwsQ0FBVSxHQUFWLElBQWtCLEtBQXZCLEVBQStCLE9BQU8sQ0FBQyxJQUFSLENBQWMsb0RBQWQ7RUFFL0IsR0FBRyxHQUFHLElBQUEsZ0JBQUEsRUFBTyxHQUFQLEVBQVksQ0FBRSxLQUFkLEVBQXFCLEtBQXJCLENBQU47RUFFQSxPQUFPLENBQUMsU0FBUixDQUFtQixDQUFuQixJQUF5QixHQUF6QjtFQUNBLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxVQUFSLENBQW9CLENBQXBCLENBQVY7RUFDQSxNQUFNLENBQUMsR0FBSyxDQUFDLElBQUksRUFBUCxHQUFjLEtBQXhCO0VBQ0EsT0FBTyxPQUFPLENBQUMsU0FBUixDQUFtQixDQUFuQixLQUEyQixDQUFFLENBQUMsR0FBRyxVQUFOLEtBQXNCLE9BQU8sQ0FBQyxVQUFSLENBQW9CLENBQXBCLENBQWpELENBQVA7QUFFQSxDLENBRUQ7OztBQUVBLFNBQVMsYUFBVCxDQUF3QixHQUF4QixFQUE4QjtFQUU3QixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksRUFBakI7RUFDQSxPQUFPLENBQUMsVUFBUixDQUFvQixDQUFwQixJQUEwQixPQUFPLENBQUMsYUFBUixDQUF1QixPQUFPLENBQUMsV0FBUixDQUFxQixDQUFyQixLQUE2QixHQUFHLEdBQUcsS0FBbkMsQ0FBdkIsSUFBc0UsT0FBTyxDQUFDLGFBQVIsQ0FBdUIsQ0FBdkIsQ0FBaEc7RUFDQSxPQUFPLE9BQU8sQ0FBQyxTQUFSLENBQW1CLENBQW5CLENBQVA7QUFFQTs7QUFFRCxNQUFNLFNBQVMsR0FBRztFQUNqQixXQUFXLEVBQUUsV0FESTtFQUVqQixhQUFhLEVBQUU7QUFGRSxDQUFsQjs7Ozs7Ozs7Ozs7QUN0S0E7O0FBRUEsTUFBTSxJQUFOLENBQVc7RUFFVixXQUFXLENBQUUsR0FBRyxHQUFHLElBQUksZUFBSixDQUFhLENBQUUsUUFBZixFQUF5QixDQUFFLFFBQTNCLEVBQXFDLENBQUUsUUFBdkMsQ0FBUixFQUEyRCxHQUFHLEdBQUcsSUFBSSxlQUFKLENBQWEsQ0FBRSxRQUFmLEVBQXlCLENBQUUsUUFBM0IsRUFBcUMsQ0FBRSxRQUF2QyxDQUFqRSxFQUFxSDtJQUUvSCxLQUFLLE1BQUwsR0FBYyxJQUFkO0lBRUEsS0FBSyxHQUFMLEdBQVcsR0FBWDtJQUNBLEtBQUssR0FBTCxHQUFXLEdBQVg7RUFFQTs7RUFFRCxHQUFHLENBQUUsR0FBRixFQUFPLEdBQVAsRUFBYTtJQUVmLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBZSxHQUFmO0lBQ0EsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFlLEdBQWY7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxZQUFZLENBQUUsS0FBRixFQUFVO0lBRXJCLEtBQUssU0FBTDs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQTVCLEVBQW9DLENBQUMsR0FBRyxFQUF4QyxFQUE0QyxDQUFDLElBQUksQ0FBakQsRUFBcUQ7TUFFcEQsS0FBSyxhQUFMLENBQW9CLE9BQU8sQ0FBQyxTQUFSLENBQW1CLEtBQW5CLEVBQTBCLENBQTFCLENBQXBCO0lBRUE7O0lBRUQsT0FBTyxJQUFQO0VBRUE7O0VBRUQsc0JBQXNCLENBQUUsU0FBRixFQUFjO0lBRW5DLEtBQUssU0FBTDs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsU0FBUyxDQUFDLEtBQWhDLEVBQXVDLENBQUMsR0FBRyxFQUEzQyxFQUErQyxDQUFDLEVBQWhELEVBQXNEO01BRXJELEtBQUssYUFBTCxDQUFvQixPQUFPLENBQUMsbUJBQVIsQ0FBNkIsU0FBN0IsRUFBd0MsQ0FBeEMsQ0FBcEI7SUFFQTs7SUFFRCxPQUFPLElBQVA7RUFFQTs7RUFFRCxhQUFhLENBQUUsTUFBRixFQUFXO0lBRXZCLEtBQUssU0FBTDs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQTdCLEVBQXFDLENBQUMsR0FBRyxFQUF6QyxFQUE2QyxDQUFDLEVBQTlDLEVBQW9EO01BRW5ELEtBQUssYUFBTCxDQUFvQixNQUFNLENBQUUsQ0FBRixDQUExQjtJQUVBOztJQUVELE9BQU8sSUFBUDtFQUVBOztFQUVELG9CQUFvQixDQUFFLE1BQUYsRUFBVSxJQUFWLEVBQWlCO0lBRXBDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxJQUFSLENBQWMsSUFBZCxFQUFxQixjQUFyQixDQUFxQyxHQUFyQyxDQUFqQjs7SUFFQSxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWUsTUFBZixFQUF3QixHQUF4QixDQUE2QixRQUE3QjtJQUNBLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBZSxNQUFmLEVBQXdCLEdBQXhCLENBQTZCLFFBQTdCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsYUFBYSxDQUFFLE1BQUYsRUFBVSxPQUFPLEdBQUcsS0FBcEIsRUFBNEI7SUFFeEMsS0FBSyxTQUFMO0lBRUEsT0FBTyxLQUFLLGNBQUwsQ0FBcUIsTUFBckIsRUFBNkIsT0FBN0IsQ0FBUDtFQUVBOztFQUVELEtBQUssR0FBRztJQUVQLE9BQU8sSUFBSSxLQUFLLFdBQVQsR0FBdUIsSUFBdkIsQ0FBNkIsSUFBN0IsQ0FBUDtFQUVBOztFQUVELElBQUksQ0FBRSxHQUFGLEVBQVE7SUFFWCxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWUsR0FBRyxDQUFDLEdBQW5CO0lBQ0EsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFlLEdBQUcsQ0FBQyxHQUFuQjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELFNBQVMsR0FBRztJQUVYLEtBQUssR0FBTCxDQUFTLENBQVQsR0FBYSxLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBVCxHQUFhLENBQUUsUUFBekM7SUFDQSxLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBVCxHQUFhLEtBQUssR0FBTCxDQUFTLENBQVQsR0FBYSxDQUFFLFFBQXpDO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsT0FBTyxHQUFHO0lBRVQ7SUFFQSxPQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsR0FBYSxLQUFLLEdBQUwsQ0FBUyxDQUF4QixJQUFpQyxLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBdkQsSUFBZ0UsS0FBSyxHQUFMLENBQVMsQ0FBVCxHQUFhLEtBQUssR0FBTCxDQUFTLENBQTdGO0VBRUE7O0VBRUQsU0FBUyxDQUFFLE1BQUYsRUFBVztJQUVuQixPQUFPLEtBQUssT0FBTCxLQUFpQixNQUFNLENBQUMsR0FBUCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLENBQWxCLENBQWpCLEdBQXlDLE1BQU0sQ0FBQyxVQUFQLENBQW1CLEtBQUssR0FBeEIsRUFBNkIsS0FBSyxHQUFsQyxFQUF3QyxjQUF4QyxDQUF3RCxHQUF4RCxDQUFoRDtFQUVBOztFQUVELE9BQU8sQ0FBRSxNQUFGLEVBQVc7SUFFakIsT0FBTyxLQUFLLE9BQUwsS0FBaUIsTUFBTSxDQUFDLEdBQVAsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFqQixHQUF5QyxNQUFNLENBQUMsVUFBUCxDQUFtQixLQUFLLEdBQXhCLEVBQTZCLEtBQUssR0FBbEMsQ0FBaEQ7RUFFQTs7RUFFRCxhQUFhLENBQUUsS0FBRixFQUFVO0lBRXRCLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYyxLQUFkO0lBQ0EsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFjLEtBQWQ7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxjQUFjLENBQUUsTUFBRixFQUFXO0lBRXhCLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYyxNQUFkO0lBQ0EsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFjLE1BQWQ7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxjQUFjLENBQUUsTUFBRixFQUFXO0lBRXhCLEtBQUssR0FBTCxDQUFTLFNBQVQsQ0FBb0IsQ0FBRSxNQUF0QjtJQUNBLEtBQUssR0FBTCxDQUFTLFNBQVQsQ0FBb0IsTUFBcEI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxjQUFjLENBQUUsTUFBRixFQUFVLE9BQU8sR0FBRyxLQUFwQixFQUE0QjtJQUV6QztJQUNBO0lBRUEsTUFBTSxDQUFDLGlCQUFQLENBQTBCLEtBQTFCLEVBQWlDLEtBQWpDOztJQUVBLElBQUssTUFBTSxDQUFDLFdBQVAsS0FBdUIsU0FBNUIsRUFBd0M7TUFFdkMsSUFBSyxNQUFNLENBQUMsV0FBUCxLQUF1QixJQUE1QixFQUFtQztRQUVsQyxNQUFNLENBQUMsa0JBQVA7TUFFQTs7TUFFRCxJQUFJLENBQUMsSUFBTCxDQUFXLE1BQU0sQ0FBQyxXQUFsQjs7TUFDQSxJQUFJLENBQUMsWUFBTCxDQUFtQixNQUFNLENBQUMsV0FBMUI7O01BRUEsS0FBSyxLQUFMLENBQVksSUFBWjtJQUVBLENBYkQsTUFhTztNQUVOLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUF4Qjs7TUFFQSxJQUFLLFFBQVEsS0FBSyxTQUFsQixFQUE4QjtRQUU3QixJQUFLLE9BQU8sSUFBSSxRQUFRLENBQUMsVUFBVCxLQUF3QixTQUFuQyxJQUFnRCxRQUFRLENBQUMsVUFBVCxDQUFvQixRQUFwQixLQUFpQyxTQUF0RixFQUFrRztVQUVqRyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsVUFBVCxDQUFvQixRQUFyQzs7VUFDQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQTlCLEVBQXFDLENBQUMsR0FBRyxDQUF6QyxFQUE0QyxDQUFDLEVBQTdDLEVBQW1EO1lBRWxELE9BQU8sQ0FBQyxtQkFBUixDQUE2QixRQUE3QixFQUF1QyxDQUF2QyxFQUEyQyxZQUEzQyxDQUF5RCxNQUFNLENBQUMsV0FBaEU7O1lBQ0EsS0FBSyxhQUFMLENBQW9CLE9BQXBCO1VBRUE7UUFFRCxDQVZELE1BVU87VUFFTixJQUFLLFFBQVEsQ0FBQyxXQUFULEtBQXlCLElBQTlCLEVBQXFDO1lBRXBDLFFBQVEsQ0FBQyxrQkFBVDtVQUVBOztVQUVELElBQUksQ0FBQyxJQUFMLENBQVcsUUFBUSxDQUFDLFdBQXBCOztVQUNBLElBQUksQ0FBQyxZQUFMLENBQW1CLE1BQU0sQ0FBQyxXQUExQjs7VUFFQSxLQUFLLEtBQUwsQ0FBWSxJQUFaO1FBRUE7TUFFRDtJQUVEOztJQUVELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUF4Qjs7SUFFQSxLQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQTlCLEVBQXNDLENBQUMsR0FBRyxDQUExQyxFQUE2QyxDQUFDLEVBQTlDLEVBQW9EO01BRW5ELEtBQUssY0FBTCxDQUFxQixRQUFRLENBQUUsQ0FBRixDQUE3QixFQUFvQyxPQUFwQztJQUVBOztJQUVELE9BQU8sSUFBUDtFQUVBOztFQUVELGFBQWEsQ0FBRSxLQUFGLEVBQVU7SUFFdEIsT0FBTyxLQUFLLENBQUMsQ0FBTixHQUFVLEtBQUssR0FBTCxDQUFTLENBQW5CLElBQXdCLEtBQUssQ0FBQyxDQUFOLEdBQVUsS0FBSyxHQUFMLENBQVMsQ0FBM0MsSUFDTixLQUFLLENBQUMsQ0FBTixHQUFVLEtBQUssR0FBTCxDQUFTLENBRGIsSUFDa0IsS0FBSyxDQUFDLENBQU4sR0FBVSxLQUFLLEdBQUwsQ0FBUyxDQURyQyxJQUVOLEtBQUssQ0FBQyxDQUFOLEdBQVUsS0FBSyxHQUFMLENBQVMsQ0FGYixJQUVrQixLQUFLLENBQUMsQ0FBTixHQUFVLEtBQUssR0FBTCxDQUFTLENBRnJDLEdBRXlDLEtBRnpDLEdBRWlELElBRnhEO0VBSUE7O0VBRUQsV0FBVyxDQUFFLEdBQUYsRUFBUTtJQUVsQixPQUFPLEtBQUssR0FBTCxDQUFTLENBQVQsSUFBYyxHQUFHLENBQUMsR0FBSixDQUFRLENBQXRCLElBQTJCLEdBQUcsQ0FBQyxHQUFKLENBQVEsQ0FBUixJQUFhLEtBQUssR0FBTCxDQUFTLENBQWpELElBQ04sS0FBSyxHQUFMLENBQVMsQ0FBVCxJQUFjLEdBQUcsQ0FBQyxHQUFKLENBQVEsQ0FEaEIsSUFDcUIsR0FBRyxDQUFDLEdBQUosQ0FBUSxDQUFSLElBQWEsS0FBSyxHQUFMLENBQVMsQ0FEM0MsSUFFTixLQUFLLEdBQUwsQ0FBUyxDQUFULElBQWMsR0FBRyxDQUFDLEdBQUosQ0FBUSxDQUZoQixJQUVxQixHQUFHLENBQUMsR0FBSixDQUFRLENBQVIsSUFBYSxLQUFLLEdBQUwsQ0FBUyxDQUZsRDtFQUlBOztFQUVELFlBQVksQ0FBRSxLQUFGLEVBQVMsTUFBVCxFQUFrQjtJQUU3QjtJQUNBO0lBRUEsT0FBTyxNQUFNLENBQUMsR0FBUCxDQUNOLENBQUUsS0FBSyxDQUFDLENBQU4sR0FBVSxLQUFLLEdBQUwsQ0FBUyxDQUFyQixLQUE2QixLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBbkQsQ0FETSxFQUVOLENBQUUsS0FBSyxDQUFDLENBQU4sR0FBVSxLQUFLLEdBQUwsQ0FBUyxDQUFyQixLQUE2QixLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBbkQsQ0FGTSxFQUdOLENBQUUsS0FBSyxDQUFDLENBQU4sR0FBVSxLQUFLLEdBQUwsQ0FBUyxDQUFyQixLQUE2QixLQUFLLEdBQUwsQ0FBUyxDQUFULEdBQWEsS0FBSyxHQUFMLENBQVMsQ0FBbkQsQ0FITSxDQUFQO0VBTUE7O0VBRUQsYUFBYSxDQUFFLEdBQUYsRUFBUTtJQUVwQjtJQUNBLE9BQU8sR0FBRyxDQUFDLEdBQUosQ0FBUSxDQUFSLEdBQVksS0FBSyxHQUFMLENBQVMsQ0FBckIsSUFBMEIsR0FBRyxDQUFDLEdBQUosQ0FBUSxDQUFSLEdBQVksS0FBSyxHQUFMLENBQVMsQ0FBL0MsSUFDTixHQUFHLENBQUMsR0FBSixDQUFRLENBQVIsR0FBWSxLQUFLLEdBQUwsQ0FBUyxDQURmLElBQ29CLEdBQUcsQ0FBQyxHQUFKLENBQVEsQ0FBUixHQUFZLEtBQUssR0FBTCxDQUFTLENBRHpDLElBRU4sR0FBRyxDQUFDLEdBQUosQ0FBUSxDQUFSLEdBQVksS0FBSyxHQUFMLENBQVMsQ0FGZixJQUVvQixHQUFHLENBQUMsR0FBSixDQUFRLENBQVIsR0FBWSxLQUFLLEdBQUwsQ0FBUyxDQUZ6QyxHQUU2QyxLQUY3QyxHQUVxRCxJQUY1RDtFQUlBOztFQUVELGdCQUFnQixDQUFFLE1BQUYsRUFBVztJQUUxQjtJQUNBLEtBQUssVUFBTCxDQUFpQixNQUFNLENBQUMsTUFBeEIsRUFBZ0MsT0FBaEMsRUFIMEIsQ0FLMUI7O0lBQ0EsT0FBTyxPQUFPLENBQUMsaUJBQVIsQ0FBMkIsTUFBTSxDQUFDLE1BQWxDLEtBQWdELE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQU0sQ0FBQyxNQUE5RTtFQUVBOztFQUVELGVBQWUsQ0FBRSxLQUFGLEVBQVU7SUFFeEI7SUFDQTtJQUVBLElBQUksR0FBSixFQUFTLEdBQVQ7O0lBRUEsSUFBSyxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsR0FBaUIsQ0FBdEIsRUFBMEI7TUFFekIsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBYixHQUFpQixLQUFLLEdBQUwsQ0FBUyxDQUFoQztNQUNBLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsR0FBaUIsS0FBSyxHQUFMLENBQVMsQ0FBaEM7SUFFQSxDQUxELE1BS087TUFFTixHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLEtBQUssR0FBTCxDQUFTLENBQWhDO01BQ0EsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBYixHQUFpQixLQUFLLEdBQUwsQ0FBUyxDQUFoQztJQUVBOztJQUVELElBQUssS0FBSyxDQUFDLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLENBQXRCLEVBQTBCO01BRXpCLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsR0FBaUIsS0FBSyxHQUFMLENBQVMsQ0FBakM7TUFDQSxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLEtBQUssR0FBTCxDQUFTLENBQWpDO0lBRUEsQ0FMRCxNQUtPO01BRU4sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBYixHQUFpQixLQUFLLEdBQUwsQ0FBUyxDQUFqQztNQUNBLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsR0FBaUIsS0FBSyxHQUFMLENBQVMsQ0FBakM7SUFFQTs7SUFFRCxJQUFLLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBYixHQUFpQixDQUF0QixFQUEwQjtNQUV6QixHQUFHLElBQUksS0FBSyxDQUFDLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLEtBQUssR0FBTCxDQUFTLENBQWpDO01BQ0EsR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBYixHQUFpQixLQUFLLEdBQUwsQ0FBUyxDQUFqQztJQUVBLENBTEQsTUFLTztNQUVOLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsR0FBaUIsS0FBSyxHQUFMLENBQVMsQ0FBakM7TUFDQSxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU4sQ0FBYSxDQUFiLEdBQWlCLEtBQUssR0FBTCxDQUFTLENBQWpDO0lBRUE7O0lBRUQsT0FBUyxHQUFHLElBQUksQ0FBRSxLQUFLLENBQUMsUUFBZixJQUEyQixHQUFHLElBQUksQ0FBRSxLQUFLLENBQUMsUUFBbkQ7RUFFQTs7RUFFRCxrQkFBa0IsQ0FBRSxRQUFGLEVBQWE7SUFFOUIsSUFBSyxLQUFLLE9BQUwsRUFBTCxFQUFzQjtNQUVyQixPQUFPLEtBQVA7SUFFQSxDQU42QixDQVE5Qjs7O0lBQ0EsS0FBSyxTQUFMLENBQWdCLE9BQWhCOztJQUNBLFFBQVEsQ0FBQyxVQUFULENBQXFCLEtBQUssR0FBMUIsRUFBK0IsT0FBL0IsRUFWOEIsQ0FZOUI7OztJQUNBLEdBQUcsQ0FBQyxVQUFKLENBQWdCLFFBQVEsQ0FBQyxDQUF6QixFQUE0QixPQUE1Qjs7SUFDQSxHQUFHLENBQUMsVUFBSixDQUFnQixRQUFRLENBQUMsQ0FBekIsRUFBNEIsT0FBNUI7O0lBQ0EsR0FBRyxDQUFDLFVBQUosQ0FBZ0IsUUFBUSxDQUFDLENBQXpCLEVBQTRCLE9BQTVCLEVBZjhCLENBaUI5Qjs7O0lBQ0EsR0FBRyxDQUFDLFVBQUosQ0FBZ0IsR0FBaEIsRUFBcUIsR0FBckI7O0lBQ0EsR0FBRyxDQUFDLFVBQUosQ0FBZ0IsR0FBaEIsRUFBcUIsR0FBckI7O0lBQ0EsR0FBRyxDQUFDLFVBQUosQ0FBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFwQjhCLENBc0I5QjtJQUNBO0lBQ0E7OztJQUNBLElBQUksSUFBSSxHQUFHLENBQ1YsQ0FEVSxFQUNQLENBQUUsR0FBRyxDQUFDLENBREMsRUFDRSxHQUFHLENBQUMsQ0FETixFQUNTLENBRFQsRUFDWSxDQUFFLEdBQUcsQ0FBQyxDQURsQixFQUNxQixHQUFHLENBQUMsQ0FEekIsRUFDNEIsQ0FENUIsRUFDK0IsQ0FBRSxHQUFHLENBQUMsQ0FEckMsRUFDd0MsR0FBRyxDQUFDLENBRDVDLEVBRVYsR0FBRyxDQUFDLENBRk0sRUFFSCxDQUZHLEVBRUEsQ0FBRSxHQUFHLENBQUMsQ0FGTixFQUVTLEdBQUcsQ0FBQyxDQUZiLEVBRWdCLENBRmhCLEVBRW1CLENBQUUsR0FBRyxDQUFDLENBRnpCLEVBRTRCLEdBQUcsQ0FBQyxDQUZoQyxFQUVtQyxDQUZuQyxFQUVzQyxDQUFFLEdBQUcsQ0FBQyxDQUY1QyxFQUdWLENBQUUsR0FBRyxDQUFDLENBSEksRUFHRCxHQUFHLENBQUMsQ0FISCxFQUdNLENBSE4sRUFHUyxDQUFFLEdBQUcsQ0FBQyxDQUhmLEVBR2tCLEdBQUcsQ0FBQyxDQUh0QixFQUd5QixDQUh6QixFQUc0QixDQUFFLEdBQUcsQ0FBQyxDQUhsQyxFQUdxQyxHQUFHLENBQUMsQ0FIekMsRUFHNEMsQ0FINUMsQ0FBWDs7SUFLQSxJQUFLLENBQUUsVUFBVSxDQUFFLElBQUYsRUFBUSxHQUFSLEVBQWEsR0FBYixFQUFrQixHQUFsQixFQUF1QixRQUF2QixDQUFqQixFQUFxRDtNQUVwRCxPQUFPLEtBQVA7SUFFQSxDQWxDNkIsQ0FvQzlCOzs7SUFDQSxJQUFJLEdBQUcsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixDQUFQOztJQUNBLElBQUssQ0FBRSxVQUFVLENBQUUsSUFBRixFQUFRLEdBQVIsRUFBYSxHQUFiLEVBQWtCLEdBQWxCLEVBQXVCLFFBQXZCLENBQWpCLEVBQXFEO01BRXBELE9BQU8sS0FBUDtJQUVBLENBMUM2QixDQTRDOUI7SUFDQTs7O0lBQ0EsZUFBZSxDQUFDLFlBQWhCLENBQThCLEdBQTlCLEVBQW1DLEdBQW5DOztJQUNBLElBQUksR0FBRyxDQUFFLGVBQWUsQ0FBQyxDQUFsQixFQUFxQixlQUFlLENBQUMsQ0FBckMsRUFBd0MsZUFBZSxDQUFDLENBQXhELENBQVA7SUFFQSxPQUFPLFVBQVUsQ0FBRSxJQUFGLEVBQVEsR0FBUixFQUFhLEdBQWIsRUFBa0IsR0FBbEIsRUFBdUIsUUFBdkIsQ0FBakI7RUFFQTs7RUFFRCxVQUFVLENBQUUsS0FBRixFQUFTLE1BQVQsRUFBa0I7SUFFM0IsT0FBTyxNQUFNLENBQUMsSUFBUCxDQUFhLEtBQWIsRUFBcUIsS0FBckIsQ0FBNEIsS0FBSyxHQUFqQyxFQUFzQyxLQUFLLEdBQTNDLENBQVA7RUFFQTs7RUFFRCxlQUFlLENBQUUsS0FBRixFQUFVO0lBRXhCLE9BQU8sS0FBSyxVQUFMLENBQWlCLEtBQWpCLEVBQXdCLE9BQXhCLEVBQWtDLFVBQWxDLENBQThDLEtBQTlDLENBQVA7RUFFQTs7RUFFRCxpQkFBaUIsQ0FBRSxNQUFGLEVBQVc7SUFFM0IsSUFBSyxLQUFLLE9BQUwsRUFBTCxFQUFzQjtNQUVyQixNQUFNLENBQUMsU0FBUDtJQUVBLENBSkQsTUFJTztNQUVOLEtBQUssU0FBTCxDQUFnQixNQUFNLENBQUMsTUFBdkI7TUFFQSxNQUFNLENBQUMsTUFBUCxHQUFnQixLQUFLLE9BQUwsQ0FBYyxPQUFkLEVBQXdCLE1BQXhCLEtBQW1DLEdBQW5EO0lBRUE7O0lBRUQsT0FBTyxNQUFQO0VBRUE7O0VBRUQsU0FBUyxDQUFFLEdBQUYsRUFBUTtJQUVoQixLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWMsR0FBRyxDQUFDLEdBQWxCO0lBQ0EsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFjLEdBQUcsQ0FBQyxHQUFsQixFQUhnQixDQUtoQjs7SUFDQSxJQUFLLEtBQUssT0FBTCxFQUFMLEVBQXNCLEtBQUssU0FBTDtJQUV0QixPQUFPLElBQVA7RUFFQTs7RUFFRCxLQUFLLENBQUUsR0FBRixFQUFRO0lBRVosS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFjLEdBQUcsQ0FBQyxHQUFsQjtJQUNBLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYyxHQUFHLENBQUMsR0FBbEI7SUFFQSxPQUFPLElBQVA7RUFFQTs7RUFFRCxZQUFZLENBQUUsTUFBRixFQUFXO0lBRXRCO0lBQ0EsSUFBSyxLQUFLLE9BQUwsRUFBTCxFQUFzQixPQUFPLElBQVAsQ0FIQSxDQUt0Qjs7SUFDQSxPQUFPLENBQUUsQ0FBRixDQUFQLENBQWEsR0FBYixDQUFrQixLQUFLLEdBQUwsQ0FBUyxDQUEzQixFQUE4QixLQUFLLEdBQUwsQ0FBUyxDQUF2QyxFQUEwQyxLQUFLLEdBQUwsQ0FBUyxDQUFuRCxFQUF1RCxZQUF2RCxDQUFxRSxNQUFyRSxFQU5zQixDQU15RDs7O0lBQy9FLE9BQU8sQ0FBRSxDQUFGLENBQVAsQ0FBYSxHQUFiLENBQWtCLEtBQUssR0FBTCxDQUFTLENBQTNCLEVBQThCLEtBQUssR0FBTCxDQUFTLENBQXZDLEVBQTBDLEtBQUssR0FBTCxDQUFTLENBQW5ELEVBQXVELFlBQXZELENBQXFFLE1BQXJFLEVBUHNCLENBT3lEOzs7SUFDL0UsT0FBTyxDQUFFLENBQUYsQ0FBUCxDQUFhLEdBQWIsQ0FBa0IsS0FBSyxHQUFMLENBQVMsQ0FBM0IsRUFBOEIsS0FBSyxHQUFMLENBQVMsQ0FBdkMsRUFBMEMsS0FBSyxHQUFMLENBQVMsQ0FBbkQsRUFBdUQsWUFBdkQsQ0FBcUUsTUFBckUsRUFSc0IsQ0FReUQ7OztJQUMvRSxPQUFPLENBQUUsQ0FBRixDQUFQLENBQWEsR0FBYixDQUFrQixLQUFLLEdBQUwsQ0FBUyxDQUEzQixFQUE4QixLQUFLLEdBQUwsQ0FBUyxDQUF2QyxFQUEwQyxLQUFLLEdBQUwsQ0FBUyxDQUFuRCxFQUF1RCxZQUF2RCxDQUFxRSxNQUFyRSxFQVRzQixDQVN5RDs7O0lBQy9FLE9BQU8sQ0FBRSxDQUFGLENBQVAsQ0FBYSxHQUFiLENBQWtCLEtBQUssR0FBTCxDQUFTLENBQTNCLEVBQThCLEtBQUssR0FBTCxDQUFTLENBQXZDLEVBQTBDLEtBQUssR0FBTCxDQUFTLENBQW5ELEVBQXVELFlBQXZELENBQXFFLE1BQXJFLEVBVnNCLENBVXlEOzs7SUFDL0UsT0FBTyxDQUFFLENBQUYsQ0FBUCxDQUFhLEdBQWIsQ0FBa0IsS0FBSyxHQUFMLENBQVMsQ0FBM0IsRUFBOEIsS0FBSyxHQUFMLENBQVMsQ0FBdkMsRUFBMEMsS0FBSyxHQUFMLENBQVMsQ0FBbkQsRUFBdUQsWUFBdkQsQ0FBcUUsTUFBckUsRUFYc0IsQ0FXeUQ7OztJQUMvRSxPQUFPLENBQUUsQ0FBRixDQUFQLENBQWEsR0FBYixDQUFrQixLQUFLLEdBQUwsQ0FBUyxDQUEzQixFQUE4QixLQUFLLEdBQUwsQ0FBUyxDQUF2QyxFQUEwQyxLQUFLLEdBQUwsQ0FBUyxDQUFuRCxFQUF1RCxZQUF2RCxDQUFxRSxNQUFyRSxFQVpzQixDQVl5RDs7O0lBQy9FLE9BQU8sQ0FBRSxDQUFGLENBQVAsQ0FBYSxHQUFiLENBQWtCLEtBQUssR0FBTCxDQUFTLENBQTNCLEVBQThCLEtBQUssR0FBTCxDQUFTLENBQXZDLEVBQTBDLEtBQUssR0FBTCxDQUFTLENBQW5ELEVBQXVELFlBQXZELENBQXFFLE1BQXJFLEVBYnNCLENBYXlEOzs7SUFFL0UsS0FBSyxhQUFMLENBQW9CLE9BQXBCO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsU0FBUyxDQUFFLE1BQUYsRUFBVztJQUVuQixLQUFLLEdBQUwsQ0FBUyxHQUFULENBQWMsTUFBZDtJQUNBLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYyxNQUFkO0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsTUFBTSxDQUFFLEdBQUYsRUFBUTtJQUViLE9BQU8sR0FBRyxDQUFDLEdBQUosQ0FBUSxNQUFSLENBQWdCLEtBQUssR0FBckIsS0FBOEIsR0FBRyxDQUFDLEdBQUosQ0FBUSxNQUFSLENBQWdCLEtBQUssR0FBckIsQ0FBckM7RUFFQTs7QUFwY1M7OztBQXdjWCxNQUFNLE9BQU8sR0FBRyxDQUNmLGFBQWMsSUFBSSxlQUFKLEVBREMsRUFFZixhQUFjLElBQUksZUFBSixFQUZDLEVBR2YsYUFBYyxJQUFJLGVBQUosRUFIQyxFQUlmLGFBQWMsSUFBSSxlQUFKLEVBSkMsRUFLZixhQUFjLElBQUksZUFBSixFQUxDLEVBTWYsYUFBYyxJQUFJLGVBQUosRUFOQyxFQU9mLGFBQWMsSUFBSSxlQUFKLEVBUEMsRUFRZixhQUFjLElBQUksZUFBSixFQVJDLENBQWhCOztBQVdBLE1BQU0sT0FBTyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTlCOztBQUVBLE1BQU0sSUFBSSxHQUFHLGFBQWMsSUFBSSxJQUFKLEVBQTNCLEMsQ0FFQTs7O0FBRUEsTUFBTSxHQUFHLEdBQUcsYUFBYyxJQUFJLGVBQUosRUFBMUI7O0FBQ0EsTUFBTSxHQUFHLEdBQUcsYUFBYyxJQUFJLGVBQUosRUFBMUI7O0FBQ0EsTUFBTSxHQUFHLEdBQUcsYUFBYyxJQUFJLGVBQUosRUFBMUIsQyxDQUVBOzs7QUFFQSxNQUFNLEdBQUcsR0FBRyxhQUFjLElBQUksZUFBSixFQUExQjs7QUFDQSxNQUFNLEdBQUcsR0FBRyxhQUFjLElBQUksZUFBSixFQUExQjs7QUFDQSxNQUFNLEdBQUcsR0FBRyxhQUFjLElBQUksZUFBSixFQUExQjs7QUFFQSxNQUFNLE9BQU8sR0FBRyxhQUFjLElBQUksZUFBSixFQUE5Qjs7QUFDQSxNQUFNLFFBQVEsR0FBRyxhQUFjLElBQUksZUFBSixFQUEvQjs7QUFDQSxNQUFNLGVBQWUsR0FBRyxhQUFjLElBQUksZUFBSixFQUF0Qzs7QUFDQSxNQUFNLFNBQVMsR0FBRyxhQUFjLElBQUksZUFBSixFQUFoQzs7QUFFQSxTQUFTLFVBQVQsQ0FBcUIsSUFBckIsRUFBMkIsRUFBM0IsRUFBK0IsRUFBL0IsRUFBbUMsRUFBbkMsRUFBdUMsT0FBdkMsRUFBaUQ7RUFFaEQsS0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFMLEdBQWMsQ0FBbkMsRUFBc0MsQ0FBQyxJQUFJLENBQTNDLEVBQThDLENBQUMsSUFBSSxDQUFuRCxFQUF1RDtJQUV0RCxTQUFTLENBQUMsU0FBVixDQUFxQixJQUFyQixFQUEyQixDQUEzQixFQUZzRCxDQUd0RDs7O0lBQ0EsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQVIsR0FBWSxJQUFJLENBQUMsR0FBTCxDQUFVLFNBQVMsQ0FBQyxDQUFwQixDQUFaLEdBQXNDLE9BQU8sQ0FBQyxDQUFSLEdBQVksSUFBSSxDQUFDLEdBQUwsQ0FBVSxTQUFTLENBQUMsQ0FBcEIsQ0FBbEQsR0FBNEUsT0FBTyxDQUFDLENBQVIsR0FBWSxJQUFJLENBQUMsR0FBTCxDQUFVLFNBQVMsQ0FBQyxDQUFwQixDQUFsRyxDQUpzRCxDQUt0RDs7SUFDQSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBSCxDQUFRLFNBQVIsQ0FBWDtJQUNBLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFILENBQVEsU0FBUixDQUFYO0lBQ0EsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUgsQ0FBUSxTQUFSLENBQVgsQ0FSc0QsQ0FTdEQ7O0lBQ0EsSUFBSyxJQUFJLENBQUMsR0FBTCxDQUFVLENBQUUsSUFBSSxDQUFDLEdBQUwsQ0FBVSxFQUFWLEVBQWMsRUFBZCxFQUFrQixFQUFsQixDQUFaLEVBQW9DLElBQUksQ0FBQyxHQUFMLENBQVUsRUFBVixFQUFjLEVBQWQsRUFBa0IsRUFBbEIsQ0FBcEMsSUFBK0QsQ0FBcEUsRUFBd0U7TUFFdkU7TUFDQTtNQUNBLE9BQU8sS0FBUDtJQUVBO0VBRUQ7O0VBRUQsT0FBTyxJQUFQO0FBRUE7Ozs7Ozs7Ozs7QUNsZ0JEOztBQUNBOztBQUNBOztBQUVBLE1BQU0sT0FBTyxHQUFHLGFBQWMsSUFBSSxlQUFKLEVBQTlCOztBQUNBLE1BQU0sV0FBVyxHQUFHLGFBQWMsSUFBSSxzQkFBSixFQUFsQzs7QUFFQSxNQUFNLEtBQU4sQ0FBWTtFQUVYLFdBQVcsQ0FBRSxDQUFDLEdBQUcsQ0FBTixFQUFTLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxDQUFwQixFQUF1QixLQUFLLEdBQUcsS0FBSyxDQUFDLGFBQXJDLEVBQXFEO0lBRS9ELEtBQUssT0FBTCxHQUFlLElBQWY7SUFFQSxLQUFLLEVBQUwsR0FBVSxDQUFWO0lBQ0EsS0FBSyxFQUFMLEdBQVUsQ0FBVjtJQUNBLEtBQUssRUFBTCxHQUFVLENBQVY7SUFDQSxLQUFLLE1BQUwsR0FBYyxLQUFkO0VBRUE7O0VBRUksSUFBRCxDQUFDLEdBQUc7SUFFUCxPQUFPLEtBQUssRUFBWjtFQUVBOztFQUVJLElBQUQsQ0FBQyxDQUFFLEtBQUYsRUFBVTtJQUVkLEtBQUssRUFBTCxHQUFVLEtBQVY7O0lBQ0EsS0FBSyxpQkFBTDtFQUVBOztFQUVJLElBQUQsQ0FBQyxHQUFHO0lBRVAsT0FBTyxLQUFLLEVBQVo7RUFFQTs7RUFFSSxJQUFELENBQUMsQ0FBRSxLQUFGLEVBQVU7SUFFZCxLQUFLLEVBQUwsR0FBVSxLQUFWOztJQUNBLEtBQUssaUJBQUw7RUFFQTs7RUFFSSxJQUFELENBQUMsR0FBRztJQUVQLE9BQU8sS0FBSyxFQUFaO0VBRUE7O0VBRUksSUFBRCxDQUFDLENBQUUsS0FBRixFQUFVO0lBRWQsS0FBSyxFQUFMLEdBQVUsS0FBVjs7SUFDQSxLQUFLLGlCQUFMO0VBRUE7O0VBRVEsSUFBTCxLQUFLLEdBQUc7SUFFWCxPQUFPLEtBQUssTUFBWjtFQUVBOztFQUVRLElBQUwsS0FBSyxDQUFFLEtBQUYsRUFBVTtJQUVsQixLQUFLLE1BQUwsR0FBYyxLQUFkOztJQUNBLEtBQUssaUJBQUw7RUFFQTs7RUFFRCxHQUFHLENBQUUsQ0FBRixFQUFLLENBQUwsRUFBUSxDQUFSLEVBQVcsS0FBSyxHQUFHLEtBQUssTUFBeEIsRUFBaUM7SUFFbkMsS0FBSyxFQUFMLEdBQVUsQ0FBVjtJQUNBLEtBQUssRUFBTCxHQUFVLENBQVY7SUFDQSxLQUFLLEVBQUwsR0FBVSxDQUFWO0lBQ0EsS0FBSyxNQUFMLEdBQWMsS0FBZDs7SUFFQSxLQUFLLGlCQUFMOztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELEtBQUssR0FBRztJQUVQLE9BQU8sSUFBSSxLQUFLLFdBQVQsQ0FBc0IsS0FBSyxFQUEzQixFQUErQixLQUFLLEVBQXBDLEVBQXdDLEtBQUssRUFBN0MsRUFBaUQsS0FBSyxNQUF0RCxDQUFQO0VBRUE7O0VBRUQsSUFBSSxDQUFFLEtBQUYsRUFBVTtJQUViLEtBQUssRUFBTCxHQUFVLEtBQUssQ0FBQyxFQUFoQjtJQUNBLEtBQUssRUFBTCxHQUFVLEtBQUssQ0FBQyxFQUFoQjtJQUNBLEtBQUssRUFBTCxHQUFVLEtBQUssQ0FBQyxFQUFoQjtJQUNBLEtBQUssTUFBTCxHQUFjLEtBQUssQ0FBQyxNQUFwQjs7SUFFQSxLQUFLLGlCQUFMOztJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELHFCQUFxQixDQUFFLENBQUYsRUFBSyxLQUFLLEdBQUcsS0FBSyxNQUFsQixFQUEwQixNQUFNLEdBQUcsSUFBbkMsRUFBMEM7SUFFOUQ7SUFFQSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsUUFBYjtJQUNBLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBRSxDQUFGLENBQWQ7SUFBQSxNQUFxQixHQUFHLEdBQUcsRUFBRSxDQUFFLENBQUYsQ0FBN0I7SUFBQSxNQUFvQyxHQUFHLEdBQUcsRUFBRSxDQUFFLENBQUYsQ0FBNUM7SUFDQSxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUUsQ0FBRixDQUFkO0lBQUEsTUFBcUIsR0FBRyxHQUFHLEVBQUUsQ0FBRSxDQUFGLENBQTdCO0lBQUEsTUFBb0MsR0FBRyxHQUFHLEVBQUUsQ0FBRSxDQUFGLENBQTVDO0lBQ0EsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFFLENBQUYsQ0FBZDtJQUFBLE1BQXFCLEdBQUcsR0FBRyxFQUFFLENBQUUsQ0FBRixDQUE3QjtJQUFBLE1BQW9DLEdBQUcsR0FBRyxFQUFFLENBQUUsRUFBRixDQUE1Qzs7SUFFQSxRQUFTLEtBQVQ7TUFFQyxLQUFLLEtBQUw7UUFFQyxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsSUFBTCxDQUFXLElBQUEsZ0JBQUEsRUFBTyxHQUFQLEVBQVksQ0FBRSxDQUFkLEVBQWlCLENBQWpCLENBQVgsQ0FBVjs7UUFFQSxJQUFLLElBQUksQ0FBQyxHQUFMLENBQVUsR0FBVixJQUFrQixTQUF2QixFQUFtQztVQUVsQyxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsS0FBTCxDQUFZLENBQUUsR0FBZCxFQUFtQixHQUFuQixDQUFWO1VBQ0EsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxDQUFFLEdBQWQsRUFBbUIsR0FBbkIsQ0FBVjtRQUVBLENBTEQsTUFLTztVQUVOLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFWO1VBQ0EsS0FBSyxFQUFMLEdBQVUsQ0FBVjtRQUVBOztRQUVEOztNQUVELEtBQUssS0FBTDtRQUVDLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxJQUFMLENBQVcsQ0FBRSxJQUFBLGdCQUFBLEVBQU8sR0FBUCxFQUFZLENBQUUsQ0FBZCxFQUFpQixDQUFqQixDQUFiLENBQVY7O1FBRUEsSUFBSyxJQUFJLENBQUMsR0FBTCxDQUFVLEdBQVYsSUFBa0IsU0FBdkIsRUFBbUM7VUFFbEMsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxHQUFaLEVBQWlCLEdBQWpCLENBQVY7VUFDQSxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsS0FBTCxDQUFZLEdBQVosRUFBaUIsR0FBakIsQ0FBVjtRQUVBLENBTEQsTUFLTztVQUVOLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksQ0FBRSxHQUFkLEVBQW1CLEdBQW5CLENBQVY7VUFDQSxLQUFLLEVBQUwsR0FBVSxDQUFWO1FBRUE7O1FBRUQ7O01BRUQsS0FBSyxLQUFMO1FBRUMsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLElBQUwsQ0FBVyxJQUFBLGdCQUFBLEVBQU8sR0FBUCxFQUFZLENBQUUsQ0FBZCxFQUFpQixDQUFqQixDQUFYLENBQVY7O1FBRUEsSUFBSyxJQUFJLENBQUMsR0FBTCxDQUFVLEdBQVYsSUFBa0IsU0FBdkIsRUFBbUM7VUFFbEMsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxDQUFFLEdBQWQsRUFBbUIsR0FBbkIsQ0FBVjtVQUNBLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksQ0FBRSxHQUFkLEVBQW1CLEdBQW5CLENBQVY7UUFFQSxDQUxELE1BS087VUFFTixLQUFLLEVBQUwsR0FBVSxDQUFWO1VBQ0EsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxHQUFaLEVBQWlCLEdBQWpCLENBQVY7UUFFQTs7UUFFRDs7TUFFRCxLQUFLLEtBQUw7UUFFQyxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsSUFBTCxDQUFXLENBQUUsSUFBQSxnQkFBQSxFQUFPLEdBQVAsRUFBWSxDQUFFLENBQWQsRUFBaUIsQ0FBakIsQ0FBYixDQUFWOztRQUVBLElBQUssSUFBSSxDQUFDLEdBQUwsQ0FBVSxHQUFWLElBQWtCLFNBQXZCLEVBQW1DO1VBRWxDLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFWO1VBQ0EsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxHQUFaLEVBQWlCLEdBQWpCLENBQVY7UUFFQSxDQUxELE1BS087VUFFTixLQUFLLEVBQUwsR0FBVSxDQUFWO1VBQ0EsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxDQUFFLEdBQWQsRUFBbUIsR0FBbkIsQ0FBVjtRQUVBOztRQUVEOztNQUVELEtBQUssS0FBTDtRQUVDLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxJQUFMLENBQVcsSUFBQSxnQkFBQSxFQUFPLEdBQVAsRUFBWSxDQUFFLENBQWQsRUFBaUIsQ0FBakIsQ0FBWCxDQUFWOztRQUVBLElBQUssSUFBSSxDQUFDLEdBQUwsQ0FBVSxHQUFWLElBQWtCLFNBQXZCLEVBQW1DO1VBRWxDLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksQ0FBRSxHQUFkLEVBQW1CLEdBQW5CLENBQVY7VUFDQSxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsS0FBTCxDQUFZLENBQUUsR0FBZCxFQUFtQixHQUFuQixDQUFWO1FBRUEsQ0FMRCxNQUtPO1VBRU4sS0FBSyxFQUFMLEdBQVUsQ0FBVjtVQUNBLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFWO1FBRUE7O1FBRUQ7O01BRUQsS0FBSyxLQUFMO1FBRUMsS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLElBQUwsQ0FBVyxDQUFFLElBQUEsZ0JBQUEsRUFBTyxHQUFQLEVBQVksQ0FBRSxDQUFkLEVBQWlCLENBQWpCLENBQWIsQ0FBVjs7UUFFQSxJQUFLLElBQUksQ0FBQyxHQUFMLENBQVUsR0FBVixJQUFrQixTQUF2QixFQUFtQztVQUVsQyxLQUFLLEVBQUwsR0FBVSxJQUFJLENBQUMsS0FBTCxDQUFZLEdBQVosRUFBaUIsR0FBakIsQ0FBVjtVQUNBLEtBQUssRUFBTCxHQUFVLElBQUksQ0FBQyxLQUFMLENBQVksR0FBWixFQUFpQixHQUFqQixDQUFWO1FBRUEsQ0FMRCxNQUtPO1VBRU4sS0FBSyxFQUFMLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBWSxDQUFFLEdBQWQsRUFBbUIsR0FBbkIsQ0FBVjtVQUNBLEtBQUssRUFBTCxHQUFVLENBQVY7UUFFQTs7UUFFRDs7TUFFRDtRQUVDLE9BQU8sQ0FBQyxJQUFSLENBQWMseUVBQXlFLEtBQXZGO0lBaEhGOztJQW9IQSxLQUFLLE1BQUwsR0FBYyxLQUFkO0lBRUEsSUFBSyxNQUFNLEtBQUssSUFBaEIsRUFBdUIsS0FBSyxpQkFBTDtJQUV2QixPQUFPLElBQVA7RUFFQTs7RUFFRCxpQkFBaUIsQ0FBRSxDQUFGLEVBQUssS0FBTCxFQUFZLE1BQVosRUFBcUI7SUFFckMsT0FBTyxDQUFDLDBCQUFSLENBQW9DLENBQXBDOztJQUVBLE9BQU8sS0FBSyxxQkFBTCxDQUE0QixPQUE1QixFQUFxQyxLQUFyQyxFQUE0QyxNQUE1QyxDQUFQO0VBRUE7O0VBRUQsY0FBYyxDQUFFLENBQUYsRUFBSyxLQUFLLEdBQUcsS0FBSyxNQUFsQixFQUEyQjtJQUV4QyxPQUFPLEtBQUssR0FBTCxDQUFVLENBQUMsQ0FBQyxDQUFaLEVBQWUsQ0FBQyxDQUFDLENBQWpCLEVBQW9CLENBQUMsQ0FBQyxDQUF0QixFQUF5QixLQUF6QixDQUFQO0VBRUE7O0VBRUQsT0FBTyxDQUFFLFFBQUYsRUFBYTtJQUVuQjtJQUVBLFdBQVcsQ0FBQyxZQUFaLENBQTBCLElBQTFCOztJQUVBLE9BQU8sS0FBSyxpQkFBTCxDQUF3QixXQUF4QixFQUFxQyxRQUFyQyxDQUFQO0VBRUE7O0VBRUQsTUFBTSxDQUFFLEtBQUYsRUFBVTtJQUVmLE9BQVMsS0FBSyxDQUFDLEVBQU4sS0FBYSxLQUFLLEVBQXBCLElBQThCLEtBQUssQ0FBQyxFQUFOLEtBQWEsS0FBSyxFQUFoRCxJQUEwRCxLQUFLLENBQUMsRUFBTixLQUFhLEtBQUssRUFBNUUsSUFBc0YsS0FBSyxDQUFDLE1BQU4sS0FBaUIsS0FBSyxNQUFuSDtFQUVBOztFQUVELFNBQVMsQ0FBRSxLQUFGLEVBQVU7SUFFbEIsS0FBSyxFQUFMLEdBQVUsS0FBSyxDQUFFLENBQUYsQ0FBZjtJQUNBLEtBQUssRUFBTCxHQUFVLEtBQUssQ0FBRSxDQUFGLENBQWY7SUFDQSxLQUFLLEVBQUwsR0FBVSxLQUFLLENBQUUsQ0FBRixDQUFmO0lBQ0EsSUFBSyxLQUFLLENBQUUsQ0FBRixDQUFMLEtBQWUsU0FBcEIsRUFBZ0MsS0FBSyxNQUFMLEdBQWMsS0FBSyxDQUFFLENBQUYsQ0FBbkI7O0lBRWhDLEtBQUssaUJBQUw7O0lBRUEsT0FBTyxJQUFQO0VBRUE7O0VBRUQsT0FBTyxDQUFFLEtBQUssR0FBRyxFQUFWLEVBQWMsTUFBTSxHQUFHLENBQXZCLEVBQTJCO0lBRWpDLEtBQUssQ0FBRSxNQUFGLENBQUwsR0FBa0IsS0FBSyxFQUF2QjtJQUNBLEtBQUssQ0FBRSxNQUFNLEdBQUcsQ0FBWCxDQUFMLEdBQXNCLEtBQUssRUFBM0I7SUFDQSxLQUFLLENBQUUsTUFBTSxHQUFHLENBQVgsQ0FBTCxHQUFzQixLQUFLLEVBQTNCO0lBQ0EsS0FBSyxDQUFFLE1BQU0sR0FBRyxDQUFYLENBQUwsR0FBc0IsS0FBSyxNQUEzQjtJQUVBLE9BQU8sS0FBUDtFQUVBOztFQUVELFNBQVMsQ0FBRSxRQUFGLEVBQWE7SUFFckIsS0FBSyxpQkFBTCxHQUF5QixRQUF6QjtJQUVBLE9BQU8sSUFBUDtFQUVBOztFQUVELGlCQUFpQixHQUFHLENBQUU7O0VBRUosRUFBZixNQUFNLENBQUMsUUFBUSxJQUFLO0lBRXRCLE1BQU0sS0FBSyxFQUFYO0lBQ0EsTUFBTSxLQUFLLEVBQVg7SUFDQSxNQUFNLEtBQUssRUFBWDtJQUNBLE1BQU0sS0FBSyxNQUFYO0VBRUE7O0FBN1NVOzs7QUFpVFosS0FBSyxDQUFDLGFBQU4sR0FBc0IsS0FBdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4VEEsTUFBTSxJQUFJLEdBQUcsQ0FBRSxJQUFGLEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MsSUFBdEMsRUFBNEMsSUFBNUMsRUFBa0QsSUFBbEQsRUFBd0QsSUFBeEQsRUFBOEQsSUFBOUQsRUFBb0UsSUFBcEUsRUFBMEUsSUFBMUUsRUFBZ0YsSUFBaEYsRUFBc0YsSUFBdEYsRUFBNEYsSUFBNUYsRUFBa0csSUFBbEcsRUFBd0csSUFBeEcsRUFBOEcsSUFBOUcsRUFBb0gsSUFBcEgsRUFBMEgsSUFBMUgsRUFBZ0ksSUFBaEksRUFBc0ksSUFBdEksRUFBNEksSUFBNUksRUFBa0osSUFBbEosRUFBd0osSUFBeEosRUFBOEosSUFBOUosRUFBb0ssSUFBcEssRUFBMEssSUFBMUssRUFBZ0wsSUFBaEwsRUFBc0wsSUFBdEwsRUFBNEwsSUFBNUwsRUFBa00sSUFBbE0sRUFBd00sSUFBeE0sRUFBOE0sSUFBOU0sRUFBb04sSUFBcE4sRUFBME4sSUFBMU4sRUFBZ08sSUFBaE8sRUFBc08sSUFBdE8sRUFBNE8sSUFBNU8sRUFBa1AsSUFBbFAsRUFBd1AsSUFBeFAsRUFBOFAsSUFBOVAsRUFBb1EsSUFBcFEsRUFBMFEsSUFBMVEsRUFBZ1IsSUFBaFIsRUFBc1IsSUFBdFIsRUFBNFIsSUFBNVIsRUFBa1MsSUFBbFMsRUFBd1MsSUFBeFMsRUFBOFMsSUFBOVMsRUFBb1QsSUFBcFQsRUFBMFQsSUFBMVQsRUFBZ1UsSUFBaFUsRUFBc1UsSUFBdFUsRUFBNFUsSUFBNVUsRUFBa1YsSUFBbFYsRUFBd1YsSUFBeFYsRUFBOFYsSUFBOVYsRUFBb1csSUFBcFcsRUFBMFcsSUFBMVcsRUFBZ1gsSUFBaFgsRUFBc1gsSUFBdFgsRUFBNFgsSUFBNVgsRUFBa1ksSUFBbFksRUFBd1ksSUFBeFksRUFBOFksSUFBOVksRUFBb1osSUFBcFosRUFBMFosSUFBMVosRUFBZ2EsSUFBaGEsRUFBc2EsSUFBdGEsRUFBNGEsSUFBNWEsRUFBa2IsSUFBbGIsRUFBd2IsSUFBeGIsRUFBOGIs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QztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQTs7TUFFRCxLQUFLLEtBQUw7UUFDQyxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0E7O01BRUQsS0FBSyxLQUFMO1FBQ0MsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBOztNQUVELEtBQUssS0FBTDtRQUNDLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5D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LElBQVA7QUFDSCxDQWJEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRqb2ludDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVF1YXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciBzLCBjLCB0XG4gIHZhciB4ID0gYXhpc1swXVxuICB2YXIgeSA9IGF4aXNbMV1cbiAgdmFyIHogPSBheGlzWzJdXG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KVxuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgMC4wMDAwMDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGVuID0gMSAvIGxlblxuICB4ICo9IGxlblxuICB5ICo9IGxlblxuICB6ICo9IGxlblxuXG4gIHMgPSBNYXRoLnNpbihyYWQpXG4gIGMgPSBNYXRoLmNvcyhyYWQpXG4gIHQgPSAxIC0gY1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IHggKiB4ICogdCArIGNcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHNcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHNcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogc1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjXG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHNcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHNcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGNcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tU2NhbGluZ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSAwXG4gIG91dFs1XSA9IHZbMV1cbiAgb3V0WzZdID0gMFxuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IDBcbiAgb3V0WzldID0gMFxuICBvdXRbMTBdID0gdlsyXVxuICBvdXRbMTFdID0gMFxuICBvdXRbMTJdID0gMFxuICBvdXRbMTNdID0gMFxuICBvdXRbMTRdID0gMFxuICBvdXRbMTVdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21UcmFuc2xhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSAxXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IDFcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IHZbMF1cbiAgb3V0WzEzXSA9IHZbMV1cbiAgb3V0WzE0XSA9IHZbMl1cbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWFJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gMVxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IDBcbiAgICBvdXRbNV0gPSBjXG4gICAgb3V0WzZdID0gc1xuICAgIG91dFs3XSA9IDBcbiAgICBvdXRbOF0gPSAwXG4gICAgb3V0WzldID0gLXNcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAtc1xuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gMVxuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gc1xuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWlJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IHNcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IC1zXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gMVxuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcnVzdHVtO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgaWRlbnRpdHk6IHJlcXVpcmUoJy4vaWRlbnRpdHknKVxuICAsIHRyYW5zcG9zZTogcmVxdWlyZSgnLi90cmFuc3Bvc2UnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGFkam9pbnQ6IHJlcXVpcmUoJy4vYWRqb2ludCcpXG4gICwgZGV0ZXJtaW5hbnQ6IHJlcXVpcmUoJy4vZGV0ZXJtaW5hbnQnKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCB0cmFuc2xhdGU6IHJlcXVpcmUoJy4vdHJhbnNsYXRlJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZnJvbVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvbicpXG4gICwgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24nKVxuICAsIGZyb21TY2FsaW5nOiByZXF1aXJlKCcuL2Zyb21TY2FsaW5nJylcbiAgLCBmcm9tVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVRyYW5zbGF0aW9uJylcbiAgLCBmcm9tWFJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21YUm90YXRpb24nKVxuICAsIGZyb21ZUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVlSb3RhdGlvbicpXG4gICwgZnJvbVpSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWlJvdGF0aW9uJylcbiAgLCBmcm9tUXVhdDogcmVxdWlyZSgnLi9mcm9tUXVhdCcpXG4gICwgZnJ1c3R1bTogcmVxdWlyZSgnLi9mcnVzdHVtJylcbiAgLCBwZXJzcGVjdGl2ZTogcmVxdWlyZSgnLi9wZXJzcGVjdGl2ZScpXG4gICwgcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcnKVxuICAsIG9ydGhvOiByZXF1aXJlKCcuL29ydGhvJylcbiAgLCBsb29rQXQ6IHJlcXVpcmUoJy4vbG9va0F0JylcbiAgLCBzdHI6IHJlcXVpcmUoJy4vc3RyJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2tBdDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gb3J0aG87XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmU7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWjtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc3RyO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc3RyKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlO1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5ncykge1xuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXG4gIHZhciBleHBycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpXG4gIHZhciBwYXJ0cyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgcGFydHMucHVzaChzdHJpbmdzW2ldLCBleHByc1tpXSB8fCAnJylcbiAgfVxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiIWZ1bmN0aW9uKHIsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpyfHxzZWxmKS5NZXlkYT10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihyLHQsZSl7aWYoZXx8Mj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBhLG49MCxvPXQubGVuZ3RoO248bztuKyspIWEmJm4gaW4gdHx8KGF8fChhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCxuKSksYVtuXT10W25dKTtyZXR1cm4gci5jb25jYXQoYXx8QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpfXZhciB0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGJsYWNrbWFuOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KHIpLGU9MipNYXRoLlBJLyhyLTEpLGE9MiplLG49MDtuPHIvMjtuKyspdFtuXT0uNDItLjUqTWF0aC5jb3MobiplKSsuMDgqTWF0aC5jb3MobiphKTtmb3Iobj1NYXRoLmNlaWwoci8yKTtuPjA7bi0tKXRbci1uXT10W24tMV07cmV0dXJuIHR9LHNpbmU6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PU1hdGguUEkvKHItMSksZT1uZXcgRmxvYXQzMkFycmF5KHIpLGE9MDthPHI7YSsrKWVbYV09TWF0aC5zaW4odCphKTtyZXR1cm4gZX0saGFubmluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41LS41Kk1hdGguY29zKDIqTWF0aC5QSSplLyhyLTEpKTtyZXR1cm4gdH0saGFtbWluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41NC0uNDYqTWF0aC5jb3MoMipNYXRoLlBJKihlL3ItMSkpO3JldHVybiB0fX0pLGU9e307ZnVuY3Rpb24gYShyKXtmb3IoO3IlMj09MCYmcj4xOylyLz0yO3JldHVybiAxPT09cn1mdW5jdGlvbiBuKHIsYSl7aWYoXCJyZWN0XCIhPT1hKXtpZihcIlwiIT09YSYmYXx8KGE9XCJoYW5uaW5nXCIpLGVbYV18fChlW2FdPXt9KSwhZVthXVtyLmxlbmd0aF0pdHJ5e2VbYV1bci5sZW5ndGhdPXRbYV0oci5sZW5ndGgpfWNhdGNoKHIpe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2luZG93aW5nIGZ1bmN0aW9uXCIpfXI9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGU9W10sYT0wO2E8TWF0aC5taW4oci5sZW5ndGgsdC5sZW5ndGgpO2ErKyllW2FdPXJbYV0qdFthXTtyZXR1cm4gZX0ocixlW2FdW3IubGVuZ3RoXSl9cmV0dXJuIHJ9ZnVuY3Rpb24gbyhyLHQsZSl7Zm9yKHZhciBhPW5ldyBGbG9hdDMyQXJyYXkociksbj0wO248YS5sZW5ndGg7bisrKWFbbl09bip0L2UsYVtuXT0xMypNYXRoLmF0YW4oYVtuXS8xMzE1LjgpKzMuNSpNYXRoLmF0YW4oTWF0aC5wb3coYVtuXS83NTE4LDIpKTtyZXR1cm4gYX1mdW5jdGlvbiBpKHIpe3JldHVybiBGbG9hdDMyQXJyYXkuZnJvbShyKX1mdW5jdGlvbiB1KHIpe3JldHVybiAxMTI1Kk1hdGgubG9nKDErci83MDApfWZ1bmN0aW9uIGYocix0LGUpe2Zvcih2YXIgYSxuPW5ldyBGbG9hdDMyQXJyYXkocisyKSxvPW5ldyBGbG9hdDMyQXJyYXkocisyKSxpPXQvMixmPXUoMCksYz0odShpKS1mKS8ocisxKSxsPW5ldyBBcnJheShyKzIpLHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPXMqYyxvW3NdPShhPW5bc10sNzAwKihNYXRoLmV4cChhLzExMjUpLTEpKSxsW3NdPU1hdGguZmxvb3IoKGUrMSkqb1tzXS90KTtmb3IodmFyIG09bmV3IEFycmF5KHIpLHA9MDtwPG0ubGVuZ3RoO3ArKyl7bVtwXT1uZXcgQXJyYXkoZS8yKzEpLmZpbGwoMCk7Zm9yKHM9bFtwXTtzPGxbcCsxXTtzKyspbVtwXVtzXT0ocy1sW3BdKS8obFtwKzFdLWxbcF0pO2ZvcihzPWxbcCsxXTtzPGxbcCsyXTtzKyspbVtwXVtzXT0obFtwKzJdLXMpLyhsW3ArMl0tbFtwKzFdKX1yZXR1cm4gbX1mdW5jdGlvbiBjKHQsZSxhLG4sbyxpLHUpe3ZvaWQgMD09PW4mJihuPTUpLHZvaWQgMD09PW8mJihvPTIpLHZvaWQgMD09PWkmJihpPSEwKSx2b2lkIDA9PT11JiYodT00NDApO3ZhciBmPU1hdGguZmxvb3IoYS8yKSsxLGM9bmV3IEFycmF5KGEpLmZpbGwoMCkubWFwKChmdW5jdGlvbihyLG4pe3JldHVybiB0KmZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubG9nMigxNipyL3QpfShlKm4vYSx1KX0pKTtjWzBdPWNbMV0tMS41KnQ7dmFyIGwscyxtLHA9Yy5zbGljZSgxKS5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubWF4KHItY1t0XSl9KSwxKS5jb25jYXQoWzFdKSxoPU1hdGgucm91bmQodC8yKSxnPW5ldyBBcnJheSh0KS5maWxsKDApLm1hcCgoZnVuY3Rpb24ocixlKXtyZXR1cm4gYy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybigxMCp0K2grci1lKSV0LWh9KSl9KSksdz1nLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygyKmdbdF1bZV0vcFtlXSwyKSl9KSl9KSk7aWYocz0obD13KVswXS5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuIDB9KSksbT1sLnJlZHVjZSgoZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3JbZV0rPU1hdGgucG93KHQsMil9KSkscn0pLHMpLm1hcChNYXRoLnNxcnQpLHc9bC5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIHIubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiByLyhtW3RdfHwxKX0pKX0pKSxvKXt2YXIgdj1jLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygoci90LW4pL28sMikpfSkpO3c9dy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gcip2W3RdfSkpfSkpfXJldHVybiBpJiYodz1yKHIoW10sdy5zbGljZSgzKSwhMCksdy5zbGljZSgwLDMpLCEwKSksdy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLnNsaWNlKDAsZil9KSl9ZnVuY3Rpb24gbChyLHQpe2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5wb3cobixyKSpNYXRoLmFicyh0W25dKSxhKz10W25dO3JldHVybiBlL2F9ZnVuY3Rpb24gcyhyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5iYXJrU2NhbGUsYT1yLm51bWJlck9mQmFya0JhbmRzLG49dm9pZCAwPT09YT8yNDphO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBvPW4saT1uZXcgRmxvYXQzMkFycmF5KG8pLHU9MCxmPXQsYz1uZXcgSW50MzJBcnJheShvKzEpO2NbMF09MDtmb3IodmFyIGw9ZVtmLmxlbmd0aC0xXS9vLHM9MSxtPTA7bTxmLmxlbmd0aDttKyspZm9yKDtlW21dPmw7KWNbcysrXT1tLGw9cyplW2YubGVuZ3RoLTFdL287Y1tvXT1mLmxlbmd0aC0xO2ZvcihtPTA7bTxvO20rKyl7Zm9yKHZhciBwPTAsaD1jW21dO2g8Y1ttKzFdO2grKylwKz1mW2hdO2lbbV09TWF0aC5wb3cocCwuMjMpfWZvcihtPTA7bTxpLmxlbmd0aDttKyspdSs9aVttXTtyZXR1cm57c3BlY2lmaWM6aSx0b3RhbDp1fX1mdW5jdGlvbiBtKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksYT0wO2E8ZS5sZW5ndGg7YSsrKWVbYV09TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZX1mdW5jdGlvbiBwKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWxpZCBtZWxGaWx0ZXJCYW5rIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2Zvcih2YXIgbj1tKHthbXBTcGVjdHJ1bTp0fSksbz1lLmxlbmd0aCxpPUFycmF5KG8pLHU9bmV3IEZsb2F0MzJBcnJheShvKSxmPTA7Zjx1Lmxlbmd0aDtmKyspe2lbZl09bmV3IEZsb2F0MzJBcnJheShhLzIpLHVbZl09MDtmb3IodmFyIGM9MDtjPGEvMjtjKyspaVtmXVtjXT1lW2ZdW2NdKm5bY10sdVtmXSs9aVtmXVtjXTt1W2ZdPU1hdGgubG9nKHVbZl0rMSl9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHUpfWZ1bmN0aW9uIGgocil7cmV0dXJuIHImJnIuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJkZWZhdWx0XCIpP3IuZGVmYXVsdDpyfXZhciBnPXtleHBvcnRzOnt9fSx3PW51bGw7dmFyIHY9ZnVuY3Rpb24ocix0KXt2YXIgZT1yLmxlbmd0aDtyZXR1cm4gdD10fHwyLHcmJndbZV18fGZ1bmN0aW9uKHIpeyh3PXd8fHt9KVtyXT1uZXcgQXJyYXkocipyKTtmb3IodmFyIHQ9TWF0aC5QSS9yLGU9MDtlPHI7ZSsrKWZvcih2YXIgYT0wO2E8cjthKyspd1tyXVthK2Uqcl09TWF0aC5jb3ModCooYSsuNSkqZSl9KGUpLHIubWFwKChmdW5jdGlvbigpe3JldHVybiAwfSkpLm1hcCgoZnVuY3Rpb24oYSxuKXtyZXR1cm4gdCpyLnJlZHVjZSgoZnVuY3Rpb24ocix0LGEsbyl7cmV0dXJuIHIrdCp3W2VdW2ErbiplXX0pLDApfSkpfTshZnVuY3Rpb24ocil7ci5leHBvcnRzPXZ9KGcpO3ZhciBkPWgoZy5leHBvcnRzKTt2YXIgeT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxidWZmZXI6ZnVuY3Rpb24ocil7cmV0dXJuIHIuc2lnbmFsfSxybXM6ZnVuY3Rpb24ocil7dmFyIHQ9ci5zaWduYWw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9MCxhPTA7YTx0Lmxlbmd0aDthKyspZSs9TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZS89dC5sZW5ndGgsZT1NYXRoLnNxcnQoZSl9LGVuZXJneTpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MDthPHQubGVuZ3RoO2ErKyllKz1NYXRoLnBvdyhNYXRoLmFicyh0W2FdKSwyKTtyZXR1cm4gZX0sY29tcGxleFNwZWN0cnVtOmZ1bmN0aW9uKHIpe3JldHVybiByLmNvbXBsZXhTcGVjdHJ1bX0sc3BlY3RyYWxTbG9wZTpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5zYW1wbGVSYXRlLGE9ci5idWZmZXJTaXplO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0wLGk9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksdT0wLGY9MCxjPTA7Yzx0Lmxlbmd0aDtjKyspe24rPXRbY107dmFyIGw9YyplL2E7aVtjXT1sLHUrPWwqbCxvKz1sLGYrPWwqdFtjXX1yZXR1cm4odC5sZW5ndGgqZi1vKm4pLyhuKih1LU1hdGgucG93KG8sMikpKX0sc3BlY3RyYWxDZW50cm9pZDpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7cmV0dXJuIGwoMSx0KX0sc3BlY3RyYWxSb2xsb2ZmOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLnNhbXBsZVJhdGU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGE9dCxuPWUvKDIqKGEubGVuZ3RoLTEpKSxvPTAsaT0wO2k8YS5sZW5ndGg7aSsrKW8rPWFbaV07Zm9yKHZhciB1PS45OSpvLGY9YS5sZW5ndGgtMTtvPnUmJmY+PTA7KW8tPWFbZl0sLS1mO3JldHVybihmKzEpKm59LHNwZWN0cmFsRmxhdG5lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5sb2codFtuXSksYSs9dFtuXTtyZXR1cm4gTWF0aC5leHAoZS90Lmxlbmd0aCkqdC5sZW5ndGgvYX0sc3BlY3RyYWxTcHJlYWQ6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3JldHVybiBNYXRoLnNxcnQobCgyLHQpLU1hdGgucG93KGwoMSx0KSwyKSl9LHNwZWN0cmFsU2tld25lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBlPWwoMSx0KSxhPWwoMix0KSxuPWwoMyx0KTtyZXR1cm4oMipNYXRoLnBvdyhlLDMpLTMqZSphK24pL01hdGgucG93KE1hdGguc3FydChhLU1hdGgucG93KGUsMikpLDMpfSxzcGVjdHJhbEt1cnRvc2lzOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT10LGE9bCgxLGUpLG49bCgyLGUpLG89bCgzLGUpLGk9bCg0LGUpO3JldHVybigtMypNYXRoLnBvdyhhLDQpKzYqYSpuLTQqYSpvK2kpL01hdGgucG93KE1hdGguc3FydChuLU1hdGgucG93KGEsMikpLDQpfSxhbXBsaXR1ZGVTcGVjdHJ1bTpmdW5jdGlvbihyKXtyZXR1cm4gci5hbXBTcGVjdHJ1bX0semNyOmZ1bmN0aW9uKHIpe3ZhciB0PXIuc2lnbmFsO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBlPTAsYT0xO2E8dC5sZW5ndGg7YSsrKSh0W2EtMV0+PTAmJnRbYV08MHx8dFthLTFdPDAmJnRbYV0+PTApJiZlKys7cmV0dXJuIGV9LGxvdWRuZXNzOnMscGVyY2VwdHVhbFNwcmVhZDpmdW5jdGlvbihyKXtmb3IodmFyIHQ9cyh7YW1wU3BlY3RydW06ci5hbXBTcGVjdHJ1bSxiYXJrU2NhbGU6ci5iYXJrU2NhbGV9KSxlPTAsYT0wO2E8dC5zcGVjaWZpYy5sZW5ndGg7YSsrKXQuc3BlY2lmaWNbYV0+ZSYmKGU9dC5zcGVjaWZpY1thXSk7cmV0dXJuIE1hdGgucG93KCh0LnRvdGFsLWUpL3QudG90YWwsMil9LHBlcmNlcHR1YWxTaGFycG5lc3M6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PXMoe2FtcFNwZWN0cnVtOnIuYW1wU3BlY3RydW0sYmFya1NjYWxlOnIuYmFya1NjYWxlfSksZT10LnNwZWNpZmljLGE9MCxuPTA7bjxlLmxlbmd0aDtuKyspYSs9bjwxNT8obisxKSplW24rMV06LjA2NipNYXRoLmV4cCguMTcxKihuKzEpKTtyZXR1cm4gYSo9LjExL3QudG90YWx9LHBvd2VyU3BlY3RydW06bSxtZmNjOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyxuPXIuYnVmZmVyU2l6ZSxvPU1hdGgubWluKDQwLE1hdGgubWF4KDEsYXx8MTMpKTtpZihlLmxlbmd0aDxvKXRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBmaWx0ZXIgYmFuayBmb3IgcmVxdWVzdGVkIG51bWJlciBvZiBjb2VmZmljaWVudHNcIik7dmFyIGk9cCh7YW1wU3BlY3RydW06dCxtZWxGaWx0ZXJCYW5rOmUsYnVmZmVyU2l6ZTpufSk7cmV0dXJuIGQoaSkuc2xpY2UoMCxvKX0sY2hyb21hOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLmNocm9tYUZpbHRlckJhbms7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgY2hyb21hRmlsdGVyQmFuayBpcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBjaHJvbWFcIik7dmFyIGE9ZS5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbih0LGUsYSl7cmV0dXJuIHQrZSpyW2FdfSksMCl9KSksbj1NYXRoLm1heC5hcHBseShNYXRoLGEpO3JldHVybiBuP2EubWFwKChmdW5jdGlvbihyKXtyZXR1cm4gci9ufSkpOmF9LHNwZWN0cmFsRmx1eDpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbCxlPXIucHJldmlvdXNTaWduYWwsYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0tYS8yO288dC5sZW5ndGgvMi0xO28rKyl4PU1hdGguYWJzKHRbb10pLU1hdGguYWJzKGVbb10pLG4rPSh4K01hdGguYWJzKHgpKS8yO3JldHVybiBufSxzcGVjdHJhbENyZXN0OmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT0wLGE9LTEvMDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihyKXtlKz1NYXRoLnBvdyhyLDIpLGE9cj5hP3I6YX0pKSxlLz10Lmxlbmd0aCxlPU1hdGguc3FydChlKSxhL2V9LG1lbEJhbmRzOnB9KTtmdW5jdGlvbiBTKHIpe2lmKEFycmF5LmlzQXJyYXkocikpe2Zvcih2YXIgdD0wLGU9QXJyYXkoci5sZW5ndGgpO3Q8ci5sZW5ndGg7dCsrKWVbdF09clt0XTtyZXR1cm4gZX1yZXR1cm4gQXJyYXkuZnJvbShyKX12YXIgXz17fSxiPXt9LE09e2JpdFJldmVyc2VBcnJheTpmdW5jdGlvbihyKXtpZih2b2lkIDA9PT1fW3JdKXtmb3IodmFyIHQ9KHItMSkudG9TdHJpbmcoMikubGVuZ3RoLGU9XCIwXCIucmVwZWF0KHQpLGE9e30sbj0wO248cjtuKyspe3ZhciBvPW4udG9TdHJpbmcoMik7bz1lLnN1YnN0cihvLmxlbmd0aCkrbyxvPVtdLmNvbmNhdChTKG8pKS5yZXZlcnNlKCkuam9pbihcIlwiKSxhW25dPXBhcnNlSW50KG8sMil9X1tyXT1hfXJldHVybiBfW3JdfSxtdWx0aXBseTpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCp0LnJlYWwtci5pbWFnKnQuaW1hZyxpbWFnOnIucmVhbCp0LmltYWcrci5pbWFnKnQucmVhbH19LGFkZDpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCt0LnJlYWwsaW1hZzpyLmltYWcrdC5pbWFnfX0sc3VidHJhY3Q6ZnVuY3Rpb24ocix0KXtyZXR1cm57cmVhbDpyLnJlYWwtdC5yZWFsLGltYWc6ci5pbWFnLXQuaW1hZ319LGV1bGVyOmZ1bmN0aW9uKHIsdCl7dmFyIGU9LTIqTWF0aC5QSSpyL3Q7cmV0dXJue3JlYWw6TWF0aC5jb3MoZSksaW1hZzpNYXRoLnNpbihlKX19LGNvbmo6ZnVuY3Rpb24ocil7cmV0dXJuIHIuaW1hZyo9LTEscn0sY29uc3RydWN0Q29tcGxleEFycmF5OmZ1bmN0aW9uKHIpe3ZhciB0PXt9O3QucmVhbD12b2lkIDA9PT1yLnJlYWw/ci5zbGljZSgpOnIucmVhbC5zbGljZSgpO3ZhciBlPXQucmVhbC5sZW5ndGg7cmV0dXJuIHZvaWQgMD09PWJbZV0mJihiW2VdPUFycmF5LmFwcGx5KG51bGwsQXJyYXkoZSkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsMCkpLHQuaW1hZz1iW2VdLnNsaWNlKCksdH19LEY9ZnVuY3Rpb24ocil7dmFyIHQ9e307dm9pZCAwPT09ci5yZWFsfHx2b2lkIDA9PT1yLmltYWc/dD1NLmNvbnN0cnVjdENvbXBsZXhBcnJheShyKToodC5yZWFsPXIucmVhbC5zbGljZSgpLHQuaW1hZz1yLmltYWcuc2xpY2UoKSk7dmFyIGU9dC5yZWFsLmxlbmd0aCxhPU1hdGgubG9nMihlKTtpZihNYXRoLnJvdW5kKGEpIT1hKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIuXCIpO2lmKHQucmVhbC5sZW5ndGghPXQuaW1hZy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cIik7Zm9yKHZhciBuPU0uYml0UmV2ZXJzZUFycmF5KGUpLG89e3JlYWw6W10saW1hZzpbXX0saT0wO2k8ZTtpKyspby5yZWFsW25baV1dPXQucmVhbFtpXSxvLmltYWdbbltpXV09dC5pbWFnW2ldO2Zvcih2YXIgdT0wO3U8ZTt1KyspdC5yZWFsW3VdPW8ucmVhbFt1XSx0LmltYWdbdV09by5pbWFnW3VdO2Zvcih2YXIgZj0xO2Y8PWE7ZisrKWZvcih2YXIgYz1NYXRoLnBvdygyLGYpLGw9MDtsPGMvMjtsKyspZm9yKHZhciBzPU0uZXVsZXIobCxjKSxtPTA7bTxlL2M7bSsrKXt2YXIgcD1jKm0rbCxoPWMqbStsK2MvMixnPXtyZWFsOnQucmVhbFtwXSxpbWFnOnQuaW1hZ1twXX0sdz17cmVhbDp0LnJlYWxbaF0saW1hZzp0LmltYWdbaF19LHY9TS5tdWx0aXBseShzLHcpLGQ9TS5zdWJ0cmFjdChnLHYpO3QucmVhbFtoXT1kLnJlYWwsdC5pbWFnW2hdPWQuaW1hZzt2YXIgeT1NLmFkZCh2LGcpO3QucmVhbFtwXT15LnJlYWwsdC5pbWFnW3BdPXkuaW1hZ31yZXR1cm4gdH0sQT1GLEU9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIsdCl7dmFyIGU9dGhpcztpZih0aGlzLl9tPXQsIXIuYXVkaW9Db250ZXh0KXRocm93IHRoaXMuX20uZXJyb3JzLm5vQUM7aWYoci5idWZmZXJTaXplJiYhYShyLmJ1ZmZlclNpemUpKXRocm93IHRoaXMuX20uX2Vycm9ycy5ub3RQb3cyO2lmKCFyLnNvdXJjZSl0aHJvdyB0aGlzLl9tLl9lcnJvcnMubm9Tb3VyY2U7dGhpcy5fbS5hdWRpb0NvbnRleHQ9ci5hdWRpb0NvbnRleHQsdGhpcy5fbS5idWZmZXJTaXplPXIuYnVmZmVyU2l6ZXx8dGhpcy5fbS5idWZmZXJTaXplfHwyNTYsdGhpcy5fbS5ob3BTaXplPXIuaG9wU2l6ZXx8dGhpcy5fbS5ob3BTaXplfHx0aGlzLl9tLmJ1ZmZlclNpemUsdGhpcy5fbS5zYW1wbGVSYXRlPXIuc2FtcGxlUmF0ZXx8dGhpcy5fbS5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZXx8NDQxMDAsdGhpcy5fbS5jYWxsYmFjaz1yLmNhbGxiYWNrLHRoaXMuX20ud2luZG93aW5nRnVuY3Rpb249ci53aW5kb3dpbmdGdW5jdGlvbnx8XCJoYW5uaW5nXCIsdGhpcy5fbS5mZWF0dXJlRXh0cmFjdG9ycz15LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPXIuc3RhcnRJbW1lZGlhdGVseXx8ITEsdGhpcy5fbS5jaGFubmVsPVwibnVtYmVyXCI9PXR5cGVvZiByLmNoYW5uZWw/ci5jaGFubmVsOjAsdGhpcy5fbS5pbnB1dHM9ci5pbnB1dHN8fDEsdGhpcy5fbS5vdXRwdXRzPXIub3V0cHV0c3x8MSx0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cz1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50c3x8dGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHN8fDEzLHRoaXMuX20ubnVtYmVyT2ZCYXJrQmFuZHM9ci5udW1iZXJPZkJhcmtCYW5kc3x8dGhpcy5fbS5udW1iZXJPZkJhcmtCYW5kc3x8MjQsdGhpcy5fbS5zcG49dGhpcy5fbS5hdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKHRoaXMuX20uYnVmZmVyU2l6ZSx0aGlzLl9tLmlucHV0cyx0aGlzLl9tLm91dHB1dHMpLHRoaXMuX20uc3BuLmNvbm5lY3QodGhpcy5fbS5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXIuZmVhdHVyZUV4dHJhY3RvcnN8fFtdLHRoaXMuX20uYmFya1NjYWxlPW8odGhpcy5fbS5idWZmZXJTaXplLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20ubWVsRmlsdGVyQmFuaz1mKE1hdGgubWF4KHRoaXMuX20ubWVsQmFuZHMsdGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20uaW5wdXREYXRhPW51bGwsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YT1udWxsLHRoaXMuX20uZnJhbWU9bnVsbCx0aGlzLl9tLnByZXZpb3VzRnJhbWU9bnVsbCx0aGlzLnNldFNvdXJjZShyLnNvdXJjZSksdGhpcy5fbS5zcG4ub25hdWRpb3Byb2Nlc3M9ZnVuY3Rpb24ocil7dmFyIHQ7bnVsbCE9PWUuX20uaW5wdXREYXRhJiYoZS5fbS5wcmV2aW91c0lucHV0RGF0YT1lLl9tLmlucHV0RGF0YSksZS5fbS5pbnB1dERhdGE9ci5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShlLl9tLmNoYW5uZWwpLGUuX20ucHJldmlvdXNJbnB1dERhdGE/KCh0PW5ldyBGbG9hdDMyQXJyYXkoZS5fbS5wcmV2aW91c0lucHV0RGF0YS5sZW5ndGgrZS5fbS5pbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpLnNldChlLl9tLnByZXZpb3VzSW5wdXREYXRhLnNsaWNlKGUuX20uaG9wU2l6ZSkpLHQuc2V0KGUuX20uaW5wdXREYXRhLGUuX20ucHJldmlvdXNJbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpOnQ9ZS5fbS5pbnB1dERhdGEsZnVuY3Rpb24ocix0LGUpe2lmKHIubGVuZ3RoPHQpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGlzIHRvbyBzaG9ydCBmb3IgZnJhbWUgbGVuZ3RoXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoXCJIb3AgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTtpZih0PDEpdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTt2YXIgYT0xK01hdGguZmxvb3IoKHIubGVuZ3RoLXQpL2UpO3JldHVybiBuZXcgQXJyYXkoYSkuZmlsbCgwKS5tYXAoKGZ1bmN0aW9uKGEsbil7cmV0dXJuIHIuc2xpY2UobiplLG4qZSt0KX0pKX0odCxlLl9tLmJ1ZmZlclNpemUsZS5fbS5ob3BTaXplKS5mb3JFYWNoKChmdW5jdGlvbihyKXtlLl9tLmZyYW1lPXI7dmFyIHQ9ZS5fbS5leHRyYWN0KGUuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LGUuX20uZnJhbWUsZS5fbS5wcmV2aW91c0ZyYW1lKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLl9tLmNhbGxiYWNrJiZlLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCYmZS5fbS5jYWxsYmFjayh0KSxlLl9tLnByZXZpb3VzRnJhbWU9ZS5fbS5mcmFtZX0pKX19cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHIpe3RoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXJ8fHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPSEwfSxyLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQ9ITF9LHIucHJvdG90eXBlLnNldFNvdXJjZT1mdW5jdGlvbihyKXt0aGlzLl9tLnNvdXJjZSYmdGhpcy5fbS5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLl9tLnNwbiksdGhpcy5fbS5zb3VyY2U9cix0aGlzLl9tLnNvdXJjZS5jb25uZWN0KHRoaXMuX20uc3BuKX0sci5wcm90b3R5cGUuc2V0Q2hhbm5lbD1mdW5jdGlvbihyKXtyPD10aGlzLl9tLmlucHV0cz90aGlzLl9tLmNoYW5uZWw9cjpjb25zb2xlLmVycm9yKFwiQ2hhbm5lbCBcIi5jb25jYXQocixcIiBkb2VzIG5vdCBleGlzdC4gTWFrZSBzdXJlIHlvdSd2ZSBwcm92aWRlZCBhIHZhbHVlIGZvciAnaW5wdXRzJyB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBcIikuY29uY2F0KHIsXCIgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBNZXlkYUFuYWx5emVyXCIpKX0sci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLl9tLmlucHV0RGF0YT90aGlzLl9tLmV4dHJhY3Qocnx8dGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsdGhpcy5fbS5pbnB1dERhdGEsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YSk6bnVsbH0scn0oKSxDPXthdWRpb0NvbnRleHQ6bnVsbCxzcG46bnVsbCxidWZmZXJTaXplOjUxMixzYW1wbGVSYXRlOjQ0MTAwLG1lbEJhbmRzOjI2LGNocm9tYUJhbmRzOjEyLGNhbGxiYWNrOm51bGwsd2luZG93aW5nRnVuY3Rpb246XCJoYW5uaW5nXCIsZmVhdHVyZUV4dHJhY3RvcnM6eSxFWFRSQUNUSU9OX1NUQVJURUQ6ITEsbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzOjEzLG51bWJlck9mQmFya0JhbmRzOjI0LF9mZWF0dXJlc1RvRXh0cmFjdDpbXSx3aW5kb3dpbmc6bixfZXJyb3JzOntub3RQb3cyOm5ldyBFcnJvcihcIk1leWRhOiBCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiwgZS5nLiA2NCBvciA1MTJcIiksZmVhdHVyZVVuZGVmOm5ldyBFcnJvcihcIk1leWRhOiBObyBmZWF0dXJlcyBkZWZpbmVkLlwiKSxpbnZhbGlkRmVhdHVyZUZtdDpuZXcgRXJyb3IoXCJNZXlkYTogSW52YWxpZCBmZWF0dXJlIGZvcm1hdFwiKSxpbnZhbGlkSW5wdXQ6bmV3IEVycm9yKFwiTWV5ZGE6IEludmFsaWQgaW5wdXQuXCIpLG5vQUM6bmV3IEVycm9yKFwiTWV5ZGE6IE5vIEF1ZGlvQ29udGV4dCBzcGVjaWZpZWQuXCIpLG5vU291cmNlOm5ldyBFcnJvcihcIk1leWRhOiBObyBzb3VyY2Ugbm9kZSBzcGVjaWZpZWQuXCIpfSxjcmVhdGVNZXlkYUFuYWx5emVyOmZ1bmN0aW9uKHIpe3JldHVybiBuZXcgRShyLE9iamVjdC5hc3NpZ24oe30sQykpfSxsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnM6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5mZWF0dXJlRXh0cmFjdG9ycyl9LGV4dHJhY3Q6ZnVuY3Rpb24ocix0LGUpe3ZhciBuPXRoaXM7aWYoIXQpdGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRJbnB1dDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyB0aGlzLl9lcnJvcnMuaW52YWxpZElucHV0O2lmKCFyKXRocm93IHRoaXMuX2Vycm9ycy5mZWF0dXJlVW5kZWY7aWYoIWEodC5sZW5ndGgpKXRocm93IHRoaXMuX2Vycm9ycy5ub3RQb3cyO3ZvaWQgMCE9PXRoaXMuYmFya1NjYWxlJiZ0aGlzLmJhcmtTY2FsZS5sZW5ndGg9PXRoaXMuYnVmZmVyU2l6ZXx8KHRoaXMuYmFya1NjYWxlPW8odGhpcy5idWZmZXJTaXplLHRoaXMuc2FtcGxlUmF0ZSx0aGlzLmJ1ZmZlclNpemUpKSx2b2lkIDAhPT10aGlzLm1lbEZpbHRlckJhbmsmJnRoaXMuYmFya1NjYWxlLmxlbmd0aD09dGhpcy5idWZmZXJTaXplJiZ0aGlzLm1lbEZpbHRlckJhbmsubGVuZ3RoPT10aGlzLm1lbEJhbmRzfHwodGhpcy5tZWxGaWx0ZXJCYW5rPWYoTWF0aC5tYXgodGhpcy5tZWxCYW5kcyx0aGlzLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyksdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLHZvaWQgMCE9PXRoaXMuY2hyb21hRmlsdGVyQmFuayYmdGhpcy5jaHJvbWFGaWx0ZXJCYW5rLmxlbmd0aD09dGhpcy5jaHJvbWFCYW5kc3x8KHRoaXMuY2hyb21hRmlsdGVyQmFuaz1jKHRoaXMuY2hyb21hQmFuZHMsdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLFwiYnVmZmVyXCJpbiB0JiZ2b2lkIDA9PT10LmJ1ZmZlcj90aGlzLnNpZ25hbD1pKHQpOnRoaXMuc2lnbmFsPXQ7dmFyIHU9ayh0LHRoaXMud2luZG93aW5nRnVuY3Rpb24sdGhpcy5idWZmZXJTaXplKTtpZih0aGlzLnNpZ25hbD11LndpbmRvd2VkU2lnbmFsLHRoaXMuY29tcGxleFNwZWN0cnVtPXUuY29tcGxleFNwZWN0cnVtLHRoaXMuYW1wU3BlY3RydW09dS5hbXBTcGVjdHJ1bSxlKXt2YXIgbD1rKGUsdGhpcy53aW5kb3dpbmdGdW5jdGlvbix0aGlzLmJ1ZmZlclNpemUpO3RoaXMucHJldmlvdXNTaWduYWw9bC53aW5kb3dlZFNpZ25hbCx0aGlzLnByZXZpb3VzQ29tcGxleFNwZWN0cnVtPWwuY29tcGxleFNwZWN0cnVtLHRoaXMucHJldmlvdXNBbXBTcGVjdHJ1bT1sLmFtcFNwZWN0cnVtfXZhciBzPWZ1bmN0aW9uKHIpe3JldHVybiBuLmZlYXR1cmVFeHRyYWN0b3JzW3JdKHthbXBTcGVjdHJ1bTpuLmFtcFNwZWN0cnVtLGNocm9tYUZpbHRlckJhbms6bi5jaHJvbWFGaWx0ZXJCYW5rLGNvbXBsZXhTcGVjdHJ1bTpuLmNvbXBsZXhTcGVjdHJ1bSxzaWduYWw6bi5zaWduYWwsYnVmZmVyU2l6ZTpuLmJ1ZmZlclNpemUsc2FtcGxlUmF0ZTpuLnNhbXBsZVJhdGUsYmFya1NjYWxlOm4uYmFya1NjYWxlLG1lbEZpbHRlckJhbms6bi5tZWxGaWx0ZXJCYW5rLHByZXZpb3VzU2lnbmFsOm4ucHJldmlvdXNTaWduYWwscHJldmlvdXNBbXBTcGVjdHJ1bTpuLnByZXZpb3VzQW1wU3BlY3RydW0scHJldmlvdXNDb21wbGV4U3BlY3RydW06bi5wcmV2aW91c0NvbXBsZXhTcGVjdHJ1bSxudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6bi5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMsbnVtYmVyT2ZCYXJrQmFuZHM6bi5udW1iZXJPZkJhcmtCYW5kc30pfTtpZihcIm9iamVjdFwiPT10eXBlb2YgcilyZXR1cm4gci5yZWR1Y2UoKGZ1bmN0aW9uKHIsdCl7dmFyIGU7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sciwoKGU9e30pW3RdPXModCksZSkpfSkse30pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByKXJldHVybiBzKHIpO3Rocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkRmVhdHVyZUZtdH19LGs9ZnVuY3Rpb24ocix0LGUpe3ZhciBhPXt9O3ZvaWQgMD09PXIuYnVmZmVyP2Euc2lnbmFsPWkocik6YS5zaWduYWw9cixhLndpbmRvd2VkU2lnbmFsPW4oYS5zaWduYWwsdCksYS5jb21wbGV4U3BlY3RydW09QShhLndpbmRvd2VkU2lnbmFsKSxhLmFtcFNwZWN0cnVtPW5ldyBGbG9hdDMyQXJyYXkoZS8yKTtmb3IodmFyIG89MDtvPGUvMjtvKyspYS5hbXBTcGVjdHJ1bVtvXT1NYXRoLnNxcnQoTWF0aC5wb3coYS5jb21wbGV4U3BlY3RydW0ucmVhbFtvXSwyKStNYXRoLnBvdyhhLmNvbXBsZXhTcGVjdHJ1bS5pbWFnW29dLDIpKTtyZXR1cm4gYX07cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5NZXlkYT1DKSxDfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV5ZGEubWluLmpzLm1hcFxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBub3cgPSByZXF1aXJlKCdyaWdodC1ub3cnKVxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpXG5cbm1vZHVsZS5leHBvcnRzID0gRW5naW5lXG5mdW5jdGlvbiBFbmdpbmUoZm4pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRW5naW5lKSkgXG4gICAgICAgIHJldHVybiBuZXcgRW5naW5lKGZuKVxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IDBcbiAgICB0aGlzLl90aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcylcblxuICAgIGlmIChmbilcbiAgICAgICAgdGhpcy5vbigndGljaycsIGZuKVxufVxuXG5pbmhlcml0cyhFbmdpbmUsIEV2ZW50RW1pdHRlcilcblxuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIFxuICAgICAgICByZXR1cm5cbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IHJhZih0aGlzLl90aWNrKVxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2ZyYW1lICE9PSAwKVxuICAgICAgICByYWYuY2FuY2VsKHRoaXMuX2ZyYW1lKVxuICAgIHRoaXMuX2ZyYW1lID0gMFxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZyYW1lID0gcmFmKHRoaXMuX3RpY2spXG4gICAgdmFyIHRpbWUgPSBub3coKVxuICAgIHZhciBkdCA9IHRpbWUgLSB0aGlzLmxhc3RcbiAgICB0aGlzLmVtaXQoJ3RpY2snLCBkdClcbiAgICB0aGlzLmxhc3QgPSB0aW1lXG59IiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbC5jcmVhdGVSRUdMID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIChcbiAgICB4IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgKVxufVxuXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGJhc2UsIG9wdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBiYXNlW2tleXNbaV1dID0gb3B0c1trZXlzW2ldXVxuICB9XG4gIHJldHVybiBiYXNlXG59XG5cbi8vIEVycm9yIGNoZWNraW5nIGFuZCBwYXJhbWV0ZXIgdmFsaWRhdGlvbi5cbi8vXG4vLyBTdGF0ZW1lbnRzIGZvciB0aGUgZm9ybSBgY2hlY2suc29tZVByb2NlZHVyZSguLi4pYCBnZXQgcmVtb3ZlZCBieVxuLy8gYSBicm93c2VyaWZ5IHRyYW5zZm9ybSBmb3Igb3B0aW1pemVkL21pbmlmaWVkIGJ1bmRsZXMuXG4vL1xuLyogZ2xvYmFscyBhdG9iICovXG52YXIgZW5kbCA9ICdcXG4nXG5cbi8vIG9ubHkgdXNlZCBmb3IgZXh0cmFjdGluZyBzaGFkZXIgbmFtZXMuICBpZiBhdG9iIG5vdCBwcmVzZW50LCB0aGVuIGVycm9yc1xuLy8gd2lsbCBiZSBzbGlnaHRseSBjcmFwcGllclxuZnVuY3Rpb24gZGVjb2RlQjY0IChzdHIpIHtcbiAgaWYgKHR5cGVvZiBhdG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhdG9iKHN0cilcbiAgfVxuICByZXR1cm4gJ2Jhc2U2NDonICsgc3RyXG59XG5cbmZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignKHJlZ2wpICcgKyBtZXNzYWdlKVxuICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB0aHJvdyBlcnJvclxufVxuXG5mdW5jdGlvbiBjaGVjayAocHJlZCwgbWVzc2FnZSkge1xuICBpZiAoIXByZWQpIHtcbiAgICByYWlzZShtZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29sb24gKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gJzogJyArIG1lc3NhZ2VcbiAgfVxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJhbWV0ZXIgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgcmFpc2UoJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICAgICAnLiBwb3NzaWJsZSB2YWx1ZXM6ICcgKyBPYmplY3Qua2V5cyhwb3NzaWJpbGl0aWVzKS5qb2luKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJc1R5cGVkQXJyYXkgKGRhdGEsIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gbXVzdCBiZSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZFR5cGVFaCAodmFsdWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCdcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVPZiAodmFsdWUsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9uTmVnYXRpdmVJbnQgKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghKCh2YWx1ZSA+PSAwKSAmJlxuICAgICAgICAoKHZhbHVlIHwgMCkgPT09IHZhbHVlKSkpIHtcbiAgICByYWlzZSgnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZSwgKCcgKyB2YWx1ZSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgICAgICcuIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja09uZU9mICh2YWx1ZSwgbGlzdCwgbWVzc2FnZSkge1xuICBpZiAobGlzdC5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICByYWlzZSgnaW52YWxpZCB2YWx1ZScgKyBlbmNvbG9uKG1lc3NhZ2UpICsgJy4gbXVzdCBiZSBvbmUgb2Y6ICcgKyBsaXN0KVxuICB9XG59XG5cbnZhciBjb25zdHJ1Y3RvcktleXMgPSBbXG4gICdnbCcsXG4gICdjYW52YXMnLFxuICAnY29udGFpbmVyJyxcbiAgJ2F0dHJpYnV0ZXMnLFxuICAncGl4ZWxSYXRpbycsXG4gICdleHRlbnNpb25zJyxcbiAgJ29wdGlvbmFsRXh0ZW5zaW9ucycsXG4gICdwcm9maWxlJyxcbiAgJ29uRG9uZSdcbl1cblxuZnVuY3Rpb24gY2hlY2tDb25zdHJ1Y3RvciAob2JqKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGNvbnN0cnVjdG9yS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICByYWlzZSgnaW52YWxpZCByZWdsIGNvbnN0cnVjdG9yIGFyZ3VtZW50IFwiJyArIGtleSArICdcIi4gbXVzdCBiZSBvbmUgb2YgJyArIGNvbnN0cnVjdG9yS2V5cylcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGxlZnRQYWQgKHN0ciwgbikge1xuICBzdHIgPSBzdHIgKyAnJ1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IG4pIHtcbiAgICBzdHIgPSAnICcgKyBzdHJcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIFNoYWRlckZpbGUgKCkge1xuICB0aGlzLm5hbWUgPSAndW5rbm93bidcbiAgdGhpcy5saW5lcyA9IFtdXG4gIHRoaXMuaW5kZXggPSB7fVxuICB0aGlzLmhhc0Vycm9ycyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIFNoYWRlckxpbmUgKG51bWJlciwgbGluZSkge1xuICB0aGlzLm51bWJlciA9IG51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lXG4gIHRoaXMuZXJyb3JzID0gW11cbn1cblxuZnVuY3Rpb24gU2hhZGVyRXJyb3IgKGZpbGVOdW1iZXIsIGxpbmVOdW1iZXIsIG1lc3NhZ2UpIHtcbiAgdGhpcy5maWxlID0gZmlsZU51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDb21tYW5kICgpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKClcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpXG4gIHZhciBwYXQgPSAvY29tcGlsZVByb2NlZHVyZS4qXFxuXFxzKmF0LipcXCgoLiopXFwpLy5leGVjKHN0YWNrKVxuICBpZiAocGF0KSB7XG4gICAgcmV0dXJuIHBhdFsxXVxuICB9XG4gIHZhciBwYXQyID0gL2NvbXBpbGVQcm9jZWR1cmUuKlxcblxccyphdFxccysoLiopKFxcbnwkKS8uZXhlYyhzdGFjaylcbiAgaWYgKHBhdDIpIHtcbiAgICByZXR1cm4gcGF0MlsxXVxuICB9XG4gIHJldHVybiAndW5rbm93bidcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDYWxsU2l0ZSAoKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcigpXG4gIHZhciBzdGFjayA9IChlcnJvci5zdGFjayB8fCBlcnJvcikudG9TdHJpbmcoKVxuICB2YXIgcGF0ID0gL2F0IFJFR0xDb21tYW5kLipcXG5cXHMrYXQuKlxcKCguKilcXCkvLmV4ZWMoc3RhY2spXG4gIGlmIChwYXQpIHtcbiAgICByZXR1cm4gcGF0WzFdXG4gIH1cbiAgdmFyIHBhdDIgPSAvYXQgUkVHTENvbW1hbmQuKlxcblxccythdFxccysoLiopXFxuLy5leGVjKHN0YWNrKVxuICBpZiAocGF0Mikge1xuICAgIHJldHVybiBwYXQyWzFdXG4gIH1cbiAgcmV0dXJuICd1bmtub3duJ1xufVxuXG5mdW5jdGlvbiBwYXJzZVNvdXJjZSAoc291cmNlLCBjb21tYW5kKSB7XG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJylcbiAgdmFyIGxpbmVOdW1iZXIgPSAxXG4gIHZhciBmaWxlTnVtYmVyID0gMFxuICB2YXIgZmlsZXMgPSB7XG4gICAgdW5rbm93bjogbmV3IFNoYWRlckZpbGUoKSxcbiAgICAwOiBuZXcgU2hhZGVyRmlsZSgpXG4gIH1cbiAgZmlsZXMudW5rbm93bi5uYW1lID0gZmlsZXNbMF0ubmFtZSA9IGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKClcbiAgZmlsZXMudW5rbm93bi5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKDAsICcnKSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV1cbiAgICB2YXIgcGFydHMgPSAvXlxccyojXFxzKihcXHcrKVxccysoLispXFxzKiQvLmV4ZWMobGluZSlcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHN3aXRjaCAocGFydHNbMV0pIHtcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFyIGxpbmVOdW1iZXJJbmZvID0gLyhcXGQrKShcXHMrXFxkKyk/Ly5leGVjKHBhcnRzWzJdKVxuICAgICAgICAgIGlmIChsaW5lTnVtYmVySW5mbykge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IGxpbmVOdW1iZXJJbmZvWzFdIHwgMFxuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJJbmZvWzJdKSB7XG4gICAgICAgICAgICAgIGZpbGVOdW1iZXIgPSBsaW5lTnVtYmVySW5mb1syXSB8IDBcbiAgICAgICAgICAgICAgaWYgKCEoZmlsZU51bWJlciBpbiBmaWxlcykpIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXSA9IG5ldyBTaGFkZXJGaWxlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdkZWZpbmUnOlxuICAgICAgICAgIHZhciBuYW1lSW5mbyA9IC9TSEFERVJfTkFNRShfQjY0KT9cXHMrKC4qKSQvLmV4ZWMocGFydHNbMl0pXG4gICAgICAgICAgaWYgKG5hbWVJbmZvKSB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXS5uYW1lID0gKG5hbWVJbmZvWzFdXG4gICAgICAgICAgICAgID8gZGVjb2RlQjY0KG5hbWVJbmZvWzJdKVxuICAgICAgICAgICAgICA6IG5hbWVJbmZvWzJdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxlc1tmaWxlTnVtYmVyXS5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKGxpbmVOdW1iZXIrKywgbGluZSkpXG4gIH1cbiAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOdW1iZXIpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgZmlsZS5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBmaWxlLmluZGV4W2xpbmUubnVtYmVyXSA9IGxpbmVcbiAgICB9KVxuICB9KVxuICByZXR1cm4gZmlsZXNcbn1cblxuZnVuY3Rpb24gcGFyc2VFcnJvckxvZyAoZXJyTG9nKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBlcnJMb2cuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGVyck1zZykge1xuICAgIGlmIChlcnJNc2cubGVuZ3RoIDwgNSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IC9eRVJST1I6XFxzKyhcXGQrKTooXFxkKyk6XFxzKiguKikkLy5leGVjKGVyck1zZylcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBTaGFkZXJFcnJvcihcbiAgICAgICAgcGFydHNbMV0gfCAwLFxuICAgICAgICBwYXJ0c1syXSB8IDAsXG4gICAgICAgIHBhcnRzWzNdLnRyaW0oKSkpXG4gICAgfSBlbHNlIGlmIChlcnJNc2cubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IFNoYWRlckVycm9yKCd1bmtub3duJywgMCwgZXJyTXNnKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gYW5ub3RhdGVGaWxlcyAoZmlsZXMsIGVycm9ycykge1xuICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2Vycm9yLmZpbGVdXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHZhciBsaW5lID0gZmlsZS5pbmRleFtlcnJvci5saW5lXVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgbGluZS5lcnJvcnMucHVzaChlcnJvcilcbiAgICAgICAgZmlsZS5oYXNFcnJvcnMgPSB0cnVlXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBmaWxlcy51bmtub3duLmhhc0Vycm9ycyA9IHRydWVcbiAgICBmaWxlcy51bmtub3duLmxpbmVzWzBdLmVycm9ycy5wdXNoKGVycm9yKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1NoYWRlckVycm9yIChnbCwgc2hhZGVyLCBzb3VyY2UsIHR5cGUsIGNvbW1hbmQpIHtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgdmFyIHR5cGVOYW1lID0gdHlwZSA9PT0gZ2wuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnXG4gICAgY2hlY2tDb21tYW5kVHlwZShzb3VyY2UsICdzdHJpbmcnLCB0eXBlTmFtZSArICcgc2hhZGVyIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJywgY29tbWFuZClcbiAgICB2YXIgZmlsZXMgPSBwYXJzZVNvdXJjZShzb3VyY2UsIGNvbW1hbmQpXG4gICAgdmFyIGVycm9ycyA9IHBhcnNlRXJyb3JMb2coZXJyTG9nKVxuICAgIGFubm90YXRlRmlsZXMoZmlsZXMsIGVycm9ycylcblxuICAgIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlTnVtYmVyKSB7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgICBpZiAoIWZpbGUuaGFzRXJyb3JzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5ncyA9IFsnJ11cbiAgICAgIHZhciBzdHlsZXMgPSBbJyddXG5cbiAgICAgIGZ1bmN0aW9uIHB1c2ggKHN0ciwgc3R5bGUpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHN0cilcbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUgfHwgJycpXG4gICAgICB9XG5cbiAgICAgIHB1c2goJ2ZpbGUgbnVtYmVyICcgKyBmaWxlTnVtYmVyICsgJzogJyArIGZpbGUubmFtZSArICdcXG4nLCAnY29sb3I6cmVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Zm9udC13ZWlnaHQ6Ym9sZCcpXG5cbiAgICAgIGZpbGUubGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHB1c2gobGVmdFBhZChsaW5lLm51bWJlciwgNCkgKyAnfCAgJywgJ2JhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICBwdXNoKGxpbmUubGluZSArIGVuZGwsICdjb2xvcjpyZWQ7IGJhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcblxuICAgICAgICAgIC8vIHRyeSB0byBndWVzcyB0b2tlblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwXG4gICAgICAgICAgbGluZS5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgdmFyIHRva2VuID0gL15cXHMqJyguKiknXFxzKjpcXHMqKC4qKSQvLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICB2YXIgdG9rZW5QYXQgPSB0b2tlblsxXVxuICAgICAgICAgICAgICBtZXNzYWdlID0gdG9rZW5bMl1cbiAgICAgICAgICAgICAgc3dpdGNoICh0b2tlblBhdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Fzc2lnbic6XG4gICAgICAgICAgICAgICAgICB0b2tlblBhdCA9ICc9J1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lLmxpbmUuaW5kZXhPZih0b2tlblBhdCwgb2Zmc2V0KSwgMClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpKVxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCdeXl4nLCBvZmZzZXQgKyAzKSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSlcbiAgICAgICAgICAgIHB1c2gobWVzc2FnZSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSArIGVuZGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaChsZWZ0UGFkKGxpbmUubnVtYmVyLCA0KSArICd8ICAnKVxuICAgICAgICAgIHB1c2gobGluZS5saW5lICsgZW5kbCwgJ2NvbG9yOnJlZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmNocm9tZSkge1xuICAgICAgICBzdHlsZXNbMF0gPSBzdHJpbmdzLmpvaW4oJyVjJylcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgc3R5bGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyaW5ncy5qb2luKCcnKSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY2hlY2sucmFpc2UoJ0Vycm9yIGNvbXBpbGluZyAnICsgdHlwZU5hbWUgKyAnIHNoYWRlciwgJyArIGZpbGVzWzBdLm5hbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tMaW5rRXJyb3IgKGdsLCBwcm9ncmFtLCBmcmFnU2hhZGVyLCB2ZXJ0U2hhZGVyLCBjb21tYW5kKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICB2YXIgZnJhZ1BhcnNlID0gcGFyc2VTb3VyY2UoZnJhZ1NoYWRlciwgY29tbWFuZClcbiAgICB2YXIgdmVydFBhcnNlID0gcGFyc2VTb3VyY2UodmVydFNoYWRlciwgY29tbWFuZClcblxuICAgIHZhciBoZWFkZXIgPSAnRXJyb3IgbGlua2luZyBwcm9ncmFtIHdpdGggdmVydGV4IHNoYWRlciwgXCInICtcbiAgICAgIHZlcnRQYXJzZVswXS5uYW1lICsgJ1wiLCBhbmQgZnJhZ21lbnQgc2hhZGVyIFwiJyArIGZyYWdQYXJzZVswXS5uYW1lICsgJ1wiJ1xuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclYycgKyBoZWFkZXIgKyBlbmRsICsgJyVjJyArIGVyckxvZyxcbiAgICAgICAgJ2NvbG9yOnJlZDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2ZvbnQtd2VpZ2h0OmJvbGQnLFxuICAgICAgICAnY29sb3I6cmVkJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coaGVhZGVyICsgZW5kbCArIGVyckxvZylcbiAgICB9XG4gICAgY2hlY2sucmFpc2UoaGVhZGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVDb21tYW5kUmVmIChvYmplY3QpIHtcbiAgb2JqZWN0Ll9jb21tYW5kUmVmID0gZ3Vlc3NDb21tYW5kKClcbn1cblxuZnVuY3Rpb24gc2F2ZURyYXdDb21tYW5kSW5mbyAob3B0cywgdW5pZm9ybXMsIGF0dHJpYnV0ZXMsIHN0cmluZ1N0b3JlKSB7XG4gIHNhdmVDb21tYW5kUmVmKG9wdHMpXG5cbiAgZnVuY3Rpb24gaWQgKHN0cikge1xuICAgIGlmIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHJpbmdTdG9yZS5pZChzdHIpXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbiAgb3B0cy5fZnJhZ0lkID0gaWQob3B0cy5zdGF0aWMuZnJhZylcbiAgb3B0cy5fdmVydElkID0gaWQob3B0cy5zdGF0aWMudmVydClcblxuICBmdW5jdGlvbiBhZGRQcm9wcyAoZGljdCwgc2V0KSB7XG4gICAgT2JqZWN0LmtleXMoc2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh1KSB7XG4gICAgICBkaWN0W3N0cmluZ1N0b3JlLmlkKHUpXSA9IHRydWVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXQgPSBvcHRzLl91bmlmb3JtU2V0ID0ge31cbiAgYWRkUHJvcHModW5pZm9ybVNldCwgdW5pZm9ybXMuc3RhdGljKVxuICBhZGRQcm9wcyh1bmlmb3JtU2V0LCB1bmlmb3Jtcy5keW5hbWljKVxuXG4gIHZhciBhdHRyaWJ1dGVTZXQgPSBvcHRzLl9hdHRyaWJ1dGVTZXQgPSB7fVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuc3RhdGljKVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuZHluYW1pYylcblxuICBvcHRzLl9oYXNDb3VudCA9IChcbiAgICAnY291bnQnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2NvdW50JyBpbiBvcHRzLmR5bmFtaWMgfHxcbiAgICAnZWxlbWVudHMnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2VsZW1lbnRzJyBpbiBvcHRzLmR5bmFtaWMpXG59XG5cbmZ1bmN0aW9uIGNvbW1hbmRSYWlzZSAobWVzc2FnZSwgY29tbWFuZCkge1xuICB2YXIgY2FsbFNpdGUgPSBndWVzc0NhbGxTaXRlKClcbiAgcmFpc2UobWVzc2FnZSArXG4gICAgJyBpbiBjb21tYW5kICcgKyAoY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSkgK1xuICAgIChjYWxsU2l0ZSA9PT0gJ3Vua25vd24nID8gJycgOiAnIGNhbGxlZCBmcm9tICcgKyBjYWxsU2l0ZSkpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29tbWFuZCAocHJlZCwgbWVzc2FnZSwgY29tbWFuZCkge1xuICBpZiAoIXByZWQpIHtcbiAgICBjb21tYW5kUmFpc2UobWVzc2FnZSwgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlckNvbW1hbmQgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlLCBjb21tYW5kKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgY29tbWFuZFJhaXNlKFxuICAgICAgJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIHBvc3NpYmxlIHZhbHVlczogJyArIE9iamVjdC5rZXlzKHBvc3NpYmlsaXRpZXMpLmpvaW4oKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tDb21tYW5kVHlwZSAodmFsdWUsIHR5cGUsIG1lc3NhZ2UsIGNvbW1hbmQpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICBjb21tYW5kUmFpc2UoXG4gICAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIGV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyAodHlwZW9mIHZhbHVlKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25hbCAoYmxvY2spIHtcbiAgYmxvY2soKVxufVxuXG5mdW5jdGlvbiBjaGVja0ZyYW1lYnVmZmVyRm9ybWF0IChhdHRhY2htZW50LCB0ZXhGb3JtYXRzLCByYkZvcm1hdHMpIHtcbiAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgIGNoZWNrT25lT2YoXG4gICAgICBhdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICB0ZXhGb3JtYXRzLFxuICAgICAgJ3Vuc3VwcG9ydGVkIHRleHR1cmUgZm9ybWF0IGZvciBhdHRhY2htZW50JylcbiAgfSBlbHNlIHtcbiAgICBjaGVja09uZU9mKFxuICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQsXG4gICAgICByYkZvcm1hdHMsXG4gICAgICAndW5zdXBwb3J0ZWQgcmVuZGVyYnVmZmVyIGZvcm1hdCBmb3IgYXR0YWNobWVudCcpXG4gIH1cbn1cblxudmFyIEdMX0NMQU1QX1RPX0VER0UgPSAweDgxMkZcblxudmFyIEdMX05FQVJFU1QgPSAweDI2MDBcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUID0gMHgyNzAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDNcblxudmFyIEdMX0JZVEUgPSA1MTIwXG52YXIgR0xfVU5TSUdORURfQllURSA9IDUxMjFcbnZhciBHTF9TSE9SVCA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCA9IDUxMjNcbnZhciBHTF9JTlQgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UID0gNTEyNVxudmFyIEdMX0ZMT0FUID0gNTEyNlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCA9IDB4ODAzM1xudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgPSAweDgwMzRcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMID0gMHg4NEZBXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MVxuXG52YXIgVFlQRV9TSVpFID0ge31cblxuVFlQRV9TSVpFW0dMX0JZVEVdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9CWVRFXSA9IDFcblxuVFlQRV9TSVpFW0dMX1NIT1JUXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRdID1cblRZUEVfU0laRVtHTF9IQUxGX0ZMT0FUX09FU10gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNl81XSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzFdID0gMlxuXG5UWVBFX1NJWkVbR0xfSU5UXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfSU5UXSA9XG5UWVBFX1NJWkVbR0xfRkxPQVRdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTF0gPSA0XG5cbmZ1bmN0aW9uIHBpeGVsU2l6ZSAodHlwZSwgY2hhbm5lbHMpIHtcbiAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81KSB7XG4gICAgcmV0dXJuIDJcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCkge1xuICAgIHJldHVybiA0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRZUEVfU0laRVt0eXBlXSAqIGNoYW5uZWxzXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQb3cyICh2KSB7XG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxufVxuXG5mdW5jdGlvbiBjaGVja1RleHR1cmUyRCAoaW5mbywgbWlwRGF0YSwgbGltaXRzKSB7XG4gIHZhciBpXG4gIHZhciB3ID0gbWlwRGF0YS53aWR0aFxuICB2YXIgaCA9IG1pcERhdGEuaGVpZ2h0XG4gIHZhciBjID0gbWlwRGF0YS5jaGFubmVsc1xuXG4gIC8vIENoZWNrIHRleHR1cmUgc2hhcGVcbiAgY2hlY2sodyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiZcbiAgICAgICAgaCA+IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsXG4gICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuXG4gIC8vIGNoZWNrIHdyYXAgbW9kZVxuICBpZiAoaW5mby53cmFwUyAhPT0gR0xfQ0xBTVBfVE9fRURHRSB8fCBpbmZvLndyYXBUICE9PSBHTF9DTEFNUF9UT19FREdFKSB7XG4gICAgY2hlY2soaXNQb3cyKHcpICYmIGlzUG93MihoKSxcbiAgICAgICdpbmNvbXBhdGlibGUgd3JhcCBtb2RlIGZvciB0ZXh0dXJlLCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBwb3dlciBvZiAyJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLm1pcG1hc2sgPT09IDEpIHtcbiAgICBpZiAodyAhPT0gMSAmJiBoICE9PSAxKSB7XG4gICAgICBjaGVjayhcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QgJiZcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiAmJlxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTElORUFSX01JUE1BUF9ORUFSRVNUICYmXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUixcbiAgICAgICAgJ21pbiBmaWx0ZXIgcmVxdWlyZXMgbWlwbWFwJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGV4dHVyZSBtdXN0IGJlIHBvd2VyIG9mIDJcbiAgICBjaGVjayhpc1BvdzIodykgJiYgaXNQb3cyKGgpLFxuICAgICAgJ3RleHR1cmUgbXVzdCBiZSBhIHNxdWFyZSBwb3dlciBvZiAyIHRvIHN1cHBvcnQgbWlwbWFwcGluZycpXG4gICAgY2hlY2sobWlwRGF0YS5taXBtYXNrID09PSAodyA8PCAxKSAtIDEsXG4gICAgICAnbWlzc2luZyBvciBpbmNvbXBsZXRlIG1pcG1hcCBkYXRhJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLnR5cGUgPT09IEdMX0ZMT0FUKSB7XG4gICAgaWYgKGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YoJ29lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpIDwgMCkge1xuICAgICAgY2hlY2soaW5mby5taW5GaWx0ZXIgPT09IEdMX05FQVJFU1QgJiYgaW5mby5tYWdGaWx0ZXIgPT09IEdMX05FQVJFU1QsXG4gICAgICAgICdmaWx0ZXIgbm90IHN1cHBvcnRlZCwgbXVzdCBlbmFibGUgb2VzX3RleHR1cmVfZmxvYXRfbGluZWFyJylcbiAgICB9XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIHdpdGggZmxvYXQgdGV4dHVyZXMnKVxuICB9XG5cbiAgLy8gY2hlY2sgaW1hZ2UgY29tcGxldGVcbiAgdmFyIG1pcGltYWdlcyA9IG1pcERhdGEuaW1hZ2VzXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgaWYgKG1pcGltYWdlc1tpXSkge1xuICAgICAgdmFyIG13ID0gdyA+PiBpXG4gICAgICB2YXIgbWggPSBoID4+IGlcbiAgICAgIGNoZWNrKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG5cbiAgICAgIHZhciBpbWcgPSBtaXBpbWFnZXNbaV1cblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgaW1nLmhlaWdodCA9PT0gbWgsXG4gICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBtaXAgaW1hZ2VzJylcblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy5mb3JtYXQgPT09IG1pcERhdGEuZm9ybWF0ICYmXG4gICAgICAgIGltZy5pbnRlcm5hbGZvcm1hdCA9PT0gbWlwRGF0YS5pbnRlcm5hbGZvcm1hdCAmJlxuICAgICAgICBpbWcudHlwZSA9PT0gbWlwRGF0YS50eXBlLFxuICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgIGlmIChpbWcuY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBzaXplIGZvciBjb21wcmVzc2VkIGltYWdlc1xuICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAvLyBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSBtdyAqIG1oICpcbiAgICAgICAgLy8gTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgIHZhciByb3dTaXplID0gTWF0aC5jZWlsKHBpeGVsU2l6ZShpbWcudHlwZSwgYykgKiBtdyAvIGltZy51bnBhY2tBbGlnbm1lbnQpICogaW1nLnVucGFja0FsaWdubWVudFxuICAgICAgICBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSByb3dTaXplICogbWgsXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICB9IGVsc2UgaWYgKGltZy5lbGVtZW50KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGVsZW1lbnQgY2FuIGJlIGxvYWRlZFxuICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBjb21wYXRpYmxlIGZvcm1hdCBhbmQgdHlwZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgY2hlY2soKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpKSA9PT0gMCwgJ2V4dHJhIG1pcG1hcCBkYXRhJylcbiAgICB9XG4gIH1cblxuICBpZiAobWlwRGF0YS5jb21wcmVzc2VkKSB7XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBmb3IgY29tcHJlc3NlZCBpbWFnZXMgbm90IHN1cHBvcnRlZCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tUZXh0dXJlQ3ViZSAodGV4dHVyZSwgaW5mbywgZmFjZXMsIGxpbWl0cykge1xuICB2YXIgdyA9IHRleHR1cmUud2lkdGhcbiAgdmFyIGggPSB0ZXh0dXJlLmhlaWdodFxuICB2YXIgYyA9IHRleHR1cmUuY2hhbm5lbHNcblxuICAvLyBDaGVjayB0ZXh0dXJlIHNoYXBlXG4gIGNoZWNrKFxuICAgIHcgPiAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplICYmIGggPiAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLFxuICAgICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICBjaGVjayhcbiAgICB3ID09PSBoLFxuICAgICdjdWJlIG1hcCBtdXN0IGJlIHNxdWFyZScpXG4gIGNoZWNrKFxuICAgIGluZm8ud3JhcFMgPT09IEdMX0NMQU1QX1RPX0VER0UgJiYgaW5mby53cmFwVCA9PT0gR0xfQ0xBTVBfVE9fRURHRSxcbiAgICAnd3JhcCBtb2RlIG5vdCBzdXBwb3J0ZWQgYnkgY3ViZSBtYXAnKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZmFjZSA9IGZhY2VzW2ldXG4gICAgY2hlY2soXG4gICAgICBmYWNlLndpZHRoID09PSB3ICYmIGZhY2UuaGVpZ2h0ID09PSBoLFxuICAgICAgJ2luY29uc2lzdGVudCBjdWJlIG1hcCBmYWNlIHNoYXBlJylcblxuICAgIGlmIChpbmZvLmdlbk1pcG1hcHMpIHtcbiAgICAgIGNoZWNrKCFmYWNlLmNvbXByZXNzZWQsXG4gICAgICAgICdjYW4gbm90IGdlbmVyYXRlIG1pcG1hcCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcycpXG4gICAgICBjaGVjayhmYWNlLm1pcG1hc2sgPT09IDEsXG4gICAgICAgICdjYW4gbm90IHNwZWNpZnkgbWlwbWFwcyBhbmQgZ2VuZXJhdGUgbWlwbWFwcycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIG1pcCBhbmQgZmlsdGVyIG1vZGVcbiAgICB9XG5cbiAgICB2YXIgbWlwbWFwcyA9IGZhY2UuaW1hZ2VzXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB2YXIgaW1nID0gbWlwbWFwc1tqXVxuICAgICAgaWYgKGltZykge1xuICAgICAgICB2YXIgbXcgPSB3ID4+IGpcbiAgICAgICAgdmFyIG1oID0gaCA+PiBqXG4gICAgICAgIGNoZWNrKGZhY2UubWlwbWFzayAmICgxIDw8IGopLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgICBpbWcuaGVpZ2h0ID09PSBtaCxcbiAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgbWlwIGltYWdlcycpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy5mb3JtYXQgPT09IHRleHR1cmUuZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLmludGVybmFsZm9ybWF0ID09PSB0ZXh0dXJlLmludGVybmFsZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLnR5cGUgPT09IHRleHR1cmUudHlwZSxcbiAgICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgICAgaWYgKGltZy5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgc2l6ZSBmb3IgY29tcHJlc3NlZCBpbWFnZXNcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAgIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IG13ICogbWggKlxuICAgICAgICAgICAgTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICAgIH0gZWxzZSBpZiAoaW1nLmVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBlbGVtZW50IGNhbiBiZSBsb2FkZWRcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGNvbXBhdGlibGUgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNoZWNrJDEgPSBleHRlbmQoY2hlY2ssIHtcbiAgb3B0aW9uYWw6IGNoZWNrT3B0aW9uYWwsXG4gIHJhaXNlOiByYWlzZSxcbiAgY29tbWFuZFJhaXNlOiBjb21tYW5kUmFpc2UsXG4gIGNvbW1hbmQ6IGNoZWNrQ29tbWFuZCxcbiAgcGFyYW1ldGVyOiBjaGVja1BhcmFtZXRlcixcbiAgY29tbWFuZFBhcmFtZXRlcjogY2hlY2tQYXJhbWV0ZXJDb21tYW5kLFxuICBjb25zdHJ1Y3RvcjogY2hlY2tDb25zdHJ1Y3RvcixcbiAgdHlwZTogY2hlY2tUeXBlT2YsXG4gIGNvbW1hbmRUeXBlOiBjaGVja0NvbW1hbmRUeXBlLFxuICBpc1R5cGVkQXJyYXk6IGNoZWNrSXNUeXBlZEFycmF5LFxuICBubmk6IGNoZWNrTm9uTmVnYXRpdmVJbnQsXG4gIG9uZU9mOiBjaGVja09uZU9mLFxuICBzaGFkZXJFcnJvcjogY2hlY2tTaGFkZXJFcnJvcixcbiAgbGlua0Vycm9yOiBjaGVja0xpbmtFcnJvcixcbiAgY2FsbFNpdGU6IGd1ZXNzQ2FsbFNpdGUsXG4gIHNhdmVDb21tYW5kUmVmOiBzYXZlQ29tbWFuZFJlZixcbiAgc2F2ZURyYXdJbmZvOiBzYXZlRHJhd0NvbW1hbmRJbmZvLFxuICBmcmFtZWJ1ZmZlckZvcm1hdDogY2hlY2tGcmFtZWJ1ZmZlckZvcm1hdCxcbiAgZ3Vlc3NDb21tYW5kOiBndWVzc0NvbW1hbmQsXG4gIHRleHR1cmUyRDogY2hlY2tUZXh0dXJlMkQsXG4gIHRleHR1cmVDdWJlOiBjaGVja1RleHR1cmVDdWJlXG59KTtcblxudmFyIFZBUklBQkxFX0NPVU5URVIgPSAwXG5cbnZhciBEWU5fRlVOQyA9IDBcbnZhciBEWU5fQ09OU1RBTlQgPSA1XG52YXIgRFlOX0FSUkFZID0gNlxuXG5mdW5jdGlvbiBEeW5hbWljVmFyaWFibGUgKHR5cGUsIGRhdGEpIHtcbiAgdGhpcy5pZCA9IChWQVJJQUJMRV9DT1VOVEVSKyspXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5kYXRhID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHIgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG59XG5cbmZ1bmN0aW9uIHNwbGl0UGFydHMgKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoMClcbiAgdmFyIGxhc3RDaGFyID0gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSlcblxuICBpZiAoc3RyLmxlbmd0aCA+IDEgJiZcbiAgICAgIGZpcnN0Q2hhciA9PT0gbGFzdENoYXIgJiZcbiAgICAgIChmaXJzdENoYXIgPT09ICdcIicgfHwgZmlyc3RDaGFyID09PSBcIidcIikpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMikpICsgJ1wiJ11cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IC9cXFsoZmFsc2V8dHJ1ZXxudWxsfFxcZCt8J1teJ10qJ3xcIlteXCJdKlwiKVxcXS8uZXhlYyhzdHIpXG4gIGlmIChwYXJ0cykge1xuICAgIHJldHVybiAoXG4gICAgICBzcGxpdFBhcnRzKHN0ci5zdWJzdHIoMCwgcGFydHMuaW5kZXgpKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMocGFydHNbMV0pKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMoc3RyLnN1YnN0cihwYXJ0cy5pbmRleCArIHBhcnRzWzBdLmxlbmd0aCkpKVxuICAgIClcbiAgfVxuXG4gIHZhciBzdWJwYXJ0cyA9IHN0ci5zcGxpdCgnLicpXG4gIGlmIChzdWJwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyKSArICdcIiddXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoc3BsaXRQYXJ0cyhzdWJwYXJ0c1tpXSkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b0FjY2Vzc29yU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuICdbJyArIHNwbGl0UGFydHMoc3RyKS5qb2luKCddWycpICsgJ10nXG59XG5cbmZ1bmN0aW9uIGRlZmluZUR5bmFtaWMgKHR5cGUsIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUodHlwZSwgdG9BY2Nlc3NvclN0cmluZyhkYXRhICsgJycpKVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWMgKHgpIHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiAheC5fcmVnbFR5cGUpIHx8ICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKVxufVxuXG5mdW5jdGlvbiB1bmJveCAoeCwgcGF0aCkge1xuICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZShEWU5fRlVOQywgeClcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHggPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1ZhcmlhYmxlKERZTl9DT05TVEFOVCwgeClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoRFlOX0FSUkFZLCB4Lm1hcCgoeSwgaSkgPT4gdW5ib3goeSwgcGF0aCArICdbJyArIGkgKyAnXScpKSlcbiAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBvcHRpb24gdHlwZSBpbiB1bmlmb3JtICcgKyBwYXRoKVxufVxuXG52YXIgZHluYW1pYyA9IHtcbiAgRHluYW1pY1ZhcmlhYmxlOiBEeW5hbWljVmFyaWFibGUsXG4gIGRlZmluZTogZGVmaW5lRHluYW1pYyxcbiAgaXNEeW5hbWljOiBpc0R5bmFtaWMsXG4gIHVuYm94OiB1bmJveCxcbiAgYWNjZXNzb3I6IHRvQWNjZXNzb3JTdHJpbmdcbn07XG5cbi8qIGdsb2JhbHMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xudmFyIHJhZiA9IHtcbiAgbmV4dDogdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGNiKSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIH1cbiAgICA6IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gc2V0VGltZW91dChjYiwgMTYpIH0sXG4gIGNhbmNlbDogdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAocmFmKSB7IHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpIH1cbiAgICA6IGNsZWFyVGltZW91dFxufTtcblxuLyogZ2xvYmFscyBwZXJmb3JtYW5jZSAqL1xudmFyIGNsb2NrID0gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KVxuICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgfVxuICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKSB9O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdTdG9yZSAoKSB7XG4gIHZhciBzdHJpbmdJZHMgPSB7ICcnOiAwIH1cbiAgdmFyIHN0cmluZ1ZhbHVlcyA9IFsnJ11cbiAgcmV0dXJuIHtcbiAgICBpZDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdID0gc3RyaW5nVmFsdWVzLmxlbmd0aFxuICAgICAgc3RyaW5nVmFsdWVzLnB1c2goc3RyKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG5cbiAgICBzdHI6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlc1tpZF1cbiAgICB9XG4gIH1cbn1cblxuLy8gQ29udGV4dCBhbmQgY2FudmFzIGNyZWF0aW9uIGhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyAoZWxlbWVudCwgb25Eb25lLCBwaXhlbFJhdGlvKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBleHRlbmQoY2FudmFzLnN0eWxlLCB7XG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGV4dGVuZChlbGVtZW50LnN0eWxlLCB7XG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZSAoKSB7XG4gICAgdmFyIHcgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBoID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB3ID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnRcbiAgICAgIGggPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcFxuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaFxuICAgIGV4dGVuZChjYW52YXMuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiB3ICsgJ3B4JyxcbiAgICAgIGhlaWdodDogaCArICdweCdcbiAgICB9KVxuICB9XG5cbiAgdmFyIHJlc2l6ZU9ic2VydmVyXG4gIGlmIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGlnbm9yZSAnUmVzaXplT2JzZXJ2ZXInIGlzIG5vdCBkZWZpbmVkXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc2V0VGltZW91dCB0byBhdm9pZCBmbGlja2VyXG4gICAgICBzZXRUaW1lb3V0KHJlc2l6ZSlcbiAgICB9KVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRGVzdHJveSAoKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSlcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMpXG4gIH1cblxuICByZXNpemUoKVxuXG4gIHJldHVybiB7XG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgb25EZXN0cm95OiBvbkRlc3Ryb3lcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0IChjYW52YXMsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XG4gIGZ1bmN0aW9uIGdldCAobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQobmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICBnZXQoJ3dlYmdsJykgfHxcbiAgICBnZXQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpIHx8XG4gICAgZ2V0KCd3ZWJnbC1leHBlcmltZW50YWwnKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIG9iai5hcHBlbmRDaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gaXNXZWJHTENvbnRleHQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmouZHJhd0FycmF5cyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBvYmouZHJhd0VsZW1lbnRzID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdCgpXG4gIH1cbiAgY2hlY2skMShBcnJheS5pc0FycmF5KGlucHV0KSwgJ2ludmFsaWQgZXh0ZW5zaW9uIGFycmF5JylcbiAgcmV0dXJuIGlucHV0XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnQgKGRlc2MpIHtcbiAgaWYgKHR5cGVvZiBkZXNjID09PSAnc3RyaW5nJykge1xuICAgIGNoZWNrJDEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJywgJ25vdCBzdXBwb3J0ZWQgb3V0c2lkZSBvZiBET00nKVxuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRlc2MpXG4gIH1cbiAgcmV0dXJuIGRlc2Ncbn1cblxuZnVuY3Rpb24gcGFyc2VBcmdzIChhcmdzXykge1xuICB2YXIgYXJncyA9IGFyZ3NfIHx8IHt9XG4gIHZhciBlbGVtZW50LCBjb250YWluZXIsIGNhbnZhcywgZ2xcbiAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0ge31cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXVxuICB2YXIgb3B0aW9uYWxFeHRlbnNpb25zID0gW11cbiAgdmFyIHBpeGVsUmF0aW8gPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gIHZhciBwcm9maWxlID0gZmFsc2VcbiAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKGVycilcbiAgICB9XG4gIH1cbiAgdmFyIG9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICdzZWxlY3RvciBxdWVyaWVzIG9ubHkgc3VwcG9ydGVkIGluIERPTSBlbnZpcm9tZW50cycpXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJncylcbiAgICBjaGVjayQxKGVsZW1lbnQsICdpbnZhbGlkIHF1ZXJ5IHN0cmluZyBmb3IgZWxlbWVudCcpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoYXJncykpIHtcbiAgICAgIGVsZW1lbnQgPSBhcmdzXG4gICAgfSBlbHNlIGlmIChpc1dlYkdMQ29udGV4dChhcmdzKSkge1xuICAgICAgZ2wgPSBhcmdzXG4gICAgICBjYW52YXMgPSBnbC5jYW52YXNcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2skMS5jb25zdHJ1Y3RvcihhcmdzKVxuICAgICAgaWYgKCdnbCcgaW4gYXJncykge1xuICAgICAgICBnbCA9IGFyZ3MuZ2xcbiAgICAgIH0gZWxzZSBpZiAoJ2NhbnZhcycgaW4gYXJncykge1xuICAgICAgICBjYW52YXMgPSBnZXRFbGVtZW50KGFyZ3MuY2FudmFzKVxuICAgICAgfSBlbHNlIGlmICgnY29udGFpbmVyJyBpbiBhcmdzKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGdldEVsZW1lbnQoYXJncy5jb250YWluZXIpXG4gICAgICB9XG4gICAgICBpZiAoJ2F0dHJpYnV0ZXMnIGluIGFyZ3MpIHtcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzLmF0dHJpYnV0ZXNcbiAgICAgICAgY2hlY2skMS50eXBlKGNvbnRleHRBdHRyaWJ1dGVzLCAnb2JqZWN0JywgJ2ludmFsaWQgY29udGV4dCBhdHRyaWJ1dGVzJylcbiAgICAgIH1cbiAgICAgIGlmICgnZXh0ZW5zaW9ucycgaW4gYXJncykge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKGFyZ3MuZXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb3B0aW9uYWxFeHRlbnNpb25zJyBpbiBhcmdzKSB7XG4gICAgICAgIG9wdGlvbmFsRXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhhcmdzLm9wdGlvbmFsRXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb25Eb25lJyBpbiBhcmdzKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBhcmdzLm9uRG9uZSwgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAnaW52YWxpZCBvciBtaXNzaW5nIG9uRG9uZSBjYWxsYmFjaycpXG4gICAgICAgIG9uRG9uZSA9IGFyZ3Mub25Eb25lXG4gICAgICB9XG4gICAgICBpZiAoJ3Byb2ZpbGUnIGluIGFyZ3MpIHtcbiAgICAgICAgcHJvZmlsZSA9ICEhYXJncy5wcm9maWxlXG4gICAgICB9XG4gICAgICBpZiAoJ3BpeGVsUmF0aW8nIGluIGFyZ3MpIHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9ICthcmdzLnBpeGVsUmF0aW9cbiAgICAgICAgY2hlY2skMShwaXhlbFJhdGlvID4gMCwgJ2ludmFsaWQgcGl4ZWwgcmF0aW8nKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsJylcbiAgfVxuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgIGNhbnZhcyA9IGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyID0gZWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2hlY2skMShcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgJ211c3QgbWFudWFsbHkgc3BlY2lmeSB3ZWJnbCBjb250ZXh0IG91dHNpZGUgb2YgRE9NIGVudmlyb25tZW50cycpXG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQ2FudmFzKGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LCBvbkRvbmUsIHBpeGVsUmF0aW8pXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY2FudmFzID0gcmVzdWx0LmNhbnZhc1xuICAgICAgb25EZXN0cm95ID0gcmVzdWx0Lm9uRGVzdHJveVxuICAgIH1cbiAgICAvLyB3b3JrYXJvdW5kIGZvciBjaHJvbWl1bSBidWcsIHByZW11bHRpcGxpZWQgYWxwaGEgdmFsdWUgaXMgcGxhdGZvcm0gZGVwZW5kZW50XG4gICAgaWYgKGNvbnRleHRBdHRyaWJ1dGVzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdW5kZWZpbmVkKSBjb250ZXh0QXR0cmlidXRlcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlXG4gICAgZ2wgPSBjcmVhdGVDb250ZXh0KGNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoIWdsKSB7XG4gICAgb25EZXN0cm95KClcbiAgICBvbkRvbmUoJ3dlYmdsIG5vdCBzdXBwb3J0ZWQsIHRyeSB1cGdyYWRpbmcgeW91ciBicm93c2VyIG9yIGdyYXBoaWNzIGRyaXZlcnMgaHR0cDovL2dldC53ZWJnbC5vcmcnKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsOiBnbCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIG9wdGlvbmFsRXh0ZW5zaW9uczogb3B0aW9uYWxFeHRlbnNpb25zLFxuICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgcHJvZmlsZTogcHJvZmlsZSxcbiAgICBvbkRvbmU6IG9uRG9uZSxcbiAgICBvbkRlc3Ryb3k6IG9uRGVzdHJveVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNhY2hlIChnbCwgY29uZmlnKSB7XG4gIHZhciBleHRlbnNpb25zID0ge31cblxuICBmdW5jdGlvbiB0cnlMb2FkRXh0ZW5zaW9uIChuYW1lXykge1xuICAgIGNoZWNrJDEudHlwZShuYW1lXywgJ3N0cmluZycsICdleHRlbnNpb24gbmFtZSBtdXN0IGJlIHN0cmluZycpXG4gICAgdmFyIG5hbWUgPSBuYW1lXy50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIGV4dFxuICAgIHRyeSB7XG4gICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gISFleHRcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbmFtZSA9IGNvbmZpZy5leHRlbnNpb25zW2ldXG4gICAgaWYgKCF0cnlMb2FkRXh0ZW5zaW9uKG5hbWUpKSB7XG4gICAgICBjb25maWcub25EZXN0cm95KClcbiAgICAgIGNvbmZpZy5vbkRvbmUoJ1wiJyArIG5hbWUgKyAnXCIgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCwgdHJ5IHVwZ3JhZGluZyB5b3VyIHN5c3RlbSBvciBhIGRpZmZlcmVudCBicm93c2VyJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uZmlnLm9wdGlvbmFsRXh0ZW5zaW9ucy5mb3JFYWNoKHRyeUxvYWRFeHRlbnNpb24pXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbbmFtZV0gJiYgIXRyeUxvYWRFeHRlbnNpb24obmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhyZWdsKTogZXJyb3IgcmVzdG9yaW5nIGV4dGVuc2lvbiAnICsgbmFtZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vcCAobiwgZikge1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBmKGkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG52YXIgR0xfQllURSQxID0gNTEyMFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkMiA9IDUxMjFcbnZhciBHTF9TSE9SVCQxID0gNTEyMlxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDEgPSA1MTIzXG52YXIgR0xfSU5UJDEgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UJDEgPSA1MTI1XG52YXIgR0xfRkxPQVQkMiA9IDUxMjZcblxuZnVuY3Rpb24gbmV4dFBvdzE2ICh2KSB7XG4gIGZvciAodmFyIGkgPSAxNjsgaSA8PSAoMSA8PCAyOCk7IGkgKj0gMTYpIHtcbiAgICBpZiAodiA8PSBpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBsb2cyICh2KSB7XG4gIHZhciByLCBzaGlmdFxuICByID0gKHYgPiAweEZGRkYpIDw8IDRcbiAgdiA+Pj49IHJcbiAgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDNcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweDMpIDw8IDFcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHJldHVybiByIHwgKHYgPj4gMSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9vbCAoKSB7XG4gIHZhciBidWZmZXJQb29sID0gbG9vcCg4LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0pXG5cbiAgZnVuY3Rpb24gYWxsb2MgKG4pIHtcbiAgICB2YXIgc3ogPSBuZXh0UG93MTYobilcbiAgICB2YXIgYmluID0gYnVmZmVyUG9vbFtsb2cyKHN6KSA+PiAyXVxuICAgIGlmIChiaW4ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGJpbi5wb3AoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKHN6KVxuICB9XG5cbiAgZnVuY3Rpb24gZnJlZSAoYnVmKSB7XG4gICAgYnVmZmVyUG9vbFtsb2cyKGJ1Zi5ieXRlTGVuZ3RoKSA+PiAyXS5wdXNoKGJ1ZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jVHlwZSAodHlwZSwgbikge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdMX0JZVEUkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQyOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfU0hPUlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoYWxsb2MoNCAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KGFsbG9jKDQgKiBuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfRkxPQVQkMjpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhbGxvYyg0ICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gbikge1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJhcnJheSgwLCBuKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlVHlwZSAoYXJyYXkpIHtcbiAgICBmcmVlKGFycmF5LmJ1ZmZlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsb2M6IGFsbG9jLFxuICAgIGZyZWU6IGZyZWUsXG4gICAgYWxsb2NUeXBlOiBhbGxvY1R5cGUsXG4gICAgZnJlZVR5cGU6IGZyZWVUeXBlXG4gIH1cbn1cblxudmFyIHBvb2wgPSBjcmVhdGVQb29sKClcblxuLy8gemVybyBwb29sIGZvciBpbml0aWFsIHplcm8gZGF0YVxucG9vbC56ZXJvID0gY3JlYXRlUG9vbCgpXG5cbnZhciBHTF9TVUJQSVhFTF9CSVRTID0gMHgwRDUwXG52YXIgR0xfUkVEX0JJVFMgPSAweDBENTJcbnZhciBHTF9HUkVFTl9CSVRTID0gMHgwRDUzXG52YXIgR0xfQkxVRV9CSVRTID0gMHgwRDU0XG52YXIgR0xfQUxQSEFfQklUUyA9IDB4MEQ1NVxudmFyIEdMX0RFUFRIX0JJVFMgPSAweDBENTZcbnZhciBHTF9TVEVOQ0lMX0JJVFMgPSAweDBENTdcblxudmFyIEdMX0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRSA9IDB4ODQ2RFxudmFyIEdMX0FMSUFTRURfTElORV9XSURUSF9SQU5HRSA9IDB4ODQ2RVxuXG52YXIgR0xfTUFYX1RFWFRVUkVfU0laRSA9IDB4MEQzM1xudmFyIEdMX01BWF9WSUVXUE9SVF9ESU1TID0gMHgwRDNBXG52YXIgR0xfTUFYX1ZFUlRFWF9BVFRSSUJTID0gMHg4ODY5XG52YXIgR0xfTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkJcbnZhciBHTF9NQVhfVkFSWUlOR19WRUNUT1JTID0gMHg4REZDXG52YXIgR0xfTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNERcbnZhciBHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNENcbnZhciBHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4ODg3MlxudmFyIEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkRcbnZhciBHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFID0gMHg4NTFDXG52YXIgR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFID0gMHg4NEU4XG5cbnZhciBHTF9WRU5ET1IgPSAweDFGMDBcbnZhciBHTF9SRU5ERVJFUiA9IDB4MUYwMVxudmFyIEdMX1ZFUlNJT04gPSAweDFGMDJcbnZhciBHTF9TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04gPSAweDhCOENcblxudmFyIEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRlxuXG52YXIgR0xfTUFYX0NPTE9SX0FUVEFDSE1FTlRTX1dFQkdMID0gMHg4Q0RGXG52YXIgR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTCA9IDB4ODgyNFxuXG52YXIgR0xfVEVYVFVSRV8yRCA9IDB4MERFMVxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTVcbnZhciBHTF9URVhUVVJFMCA9IDB4ODRDMFxudmFyIEdMX1JHQkEgPSAweDE5MDhcbnZhciBHTF9GTE9BVCQxID0gMHgxNDA2XG52YXIgR0xfVU5TSUdORURfQllURSQxID0gMHgxNDAxXG52YXIgR0xfRlJBTUVCVUZGRVIgPSAweDhENDBcbnZhciBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSA9IDB4OENENVxudmFyIEdMX0NPTE9SX0FUVEFDSE1FTlQwID0gMHg4Q0UwXG52YXIgR0xfQ09MT1JfQlVGRkVSX0JJVCQxID0gMHg0MDAwXG5cbnZhciB3cmFwTGltaXRzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zKSB7XG4gIHZhciBtYXhBbmlzb3Ryb3BpYyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljKSB7XG4gICAgbWF4QW5pc290cm9waWMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKVxuICB9XG5cbiAgdmFyIG1heERyYXdidWZmZXJzID0gMVxuICB2YXIgbWF4Q29sb3JBdHRhY2htZW50cyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzKSB7XG4gICAgbWF4RHJhd2J1ZmZlcnMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTClcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzID0gZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DT0xPUl9BVFRBQ0hNRU5UU19XRUJHTClcbiAgfVxuXG4gIC8vIGRldGVjdCBpZiByZWFkaW5nIGZsb2F0IHRleHR1cmVzIGlzIGF2YWlsYWJsZSAoU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIHJlYWRGbG9hdCA9ICEhZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdFxuICBpZiAocmVhZEZsb2F0KSB7XG4gICAgdmFyIHJlYWRGbG9hdFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlKVxuICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV8yRCwgMCwgR0xfUkdCQSwgMSwgMSwgMCwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgbnVsbClcblxuICAgIHZhciBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSLCBmYm8pXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoR0xfRlJBTUVCVUZGRVIsIEdMX0NPTE9SX0FUVEFDSE1FTlQwLCBHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlLCAwKVxuICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQsIG51bGwpXG5cbiAgICBpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhHTF9GUkFNRUJVRkZFUikgIT09IEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFKSByZWFkRmxvYXQgPSBmYWxzZVxuXG4gICAgZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCAxLCAxKVxuICAgICAgZ2wuY2xlYXJDb2xvcigxLjAsIDAuMCwgMC4wLCAxLjApXG4gICAgICBnbC5jbGVhcihHTF9DT0xPUl9CVUZGRVJfQklUJDEpXG4gICAgICB2YXIgcGl4ZWxzID0gcG9vbC5hbGxvY1R5cGUoR0xfRkxPQVQkMSwgNClcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgcGl4ZWxzKVxuXG4gICAgICBpZiAoZ2wuZ2V0RXJyb3IoKSkgcmVhZEZsb2F0ID0gZmFsc2VcbiAgICAgIGVsc2Uge1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8pXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocmVhZEZsb2F0VGV4dHVyZSlcblxuICAgICAgICByZWFkRmxvYXQgPSBwaXhlbHNbMF0gPT09IDEuMFxuICAgICAgfVxuXG4gICAgICBwb29sLmZyZWVUeXBlKHBpeGVscylcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlY3Qgbm9uIHBvd2VyIG9mIHR3byBjdWJlIHRleHR1cmVzIHN1cHBvcnQgKElFIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIGlzSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL1RyaWRlbnRcXC8vLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pIHx8IC9FZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuXG4gIHZhciBucG90VGV4dHVyZUN1YmUgPSB0cnVlXG5cbiAgaWYgKCFpc0lFKSB7XG4gICAgdmFyIGN1YmVUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgdmFyIGRhdGEgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9CWVRFJDEsIDM2KVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTApXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgY3ViZVRleHR1cmUpXG4gICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDAsIEdMX1JHQkEsIDMsIDMsIDAsIEdMX1JHQkEsIEdMX1VOU0lHTkVEX0JZVEUkMSwgZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgbnVsbClcbiAgICBnbC5kZWxldGVUZXh0dXJlKGN1YmVUZXh0dXJlKVxuICAgIG5wb3RUZXh0dXJlQ3ViZSA9ICFnbC5nZXRFcnJvcigpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRyYXdpbmcgYnVmZmVyIGJpdCBkZXB0aFxuICAgIGNvbG9yQml0czogW1xuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFRF9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9HUkVFTl9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9CTFVFX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0FMUEhBX0JJVFMpXG4gICAgXSxcbiAgICBkZXB0aEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9ERVBUSF9CSVRTKSxcbiAgICBzdGVuY2lsQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX1NURU5DSUxfQklUUyksXG4gICAgc3VicGl4ZWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1VCUElYRUxfQklUUyksXG5cbiAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnM6IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZpbHRlcihmdW5jdGlvbiAoZXh0KSB7XG4gICAgICByZXR1cm4gISFleHRlbnNpb25zW2V4dF1cbiAgICB9KSxcblxuICAgIC8vIG1heCBhbmlzbyBzYW1wbGVzXG4gICAgbWF4QW5pc290cm9waWM6IG1heEFuaXNvdHJvcGljLFxuXG4gICAgLy8gbWF4IGRyYXcgYnVmZmVyc1xuICAgIG1heERyYXdidWZmZXJzOiBtYXhEcmF3YnVmZmVycyxcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzOiBtYXhDb2xvckF0dGFjaG1lbnRzLFxuXG4gICAgLy8gcG9pbnQgYW5kIGxpbmUgc2l6ZSByYW5nZXNcbiAgICBwb2ludFNpemVEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFKSxcbiAgICBsaW5lV2lkdGhEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKSxcbiAgICBtYXhWaWV3cG9ydERpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVklFV1BPUlRfRElNUyksXG4gICAgbWF4Q29tYmluZWRUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4Q3ViZU1hcFNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhSZW5kZXJidWZmZXJTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFKSxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4VGV4dHVyZVNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhBdHRyaWJ1dGVzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZFUlRFWF9BVFRSSUJTKSxcbiAgICBtYXhWZXJ0ZXhVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSxcbiAgICBtYXhWZXJ0ZXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgIG1heFZhcnlpbmdWZWN0b3JzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZBUllJTkdfVkVDVE9SUyksXG4gICAgbWF4RnJhZ21lbnRVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxuXG4gICAgLy8gdmVuZG9yIGluZm9cbiAgICBnbHNsOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKSxcbiAgICByZW5kZXJlcjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFTkRFUkVSKSxcbiAgICB2ZW5kb3I6IGdsLmdldFBhcmFtZXRlcihHTF9WRU5ET1IpLFxuICAgIHZlcnNpb246IGdsLmdldFBhcmFtZXRlcihHTF9WRVJTSU9OKSxcblxuICAgIC8vIHF1aXJrc1xuICAgIHJlYWRGbG9hdDogcmVhZEZsb2F0LFxuICAgIG5wb3RUZXh0dXJlQ3ViZTogbnBvdFRleHR1cmVDdWJlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOREFycmF5TGlrZSAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgISFvYmogJiZcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnNoYXBlKSAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnN0cmlkZSkgJiZcbiAgICB0eXBlb2Ygb2JqLm9mZnNldCA9PT0gJ251bWJlcicgJiZcbiAgICBvYmouc2hhcGUubGVuZ3RoID09PSBvYmouc3RyaWRlLmxlbmd0aCAmJlxuICAgIChBcnJheS5pc0FycmF5KG9iai5kYXRhKSB8fFxuICAgICAgaXNUeXBlZEFycmF5KG9iai5kYXRhKSkpXG59XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XSB9KVxufVxuXG52YXIgZmxhdHRlblV0aWxzID0ge1xuICBzaGFwZTogYXJyYXlTaGFwZSQxLFxuICBmbGF0dGVuOiBmbGF0dGVuQXJyYXlcbn07XG5cbmZ1bmN0aW9uIGZsYXR0ZW4xRCAoYXJyYXksIG54LCBvdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBueDsgKytpKSB7XG4gICAgb3V0W2ldID0gYXJyYXlbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuMkQgKGFycmF5LCBueCwgbnksIG91dCkge1xuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcbiAgICB2YXIgcm93ID0gYXJyYXlbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG55OyArK2opIHtcbiAgICAgIG91dFtwdHIrK10gPSByb3dbal1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbjNEIChhcnJheSwgbngsIG55LCBueiwgb3V0LCBwdHJfKSB7XG4gIHZhciBwdHIgPSBwdHJfXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbng7ICsraSkge1xuICAgIHZhciByb3cgPSBhcnJheVtpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnk7ICsraikge1xuICAgICAgdmFyIGNvbCA9IHJvd1tqXVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuejsgKytrKSB7XG4gICAgICAgIG91dFtwdHIrK10gPSBjb2xba11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlblJlYyAoYXJyYXksIHNoYXBlLCBsZXZlbCwgb3V0LCBwdHIpIHtcbiAgdmFyIHN0cmlkZSA9IDFcbiAgZm9yICh2YXIgaSA9IGxldmVsICsgMTsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgc3RyaWRlICo9IHNoYXBlW2ldXG4gIH1cbiAgdmFyIG4gPSBzaGFwZVtsZXZlbF1cbiAgaWYgKHNoYXBlLmxlbmd0aCAtIGxldmVsID09PSA0KSB7XG4gICAgdmFyIG54ID0gc2hhcGVbbGV2ZWwgKyAxXVxuICAgIHZhciBueSA9IHNoYXBlW2xldmVsICsgMl1cbiAgICB2YXIgbnogPSBzaGFwZVtsZXZlbCArIDNdXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlbjNEKGFycmF5W2ldLCBueCwgbnksIG56LCBvdXQsIHB0cilcbiAgICAgIHB0ciArPSBzdHJpZGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlblJlYyhhcnJheVtpXSwgc2hhcGUsIGxldmVsICsgMSwgb3V0LCBwdHIpXG4gICAgICBwdHIgKz0gc3RyaWRlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSAoYXJyYXksIHNoYXBlLCB0eXBlLCBvdXRfKSB7XG4gIHZhciBzeiA9IDFcbiAgaWYgKHNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN6ID0gMFxuICB9XG4gIHZhciBvdXQgPSBvdXRfIHx8IHBvb2wuYWxsb2NUeXBlKHR5cGUsIHN6KVxuICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgZmxhdHRlbjFEKGFycmF5LCBzaGFwZVswXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6XG4gICAgICBmbGF0dGVuMkQoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDM6XG4gICAgICBmbGF0dGVuM0QoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgc2hhcGVbMl0sIG91dCwgMClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGZsYXR0ZW5SZWMoYXJyYXksIHNoYXBlLCAwLCBvdXQsIDApXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBhcnJheVNoYXBlJDEgKGFycmF5Xykge1xuICB2YXIgc2hhcGUgPSBbXVxuICBmb3IgKHZhciBhcnJheSA9IGFycmF5XzsgYXJyYXkubGVuZ3RoOyBhcnJheSA9IGFycmF5WzBdKSB7XG4gICAgc2hhcGUucHVzaChhcnJheS5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHNoYXBlXG59XG5cbnZhciBhcnJheVR5cGVzID0gIHtcblx0XCJbb2JqZWN0IEludDhBcnJheV1cIjogNTEyMCxcblx0XCJbb2JqZWN0IEludDE2QXJyYXldXCI6IDUxMjIsXG5cdFwiW29iamVjdCBJbnQzMkFycmF5XVwiOiA1MTI0LFxuXHRcIltvYmplY3QgVWludDhBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOiA1MTIxLFxuXHRcIltvYmplY3QgVWludDE2QXJyYXldXCI6IDUxMjMsXG5cdFwiW29iamVjdCBVaW50MzJBcnJheV1cIjogNTEyNSxcblx0XCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjogNTEyNixcblx0XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiOiA1MTIxXG59O1xuXG52YXIgaW50OCA9IDUxMjA7XG52YXIgaW50MTYgPSA1MTIyO1xudmFyIGludDMyID0gNTEyNDtcbnZhciB1aW50OCA9IDUxMjE7XG52YXIgdWludDE2ID0gNTEyMztcbnZhciB1aW50MzIgPSA1MTI1O1xudmFyIGZsb2F0ID0gNTEyNjtcbnZhciBmbG9hdDMyID0gNTEyNjtcbnZhciBnbFR5cGVzID0ge1xuXHRpbnQ4OiBpbnQ4LFxuXHRpbnQxNjogaW50MTYsXG5cdGludDMyOiBpbnQzMixcblx0dWludDg6IHVpbnQ4LFxuXHR1aW50MTY6IHVpbnQxNixcblx0dWludDMyOiB1aW50MzIsXG5cdGZsb2F0OiBmbG9hdCxcblx0ZmxvYXQzMjogZmxvYXQzMlxufTtcblxudmFyIGR5bmFtaWMkMSA9IDM1MDQ4O1xudmFyIHN0cmVhbSA9IDM1MDQwO1xudmFyIHVzYWdlVHlwZXMgPSB7XG5cdGR5bmFtaWM6IGR5bmFtaWMkMSxcblx0c3RyZWFtOiBzdHJlYW0sXG5cdFwic3RhdGljXCI6IDM1MDQ0XG59O1xuXG52YXIgYXJyYXlGbGF0dGVuID0gZmxhdHRlblV0aWxzLmZsYXR0ZW5cbnZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlXG5cbnZhciBHTF9TVEFUSUNfRFJBVyA9IDB4ODhFNFxudmFyIEdMX1NUUkVBTV9EUkFXID0gMHg4OEUwXG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDMgPSA1MTIxXG52YXIgR0xfRkxPQVQkMyA9IDUxMjZcblxudmFyIERUWVBFU19TSVpFUyA9IFtdXG5EVFlQRVNfU0laRVNbNTEyMF0gPSAxIC8vIGludDhcbkRUWVBFU19TSVpFU1s1MTIyXSA9IDIgLy8gaW50MTZcbkRUWVBFU19TSVpFU1s1MTI0XSA9IDQgLy8gaW50MzJcbkRUWVBFU19TSVpFU1s1MTIxXSA9IDEgLy8gdWludDhcbkRUWVBFU19TSVpFU1s1MTIzXSA9IDIgLy8gdWludDE2XG5EVFlQRVNfU0laRVNbNTEyNV0gPSA0IC8vIHVpbnQzMlxuRFRZUEVTX1NJWkVTWzUxMjZdID0gNCAvLyBmbG9hdDMyXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlDb2RlIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheSAob3V0LCBpbnApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaV0gPSBpbnBbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2UgKFxuICByZXN1bHQsIGRhdGEsIHNoYXBlWCwgc2hhcGVZLCBzdHJpZGVYLCBzdHJpZGVZLCBvZmZzZXQpIHtcbiAgdmFyIHB0ciA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZVg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGVZOyArK2opIHtcbiAgICAgIHJlc3VsdFtwdHIrK10gPSBkYXRhW3N0cmlkZVggKiBpICsgc3RyaWRlWSAqIGogKyBvZmZzZXRdXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBCdWZmZXJTdGF0ZSAoZ2wsIHN0YXRzLCBjb25maWcsIGRlc3Ryb3lCdWZmZXIpIHtcbiAgdmFyIGJ1ZmZlckNvdW50ID0gMFxuICB2YXIgYnVmZmVyU2V0ID0ge31cblxuICBmdW5jdGlvbiBSRUdMQnVmZmVyICh0eXBlKSB7XG4gICAgdGhpcy5pZCA9IGJ1ZmZlckNvdW50KytcbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDBcbiAgICB0aGlzLmRpbWVuc2lvbiA9IDFcbiAgICB0aGlzLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG5cbiAgICB0aGlzLnBlcnNpc3RlbnREYXRhID0gbnVsbFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcilcbiAgfVxuXG4gIFJFR0xCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG5cbiAgdmFyIHN0cmVhbVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAodHlwZSwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSBzdHJlYW1Qb29sLnBvcCgpXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKHR5cGUpXG4gICAgfVxuICAgIGJ1ZmZlci5iaW5kKClcbiAgICBpbml0QnVmZmVyRnJvbURhdGEoYnVmZmVyLCBkYXRhLCBHTF9TVFJFQU1fRFJBVywgMCwgMSwgZmFsc2UpXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVN0cmVhbSAoc3RyZWFtJCQxKSB7XG4gICAgc3RyZWFtUG9vbC5wdXNoKHN0cmVhbSQkMSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheSAoYnVmZmVyLCBkYXRhLCB1c2FnZSkge1xuICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgZGF0YSwgdXNhZ2UpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0QnVmZmVyRnJvbURhdGEgKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3QpIHtcbiAgICB2YXIgc2hhcGVcbiAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9GTE9BVCQzXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBmbGF0RGF0YVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgICAgIHNoYXBlID0gYXJyYXlTaGFwZShkYXRhKVxuICAgICAgICAgIHZhciBkaW0gPSAxXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZGltICo9IHNoYXBlW2ldXG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1cbiAgICAgICAgICBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIGZsYXREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gZmxhdERhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgICAgIHZhciB0eXBlZERhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgIGNvcHlBcnJheSh0eXBlZERhdGEsIGRhdGEpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgdHlwZWREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHlwZWREYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVR5cGUodHlwZWREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YVswXSkpIHtcbiAgICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGF0YVswXS5sZW5ndGhcbiAgICAgICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhWzBdKSB8fCBHTF9GTE9BVCQzXG4gICAgICAgICAgZmxhdERhdGEgPSBhcnJheUZsYXR0ZW4oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgW2RhdGEubGVuZ3RoLCBkYXRhWzBdLmxlbmd0aF0sXG4gICAgICAgICAgICBidWZmZXIuZHR5cGUpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKVxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBmbGF0RGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGZsYXREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhKVxuICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZGF0YSwgdXNhZ2UpXG4gICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBuZXcgVWludDhBcnJheShuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc05EQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgICBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIG9mZnNldCA9IGRhdGEub2Zmc2V0XG5cbiAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICB2YXIgc2hhcGVZID0gMFxuICAgICAgdmFyIHN0cmlkZVggPSAwXG4gICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSAwXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzaGFwZVggPSBzaGFwZVswXVxuICAgICAgICBzaGFwZVkgPSBzaGFwZVsxXVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSBzdHJpZGVbMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpIHx8IEdMX0ZMT0FUJDNcbiAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBzaGFwZVlcblxuICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIHNoYXBlWCAqIHNoYXBlWSlcbiAgICAgIHRyYW5zcG9zZSh0cmFuc3Bvc2VEYXRhLFxuICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgIHNoYXBlWCwgc2hhcGVZLFxuICAgICAgICBzdHJpZGVYLCBzdHJpZGVZLFxuICAgICAgICBvZmZzZXQpXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCB0cmFuc3Bvc2VEYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IHRyYW5zcG9zZURhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnVmZmVyLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG4gICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBkYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRhdGEpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95IChidWZmZXIpIHtcbiAgICBzdGF0cy5idWZmZXJDb3VudC0tXG5cbiAgICAvLyByZW1vdmUgYXR0cmlidXRlIGxpbmtcbiAgICBkZXN0cm95QnVmZmVyKGJ1ZmZlcilcblxuICAgIHZhciBoYW5kbGUgPSBidWZmZXIuYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdidWZmZXIgbXVzdCBub3QgYmUgZGVsZXRlZCBhbHJlYWR5JylcbiAgICBnbC5kZWxldGVCdWZmZXIoaGFuZGxlKVxuICAgIGJ1ZmZlci5idWZmZXIgPSBudWxsXG4gICAgZGVsZXRlIGJ1ZmZlclNldFtidWZmZXIuaWRdXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKG9wdGlvbnMsIHR5cGUsIGRlZmVySW5pdCwgcGVyc2lzdGVudCkge1xuICAgIHN0YXRzLmJ1ZmZlckNvdW50KytcblxuICAgIHZhciBidWZmZXIgPSBuZXcgUkVHTEJ1ZmZlcih0eXBlKVxuICAgIGJ1ZmZlclNldFtidWZmZXIuaWRdID0gYnVmZmVyXG5cbiAgICBmdW5jdGlvbiByZWdsQnVmZmVyIChvcHRpb25zKSB7XG4gICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgICAgdmFyIGRhdGEgPSBudWxsXG4gICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgIHZhciBkdHlwZSA9IDBcbiAgICAgIHZhciBkaW1lbnNpb24gPSAxXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzVHlwZWRBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzTkRBcnJheUxpa2Uob3B0aW9ucykgfHxcbiAgICAgICAgICBvcHRpb25zIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zIHwgMFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBvcHRpb25zLCAnb2JqZWN0JyxcbiAgICAgICAgICAnYnVmZmVyIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdCwgYSBudW1iZXIgb3IgYW4gYXJyYXknKVxuXG4gICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBkYXRhID09PSBudWxsIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICBpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBidWZmZXInKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLnVzYWdlLCB1c2FnZVR5cGVzLCAnaW52YWxpZCBidWZmZXIgdXNhZ2UnKVxuICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy50eXBlLCBnbFR5cGVzLCAnaW52YWxpZCBidWZmZXIgdHlwZScpXG4gICAgICAgICAgZHR5cGUgPSBnbFR5cGVzW29wdGlvbnMudHlwZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGltZW5zaW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZGltZW5zaW9uLCAnbnVtYmVyJywgJ2ludmFsaWQgZGltZW5zaW9uJylcbiAgICAgICAgICBkaW1lbnNpb24gPSBvcHRpb25zLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5ubmkoYnl0ZUxlbmd0aCwgJ2J1ZmZlciBsZW5ndGggbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuYmluZCgpXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gIzQ3NVxuICAgICAgICBpZiAoYnl0ZUxlbmd0aCkgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkM1xuICAgICAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdEJ1ZmZlckZyb21EYXRhKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3RlbnQpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICBidWZmZXIuc3RhdHMuc2l6ZSA9IGJ1ZmZlci5ieXRlTGVuZ3RoICogRFRZUEVTX1NJWkVTW2J1ZmZlci5kdHlwZV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTdWJEYXRhIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGNoZWNrJDEob2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoIDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAnaW52YWxpZCBidWZmZXIgc3ViZGF0YSBjYWxsLCBidWZmZXIgaXMgdG9vIHNtYWxsLiAnICsgJyBDYW5cXCd0IHdyaXRlIGRhdGEgb2Ygc2l6ZSAnICsgZGF0YS5ieXRlTGVuZ3RoICsgJyBzdGFydGluZyBmcm9tIG9mZnNldCAnICsgb2Zmc2V0ICsgJyB0byBhIGJ1ZmZlciBvZiBzaXplICcgKyBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgb2Zmc2V0LCBkYXRhKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmRhdGEgKGRhdGEsIG9mZnNldF8pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAob2Zmc2V0XyB8fCAwKSB8IDBcbiAgICAgIHZhciBzaGFwZVxuICAgICAgYnVmZmVyLmJpbmQoKVxuICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSB8fCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgc2V0U3ViRGF0YShkYXRhLCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgY29weUFycmF5KGNvbnZlcnRlZCwgZGF0YSlcbiAgICAgICAgICAgIHNldFN1YkRhdGEoY29udmVydGVkLCBvZmZzZXQpXG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGNvbnZlcnRlZClcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXSkgfHwgaXNUeXBlZEFycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgICBzaGFwZSA9IGFycmF5U2hhcGUoZGF0YSlcbiAgICAgICAgICAgIHZhciBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgICAgc2V0U3ViRGF0YShmbGF0RGF0YSwgb2Zmc2V0KVxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBidWZmZXIgZGF0YScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcbiAgICAgICAgc2hhcGUgPSBkYXRhLnNoYXBlXG4gICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuXG4gICAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICAgIHZhciBzaGFwZVkgPSAwXG4gICAgICAgIHZhciBzdHJpZGVYID0gMFxuICAgICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgICBzdHJpZGVZID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gc2hhcGVbMV1cbiAgICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKVxuICAgICAgICAgID8gYnVmZmVyLmR0eXBlXG4gICAgICAgICAgOiB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpXG5cbiAgICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShkdHlwZSwgc2hhcGVYICogc2hhcGVZKVxuICAgICAgICB0cmFuc3Bvc2UodHJhbnNwb3NlRGF0YSxcbiAgICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgICAgc2hhcGVYLCBzaGFwZVksXG4gICAgICAgICAgc3RyaWRlWCwgc3RyaWRlWSxcbiAgICAgICAgICBkYXRhLm9mZnNldClcbiAgICAgICAgc2V0U3ViRGF0YSh0cmFuc3Bvc2VEYXRhLCBvZmZzZXQpXG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgYnVmZmVyIHN1YmRhdGEnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAoIWRlZmVySW5pdCkge1xuICAgICAgcmVnbEJ1ZmZlcihvcHRpb25zKVxuICAgIH1cblxuICAgIHJlZ2xCdWZmZXIuX3JlZ2xUeXBlID0gJ2J1ZmZlcidcbiAgICByZWdsQnVmZmVyLl9idWZmZXIgPSBidWZmZXJcbiAgICByZWdsQnVmZmVyLnN1YmRhdGEgPSBzdWJkYXRhXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICByZWdsQnVmZmVyLnN0YXRzID0gYnVmZmVyLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xCdWZmZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgZGVzdHJveShidWZmZXIpIH1cblxuICAgIHJldHVybiByZWdsQnVmZmVyXG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlQnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICBidWZmZXIuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGJ1ZmZlci5idWZmZXIpXG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBidWZmZXIudHlwZSwgYnVmZmVyLnBlcnNpc3RlbnREYXRhIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIudXNhZ2UpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdywgdGhlIHN0cmVhbXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSB0b3RhbCBjb3VudC5cbiAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IGJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlQnVmZmVyLFxuXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0sXG4gICAgZGVzdHJveVN0cmVhbTogZGVzdHJveVN0cmVhbSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWx1ZXMoYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG4gICAgICBzdHJlYW1Qb29sLmZvckVhY2goZGVzdHJveSlcbiAgICB9LFxuXG4gICAgZ2V0QnVmZmVyOiBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgJiYgd3JhcHBlci5fYnVmZmVyIGluc3RhbmNlb2YgUkVHTEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5fYnVmZmVyXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlQnVmZmVycyxcblxuICAgIF9pbml0QnVmZmVyOiBpbml0QnVmZmVyRnJvbURhdGFcbiAgfVxufVxuXG52YXIgcG9pbnRzID0gMDtcbnZhciBwb2ludCA9IDA7XG52YXIgbGluZXMgPSAxO1xudmFyIGxpbmUgPSAxO1xudmFyIHRyaWFuZ2xlcyA9IDQ7XG52YXIgdHJpYW5nbGUgPSA0O1xudmFyIHByaW1UeXBlcyA9IHtcblx0cG9pbnRzOiBwb2ludHMsXG5cdHBvaW50OiBwb2ludCxcblx0bGluZXM6IGxpbmVzLFxuXHRsaW5lOiBsaW5lLFxuXHR0cmlhbmdsZXM6IHRyaWFuZ2xlcyxcblx0dHJpYW5nbGU6IHRyaWFuZ2xlLFxuXHRcImxpbmUgbG9vcFwiOiAyLFxuXHRcImxpbmUgc3RyaXBcIjogMyxcblx0XCJ0cmlhbmdsZSBzdHJpcFwiOiA1LFxuXHRcInRyaWFuZ2xlIGZhblwiOiA2XG59O1xuXG52YXIgR0xfUE9JTlRTID0gMFxudmFyIEdMX0xJTkVTID0gMVxudmFyIEdMX1RSSUFOR0xFUyA9IDRcblxudmFyIEdMX0JZVEUkMiA9IDUxMjBcbnZhciBHTF9VTlNJR05FRF9CWVRFJDQgPSA1MTIxXG52YXIgR0xfU0hPUlQkMiA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQyID0gNTEyM1xudmFyIEdMX0lOVCQyID0gNTEyNFxudmFyIEdMX1VOU0lHTkVEX0lOVCQyID0gNTEyNVxuXG52YXIgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2M1xuXG52YXIgR0xfU1RSRUFNX0RSQVckMSA9IDB4ODhFMFxudmFyIEdMX1NUQVRJQ19EUkFXJDEgPSAweDg4RTRcblxuZnVuY3Rpb24gd3JhcEVsZW1lbnRzU3RhdGUgKGdsLCBleHRlbnNpb25zLCBidWZmZXJTdGF0ZSwgc3RhdHMpIHtcbiAgdmFyIGVsZW1lbnRTZXQgPSB7fVxuICB2YXIgZWxlbWVudENvdW50ID0gMFxuXG4gIHZhciBlbGVtZW50VHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ0LFxuICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50KSB7XG4gICAgZWxlbWVudFR5cGVzLnVpbnQzMiA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gIH1cblxuICBmdW5jdGlvbiBSRUdMRWxlbWVudEJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgdGhpcy5pZCA9IGVsZW1lbnRDb3VudCsrXG4gICAgZWxlbWVudFNldFt0aGlzLmlkXSA9IHRoaXNcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlclxuICAgIHRoaXMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICB0aGlzLnZlcnRDb3VudCA9IDBcbiAgICB0aGlzLnR5cGUgPSAwXG4gIH1cblxuICBSRUdMRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1ZmZlci5iaW5kKClcbiAgfVxuXG4gIHZhciBidWZmZXJQb29sID0gW11cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50U3RyZWFtIChkYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJ1ZmZlclBvb2wucG9wKClcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbmV3IFJFR0xFbGVtZW50QnVmZmVyKGJ1ZmZlclN0YXRlLmNyZWF0ZShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlKS5fYnVmZmVyKVxuICAgIH1cbiAgICBpbml0RWxlbWVudHMocmVzdWx0LCBkYXRhLCBHTF9TVFJFQU1fRFJBVyQxLCAtMSwgLTEsIDAsIDApXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnRTdHJlYW0gKGVsZW1lbnRzKSB7XG4gICAgYnVmZmVyUG9vbC5wdXNoKGVsZW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEVsZW1lbnRzIChcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhLFxuICAgIHVzYWdlLFxuICAgIHByaW0sXG4gICAgY291bnQsXG4gICAgYnl0ZUxlbmd0aCxcbiAgICB0eXBlKSB7XG4gICAgZWxlbWVudHMuYnVmZmVyLmJpbmQoKVxuICAgIHZhciBkdHlwZVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgcHJlZGljdGVkVHlwZSA9IHR5cGVcbiAgICAgIGlmICghdHlwZSAmJiAoXG4gICAgICAgICFpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgIChpc05EQXJyYXlMaWtlKGRhdGEpICYmICFpc1R5cGVkQXJyYXkoZGF0YS5kYXRhKSkpKSB7XG4gICAgICAgIHByZWRpY3RlZFR5cGUgPSBleHRlbnNpb25zLm9lc19lbGVtZW50X2luZGV4X3VpbnRcbiAgICAgICAgICA/IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gICAgICB9XG4gICAgICBidWZmZXJTdGF0ZS5faW5pdEJ1ZmZlcihcbiAgICAgICAgZWxlbWVudHMuYnVmZmVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgcHJlZGljdGVkVHlwZSxcbiAgICAgICAgMylcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYnVmZmVyRGF0YShHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICBlbGVtZW50cy5idWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci51c2FnZSA9IHVzYWdlXG4gICAgICBlbGVtZW50cy5idWZmZXIuZGltZW5zaW9uID0gM1xuICAgICAgZWxlbWVudHMuYnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG4gICAgfVxuXG4gICAgZHR5cGUgPSB0eXBlXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICBzd2l0Y2ggKGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSkge1xuICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0JZVEUkNDpcbiAgICAgICAgY2FzZSBHTF9CWVRFJDI6XG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfVU5TSUdORURfU0hPUlQkMjpcbiAgICAgICAgY2FzZSBHTF9TSE9SVCQyOlxuICAgICAgICAgIGR0eXBlID0gR0xfVU5TSUdORURfU0hPUlQkMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMjpcbiAgICAgICAgY2FzZSBHTF9JTlQkMjpcbiAgICAgICAgICBkdHlwZSA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yIGVsZW1lbnQgYXJyYXknKVxuICAgICAgfVxuICAgICAgZWxlbWVudHMuYnVmZmVyLmR0eXBlID0gZHR5cGVcbiAgICB9XG4gICAgZWxlbWVudHMudHlwZSA9IGR0eXBlXG5cbiAgICAvLyBDaGVjayBvZXNfZWxlbWVudF9pbmRleF91aW50IGV4dGVuc2lvblxuICAgIGNoZWNrJDEoXG4gICAgICBkdHlwZSAhPT0gR0xfVU5TSUdORURfSU5UJDIgfHxcbiAgICAgICEhZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50LFxuICAgICAgJzMyIGJpdCBlbGVtZW50IGJ1ZmZlcnMgbm90IHN1cHBvcnRlZCwgZW5hYmxlIG9lc19lbGVtZW50X2luZGV4X3VpbnQgZmlyc3QnKVxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIGRlZmF1bHQgcHJpbWl0aXZlIHR5cGUgYW5kIGFyZ3VtZW50c1xuICAgIHZhciB2ZXJ0Q291bnQgPSBjb3VudFxuICAgIGlmICh2ZXJ0Q291bnQgPCAwKSB7XG4gICAgICB2ZXJ0Q291bnQgPSBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVCQyKSB7XG4gICAgICAgIHZlcnRDb3VudCA+Pj0gMVxuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gR0xfVU5TSUdORURfSU5UJDIpIHtcbiAgICAgICAgdmVydENvdW50ID4+PSAyXG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IHZlcnRDb3VudFxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIHByaW1pdGl2ZSB0eXBlIGZyb20gY2VsbCBkaW1lbnNpb25cbiAgICB2YXIgcHJpbVR5cGUgPSBwcmltXG4gICAgaWYgKHByaW0gPCAwKSB7XG4gICAgICBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IGVsZW1lbnRzLmJ1ZmZlci5kaW1lbnNpb25cbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHByaW1UeXBlID0gR0xfUE9JTlRTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAyKSBwcmltVHlwZSA9IEdMX0xJTkVTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAzKSBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgIH1cbiAgICBlbGVtZW50cy5wcmltVHlwZSA9IHByaW1UeXBlXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95RWxlbWVudHMgKGVsZW1lbnRzKSB7XG4gICAgc3RhdHMuZWxlbWVudHNDb3VudC0tXG5cbiAgICBjaGVjayQxKGVsZW1lbnRzLmJ1ZmZlciAhPT0gbnVsbCwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IGVsZW1lbnRzJylcbiAgICBkZWxldGUgZWxlbWVudFNldFtlbGVtZW50cy5pZF1cbiAgICBlbGVtZW50cy5idWZmZXIuZGVzdHJveSgpXG4gICAgZWxlbWVudHMuYnVmZmVyID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMgKG9wdGlvbnMsIHBlcnNpc3RlbnQpIHtcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyU3RhdGUuY3JlYXRlKG51bGwsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCB0cnVlKVxuICAgIHZhciBlbGVtZW50cyA9IG5ldyBSRUdMRWxlbWVudEJ1ZmZlcihidWZmZXIuX2J1ZmZlcilcbiAgICBzdGF0cy5lbGVtZW50c0NvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xFbGVtZW50cyAob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGJ1ZmZlcigpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IDBcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnVmZmVyKG9wdGlvbnMpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IG9wdGlvbnMgfCAwXG4gICAgICAgIGVsZW1lbnRzLnR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gbnVsbFxuICAgICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBVyQxXG4gICAgICAgIHZhciBwcmltVHlwZSA9IC0xXG4gICAgICAgIHZhciB2ZXJ0Q291bnQgPSAtMVxuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgICAgdmFyIGR0eXBlID0gMFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgICBpc05EQXJyYXlMaWtlKG9wdGlvbnMpKSB7XG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZWxlbWVudHMnKVxuICAgICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzVHlwZWRBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGVsZW1lbnQgYnVmZmVyJylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd1c2FnZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMudXNhZ2UsXG4gICAgICAgICAgICAgIHVzYWdlVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHVzYWdlJylcbiAgICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3ByaW1pdGl2ZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMucHJpbWl0aXZlLFxuICAgICAgICAgICAgICBwcmltVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHByaW1pdGl2ZScpXG4gICAgICAgICAgICBwcmltVHlwZSA9IHByaW1UeXBlc1tvcHRpb25zLnByaW1pdGl2ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY291bnQgPT09ICdudW1iZXInICYmIG9wdGlvbnMuY291bnQgPj0gMCxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50IGZvciBlbGVtZW50cycpXG4gICAgICAgICAgICB2ZXJ0Q291bnQgPSBvcHRpb25zLmNvdW50IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKFxuICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlcyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgZHR5cGUgPSBlbGVtZW50VHlwZXNbb3B0aW9ucy50eXBlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHwgMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdmVydENvdW50XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUJDIgfHwgZHR5cGUgPT09IEdMX1NIT1JUJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSAyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMiB8fCBkdHlwZSA9PT0gR0xfSU5UJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSA0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXRFbGVtZW50cyhcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHByaW1UeXBlLFxuICAgICAgICAgIHZlcnRDb3VudCxcbiAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgIGR0eXBlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gICAgfVxuXG4gICAgcmVnbEVsZW1lbnRzKG9wdGlvbnMpXG5cbiAgICByZWdsRWxlbWVudHMuX3JlZ2xUeXBlID0gJ2VsZW1lbnRzJ1xuICAgIHJlZ2xFbGVtZW50cy5fZWxlbWVudHMgPSBlbGVtZW50c1xuICAgIHJlZ2xFbGVtZW50cy5zdWJkYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgYnVmZmVyLnN1YmRhdGEoZGF0YSwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIHJlZ2xFbGVtZW50c1xuICAgIH1cbiAgICByZWdsRWxlbWVudHMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlc3Ryb3lFbGVtZW50cyhlbGVtZW50cylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlRWxlbWVudHMsXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVFbGVtZW50U3RyZWFtLFxuICAgIGRlc3Ryb3lTdHJlYW06IGRlc3Ryb3lFbGVtZW50U3RyZWFtLFxuICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBlbGVtZW50cy5fZWxlbWVudHMgaW5zdGFuY2VvZiBSRUdMRWxlbWVudEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuX2VsZW1lbnRzXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhlbGVtZW50U2V0KS5mb3JFYWNoKGRlc3Ryb3lFbGVtZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIEZMT0FUID0gbmV3IEZsb2F0MzJBcnJheSgxKVxudmFyIElOVCA9IG5ldyBVaW50MzJBcnJheShGTE9BVC5idWZmZXIpXG5cbnZhciBHTF9VTlNJR05FRF9TSE9SVCQ0ID0gNTEyM1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9IYWxmRmxvYXQgKGFycmF5KSB7XG4gIHZhciB1c2hvcnRzID0gcG9vbC5hbGxvY1R5cGUoR0xfVU5TSUdORURfU0hPUlQkNCwgYXJyYXkubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oYXJyYXlbaV0pKSB7XG4gICAgICB1c2hvcnRzW2ldID0gMHhmZmZmXG4gICAgfSBlbHNlIGlmIChhcnJheVtpXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweDdjMDBcbiAgICB9IGVsc2UgaWYgKGFycmF5W2ldID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZjMDBcbiAgICB9IGVsc2Uge1xuICAgICAgRkxPQVRbMF0gPSBhcnJheVtpXVxuICAgICAgdmFyIHggPSBJTlRbMF1cblxuICAgICAgdmFyIHNnbiA9ICh4ID4+PiAzMSkgPDwgMTVcbiAgICAgIHZhciBleHAgPSAoKHggPDwgMSkgPj4+IDI0KSAtIDEyN1xuICAgICAgdmFyIGZyYWMgPSAoeCA+PiAxMykgJiAoKDEgPDwgMTApIC0gMSlcblxuICAgICAgaWYgKGV4cCA8IC0yNCkge1xuICAgICAgICAvLyByb3VuZCBub24tcmVwcmVzZW50YWJsZSBkZW5vcm1hbHMgdG8gMFxuICAgICAgICB1c2hvcnRzW2ldID0gc2duXG4gICAgICB9IGVsc2UgaWYgKGV4cCA8IC0xNCkge1xuICAgICAgICAvLyBoYW5kbGUgZGVub3JtYWxzXG4gICAgICAgIHZhciBzID0gLTE0IC0gZXhwXG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAoKGZyYWMgKyAoMSA8PCAxMCkpID4+IHMpXG4gICAgICB9IGVsc2UgaWYgKGV4cCA+IDE1KSB7XG4gICAgICAgIC8vIHJvdW5kIG92ZXJmbG93IHRvICsvLSBJbmZpbml0eVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgMHg3YzAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgY29udmVydCBkaXJlY3RseVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgKChleHAgKyAxNSkgPDwgMTApICsgZnJhY1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1c2hvcnRzXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlIChzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpIHx8IGlzVHlwZWRBcnJheShzKVxufVxuXG52YXIgaXNQb3cyJDEgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gISh2ICYgKHYgLSAxKSkgJiYgKCEhdilcbn1cblxudmFyIEdMX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTID0gMHg4NkEzXG5cbnZhciBHTF9URVhUVVJFXzJEJDEgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQJDEgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSA9IDB4ODUxNVxuXG52YXIgR0xfUkdCQSQxID0gMHgxOTA4XG52YXIgR0xfQUxQSEEgPSAweDE5MDZcbnZhciBHTF9SR0IgPSAweDE5MDdcbnZhciBHTF9MVU1JTkFOQ0UgPSAweDE5MDlcbnZhciBHTF9MVU1JTkFOQ0VfQUxQSEEgPSAweDE5MEFcblxudmFyIEdMX1JHQkE0ID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSA9IDB4ODA1N1xudmFyIEdMX1JHQjU2NSA9IDB4OEQ2MlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCQxID0gMHg4MDMzXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSQxID0gMHg4MDM0XG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMJDEgPSAweDg0RkFcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMlxudmFyIEdMX0RFUFRIX1NURU5DSUwgPSAweDg0RjlcblxudmFyIEdMX1NSR0JfRVhUID0gMHg4QzQwXG52YXIgR0xfU1JHQl9BTFBIQV9FWFQgPSAweDhDNDJcblxudmFyIEdMX0hBTEZfRkxPQVRfT0VTJDEgPSAweDhENjFcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgPSAweDgzRjBcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMVxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUID0gMHg4M0YyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgPSAweDgzRjNcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTCA9IDB4OEM5MlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0wgPSAweDhDOTNcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTCA9IDB4ODdFRVxuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMFxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUcgPSAweDhDMDFcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HID0gMHg4QzAzXG5cbnZhciBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMID0gMHg4RDY0XG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDUgPSAweDE0MDFcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQzID0gMHgxNDAzXG52YXIgR0xfVU5TSUdORURfSU5UJDMgPSAweDE0MDVcbnZhciBHTF9GTE9BVCQ0ID0gMHgxNDA2XG5cbnZhciBHTF9URVhUVVJFX1dSQVBfUyA9IDB4MjgwMlxudmFyIEdMX1RFWFRVUkVfV1JBUF9UID0gMHgyODAzXG5cbnZhciBHTF9SRVBFQVQgPSAweDI5MDFcbnZhciBHTF9DTEFNUF9UT19FREdFJDEgPSAweDgxMkZcbnZhciBHTF9NSVJST1JFRF9SRVBFQVQgPSAweDgzNzBcblxudmFyIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMFxudmFyIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMVxuXG52YXIgR0xfTkVBUkVTVCQxID0gMHgyNjAwXG52YXIgR0xfTElORUFSID0gMHgyNjAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEgPSAweDI3MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSA9IDB4MjcwMlxudmFyIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDEgPSAweDI3MDNcblxudmFyIEdMX0dFTkVSQVRFX01JUE1BUF9ISU5UID0gMHg4MTkyXG52YXIgR0xfRE9OVF9DQVJFID0gMHgxMTAwXG52YXIgR0xfRkFTVEVTVCA9IDB4MTEwMVxudmFyIEdMX05JQ0VTVCA9IDB4MTEwMlxuXG52YXIgR0xfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgPSAweDg0RkVcblxudmFyIEdMX1VOUEFDS19BTElHTk1FTlQgPSAweDBDRjVcbnZhciBHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMID0gMHg5MjQwXG52YXIgR0xfVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMID0gMHg5MjQxXG52YXIgR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCA9IDB4OTI0M1xuXG52YXIgR0xfQlJPV1NFUl9ERUZBVUxUX1dFQkdMID0gMHg5MjQ0XG5cbnZhciBHTF9URVhUVVJFMCQxID0gMHg4NEMwXG5cbnZhciBNSVBNQVBfRklMVEVSUyA9IFtcbiAgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxLFxuICBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSxcbiAgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbl1cblxudmFyIENIQU5ORUxTX0ZPUk1BVCA9IFtcbiAgMCxcbiAgR0xfTFVNSU5BTkNFLFxuICBHTF9MVU1JTkFOQ0VfQUxQSEEsXG4gIEdMX1JHQixcbiAgR0xfUkdCQSQxXG5dXG5cbnZhciBGT1JNQVRfQ0hBTk5FTFMgPSB7fVxuRk9STUFUX0NIQU5ORUxTW0dMX0xVTUlOQU5DRV0gPVxuRk9STUFUX0NIQU5ORUxTW0dMX0FMUEhBXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfREVQVEhfQ09NUE9ORU5UXSA9IDFcbkZPUk1BVF9DSEFOTkVMU1tHTF9ERVBUSF9TVEVOQ0lMXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfTFVNSU5BTkNFX0FMUEhBXSA9IDJcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9TUkdCX0VYVF0gPSAzXG5GT1JNQVRfQ0hBTk5FTFNbR0xfUkdCQSQxXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfU1JHQl9BTFBIQV9FWFRdID0gNFxuXG5mdW5jdGlvbiBvYmplY3ROYW1lIChzdHIpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBzdHIgKyAnXSdcbn1cblxudmFyIENBTlZBU19DTEFTUyA9IG9iamVjdE5hbWUoJ0hUTUxDYW52YXNFbGVtZW50JylcbnZhciBPRkZTQ1JFRU5DQU5WQVNfQ0xBU1MgPSBvYmplY3ROYW1lKCdPZmZzY3JlZW5DYW52YXMnKVxudmFyIENPTlRFWFQyRF9DTEFTUyA9IG9iamVjdE5hbWUoJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCcpXG52YXIgQklUTUFQX0NMQVNTID0gb2JqZWN0TmFtZSgnSW1hZ2VCaXRtYXAnKVxudmFyIElNQUdFX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTEltYWdlRWxlbWVudCcpXG52YXIgVklERU9fQ0xBU1MgPSBvYmplY3ROYW1lKCdIVE1MVmlkZW9FbGVtZW50JylcblxudmFyIFBJWEVMX0NMQVNTRVMgPSBPYmplY3Qua2V5cyhhcnJheVR5cGVzKS5jb25jYXQoW1xuICBDQU5WQVNfQ0xBU1MsXG4gIE9GRlNDUkVFTkNBTlZBU19DTEFTUyxcbiAgQ09OVEVYVDJEX0NMQVNTLFxuICBCSVRNQVBfQ0xBU1MsXG4gIElNQUdFX0NMQVNTLFxuICBWSURFT19DTEFTU1xuXSlcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIFRZUEVfU0laRVMgPSBbXVxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9CWVRFJDVdID0gMVxuVFlQRV9TSVpFU1tHTF9GTE9BVCQ0XSA9IDRcblRZUEVfU0laRVNbR0xfSEFMRl9GTE9BVF9PRVMkMV0gPSAyXG5cblRZUEVfU0laRVNbR0xfVU5TSUdORURfU0hPUlQkM10gPSAyXG5UWVBFX1NJWkVTW0dMX1VOU0lHTkVEX0lOVCQzXSA9IDRcblxudmFyIEZPUk1BVF9TSVpFU19TUEVDSUFMID0gW11cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQkE0XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQjVfQTFdID0gMlxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfUkdCNTY1XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0RFUFRIX1NURU5DSUxdID0gNFxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRdID0gMC41XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVF0gPSAxXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVF0gPSAxXG5cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTF0gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0xdID0gMVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xdID0gMVxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNR10gPSAwLjI1XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR10gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXSA9IDAuMjVcblxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTF0gPSAwLjVcblxuZnVuY3Rpb24gaXNOdW1lcmljQXJyYXkgKGFycikge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYXJyKSAmJlxuICAgIChhcnIubGVuZ3RoID09PSAwIHx8XG4gICAgdHlwZW9mIGFyclswXSA9PT0gJ251bWJlcicpKVxufVxuXG5mdW5jdGlvbiBpc1JlY3RBcnJheSAoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIHdpZHRoID0gYXJyLmxlbmd0aFxuICBpZiAod2lkdGggPT09IDAgfHwgIWlzQXJyYXlMaWtlKGFyclswXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyAoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpXG59XG5cbmZ1bmN0aW9uIGlzQ2FudmFzRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBDQU5WQVNfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNPZmZzY3JlZW5DYW52YXMgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gT0ZGU0NSRUVOQ0FOVkFTX0NMQVNTXG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dDJEIChvYmplY3QpIHtcbiAgcmV0dXJuIGNsYXNzU3RyaW5nKG9iamVjdCkgPT09IENPTlRFWFQyRF9DTEFTU1xufVxuXG5mdW5jdGlvbiBpc0JpdG1hcCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBCSVRNQVBfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNJbWFnZUVsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gSU1BR0VfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNWaWRlb0VsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gVklERU9fQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNQaXhlbERhdGEgKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBjbGFzc05hbWUgPSBjbGFzc1N0cmluZyhvYmplY3QpXG4gIGlmIChQSVhFTF9DTEFTU0VTLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gKFxuICAgIGlzTnVtZXJpY0FycmF5KG9iamVjdCkgfHxcbiAgICBpc1JlY3RBcnJheShvYmplY3QpIHx8XG4gICAgaXNOREFycmF5TGlrZShvYmplY3QpKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5Q29kZSQxIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREYXRhIChyZXN1bHQsIGRhdGEpIHtcbiAgdmFyIG4gPSBkYXRhLmxlbmd0aFxuICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgY2FzZSBHTF9VTlNJR05FRF9CWVRFJDU6XG4gICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQzOlxuICAgIGNhc2UgR0xfVU5TSUdORURfSU5UJDM6XG4gICAgY2FzZSBHTF9GTE9BVCQ0OlxuICAgICAgdmFyIGNvbnZlcnRlZCA9IHBvb2wuYWxsb2NUeXBlKHJlc3VsdC50eXBlLCBuKVxuICAgICAgY29udmVydGVkLnNldChkYXRhKVxuICAgICAgcmVzdWx0LmRhdGEgPSBjb252ZXJ0ZWRcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIEdMX0hBTEZfRkxPQVRfT0VTJDE6XG4gICAgICByZXN1bHQuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChkYXRhKVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjaGVjayQxLnJhaXNlKCd1bnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUsIG11c3Qgc3BlY2lmeSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVDb252ZXJ0IChpbWFnZSwgbikge1xuICByZXR1cm4gcG9vbC5hbGxvY1R5cGUoXG4gICAgaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMVxuICAgICAgPyBHTF9GTE9BVCQ0XG4gICAgICA6IGltYWdlLnR5cGUsIG4pXG59XG5cbmZ1bmN0aW9uIHBvc3RDb252ZXJ0IChpbWFnZSwgZGF0YSkge1xuICBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMSkge1xuICAgIGltYWdlLmRhdGEgPSBjb252ZXJ0VG9IYWxmRmxvYXQoZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2VEYXRhIChpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIG9mZnNldCkge1xuICB2YXIgdyA9IGltYWdlLndpZHRoXG4gIHZhciBoID0gaW1hZ2UuaGVpZ2h0XG4gIHZhciBjID0gaW1hZ2UuY2hhbm5lbHNcbiAgdmFyIG4gPSB3ICogaCAqIGNcbiAgdmFyIGRhdGEgPSBwcmVDb252ZXJ0KGltYWdlLCBuKVxuXG4gIHZhciBwID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdzsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGM7ICsraykge1xuICAgICAgICBkYXRhW3ArK10gPSBhcnJheVtzdHJpZGVYICogaiArIHN0cmlkZVkgKiBpICsgc3RyaWRlQyAqIGsgKyBvZmZzZXRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zdENvbnZlcnQoaW1hZ2UsIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVTaXplIChmb3JtYXQsIHR5cGUsIHdpZHRoLCBoZWlnaHQsIGlzTWlwbWFwLCBpc0N1YmUpIHtcbiAgdmFyIHNcbiAgaWYgKHR5cGVvZiBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdlIGhhdmUgYSBzcGVjaWFsIGFycmF5IGZvciBkZWFsaW5nIHdpdGggd2VpcmQgY29sb3IgZm9ybWF0cyBzdWNoIGFzIFJHQjVBMVxuICAgIHMgPSBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdXG4gIH0gZWxzZSB7XG4gICAgcyA9IEZPUk1BVF9DSEFOTkVMU1tmb3JtYXRdICogVFlQRV9TSVpFU1t0eXBlXVxuICB9XG5cbiAgaWYgKGlzQ3ViZSkge1xuICAgIHMgKj0gNlxuICB9XG5cbiAgaWYgKGlzTWlwbWFwKSB7XG4gICAgLy8gY29tcHV0ZSB0aGUgdG90YWwgc2l6ZSBvZiBhbGwgdGhlIG1pcG1hcHMuXG4gICAgdmFyIHRvdGFsID0gMFxuXG4gICAgdmFyIHcgPSB3aWR0aFxuICAgIHdoaWxlICh3ID49IDEpIHtcbiAgICAgIC8vIHdlIGNhbiBvbmx5IHVzZSBtaXBtYXBzIG9uIGEgc3F1YXJlIGltYWdlLFxuICAgICAgLy8gc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIHdpZHRoIGFuZCBpZ25vcmUgdGhlIGhlaWdodDpcbiAgICAgIHRvdGFsICs9IHMgKiB3ICogd1xuICAgICAgdyAvPSAyXG4gICAgfVxuICAgIHJldHVybiB0b3RhbFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzICogd2lkdGggKiBoZWlnaHRcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlU2V0IChcbiAgZ2wsIGV4dGVuc2lvbnMsIGxpbWl0cywgcmVnbFBvbGwsIGNvbnRleHRTdGF0ZSwgc3RhdHMsIGNvbmZpZykge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEluaXRpYWxpemUgY29uc3RhbnRzIGFuZCBwYXJhbWV0ZXIgdGFibGVzIGhlcmVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbWlwbWFwSGludCA9IHtcbiAgICBcImRvbid0IGNhcmVcIjogR0xfRE9OVF9DQVJFLFxuICAgICdkb250IGNhcmUnOiBHTF9ET05UX0NBUkUsXG4gICAgJ25pY2UnOiBHTF9OSUNFU1QsXG4gICAgJ2Zhc3QnOiBHTF9GQVNURVNUXG4gIH1cblxuICB2YXIgd3JhcE1vZGVzID0ge1xuICAgICdyZXBlYXQnOiBHTF9SRVBFQVQsXG4gICAgJ2NsYW1wJzogR0xfQ0xBTVBfVE9fRURHRSQxLFxuICAgICdtaXJyb3InOiBHTF9NSVJST1JFRF9SRVBFQVRcbiAgfVxuXG4gIHZhciBtYWdGaWx0ZXJzID0ge1xuICAgICduZWFyZXN0JzogR0xfTkVBUkVTVCQxLFxuICAgICdsaW5lYXInOiBHTF9MSU5FQVJcbiAgfVxuXG4gIHZhciBtaW5GaWx0ZXJzID0gZXh0ZW5kKHtcbiAgICAnbWlwbWFwJzogR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMSxcbiAgICAnbmVhcmVzdCBtaXBtYXAgbmVhcmVzdCc6IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QkMSxcbiAgICAnbGluZWFyIG1pcG1hcCBuZWFyZXN0JzogR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gICAgJ25lYXJlc3QgbWlwbWFwIGxpbmVhcic6IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxLFxuICAgICdsaW5lYXIgbWlwbWFwIGxpbmVhcic6IEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbiAgfSwgbWFnRmlsdGVycylcblxuICB2YXIgY29sb3JTcGFjZSA9IHtcbiAgICAnbm9uZSc6IDAsXG4gICAgJ2Jyb3dzZXInOiBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0xcbiAgfVxuXG4gIHZhciB0ZXh0dXJlVHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ1LFxuICAgICdyZ2JhNCc6IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSxcbiAgICAncmdiNTY1JzogR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSxcbiAgICAncmdiNSBhMSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEkMVxuICB9XG5cbiAgdmFyIHRleHR1cmVGb3JtYXRzID0ge1xuICAgICdhbHBoYSc6IEdMX0FMUEhBLFxuICAgICdsdW1pbmFuY2UnOiBHTF9MVU1JTkFOQ0UsXG4gICAgJ2x1bWluYW5jZSBhbHBoYSc6IEdMX0xVTUlOQU5DRV9BTFBIQSxcbiAgICAncmdiJzogR0xfUkdCLFxuICAgICdyZ2JhJzogR0xfUkdCQSQxLFxuICAgICdyZ2JhNCc6IEdMX1JHQkE0LFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSxcbiAgICAncmdiNTY1JzogR0xfUkdCNTY1XG4gIH1cblxuICB2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0ge31cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfc3JnYikge1xuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2IgPSBHTF9TUkdCX0VYVFxuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2JhID0gR0xfU1JHQl9BTFBIQV9FWFRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzLmZsb2F0MzIgPSB0ZXh0dXJlVHlwZXMuZmxvYXQgPSBHTF9GTE9BVCQ0XG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzWydmbG9hdDE2J10gPSB0ZXh0dXJlVHlwZXNbJ2hhbGYgZmxvYXQnXSA9IEdMX0hBTEZfRkxPQVRfT0VTJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUpIHtcbiAgICBleHRlbmQodGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVCxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfREVQVEhfU1RFTkNJTFxuICAgIH0pXG5cbiAgICBleHRlbmQodGV4dHVyZVR5cGVzLCB7XG4gICAgICAndWludDE2JzogR0xfVU5TSUdORURfU0hPUlQkMyxcbiAgICAgICd1aW50MzInOiBHTF9VTlNJR05FRF9JTlQkMyxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wkMVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgczN0YyBkeHQxJzogR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCxcbiAgICAgICdyZ2JhIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICAgICAgJ3JnYmEgczN0YyBkeHQzJzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gICAgICAncmdiYSBzM3RjIGR4dDUnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfYXRjKSB7XG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBhdGMnOiBHTF9DT01QUkVTU0VEX1JHQl9BVENfV0VCR0wsXG4gICAgICAncmdiYSBhdGMgZXhwbGljaXQgYWxwaGEnOiBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMLFxuICAgICAgJ3JnYmEgYXRjIGludGVycG9sYXRlZCBhbHBoYSc6IEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyxcbiAgICAgICdyZ2IgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyxcbiAgICAgICdyZ2JhIHB2cnRjIDRicHB2MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HLFxuICAgICAgJ3JnYmEgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcbiAgICB9KVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEpIHtcbiAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHNbJ3JnYiBldGMxJ10gPSBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMXG4gIH1cblxuICAvLyBDb3B5IG92ZXIgYWxsIHRleHR1cmUgZm9ybWF0c1xuICB2YXIgc3VwcG9ydGVkQ29tcHJlc3NlZEZvcm1hdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMpKVxuICBPYmplY3Qua2V5cyhjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzW25hbWVdXG4gICAgaWYgKHN1cHBvcnRlZENvbXByZXNzZWRGb3JtYXRzLmluZGV4T2YoZm9ybWF0KSA+PSAwKSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIH1cbiAgfSlcblxuICB2YXIgc3VwcG9ydGVkRm9ybWF0cyA9IE9iamVjdC5rZXlzKHRleHR1cmVGb3JtYXRzKVxuICBsaW1pdHMudGV4dHVyZUZvcm1hdHMgPSBzdXBwb3J0ZWRGb3JtYXRzXG5cbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgZm9ybWF0IHN0cmluZyBpdHNcbiAgLy8gY29ycmVzcG9uZGluZyBHTC12YWx1ZS5cbiAgdmFyIHRleHR1cmVGb3JtYXRzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB0ZXh0dXJlRm9ybWF0c1trZXldXG4gICAgdGV4dHVyZUZvcm1hdHNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIC8vIGFzc29jaWF0ZSB3aXRoIGV2ZXJ5IHR5cGUgc3RyaW5nIGl0c1xuICAvLyBjb3JyZXNwb25kaW5nIEdMLXZhbHVlLlxuICB2YXIgdGV4dHVyZVR5cGVzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gdGV4dHVyZVR5cGVzW2tleV1cbiAgICB0ZXh0dXJlVHlwZXNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtYWdGaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWFnRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1hZ0ZpbHRlcnNba2V5XVxuICAgIG1hZ0ZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtaW5GaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWluRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1pbkZpbHRlcnNba2V5XVxuICAgIG1pbkZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciB3cmFwTW9kZXNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyh3cmFwTW9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB3cmFwTW9kZXNba2V5XVxuICAgIHdyYXBNb2Rlc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgLy8gY29sb3JGb3JtYXRzW10gZ2l2ZXMgdGhlIGZvcm1hdCAoY2hhbm5lbHMpIGFzc29jaWF0ZWQgdG8gYW5cbiAgLy8gaW50ZXJuYWxmb3JtYXRcbiAgdmFyIGNvbG9yRm9ybWF0cyA9IHN1cHBvcnRlZEZvcm1hdHMucmVkdWNlKGZ1bmN0aW9uIChjb2xvciwga2V5KSB7XG4gICAgdmFyIGdsZW51bSA9IHRleHR1cmVGb3JtYXRzW2tleV1cbiAgICBpZiAoZ2xlbnVtID09PSBHTF9MVU1JTkFOQ0UgfHxcbiAgICAgICAgZ2xlbnVtID09PSBHTF9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRV9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX1NURU5DSUwgfHxcbiAgICAgICAgKGV4dGVuc2lvbnMuZXh0X3NyZ2IgJiZcbiAgICAgICAgICAgICAgICAoZ2xlbnVtID09PSBHTF9TUkdCX0VYVCB8fFxuICAgICAgICAgICAgICAgICBnbGVudW0gPT09IEdMX1NSR0JfQUxQSEFfRVhUKSkpIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBnbGVudW1cbiAgICB9IGVsc2UgaWYgKGdsZW51bSA9PT0gR0xfUkdCNV9BMSB8fCBrZXkuaW5kZXhPZigncmdiYScpID49IDApIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JBJDFcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JbZ2xlbnVtXSA9IEdMX1JHQlxuICAgIH1cbiAgICByZXR1cm4gY29sb3JcbiAgfSwge30pXG5cbiAgZnVuY3Rpb24gVGV4RmxhZ3MgKCkge1xuICAgIC8vIGZvcm1hdCBpbmZvXG4gICAgdGhpcy5pbnRlcm5hbGZvcm1hdCA9IEdMX1JHQkEkMVxuICAgIHRoaXMuZm9ybWF0ID0gR0xfUkdCQSQxXG4gICAgdGhpcy50eXBlID0gR0xfVU5TSUdORURfQllURSQ1XG4gICAgdGhpcy5jb21wcmVzc2VkID0gZmFsc2VcblxuICAgIC8vIHBpeGVsIHN0b3JhZ2VcbiAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZVxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZVxuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMVxuICAgIHRoaXMuY29sb3JTcGFjZSA9IEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTFxuXG4gICAgLy8gc2hhcGUgaW5mb1xuICAgIHRoaXMud2lkdGggPSAwXG4gICAgdGhpcy5oZWlnaHQgPSAwXG4gICAgdGhpcy5jaGFubmVscyA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlGbGFncyAocmVzdWx0LCBvdGhlcikge1xuICAgIHJlc3VsdC5pbnRlcm5hbGZvcm1hdCA9IG90aGVyLmludGVybmFsZm9ybWF0XG4gICAgcmVzdWx0LmZvcm1hdCA9IG90aGVyLmZvcm1hdFxuICAgIHJlc3VsdC50eXBlID0gb3RoZXIudHlwZVxuICAgIHJlc3VsdC5jb21wcmVzc2VkID0gb3RoZXIuY29tcHJlc3NlZFxuXG4gICAgcmVzdWx0LnByZW11bHRpcGx5QWxwaGEgPSBvdGhlci5wcmVtdWx0aXBseUFscGhhXG4gICAgcmVzdWx0LmZsaXBZID0gb3RoZXIuZmxpcFlcbiAgICByZXN1bHQudW5wYWNrQWxpZ25tZW50ID0gb3RoZXIudW5wYWNrQWxpZ25tZW50XG4gICAgcmVzdWx0LmNvbG9yU3BhY2UgPSBvdGhlci5jb2xvclNwYWNlXG5cbiAgICByZXN1bHQud2lkdGggPSBvdGhlci53aWR0aFxuICAgIHJlc3VsdC5oZWlnaHQgPSBvdGhlci5oZWlnaHRcbiAgICByZXN1bHQuY2hhbm5lbHMgPSBvdGhlci5jaGFubmVsc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGbGFncyAoZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8ICFvcHRpb25zKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoJ3ByZW11bHRpcGx5QWxwaGEnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLnByZW11bHRpcGx5QWxwaGEsICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgcHJlbXVsdGlwbHlBbHBoYScpXG4gICAgICBmbGFncy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhXG4gICAgfVxuXG4gICAgaWYgKCdmbGlwWScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZmxpcFksICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSBmbGlwJylcbiAgICAgIGZsYWdzLmZsaXBZID0gb3B0aW9ucy5mbGlwWVxuICAgIH1cblxuICAgIGlmICgnYWxpZ25tZW50JyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLm9uZU9mKG9wdGlvbnMuYWxpZ25tZW50LCBbMSwgMiwgNCwgOF0sXG4gICAgICAgICdpbnZhbGlkIHRleHR1cmUgdW5wYWNrIGFsaWdubWVudCcpXG4gICAgICBmbGFncy51bnBhY2tBbGlnbm1lbnQgPSBvcHRpb25zLmFsaWdubWVudFxuICAgIH1cblxuICAgIGlmICgnY29sb3JTcGFjZScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy5jb2xvclNwYWNlLCBjb2xvclNwYWNlLFxuICAgICAgICAnaW52YWxpZCBjb2xvclNwYWNlJylcbiAgICAgIGZsYWdzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlW29wdGlvbnMuY29sb3JTcGFjZV1cbiAgICB9XG5cbiAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQgfHxcbiAgICAgICAgISh0eXBlID09PSAnZmxvYXQnIHx8IHR5cGUgPT09ICdmbG9hdDMyJyksXG4gICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBPRVNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCB8fFxuICAgICAgICAhKHR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCB0eXBlID09PSAnZmxvYXQxNicpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIDE2LWJpdCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4nKVxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcbiAgICAgICAgISh0eXBlID09PSAndWludDE2JyB8fCB0eXBlID09PSAndWludDMyJyB8fCB0eXBlID09PSAnZGVwdGggc3RlbmNpbCcpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJylcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHR5cGUsIHRleHR1cmVUeXBlcyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSB0eXBlJylcbiAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbdHlwZV1cbiAgICB9XG5cbiAgICB2YXIgdyA9IGZsYWdzLndpZHRoXG4gICAgdmFyIGggPSBmbGFncy5oZWlnaHRcbiAgICB2YXIgYyA9IGZsYWdzLmNoYW5uZWxzXG4gICAgdmFyIGhhc0NoYW5uZWxzID0gZmFsc2VcbiAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zaGFwZSkgJiYgb3B0aW9ucy5zaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgJ3NoYXBlIG11c3QgYmUgYW4gYXJyYXknKVxuICAgICAgdyA9IG9wdGlvbnMuc2hhcGVbMF1cbiAgICAgIGggPSBvcHRpb25zLnNoYXBlWzFdXG4gICAgICBpZiAob3B0aW9ucy5zaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYyA9IG9wdGlvbnMuc2hhcGVbMl1cbiAgICAgICAgY2hlY2skMShjID4gMCAmJiBjIDw9IDQsICdpbnZhbGlkIG51bWJlciBvZiBjaGFubmVscycpXG4gICAgICAgIGhhc0NoYW5uZWxzID0gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hlY2skMSh3ID49IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIHdpZHRoJylcbiAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ3JhZGl1cycgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgIGNoZWNrJDEodyA+PSAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCByYWRpdXMnKVxuICAgICAgfVxuICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gb3B0aW9ucy53aWR0aFxuICAgICAgICBjaGVjayQxKHcgPj0gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSwgJ2ludmFsaWQgd2lkdGgnKVxuICAgICAgfVxuICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgICAgfVxuICAgICAgaWYgKCdjaGFubmVscycgaW4gb3B0aW9ucykge1xuICAgICAgICBjID0gb3B0aW9ucy5jaGFubmVsc1xuICAgICAgICBjaGVjayQxKGMgPiAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzJylcbiAgICAgICAgaGFzQ2hhbm5lbHMgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGZsYWdzLndpZHRoID0gdyB8IDBcbiAgICBmbGFncy5oZWlnaHQgPSBoIHwgMFxuICAgIGZsYWdzLmNoYW5uZWxzID0gYyB8IDBcblxuICAgIHZhciBoYXNGb3JtYXQgPSBmYWxzZVxuICAgIGlmICgnZm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgZm9ybWF0U3RyID0gb3B0aW9ucy5mb3JtYXRcbiAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlIHx8XG4gICAgICAgICEoZm9ybWF0U3RyID09PSAnZGVwdGgnIHx8IGZvcm1hdFN0ciA9PT0gJ2RlcHRoIHN0ZW5jaWwnKSxcbiAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIFdFQkdMX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBkZXB0aC9zdGVuY2lsIHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihmb3JtYXRTdHIsIHRleHR1cmVGb3JtYXRzLFxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIGZvcm1hdCcpXG4gICAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBmbGFncy5pbnRlcm5hbGZvcm1hdCA9IHRleHR1cmVGb3JtYXRzW2Zvcm1hdFN0cl1cbiAgICAgIGZsYWdzLmZvcm1hdCA9IGNvbG9yRm9ybWF0c1tpbnRlcm5hbGZvcm1hdF1cbiAgICAgIGlmIChmb3JtYXRTdHIgaW4gdGV4dHVyZVR5cGVzKSB7XG4gICAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbZm9ybWF0U3RyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0U3RyIGluIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykge1xuICAgICAgICBmbGFncy5jb21wcmVzc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaGFzRm9ybWF0ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFJlY29uY2lsZSBjaGFubmVscyBhbmQgZm9ybWF0XG4gICAgaWYgKCFoYXNDaGFubmVscyAmJiBoYXNGb3JtYXQpIHtcbiAgICAgIGZsYWdzLmNoYW5uZWxzID0gRk9STUFUX0NIQU5ORUxTW2ZsYWdzLmZvcm1hdF1cbiAgICB9IGVsc2UgaWYgKGhhc0NoYW5uZWxzICYmICFoYXNGb3JtYXQpIHtcbiAgICAgIGlmIChmbGFncy5jaGFubmVscyAhPT0gQ0hBTk5FTFNfRk9STUFUW2ZsYWdzLmZvcm1hdF0pIHtcbiAgICAgICAgZmxhZ3MuZm9ybWF0ID0gZmxhZ3MuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbZmxhZ3MuY2hhbm5lbHNdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNGb3JtYXQgJiYgaGFzQ2hhbm5lbHMpIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZsYWdzLmNoYW5uZWxzID09PSBGT1JNQVRfQ0hBTk5FTFNbZmxhZ3MuZm9ybWF0XSxcbiAgICAgICAgJ251bWJlciBvZiBjaGFubmVscyBpbmNvbnNpc3RlbnQgd2l0aCBzcGVjaWZpZWQgZm9ybWF0JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmbGFncy5mbGlwWSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZsYWdzLnByZW11bHRpcGx5QWxwaGEpXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZmxhZ3MuY29sb3JTcGFjZSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQUxJR05NRU5ULCBmbGFncy51bnBhY2tBbGlnbm1lbnQpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRleCBpbWFnZSBkYXRhXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gVGV4SW1hZ2UgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMueE9mZnNldCA9IDBcbiAgICB0aGlzLnlPZmZzZXQgPSAwXG5cbiAgICAvLyBkYXRhXG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICAgIHRoaXMubmVlZHNGcmVlID0gZmFsc2VcblxuICAgIC8vIGh0bWwgZWxlbWVudFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcblxuICAgIC8vIGNvcHlUZXhJbWFnZSBpbmZvXG4gICAgdGhpcy5uZWVkc0NvcHkgPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJbWFnZSAoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGRhdGEgPSBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIHBpeGVsIGRhdGEgdHlwZScpXG4gICAgICBwYXJzZUZsYWdzKGltYWdlLCBvcHRpb25zKVxuICAgICAgaWYgKCd4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGltYWdlLnhPZmZzZXQgPSBvcHRpb25zLnggfCAwXG4gICAgICB9XG4gICAgICBpZiAoJ3knIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaW1hZ2UueU9mZnNldCA9IG9wdGlvbnMueSB8IDBcbiAgICAgIH1cbiAgICAgIGlmIChpc1BpeGVsRGF0YShvcHRpb25zLmRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayQxKFxuICAgICAgIWltYWdlLmNvbXByZXNzZWQgfHxcbiAgICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgJ2NvbXByZXNzZWQgdGV4dHVyZSBkYXRhIG11c3QgYmUgc3RvcmVkIGluIGEgdWludDhhcnJheScpXG5cbiAgICBpZiAob3B0aW9ucy5jb3B5KSB7XG4gICAgICBjaGVjayQxKCFkYXRhLCAnY2FuIG5vdCBzcGVjaWZ5IGNvcHkgYW5kIGRhdGEgZmllbGQgZm9yIHRoZSBzYW1lIHRleHR1cmUnKVxuICAgICAgdmFyIHZpZXdXID0gY29udGV4dFN0YXRlLnZpZXdwb3J0V2lkdGhcbiAgICAgIHZhciB2aWV3SCA9IGNvbnRleHRTdGF0ZS52aWV3cG9ydEhlaWdodFxuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAodmlld1cgLSBpbWFnZS54T2Zmc2V0KVxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IHx8ICh2aWV3SCAtIGltYWdlLnlPZmZzZXQpXG4gICAgICBpbWFnZS5uZWVkc0NvcHkgPSB0cnVlXG4gICAgICBjaGVjayQxKGltYWdlLnhPZmZzZXQgPj0gMCAmJiBpbWFnZS54T2Zmc2V0IDwgdmlld1cgJiZcbiAgICAgICAgICAgIGltYWdlLnlPZmZzZXQgPj0gMCAmJiBpbWFnZS55T2Zmc2V0IDwgdmlld0ggJiZcbiAgICAgICAgICAgIGltYWdlLndpZHRoID4gMCAmJiBpbWFnZS53aWR0aCA8PSB2aWV3VyAmJlxuICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0ID4gMCAmJiBpbWFnZS5oZWlnaHQgPD0gdmlld0gsXG4gICAgICAnY29weSB0ZXh0dXJlIHJlYWQgb3V0IG9mIGJvdW5kcycpXG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAxXG4gICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgMVxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBpbWFnZS5jaGFubmVscyB8fCA0XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gaW1hZ2UuY2hhbm5lbHMgfHwgNFxuICAgICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSAmJiBpbWFnZS50eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDUpIHtcbiAgICAgICAgaW1hZ2UudHlwZSA9IHR5cGVkQXJyYXlDb2RlJDEoZGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTnVtZXJpY0FycmF5KGRhdGEpKSB7XG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDRcbiAgICAgIGNvbnZlcnREYXRhKGltYWdlLCBkYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgdmFyIGFycmF5ID0gZGF0YS5kYXRhXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpICYmIGltYWdlLnR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNSkge1xuICAgICAgICBpbWFnZS50eXBlID0gdHlwZWRBcnJheUNvZGUkMShhcnJheSlcbiAgICAgIH1cbiAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIHNoYXBlWCwgc2hhcGVZLCBzaGFwZUMsIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUNcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc2hhcGVDID0gc2hhcGVbMl1cbiAgICAgICAgc3RyaWRlQyA9IHN0cmlkZVsyXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMShzaGFwZS5sZW5ndGggPT09IDIsICdpbnZhbGlkIG5kYXJyYXkgcGl4ZWwgZGF0YSwgbXVzdCBiZSAyIG9yIDNEJylcbiAgICAgICAgc2hhcGVDID0gMVxuICAgICAgICBzdHJpZGVDID0gMVxuICAgICAgfVxuICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgIHNoYXBlWSA9IHNoYXBlWzFdXG4gICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICBzdHJpZGVZID0gc3RyaWRlWzFdXG4gICAgICBpbWFnZS5hbGlnbm1lbnQgPSAxXG4gICAgICBpbWFnZS53aWR0aCA9IHNoYXBlWFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gc2hhcGVZXG4gICAgICBpbWFnZS5jaGFubmVscyA9IHNoYXBlQ1xuICAgICAgaW1hZ2UuZm9ybWF0ID0gaW1hZ2UuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbc2hhcGVDXVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgICAgdHJhbnNwb3NlRGF0YShpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIGRhdGEub2Zmc2V0KVxuICAgIH0gZWxzZSBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpIHx8IGlzQ29udGV4dDJEKGRhdGEpKSB7XG4gICAgICBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpKSB7XG4gICAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YS5jYW52YXNcbiAgICAgIH1cbiAgICAgIGltYWdlLndpZHRoID0gaW1hZ2UuZWxlbWVudC53aWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuZWxlbWVudC5oZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNCaXRtYXAoZGF0YSkpIHtcbiAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICBpbWFnZS53aWR0aCA9IGRhdGEud2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEuaGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzSW1hZ2VFbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLm5hdHVyYWxXaWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS5uYXR1cmFsSGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzVmlkZW9FbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLnZpZGVvV2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEudmlkZW9IZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNSZWN0QXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciB3ID0gaW1hZ2Uud2lkdGggfHwgZGF0YVswXS5sZW5ndGhcbiAgICAgIHZhciBoID0gaW1hZ2UuaGVpZ2h0IHx8IGRhdGEubGVuZ3RoXG4gICAgICB2YXIgYyA9IGltYWdlLmNoYW5uZWxzXG4gICAgICBpZiAoaXNBcnJheUxpa2UoZGF0YVswXVswXSkpIHtcbiAgICAgICAgYyA9IGMgfHwgZGF0YVswXVswXS5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBjIHx8IDFcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlKGRhdGEpXG4gICAgICB2YXIgbiA9IDFcbiAgICAgIGZvciAodmFyIGRkID0gMDsgZGQgPCBhcnJheVNoYXBlLmxlbmd0aDsgKytkZCkge1xuICAgICAgICBuICo9IGFycmF5U2hhcGVbZGRdXG4gICAgICB9XG4gICAgICB2YXIgYWxsb2NEYXRhID0gcHJlQ29udmVydChpbWFnZSwgbilcbiAgICAgIGZsYXR0ZW5VdGlscy5mbGF0dGVuKGRhdGEsIGFycmF5U2hhcGUsICcnLCBhbGxvY0RhdGEpXG4gICAgICBwb3N0Q29udmVydChpbWFnZSwgYWxsb2NEYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2Uud2lkdGggPSB3XG4gICAgICBpbWFnZS5oZWlnaHQgPSBoXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGNcbiAgICAgIGltYWdlLmZvcm1hdCA9IGltYWdlLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW2NdXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGltYWdlLnR5cGUgPT09IEdMX0ZMT0FUJDQpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfZmxvYXQnKSA+PSAwLFxuICAgICAgICAnb2VzX3RleHR1cmVfZmxvYXQgZXh0ZW5zaW9uIG5vdCBlbmFibGVkJylcbiAgICB9IGVsc2UgaWYgKGltYWdlLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTJDEpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfaGFsZl9mbG9hdCcpID49IDAsXG4gICAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IGV4dGVuc2lvbiBub3QgZW5hYmxlZCcpXG4gICAgfVxuXG4gICAgLy8gZG8gY29tcHJlc3NlZCB0ZXh0dXJlICB2YWxpZGF0aW9uIGhlcmUuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbWFnZSAoaW5mbywgdGFyZ2V0LCBtaXBsZXZlbCkge1xuICAgIHZhciBlbGVtZW50ID0gaW5mby5lbGVtZW50XG4gICAgdmFyIGRhdGEgPSBpbmZvLmRhdGFcbiAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBpbmZvLmludGVybmFsZm9ybWF0XG4gICAgdmFyIGZvcm1hdCA9IGluZm8uZm9ybWF0XG4gICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVcbiAgICB2YXIgd2lkdGggPSBpbmZvLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGluZm8uaGVpZ2h0XG5cbiAgICBzZXRGbGFncyhpbmZvKVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBkYXRhKVxuICAgIH0gZWxzZSBpZiAoaW5mby5uZWVkc0NvcHkpIHtcbiAgICAgIHJlZ2xQb2xsKClcbiAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCBmb3JtYXQsIGluZm8ueE9mZnNldCwgaW5mby55T2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBkYXRhIHx8IG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3ViSW1hZ2UgKGluZm8sIHRhcmdldCwgeCwgeSwgbWlwbGV2ZWwpIHtcbiAgICB2YXIgZWxlbWVudCA9IGluZm8uZWxlbWVudFxuICAgIHZhciBkYXRhID0gaW5mby5kYXRhXG4gICAgdmFyIGludGVybmFsZm9ybWF0ID0gaW5mby5pbnRlcm5hbGZvcm1hdFxuICAgIHZhciBmb3JtYXQgPSBpbmZvLmZvcm1hdFxuICAgIHZhciB0eXBlID0gaW5mby50eXBlXG4gICAgdmFyIHdpZHRoID0gaW5mby53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBpbmZvLmhlaWdodFxuXG4gICAgc2V0RmxhZ3MoaW5mbylcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbiAgICB9IGVsc2UgaWYgKGluZm8ubmVlZHNDb3B5KSB7XG4gICAgICByZWdsUG9sbCgpXG4gICAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgeCwgeSwgaW5mby54T2Zmc2V0LCBpbmZvLnlPZmZzZXQsIHdpZHRoLCBoZWlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyB0ZXhJbWFnZSBwb29sXG4gIHZhciBpbWFnZVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jSW1hZ2UgKCkge1xuICAgIHJldHVybiBpbWFnZVBvb2wucG9wKCkgfHwgbmV3IFRleEltYWdlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVJbWFnZSAoaW1hZ2UpIHtcbiAgICBpZiAoaW1hZ2UubmVlZHNGcmVlKSB7XG4gICAgICBwb29sLmZyZWVUeXBlKGltYWdlLmRhdGEpXG4gICAgfVxuICAgIFRleEltYWdlLmNhbGwoaW1hZ2UpXG4gICAgaW1hZ2VQb29sLnB1c2goaW1hZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE1pcCBtYXBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBNaXBNYXAgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gICAgdGhpcy5taXBtYXNrID0gMFxuICAgIHRoaXMuaW1hZ2VzID0gQXJyYXkoMTYpXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pcE1hcEZyb21TaGFwZSAobWlwbWFwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGltZyA9IG1pcG1hcC5pbWFnZXNbMF0gPSBhbGxvY0ltYWdlKClcbiAgICBtaXBtYXAubWlwbWFzayA9IDFcbiAgICBpbWcud2lkdGggPSBtaXBtYXAud2lkdGggPSB3aWR0aFxuICAgIGltZy5oZWlnaHQgPSBtaXBtYXAuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgaW1nLmNoYW5uZWxzID0gbWlwbWFwLmNoYW5uZWxzID0gNFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaXBNYXBGcm9tT2JqZWN0IChtaXBtYXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW1nRGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGltZ0RhdGEgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBvcHRpb25zKVxuICAgICAgbWlwbWFwLm1pcG1hc2sgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlRmxhZ3MobWlwbWFwLCBvcHRpb25zKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApKSB7XG4gICAgICAgIHZhciBtaXBEYXRhID0gb3B0aW9ucy5taXBtYXBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXBEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbaV0gPSBhbGxvY0ltYWdlKClcbiAgICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICAgIGltZ0RhdGEud2lkdGggPj49IGlcbiAgICAgICAgICBpbWdEYXRhLmhlaWdodCA+Pj0gaVxuICAgICAgICAgIHBhcnNlSW1hZ2UoaW1nRGF0YSwgbWlwRGF0YVtpXSlcbiAgICAgICAgICBtaXBtYXAubWlwbWFzayB8PSAoMSA8PCBpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWdEYXRhID0gbWlwbWFwLmltYWdlc1swXSA9IGFsbG9jSW1hZ2UoKVxuICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICBwYXJzZUltYWdlKGltZ0RhdGEsIG9wdGlvbnMpXG4gICAgICAgIG1pcG1hcC5taXBtYXNrID0gMVxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5RmxhZ3MobWlwbWFwLCBtaXBtYXAuaW1hZ2VzWzBdKVxuXG4gICAgLy8gRm9yIHRleHR1cmVzIG9mIHRoZSBjb21wcmVzc2VkIGZvcm1hdCBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgIC8vIHdlIG11c3QgaGF2ZSB0aGF0XG4gICAgLy9cbiAgICAvLyBcIldoZW4gbGV2ZWwgZXF1YWxzIHplcm8gd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAgICAvLyBXaGVuIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiAwIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSAwLCAxLCAyIG9yIGEgbXVsdGlwbGUgb2YgNC4gXCJcbiAgICAvL1xuICAgIC8vIGJ1dCB3ZSBkbyBub3QgeWV0IHN1cHBvcnQgaGF2aW5nIG11bHRpcGxlIG1pcG1hcCBsZXZlbHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMsXG4gICAgLy8gc28gd2Ugb25seSB0ZXN0IGZvciBsZXZlbCB6ZXJvLlxuXG4gICAgaWYgKFxuICAgICAgbWlwbWFwLmNvbXByZXNzZWQgJiZcbiAgICAgIChcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUIHx8XG4gICAgICAgIG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQgfHxcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCB8fFxuICAgICAgICBtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG4gICAgICApXG4gICAgKSB7XG4gICAgICBjaGVjayQxKG1pcG1hcC53aWR0aCAlIDQgPT09IDAgJiYgbWlwbWFwLmhlaWdodCAlIDQgPT09IDAsXG4gICAgICAgICdmb3IgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHMsIG1pcG1hcCBsZXZlbCAwIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgYXJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWlwTWFwIChtaXBtYXAsIHRhcmdldCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghaW1hZ2VzW2ldKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2V0SW1hZ2UoaW1hZ2VzW2ldLCB0YXJnZXQsIGkpXG4gICAgfVxuICB9XG5cbiAgdmFyIG1pcFBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jTWlwTWFwICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWlwUG9vbC5wb3AoKSB8fCBuZXcgTWlwTWFwKClcbiAgICBUZXhGbGFncy5jYWxsKHJlc3VsdClcbiAgICByZXN1bHQubWlwbWFzayA9IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHJlc3VsdC5pbWFnZXNbaV0gPSBudWxsXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVNaXBNYXAgKG1pcG1hcCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpbWFnZXNbaV0pIHtcbiAgICAgICAgZnJlZUltYWdlKGltYWdlc1tpXSlcbiAgICAgIH1cbiAgICAgIGltYWdlc1tpXSA9IG51bGxcbiAgICB9XG4gICAgbWlwUG9vbC5wdXNoKG1pcG1hcClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGV4IGluZm9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBUZXhJbmZvICgpIHtcbiAgICB0aGlzLm1pbkZpbHRlciA9IEdMX05FQVJFU1QkMVxuICAgIHRoaXMubWFnRmlsdGVyID0gR0xfTkVBUkVTVCQxXG5cbiAgICB0aGlzLndyYXBTID0gR0xfQ0xBTVBfVE9fRURHRSQxXG4gICAgdGhpcy53cmFwVCA9IEdMX0NMQU1QX1RPX0VER0UkMVxuXG4gICAgdGhpcy5hbmlzb3Ryb3BpYyA9IDFcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRleEluZm8gKGluZm8sIG9wdGlvbnMpIHtcbiAgICBpZiAoJ21pbicgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1pbkZpbHRlciA9IG9wdGlvbnMubWluXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtaW5GaWx0ZXIsIG1pbkZpbHRlcnMpXG4gICAgICBpbmZvLm1pbkZpbHRlciA9IG1pbkZpbHRlcnNbbWluRmlsdGVyXVxuICAgICAgaWYgKE1JUE1BUF9GSUxURVJTLmluZGV4T2YoaW5mby5taW5GaWx0ZXIpID49IDAgJiYgISgnZmFjZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ21hZycgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtYWdGaWx0ZXIsIG1hZ0ZpbHRlcnMpXG4gICAgICBpbmZvLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcnNbbWFnRmlsdGVyXVxuICAgIH1cblxuICAgIHZhciB3cmFwUyA9IGluZm8ud3JhcFNcbiAgICB2YXIgd3JhcFQgPSBpbmZvLndyYXBUXG4gICAgaWYgKCd3cmFwJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgd3JhcCA9IG9wdGlvbnMud3JhcFxuICAgICAgaWYgKHR5cGVvZiB3cmFwID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcFQgPSB3cmFwTW9kZXNbd3JhcF1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh3cmFwKSkge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwWzBdLCB3cmFwTW9kZXMpXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXBbMV0sIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFMgPSB3cmFwTW9kZXNbd3JhcFswXV1cbiAgICAgICAgd3JhcFQgPSB3cmFwTW9kZXNbd3JhcFsxXV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCd3cmFwUycgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFMgPSBvcHRpb25zLndyYXBTXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBTLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcE1vZGVzW29wdFdyYXBTXVxuICAgICAgfVxuICAgICAgaWYgKCd3cmFwVCcgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFQgPSBvcHRpb25zLndyYXBUXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBULCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBUID0gd3JhcE1vZGVzW29wdFdyYXBUXVxuICAgICAgfVxuICAgIH1cbiAgICBpbmZvLndyYXBTID0gd3JhcFNcbiAgICBpbmZvLndyYXBUID0gd3JhcFRcblxuICAgIGlmICgnYW5pc290cm9waWMnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhbmlzb3Ryb3BpYyA9IG9wdGlvbnMuYW5pc290cm9waWNcbiAgICAgIGNoZWNrJDEodHlwZW9mIGFuaXNvdHJvcGljID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgYW5pc290cm9waWMgPj0gMSAmJiBhbmlzb3Ryb3BpYyA8PSBsaW1pdHMubWF4QW5pc290cm9waWMsXG4gICAgICAnYW5pc28gc2FtcGxlcyBtdXN0IGJlIGJldHdlZW4gMSBhbmQgJylcbiAgICAgIGluZm8uYW5pc290cm9waWMgPSBvcHRpb25zLmFuaXNvdHJvcGljXG4gICAgfVxuXG4gICAgaWYgKCdtaXBtYXAnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoYXNNaXBNYXAgPSBmYWxzZVxuICAgICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucy5taXBtYXApIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLm1pcG1hcCwgbWlwbWFwSGludCxcbiAgICAgICAgICAgICdpbnZhbGlkIG1pcG1hcCBoaW50JylcbiAgICAgICAgICBpbmZvLm1pcG1hcEhpbnQgPSBtaXBtYXBIaW50W29wdGlvbnMubWlwbWFwXVxuICAgICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICBoYXNNaXBNYXAgPSBpbmZvLmdlbk1pcG1hcHMgPSBvcHRpb25zLm1pcG1hcFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApLCAnaW52YWxpZCBtaXBtYXAgdHlwZScpXG4gICAgICAgICAgaW5mby5nZW5NaXBtYXBzID0gZmFsc2VcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgbWlwbWFwIHR5cGUnKVxuICAgICAgfVxuICAgICAgaWYgKGhhc01pcE1hcCAmJiAhKCdtaW4nIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8ubWluRmlsdGVyID0gR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4SW5mbyAoaW5mbywgdGFyZ2V0KSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgaW5mby5taW5GaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiwgaW5mby5tYWdGaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9TLCBpbmZvLndyYXBTKVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX1dSQVBfVCwgaW5mby53cmFwVClcbiAgICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgaW5mby5hbmlzb3Ryb3BpYylcbiAgICB9XG4gICAgaWYgKGluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgZ2wuaGludChHTF9HRU5FUkFURV9NSVBNQVBfSElOVCwgaW5mby5taXBtYXBIaW50KVxuICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRnVsbCB0ZXh0dXJlIG9iamVjdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciB0ZXh0dXJlQ291bnQgPSAwXG4gIHZhciB0ZXh0dXJlU2V0ID0ge31cbiAgdmFyIG51bVRleFVuaXRzID0gbGltaXRzLm1heFRleHR1cmVVbml0c1xuICB2YXIgdGV4dHVyZVVuaXRzID0gQXJyYXkobnVtVGV4VW5pdHMpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSlcblxuICBmdW5jdGlvbiBSRUdMVGV4dHVyZSAodGFyZ2V0KSB7XG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKVxuICAgIHRoaXMubWlwbWFzayA9IDBcbiAgICB0aGlzLmludGVybmFsZm9ybWF0ID0gR0xfUkdCQSQxXG5cbiAgICB0aGlzLmlkID0gdGV4dHVyZUNvdW50KytcblxuICAgIHRoaXMucmVmQ291bnQgPSAxXG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFxuICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuXG4gICAgdGhpcy51bml0ID0gLTFcbiAgICB0aGlzLmJpbmRDb3VudCA9IDBcblxuICAgIHRoaXMudGV4SW5mbyA9IG5ldyBUZXhJbmZvKClcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHsgc2l6ZTogMCB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGVtcEJpbmQgKHRleHR1cmUpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEpXG4gICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIHRleHR1cmUudGV4dHVyZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBSZXN0b3JlICgpIHtcbiAgICB2YXIgcHJldiA9IHRleHR1cmVVbml0c1swXVxuICAgIGlmIChwcmV2KSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShwcmV2LnRhcmdldCwgcHJldi50ZXh0dXJlKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAodGV4dHVyZSkge1xuICAgIHZhciBoYW5kbGUgPSB0ZXh0dXJlLnRleHR1cmVcbiAgICBjaGVjayQxKGhhbmRsZSwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IHRleHR1cmUnKVxuICAgIHZhciB1bml0ID0gdGV4dHVyZS51bml0XG4gICAgdmFyIHRhcmdldCA9IHRleHR1cmUudGFyZ2V0XG4gICAgaWYgKHVuaXQgPj0gMCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgdW5pdClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgbnVsbClcbiAgICAgIHRleHR1cmVVbml0c1t1bml0XSA9IG51bGxcbiAgICB9XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShoYW5kbGUpXG4gICAgdGV4dHVyZS50ZXh0dXJlID0gbnVsbFxuICAgIHRleHR1cmUucGFyYW1zID0gbnVsbFxuICAgIHRleHR1cmUucGl4ZWxzID0gbnVsbFxuICAgIHRleHR1cmUucmVmQ291bnQgPSAwXG4gICAgZGVsZXRlIHRleHR1cmVTZXRbdGV4dHVyZS5pZF1cbiAgICBzdGF0cy50ZXh0dXJlQ291bnQtLVxuICB9XG5cbiAgZXh0ZW5kKFJFR0xUZXh0dXJlLnByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gdGhpc1xuICAgICAgdGV4dHVyZS5iaW5kQ291bnQgKz0gMVxuICAgICAgdmFyIHVuaXQgPSB0ZXh0dXJlLnVuaXRcbiAgICAgIGlmICh1bml0IDwgMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5iaW5kQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlci51bml0ID0gLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gdGV4dHVyZVxuICAgICAgICAgIHVuaXQgPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA+PSBudW1UZXhVbml0cykge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2luc3VmZmljaWVudCBudW1iZXIgb2YgdGV4dHVyZSB1bml0cycpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5wcm9maWxlICYmIHN0YXRzLm1heFRleHR1cmVVbml0cyA8ICh1bml0ICsgMSkpIHtcbiAgICAgICAgICBzdGF0cy5tYXhUZXh0dXJlVW5pdHMgPSB1bml0ICsgMSAvLyArMSwgc2luY2UgdGhlIHVuaXRzIGFyZSB6ZXJvLWJhc2VkXG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS51bml0ID0gdW5pdFxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyB1bml0KVxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaXRcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJpbmRDb3VudCAtPSAxXG4gICAgfSxcblxuICAgIGRlY1JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgIGRlc3Ryb3kodGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEIChhLCBiKSB7XG4gICAgdmFyIHRleHR1cmUgPSBuZXcgUkVHTFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxKVxuICAgIHRleHR1cmVTZXRbdGV4dHVyZS5pZF0gPSB0ZXh0dXJlXG4gICAgc3RhdHMudGV4dHVyZUNvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlMkQgKGEsIGIpIHtcbiAgICAgIHZhciB0ZXhJbmZvID0gdGV4dHVyZS50ZXhJbmZvXG4gICAgICBUZXhJbmZvLmNhbGwodGV4SW5mbylcbiAgICAgIHZhciBtaXBEYXRhID0gYWxsb2NNaXBNYXAoKVxuXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYiB8IDApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgYSB8IDAsIGEgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgICAgY2hlY2skMS50eXBlKGEsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVnbC50ZXh0dXJlJylcbiAgICAgICAgcGFyc2VUZXhJbmZvKHRleEluZm8sIGEpXG4gICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChtaXBEYXRhLCBhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgdGV4dHVyZXMgZ2V0IGFzc2lnbmVkIGEgZGVmYXVsdCBzaGFwZSBvZiAxeDFcbiAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgMSwgMSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRleEluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgICBtaXBEYXRhLm1pcG1hc2sgPSAobWlwRGF0YS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH1cbiAgICAgIHRleHR1cmUubWlwbWFzayA9IG1pcERhdGEubWlwbWFza1xuXG4gICAgICBjb3B5RmxhZ3ModGV4dHVyZSwgbWlwRGF0YSlcblxuICAgICAgY2hlY2skMS50ZXh0dXJlMkQodGV4SW5mbywgbWlwRGF0YSwgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IG1pcERhdGEuaW50ZXJuYWxmb3JtYXRcblxuICAgICAgcmVnbFRleHR1cmUyRC53aWR0aCA9IG1pcERhdGEud2lkdGhcbiAgICAgIHJlZ2xUZXh0dXJlMkQuaGVpZ2h0ID0gbWlwRGF0YS5oZWlnaHRcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldE1pcE1hcChtaXBEYXRhLCBHTF9URVhUVVJFXzJEJDEpXG4gICAgICBzZXRUZXhJbmZvKHRleEluZm8sIEdMX1RFWFRVUkVfMkQkMSlcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZU1pcE1hcChtaXBEYXRhKVxuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgdGV4dHVyZS5zdGF0cy5zaXplID0gZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgbWlwRGF0YS53aWR0aCxcbiAgICAgICAgICBtaXBEYXRhLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG4gICAgICByZWdsVGV4dHVyZTJELmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZTJELnR5cGUgPSB0ZXh0dXJlVHlwZXNJbnZlcnRbdGV4dHVyZS50eXBlXVxuXG4gICAgICByZWdsVGV4dHVyZTJELm1hZyA9IG1hZ0ZpbHRlcnNJbnZlcnRbdGV4SW5mby5tYWdGaWx0ZXJdXG4gICAgICByZWdsVGV4dHVyZTJELm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFMgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwU11cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFQgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwVF1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJpbWFnZSAoaW1hZ2UsIHhfLCB5XywgbGV2ZWxfKSB7XG4gICAgICBjaGVjayQxKCEhaW1hZ2UsICdtdXN0IHNwZWNpZnkgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHZhciB4ID0geF8gfCAwXG4gICAgICB2YXIgeSA9IHlfIHwgMFxuICAgICAgdmFyIGxldmVsID0gbGV2ZWxfIHwgMFxuXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1hZ2VEYXRhLCB0ZXh0dXJlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gMFxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IDBcbiAgICAgIHBhcnNlSW1hZ2UoaW1hZ2VEYXRhLCBpbWFnZSlcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IGltYWdlRGF0YS53aWR0aCB8fCAoKHRleHR1cmUud2lkdGggPj4gbGV2ZWwpIC0geClcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0IHx8ICgodGV4dHVyZS5oZWlnaHQgPj4gbGV2ZWwpIC0geSlcblxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS50eXBlID09PSBpbWFnZURhdGEudHlwZSAmJlxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9PT0gaW1hZ2VEYXRhLmZvcm1hdCAmJlxuICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID09PSBpbWFnZURhdGEuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICdpbmNvbXBhdGlibGUgZm9ybWF0IGZvciB0ZXh0dXJlLnN1YmltYWdlJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHggPj0gMCAmJiB5ID49IDAgJiZcbiAgICAgICAgeCArIGltYWdlRGF0YS53aWR0aCA8PSB0ZXh0dXJlLndpZHRoICYmXG4gICAgICAgIHkgKyBpbWFnZURhdGEuaGVpZ2h0IDw9IHRleHR1cmUuaGVpZ2h0LFxuICAgICAgICAndGV4dHVyZS5zdWJpbWFnZSB3cml0ZSBvdXQgb2YgYm91bmRzJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHRleHR1cmUubWlwbWFzayAmICgxIDw8IGxldmVsKSxcbiAgICAgICAgJ21pc3NpbmcgbWlwbWFwIGRhdGEnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhLmVsZW1lbnQgfHwgaW1hZ2VEYXRhLm5lZWRzQ29weSxcbiAgICAgICAgJ21pc3NpbmcgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBzZXRTdWJJbWFnZShpbWFnZURhdGEsIEdMX1RFWFRVUkVfMkQkMSwgeCwgeSwgbGV2ZWwpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGZyZWVJbWFnZShpbWFnZURhdGEpXG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcbiAgICAgIHZhciB3ID0gd18gfCAwXG4gICAgICB2YXIgaCA9IChoXyB8IDApIHx8IHdcbiAgICAgIGlmICh3ID09PSB0ZXh0dXJlLndpZHRoICYmIGggPT09IHRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgICB9XG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gd1xuICAgICAgcmVnbFRleHR1cmUyRC5oZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA9IGhcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRleHR1cmUubWlwbWFzayA+PiBpOyArK2kpIHtcbiAgICAgICAgdmFyIF93ID0gdyA+PiBpXG4gICAgICAgIHZhciBfaCA9IGggPj4gaVxuICAgICAgICBpZiAoIV93IHx8ICFfaCkgYnJlYWtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICBHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICBfdyxcbiAgICAgICAgICBfaCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICBudWxsKVxuICAgICAgfVxuICAgICAgdGVtcFJlc3RvcmUoKVxuXG4gICAgICAvLyBhbHNvLCByZWNvbXB1dGUgdGhlIHRleHR1cmUgc2l6ZS5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmUyRChhLCBiKVxuXG4gICAgcmVnbFRleHR1cmUyRC5zdWJpbWFnZSA9IHN1YmltYWdlXG4gICAgcmVnbFRleHR1cmUyRC5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZTJELl9yZWdsVHlwZSA9ICd0ZXh0dXJlMmQnXG4gICAgcmVnbFRleHR1cmUyRC5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlMkQuc3RhdHMgPSB0ZXh0dXJlLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xUZXh0dXJlMkQuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRleHR1cmUuZGVjUmVmKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBSRUdMVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmVcbiAgICBzdGF0cy5jdWJlQ291bnQrK1xuXG4gICAgdmFyIGZhY2VzID0gbmV3IEFycmF5KDYpXG5cbiAgICBmdW5jdGlvbiByZWdsVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgIHZhciBpXG4gICAgICB2YXIgdGV4SW5mbyA9IHRleHR1cmUudGV4SW5mb1xuICAgICAgVGV4SW5mby5jYWxsKHRleEluZm8pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldID0gYWxsb2NNaXBNYXAoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGEwID09PSAnbnVtYmVyJyB8fCAhYTApIHtcbiAgICAgICAgdmFyIHMgPSAoYTAgfCAwKSB8fCAxXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShmYWNlc1tpXSwgcywgcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChhMSkge1xuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1swXSwgYTApXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzFdLCBhMSlcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbMl0sIGEyKVxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1szXSwgYTMpXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzRdLCBhNClcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbNV0sIGE1KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlVGV4SW5mbyh0ZXhJbmZvLCBhMClcbiAgICAgICAgICBwYXJzZUZsYWdzKHRleHR1cmUsIGEwKVxuICAgICAgICAgIGlmICgnZmFjZXMnIGluIGEwKSB7XG4gICAgICAgICAgICB2YXIgZmFjZUlucHV0ID0gYTAuZmFjZXNcbiAgICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShmYWNlSW5wdXQpICYmIGZhY2VJbnB1dC5sZW5ndGggPT09IDYsXG4gICAgICAgICAgICAgICdjdWJlIGZhY2VzIG11c3QgYmUgYSBsZW5ndGggNiBhcnJheScpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2VJbnB1dFtpXSA9PT0gJ29iamVjdCcgJiYgISFmYWNlSW5wdXRbaV0sXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgaW5wdXQgZm9yIGN1YmUgbWFwIGZhY2UnKVxuICAgICAgICAgICAgICBjb3B5RmxhZ3MoZmFjZXNbaV0sIHRleHR1cmUpXG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgZmFjZUlucHV0W2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgYTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byBjdWJlIG1hcCcpXG4gICAgICB9XG5cbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBmYWNlc1swXSlcblxuICAgICAgaWYgKCFsaW1pdHMubnBvdFRleHR1cmVDdWJlKSB7XG4gICAgICAgIGNoZWNrJDEoaXNQb3cyJDEodGV4dHVyZS53aWR0aCkgJiYgaXNQb3cyJDEodGV4dHVyZS5oZWlnaHQpLCAneW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbm9uIHBvd2VyIG9yIHR3byB0ZXh0dXJlIGRpbWVuc2lvbnMnKVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4SW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IChmYWNlc1swXS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IGZhY2VzWzBdLm1pcG1hc2tcbiAgICAgIH1cblxuICAgICAgY2hlY2skMS50ZXh0dXJlQ3ViZSh0ZXh0dXJlLCB0ZXhJbmZvLCBmYWNlcywgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IGZhY2VzWzBdLmludGVybmFsZm9ybWF0XG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCA9IGZhY2VzWzBdLndpZHRoXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gZmFjZXNbMF0uaGVpZ2h0XG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIHNldE1pcE1hcChmYWNlc1tpXSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBpKVxuICAgICAgfVxuICAgICAgc2V0VGV4SW5mbyh0ZXhJbmZvLCBHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgcmVnbFRleHR1cmVDdWJlLmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZUN1YmUudHlwZSA9IHRleHR1cmVUeXBlc0ludmVydFt0ZXh0dXJlLnR5cGVdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5tYWcgPSBtYWdGaWx0ZXJzSW52ZXJ0W3RleEluZm8ubWFnRmlsdGVyXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLndyYXBUID0gd3JhcE1vZGVzSW52ZXJ0W3RleEluZm8ud3JhcFRdXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZnJlZU1pcE1hcChmYWNlc1tpXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmltYWdlIChmYWNlLCBpbWFnZSwgeF8sIHlfLCBsZXZlbF8pIHtcbiAgICAgIGNoZWNrJDEoISFpbWFnZSwgJ211c3Qgc3BlY2lmeSBpbWFnZSBkYXRhJylcbiAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2UgPT09ICdudW1iZXInICYmIGZhY2UgPT09IChmYWNlIHwgMCkgJiZcbiAgICAgICAgZmFjZSA+PSAwICYmIGZhY2UgPCA2LCAnaW52YWxpZCBmYWNlJylcblxuICAgICAgdmFyIHggPSB4XyB8IDBcbiAgICAgIHZhciB5ID0geV8gfCAwXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbF8gfCAwXG5cbiAgICAgIHZhciBpbWFnZURhdGEgPSBhbGxvY0ltYWdlKClcbiAgICAgIGNvcHlGbGFncyhpbWFnZURhdGEsIHRleHR1cmUpXG4gICAgICBpbWFnZURhdGEud2lkdGggPSAwXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gMFxuICAgICAgcGFyc2VJbWFnZShpbWFnZURhdGEsIGltYWdlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoIHx8ICgodGV4dHVyZS53aWR0aCA+PiBsZXZlbCkgLSB4KVxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQgfHwgKCh0ZXh0dXJlLmhlaWdodCA+PiBsZXZlbCkgLSB5KVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0ZXh0dXJlLnR5cGUgPT09IGltYWdlRGF0YS50eXBlICYmXG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID09PSBpbWFnZURhdGEuZm9ybWF0ICYmXG4gICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPT09IGltYWdlRGF0YS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgJ2luY29tcGF0aWJsZSBmb3JtYXQgZm9yIHRleHR1cmUuc3ViaW1hZ2UnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHkgPj0gMCAmJlxuICAgICAgICB4ICsgaW1hZ2VEYXRhLndpZHRoIDw9IHRleHR1cmUud2lkdGggJiZcbiAgICAgICAgeSArIGltYWdlRGF0YS5oZWlnaHQgPD0gdGV4dHVyZS5oZWlnaHQsXG4gICAgICAgICd0ZXh0dXJlLnN1YmltYWdlIHdyaXRlIG91dCBvZiBib3VuZHMnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrICYgKDEgPDwgbGV2ZWwpLFxuICAgICAgICAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICBjaGVjayQxKFxuICAgICAgICBpbWFnZURhdGEuZGF0YSB8fCBpbWFnZURhdGEuZWxlbWVudCB8fCBpbWFnZURhdGEubmVlZHNDb3B5LFxuICAgICAgICAnbWlzc2luZyBpbWFnZSBkYXRhJylcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldFN1YkltYWdlKGltYWdlRGF0YSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBmYWNlLCB4LCB5LCBsZXZlbClcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZUltYWdlKGltYWdlRGF0YSlcblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c18gfCAwXG4gICAgICBpZiAocmFkaXVzID09PSB0ZXh0dXJlLndpZHRoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gcmFkaXVzXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPSByYWRpdXNcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyB0ZXh0dXJlLm1pcG1hc2sgPj4gajsgKytqKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICAgIHJhZGl1cyA+PiBqLFxuICAgICAgICAgICAgcmFkaXVzID4+IGosXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgICBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmVDdWJlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpXG5cbiAgICByZWdsVGV4dHVyZUN1YmUuc3ViaW1hZ2UgPSBzdWJpbWFnZVxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZUN1YmUuX3JlZ2xUeXBlID0gJ3RleHR1cmVDdWJlJ1xuICAgIHJlZ2xUZXh0dXJlQ3ViZS5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5zdGF0cyA9IHRleHR1cmUuc3RhdHNcbiAgICB9XG4gICAgcmVnbFRleHR1cmVDdWJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0dXJlLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gcmVnbCBpcyBkZXN0cm95ZWRcbiAgZnVuY3Rpb24gZGVzdHJveVRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSArIGkpXG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgfVxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG5cbiAgICBzdGF0cy5jdWJlQ291bnQgPSAwXG4gICAgc3RhdHMudGV4dHVyZUNvdW50ID0gMFxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0VG90YWxUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHRleHR1cmVTZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0b3RhbCArPSB0ZXh0dXJlU2V0W2tleV0uc3RhdHMuc2l6ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVUZXh0dXJlcyAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UZXhVbml0czsgKytpKSB7XG4gICAgICB2YXIgdGV4ID0gdGV4dHVyZVVuaXRzW2ldXG4gICAgICBpZiAodGV4KSB7XG4gICAgICAgIHRleC5iaW5kQ291bnQgPSAwXG4gICAgICAgIHRleC51bml0ID0gLTFcbiAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0ZXh0dXJlLnRleHR1cmUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ZXh0dXJlLm1pcG1hc2sgJiAoMSA8PCBpKSkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLnRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQxKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUud2lkdGggPj4gaSxcbiAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2OyArK2opIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBqLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoID4+IGksXG4gICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFRleEluZm8odGV4dHVyZS50ZXhJbmZvLCB0ZXh0dXJlLnRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIHZhciB0ZXggPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgIGlmICh0ZXgpIHtcbiAgICAgICAgdGV4LmJpbmRDb3VudCA9IDBcbiAgICAgICAgdGV4LnVuaXQgPSAtMVxuICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgICB9XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyBpKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxLCBudWxsKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCQxLCBudWxsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlMkQ6IGNyZWF0ZVRleHR1cmUyRCxcbiAgICBjcmVhdGVDdWJlOiBjcmVhdGVUZXh0dXJlQ3ViZSxcbiAgICBjbGVhcjogZGVzdHJveVRleHR1cmVzLFxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVRleHR1cmVzLFxuICAgIHJlZnJlc2g6IHJlZnJlc2hUZXh0dXJlc1xuICB9XG59XG5cbnZhciBHTF9SRU5ERVJCVUZGRVIgPSAweDhENDFcblxudmFyIEdMX1JHQkE0JDEgPSAweDgwNTZcbnZhciBHTF9SR0I1X0ExJDEgPSAweDgwNTdcbnZhciBHTF9SR0I1NjUkMSA9IDB4OEQ2MlxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVDE2ID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDggPSAweDhENDhcbnZhciBHTF9ERVBUSF9TVEVOQ0lMJDEgPSAweDg0RjlcblxudmFyIEdMX1NSR0I4X0FMUEhBOF9FWFQgPSAweDhDNDNcblxudmFyIEdMX1JHQkEzMkZfRVhUID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCA9IDB4ODgxQVxudmFyIEdMX1JHQjE2Rl9FWFQgPSAweDg4MUJcblxudmFyIEZPUk1BVF9TSVpFUyA9IFtdXG5cbkZPUk1BVF9TSVpFU1tHTF9SR0JBNCQxXSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9SR0I1X0ExJDFdID0gMlxuRk9STUFUX1NJWkVTW0dMX1JHQjU2NSQxXSA9IDJcblxuRk9STUFUX1NJWkVTW0dMX0RFUFRIX0NPTVBPTkVOVDE2XSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9TVEVOQ0lMX0lOREVYOF0gPSAxXG5GT1JNQVRfU0laRVNbR0xfREVQVEhfU1RFTkNJTCQxXSA9IDRcblxuRk9STUFUX1NJWkVTW0dMX1NSR0I4X0FMUEhBOF9FWFRdID0gNFxuRk9STUFUX1NJWkVTW0dMX1JHQkEzMkZfRVhUXSA9IDE2XG5GT1JNQVRfU0laRVNbR0xfUkdCQTE2Rl9FWFRdID0gOFxuRk9STUFUX1NJWkVTW0dMX1JHQjE2Rl9FWFRdID0gNlxuXG5mdW5jdGlvbiBnZXRSZW5kZXJidWZmZXJTaXplIChmb3JtYXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIEZPUk1BVF9TSVpFU1tmb3JtYXRdICogd2lkdGggKiBoZWlnaHRcbn1cblxudmFyIHdyYXBSZW5kZXJidWZmZXJzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzLCBjb25maWcpIHtcbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgICdyZ2JhNCc6IEdMX1JHQkE0JDEsXG4gICAgJ3JnYjU2NSc6IEdMX1JHQjU2NSQxLFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSQxLFxuICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVDE2LFxuICAgICdzdGVuY2lsJzogR0xfU1RFTkNJTF9JTkRFWDgsXG4gICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XG4gICAgZm9ybWF0VHlwZXNbJ3NyZ2JhJ10gPSBHTF9TUkdCOF9BTFBIQThfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTE2ZiddID0gR0xfUkdCQTE2Rl9FWFRcbiAgICBmb3JtYXRUeXBlc1sncmdiMTZmJ10gPSBHTF9SR0IxNkZfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTMyZiddID0gR0xfUkdCQTMyRl9FWFRcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlc0ludmVydCA9IFtdXG4gIE9iamVjdC5rZXlzKGZvcm1hdFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gZm9ybWF0VHlwZXNba2V5XVxuICAgIGZvcm1hdFR5cGVzSW52ZXJ0W3ZhbF0gPSBrZXlcbiAgfSlcblxuICB2YXIgcmVuZGVyYnVmZmVyQ291bnQgPSAwXG4gIHZhciByZW5kZXJidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xSZW5kZXJidWZmZXIgKHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMuaWQgPSByZW5kZXJidWZmZXJDb3VudCsrXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB0aGlzLmZvcm1hdCA9IEdMX1JHQkE0JDFcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMUmVuZGVyYnVmZmVyLnByb3RvdHlwZS5kZWNSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICBkZXN0cm95KHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAocmIpIHtcbiAgICB2YXIgaGFuZGxlID0gcmIucmVuZGVyYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSByZW5kZXJidWZmZXInKVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihoYW5kbGUpXG4gICAgcmIucmVuZGVyYnVmZmVyID0gbnVsbFxuICAgIHJiLnJlZkNvdW50ID0gMFxuICAgIGRlbGV0ZSByZW5kZXJidWZmZXJTZXRbcmIuaWRdXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQtLVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyYnVmZmVyIChhLCBiKSB7XG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IG5ldyBSRUdMUmVuZGVyYnVmZmVyKGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpKVxuICAgIHJlbmRlcmJ1ZmZlclNldFtyZW5kZXJidWZmZXIuaWRdID0gcmVuZGVyYnVmZmVyXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbFJlbmRlcmJ1ZmZlciAoYSwgYikge1xuICAgICAgdmFyIHcgPSAwXG4gICAgICB2YXIgaCA9IDBcbiAgICAgIHZhciBmb3JtYXQgPSBHTF9SR0JBNCQxXG5cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcbiAgICAgICAgaWYgKCdzaGFwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBzaGFwZSA9IG9wdGlvbnMuc2hhcGVcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkoc2hhcGUpICYmIHNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNoYXBlJylcbiAgICAgICAgICB3ID0gc2hhcGVbMF0gfCAwXG4gICAgICAgICAgaCA9IHNoYXBlWzFdIHwgMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGggPSBvcHRpb25zLmhlaWdodCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLmZvcm1hdCwgZm9ybWF0VHlwZXMsXG4gICAgICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgZm9ybWF0JylcbiAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRUeXBlc1tvcHRpb25zLmZvcm1hdF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdyA9IGEgfCAwXG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBoID0gYiB8IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoID0gd1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhKSB7XG4gICAgICAgIHcgPSBoID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVuZGVyYnVmZmVyIGNvbnN0cnVjdG9yJylcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgc2hhcGVcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHcgPiAwICYmIGggPiAwICYmXG4gICAgICAgIHcgPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUgJiYgaCA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSxcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNpemUnKVxuXG4gICAgICBpZiAodyA9PT0gcmVuZGVyYnVmZmVyLndpZHRoICYmXG4gICAgICAgICAgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCAmJlxuICAgICAgICAgIGZvcm1hdCA9PT0gcmVuZGVyYnVmZmVyLmZvcm1hdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci53aWR0aCA9IHJlbmRlcmJ1ZmZlci53aWR0aCA9IHdcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuaGVpZ2h0ID0gcmVuZGVyYnVmZmVyLmhlaWdodCA9IGhcbiAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRcblxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgZm9ybWF0LCB3LCBoKVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbC5nZXRFcnJvcigpID09PSAwLFxuICAgICAgICAnaW52YWxpZCByZW5kZXIgYnVmZmVyIGZvcm1hdCcpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICByZW5kZXJidWZmZXIuc3RhdHMuc2l6ZSA9IGdldFJlbmRlcmJ1ZmZlclNpemUocmVuZGVyYnVmZmVyLmZvcm1hdCwgcmVuZGVyYnVmZmVyLndpZHRoLCByZW5kZXJidWZmZXIuaGVpZ2h0KVxuICAgICAgfVxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRUeXBlc0ludmVydFtyZW5kZXJidWZmZXIuZm9ybWF0XVxuXG4gICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICB2YXIgdyA9IHdfIHwgMFxuICAgICAgdmFyIGggPSAoaF8gfCAwKSB8fCB3XG5cbiAgICAgIGlmICh3ID09PSByZW5kZXJidWZmZXIud2lkdGggJiYgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBzaGFwZVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdyA+IDAgJiYgaCA+IDAgJiZcbiAgICAgICAgdyA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSAmJiBoIDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplLFxuICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2l6ZScpXG5cbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIud2lkdGggPSByZW5kZXJidWZmZXIud2lkdGggPSB3XG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmhlaWdodCA9IHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBoXG5cbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHcsIGgpXG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGdsLmdldEVycm9yKCkgPT09IDAsXG4gICAgICAgICdpbnZhbGlkIHJlbmRlciBidWZmZXIgZm9ybWF0JylcblxuICAgICAgLy8gYWxzbywgcmVjb21wdXRlIHNpemUuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgcmVuZGVyYnVmZmVyLnN0YXRzLnNpemUgPSBnZXRSZW5kZXJidWZmZXJTaXplKFxuICAgICAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHJlbmRlcmJ1ZmZlci53aWR0aCwgcmVuZGVyYnVmZmVyLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgICB9XG5cbiAgICByZWdsUmVuZGVyYnVmZmVyKGEsIGIpXG5cbiAgICByZWdsUmVuZGVyYnVmZmVyLnJlc2l6ZSA9IHJlc2l6ZVxuICAgIHJlZ2xSZW5kZXJidWZmZXIuX3JlZ2xUeXBlID0gJ3JlbmRlcmJ1ZmZlcidcbiAgICByZWdsUmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuc3RhdHMgPSByZW5kZXJidWZmZXIuc3RhdHNcbiAgICB9XG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVuZGVyYnVmZmVyLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsUmVuZGVyYnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IHJlbmRlcmJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlUmVuZGVyYnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAocmIpIHtcbiAgICAgIHJiLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpXG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgcmIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJiLmZvcm1hdCwgcmIud2lkdGgsIHJiLmhlaWdodClcbiAgICB9KVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZVJlbmRlcmJ1ZmZlcixcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVJlbmRlcmJ1ZmZlcnNcbiAgfVxufVxuXG4vLyBXZSBzdG9yZSB0aGVzZSBjb25zdGFudHMgc28gdGhhdCB0aGUgbWluaWZpZXIgY2FuIGlubGluZSB0aGVtXG52YXIgR0xfRlJBTUVCVUZGRVIkMSA9IDB4OEQ0MFxudmFyIEdMX1JFTkRFUkJVRkZFUiQxID0gMHg4RDQxXG5cbnZhciBHTF9URVhUVVJFXzJEJDIgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiA9IDB4ODUxNVxuXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSA9IDB4OENFMFxudmFyIEdMX0RFUFRIX0FUVEFDSE1FTlQgPSAweDhEMDBcbnZhciBHTF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDhEMjBcbnZhciBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDgyMUFcblxudmFyIEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEgPSAweDhDRDVcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQgPSAweDhDRDZcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCA9IDB4OENEN1xudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyA9IDB4OENEOVxudmFyIEdMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEID0gMHg4Q0REXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyQyID0gMHg4RDYxXG52YXIgR0xfVU5TSUdORURfQllURSQ2ID0gMHgxNDAxXG52YXIgR0xfRkxPQVQkNSA9IDB4MTQwNlxuXG52YXIgR0xfUkdCJDEgPSAweDE5MDdcbnZhciBHTF9SR0JBJDIgPSAweDE5MDhcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCQxID0gMHgxOTAyXG5cbnZhciBjb2xvclRleHR1cmVGb3JtYXRFbnVtcyA9IFtcbiAgR0xfUkdCJDEsXG4gIEdMX1JHQkEkMlxuXVxuXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSBmb3JtYXQsIHN0b3JlXG4vLyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG52YXIgdGV4dHVyZUZvcm1hdENoYW5uZWxzID0gW11cbnRleHR1cmVGb3JtYXRDaGFubmVsc1tHTF9SR0JBJDJdID0gNFxudGV4dHVyZUZvcm1hdENoYW5uZWxzW0dMX1JHQiQxXSA9IDNcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIHRleHR1cmVUeXBlU2l6ZXMgPSBbXVxudGV4dHVyZVR5cGVTaXplc1tHTF9VTlNJR05FRF9CWVRFJDZdID0gMVxudGV4dHVyZVR5cGVTaXplc1tHTF9GTE9BVCQ1XSA9IDRcbnRleHR1cmVUeXBlU2l6ZXNbR0xfSEFMRl9GTE9BVF9PRVMkMl0gPSAyXG5cbnZhciBHTF9SR0JBNCQyID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSQyID0gMHg4MDU3XG52YXIgR0xfUkdCNTY1JDIgPSAweDhENjJcbnZhciBHTF9ERVBUSF9DT01QT05FTlQxNiQxID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDgkMSA9IDB4OEQ0OFxudmFyIEdMX0RFUFRIX1NURU5DSUwkMiA9IDB4ODRGOVxuXG52YXIgR0xfU1JHQjhfQUxQSEE4X0VYVCQxID0gMHg4QzQzXG5cbnZhciBHTF9SR0JBMzJGX0VYVCQxID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCQxID0gMHg4ODFBXG52YXIgR0xfUkdCMTZGX0VYVCQxID0gMHg4ODFCXG5cbnZhciBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zID0gW1xuICBHTF9SR0JBNCQyLFxuICBHTF9SR0I1X0ExJDIsXG4gIEdMX1JHQjU2NSQyLFxuICBHTF9TUkdCOF9BTFBIQThfRVhUJDEsXG4gIEdMX1JHQkExNkZfRVhUJDEsXG4gIEdMX1JHQjE2Rl9FWFQkMSxcbiAgR0xfUkdCQTMyRl9FWFQkMVxuXVxuXG52YXIgc3RhdHVzQ29kZSA9IHt9XG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDFdID0gJ2NvbXBsZXRlJ1xuc3RhdHVzQ29kZVtHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdID0gJ2luY29tcGxldGUgYXR0YWNobWVudCdcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXSA9ICdpbmNvbXBsZXRlIGRpbWVuc2lvbnMnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXSA9ICdpbmNvbXBsZXRlLCBtaXNzaW5nIGF0dGFjaG1lbnQnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXSA9ICd1bnN1cHBvcnRlZCdcblxuZnVuY3Rpb24gd3JhcEZCT1N0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgdGV4dHVyZVN0YXRlLFxuICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgc3RhdHMpIHtcbiAgdmFyIGZyYW1lYnVmZmVyU3RhdGUgPSB7XG4gICAgY3VyOiBudWxsLFxuICAgIG5leHQ6IG51bGwsXG4gICAgZGlydHk6IGZhbHNlLFxuICAgIHNldEZCTzogbnVsbFxuICB9XG5cbiAgdmFyIGNvbG9yVGV4dHVyZUZvcm1hdHMgPSBbJ3JnYmEnXVxuICB2YXIgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzID0gWydyZ2JhNCcsICdyZ2I1NjUnLCAncmdiNSBhMSddXG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3NyZ2IpIHtcbiAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMucHVzaCgnc3JnYmEnKVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0KSB7XG4gICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLnB1c2goJ3JnYmExNmYnLCAncmdiMTZmJylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCkge1xuICAgIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5wdXNoKCdyZ2JhMzJmJylcbiAgfVxuXG4gIHZhciBjb2xvclR5cGVzID0gWyd1aW50OCddXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2hhbGYgZmxvYXQnLCAnZmxvYXQxNicpXG4gIH1cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2Zsb2F0JywgJ2Zsb2F0MzInKVxuICB9XG5cbiAgZnVuY3Rpb24gRnJhbWVidWZmZXJBdHRhY2htZW50ICh0YXJnZXQsIHRleHR1cmUsIHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB2YXIgdyA9IDBcbiAgICB2YXIgaCA9IDBcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdyA9IHRleHR1cmUud2lkdGhcbiAgICAgIGggPSB0ZXh0dXJlLmhlaWdodFxuICAgIH0gZWxzZSBpZiAocmVuZGVyYnVmZmVyKSB7XG4gICAgICB3ID0gcmVuZGVyYnVmZmVyLndpZHRoXG4gICAgICBoID0gcmVuZGVyYnVmZmVyLmhlaWdodFxuICAgIH1cbiAgICB0aGlzLndpZHRoID0gd1xuICAgIHRoaXMuaGVpZ2h0ID0gaFxuICB9XG5cbiAgZnVuY3Rpb24gZGVjUmVmIChhdHRhY2htZW50KSB7XG4gICAgaWYgKGF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcbiAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmRlY1JlZigpXG4gICAgICB9XG4gICAgICBpZiAoYXR0YWNobWVudC5yZW5kZXJidWZmZXIpIHtcbiAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5kZWNSZWYoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY1JlZkFuZENoZWNrU2hhcGUgKGF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZVxuICAgICAgdmFyIHR3ID0gTWF0aC5tYXgoMSwgdGV4dHVyZS53aWR0aClcbiAgICAgIHZhciB0aCA9IE1hdGgubWF4KDEsIHRleHR1cmUuaGVpZ2h0KVxuICAgICAgY2hlY2skMSh0dyA9PT0gd2lkdGggJiYgdGggPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHN1cHBsaWVkIHRleHR1cmUnKVxuICAgICAgdGV4dHVyZS5yZWZDb3VudCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZW5kZXJidWZmZXIgPSBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyXG4gICAgICBjaGVjayQxKFxuICAgICAgICByZW5kZXJidWZmZXIud2lkdGggPT09IHdpZHRoICYmIHJlbmRlcmJ1ZmZlci5oZWlnaHQgPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICByZW5kZXJidWZmZXIucmVmQ291bnQgKz0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaCAobG9jYXRpb24sIGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIGF0dGFjaG1lbnQudGFyZ2V0LFxuICAgICAgICAgIGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIEdMX1JFTkRFUkJVRkZFUiQxLFxuICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudCAoYXR0YWNobWVudCkge1xuICAgIHZhciB0YXJnZXQgPSBHTF9URVhUVVJFXzJEJDJcbiAgICB2YXIgdGV4dHVyZSA9IG51bGxcbiAgICB2YXIgcmVuZGVyYnVmZmVyID0gbnVsbFxuXG4gICAgdmFyIGRhdGEgPSBhdHRhY2htZW50XG4gICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YVxuICAgICAgaWYgKCd0YXJnZXQnIGluIGF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYXR0YWNobWVudC50YXJnZXQgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMS50eXBlKGRhdGEsICdmdW5jdGlvbicsICdpbnZhbGlkIGF0dGFjaG1lbnQgZGF0YScpXG5cbiAgICB2YXIgdHlwZSA9IGRhdGEuX3JlZ2xUeXBlXG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0dXJlMmQnKSB7XG4gICAgICB0ZXh0dXJlID0gZGF0YVxuICAgICAgY2hlY2skMSh0YXJnZXQgPT09IEdMX1RFWFRVUkVfMkQkMilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgIHRleHR1cmUgPSBkYXRhXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0YXJnZXQgPj0gR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgJiZcbiAgICAgICAgdGFyZ2V0IDwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgKyA2LFxuICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCB0YXJnZXQnKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmJ1ZmZlcicpIHtcbiAgICAgIHJlbmRlcmJ1ZmZlciA9IGRhdGFcbiAgICAgIHRhcmdldCA9IEdMX1JFTkRFUkJVRkZFUiQxXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgcmVnbCBvYmplY3QgZm9yIGF0dGFjaG1lbnQnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KHRhcmdldCwgdGV4dHVyZSwgcmVuZGVyYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NBdHRhY2htZW50IChcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgaXNUZXh0dXJlLFxuICAgIGZvcm1hdCxcbiAgICB0eXBlKSB7XG4gICAgaWYgKGlzVGV4dHVyZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQoe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSlcbiAgICAgIHRleHR1cmUuX3RleHR1cmUucmVmQ291bnQgPSAwXG4gICAgICByZXR1cm4gbmV3IEZyYW1lYnVmZmVyQXR0YWNobWVudChHTF9URVhUVVJFXzJEJDIsIHRleHR1cmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYiA9IHJlbmRlcmJ1ZmZlclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgICB9KVxuICAgICAgcmIuX3JlbmRlcmJ1ZmZlci5yZWZDb3VudCA9IDBcbiAgICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KEdMX1JFTkRFUkJVRkZFUiQxLCBudWxsLCByYilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXBBdHRhY2htZW50IChhdHRhY2htZW50KSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnQgJiYgKGF0dGFjaG1lbnQudGV4dHVyZSB8fCBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZUF0dGFjaG1lbnQgKGF0dGFjaG1lbnQsIHcsIGgpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBhdHRhY2htZW50LnRleHR1cmUucmVzaXplKHcsIGgpXG4gICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyKSB7XG4gICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLnJlc2l6ZSh3LCBoKVxuICAgICAgfVxuICAgICAgYXR0YWNobWVudC53aWR0aCA9IHdcbiAgICAgIGF0dGFjaG1lbnQuaGVpZ2h0ID0gaFxuICAgIH1cbiAgfVxuXG4gIHZhciBmcmFtZWJ1ZmZlckNvdW50ID0gMFxuICB2YXIgZnJhbWVidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xGcmFtZWJ1ZmZlciAoKSB7XG4gICAgdGhpcy5pZCA9IGZyYW1lYnVmZmVyQ291bnQrK1xuICAgIGZyYW1lYnVmZmVyU2V0W3RoaXMuaWRdID0gdGhpc1xuXG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgdGhpcy5jb2xvckF0dGFjaG1lbnRzID0gW11cbiAgICB0aGlzLmRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICB0aGlzLnN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuICAgIHRoaXMuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY0ZCT1JlZnMgKGZyYW1lYnVmZmVyKSB7XG4gICAgZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50cy5mb3JFYWNoKGRlY1JlZilcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudClcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKGZyYW1lYnVmZmVyKSB7XG4gICAgdmFyIGhhbmRsZSA9IGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSBmcmFtZWJ1ZmZlcicpXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoaGFuZGxlKVxuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gbnVsbFxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQtLVxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlclNldFtmcmFtZWJ1ZmZlci5pZF1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lYnVmZmVyIChmcmFtZWJ1ZmZlcikge1xuICAgIHZhciBpXG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIkMSwgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIpXG4gICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGF0dGFjaChHTF9DT0xPUl9BVFRBQ0hNRU5UMCQxICsgaSwgY29sb3JBdHRhY2htZW50c1tpXSlcbiAgICB9XG4gICAgZm9yIChpID0gY29sb3JBdHRhY2htZW50cy5sZW5ndGg7IGkgPCBsaW1pdHMubWF4Q29sb3JBdHRhY2htZW50czsgKytpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgR0xfRlJBTUVCVUZGRVIkMSxcbiAgICAgICAgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSArIGksXG4gICAgICAgIEdMX1RFWFRVUkVfMkQkMixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMClcbiAgICB9XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXG4gICAgICBudWxsLFxuICAgICAgMClcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgR0xfU1RFTkNJTF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG5cbiAgICBhdHRhY2goR0xfREVQVEhfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpXG5cbiAgICAvLyBDaGVjayBzdGF0dXMgY29kZVxuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKEdMX0ZSQU1FQlVGRkVSJDEpXG4gICAgaWYgKCFnbC5pc0NvbnRleHRMb3N0KCkgJiYgc3RhdHVzICE9PSBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSQxKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uIG5vdCBzdXBwb3J0ZWQsIHN0YXR1cyA9ICcgK1xuICAgICAgICBzdGF0dXNDb2RlW3N0YXR1c10pXG4gICAgfVxuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSJDEsIGZyYW1lYnVmZmVyU3RhdGUubmV4dCA/IGZyYW1lYnVmZmVyU3RhdGUubmV4dC5mcmFtZWJ1ZmZlciA6IG51bGwpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBmcmFtZWJ1ZmZlclN0YXRlLm5leHRcblxuICAgIC8vIEZJWE1FOiBDbGVhciBlcnJvciBjb2RlIGhlcmUuICBUaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIGEgYnVnIGluXG4gICAgLy8gaGVhZGxlc3MtZ2xcbiAgICBnbC5nZXRFcnJvcigpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGQk8gKGEwLCBhMSkge1xuICAgIHZhciBmcmFtZWJ1ZmZlciA9IG5ldyBSRUdMRnJhbWVidWZmZXIoKVxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbEZyYW1lYnVmZmVyIChhLCBiKSB7XG4gICAgICB2YXIgaVxuXG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHVwZGF0ZSBmcmFtZWJ1ZmZlciB3aGljaCBpcyBjdXJyZW50bHkgaW4gdXNlJylcblxuICAgICAgdmFyIHdpZHRoID0gMFxuICAgICAgdmFyIGhlaWdodCA9IDBcblxuICAgICAgdmFyIG5lZWRzRGVwdGggPSB0cnVlXG4gICAgICB2YXIgbmVlZHNTdGVuY2lsID0gdHJ1ZVxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JUZXh0dXJlID0gdHJ1ZVxuICAgICAgdmFyIGNvbG9yRm9ybWF0ID0gJ3JnYmEnXG4gICAgICB2YXIgY29sb3JUeXBlID0gJ3VpbnQ4J1xuICAgICAgdmFyIGNvbG9yQ291bnQgPSAxXG5cbiAgICAgIHZhciBkZXB0aEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQnVmZmVyID0gbnVsbFxuICAgICAgdmFyIGRlcHRoU3RlbmNpbEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxUZXh0dXJlID0gZmFsc2VcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICB3aWR0aCA9IGEgfCAwXG4gICAgICAgIGhlaWdodCA9IChiIHwgMCkgfHwgd2lkdGhcbiAgICAgIH0gZWxzZSBpZiAoIWEpIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICAgIHdpZHRoID0gc2hhcGVbMF1cbiAgICAgICAgICBoZWlnaHQgPSBzaGFwZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnd2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy53aWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2NvbG9yJyBpbiBvcHRpb25zIHx8XG4gICAgICAgICAgICAnY29sb3JzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY29sb3JCdWZmZXIgPVxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvciB8fFxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvcnNcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvckJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICAgIGNvbG9yQnVmZmVyLmxlbmd0aCA9PT0gMSB8fCBleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyxcbiAgICAgICAgICAgICAgJ211bHRpcGxlIHJlbmRlciB0YXJnZXRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29sb3JCdWZmZXIpIHtcbiAgICAgICAgICBpZiAoJ2NvbG9yQ291bnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yQ291bnQgPSBvcHRpb25zLmNvbG9yQ291bnQgfCAwXG4gICAgICAgICAgICBjaGVjayQxKGNvbG9yQ291bnQgPiAwLCAnaW52YWxpZCBjb2xvciBidWZmZXIgY291bnQnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JUZXh0dXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvclRleHR1cmUgPSAhIW9wdGlvbnMuY29sb3JUZXh0dXJlXG4gICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhNCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2NvbG9yVHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JUeXBlID0gb3B0aW9ucy5jb2xvclR5cGVcbiAgICAgICAgICAgIGlmICghY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIEVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCB0byB1c2UgMTYtYml0IHJlbmRlciBidWZmZXJzJylcbiAgICAgICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhMTZmJ1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yVHlwZSA9PT0gJ2Zsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMzItYml0IGZsb2F0aW5nIHBvaW50IHJlbmRlcmJ1ZmZlcnMnKVxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gJ3JnYmEzMmYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCB8fFxuICAgICAgICAgICAgICAgICEoY29sb3JUeXBlID09PSAnZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MzInKSxcbiAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBPRVNfdGV4dHVyZV9mbG9hdCBpbiBvcmRlciB0byB1c2UgZmxvYXRpbmcgcG9pbnQgZnJhbWVidWZmZXIgb2JqZWN0cycpXG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IHx8XG4gICAgICAgICAgICAgICAgIShjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2JyksXG4gICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMTYtYml0IGZsb2F0aW5nIHBvaW50IGZyYW1lYnVmZmVyIG9iamVjdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2skMS5vbmVPZihjb2xvclR5cGUsIGNvbG9yVHlwZXMsICdpbnZhbGlkIGNvbG9yIHR5cGUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JGb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gb3B0aW9ucy5jb2xvckZvcm1hdFxuICAgICAgICAgICAgaWYgKGNvbG9yVGV4dHVyZUZvcm1hdHMuaW5kZXhPZihjb2xvckZvcm1hdCkgPj0gMCkge1xuICAgICAgICAgICAgICBjb2xvclRleHR1cmUgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5pbmRleE9mKGNvbG9yRm9ybWF0KSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlcHRoVGV4dHVyZScgaW4gb3B0aW9ucyB8fCAnZGVwdGhTdGVuY2lsVGV4dHVyZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGRlcHRoU3RlbmNpbFRleHR1cmUgPSAhIShvcHRpb25zLmRlcHRoVGV4dHVyZSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5kZXB0aFN0ZW5jaWxUZXh0dXJlKVxuICAgICAgICAgIGNoZWNrJDEoIWRlcHRoU3RlbmNpbFRleHR1cmUgfHwgZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlLFxuICAgICAgICAgICAgJ3dlYmdsX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gb3B0aW9ucy5kZXB0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhcbiAgICAgICAgICAgIG5lZWRzU3RlbmNpbCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdzdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0ZW5jaWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5zdGVuY2lsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGhTdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoU3RlbmNpbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVwdGhTdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgYXR0YWNobWVudHNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gbnVsbFxuICAgICAgdmFyIGRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuXG4gICAgICAvLyBTZXQgdXAgY29sb3IgYXR0YWNobWVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICBjb2xvckF0dGFjaG1lbnRzID0gY29sb3JCdWZmZXIubWFwKHBhcnNlQXR0YWNobWVudClcbiAgICAgIH0gZWxzZSBpZiAoY29sb3JCdWZmZXIpIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IFtwYXJzZUF0dGFjaG1lbnQoY29sb3JCdWZmZXIpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IG5ldyBBcnJheShjb2xvckNvdW50KVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JDb3VudDsgKytpKSB7XG4gICAgICAgICAgY29sb3JBdHRhY2htZW50c1tpXSA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JUZXh0dXJlLFxuICAgICAgICAgICAgY29sb3JGb3JtYXQsXG4gICAgICAgICAgICBjb2xvclR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyB8fCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aCA8PSAxLFxuICAgICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBXRUJHTF9kcmF3X2J1ZmZlcnMgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBtdWx0aXBsZSBjb2xvciBidWZmZXJzLicpXG4gICAgICBjaGVjayQxKGNvbG9yQXR0YWNobWVudHMubGVuZ3RoIDw9IGxpbWl0cy5tYXhDb2xvckF0dGFjaG1lbnRzLFxuICAgICAgICAndG9vIG1hbnkgY29sb3IgYXR0YWNobWVudHMsIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgICB3aWR0aCA9IHdpZHRoIHx8IGNvbG9yQXR0YWNobWVudHNbMF0ud2lkdGhcbiAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBjb2xvckF0dGFjaG1lbnRzWzBdLmhlaWdodFxuXG4gICAgICBpZiAoZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KGRlcHRoQnVmZmVyKVxuICAgICAgfSBlbHNlIGlmIChuZWVkc0RlcHRoICYmICFuZWVkc1N0ZW5jaWwpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgJ3VpbnQzMicpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgIHN0ZW5jaWxBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzU3RlbmNpbCAmJiAhbmVlZHNEZXB0aCkge1xuICAgICAgICBzdGVuY2lsQXR0YWNobWVudCA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ3N0ZW5jaWwnLFxuICAgICAgICAgICd1aW50OCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChkZXB0aFN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudChkZXB0aFN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKCFkZXB0aEJ1ZmZlciAmJiAhc3RlbmNpbEJ1ZmZlciAmJiBuZWVkc1N0ZW5jaWwgJiYgbmVlZHNEZXB0aCkge1xuICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCBzdGVuY2lsJyxcbiAgICAgICAgICAnZGVwdGggc3RlbmNpbCcpXG4gICAgICB9XG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgICghIWRlcHRoQnVmZmVyKSArICghIXN0ZW5jaWxCdWZmZXIpICsgKCEhZGVwdGhTdGVuY2lsQnVmZmVyKSA8PSAxLFxuICAgICAgICAnaW52YWxpZCBmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uLCBjYW4gc3BlY2lmeSBleGFjdGx5IG9uZSBkZXB0aC9zdGVuY2lsIGF0dGFjaG1lbnQnKVxuXG4gICAgICB2YXIgY29tbW9uQ29sb3JBdHRhY2htZW50U2l6ZSA9IG51bGxcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShjb2xvckF0dGFjaG1lbnRzW2ldLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBjaGVjayQxKCFjb2xvckF0dGFjaG1lbnRzW2ldIHx8XG4gICAgICAgICAgKGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSAmJlxuICAgICAgICAgICAgY29sb3JUZXh0dXJlRm9ybWF0RW51bXMuaW5kZXhPZihjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUuZm9ybWF0KSA+PSAwKSB8fFxuICAgICAgICAgIChjb2xvckF0dGFjaG1lbnRzW2ldLnJlbmRlcmJ1ZmZlciAmJlxuICAgICAgICAgICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRFbnVtcy5pbmRleE9mKGNvbG9yQXR0YWNobWVudHNbaV0ucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZm9ybWF0KSA+PSAwKSxcbiAgICAgICAgJ2ZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgJyArIGkgKyAnIGlzIGludmFsaWQnKVxuXG4gICAgICAgIGlmIChjb2xvckF0dGFjaG1lbnRzW2ldICYmIGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSkge1xuICAgICAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRTaXplID1cbiAgICAgICAgICAgICAgdGV4dHVyZUZvcm1hdENoYW5uZWxzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS5mb3JtYXRdICpcbiAgICAgICAgICAgICAgdGV4dHVyZVR5cGVTaXplc1tjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUudHlwZV1cblxuICAgICAgICAgIGlmIChjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gY29sb3JBdHRhY2htZW50U2l6ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBjb2xvciBhdHRhY2htZW50cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRwbGFuZXNcbiAgICAgICAgICAgIC8vICh0aGF0IGlzLCB0aGUgc2FtZSBudW1lciBvZiBiaXRzIHBlciBwaXhlbClcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgdGhlIEdMRVMyLjAgc3RhbmRhcmQuIFNlZSB0aGUgYmVnaW5uaW5nIG9mIENoYXB0ZXIgNCBpbiB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgY2hlY2skMShjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBjb2xvckF0dGFjaG1lbnRTaXplLFxuICAgICAgICAgICAgICAnYWxsIGNvbG9yIGF0dGFjaG1lbnRzIG11Y2ggaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYml0cyBwZXIgcGl4ZWwuJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluY1JlZkFuZENoZWNrU2hhcGUoZGVwdGhBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhBdHRhY2htZW50IHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQudGV4dHVyZSAmJlxuICAgICAgICAgIGRlcHRoQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UJDEpIHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyICYmXG4gICAgICAgICAgZGVwdGhBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UMTYkMSksXG4gICAgICAnaW52YWxpZCBkZXB0aCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShzdGVuY2lsQXR0YWNobWVudCwgd2lkdGgsIGhlaWdodClcbiAgICAgIGNoZWNrJDEoIXN0ZW5jaWxBdHRhY2htZW50IHx8XG4gICAgICAgIChzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQgPT09IEdMX1NURU5DSUxfSU5ERVg4JDEpLFxuICAgICAgJ2ludmFsaWQgc3RlbmNpbCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShkZXB0aFN0ZW5jaWxBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhTdGVuY2lsQXR0YWNobWVudCB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlICYmXG4gICAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSxcbiAgICAgICdpbnZhbGlkIGRlcHRoLXN0ZW5jaWwgYXR0YWNobWVudCBmb3IgZnJhbWVidWZmZXIgb2JqZWN0JylcblxuICAgICAgLy8gZGVjcmVtZW50IHJlZmVyZW5jZXNcbiAgICAgIGRlY0ZCT1JlZnMoZnJhbWVidWZmZXIpXG5cbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGhcbiAgICAgIGZyYW1lYnVmZmVyLmhlaWdodCA9IGhlaWdodFxuXG4gICAgICBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzID0gY29sb3JBdHRhY2htZW50c1xuICAgICAgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50ID0gZGVwdGhBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCA9IHN0ZW5jaWxBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gZGVwdGhTdGVuY2lsQXR0YWNobWVudFxuXG4gICAgICByZWdsRnJhbWVidWZmZXIuY29sb3IgPSBjb2xvckF0dGFjaG1lbnRzLm1hcCh1bndyYXBBdHRhY2htZW50KVxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmRlcHRoID0gdW53cmFwQXR0YWNobWVudChkZXB0aEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuc3RlbmNpbCA9IHVud3JhcEF0dGFjaG1lbnQoc3RlbmNpbEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsID0gdW53cmFwQXR0YWNobWVudChkZXB0aFN0ZW5jaWxBdHRhY2htZW50KVxuXG4gICAgICByZWdsRnJhbWVidWZmZXIud2lkdGggPSBmcmFtZWJ1ZmZlci53aWR0aFxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmhlaWdodCA9IGZyYW1lYnVmZmVyLmhlaWdodFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHJlc2l6ZSBhIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgdyA9IE1hdGgubWF4KHdfIHwgMCwgMSlcbiAgICAgIHZhciBoID0gTWF0aC5tYXgoKGhfIHwgMCkgfHwgdywgMSlcbiAgICAgIGlmICh3ID09PSBmcmFtZWJ1ZmZlci53aWR0aCAmJiBoID09PSBmcmFtZWJ1ZmZlci5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyByZXNpemUgYWxsIGJ1ZmZlcnNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoY29sb3JBdHRhY2htZW50c1tpXSwgdywgaClcbiAgICAgIH1cbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50LCB3LCBoKVxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCwgdywgaClcbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudCwgdywgaClcblxuICAgICAgZnJhbWVidWZmZXIud2lkdGggPSByZWdsRnJhbWVidWZmZXIud2lkdGggPSB3XG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSByZWdsRnJhbWVidWZmZXIuaGVpZ2h0ID0gaFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlcihhMCwgYTEpXG5cbiAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlciwge1xuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlcicsXG4gICAgICBfZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95KGZyYW1lYnVmZmVyKVxuICAgICAgICBkZWNGQk9SZWZzKGZyYW1lYnVmZmVyKVxuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgICAgICBmcmFtZWJ1ZmZlcjogcmVnbEZyYW1lYnVmZmVyXG4gICAgICAgIH0sIGJsb2NrKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDdWJlRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIGZhY2VzID0gQXJyYXkoNilcblxuICAgIGZ1bmN0aW9uIHJlZ2xGcmFtZWJ1ZmZlckN1YmUgKGEpIHtcbiAgICAgIHZhciBpXG5cbiAgICAgIGNoZWNrJDEoZmFjZXMuaW5kZXhPZihmcmFtZWJ1ZmZlclN0YXRlLm5leHQpIDwgMCxcbiAgICAgICAgJ2NhbiBub3QgdXBkYXRlIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBjb2xvcjogbnVsbFxuICAgICAgfVxuXG4gICAgICB2YXIgcmFkaXVzID0gMFxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JGb3JtYXQgPSAncmdiYSdcbiAgICAgIHZhciBjb2xvclR5cGUgPSAndWludDgnXG4gICAgICB2YXIgY29sb3JDb3VudCA9IDFcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICByYWRpdXMgPSBhIHwgMFxuICAgICAgfSBlbHNlIGlmICghYSkge1xuICAgICAgICByYWRpdXMgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgIHNoYXBlWzBdID09PSBzaGFwZVsxXSxcbiAgICAgICAgICAgICdjdWJlIGZyYW1lYnVmZmVyIG11c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICByYWRpdXMgPSBzaGFwZVswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICAgIGlmICgnaGVpZ2h0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEob3B0aW9ucy5oZWlnaHQgPT09IHJhZGl1cywgJ211c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9wdGlvbnMuaGVpZ2h0IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnY29sb3InIGluIG9wdGlvbnMgfHxcbiAgICAgICAgICAgICdjb2xvcnMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yc1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgY29sb3JCdWZmZXIubGVuZ3RoID09PSAxIHx8IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzLFxuICAgICAgICAgICAgICAnbXVsdGlwbGUgcmVuZGVyIHRhcmdldHMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvckJ1ZmZlcikge1xuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JDb3VudCA9IG9wdGlvbnMuY29sb3JDb3VudCB8IDBcbiAgICAgICAgICAgIGNoZWNrJDEoY29sb3JDb3VudCA+IDAsICdpbnZhbGlkIGNvbG9yIGJ1ZmZlciBjb3VudCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvclR5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JUeXBlLCBjb2xvclR5cGVzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciB0eXBlJylcbiAgICAgICAgICAgIGNvbG9yVHlwZSA9IG9wdGlvbnMuY29sb3JUeXBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvckZvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0XG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxuICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclRleHR1cmVGb3JtYXRzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGggPSBvcHRpb25zLmRlcHRoXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IG9wdGlvbnMuc3RlbmNpbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aFN0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JDdWJlc1xuICAgICAgaWYgKGNvbG9yQnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbXVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29sb3JDdWJlc1tpXSA9IGNvbG9yQnVmZmVyW2ldXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbIGNvbG9yQnVmZmVyIF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JDdWJlcyA9IEFycmF5KGNvbG9yQ291bnQpXG4gICAgICAgIHZhciBjdWJlTWFwUGFyYW1zID0ge1xuICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgIGZvcm1hdDogY29sb3JGb3JtYXQsXG4gICAgICAgICAgdHlwZTogY29sb3JUeXBlXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQ291bnQ7ICsraSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXNbaV0gPSB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZShjdWJlTWFwUGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGNvbG9yIGN1YmVzXG4gICAgICBwYXJhbXMuY29sb3IgPSBBcnJheShjb2xvckN1YmVzLmxlbmd0aClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckN1YmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdWJlID0gY29sb3JDdWJlc1tpXVxuICAgICAgICBjaGVjayQxKFxuICAgICAgICAgIHR5cGVvZiBjdWJlID09PSAnZnVuY3Rpb24nICYmIGN1YmUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnLFxuICAgICAgICAgICdpbnZhbGlkIGN1YmUgbWFwJylcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IGN1YmUud2lkdGhcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBjdWJlLndpZHRoID09PSByYWRpdXMgJiYgY3ViZS5oZWlnaHQgPT09IHJhZGl1cyxcbiAgICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCBzaGFwZScpXG4gICAgICAgIHBhcmFtcy5jb2xvcltpXSA9IHtcbiAgICAgICAgICB0YXJnZXQ6IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyLFxuICAgICAgICAgIGRhdGE6IGNvbG9yQ3ViZXNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sb3JDdWJlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHBhcmFtcy5jb2xvcltqXS50YXJnZXQgPSBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiArIGlcbiAgICAgICAgfVxuICAgICAgICAvLyByZXVzZSBkZXB0aC1zdGVuY2lsIGF0dGFjaG1lbnRzIGFjcm9zcyBhbGwgY3ViZSBtYXBzXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHBhcmFtcy5kZXB0aCA9IGZhY2VzWzBdLmRlcHRoXG4gICAgICAgICAgcGFyYW1zLnN0ZW5jaWwgPSBmYWNlc1swXS5zdGVuY2lsXG4gICAgICAgICAgcGFyYW1zLmRlcHRoU3RlbmNpbCA9IGZhY2VzWzBdLmRlcHRoU3RlbmNpbFxuICAgICAgICB9XG4gICAgICAgIGlmIChmYWNlc1tpXSkge1xuICAgICAgICAgIChmYWNlc1tpXSkocGFyYW1zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2VzW2ldID0gY3JlYXRlRkJPKHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlckN1YmUsIHtcbiAgICAgICAgd2lkdGg6IHJhZGl1cyxcbiAgICAgICAgaGVpZ2h0OiByYWRpdXMsXG4gICAgICAgIGNvbG9yOiBjb2xvckN1YmVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIGlcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNfIHwgMFxuICAgICAgY2hlY2skMShyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSBsaW1pdHMubWF4Q3ViZU1hcFNpemUsXG4gICAgICAgICdpbnZhbGlkIHJhZGl1cyBmb3IgY3ViZSBmYm8nKVxuXG4gICAgICBpZiAocmFkaXVzID09PSByZWdsRnJhbWVidWZmZXJDdWJlLndpZHRoKSB7XG4gICAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvcnMgPSByZWdsRnJhbWVidWZmZXJDdWJlLmNvbG9yXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbG9yc1tpXS5yZXNpemUocmFkaXVzKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldLnJlc2l6ZShyYWRpdXMpXG4gICAgICB9XG5cbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUud2lkdGggPSByZWdsRnJhbWVidWZmZXJDdWJlLmhlaWdodCA9IHJhZGl1c1xuXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyQ3ViZVxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUob3B0aW9ucylcblxuICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyQ3ViZSwge1xuICAgICAgZmFjZXM6IGZhY2VzLFxuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlckN1YmUnLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgZi5kZXN0cm95KClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZUZyYW1lYnVmZmVycyAoKSB7XG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBudWxsXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID0gbnVsbFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuZGlydHkgPSB0cnVlXG4gICAgdmFsdWVzKGZyYW1lYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChmYikge1xuICAgICAgZmIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmYilcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuZChmcmFtZWJ1ZmZlclN0YXRlLCB7XG4gICAgZ2V0RnJhbWVidWZmZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nICYmIG9iamVjdC5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpIHtcbiAgICAgICAgdmFyIGZibyA9IG9iamVjdC5fZnJhbWVidWZmZXJcbiAgICAgICAgaWYgKGZibyBpbnN0YW5jZW9mIFJFR0xGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBmYm9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlRkJPLFxuICAgIGNyZWF0ZUN1YmU6IGNyZWF0ZUN1YmVGQk8sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhmcmFtZWJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZUZyYW1lYnVmZmVyc1xuICB9KVxufVxuXG52YXIgR0xfRkxPQVQkNiA9IDUxMjZcbnZhciBHTF9BUlJBWV9CVUZGRVIkMSA9IDM0OTYyXG5cbmZ1bmN0aW9uIEF0dHJpYnV0ZVJlY29yZCAoKSB7XG4gIHRoaXMuc3RhdGUgPSAwXG5cbiAgdGhpcy54ID0gMC4wXG4gIHRoaXMueSA9IDAuMFxuICB0aGlzLnogPSAwLjBcbiAgdGhpcy53ID0gMC4wXG5cbiAgdGhpcy5idWZmZXIgPSBudWxsXG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2VcbiAgdGhpcy50eXBlID0gR0xfRkxPQVQkNlxuICB0aGlzLm9mZnNldCA9IDBcbiAgdGhpcy5zdHJpZGUgPSAwXG4gIHRoaXMuZGl2aXNvciA9IDBcbn1cblxuZnVuY3Rpb24gd3JhcEF0dHJpYnV0ZVN0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgc3RhdHMsXG4gIGJ1ZmZlclN0YXRlKSB7XG4gIHZhciBOVU1fQVRUUklCVVRFUyA9IGxpbWl0cy5tYXhBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IG5ldyBBcnJheShOVU1fQVRUUklCVVRFUylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOVU1fQVRUUklCVVRFUzsgKytpKSB7XG4gICAgYXR0cmlidXRlQmluZGluZ3NbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgfVxuICB2YXIgdmFvQ291bnQgPSAwXG4gIHZhciB2YW9TZXQgPSB7fVxuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBSZWNvcmQ6IEF0dHJpYnV0ZVJlY29yZCxcbiAgICBzY29wZToge30sXG4gICAgc3RhdGU6IGF0dHJpYnV0ZUJpbmRpbmdzLFxuICAgIGN1cnJlbnRWQU86IG51bGwsXG4gICAgdGFyZ2V0VkFPOiBudWxsLFxuICAgIHJlc3RvcmU6IGV4dFZBTygpID8gcmVzdG9yZVZBTyA6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGNyZWF0ZVZBTzogY3JlYXRlVkFPLFxuICAgIGdldFZBTzogZ2V0VkFPLFxuICAgIGRlc3Ryb3lCdWZmZXI6IGRlc3Ryb3lCdWZmZXIsXG4gICAgc2V0VkFPOiBleHRWQU8oKSA/IHNldFZBT0VYVCA6IHNldFZBT0VtdWxhdGVkLFxuICAgIGNsZWFyOiBleHRWQU8oKSA/IGRlc3Ryb3lWQU9FWFQgOiBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHJlY29yZCA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICBpZiAocmVjb3JkLmJ1ZmZlciA9PT0gYnVmZmVyKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgICByZWNvcmQuYnVmZmVyID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dFZBTyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dEluc3RhbmNlZCAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5c1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VkFPICh2YW8pIHtcbiAgICBpZiAodHlwZW9mIHZhbyA9PT0gJ2Z1bmN0aW9uJyAmJiB2YW8uX3Zhbykge1xuICAgICAgcmV0dXJuIHZhby5fdmFvXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRWQU9FWFQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAodmFvKSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby52YW8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbClcbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VkFPRW11bGF0ZWQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFvKSB7XG4gICAgICB2YW8uYmluZEF0dHJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4dGkgPSBleHRJbnN0YW5jZWQoKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICAgIGlmIChiaW5kaW5nLmJ1ZmZlcikge1xuICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBiaW5kaW5nLnNpemUsIGJpbmRpbmcudHlwZSwgYmluZGluZy5ub3JtYWxpemVkLCBiaW5kaW5nLnN0cmlkZSwgYmluZGluZy5vZmZmc2V0KVxuICAgICAgICAgIGlmIChleHRpICYmIGJpbmRpbmcuZGl2aXNvcikge1xuICAgICAgICAgICAgZXh0aS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaSwgYmluZGluZy5kaXZpc29yKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZihpLCBiaW5kaW5nLngsIGJpbmRpbmcueSwgYmluZGluZy56LCBiaW5kaW5nLncpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVZBT0VYVCAoKSB7XG4gICAgdmFsdWVzKHZhb1NldCkuZm9yRWFjaChmdW5jdGlvbiAodmFvKSB7XG4gICAgICB2YW8uZGVzdHJveSgpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFJFR0xWQU8gKCkge1xuICAgIHRoaXMuaWQgPSArK3Zhb0NvdW50XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW11cbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0VkFPKClcbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICB0aGlzLnZhbyA9IGV4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFvID0gbnVsbFxuICAgIH1cbiAgICB2YW9TZXRbdGhpcy5pZF0gPSB0aGlzXG4gICAgdGhpcy5idWZmZXJzID0gW11cbiAgfVxuXG4gIFJFR0xWQU8ucHJvdG90eXBlLmJpbmRBdHRycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0aSA9IGV4dEluc3RhbmNlZCgpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXVxuICAgICAgaWYgKGF0dHIuYnVmZmVyKSB7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoR0xfQVJSQVlfQlVGRkVSJDEsIGF0dHIuYnVmZmVyLmJ1ZmZlcilcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkLCBhdHRyLnN0cmlkZSwgYXR0ci5vZmZzZXQpXG4gICAgICAgIGlmIChleHRpICYmIGF0dHIuZGl2aXNvcikge1xuICAgICAgICAgIGV4dGkudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGksIGF0dHIuZGl2aXNvcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjRmKGksIGF0dHIueCwgYXR0ci55LCBhdHRyLnosIGF0dHIudylcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgTlVNX0FUVFJJQlVURVM7ICsraikge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGopXG4gICAgfVxuICB9XG5cbiAgUkVHTFZBTy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAoZXh0KSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHRoaXMudmFvKVxuICAgICAgdGhpcy5iaW5kQXR0cnMoKVxuICAgICAgc3RhdGUuY3VycmVudFZBTyA9IHRoaXNcbiAgICB9XG4gIH1cblxuICBSRUdMVkFPLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZhbykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dFZBTygpXG4gICAgICBpZiAodGhpcyA9PT0gc3RhdGUuY3VycmVudFZBTykge1xuICAgICAgICBzdGF0ZS5jdXJyZW50VkFPID0gbnVsbFxuICAgICAgICBleHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpXG4gICAgICB9XG4gICAgICBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pXG4gICAgICB0aGlzLnZhbyA9IG51bGxcbiAgICB9XG4gICAgaWYgKHZhb1NldFt0aGlzLmlkXSkge1xuICAgICAgZGVsZXRlIHZhb1NldFt0aGlzLmlkXVxuICAgICAgc3RhdHMudmFvQ291bnQgLT0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVWQU8gKCkge1xuICAgIHZhciBleHQgPSBleHRWQU8oKVxuICAgIGlmIChleHQpIHtcbiAgICAgIHZhbHVlcyh2YW9TZXQpLmZvckVhY2goZnVuY3Rpb24gKHZhbykge1xuICAgICAgICB2YW8ucmVmcmVzaCgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZBTyAoX2F0dHIpIHtcbiAgICB2YXIgdmFvID0gbmV3IFJFR0xWQU8oKVxuICAgIHN0YXRzLnZhb0NvdW50ICs9IDFcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZBTyAoYXR0cmlidXRlcykge1xuICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpLCAnYXJndW1lbnRzIHRvIHZlcnRleCBhcnJheSBjb25zdHJ1Y3RvciBtdXN0IGJlIGFuIGFycmF5JylcbiAgICAgIGNoZWNrJDEoYXR0cmlidXRlcy5sZW5ndGggPCBOVU1fQVRUUklCVVRFUywgJ3RvbyBtYW55IGF0dHJpYnV0ZXMnKVxuICAgICAgY2hlY2skMShhdHRyaWJ1dGVzLmxlbmd0aCA+IDAsICdtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZScpXG5cbiAgICAgIHZhciBidWZVcGRhdGVkID0ge31cbiAgICAgIHZhciBuYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzXG4gICAgICBuYXR0cmlidXRlcy5sZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGVjID0gYXR0cmlidXRlc1tpXVxuICAgICAgICB2YXIgcmVjID0gbmF0dHJpYnV0ZXNbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgICAgdmFyIGRhdGEgPSBzcGVjLmRhdGEgfHwgc3BlY1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1R5cGVkQXJyYXkoZGF0YSkgfHwgaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgICAgIHZhciBidWZcbiAgICAgICAgICBpZiAodmFvLmJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgIGJ1ZiA9IHZhby5idWZmZXJzW2ldXG4gICAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpICYmIGJ1Zi5fYnVmZmVyLmJ5dGVMZW5ndGggPj0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJ1Zi5zdWJkYXRhKGRhdGEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBidWYuZGVzdHJveSgpXG4gICAgICAgICAgICAgIHZhby5idWZmZXJzW2ldID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhby5idWZmZXJzW2ldKSB7XG4gICAgICAgICAgICBidWYgPSB2YW8uYnVmZmVyc1tpXSA9IGJ1ZmZlclN0YXRlLmNyZWF0ZShzcGVjLCBHTF9BUlJBWV9CVUZGRVIkMSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoYnVmKVxuICAgICAgICAgIHJlYy5zaXplID0gcmVjLmJ1ZmZlci5kaW1lbnNpb24gfCAwXG4gICAgICAgICAgcmVjLm5vcm1hbGl6ZWQgPSBmYWxzZVxuICAgICAgICAgIHJlYy50eXBlID0gcmVjLmJ1ZmZlci5kdHlwZVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IDBcbiAgICAgICAgICByZWMuc3RhdGUgPSAxXG4gICAgICAgICAgYnVmVXBkYXRlZFtpXSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYykpIHtcbiAgICAgICAgICByZWMuYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHNwZWMpXG4gICAgICAgICAgcmVjLnNpemUgPSByZWMuYnVmZmVyLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgICByZWMubm9ybWFsaXplZCA9IGZhbHNlXG4gICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgcmVjLm9mZnNldCA9IDBcbiAgICAgICAgICByZWMuc3RyaWRlID0gMFxuICAgICAgICAgIHJlYy5kaXZpc29yID0gMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYy5idWZmZXIpKSB7XG4gICAgICAgICAgcmVjLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihzcGVjLmJ1ZmZlcilcbiAgICAgICAgICByZWMuc2l6ZSA9ICgoK3NwZWMuc2l6ZSkgfHwgcmVjLmJ1ZmZlci5kaW1lbnNpb24pIHwgMFxuICAgICAgICAgIHJlYy5ub3JtYWxpemVkID0gISFzcGVjLm5vcm1hbGl6ZWQgfHwgZmFsc2VcbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIHNwZWMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHNwZWMudHlwZSwgZ2xUeXBlcywgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgcmVjLnR5cGUgPSBnbFR5cGVzW3NwZWMudHlwZV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAoc3BlYy5vZmZzZXQgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IChzcGVjLnN0cmlkZSB8fCAwKSB8IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IChzcGVjLmRpdmlzb3IgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0YXRlID0gMVxuXG4gICAgICAgICAgY2hlY2skMShyZWMuc2l6ZSA+PSAxICYmIHJlYy5zaXplIDw9IDQsICdzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5vZmZzZXQgPj0gMCwgJ2ludmFsaWQgb2Zmc2V0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5zdHJpZGUgPj0gMCAmJiByZWMuc3RyaWRlIDw9IDI1NSwgJ3N0cmlkZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5kaXZpc29yID49IDAsICdkaXZpc29yIG11c3QgYmUgcG9zaXRpdmUnKVxuICAgICAgICAgIGNoZWNrJDEoIXJlYy5kaXZpc29yIHx8ICEhZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzLCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIGRpdmlzb3InKVxuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBzcGVjKSB7XG4gICAgICAgICAgY2hlY2skMShpID4gMCwgJ2ZpcnN0IGF0dHJpYnV0ZSBtdXN0IG5vdCBiZSBhIGNvbnN0YW50JylcbiAgICAgICAgICByZWMueCA9ICtzcGVjLnggfHwgMFxuICAgICAgICAgIHJlYy55ID0gK3NwZWMueSB8fCAwXG4gICAgICAgICAgcmVjLnogPSArc3BlYy56IHx8IDBcbiAgICAgICAgICByZWMudyA9ICtzcGVjLncgfHwgMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBhdHRyaWJ1dGUgc3BlYyBmb3IgbG9jYXRpb24gJyArIGkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmV0aXJlIHVudXNlZCBidWZmZXJzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhby5idWZmZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICghYnVmVXBkYXRlZFtqXSAmJiB2YW8uYnVmZmVyc1tqXSkge1xuICAgICAgICAgIHZhby5idWZmZXJzW2pdLmRlc3Ryb3koKVxuICAgICAgICAgIHZhby5idWZmZXJzW2pdID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhby5yZWZyZXNoKClcbiAgICAgIHJldHVybiB1cGRhdGVWQU9cbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFvLmJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKHZhby5idWZmZXJzW2pdKSB7XG4gICAgICAgICAgdmFvLmJ1ZmZlcnNbal0uZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhby5idWZmZXJzLmxlbmd0aCA9IDBcbiAgICAgIHZhby5kZXN0cm95KClcbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uX3ZhbyA9IHZhb1xuICAgIHVwZGF0ZVZBTy5fcmVnbFR5cGUgPSAndmFvJ1xuXG4gICAgcmV0dXJuIHVwZGF0ZVZBTyhfYXR0cilcbiAgfVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG52YXIgR0xfRlJBR01FTlRfU0hBREVSID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSID0gMzU2MzNcblxudmFyIEdMX0FDVElWRV9VTklGT1JNUyA9IDB4OEI4NlxudmFyIEdMX0FDVElWRV9BVFRSSUJVVEVTID0gMHg4Qjg5XG5cbmZ1bmN0aW9uIHdyYXBTaGFkZXJTdGF0ZSAoZ2wsIHN0cmluZ1N0b3JlLCBzdGF0cywgY29uZmlnKSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBnbHNsIGNvbXBpbGF0aW9uIGFuZCBsaW5raW5nXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgZnJhZ1NoYWRlcnMgPSB7fVxuICB2YXIgdmVydFNoYWRlcnMgPSB7fVxuXG4gIGZ1bmN0aW9uIEFjdGl2ZUluZm8gKG5hbWUsIGlkLCBsb2NhdGlvbiwgaW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb25cbiAgICB0aGlzLmluZm8gPSBpbmZvXG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBY3RpdmVJbmZvIChsaXN0LCBpbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobGlzdFtpXS5pZCA9PT0gaW5mby5pZCkge1xuICAgICAgICBsaXN0W2ldLmxvY2F0aW9uID0gaW5mby5sb2NhdGlvblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgbGlzdC5wdXNoKGluZm8pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaGFkZXIgKHR5cGUsIGlkLCBjb21tYW5kKSB7XG4gICAgdmFyIGNhY2hlID0gdHlwZSA9PT0gR0xfRlJBR01FTlRfU0hBREVSID8gZnJhZ1NoYWRlcnMgOiB2ZXJ0U2hhZGVyc1xuICAgIHZhciBzaGFkZXIgPSBjYWNoZVtpZF1cblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RyaW5nU3RvcmUuc3RyKGlkKVxuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcbiAgICAgIGNoZWNrJDEuc2hhZGVyRXJyb3IoZ2wsIHNoYWRlciwgc291cmNlLCB0eXBlLCBjb21tYW5kKVxuICAgICAgY2FjaGVbaWRdID0gc2hhZGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIHByb2dyYW0gbGlua2luZ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIHByb2dyYW1DYWNoZSA9IHt9XG4gIHZhciBwcm9ncmFtTGlzdCA9IFtdXG5cbiAgdmFyIFBST0dSQU1fQ09VTlRFUiA9IDBcblxuICBmdW5jdGlvbiBSRUdMUHJvZ3JhbSAoZnJhZ0lkLCB2ZXJ0SWQpIHtcbiAgICB0aGlzLmlkID0gUFJPR1JBTV9DT1VOVEVSKytcbiAgICB0aGlzLmZyYWdJZCA9IGZyYWdJZFxuICAgIHRoaXMudmVydElkID0gdmVydElkXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbFxuICAgIHRoaXMudW5pZm9ybXMgPSBbXVxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgdW5pZm9ybXNDb3VudDogMCxcbiAgICAgICAgYXR0cmlidXRlc0NvdW50OiAwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlua1Byb2dyYW0gKGRlc2MsIGNvbW1hbmQsIGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgIHZhciBpLCBpbmZvXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29tcGlsZSAmIGxpbmtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGZyYWdTaGFkZXIgPSBnZXRTaGFkZXIoR0xfRlJBR01FTlRfU0hBREVSLCBkZXNjLmZyYWdJZClcbiAgICB2YXIgdmVydFNoYWRlciA9IGdldFNoYWRlcihHTF9WRVJURVhfU0hBREVSLCBkZXNjLnZlcnRJZClcblxuICAgIHZhciBwcm9ncmFtID0gZGVzYy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpXG4gICAgaWYgKGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZUxvY2F0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUxvY2F0aW9uc1tpXVxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYmluZGluZ1swXSwgYmluZGluZ1sxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKVxuICAgIGNoZWNrJDEubGlua0Vycm9yKFxuICAgICAgZ2wsXG4gICAgICBwcm9ncmFtLFxuICAgICAgc3RyaW5nU3RvcmUuc3RyKGRlc2MuZnJhZ0lkKSxcbiAgICAgIHN0cmluZ1N0b3JlLnN0cihkZXNjLnZlcnRJZCksXG4gICAgICBjb21tYW5kKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdyYWIgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfVU5JRk9STVMpXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICBkZXNjLnN0YXRzLnVuaWZvcm1zQ291bnQgPSBudW1Vbmlmb3Jtc1xuICAgIH1cbiAgICB2YXIgdW5pZm9ybXMgPSBkZXNjLnVuaWZvcm1zXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyArK2kpIHtcbiAgICAgIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpZiAoaW5mby5zaXplID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5mby5zaXplOyArK2opIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICdbJyArIGogKyAnXScpXG4gICAgICAgICAgICBpbnNlcnRBY3RpdmVJbmZvKHVuaWZvcm1zLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQobmFtZSksXG4gICAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEFjdGl2ZUluZm8odW5pZm9ybXMsIG5ldyBBY3RpdmVJbmZvKFxuICAgICAgICAgICAgaW5mby5uYW1lLFxuICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgICAgaW5mbykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ3JhYiBhdHRyaWJ1dGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfQVRUUklCVVRFUylcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50ID0gbnVtQXR0cmlidXRlc1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZGVzYy5hdHRyaWJ1dGVzXG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7ICsraSkge1xuICAgICAgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5zZXJ0QWN0aXZlSW5mbyhhdHRyaWJ1dGVzLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICBpbmZvLm5hbWUsXG4gICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgIGluZm8pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldE1heFVuaWZvcm1zQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbSA9IDBcbiAgICAgIHByb2dyYW1MaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgaWYgKGRlc2Muc3RhdHMudW5pZm9ybXNDb3VudCA+IG0pIHtcbiAgICAgICAgICBtID0gZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cblxuICAgIHN0YXRzLmdldE1heEF0dHJpYnV0ZXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtID0gMFxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnQgPiBtKSB7XG4gICAgICAgICAgbSA9IGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTaGFkZXJzICgpIHtcbiAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgdmVydFNoYWRlcnMgPSB7fVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW1MaXN0W2ldLCBudWxsLCBwcm9ncmFtTGlzdFtpXS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICByZXR1cm4gW2luZm8ubG9jYXRpb24sIGluZm8ubmFtZV1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWxldGVTaGFkZXIgPSBnbC5kZWxldGVTaGFkZXIuYmluZChnbClcbiAgICAgIHZhbHVlcyhmcmFnU2hhZGVycykuZm9yRWFjaChkZWxldGVTaGFkZXIpXG4gICAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgICB2YWx1ZXModmVydFNoYWRlcnMpLmZvckVhY2goZGVsZXRlU2hhZGVyKVxuICAgICAgdmVydFNoYWRlcnMgPSB7fVxuXG4gICAgICBwcm9ncmFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oZGVzYy5wcm9ncmFtKVxuICAgICAgfSlcbiAgICAgIHByb2dyYW1MaXN0Lmxlbmd0aCA9IDBcbiAgICAgIHByb2dyYW1DYWNoZSA9IHt9XG5cbiAgICAgIHN0YXRzLnNoYWRlckNvdW50ID0gMFxuICAgIH0sXG5cbiAgICBwcm9ncmFtOiBmdW5jdGlvbiAodmVydElkLCBmcmFnSWQsIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgY2hlY2skMS5jb21tYW5kKHZlcnRJZCA+PSAwLCAnbWlzc2luZyB2ZXJ0ZXggc2hhZGVyJywgY29tbWFuZClcbiAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFnSWQgPj0gMCwgJ21pc3NpbmcgZnJhZ21lbnQgc2hhZGVyJywgY29tbWFuZClcblxuICAgICAgdmFyIGNhY2hlID0gcHJvZ3JhbUNhY2hlW2ZyYWdJZF1cbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBwcm9ncmFtQ2FjaGVbZnJhZ0lkXSA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgcHJldlByb2dyYW0gPSBjYWNoZVt2ZXJ0SWRdXG4gICAgICBpZiAocHJldlByb2dyYW0pIHtcbiAgICAgICAgcHJldlByb2dyYW0ucmVmQ291bnQrK1xuICAgICAgICBpZiAoIWF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICAgIHJldHVybiBwcmV2UHJvZ3JhbVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBSRUdMUHJvZ3JhbShmcmFnSWQsIHZlcnRJZClcbiAgICAgIHN0YXRzLnNoYWRlckNvdW50KytcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW0sIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucylcbiAgICAgIGlmICghcHJldlByb2dyYW0pIHtcbiAgICAgICAgY2FjaGVbdmVydElkXSA9IHByb2dyYW1cbiAgICAgIH1cbiAgICAgIHByb2dyYW1MaXN0LnB1c2gocHJvZ3JhbSlcbiAgICAgIHJldHVybiBleHRlbmQocHJvZ3JhbSwge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvZ3JhbS5yZWZDb3VudC0tXG4gICAgICAgICAgaWYgKHByb2dyYW0ucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtLnByb2dyYW0pXG4gICAgICAgICAgICB2YXIgaWR4ID0gcHJvZ3JhbUxpc3QuaW5kZXhPZihwcm9ncmFtKVxuICAgICAgICAgICAgcHJvZ3JhbUxpc3Quc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICAgIHN0YXRzLnNoYWRlckNvdW50LS1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyB2ZXJ0IGFueW1vcmVcbiAgICAgICAgICBpZiAoY2FjaGVbcHJvZ3JhbS52ZXJ0SWRdLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0U2hhZGVyc1twcm9ncmFtLnZlcnRJZF0pXG4gICAgICAgICAgICBkZWxldGUgdmVydFNoYWRlcnNbcHJvZ3JhbS52ZXJ0SWRdXG4gICAgICAgICAgICBkZWxldGUgcHJvZ3JhbUNhY2hlW3Byb2dyYW0uZnJhZ0lkXVtwcm9ncmFtLnZlcnRJZF1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyBmcmFnIGFueW1vcmVcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHByb2dyYW1DYWNoZVtwcm9ncmFtLmZyYWdJZF0pLmxlbmd0aCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdTaGFkZXJzW3Byb2dyYW0uZnJhZ0lkXSlcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFnU2hhZGVyc1twcm9ncmFtLmZyYWdJZF1cbiAgICAgICAgICAgIGRlbGV0ZSBwcm9ncmFtQ2FjaGVbcHJvZ3JhbS5mcmFnSWRdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlU2hhZGVycyxcblxuICAgIHNoYWRlcjogZ2V0U2hhZGVyLFxuXG4gICAgZnJhZzogLTEsXG4gICAgdmVydDogLTFcbiAgfVxufVxuXG52YXIgR0xfUkdCQSQzID0gNjQwOFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNyA9IDUxMjFcbnZhciBHTF9QQUNLX0FMSUdOTUVOVCA9IDB4MEQwNVxudmFyIEdMX0ZMT0FUJDcgPSAweDE0MDYgLy8gNTEyNlxuXG5mdW5jdGlvbiB3cmFwUmVhZFBpeGVscyAoXG4gIGdsLFxuICBmcmFtZWJ1ZmZlclN0YXRlLFxuICByZWdsUG9sbCxcbiAgY29udGV4dCxcbiAgZ2xBdHRyaWJ1dGVzLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMpIHtcbiAgZnVuY3Rpb24gcmVhZFBpeGVsc0ltcGwgKGlucHV0KSB7XG4gICAgdmFyIHR5cGVcbiAgICBpZiAoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID09PSBudWxsKSB7XG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAneW91IG11c3QgY3JlYXRlIGEgd2ViZ2wgY29udGV4dCB3aXRoIFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCI6dHJ1ZSBpbiBvcmRlciB0byByZWFkIHBpeGVscyBmcm9tIHRoZSBkcmF3aW5nIGJ1ZmZlcicpXG4gICAgICB0eXBlID0gR0xfVU5TSUdORURfQllURSQ3XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUubmV4dC5jb2xvckF0dGFjaG1lbnRzWzBdLnRleHR1cmUgIT09IG51bGwsXG4gICAgICAgICdZb3UgY2Fubm90IHJlYWQgZnJvbSBhIHJlbmRlcmJ1ZmZlcicpXG4gICAgICB0eXBlID0gZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmNvbG9yQXR0YWNobWVudHNbMF0udGV4dHVyZS5fdGV4dHVyZS50eXBlXG5cbiAgICAgIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3IHx8IHR5cGUgPT09IEdMX0ZMT0FUJDcsXG4gICAgICAgICAgJ1JlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIHR5cGVzIFxcJ3VpbnQ4XFwnIGFuZCBcXCdmbG9hdFxcJycpXG5cbiAgICAgICAgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcbiAgICAgICAgICBjaGVjayQxKGxpbWl0cy5yZWFkRmxvYXQsICdSZWFkaW5nIFxcJ2Zsb2F0XFwnIHZhbHVlcyBpcyBub3QgcGVybWl0dGVkIGluIHlvdXIgYnJvd3Nlci4gRm9yIGEgZmFsbGJhY2ssIHBsZWFzZSBzZWU6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dsc2wtcmVhZC1mbG9hdCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3LFxuICAgICAgICAgICdSZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSB0eXBlIFxcJ3VpbnQ4XFwnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCA9IDBcbiAgICB2YXIgeSA9IDBcbiAgICB2YXIgd2lkdGggPSBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodFxuICAgIHZhciBkYXRhID0gbnVsbFxuXG4gICAgaWYgKGlzVHlwZWRBcnJheShpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dFxuICAgIH0gZWxzZSBpZiAoaW5wdXQpIHtcbiAgICAgIGNoZWNrJDEudHlwZShpbnB1dCwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsLnJlYWQoKScpXG4gICAgICB4ID0gaW5wdXQueCB8IDBcbiAgICAgIHkgPSBpbnB1dC55IHwgMFxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHggPCBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGgsXG4gICAgICAgICdpbnZhbGlkIHggb2Zmc2V0IGZvciByZWdsLnJlYWQnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeSA+PSAwICYmIHkgPCBjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0LFxuICAgICAgICAnaW52YWxpZCB5IG9mZnNldCBmb3IgcmVnbC5yZWFkJylcbiAgICAgIHdpZHRoID0gKGlucHV0LndpZHRoIHx8IChjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGggLSB4KSkgfCAwXG4gICAgICBoZWlnaHQgPSAoaW5wdXQuaGVpZ2h0IHx8IChjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0IC0geSkpIHwgMFxuICAgICAgZGF0YSA9IGlucHV0LmRhdGEgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBpbnB1dC5kYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcpIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnVWludDhBcnJheVxcJyB3aGVuIHJlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIG9mIHR5cGUgXFwndWludDhcXCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnRmxvYXQzMkFycmF5XFwnIHdoZW4gcmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgb2YgdHlwZSBcXCdmbG9hdFxcJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMShcbiAgICAgIHdpZHRoID4gMCAmJiB3aWR0aCArIHggPD0gY29udGV4dC5mcmFtZWJ1ZmZlcldpZHRoLFxuICAgICAgJ2ludmFsaWQgd2lkdGggZm9yIHJlYWQgcGl4ZWxzJylcbiAgICBjaGVjayQxKFxuICAgICAgaGVpZ2h0ID4gMCAmJiBoZWlnaHQgKyB5IDw9IGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQsXG4gICAgICAnaW52YWxpZCBoZWlnaHQgZm9yIHJlYWQgcGl4ZWxzJylcblxuICAgIC8vIFVwZGF0ZSBXZWJHTCBzdGF0ZVxuICAgIHJlZ2xQb2xsKClcblxuICAgIC8vIENvbXB1dGUgc2l6ZVxuICAgIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQgKiA0XG5cbiAgICAvLyBBbGxvY2F0ZSBkYXRhXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAodHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3KSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGNoZWNrXG4gICAgY2hlY2skMS5pc1R5cGVkQXJyYXkoZGF0YSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSBtdXN0IGJlIGEgdHlwZWRhcnJheScpXG4gICAgY2hlY2skMShkYXRhLmJ5dGVMZW5ndGggPj0gc2l6ZSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSB0b28gc21hbGwnKVxuXG4gICAgLy8gUnVuIHJlYWQgcGl4ZWxzXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfUEFDS19BTElHTk1FTlQsIDQpXG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBHTF9SR0JBJDMsXG4gICAgICB0eXBlLFxuICAgICAgZGF0YSlcblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiByZWFkUGl4ZWxzRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgIGZyYW1lYnVmZmVyOiBvcHRpb25zLmZyYW1lYnVmZmVyXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdWx0ID0gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHMgKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgISgnZnJhbWVidWZmZXInIGluIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlYWRQaXhlbHNGQk8ob3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZFBpeGVsc1xufVxuXG5mdW5jdGlvbiBzbGljZSAoeCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoeClcbn1cblxuZnVuY3Rpb24gam9pbiAoeCkge1xuICByZXR1cm4gc2xpY2UoeCkuam9pbignJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnQgKCkge1xuICAvLyBVbmlxdWUgdmFyaWFibGUgaWQgY291bnRlclxuICB2YXIgdmFyQ291bnRlciA9IDBcblxuICAvLyBMaW5rZWQgdmFsdWVzIGFyZSBwYXNzZWQgZnJvbSB0aGlzIHNjb3BlIGludG8gdGhlIGdlbmVyYXRlZCBjb2RlIGJsb2NrXG4gIC8vIENhbGxpbmcgbGluaygpIHBhc3NlcyBhIHZhbHVlIGludG8gdGhlIGdlbmVyYXRlZCBzY29wZSBhbmQgcmV0dXJuc1xuICAvLyB0aGUgdmFyaWFibGUgbmFtZSB3aGljaCBpdCBpcyBib3VuZCB0b1xuICB2YXIgbGlua2VkTmFtZXMgPSBbXVxuICB2YXIgbGlua2VkVmFsdWVzID0gW11cbiAgZnVuY3Rpb24gbGluayAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtlZFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGxpbmtlZFZhbHVlc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtlZE5hbWVzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSAnZycgKyAodmFyQ291bnRlcisrKVxuICAgIGxpbmtlZE5hbWVzLnB1c2gobmFtZSlcbiAgICBsaW5rZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgY29kZSBibG9ja1xuICBmdW5jdGlvbiBibG9jayAoKSB7XG4gICAgdmFyIGNvZGUgPSBbXVxuICAgIGZ1bmN0aW9uIHB1c2ggKCkge1xuICAgICAgY29kZS5wdXNoLmFwcGx5KGNvZGUsIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfVxuXG4gICAgdmFyIHZhcnMgPSBbXVxuICAgIGZ1bmN0aW9uIGRlZiAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICd2JyArICh2YXJDb3VudGVyKyspXG4gICAgICB2YXJzLnB1c2gobmFtZSlcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChuYW1lLCAnPScpXG4gICAgICAgIGNvZGUucHVzaC5hcHBseShjb2RlLCBzbGljZShhcmd1bWVudHMpKVxuICAgICAgICBjb2RlLnB1c2goJzsnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQocHVzaCwge1xuICAgICAgZGVmOiBkZWYsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gam9pbihbXG4gICAgICAgICAgKHZhcnMubGVuZ3RoID4gMCA/ICd2YXIgJyArIHZhcnMuam9pbignLCcpICsgJzsnIDogJycpLFxuICAgICAgICAgIGpvaW4oY29kZSlcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gc2NvcGUgKCkge1xuICAgIHZhciBlbnRyeSA9IGJsb2NrKClcbiAgICB2YXIgZXhpdCA9IGJsb2NrKClcblxuICAgIHZhciBlbnRyeVRvU3RyaW5nID0gZW50cnkudG9TdHJpbmdcbiAgICB2YXIgZXhpdFRvU3RyaW5nID0gZXhpdC50b1N0cmluZ1xuXG4gICAgZnVuY3Rpb24gc2F2ZSAob2JqZWN0LCBwcm9wKSB7XG4gICAgICBleGl0KG9iamVjdCwgcHJvcCwgJz0nLCBlbnRyeS5kZWYob2JqZWN0LCBwcm9wKSwgJzsnKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgZW50cnkuYXBwbHkoZW50cnksIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfSwge1xuICAgICAgZGVmOiBlbnRyeS5kZWYsXG4gICAgICBlbnRyeTogZW50cnksXG4gICAgICBleGl0OiBleGl0LFxuICAgICAgc2F2ZTogc2F2ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgc2F2ZShvYmplY3QsIHByb3ApXG4gICAgICAgIGVudHJ5KG9iamVjdCwgcHJvcCwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbnRyeVRvU3RyaW5nKCkgKyBleGl0VG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25kaXRpb25hbCAoKSB7XG4gICAgdmFyIHByZWQgPSBqb2luKGFyZ3VtZW50cylcbiAgICB2YXIgdGhlbkJsb2NrID0gc2NvcGUoKVxuICAgIHZhciBlbHNlQmxvY2sgPSBzY29wZSgpXG5cbiAgICB2YXIgdGhlblRvU3RyaW5nID0gdGhlbkJsb2NrLnRvU3RyaW5nXG4gICAgdmFyIGVsc2VUb1N0cmluZyA9IGVsc2VCbG9jay50b1N0cmluZ1xuXG4gICAgcmV0dXJuIGV4dGVuZCh0aGVuQmxvY2ssIHtcbiAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhlbkJsb2NrLmFwcGx5KHRoZW5CbG9jaywgc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBlbHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsc2VCbG9jay5hcHBseShlbHNlQmxvY2ssIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsc2VDbGF1c2UgPSBlbHNlVG9TdHJpbmcoKVxuICAgICAgICBpZiAoZWxzZUNsYXVzZSkge1xuICAgICAgICAgIGVsc2VDbGF1c2UgPSAnZWxzZXsnICsgZWxzZUNsYXVzZSArICd9J1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnaWYoJywgcHJlZCwgJyl7JyxcbiAgICAgICAgICB0aGVuVG9TdHJpbmcoKSxcbiAgICAgICAgICAnfScsIGVsc2VDbGF1c2VcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gcHJvY2VkdXJlIGxpc3RcbiAgdmFyIGdsb2JhbEJsb2NrID0gYmxvY2soKVxuICB2YXIgcHJvY2VkdXJlcyA9IHt9XG4gIGZ1bmN0aW9uIHByb2MgKG5hbWUsIGNvdW50KSB7XG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZ1bmN0aW9uIGFyZyAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICdhJyArIGFyZ3MubGVuZ3RoXG4gICAgICBhcmdzLnB1c2gobmFtZSlcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuXG4gICAgY291bnQgPSBjb3VudCB8fCAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBhcmcoKVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gc2NvcGUoKVxuICAgIHZhciBib2R5VG9TdHJpbmcgPSBib2R5LnRvU3RyaW5nXG5cbiAgICB2YXIgcmVzdWx0ID0gcHJvY2VkdXJlc1tuYW1lXSA9IGV4dGVuZChib2R5LCB7XG4gICAgICBhcmc6IGFyZyxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnZnVuY3Rpb24oJywgYXJncy5qb2luKCksICcpeycsXG4gICAgICAgICAgYm9keVRvU3RyaW5nKCksXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKCkge1xuICAgIHZhciBjb2RlID0gWydcInVzZSBzdHJpY3RcIjsnLFxuICAgICAgZ2xvYmFsQmxvY2ssXG4gICAgICAncmV0dXJuIHsnXVxuICAgIE9iamVjdC5rZXlzKHByb2NlZHVyZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvZGUucHVzaCgnXCInLCBuYW1lLCAnXCI6JywgcHJvY2VkdXJlc1tuYW1lXS50b1N0cmluZygpLCAnLCcpXG4gICAgfSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICAgIHZhciBzcmMgPSBqb2luKGNvZGUpXG4gICAgICAucmVwbGFjZSgvOy9nLCAnO1xcbicpXG4gICAgICAucmVwbGFjZSgvfS9nLCAnfVxcbicpXG4gICAgICAucmVwbGFjZSgvey9nLCAne1xcbicpXG4gICAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseShudWxsLCBsaW5rZWROYW1lcy5jb25jYXQoc3JjKSlcbiAgICByZXR1cm4gcHJvYy5hcHBseShudWxsLCBsaW5rZWRWYWx1ZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsb2JhbDogZ2xvYmFsQmxvY2ssXG4gICAgbGluazogbGluayxcbiAgICBibG9jazogYmxvY2ssXG4gICAgcHJvYzogcHJvYyxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgY29uZDogY29uZGl0aW9uYWwsXG4gICAgY29tcGlsZTogY29tcGlsZVxuICB9XG59XG5cbi8vIFwiY3V0ZVwiIG5hbWVzIGZvciB2ZWN0b3IgY29tcG9uZW50c1xudmFyIENVVEVfQ09NUE9ORU5UUyA9ICd4eXp3Jy5zcGxpdCgnJylcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUkOCA9IDUxMjFcblxudmFyIEFUVFJJQl9TVEFURV9QT0lOVEVSID0gMVxudmFyIEFUVFJJQl9TVEFURV9DT05TVEFOVCA9IDJcblxudmFyIERZTl9GVU5DJDEgPSAwXG52YXIgRFlOX1BST1AkMSA9IDFcbnZhciBEWU5fQ09OVEVYVCQxID0gMlxudmFyIERZTl9TVEFURSQxID0gM1xudmFyIERZTl9USFVOSyA9IDRcbnZhciBEWU5fQ09OU1RBTlQkMSA9IDVcbnZhciBEWU5fQVJSQVkkMSA9IDZcblxudmFyIFNfRElUSEVSID0gJ2RpdGhlcidcbnZhciBTX0JMRU5EX0VOQUJMRSA9ICdibGVuZC5lbmFibGUnXG52YXIgU19CTEVORF9DT0xPUiA9ICdibGVuZC5jb2xvcidcbnZhciBTX0JMRU5EX0VRVUFUSU9OID0gJ2JsZW5kLmVxdWF0aW9uJ1xudmFyIFNfQkxFTkRfRlVOQyA9ICdibGVuZC5mdW5jJ1xudmFyIFNfREVQVEhfRU5BQkxFID0gJ2RlcHRoLmVuYWJsZSdcbnZhciBTX0RFUFRIX0ZVTkMgPSAnZGVwdGguZnVuYydcbnZhciBTX0RFUFRIX1JBTkdFID0gJ2RlcHRoLnJhbmdlJ1xudmFyIFNfREVQVEhfTUFTSyA9ICdkZXB0aC5tYXNrJ1xudmFyIFNfQ09MT1JfTUFTSyA9ICdjb2xvck1hc2snXG52YXIgU19DVUxMX0VOQUJMRSA9ICdjdWxsLmVuYWJsZSdcbnZhciBTX0NVTExfRkFDRSA9ICdjdWxsLmZhY2UnXG52YXIgU19GUk9OVF9GQUNFID0gJ2Zyb250RmFjZSdcbnZhciBTX0xJTkVfV0lEVEggPSAnbGluZVdpZHRoJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfRU5BQkxFID0gJ3BvbHlnb25PZmZzZXQuZW5hYmxlJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfT0ZGU0VUID0gJ3BvbHlnb25PZmZzZXQub2Zmc2V0J1xudmFyIFNfU0FNUExFX0FMUEhBID0gJ3NhbXBsZS5hbHBoYSdcbnZhciBTX1NBTVBMRV9FTkFCTEUgPSAnc2FtcGxlLmVuYWJsZSdcbnZhciBTX1NBTVBMRV9DT1ZFUkFHRSA9ICdzYW1wbGUuY292ZXJhZ2UnXG52YXIgU19TVEVOQ0lMX0VOQUJMRSA9ICdzdGVuY2lsLmVuYWJsZSdcbnZhciBTX1NURU5DSUxfTUFTSyA9ICdzdGVuY2lsLm1hc2snXG52YXIgU19TVEVOQ0lMX0ZVTkMgPSAnc3RlbmNpbC5mdW5jJ1xudmFyIFNfU1RFTkNJTF9PUEZST05UID0gJ3N0ZW5jaWwub3BGcm9udCdcbnZhciBTX1NURU5DSUxfT1BCQUNLID0gJ3N0ZW5jaWwub3BCYWNrJ1xudmFyIFNfU0NJU1NPUl9FTkFCTEUgPSAnc2Npc3Nvci5lbmFibGUnXG52YXIgU19TQ0lTU09SX0JPWCA9ICdzY2lzc29yLmJveCdcbnZhciBTX1ZJRVdQT1JUID0gJ3ZpZXdwb3J0J1xuXG52YXIgU19QUk9GSUxFID0gJ3Byb2ZpbGUnXG5cbnZhciBTX0ZSQU1FQlVGRkVSID0gJ2ZyYW1lYnVmZmVyJ1xudmFyIFNfVkVSVCA9ICd2ZXJ0J1xudmFyIFNfRlJBRyA9ICdmcmFnJ1xudmFyIFNfRUxFTUVOVFMgPSAnZWxlbWVudHMnXG52YXIgU19QUklNSVRJVkUgPSAncHJpbWl0aXZlJ1xudmFyIFNfQ09VTlQgPSAnY291bnQnXG52YXIgU19PRkZTRVQgPSAnb2Zmc2V0J1xudmFyIFNfSU5TVEFOQ0VTID0gJ2luc3RhbmNlcydcbnZhciBTX1ZBTyA9ICd2YW8nXG5cbnZhciBTVUZGSVhfV0lEVEggPSAnV2lkdGgnXG52YXIgU1VGRklYX0hFSUdIVCA9ICdIZWlnaHQnXG5cbnZhciBTX0ZSQU1FQlVGRkVSX1dJRFRIID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9XSURUSFxudmFyIFNfRlJBTUVCVUZGRVJfSEVJR0hUID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9IRUlHSFRcbnZhciBTX1ZJRVdQT1JUX1dJRFRIID0gU19WSUVXUE9SVCArIFNVRkZJWF9XSURUSFxudmFyIFNfVklFV1BPUlRfSEVJR0hUID0gU19WSUVXUE9SVCArIFNVRkZJWF9IRUlHSFRcbnZhciBTX0RSQVdJTkdCVUZGRVIgPSAnZHJhd2luZ0J1ZmZlcidcbnZhciBTX0RSQVdJTkdCVUZGRVJfV0lEVEggPSBTX0RSQVdJTkdCVUZGRVIgKyBTVUZGSVhfV0lEVEhcbnZhciBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUID0gU19EUkFXSU5HQlVGRkVSICsgU1VGRklYX0hFSUdIVFxuXG52YXIgTkVTVEVEX09QVElPTlMgPSBbXG4gIFNfQkxFTkRfRlVOQyxcbiAgU19CTEVORF9FUVVBVElPTixcbiAgU19TVEVOQ0lMX0ZVTkMsXG4gIFNfU1RFTkNJTF9PUEZST05ULFxuICBTX1NURU5DSUxfT1BCQUNLLFxuICBTX1NBTVBMRV9DT1ZFUkFHRSxcbiAgU19WSUVXUE9SVCxcbiAgU19TQ0lTU09SX0JPWCxcbiAgU19QT0xZR09OX09GRlNFVF9PRkZTRVRcbl1cblxudmFyIEdMX0FSUkFZX0JVRkZFUiQyID0gMzQ5NjJcbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjNcblxudmFyIEdMX0ZSQUdNRU5UX1NIQURFUiQxID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSJDEgPSAzNTYzM1xuXG52YXIgR0xfVEVYVFVSRV8yRCQzID0gMHgwREUxXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUCQyID0gMHg4NTEzXG5cbnZhciBHTF9DVUxMX0ZBQ0UgPSAweDBCNDRcbnZhciBHTF9CTEVORCA9IDB4MEJFMlxudmFyIEdMX0RJVEhFUiA9IDB4MEJEMFxudmFyIEdMX1NURU5DSUxfVEVTVCA9IDB4MEI5MFxudmFyIEdMX0RFUFRIX1RFU1QgPSAweDBCNzFcbnZhciBHTF9TQ0lTU09SX1RFU1QgPSAweDBDMTFcbnZhciBHTF9QT0xZR09OX09GRlNFVF9GSUxMID0gMHg4MDM3XG52YXIgR0xfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFID0gMHg4MDlFXG52YXIgR0xfU0FNUExFX0NPVkVSQUdFID0gMHg4MEEwXG5cbnZhciBHTF9GTE9BVCQ4ID0gNTEyNlxudmFyIEdMX0ZMT0FUX1ZFQzIgPSAzNTY2NFxudmFyIEdMX0ZMT0FUX1ZFQzMgPSAzNTY2NVxudmFyIEdMX0ZMT0FUX1ZFQzQgPSAzNTY2NlxudmFyIEdMX0lOVCQzID0gNTEyNFxudmFyIEdMX0lOVF9WRUMyID0gMzU2NjdcbnZhciBHTF9JTlRfVkVDMyA9IDM1NjY4XG52YXIgR0xfSU5UX1ZFQzQgPSAzNTY2OVxudmFyIEdMX0JPT0wgPSAzNTY3MFxudmFyIEdMX0JPT0xfVkVDMiA9IDM1NjcxXG52YXIgR0xfQk9PTF9WRUMzID0gMzU2NzJcbnZhciBHTF9CT09MX1ZFQzQgPSAzNTY3M1xudmFyIEdMX0ZMT0FUX01BVDIgPSAzNTY3NFxudmFyIEdMX0ZMT0FUX01BVDMgPSAzNTY3NVxudmFyIEdMX0ZMT0FUX01BVDQgPSAzNTY3NlxudmFyIEdMX1NBTVBMRVJfMkQgPSAzNTY3OFxudmFyIEdMX1NBTVBMRVJfQ1VCRSA9IDM1NjgwXG5cbnZhciBHTF9UUklBTkdMRVMkMSA9IDRcblxudmFyIEdMX0ZST05UID0gMTAyOFxudmFyIEdMX0JBQ0sgPSAxMDI5XG52YXIgR0xfQ1cgPSAweDA5MDBcbnZhciBHTF9DQ1cgPSAweDA5MDFcbnZhciBHTF9NSU5fRVhUID0gMHg4MDA3XG52YXIgR0xfTUFYX0VYVCA9IDB4ODAwOFxudmFyIEdMX0FMV0FZUyA9IDUxOVxudmFyIEdMX0tFRVAgPSA3NjgwXG52YXIgR0xfWkVSTyA9IDBcbnZhciBHTF9PTkUgPSAxXG52YXIgR0xfRlVOQ19BREQgPSAweDgwMDZcbnZhciBHTF9MRVNTID0gNTEzXG5cbnZhciBHTF9GUkFNRUJVRkZFUiQyID0gMHg4RDQwXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMiA9IDB4OENFMFxuXG52YXIgYmxlbmRGdW5jcyA9IHtcbiAgJzAnOiAwLFxuICAnMSc6IDEsXG4gICd6ZXJvJzogMCxcbiAgJ29uZSc6IDEsXG4gICdzcmMgY29sb3InOiA3NjgsXG4gICdvbmUgbWludXMgc3JjIGNvbG9yJzogNzY5LFxuICAnc3JjIGFscGhhJzogNzcwLFxuICAnb25lIG1pbnVzIHNyYyBhbHBoYSc6IDc3MSxcbiAgJ2RzdCBjb2xvcic6IDc3NCxcbiAgJ29uZSBtaW51cyBkc3QgY29sb3InOiA3NzUsXG4gICdkc3QgYWxwaGEnOiA3NzIsXG4gICdvbmUgbWludXMgZHN0IGFscGhhJzogNzczLFxuICAnY29uc3RhbnQgY29sb3InOiAzMjc2OSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvcic6IDMyNzcwLFxuICAnY29uc3RhbnQgYWxwaGEnOiAzMjc3MSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSc6IDMyNzcyLFxuICAnc3JjIGFscGhhIHNhdHVyYXRlJzogNzc2XG59XG5cbi8vIFRoZXJlIGFyZSBpbnZhbGlkIHZhbHVlcyBmb3Igc3JjUkdCIGFuZCBkc3RSR0IuIFNlZTpcbi8vIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jNi4xM1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9XZWJHTC9ibG9iLzBkMzIwMWY1ZjdlYzNjMDA2MGJjMWYwNDA3NzQ2MTU0MWYxOTg3YjkvY29uZm9ybWFuY2Utc3VpdGVzLzEuMC4zL2NvbmZvcm1hbmNlL21pc2Mvd2ViZ2wtc3BlY2lmaWMuaHRtbCNMNTZcbnZhciBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBbXG4gICdjb25zdGFudCBjb2xvciwgY29uc3RhbnQgYWxwaGEnLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yLCBjb25zdGFudCBhbHBoYScsXG4gICdjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ2NvbnN0YW50IGFscGhhLCBjb25zdGFudCBjb2xvcicsXG4gICdjb25zdGFudCBhbHBoYSwgb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSwgY29uc3RhbnQgY29sb3InLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhLCBvbmUgbWludXMgY29uc3RhbnQgY29sb3InXG5dXG5cbnZhciBjb21wYXJlRnVuY3MgPSB7XG4gICduZXZlcic6IDUxMixcbiAgJ2xlc3MnOiA1MTMsXG4gICc8JzogNTEzLFxuICAnZXF1YWwnOiA1MTQsXG4gICc9JzogNTE0LFxuICAnPT0nOiA1MTQsXG4gICc9PT0nOiA1MTQsXG4gICdsZXF1YWwnOiA1MTUsXG4gICc8PSc6IDUxNSxcbiAgJ2dyZWF0ZXInOiA1MTYsXG4gICc+JzogNTE2LFxuICAnbm90ZXF1YWwnOiA1MTcsXG4gICchPSc6IDUxNyxcbiAgJyE9PSc6IDUxNyxcbiAgJ2dlcXVhbCc6IDUxOCxcbiAgJz49JzogNTE4LFxuICAnYWx3YXlzJzogNTE5XG59XG5cbnZhciBzdGVuY2lsT3BzID0ge1xuICAnMCc6IDAsXG4gICd6ZXJvJzogMCxcbiAgJ2tlZXAnOiA3NjgwLFxuICAncmVwbGFjZSc6IDc2ODEsXG4gICdpbmNyZW1lbnQnOiA3NjgyLFxuICAnZGVjcmVtZW50JzogNzY4MyxcbiAgJ2luY3JlbWVudCB3cmFwJzogMzQwNTUsXG4gICdkZWNyZW1lbnQgd3JhcCc6IDM0MDU2LFxuICAnaW52ZXJ0JzogNTM4NlxufVxuXG52YXIgc2hhZGVyVHlwZSA9IHtcbiAgJ2ZyYWcnOiBHTF9GUkFHTUVOVF9TSEFERVIkMSxcbiAgJ3ZlcnQnOiBHTF9WRVJURVhfU0hBREVSJDFcbn1cblxudmFyIG9yaWVudGF0aW9uVHlwZSA9IHtcbiAgJ2N3JzogR0xfQ1csXG4gICdjY3cnOiBHTF9DQ1dcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXJBcmdzICh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpIHx8XG4gICAgaXNUeXBlZEFycmF5KHgpIHx8XG4gICAgaXNOREFycmF5TGlrZSh4KVxufVxuXG4vLyBNYWtlIHN1cmUgdmlld3BvcnQgaXMgcHJvY2Vzc2VkIGZpcnN0XG5mdW5jdGlvbiBzb3J0U3RhdGUgKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IFNfVklFV1BPUlQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gU19WSUVXUE9SVCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIChhIDwgYikgPyAtMSA6IDFcbiAgfSlcbn1cblxuZnVuY3Rpb24gRGVjbGFyYXRpb24gKHRoaXNEZXAsIGNvbnRleHREZXAsIHByb3BEZXAsIGFwcGVuZCkge1xuICB0aGlzLnRoaXNEZXAgPSB0aGlzRGVwXG4gIHRoaXMuY29udGV4dERlcCA9IGNvbnRleHREZXBcbiAgdGhpcy5wcm9wRGVwID0gcHJvcERlcFxuICB0aGlzLmFwcGVuZCA9IGFwcGVuZFxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAoZGVjbCkge1xuICByZXR1cm4gZGVjbCAmJiAhKGRlY2wudGhpc0RlcCB8fCBkZWNsLmNvbnRleHREZXAgfHwgZGVjbC5wcm9wRGVwKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNEZWNsIChhcHBlbmQpIHtcbiAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihmYWxzZSwgZmFsc2UsIGZhbHNlLCBhcHBlbmQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNEZWNsIChkeW4sIGFwcGVuZCkge1xuICB2YXIgdHlwZSA9IGR5bi50eXBlXG4gIGlmICh0eXBlID09PSBEWU5fRlVOQyQxKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBkeW4uZGF0YS5sZW5ndGhcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgdHJ1ZSxcbiAgICAgIG51bUFyZ3MgPj0gMSxcbiAgICAgIG51bUFyZ3MgPj0gMixcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fVEhVTkspIHtcbiAgICB2YXIgZGF0YSA9IGR5bi5kYXRhXG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIGRhdGEudGhpc0RlcCxcbiAgICAgIGRhdGEuY29udGV4dERlcCxcbiAgICAgIGRhdGEucHJvcERlcCxcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fQ09OU1RBTlQkMSkge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRFlOX0FSUkFZJDEpIHtcbiAgICB2YXIgdGhpc0RlcCA9IGZhbHNlXG4gICAgdmFyIGNvbnRleHREZXAgPSBmYWxzZVxuICAgIHZhciBwcm9wRGVwID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5bi5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViRHluID0gZHluLmRhdGFbaV1cbiAgICAgIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1BST1AkMSkge1xuICAgICAgICBwcm9wRGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX0NPTlRFWFQkMSkge1xuICAgICAgICBjb250ZXh0RGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1NUQVRFJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoc3ViRHluLnR5cGUgPT09IERZTl9GVU5DJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgICAgdmFyIHN1YkFyZ3MgPSBzdWJEeW4uZGF0YVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAxKSB7XG4gICAgICAgICAgY29udGV4dERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAyKSB7XG4gICAgICAgICAgcHJvcERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1RIVU5LKSB7XG4gICAgICAgIHRoaXNEZXAgPSB0aGlzRGVwIHx8IHN1YkR5bi5kYXRhLnRoaXNEZXBcbiAgICAgICAgY29udGV4dERlcCA9IGNvbnRleHREZXAgfHwgc3ViRHluLmRhdGEuY29udGV4dERlcFxuICAgICAgICBwcm9wRGVwID0gcHJvcERlcCB8fCBzdWJEeW4uZGF0YS5wcm9wRGVwXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICB0aGlzRGVwLFxuICAgICAgY29udGV4dERlcCxcbiAgICAgIHByb3BEZXAsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIHR5cGUgPT09IERZTl9TVEFURSQxLFxuICAgICAgdHlwZSA9PT0gRFlOX0NPTlRFWFQkMSxcbiAgICAgIHR5cGUgPT09IERZTl9QUk9QJDEsXG4gICAgICBhcHBlbmQpXG4gIH1cbn1cblxudmFyIFNDT1BFX0RFQ0wgPSBuZXcgRGVjbGFyYXRpb24oZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24gKCkge30pXG5cbmZ1bmN0aW9uIHJlZ2xDb3JlIChcbiAgZ2wsXG4gIHN0cmluZ1N0b3JlLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMsXG4gIGJ1ZmZlclN0YXRlLFxuICBlbGVtZW50U3RhdGUsXG4gIHRleHR1cmVTdGF0ZSxcbiAgZnJhbWVidWZmZXJTdGF0ZSxcbiAgdW5pZm9ybVN0YXRlLFxuICBhdHRyaWJ1dGVTdGF0ZSxcbiAgc2hhZGVyU3RhdGUsXG4gIGRyYXdTdGF0ZSxcbiAgY29udGV4dFN0YXRlLFxuICB0aW1lcixcbiAgY29uZmlnKSB7XG4gIHZhciBBdHRyaWJ1dGVSZWNvcmQgPSBhdHRyaWJ1dGVTdGF0ZS5SZWNvcmRcblxuICB2YXIgYmxlbmRFcXVhdGlvbnMgPSB7XG4gICAgJ2FkZCc6IDMyNzc0LFxuICAgICdzdWJ0cmFjdCc6IDMyNzc4LFxuICAgICdyZXZlcnNlIHN1YnRyYWN0JzogMzI3NzlcbiAgfVxuICBpZiAoZXh0ZW5zaW9ucy5leHRfYmxlbmRfbWlubWF4KSB7XG4gICAgYmxlbmRFcXVhdGlvbnMubWluID0gR0xfTUlOX0VYVFxuICAgIGJsZW5kRXF1YXRpb25zLm1heCA9IEdMX01BWF9FWFRcbiAgfVxuXG4gIHZhciBleHRJbnN0YW5jaW5nID0gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gIHZhciBleHREcmF3QnVmZmVycyA9IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBXRUJHTCBTVEFURVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBjdXJyZW50U3RhdGUgPSB7XG4gICAgZGlydHk6IHRydWUsXG4gICAgcHJvZmlsZTogY29uZmlnLnByb2ZpbGVcbiAgfVxuICB2YXIgbmV4dFN0YXRlID0ge31cbiAgdmFyIEdMX1NUQVRFX05BTUVTID0gW11cbiAgdmFyIEdMX0ZMQUdTID0ge31cbiAgdmFyIEdMX1ZBUklBQkxFUyA9IHt9XG5cbiAgZnVuY3Rpb24gcHJvcE5hbWUgKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCcuJywgJ18nKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVGbGFnIChzbmFtZSwgY2FwLCBpbml0KSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZShzbmFtZSlcbiAgICBHTF9TVEFURV9OQU1FUy5wdXNoKHNuYW1lKVxuICAgIG5leHRTdGF0ZVtuYW1lXSA9IGN1cnJlbnRTdGF0ZVtuYW1lXSA9ICEhaW5pdFxuICAgIEdMX0ZMQUdTW25hbWVdID0gY2FwXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZVZhcmlhYmxlIChzbmFtZSwgZnVuYywgaW5pdCkge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWUoc25hbWUpXG4gICAgR0xfU1RBVEVfTkFNRVMucHVzaChzbmFtZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gaW5pdC5zbGljZSgpXG4gICAgICBuZXh0U3RhdGVbbmFtZV0gPSBpbml0LnNsaWNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gbmV4dFN0YXRlW25hbWVdID0gaW5pdFxuICAgIH1cbiAgICBHTF9WQVJJQUJMRVNbbmFtZV0gPSBmdW5jXG4gIH1cblxuICAvLyBEaXRoZXJpbmdcbiAgc3RhdGVGbGFnKFNfRElUSEVSLCBHTF9ESVRIRVIpXG5cbiAgLy8gQmxlbmRpbmdcbiAgc3RhdGVGbGFnKFNfQkxFTkRfRU5BQkxFLCBHTF9CTEVORClcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0NPTE9SLCAnYmxlbmRDb2xvcicsIFswLCAwLCAwLCAwXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0VRVUFUSU9OLCAnYmxlbmRFcXVhdGlvblNlcGFyYXRlJyxcbiAgICBbR0xfRlVOQ19BREQsIEdMX0ZVTkNfQUREXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0ZVTkMsICdibGVuZEZ1bmNTZXBhcmF0ZScsXG4gICAgW0dMX09ORSwgR0xfWkVSTywgR0xfT05FLCBHTF9aRVJPXSlcblxuICAvLyBEZXB0aFxuICBzdGF0ZUZsYWcoU19ERVBUSF9FTkFCTEUsIEdMX0RFUFRIX1RFU1QsIHRydWUpXG4gIHN0YXRlVmFyaWFibGUoU19ERVBUSF9GVU5DLCAnZGVwdGhGdW5jJywgR0xfTEVTUylcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX1JBTkdFLCAnZGVwdGhSYW5nZScsIFswLCAxXSlcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX01BU0ssICdkZXB0aE1hc2snLCB0cnVlKVxuXG4gIC8vIENvbG9yIG1hc2tcbiAgc3RhdGVWYXJpYWJsZShTX0NPTE9SX01BU0ssIFNfQ09MT1JfTUFTSywgW3RydWUsIHRydWUsIHRydWUsIHRydWVdKVxuXG4gIC8vIEZhY2UgY3VsbGluZ1xuICBzdGF0ZUZsYWcoU19DVUxMX0VOQUJMRSwgR0xfQ1VMTF9GQUNFKVxuICBzdGF0ZVZhcmlhYmxlKFNfQ1VMTF9GQUNFLCAnY3VsbEZhY2UnLCBHTF9CQUNLKVxuXG4gIC8vIEZyb250IGZhY2Ugb3JpZW50YXRpb25cbiAgc3RhdGVWYXJpYWJsZShTX0ZST05UX0ZBQ0UsIFNfRlJPTlRfRkFDRSwgR0xfQ0NXKVxuXG4gIC8vIExpbmUgd2lkdGhcbiAgc3RhdGVWYXJpYWJsZShTX0xJTkVfV0lEVEgsIFNfTElORV9XSURUSCwgMSlcblxuICAvLyBQb2x5Z29uIG9mZnNldFxuICBzdGF0ZUZsYWcoU19QT0xZR09OX09GRlNFVF9FTkFCTEUsIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwpXG4gIHN0YXRlVmFyaWFibGUoU19QT0xZR09OX09GRlNFVF9PRkZTRVQsICdwb2x5Z29uT2Zmc2V0JywgWzAsIDBdKVxuXG4gIC8vIFNhbXBsZSBjb3ZlcmFnZVxuICBzdGF0ZUZsYWcoU19TQU1QTEVfQUxQSEEsIEdMX1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSlcbiAgc3RhdGVGbGFnKFNfU0FNUExFX0VOQUJMRSwgR0xfU0FNUExFX0NPVkVSQUdFKVxuICBzdGF0ZVZhcmlhYmxlKFNfU0FNUExFX0NPVkVSQUdFLCAnc2FtcGxlQ292ZXJhZ2UnLCBbMSwgZmFsc2VdKVxuXG4gIC8vIFN0ZW5jaWxcbiAgc3RhdGVGbGFnKFNfU1RFTkNJTF9FTkFCTEUsIEdMX1NURU5DSUxfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfTUFTSywgJ3N0ZW5jaWxNYXNrJywgLTEpXG4gIHN0YXRlVmFyaWFibGUoU19TVEVOQ0lMX0ZVTkMsICdzdGVuY2lsRnVuYycsIFtHTF9BTFdBWVMsIDAsIC0xXSlcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfT1BGUk9OVCwgJ3N0ZW5jaWxPcFNlcGFyYXRlJyxcbiAgICBbR0xfRlJPTlQsIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9PUEJBQ0ssICdzdGVuY2lsT3BTZXBhcmF0ZScsXG4gICAgW0dMX0JBQ0ssIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuXG4gIC8vIFNjaXNzb3JcbiAgc3RhdGVGbGFnKFNfU0NJU1NPUl9FTkFCTEUsIEdMX1NDSVNTT1JfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NDSVNTT1JfQk9YLCAnc2Npc3NvcicsXG4gICAgWzAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodF0pXG5cbiAgLy8gVmlld3BvcnRcbiAgc3RhdGVWYXJpYWJsZShTX1ZJRVdQT1JULCBTX1ZJRVdQT1JULFxuICAgIFswLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHRdKVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRU5WSVJPTk1FTlRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgc2hhcmVkU3RhdGUgPSB7XG4gICAgZ2w6IGdsLFxuICAgIGNvbnRleHQ6IGNvbnRleHRTdGF0ZSxcbiAgICBzdHJpbmdzOiBzdHJpbmdTdG9yZSxcbiAgICBuZXh0OiBuZXh0U3RhdGUsXG4gICAgY3VycmVudDogY3VycmVudFN0YXRlLFxuICAgIGRyYXc6IGRyYXdTdGF0ZSxcbiAgICBlbGVtZW50czogZWxlbWVudFN0YXRlLFxuICAgIGJ1ZmZlcjogYnVmZmVyU3RhdGUsXG4gICAgc2hhZGVyOiBzaGFkZXJTdGF0ZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVTdGF0ZS5zdGF0ZSxcbiAgICB2YW86IGF0dHJpYnV0ZVN0YXRlLFxuICAgIHVuaWZvcm1zOiB1bmlmb3JtU3RhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcblxuICAgIHRpbWVyOiB0aW1lcixcbiAgICBpc0J1ZmZlckFyZ3M6IGlzQnVmZmVyQXJnc1xuICB9XG5cbiAgdmFyIHNoYXJlZENvbnN0YW50cyA9IHtcbiAgICBwcmltVHlwZXM6IHByaW1UeXBlcyxcbiAgICBjb21wYXJlRnVuY3M6IGNvbXBhcmVGdW5jcyxcbiAgICBibGVuZEZ1bmNzOiBibGVuZEZ1bmNzLFxuICAgIGJsZW5kRXF1YXRpb25zOiBibGVuZEVxdWF0aW9ucyxcbiAgICBzdGVuY2lsT3BzOiBzdGVuY2lsT3BzLFxuICAgIGdsVHlwZXM6IGdsVHlwZXMsXG4gICAgb3JpZW50YXRpb25UeXBlOiBvcmllbnRhdGlvblR5cGVcbiAgfVxuXG4gIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZFN0YXRlLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VcbiAgfSlcblxuICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICBzaGFyZWRDb25zdGFudHMuYmFja0J1ZmZlciA9IFtHTF9CQUNLXVxuICAgIHNoYXJlZENvbnN0YW50cy5kcmF3QnVmZmVyID0gbG9vcChsaW1pdHMubWF4RHJhd2J1ZmZlcnMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdXG4gICAgICB9XG4gICAgICByZXR1cm4gbG9vcChpLCBmdW5jdGlvbiAoaikge1xuICAgICAgICByZXR1cm4gR0xfQ09MT1JfQVRUQUNITUVOVDAkMiArIGpcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBkcmF3Q2FsbENvdW50ZXIgPSAwXG4gIGZ1bmN0aW9uIGNyZWF0ZVJFR0xFbnZpcm9ubWVudCAoKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KClcbiAgICB2YXIgbGluayA9IGVudi5saW5rXG4gICAgdmFyIGdsb2JhbCA9IGVudi5nbG9iYWxcbiAgICBlbnYuaWQgPSBkcmF3Q2FsbENvdW50ZXIrK1xuXG4gICAgZW52LmJhdGNoSWQgPSAnMCdcblxuICAgIC8vIGxpbmsgc2hhcmVkIHN0YXRlXG4gICAgdmFyIFNIQVJFRCA9IGxpbmsoc2hhcmVkU3RhdGUpXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQgPSB7XG4gICAgICBwcm9wczogJ2EwJ1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgc2hhcmVkW3Byb3BdID0gZ2xvYmFsLmRlZihTSEFSRUQsICcuJywgcHJvcClcbiAgICB9KVxuXG4gICAgLy8gSW5qZWN0IHJ1bnRpbWUgYXNzZXJ0aW9uIHN0dWZmIGZvciBkZWJ1ZyBidWlsZHNcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5DSEVDSyA9IGxpbmsoY2hlY2skMSlcbiAgICAgIGVudi5jb21tYW5kU3RyID0gY2hlY2skMS5ndWVzc0NvbW1hbmQoKVxuICAgICAgZW52LmNvbW1hbmQgPSBsaW5rKGVudi5jb21tYW5kU3RyKVxuICAgICAgZW52LmFzc2VydCA9IGZ1bmN0aW9uIChibG9jaywgcHJlZCwgbWVzc2FnZSkge1xuICAgICAgICBibG9jayhcbiAgICAgICAgICAnaWYoISgnLCBwcmVkLCAnKSknLFxuICAgICAgICAgIHRoaXMuQ0hFQ0ssICcuY29tbWFuZFJhaXNlKCcsIGxpbmsobWVzc2FnZSksICcsJywgdGhpcy5jb21tYW5kLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBzaGFyZWRDb25zdGFudHMuaW52YWxpZEJsZW5kQ29tYmluYXRpb25zID0gaW52YWxpZEJsZW5kQ29tYmluYXRpb25zXG4gICAgfSlcblxuICAgIC8vIENvcHkgR0wgc3RhdGUgdmFyaWFibGVzIG92ZXJcbiAgICB2YXIgbmV4dFZhcnMgPSBlbnYubmV4dCA9IHt9XG4gICAgdmFyIGN1cnJlbnRWYXJzID0gZW52LmN1cnJlbnQgPSB7fVxuICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTdGF0ZVt2YXJpYWJsZV0pKSB7XG4gICAgICAgIG5leHRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLm5leHQsICcuJywgdmFyaWFibGUpXG4gICAgICAgIGN1cnJlbnRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLmN1cnJlbnQsICcuJywgdmFyaWFibGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEluaXRpYWxpemUgc2hhcmVkIGNvbnN0YW50c1xuICAgIHZhciBjb25zdGFudHMgPSBlbnYuY29uc3RhbnRzID0ge31cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRDb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnN0YW50c1tuYW1lXSA9IGdsb2JhbC5kZWYoSlNPTi5zdHJpbmdpZnkoc2hhcmVkQ29uc3RhbnRzW25hbWVdKSlcbiAgICB9KVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBjYWxsaW5nIGEgYmxvY2tcbiAgICBlbnYuaW52b2tlID0gZnVuY3Rpb24gKGJsb2NrLCB4KSB7XG4gICAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICAgICBjYXNlIERZTl9GVU5DJDE6XG4gICAgICAgICAgdmFyIGFyZ0xpc3QgPSBbXG4gICAgICAgICAgICAndGhpcycsXG4gICAgICAgICAgICBzaGFyZWQuY29udGV4dCxcbiAgICAgICAgICAgIHNoYXJlZC5wcm9wcyxcbiAgICAgICAgICAgIGVudi5iYXRjaElkXG4gICAgICAgICAgXVxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoXG4gICAgICAgICAgICBsaW5rKHguZGF0YSksICcuY2FsbCgnLFxuICAgICAgICAgICAgYXJnTGlzdC5zbGljZSgwLCBNYXRoLm1heCh4LmRhdGEubGVuZ3RoICsgMSwgNCkpLFxuICAgICAgICAgICAgJyknKVxuICAgICAgICBjYXNlIERZTl9QUk9QJDE6XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihzaGFyZWQucHJvcHMsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fQ09OVEVYVCQxOlxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoc2hhcmVkLmNvbnRleHQsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fU1RBVEUkMTpcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKCd0aGlzJywgeC5kYXRhKVxuICAgICAgICBjYXNlIERZTl9USFVOSzpcbiAgICAgICAgICB4LmRhdGEuYXBwZW5kKGVudiwgYmxvY2spXG4gICAgICAgICAgcmV0dXJuIHguZGF0YS5yZWZcbiAgICAgICAgY2FzZSBEWU5fQ09OU1RBTlQkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY2FzZSBEWU5fQVJSQVkkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5pbnZva2UoYmxvY2ssIHkpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnYuYXR0cmliQ2FjaGUgPSB7fVxuXG4gICAgdmFyIHNjb3BlQXR0cmlicyA9IHt9XG4gICAgZW52LnNjb3BlQXR0cmliID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpZCA9IHN0cmluZ1N0b3JlLmlkKG5hbWUpXG4gICAgICBpZiAoaWQgaW4gc2NvcGVBdHRyaWJzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUF0dHJpYnNbaWRdXG4gICAgICB9XG4gICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZVN0YXRlLnNjb3BlW2lkXVxuICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcgPSBhdHRyaWJ1dGVTdGF0ZS5zY29wZVtpZF0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzY29wZUF0dHJpYnNbaWRdID0gbGluayhiaW5kaW5nKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHJldHVybiBlbnZcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUEFSU0lOR1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIHBhcnNlUHJvZmlsZSAob3B0aW9ucykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBwcm9maWxlRW5hYmxlXG4gICAgaWYgKFNfUFJPRklMRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWUgPSAhIXN0YXRpY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9KVxuICAgICAgcHJvZmlsZUVuYWJsZS5lbmFibGUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoU19QUk9GSUxFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2ZpbGVFbmFibGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnJhbWVidWZmZXIgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGlmIChTX0ZSQU1FQlVGRkVSIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IHN0YXRpY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICBmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyU3RhdGUuZ2V0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFtZWJ1ZmZlciwgJ2ludmFsaWQgZnJhbWVidWZmZXIgb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgYmxvY2spIHtcbiAgICAgICAgICB2YXIgRlJBTUVCVUZGRVIgPSBlbnYubGluayhmcmFtZWJ1ZmZlcilcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUilcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0XG4gICAgICAgICAgYmxvY2suc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfV0lEVEgsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUiArICcud2lkdGgnKVxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICAgIEZSQU1FQlVGRkVSICsgJy5oZWlnaHQnKVxuICAgICAgICAgIHJldHVybiBGUkFNRUJVRkZFUlxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICAnbnVsbCcpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX1dJRFRILFxuICAgICAgICAgICAgQ09OVEVYVCArICcuJyArIFNfRFJBV0lOR0JVRkZFUl9XSURUSClcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9IRUlHSFQsXG4gICAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTX0ZSQU1FQlVGRkVSIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHZhciBGUkFNRUJVRkZFUl9GVU5DID0gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICB2YXIgRlJBTUVCVUZGRVJfU1RBVEUgPSBzaGFyZWQuZnJhbWVidWZmZXJcbiAgICAgICAgdmFyIEZSQU1FQlVGRkVSID0gc2NvcGUuZGVmKFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLCAnLmdldEZyYW1lYnVmZmVyKCcsIEZSQU1FQlVGRkVSX0ZVTkMsICcpJylcblxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgJyEnICsgRlJBTUVCVUZGRVJfRlVOQyArICd8fCcgKyBGUkFNRUJVRkZFUixcbiAgICAgICAgICAgICdpbnZhbGlkIGZyYW1lYnVmZmVyIG9iamVjdCcpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLFxuICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgRlJBTUVCVUZGRVIpXG4gICAgICAgIHZhciBDT05URVhUID0gc2hhcmVkLmNvbnRleHRcbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArICc/JyArIEZSQU1FQlVGRkVSICsgJy53aWR0aDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX1dJRFRIKVxuICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArXG4gICAgICAgICAgJz8nICsgRlJBTUVCVUZGRVIgKyAnLmhlaWdodDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgcmV0dXJuIEZSQU1FQlVGRkVSXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVmlld3BvcnRTY2lzc29yIChvcHRpb25zLCBmcmFtZWJ1ZmZlciwgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCb3ggKHBhcmFtKSB7XG4gICAgICBpZiAocGFyYW0gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgYm94ID0gc3RhdGljT3B0aW9uc1twYXJhbV1cbiAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShib3gsICdvYmplY3QnLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgIHZhciBpc1N0YXRpYyA9IHRydWVcbiAgICAgICAgdmFyIHggPSBib3gueCB8IDBcbiAgICAgICAgdmFyIHkgPSBib3gueSB8IDBcbiAgICAgICAgdmFyIHcsIGhcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gYm94KSB7XG4gICAgICAgICAgdyA9IGJveC53aWR0aCB8IDBcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodyA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzU3RhdGljID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2hlaWdodCcgaW4gYm94KSB7XG4gICAgICAgICAgaCA9IGJveC5oZWlnaHQgfCAwXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGggPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5jb250ZXh0RGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5wcm9wRGVwLFxuICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgICAgdmFyIEJPWF9XID0gd1xuICAgICAgICAgICAgaWYgKCEoJ3dpZHRoJyBpbiBib3gpKSB7XG4gICAgICAgICAgICAgIEJPWF9XID0gc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCB4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEJPWF9IID0gaFxuICAgICAgICAgICAgaWYgKCEoJ2hlaWdodCcgaW4gYm94KSkge1xuICAgICAgICAgICAgICBCT1hfSCA9IHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hULCAnLScsIHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIEJPWF9XLCBCT1hfSF1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluQm94ID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVEeW5hbWljRGVjbChkeW5Cb3gsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIEJPWCA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bkJveClcblxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgQk9YICsgJyYmdHlwZW9mICcgKyBCT1ggKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwYXJhbSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICB2YXIgQk9YX1ggPSBzY29wZS5kZWYoQk9YLCAnLnh8MCcpXG4gICAgICAgICAgdmFyIEJPWF9ZID0gc2NvcGUuZGVmKEJPWCwgJy55fDAnKVxuICAgICAgICAgIHZhciBCT1hfVyA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcIndpZHRoXCIgaW4gJywgQk9YLCAnPycsIEJPWCwgJy53aWR0aHwwOicsXG4gICAgICAgICAgICAnKCcsIENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCBCT1hfWCwgJyknKVxuICAgICAgICAgIHZhciBCT1hfSCA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcImhlaWdodFwiIGluICcsIEJPWCwgJz8nLCBCT1gsICcuaGVpZ2h0fDA6JyxcbiAgICAgICAgICAgICcoJywgQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCwgJy0nLCBCT1hfWSwgJyknKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBCT1hfVyArICc+PTAmJicgK1xuICAgICAgICAgICAgICBCT1hfSCArICc+PTAnLFxuICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBbQk9YX1gsIEJPWF9ZLCBCT1hfVywgQk9YX0hdXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC50aGlzRGVwID0gcmVzdWx0LnRoaXNEZXAgfHwgZnJhbWVidWZmZXIudGhpc0RlcFxuICAgICAgICAgIHJlc3VsdC5jb250ZXh0RGVwID0gcmVzdWx0LmNvbnRleHREZXAgfHwgZnJhbWVidWZmZXIuY29udGV4dERlcFxuICAgICAgICAgIHJlc3VsdC5wcm9wRGVwID0gcmVzdWx0LnByb3BEZXAgfHwgZnJhbWVidWZmZXIucHJvcERlcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgIGZyYW1lYnVmZmVyLmNvbnRleHREZXAsXG4gICAgICAgICAgZnJhbWVidWZmZXIucHJvcERlcCxcbiAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgIHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfV0lEVEgpLFxuICAgICAgICAgICAgICBzY29wZS5kZWYoQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCldXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0ID0gcGFyc2VCb3goU19WSUVXUE9SVClcblxuICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgdmFyIHByZXZWaWV3cG9ydCA9IHZpZXdwb3J0XG4gICAgICB2aWV3cG9ydCA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgdmlld3BvcnQudGhpc0RlcCxcbiAgICAgICAgdmlld3BvcnQuY29udGV4dERlcCxcbiAgICAgICAgdmlld3BvcnQucHJvcERlcCxcbiAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgVklFV1BPUlQgPSBwcmV2Vmlld3BvcnQuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19WSUVXUE9SVF9XSURUSCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzJdKVxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX1ZJRVdQT1JUX0hFSUdIVCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzNdKVxuICAgICAgICAgIHJldHVybiBWSUVXUE9SVFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBzY2lzc29yX2JveDogcGFyc2VCb3goU19TQ0lTU09SX0JPWClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYkxvY2F0aW9ucyAob3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgc3RhdGljUHJvZ3JhbSA9XG4gICAgICB0eXBlb2Ygc3RhdGljT3B0aW9uc1tTX0ZSQUddID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIHN0YXRpY09wdGlvbnNbU19WRVJUXSA9PT0gJ3N0cmluZydcbiAgICBpZiAoc3RhdGljUHJvZ3JhbSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuZHluYW1pYykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnN0YXRpY1xuICAgICAgdmFyIHNBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoc3RhdGljQXR0cmlidXRlcylcbiAgICAgIGlmIChzQXR0cmlidXRlcy5sZW5ndGggPiAwICYmIHR5cGVvZiBzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzWzBdXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNoZWNrJDEodHlwZW9mIHN0YXRpY0F0dHJpYnV0ZXNbc0F0dHJpYnV0ZXNbaV1dID09PSAnbnVtYmVyJywgJ211c3Qgc3BlY2lmeSBhbGwgdmVydGV4IGF0dHJpYnV0ZSBsb2NhdGlvbnMgd2hlbiB1c2luZyB2YW9zJylcbiAgICAgICAgICBiaW5kaW5ncy5wdXNoKFtzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzW2ldXSB8IDAsIHNBdHRyaWJ1dGVzW2ldXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSAob3B0aW9ucywgZW52LCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNoYWRlciAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChzdGF0aWNPcHRpb25zW25hbWVdKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzaGFkZXJTdGF0ZS5zaGFkZXIoc2hhZGVyVHlwZVtuYW1lXSwgaWQsIGNoZWNrJDEuZ3Vlc3NDb21tYW5kKCkpXG4gICAgICAgIH0pXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaWRcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0LmlkID0gaWRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tuYW1lXVxuICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBzdHIgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGlkID0gc2NvcGUuZGVmKGVudi5zaGFyZWQuc3RyaW5ncywgJy5pZCgnLCBzdHIsICcpJylcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgICBlbnYuc2hhcmVkLnNoYWRlciwgJy5zaGFkZXIoJyxcbiAgICAgICAgICAgICAgc2hhZGVyVHlwZVtuYW1lXSwgJywnLFxuICAgICAgICAgICAgICBpZCwgJywnLFxuICAgICAgICAgICAgICBlbnYuY29tbWFuZCwgJyk7JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IHBhcnNlU2hhZGVyKFNfRlJBRylcbiAgICB2YXIgdmVydCA9IHBhcnNlU2hhZGVyKFNfVkVSVClcblxuICAgIHZhciBwcm9ncmFtID0gbnVsbFxuICAgIHZhciBwcm9nVmFyXG4gICAgaWYgKGlzU3RhdGljKGZyYWcpICYmIGlzU3RhdGljKHZlcnQpKSB7XG4gICAgICBwcm9ncmFtID0gc2hhZGVyU3RhdGUucHJvZ3JhbSh2ZXJ0LmlkLCBmcmFnLmlkLCBudWxsLCBhdHRyaWJMb2NhdGlvbnMpXG4gICAgICBwcm9nVmFyID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52LmxpbmsocHJvZ3JhbSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dWYXIgPSBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgIChmcmFnICYmIGZyYWcudGhpc0RlcCkgfHwgKHZlcnQgJiYgdmVydC50aGlzRGVwKSxcbiAgICAgICAgKGZyYWcgJiYgZnJhZy5jb250ZXh0RGVwKSB8fCAodmVydCAmJiB2ZXJ0LmNvbnRleHREZXApLFxuICAgICAgICAoZnJhZyAmJiBmcmFnLnByb3BEZXApIHx8ICh2ZXJ0ICYmIHZlcnQucHJvcERlcCksXG4gICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIFNIQURFUl9TVEFURSA9IGVudi5zaGFyZWQuc2hhZGVyXG4gICAgICAgICAgdmFyIGZyYWdJZFxuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBmcmFnLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfRlJBRylcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZlcnRJZFxuICAgICAgICAgIGlmICh2ZXJ0KSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSB2ZXJ0LmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfVkVSVClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByb2dEZWYgPSBTSEFERVJfU1RBVEUgKyAnLnByb2dyYW0oJyArIHZlcnRJZCArICcsJyArIGZyYWdJZFxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvZ0RlZiArPSAnLCcgKyBlbnYuY29tbWFuZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihwcm9nRGVmICsgJyknKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgdmVydDogdmVydCxcbiAgICAgIHByb2dWYXI6IHByb2dWYXIsXG4gICAgICBwcm9ncmFtOiBwcm9ncmFtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEcmF3IChvcHRpb25zLCBlbnYpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzICgpIHtcbiAgICAgIGlmIChTX0VMRU1FTlRTIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gc3RhdGljT3B0aW9uc1tTX0VMRU1FTlRTXVxuICAgICAgICBpZiAoaXNCdWZmZXJBcmdzKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudFN0YXRlLmdldEVsZW1lbnRzKGVsZW1lbnRTdGF0ZS5jcmVhdGUoZWxlbWVudHMsIHRydWUpKVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50U3RhdGUuZ2V0RWxlbWVudHMoZWxlbWVudHMpXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGVsZW1lbnRzLCAnaW52YWxpZCBlbGVtZW50cycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmxpbmsoZWxlbWVudHMpXG4gICAgICAgICAgICBlbnYuRUxFTUVOVFMgPSByZXN1bHRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgZW52LkVMRU1FTlRTID0gbnVsbFxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGVsZW1lbnRzXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoU19FTEVNRU5UUyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19FTEVNRU5UU11cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgICAgICAgdmFyIElTX0JVRkZFUl9BUkdTID0gc2hhcmVkLmlzQnVmZmVyQXJnc1xuICAgICAgICAgIHZhciBFTEVNRU5UX1NUQVRFID0gc2hhcmVkLmVsZW1lbnRzXG5cbiAgICAgICAgICB2YXIgZWxlbWVudERlZm4gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2NvcGUuZGVmKCdudWxsJylcbiAgICAgICAgICB2YXIgZWxlbWVudFN0cmVhbSA9IHNjb3BlLmRlZihJU19CVUZGRVJfQVJHUywgJygnLCBlbGVtZW50RGVmbiwgJyknKVxuXG4gICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChlbGVtZW50U3RyZWFtKVxuICAgICAgICAgICAgLnRoZW4oZWxlbWVudHMsICc9JywgRUxFTUVOVF9TVEFURSwgJy5jcmVhdGVTdHJlYW0oJywgZWxlbWVudERlZm4sICcpOycpXG4gICAgICAgICAgICAuZWxzZShlbGVtZW50cywgJz0nLCBFTEVNRU5UX1NUQVRFLCAnLmdldEVsZW1lbnRzKCcsIGVsZW1lbnREZWZuLCAnKTsnKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KGlmdGUuZWxzZSxcbiAgICAgICAgICAgICAgJyEnICsgZWxlbWVudERlZm4gKyAnfHwnICsgZWxlbWVudHMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnRzJylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc2NvcGUuZW50cnkoaWZ0ZSlcbiAgICAgICAgICBzY29wZS5leGl0KFxuICAgICAgICAgICAgZW52LmNvbmQoZWxlbWVudFN0cmVhbSlcbiAgICAgICAgICAgICAgLnRoZW4oRUxFTUVOVF9TVEFURSwgJy5kZXN0cm95U3RyZWFtKCcsIGVsZW1lbnRzLCAnKTsnKSlcblxuICAgICAgICAgIGVudi5FTEVNRU5UUyA9IGVsZW1lbnRzXG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBwYXJzZUVsZW1lbnRzKClcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlICgpIHtcbiAgICAgIGlmIChTX1BSSU1JVElWRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBwcmltaXRpdmUgPSBzdGF0aWNPcHRpb25zW1NfUFJJTUlUSVZFXVxuICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIocHJpbWl0aXZlLCBwcmltVHlwZXMsICdpbnZhbGlkIHByaW1pdHZlJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW1UeXBlc1twcmltaXRpdmVdXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKFNfUFJJTUlUSVZFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5QcmltaXRpdmUgPSBkeW5hbWljT3B0aW9uc1tTX1BSSU1JVElWRV1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5blByaW1pdGl2ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgUFJJTV9UWVBFUyA9IGVudi5jb25zdGFudHMucHJpbVR5cGVzXG4gICAgICAgICAgdmFyIHByaW0gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5QcmltaXRpdmUpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBwcmltICsgJyBpbiAnICsgUFJJTV9UWVBFUyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbWl0aXZlLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMocHJpbVR5cGVzKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoUFJJTV9UWVBFUywgJ1snLCBwcmltLCAnXScpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0YXRpYyhlbGVtZW50cykpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudHMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnByaW1UeXBlJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEdMX1RSSUFOR0xFUyQxXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgZWxlbWVudHMudGhpc0RlcCxcbiAgICAgICAgICAgIGVsZW1lbnRzLmNvbnRleHREZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5wcm9wRGVwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZW52LkVMRU1FTlRTXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcucHJpbVR5cGU6JywgR0xfVFJJQU5HTEVTJDEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW0gKHBhcmFtLCBpc09mZnNldCkge1xuICAgICAgaWYgKHBhcmFtIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGljT3B0aW9uc1twYXJhbV0gfCAwXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZCghaXNPZmZzZXQgfHwgdmFsdWUgPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGVudi5PRkZTRVQgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5blZhbHVlID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5WYWx1ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluVmFsdWUpXG4gICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICBlbnYuT0ZGU0VUID0gcmVzdWx0XG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICByZXN1bHQgKyAnPj0wJyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzT2Zmc2V0ICYmIGVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgZW52Lk9GRlNFVCA9ICcwJ1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBPRkZTRVQgPSBwYXJzZVBhcmFtKFNfT0ZGU0VULCB0cnVlKVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWZXJ0Q291bnQgKCkge1xuICAgICAgaWYgKFNfQ09VTlQgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgY291bnQgPSBzdGF0aWNPcHRpb25zW1NfQ09VTlRdIHwgMFxuICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgdHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyAmJiBjb3VudCA+PSAwLCAnaW52YWxpZCB2ZXJ0ZXggY291bnQnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb3VudFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChTX0NPVU5UIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5Db3VudCA9IGR5bmFtaWNPcHRpb25zW1NfQ09VTlRdXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5Db3VudCwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluQ291bnQpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAndHlwZW9mICcgKyByZXN1bHQgKyAnPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgIHJlc3VsdCArICc+PTAmJicgK1xuICAgICAgICAgICAgICByZXN1bHQgKyAnPT09KCcgKyByZXN1bHQgKyAnfDApJyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKE9GRlNFVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgIE9GRlNFVC50aGlzRGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5wcm9wRGVwLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgICBlbnYuRUxFTUVOVFMsICcudmVydENvdW50LScsIGVudi5PRkZTRVQpXG5cbiAgICAgICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArICc+PTAnLFxuICAgICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIHZlcnRleCBvZmZzZXQvZWxlbWVudCBidWZmZXIgdG9vIHNtYWxsJylcbiAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVudi5FTEVNRU5UUywgJy52ZXJ0Q291bnQnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXN1bHQuTUlTU0lORyA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICAgIGVsZW1lbnRzLnRoaXNEZXAgfHwgT0ZGU0VULnRoaXNEZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5jb250ZXh0RGVwIHx8IE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgZWxlbWVudHMucHJvcERlcCB8fCBPRkZTRVQucHJvcERlcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGVudi5FTEVNRU5UU1xuICAgICAgICAgICAgICBpZiAoZW52Lk9GRlNFVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcudmVydENvdW50LScsXG4gICAgICAgICAgICAgICAgICBlbnYuT0ZGU0VULCAnOi0xJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVsZW1lbnRzLCAnPycsIGVsZW1lbnRzLCAnLnZlcnRDb3VudDotMScpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyaWFibGUuRFlOQU1JQyA9IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiB2YXJpYWJsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBwcmltaXRpdmU6IHBhcnNlUHJpbWl0aXZlKCksXG4gICAgICBjb3VudDogcGFyc2VWZXJ0Q291bnQoKSxcbiAgICAgIGluc3RhbmNlczogcGFyc2VQYXJhbShTX0lOU1RBTkNFUywgZmFsc2UpLFxuICAgICAgb2Zmc2V0OiBPRkZTRVRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdMU3RhdGUgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBTVEFURSA9IHt9XG5cbiAgICBHTF9TVEFURV9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YXIgcGFyYW0gPSBwcm9wTmFtZShwcm9wKVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZVBhcmFtIChwYXJzZVN0YXRpYywgcGFyc2VEeW5hbWljKSB7XG4gICAgICAgIGlmIChwcm9wIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVN0YXRpYyhzdGF0aWNPcHRpb25zW3Byb3BdKVxuICAgICAgICAgIFNUQVRFW3BhcmFtXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW3Byb3BdXG4gICAgICAgICAgU1RBVEVbcGFyYW1dID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHluYW1pYyhlbnYsIHNjb3BlLCBlbnYuaW52b2tlKHNjb3BlLCBkeW4pKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU19DVUxMX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0JMRU5EX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0RJVEhFUjpcbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfU0NJU1NPUl9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19QT0xZR09OX09GRlNFVF9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfQUxQSEE6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfTUFTSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnYm9vbGVhbicsIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwiYm9vbGVhblwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGZsYWcgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0RFUFRIX0ZVTkM6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBjb21wYXJlRnVuY3MsICdpbnZhbGlkICcgKyBwcm9wLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVGdW5jc1t2YWx1ZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnIGluICcgKyBDT01QQVJFX0ZVTkNTLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoY29tcGFyZUZ1bmNzKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnXScpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19ERVBUSF9SQU5HRTpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVswXSA8PSB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAnZGVwdGggcmFuZ2UgaXMgMmQgYXJyYXknLFxuICAgICAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT0yJiYnICtcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJ1swXT09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnWzFdPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICdbMF08PScgKyB2YWx1ZSArICdbMV0nLFxuICAgICAgICAgICAgICAgICAgJ2RlcHRoIHJhbmdlIG11c3QgYmUgYSAyZCBhcnJheScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIFpfTkVBUiA9IHNjb3BlLmRlZignKycsIHZhbHVlLCAnWzBdJylcbiAgICAgICAgICAgICAgdmFyIFpfRkFSID0gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbMV0nKVxuICAgICAgICAgICAgICByZXR1cm4gW1pfTkVBUiwgWl9GQVJdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9GVU5DOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCAnYmxlbmQuZnVuYycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgc3JjUkdCID0gKCdzcmNSR0InIGluIHZhbHVlID8gdmFsdWUuc3JjUkdCIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgc3JjQWxwaGEgPSAoJ3NyY0FscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLnNyY0FscGhhIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gKCdkc3RSR0InIGluIHZhbHVlID8gdmFsdWUuZHN0UkdCIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICB2YXIgZHN0QWxwaGEgPSAoJ2RzdEFscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLmRzdEFscGhhIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoc3JjUkdCLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuc3JjUkdCJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihzcmNBbHBoYSwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLnNyY0FscGhhJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihkc3RSR0IsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5kc3RSR0InLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGRzdEFscGhhLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuZHN0QWxwaGEnLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgKGludmFsaWRCbGVuZENvbWJpbmF0aW9ucy5pbmRleE9mKHNyY1JHQiArICcsICcgKyBkc3RSR0IpID09PSAtMSksXG4gICAgICAgICAgICAgICAgJ3VuYWxsb3dlZCBibGVuZGluZyBjb21iaW5hdGlvbiAoc3JjUkdCLCBkc3RSR0IpID0gKCcgKyBzcmNSR0IgKyAnLCAnICsgZHN0UkdCICsgJyknLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJsZW5kRnVuY3Nbc3JjUkdCXSxcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW2RzdFJHQl0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNBbHBoYV0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tkc3RBbHBoYV1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgQkxFTkRfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmJsZW5kRnVuY3NcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgYmxlbmQgZnVuYywgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgICAnXCInLCBwcmVmaXgsIHN1ZmZpeCwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCB2YWx1ZSwgJy4nLCBwcmVmaXgsIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICc6JywgdmFsdWUsICcuJywgcHJlZml4KVxuXG4gICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jICsgJyBpbiAnICsgQkxFTkRfRlVOQ1MsXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wICsgJy4nICsgcHJlZml4ICsgc3VmZml4ICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGJsZW5kRnVuY3MpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNyY1JHQiA9IHJlYWQoJ3NyYycsICdSR0InKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gcmVhZCgnZHN0JywgJ1JHQicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIElOVkFMSURfQkxFTkRfQ09NQklOQVRJT05TID0gZW52LmNvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnNcblxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX0JMRU5EX0NPTUJJTkFUSU9OUyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnLmluZGV4T2YoJyArIHNyY1JHQiArICcrXCIsIFwiKycgKyBkc3RSR0IgKyAnKSA9PT0gLTEgJyxcbiAgICAgICAgICAgICAgICAgICd1bmFsbG93ZWQgYmxlbmRpbmcgY29tYmluYXRpb24gZm9yIChzcmNSR0IsIGRzdFJHQiknXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHZhciBTUkNfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHNyY1JHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgU1JDX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ3NyYycsICdBbHBoYScpLCAnXScpXG4gICAgICAgICAgICAgIHZhciBEU1RfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIGRzdFJHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgRFNUX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ2RzdCcsICdBbHBoYScpLCAnXScpXG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtTUkNfUkdCLCBEU1RfUkdCLCBTUkNfQUxQSEEsIERTVF9BTFBIQV1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0JMRU5EX0VRVUFUSU9OOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBibGVuZEVxdWF0aW9ucywgJ2ludmFsaWQgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnJnYiwgYmxlbmRFcXVhdGlvbnMsIHByb3AgKyAnLnJnYicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLmFscGhhLCBibGVuZEVxdWF0aW9ucywgcHJvcCArICcuYWxwaGEnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUucmdiXSxcbiAgICAgICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlLmFscGhhXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBibGVuZC5lcXVhdGlvbicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTlMgPSBlbnYuY29uc3RhbnRzLmJsZW5kRXF1YXRpb25zXG5cbiAgICAgICAgICAgICAgdmFyIFJHQiA9IHNjb3BlLmRlZigpXG4gICAgICAgICAgICAgIHZhciBBTFBIQSA9IHNjb3BlLmRlZigpXG5cbiAgICAgICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZCgndHlwZW9mICcsIHZhbHVlLCAnPT09XCJzdHJpbmdcIicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tQcm9wIChibG9jaywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyBpbiAnICsgQkxFTkRfRVFVQVRJT05TLFxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgbmFtZSArICcsIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhibGVuZEVxdWF0aW9ucykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLnRoZW4sIHByb3AsIHZhbHVlKVxuXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChpZnRlLmVsc2UsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcClcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5yZ2InLCB2YWx1ZSArICcucmdiJylcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5hbHBoYScsIHZhbHVlICsgJy5hbHBoYScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgICAgICAgIFJHQiwgJz0nLCBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICddOycpXG4gICAgICAgICAgICAgIGlmdGUuZWxzZShcbiAgICAgICAgICAgICAgICBSR0IsICc9JywgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhbHVlLCAnLnJnYl07JyxcbiAgICAgICAgICAgICAgICBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICcuYWxwaGFdOycpXG5cbiAgICAgICAgICAgICAgc2NvcGUoaWZ0ZSlcblxuICAgICAgICAgICAgICByZXR1cm4gW1JHQiwgQUxQSEFdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9DT0xPUjpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICdibGVuZC5jb2xvciBtdXN0IGJlIGEgNGQgYXJyYXknLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlW2ldXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBlbnYuc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgdmFsdWUgKyAnKSYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcubGVuZ3RoPT09NCcsXG4gICAgICAgICAgICAgICAgICAnYmxlbmQuY29sb3IgbXVzdCBiZSBhIDRkIGFycmF5JylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbJywgaSwgJ10nKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9NQVNLOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdudW1iZXInLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5tYXNrJylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZih2YWx1ZSwgJ3wwJylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRlVOQzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgY21wID0gdmFsdWUuY21wIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUucmVmIHx8IDBcbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSAnbWFzaycgaW4gdmFsdWUgPyB2YWx1ZS5tYXNrIDogLTFcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGNtcCwgY29tcGFyZUZ1bmNzLCBwcm9wICsgJy5jbXAnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShyZWYsICdudW1iZXInLCBwcm9wICsgJy5yZWYnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShtYXNrLCAnbnVtYmVyJywgcHJvcCArICcubWFzaycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbXBhcmVGdW5jc1tjbXBdLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBtYXNrXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQgKCkge1xuICAgICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5mdW5jJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlICsgJyYmdHlwZW9mICcsIHZhbHVlLCAnPT09XCJvYmplY3RcIicpXG4gICAgICAgICAgICAgICAgYXNzZXJ0KCchKFwiY21wXCIgaW4gJywgdmFsdWUsICcpfHwoJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCAnLmNtcCBpbiAnLCBDT01QQVJFX0ZVTkNTLCAnKScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHZhciBjbXAgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1wiY21wXCIgaW4gJywgdmFsdWUsXG4gICAgICAgICAgICAgICAgJz8nLCBDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnLmNtcF0nLFxuICAgICAgICAgICAgICAgICc6JywgR0xfS0VFUClcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5yZWZ8MCcpXG4gICAgICAgICAgICAgIHZhciBtYXNrID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICdcIm1hc2tcIiBpbiAnLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAnPycsIHZhbHVlLCAnLm1hc2t8MDotMScpXG4gICAgICAgICAgICAgIHJldHVybiBbY21wLCByZWYsIG1hc2tdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QRlJPTlQ6XG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QQkFDSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFpbCA9IHZhbHVlLmZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgICAgIHZhciB6ZmFpbCA9IHZhbHVlLnpmYWlsIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgenBhc3MgPSB2YWx1ZS56cGFzcyB8fCAna2VlcCdcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGZhaWwsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLmZhaWwnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHpmYWlsLCBzdGVuY2lsT3BzLCBwcm9wICsgJy56ZmFpbCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoenBhc3MsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLnpwYXNzJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsT3BzW2ZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbemZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbenBhc3NdXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIFNURU5DSUxfT1BTID0gZW52LmNvbnN0YW50cy5zdGVuY2lsT3BzXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICchKFwiJyArIG5hbWUgKyAnXCIgaW4gJyArIHZhbHVlICsgJyl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAnKCcgKyB2YWx1ZSArICcuJyArIG5hbWUgKyAnIGluICcgKyBTVEVOQ0lMX09QUyArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLicgKyBuYW1lICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKHN0ZW5jaWxPcHMpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgJ1wiJywgbmFtZSwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCBTVEVOQ0lMX09QUywgJ1snLCB2YWx1ZSwgJy4nLCBuYW1lLCAnXTonLFxuICAgICAgICAgICAgICAgICAgR0xfS0VFUClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICByZWFkKCdmYWlsJyksXG4gICAgICAgICAgICAgICAgcmVhZCgnemZhaWwnKSxcbiAgICAgICAgICAgICAgICByZWFkKCd6cGFzcycpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gdmFsdWUuZmFjdG9yIHwgMFxuICAgICAgICAgICAgICB2YXIgdW5pdHMgPSB2YWx1ZS51bml0cyB8IDBcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShmYWN0b3IsICdudW1iZXInLCBwYXJhbSArICcuZmFjdG9yJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodW5pdHMsICdudW1iZXInLCBwYXJhbSArICcudW5pdHMnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIFtmYWN0b3IsIHVuaXRzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3ApXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIEZBQ1RPUiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5mYWN0b3J8MCcpXG4gICAgICAgICAgICAgIHZhciBVTklUUyA9IHNjb3BlLmRlZih2YWx1ZSwgJy51bml0c3wwJylcblxuICAgICAgICAgICAgICByZXR1cm4gW0ZBQ1RPUiwgVU5JVFNdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19DVUxMX0ZBQ0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIGZhY2UgPSAwXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9GUk9OVFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnYmFjaycpIHtcbiAgICAgICAgICAgICAgICBmYWNlID0gR0xfQkFDS1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWZhY2UsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGZhY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiZnJvbnRcInx8JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImJhY2tcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjdWxsLmZhY2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHZhbHVlLCAnPT09XCJmcm9udFwiPycsIEdMX0ZST05ULCAnOicsIEdMX0JBQ0spXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19MSU5FX1dJRFRIOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPj0gbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBsaW1pdHMubGluZVdpZHRoRGltc1sxXSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBsaW5lIHdpZHRoLCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIGJldHdlZW4gJyArXG4gICAgICAgICAgICAgICAgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnIGFuZCAnICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMV0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPj0nICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJzw9JyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgbGluZSB3aWR0aCcpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19GUk9OVF9GQUNFOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcih2YWx1ZSwgb3JpZW50YXRpb25UeXBlLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBvcmllbnRhdGlvblR5cGVbdmFsdWVdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImN3XCJ8fCcgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJjY3dcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBmcm9udEZhY2UsIG11c3QgYmUgb25lIG9mIGN3LGNjdycpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUgKyAnPT09XCJjd1wiPycgKyBHTF9DVyArICc6JyArIEdMX0NDVylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0NPTE9SX01BU0s6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgJ2NvbG9yLm1hc2sgbXVzdCBiZSBsZW5ndGggNCBhcnJheScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhIXYgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT00JyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yLm1hc2snKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnISEnICsgdmFsdWUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TQU1QTEVfQ09WRVJBR0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlID0gJ3ZhbHVlJyBpbiB2YWx1ZSA/IHZhbHVlLnZhbHVlIDogMVxuICAgICAgICAgICAgICB2YXIgc2FtcGxlSW52ZXJ0ID0gISF2YWx1ZS5pbnZlcnRcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBzYW1wbGVWYWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBzYW1wbGVWYWx1ZSA+PSAwICYmIHNhbXBsZVZhbHVlIDw9IDEsXG4gICAgICAgICAgICAgICAgJ3NhbXBsZS5jb3ZlcmFnZS52YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZVZhbHVlLCBzYW1wbGVJbnZlcnRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBzYW1wbGUuY292ZXJhZ2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB2YXIgVkFMVUUgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1widmFsdWVcIiBpbiAnLCB2YWx1ZSwgJz8rJywgdmFsdWUsICcudmFsdWU6MScpXG4gICAgICAgICAgICAgIHZhciBJTlZFUlQgPSBzY29wZS5kZWYoJyEhJywgdmFsdWUsICcuaW52ZXJ0JylcbiAgICAgICAgICAgICAgcmV0dXJuIFtWQUxVRSwgSU5WRVJUXVxuICAgICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIFNUQVRFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVVuaWZvcm1zICh1bmlmb3JtcywgZW52KSB7XG4gICAgdmFyIHN0YXRpY1VuaWZvcm1zID0gdW5pZm9ybXMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNVbmlmb3JtcyA9IHVuaWZvcm1zLmR5bmFtaWNcblxuICAgIHZhciBVTklGT1JNUyA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhzdGF0aWNVbmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljVW5pZm9ybXNbbmFtZV1cbiAgICAgIHZhciByZXN1bHRcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcmVnbFR5cGUgPSB2YWx1ZS5fcmVnbFR5cGVcbiAgICAgICAgaWYgKHJlZ2xUeXBlID09PSAndGV4dHVyZTJkJyB8fFxuICAgICAgICAgICAgcmVnbFR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYubGluayh2YWx1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2xUeXBlID09PSAnZnJhbWVidWZmZXInIHx8XG4gICAgICAgICAgICAgICAgICAgcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKHZhbHVlLmNvbG9yLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAnbWlzc2luZyBjb2xvciBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBzZW50IHRvIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlLmNvbG9yWzBdKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgIHZhciBJVEVNID0gZW52Lmdsb2JhbC5kZWYoJ1snLFxuICAgICAgICAgICAgbG9vcCh2YWx1ZS5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWVbaV0gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlW2ldID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtpXVxuICAgICAgICAgICAgfSksICddJylcbiAgICAgICAgICByZXR1cm4gSVRFTVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgb3IgbWlzc2luZyBkYXRhIGZvciB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCInLCBlbnYuY29tbWFuZFN0cilcbiAgICAgIH1cbiAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlXG4gICAgICBVTklGT1JNU1tuYW1lXSA9IHJlc3VsdFxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljVW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNVbmlmb3Jtc1trZXldXG4gICAgICBVTklGT1JNU1trZXldID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIFVOSUZPUk1TXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMgKGF0dHJpYnV0ZXMsIGVudikge1xuICAgIHZhciBzdGF0aWNBdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmR5bmFtaWNcblxuICAgIHZhciBhdHRyaWJ1dGVEZWZzID0ge31cblxuICAgIE9iamVjdC5rZXlzKHN0YXRpY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChhdHRyaWJ1dGUpXG5cbiAgICAgIHZhciByZWNvcmQgPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIGlmIChpc0J1ZmZlckFyZ3ModmFsdWUpKSB7XG4gICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoXG4gICAgICAgICAgYnVmZmVyU3RhdGUuY3JlYXRlKHZhbHVlLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIodmFsdWUpXG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICByZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSxcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICBpZiAoJ2NvbnN0YW50JyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbnN0YW50ID0gdmFsdWUuY29uc3RhbnRcbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSAnbnVsbCdcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9DT05TVEFOVFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdGFudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmVjb3JkLnggPSBjb25zdGFudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKGNvbnN0YW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbnN0YW50Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb25zdGFudC5sZW5ndGggPD0gNCxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBjb25zdGFudCBmb3IgYXR0cmlidXRlICcgKyBhdHRyaWJ1dGUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgY29uc3RhbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZWNvcmRbY10gPSBjb25zdGFudFtpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQnVmZmVyQXJncyh2YWx1ZS5idWZmZXIpKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihcbiAgICAgICAgICAgICAgICBidWZmZXJTdGF0ZS5jcmVhdGUodmFsdWUuYnVmZmVyLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHZhbHVlLmJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWJ1ZmZlciwgJ21pc3NpbmcgYnVmZmVyIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2YWx1ZS5vZmZzZXQgfCAwXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQob2Zmc2V0ID49IDAsXG4gICAgICAgICAgICAgICdpbnZhbGlkIG9mZnNldCBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdmFsdWUuc3RyaWRlIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHN0cmlkZSA+PSAwICYmIHN0cmlkZSA8IDI1NixcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc3RyaWRlIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBtdXN0IGJlIGludGVnZXIgYmV0d2VlZW4gWzAsIDI1NV0nLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgdmFyIHNpemUgPSB2YWx1ZS5zaXplIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEoJ3NpemUnIGluIHZhbHVlKSB8fCAoc2l6ZSA+IDAgJiYgc2l6ZSA8PSA0KSxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc2l6ZSBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgbXVzdCBiZSAxLDIsMyw0JywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gISF2YWx1ZS5ub3JtYWxpemVkXG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gMFxuICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSwgZ2xUeXBlcyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHR5cGUgPSBnbFR5cGVzW3ZhbHVlLnR5cGVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gdmFsdWUuZGl2aXNvciB8IDBcbiAgICAgICAgICAgIGlmICgnZGl2aXNvcicgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPT09IDAgfHwgZXh0SW5zdGFuY2luZyxcbiAgICAgICAgICAgICAgICAnY2Fubm90IHNwZWNpZnkgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgaW5zdGFuY2luZyBub3Qgc3VwcG9ydGVkJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChkaXZpc29yID49IDAsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBlbnYuY29tbWFuZFN0clxuXG4gICAgICAgICAgICAgIHZhciBWQUxJRF9LRVlTID0gW1xuICAgICAgICAgICAgICAgICdidWZmZXInLFxuICAgICAgICAgICAgICAgICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICdkaXZpc29yJyxcbiAgICAgICAgICAgICAgICAnbm9ybWFsaXplZCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICAgICAgICdzaXplJyxcbiAgICAgICAgICAgICAgICAnc3RyaWRlJ1xuICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBWQUxJRF9LRVlTLmluZGV4T2YocHJvcCkgPj0gMCxcbiAgICAgICAgICAgICAgICAgICd1bmtub3duIHBhcmFtZXRlciBcIicgKyBwcm9wICsgJ1wiIGZvciBhdHRyaWJ1dGUgcG9pbnRlciBcIicgKyBhdHRyaWJ1dGUgKyAnXCIgKHZhbGlkIHBhcmFtZXRlcnMgYXJlICcgKyBWQUxJRF9LRVlTICsgJyknLFxuICAgICAgICAgICAgICAgICAgY29tbWFuZClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgICAgICByZWNvcmQuc2l6ZSA9IHNpemVcbiAgICAgICAgICAgIHJlY29yZC5ub3JtYWxpemVkID0gbm9ybWFsaXplZFxuICAgICAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5kdHlwZVxuICAgICAgICAgICAgcmVjb3JkLm9mZnNldCA9IG9mZnNldFxuICAgICAgICAgICAgcmVjb3JkLnN0cmlkZSA9IHN0cmlkZVxuICAgICAgICAgICAgcmVjb3JkLmRpdmlzb3IgPSBkaXZpc29yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZURlZnNbYXR0cmlidXRlXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gZW52LmF0dHJpYkNhY2hlXG4gICAgICAgIGlmIChpZCBpbiBjYWNoZSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZVtpZF1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzU3RyZWFtOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHJlY29yZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSByZWNvcmRba2V5XVxuICAgICAgICB9KVxuICAgICAgICBpZiAocmVjb3JkLmJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC5idWZmZXIgPSBlbnYubGluayhyZWNvcmQuYnVmZmVyKVxuICAgICAgICAgIHJlc3VsdC50eXBlID0gcmVzdWx0LnR5cGUgfHwgKHJlc3VsdC5idWZmZXIgKyAnLmR0eXBlJylcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtpZF0gPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNBdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kQXR0cmlidXRlQ29kZSAoZW52LCBibG9jaykge1xuICAgICAgICB2YXIgVkFMVUUgPSBlbnYuaW52b2tlKGJsb2NrLCBkeW4pXG5cbiAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICAgICAgdmFyIGNvbnN0YW50cyA9IGVudi5jb25zdGFudHNcblxuICAgICAgICB2YXIgSVNfQlVGRkVSX0FSR1MgPSBzaGFyZWQuaXNCdWZmZXJBcmdzXG4gICAgICAgIHZhciBCVUZGRVJfU1RBVEUgPSBzaGFyZWQuYnVmZmVyXG5cbiAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uIG9uIGF0dHJpYnV0ZVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KGJsb2NrLFxuICAgICAgICAgICAgVkFMVUUgKyAnJiYodHlwZW9mICcgKyBWQUxVRSArICc9PT1cIm9iamVjdFwifHx0eXBlb2YgJyArXG4gICAgICAgICAgICBWQUxVRSArICc9PT1cImZ1bmN0aW9uXCIpJiYoJyArXG4gICAgICAgICAgICBJU19CVUZGRVJfQVJHUyArICcoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJy5idWZmZXIpfHwnICtcbiAgICAgICAgICAgIElTX0JVRkZFUl9BUkdTICsgJygnICsgVkFMVUUgKyAnLmJ1ZmZlcil8fCcgK1xuICAgICAgICAgICAgJyhcImNvbnN0YW50XCIgaW4gJyArIFZBTFVFICtcbiAgICAgICAgICAgICcmJih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudD09PVwibnVtYmVyXCJ8fCcgK1xuICAgICAgICAgICAgc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgVkFMVUUgKyAnLmNvbnN0YW50KSkpKScsXG4gICAgICAgICAgICAnaW52YWxpZCBkeW5hbWljIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGFsbG9jYXRlIG5hbWVzIGZvciByZXN1bHRcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBpc1N0cmVhbTogYmxvY2suZGVmKGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0UmVjb3JkID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpXG4gICAgICAgIGRlZmF1bHRSZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0UmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGJsb2NrLmRlZignJyArIGRlZmF1bHRSZWNvcmRba2V5XSlcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgQlVGRkVSID0gcmVzdWx0LmJ1ZmZlclxuICAgICAgICB2YXIgVFlQRSA9IHJlc3VsdC50eXBlXG4gICAgICAgIGJsb2NrKFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJykpeycsXG4gICAgICAgICAgcmVzdWx0LmlzU3RyZWFtLCAnPXRydWU7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmNyZWF0ZVN0cmVhbSgnLCBHTF9BUlJBWV9CVUZGRVIkMiwgJywnLCBWQUxVRSwgJyk7JyxcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxuICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuZ2V0QnVmZmVyKCcsIFZBTFVFLCAnKTsnLFxuICAgICAgICAgICdpZignLCBCVUZGRVIsICcpeycsXG4gICAgICAgICAgVFlQRSwgJz0nLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICAnfWVsc2UgaWYoXCJjb25zdGFudFwiIGluICcsIFZBTFVFLCAnKXsnLFxuICAgICAgICAgIHJlc3VsdC5zdGF0ZSwgJz0nLCBBVFRSSUJfU1RBVEVfQ09OU1RBTlQsICc7JyxcbiAgICAgICAgICAnaWYodHlwZW9mICcgKyBWQUxVRSArICcuY29uc3RhbnQgPT09IFwibnVtYmVyXCIpeycsXG4gICAgICAgICAgcmVzdWx0W0NVVEVfQ09NUE9ORU5UU1swXV0sICc9JywgVkFMVUUsICcuY29uc3RhbnQ7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0W25dXG4gICAgICAgICAgfSkuam9pbignPScpLCAnPTA7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gKyAnPScgKyBWQUxVRSArICcuY29uc3RhbnQubGVuZ3RoPicgKyBpICtcbiAgICAgICAgICAgICAgJz8nICsgVkFMVUUgKyAnLmNvbnN0YW50WycgKyBpICsgJ106MDsnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkuam9pbignJyksXG4gICAgICAgICAgJ319ZWxzZXsnLFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJy5idWZmZXIpKXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsIFZBTFVFLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmdldEJ1ZmZlcignLCBWQUxVRSwgJy5idWZmZXIpOycsXG4gICAgICAgICAgJ30nLFxuICAgICAgICAgIFRZUEUsICc9XCJ0eXBlXCIgaW4gJywgVkFMVUUsICc/JyxcbiAgICAgICAgICBjb25zdGFudHMuZ2xUeXBlcywgJ1snLCBWQUxVRSwgJy50eXBlXTonLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICByZXN1bHQubm9ybWFsaXplZCwgJz0hIScsIFZBTFVFLCAnLm5vcm1hbGl6ZWQ7JylcbiAgICAgICAgZnVuY3Rpb24gZW1pdFJlYWRSZWNvcmQgKG5hbWUpIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbbmFtZV0sICc9JywgVkFMVUUsICcuJywgbmFtZSwgJ3wwOycpXG4gICAgICAgIH1cbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3NpemUnKVxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnb2Zmc2V0JylcbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3N0cmlkZScpXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdkaXZpc29yJylcblxuICAgICAgICBibG9jaygnfX0nKVxuXG4gICAgICAgIGJsb2NrLmV4aXQoXG4gICAgICAgICAgJ2lmKCcsIHJlc3VsdC5pc1N0cmVhbSwgJyl7JyxcbiAgICAgICAgICBCVUZGRVJfU1RBVEUsICcuZGVzdHJveVN0cmVhbSgnLCBCVUZGRVIsICcpOycsXG4gICAgICAgICAgJ30nKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlRGVmc1thdHRyaWJ1dGVdID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBhcHBlbmRBdHRyaWJ1dGVDb2RlKVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXR0cmlidXRlRGVmc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWQU8gKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcbiAgICBpZiAoU19WQU8gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgdmFyIHZhbyA9IHN0YXRpY09wdGlvbnNbU19WQU9dXG4gICAgICBpZiAodmFvICE9PSBudWxsICYmIGF0dHJpYnV0ZVN0YXRlLmdldFZBTyh2YW8pID09PSBudWxsKSB7XG4gICAgICAgIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmNyZWF0ZVZBTyh2YW8pXG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIHJldHVybiBlbnYubGluayhhdHRyaWJ1dGVTdGF0ZS5nZXRWQU8odmFvKSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChTX1ZBTyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW1NfVkFPXVxuICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIHZhb1JlZiA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbnYuc2hhcmVkLnZhbyArICcuZ2V0VkFPKCcgKyB2YW9SZWYgKyAnKScpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb250ZXh0IChjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRpY0NvbnRleHQgPSBjb250ZXh0LnN0YXRpY1xuICAgIHZhciBkeW5hbWljQ29udGV4dCA9IGNvbnRleHQuZHluYW1pY1xuICAgIHZhciByZXN1bHQgPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoc3RhdGljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQ29udGV4dFtuYW1lXVxuICAgICAgcmVzdWx0W25hbWVdID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNDb250ZXh0W25hbWVdXG4gICAgICByZXN1bHRbbmFtZV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIEtFWV9OQU1FUyA9IFtcbiAgICAgICAgU19GUkFNRUJVRkZFUixcbiAgICAgICAgU19WRVJULFxuICAgICAgICBTX0ZSQUcsXG4gICAgICAgIFNfRUxFTUVOVFMsXG4gICAgICAgIFNfUFJJTUlUSVZFLFxuICAgICAgICBTX09GRlNFVCxcbiAgICAgICAgU19DT1VOVCxcbiAgICAgICAgU19JTlNUQU5DRVMsXG4gICAgICAgIFNfUFJPRklMRSxcbiAgICAgICAgU19WQU9cbiAgICAgIF0uY29uY2F0KEdMX1NUQVRFX05BTUVTKVxuXG4gICAgICBmdW5jdGlvbiBjaGVja0tleXMgKGRpY3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgS0VZX05BTUVTLmluZGV4T2Yoa2V5KSA+PSAwLFxuICAgICAgICAgICAgJ3Vua25vd24gcGFyYW1ldGVyIFwiJyArIGtleSArICdcIicsXG4gICAgICAgICAgICBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY2hlY2tLZXlzKHN0YXRpY09wdGlvbnMpXG4gICAgICBjaGVja0tleXMoZHluYW1pY09wdGlvbnMpXG4gICAgfSlcblxuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSBwYXJzZUF0dHJpYkxvY2F0aW9ucyhvcHRpb25zLCBhdHRyaWJ1dGVzKVxuXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gcGFyc2VGcmFtZWJ1ZmZlcihvcHRpb25zLCBlbnYpXG4gICAgdmFyIHZpZXdwb3J0QW5kU2Npc3NvciA9IHBhcnNlVmlld3BvcnRTY2lzc29yKG9wdGlvbnMsIGZyYW1lYnVmZmVyLCBlbnYpXG4gICAgdmFyIGRyYXcgPSBwYXJzZURyYXcob3B0aW9ucywgZW52KVxuICAgIHZhciBzdGF0ZSA9IHBhcnNlR0xTdGF0ZShvcHRpb25zLCBlbnYpXG4gICAgdmFyIHNoYWRlciA9IHBhcnNlUHJvZ3JhbShvcHRpb25zLCBlbnYsIGF0dHJpYkxvY2F0aW9ucylcblxuICAgIGZ1bmN0aW9uIGNvcHlCb3ggKG5hbWUpIHtcbiAgICAgIHZhciBkZWZuID0gdmlld3BvcnRBbmRTY2lzc29yW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBzdGF0ZVtuYW1lXSA9IGRlZm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29weUJveChTX1ZJRVdQT1JUKVxuICAgIGNvcHlCb3gocHJvcE5hbWUoU19TQ0lTU09SX0JPWCkpXG5cbiAgICB2YXIgZGlydHkgPSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoID4gMFxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZyYW1lYnVmZmVyOiBmcmFtZWJ1ZmZlcixcbiAgICAgIGRyYXc6IGRyYXcsXG4gICAgICBzaGFkZXI6IHNoYWRlcixcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgIHNjb3BlVkFPOiBudWxsLFxuICAgICAgZHJhd1ZBTzogbnVsbCxcbiAgICAgIHVzZVZBTzogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH1cblxuICAgIHJlc3VsdC5wcm9maWxlID0gcGFyc2VQcm9maWxlKG9wdGlvbnMsIGVudilcbiAgICByZXN1bHQudW5pZm9ybXMgPSBwYXJzZVVuaWZvcm1zKHVuaWZvcm1zLCBlbnYpXG4gICAgcmVzdWx0LmRyYXdWQU8gPSByZXN1bHQuc2NvcGVWQU8gPSBwYXJzZVZBTyhvcHRpb25zLCBlbnYpXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBjaGVjayBpZiB3ZSBjYW4gc3RhdGljYWxseSBhbGxvY2F0ZSBhIHZlcnRleCBhcnJheSBvYmplY3QgZm9yIHRoaXMgcHJvZ3JhbVxuICAgIGlmICghcmVzdWx0LmRyYXdWQU8gJiYgc2hhZGVyLnByb2dyYW0gJiYgIWF0dHJpYkxvY2F0aW9ucyAmJiBleHRlbnNpb25zLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMpIHtcbiAgICAgIHZhciB1c2VWQU8gPSB0cnVlXG4gICAgICB2YXIgc3RhdGljQmluZGluZ3MgPSBzaGFkZXIucHJvZ3JhbS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZXMuc3RhdGljW2F0dHJdXG4gICAgICAgIHVzZVZBTyA9IHVzZVZBTyAmJiAhIWJpbmRpbmdcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdcbiAgICAgIH0pXG4gICAgICBpZiAodXNlVkFPICYmIHN0YXRpY0JpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmdldFZBTyhhdHRyaWJ1dGVTdGF0ZS5jcmVhdGVWQU8oc3RhdGljQmluZGluZ3MpKVxuICAgICAgICByZXN1bHQuZHJhd1ZBTyA9IG5ldyBEZWNsYXJhdGlvbihudWxsLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHJldHVybiBlbnYubGluayh2YW8pXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGVudilcbiAgICB9XG4gICAgcmVzdWx0LmNvbnRleHQgPSBwYXJzZUNvbnRleHQoY29udGV4dCwgZW52KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09NTU9OIFVQREFURSBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBlbWl0Q29udGV4dCAoZW52LCBzY29wZSwgY29udGV4dCkge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuXG4gICAgdmFyIGNvbnRleHRFbnRlciA9IGVudi5zY29wZSgpXG5cbiAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzY29wZS5zYXZlKENPTlRFWFQsICcuJyArIG5hbWUpXG4gICAgICB2YXIgZGVmbiA9IGNvbnRleHRbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz1bJywgdmFsdWUuam9pbigpLCAnXTsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzY29wZShjb250ZXh0RW50ZXIpXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENPTU1PTiBEUkFXSU5HIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXRQb2xsRnJhbWVidWZmZXIgKGVudiwgc2NvcGUsIGZyYW1lYnVmZmVyLCBza2lwQ2hlY2spIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsXG4gICAgdmFyIEZSQU1FQlVGRkVSX1NUQVRFID0gc2hhcmVkLmZyYW1lYnVmZmVyXG4gICAgdmFyIEVYVF9EUkFXX0JVRkZFUlNcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIEVYVF9EUkFXX0JVRkZFUlMgPSBzY29wZS5kZWYoc2hhcmVkLmV4dGVuc2lvbnMsICcud2ViZ2xfZHJhd19idWZmZXJzJylcbiAgICB9XG5cbiAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50c1xuXG4gICAgdmFyIERSQVdfQlVGRkVSUyA9IGNvbnN0YW50cy5kcmF3QnVmZmVyXG4gICAgdmFyIEJBQ0tfQlVGRkVSID0gY29uc3RhbnRzLmJhY2tCdWZmZXJcblxuICAgIHZhciBORVhUXG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBORVhUID0gZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIE5FWFQgPSBzY29wZS5kZWYoRlJBTUVCVUZGRVJfU1RBVEUsICcubmV4dCcpXG4gICAgfVxuXG4gICAgaWYgKCFza2lwQ2hlY2spIHtcbiAgICAgIHNjb3BlKCdpZignLCBORVhULCAnIT09JywgRlJBTUVCVUZGRVJfU1RBVEUsICcuY3VyKXsnKVxuICAgIH1cbiAgICBzY29wZShcbiAgICAgICdpZignLCBORVhULCAnKXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsJywgTkVYVCwgJy5mcmFtZWJ1ZmZlcik7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLFxuICAgICAgICBEUkFXX0JVRkZFUlMsICdbJywgTkVYVCwgJy5jb2xvckF0dGFjaG1lbnRzLmxlbmd0aF0pOycpXG4gICAgfVxuICAgIHNjb3BlKCd9ZWxzZXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsbnVsbCk7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLCBCQUNLX0JVRkZFUiwgJyk7JylcbiAgICB9XG4gICAgc2NvcGUoXG4gICAgICAnfScsXG4gICAgICBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXI9JywgTkVYVCwgJzsnKVxuICAgIGlmICghc2tpcENoZWNrKSB7XG4gICAgICBzY29wZSgnfScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFBvbGxTdGF0ZSAoZW52LCBzY29wZSwgYXJncykge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG5cbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBORVhUX1ZBUlMgPSBlbnYubmV4dFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgTkVYVF9TVEFURSA9IHNoYXJlZC5uZXh0XG5cbiAgICB2YXIgYmxvY2sgPSBlbnYuY29uZChDVVJSRU5UX1NUQVRFLCAnLmRpcnR5JylcblxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbSA9IHByb3BOYW1lKHByb3ApXG4gICAgICBpZiAocGFyYW0gaW4gYXJncy5zdGF0ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIE5FWFQsIENVUlJFTlRcbiAgICAgIGlmIChwYXJhbSBpbiBORVhUX1ZBUlMpIHtcbiAgICAgICAgTkVYVCA9IE5FWFRfVkFSU1twYXJhbV1cbiAgICAgICAgQ1VSUkVOVCA9IENVUlJFTlRfVkFSU1twYXJhbV1cbiAgICAgICAgdmFyIHBhcnRzID0gbG9vcChjdXJyZW50U3RhdGVbcGFyYW1dLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKE5FWFQsICdbJywgaSwgJ10nKVxuICAgICAgICB9KVxuICAgICAgICBibG9jayhlbnYuY29uZChwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcCArICchPT0nICsgQ1VSUkVOVCArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkuam9pbignfHwnKSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgcGFydHMsICcpOycsXG4gICAgICAgICAgICBwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHBcbiAgICAgICAgICAgIH0pLmpvaW4oJzsnKSwgJzsnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE5FWFQgPSBibG9jay5kZWYoTkVYVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgYmxvY2soaWZ0ZSlcbiAgICAgICAgaWYgKHBhcmFtIGluIEdMX0ZMQUdTKSB7XG4gICAgICAgICAgaWZ0ZShcbiAgICAgICAgICAgIGVudi5jb25kKE5FWFQpXG4gICAgICAgICAgICAgIC50aGVuKEdMLCAnLmVuYWJsZSgnLCBHTF9GTEFHU1twYXJhbV0sICcpOycpXG4gICAgICAgICAgICAgIC5lbHNlKEdMLCAnLmRpc2FibGUoJywgR0xfRkxBR1NbcGFyYW1dLCAnKTsnKSxcbiAgICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgTkVYVCwgJzsnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmdGUoXG4gICAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIE5FWFQsICcpOycsXG4gICAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYmxvY2soQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT1mYWxzZTsnKVxuICAgIH1cbiAgICBzY29wZShibG9jaylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRTZXRPcHRpb25zIChlbnYsIHNjb3BlLCBvcHRpb25zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMob3B0aW9ucykpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZGVmbiA9IG9wdGlvbnNbcGFyYW1dXG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIoZGVmbikpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgdmFyaWFibGUgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEdMX0ZMQUdTW3BhcmFtXSkge1xuICAgICAgICB2YXIgZmxhZyA9IEdMX0ZMQUdTW3BhcmFtXVxuICAgICAgICBpZiAoaXNTdGF0aWMoZGVmbikpIHtcbiAgICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLmVuYWJsZSgnLCBmbGFnLCAnKTsnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKGVudi5jb25kKHZhcmlhYmxlKVxuICAgICAgICAgICAgLnRoZW4oR0wsICcuZW5hYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgICAuZWxzZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpKVxuICAgICAgICB9XG4gICAgICAgIHNjb3BlKENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgdmFyaWFibGUsICc7JylcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFyaWFibGUpKSB7XG4gICAgICAgIHZhciBDVVJSRU5UID0gQ1VSUkVOVF9WQVJTW3BhcmFtXVxuICAgICAgICBzY29wZShcbiAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIHZhcmlhYmxlLCAnKTsnLFxuICAgICAgICAgIHZhcmlhYmxlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHZcbiAgICAgICAgICB9KS5qb2luKCc7JyksICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgdmFyaWFibGUsICcpOycsXG4gICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25zIChlbnYsIHNjb3BlKSB7XG4gICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgIGVudi5pbnN0YW5jaW5nID0gc2NvcGUuZGVmKFxuICAgICAgICBlbnYuc2hhcmVkLmV4dGVuc2lvbnMsICcuYW5nbGVfaW5zdGFuY2VkX2FycmF5cycpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFByb2ZpbGUgKGVudiwgc2NvcGUsIGFyZ3MsIHVzZVNjb3BlLCBpbmNyZW1lbnRDb3VudGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICB2YXIgU1RBVFMgPSBlbnYuc3RhdHNcbiAgICB2YXIgQ1VSUkVOVF9TVEFURSA9IHNoYXJlZC5jdXJyZW50XG4gICAgdmFyIFRJTUVSID0gc2hhcmVkLnRpbWVyXG4gICAgdmFyIHByb2ZpbGVBcmcgPSBhcmdzLnByb2ZpbGVcblxuICAgIGZ1bmN0aW9uIHBlcmZDb3VudGVyICgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnRGF0ZS5ub3coKSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2Uubm93KCknXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENQVV9TVEFSVCwgUVVFUllfQ09VTlRFUlxuICAgIGZ1bmN0aW9uIGVtaXRQcm9maWxlU3RhcnQgKGJsb2NrKSB7XG4gICAgICBDUFVfU1RBUlQgPSBzY29wZS5kZWYoKVxuICAgICAgYmxvY2soQ1BVX1NUQVJULCAnPScsIHBlcmZDb3VudGVyKCksICc7JylcbiAgICAgIGlmICh0eXBlb2YgaW5jcmVtZW50Q291bnRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrPScsIGluY3JlbWVudENvdW50ZXIsICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrKFNUQVRTLCAnLmNvdW50Kys7JylcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBpZiAodXNlU2NvcGUpIHtcbiAgICAgICAgICBRVUVSWV9DT1VOVEVSID0gc2NvcGUuZGVmKClcbiAgICAgICAgICBibG9jayhRVUVSWV9DT1VOVEVSLCAnPScsIFRJTUVSLCAnLmdldE51bVBlbmRpbmdRdWVyaWVzKCk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5iZWdpblF1ZXJ5KCcsIFNUQVRTLCAnKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVFbmQgKGJsb2NrKSB7XG4gICAgICBibG9jayhTVEFUUywgJy5jcHVUaW1lKz0nLCBwZXJmQ291bnRlcigpLCAnLScsIENQVV9TVEFSVCwgJzsnKVxuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGlmICh1c2VTY29wZSkge1xuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLnB1c2hTY29wZVN0YXRzKCcsXG4gICAgICAgICAgICBRVUVSWV9DT1VOVEVSLCAnLCcsXG4gICAgICAgICAgICBUSU1FUiwgJy5nZXROdW1QZW5kaW5nUXVlcmllcygpLCcsXG4gICAgICAgICAgICBTVEFUUywgJyk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5lbmRRdWVyeSgpOycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY29wZVByb2ZpbGUgKHZhbHVlKSB7XG4gICAgICB2YXIgcHJldiA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKVxuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlPScsIHZhbHVlLCAnOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcucHJvZmlsZT0nLCBwcmV2LCAnOycpXG4gICAgfVxuXG4gICAgdmFyIFVTRV9QUk9GSUxFXG4gICAgaWYgKHByb2ZpbGVBcmcpIHtcbiAgICAgIGlmIChpc1N0YXRpYyhwcm9maWxlQXJnKSkge1xuICAgICAgICBpZiAocHJvZmlsZUFyZy5lbmFibGUpIHtcbiAgICAgICAgICBlbWl0UHJvZmlsZVN0YXJ0KHNjb3BlKVxuICAgICAgICAgIGVtaXRQcm9maWxlRW5kKHNjb3BlLmV4aXQpXG4gICAgICAgICAgc2NvcGVQcm9maWxlKCd0cnVlJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZVByb2ZpbGUoJ2ZhbHNlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFVTRV9QUk9GSUxFID0gcHJvZmlsZUFyZy5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHNjb3BlUHJvZmlsZShVU0VfUFJPRklMRSlcbiAgICB9IGVsc2Uge1xuICAgICAgVVNFX1BST0ZJTEUgPSBzY29wZS5kZWYoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlJylcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlU3RhcnQoc3RhcnQpXG4gICAgc2NvcGUoJ2lmKCcsIFVTRV9QUk9GSUxFLCAnKXsnLCBzdGFydCwgJ30nKVxuICAgIHZhciBlbmQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlRW5kKGVuZClcbiAgICBzY29wZS5leGl0KCdpZignLCBVU0VfUFJPRklMRSwgJyl7JywgZW5kLCAnfScpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QXR0cmlidXRlcyAoZW52LCBzY29wZSwgYXJncywgYXR0cmlidXRlcywgZmlsdGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcblxuICAgIGZ1bmN0aW9uIHR5cGVMZW5ndGggKHgpIHtcbiAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgIHJldHVybiAyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgcmV0dXJuIDNcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICByZXR1cm4gNFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdEJpbmRBdHRyaWJ1dGUgKEFUVFJJQlVURSwgc2l6ZSwgcmVjb3JkKSB7XG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgICAgdmFyIExPQ0FUSU9OID0gc2NvcGUuZGVmKEFUVFJJQlVURSwgJy5sb2NhdGlvbicpXG4gICAgICB2YXIgQklORElORyA9IHNjb3BlLmRlZihzaGFyZWQuYXR0cmlidXRlcywgJ1snLCBMT0NBVElPTiwgJ10nKVxuXG4gICAgICB2YXIgU1RBVEUgPSByZWNvcmQuc3RhdGVcbiAgICAgIHZhciBCVUZGRVIgPSByZWNvcmQuYnVmZmVyXG4gICAgICB2YXIgQ09OU1RfQ09NUE9ORU5UUyA9IFtcbiAgICAgICAgcmVjb3JkLngsXG4gICAgICAgIHJlY29yZC55LFxuICAgICAgICByZWNvcmQueixcbiAgICAgICAgcmVjb3JkLndcbiAgICAgIF1cblxuICAgICAgdmFyIENPTU1PTl9LRVlTID0gW1xuICAgICAgICAnYnVmZmVyJyxcbiAgICAgICAgJ25vcm1hbGl6ZWQnLFxuICAgICAgICAnb2Zmc2V0JyxcbiAgICAgICAgJ3N0cmlkZSdcbiAgICAgIF1cblxuICAgICAgZnVuY3Rpb24gZW1pdEJ1ZmZlciAoKSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZighJywgQklORElORywgJy5idWZmZXIpeycsXG4gICAgICAgICAgR0wsICcuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoJywgTE9DQVRJT04sICcpO30nKVxuXG4gICAgICAgIHZhciBUWVBFID0gcmVjb3JkLnR5cGVcbiAgICAgICAgdmFyIFNJWkVcbiAgICAgICAgaWYgKCFyZWNvcmQuc2l6ZSkge1xuICAgICAgICAgIFNJWkUgPSBzaXplXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgU0laRSA9IHNjb3BlLmRlZihyZWNvcmQuc2l6ZSwgJ3x8Jywgc2l6ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlKCdpZignLFxuICAgICAgICAgIEJJTkRJTkcsICcudHlwZSE9PScsIFRZUEUsICd8fCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplIT09JywgU0laRSwgJ3x8JyxcbiAgICAgICAgICBDT01NT05fS0VZUy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBrZXkgKyAnIT09JyArIHJlY29yZFtrZXldXG4gICAgICAgICAgfSkuam9pbignfHwnKSxcbiAgICAgICAgICAnKXsnLFxuICAgICAgICAgIEdMLCAnLmJpbmRCdWZmZXIoJywgR0xfQVJSQVlfQlVGRkVSJDIsICcsJywgQlVGRkVSLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWJQb2ludGVyKCcsIFtcbiAgICAgICAgICAgIExPQ0FUSU9OLFxuICAgICAgICAgICAgU0laRSxcbiAgICAgICAgICAgIFRZUEUsXG4gICAgICAgICAgICByZWNvcmQubm9ybWFsaXplZCxcbiAgICAgICAgICAgIHJlY29yZC5zdHJpZGUsXG4gICAgICAgICAgICByZWNvcmQub2Zmc2V0XG4gICAgICAgICAgXSwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnR5cGU9JywgVFlQRSwgJzsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuc2l6ZT0nLCBTSVpFLCAnOycsXG4gICAgICAgICAgQ09NTU9OX0tFWVMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBCSU5ESU5HICsgJy4nICsga2V5ICsgJz0nICsgcmVjb3JkW2tleV0gKyAnOydcbiAgICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgICAnfScpXG5cbiAgICAgICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgICAgICB2YXIgRElWSVNPUiA9IHJlY29yZC5kaXZpc29yXG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnaWYoJywgQklORElORywgJy5kaXZpc29yIT09JywgRElWSVNPUiwgJyl7JyxcbiAgICAgICAgICAgIGVudi5pbnN0YW5jaW5nLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLCBbTE9DQVRJT04sIERJVklTT1JdLCAnKTsnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yPScsIERJVklTT1IsICc7fScpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW1pdENvbnN0YW50ICgpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcsIEJJTkRJTkcsICcuYnVmZmVyKXsnLFxuICAgICAgICAgIEdMLCAnLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSgnLCBMT0NBVElPTiwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLmJ1ZmZlcj1udWxsOycsXG4gICAgICAgICAgJ31pZignLCBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnIT09JyArIENPTlNUX0NPTVBPTkVOVFNbaV1cbiAgICAgICAgICB9KS5qb2luKCd8fCcpLCAnKXsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYjRmKCcsIExPQ0FUSU9OLCAnLCcsIENPTlNUX0NPTVBPTkVOVFMsICcpOycsXG4gICAgICAgICAgQ1VURV9DT01QT05FTlRTLm1hcChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBjICsgJz0nICsgQ09OU1RfQ09NUE9ORU5UU1tpXSArICc7J1xuICAgICAgICAgIH0pLmpvaW4oJycpLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFID09PSBBVFRSSUJfU1RBVEVfUE9JTlRFUikge1xuICAgICAgICBlbWl0QnVmZmVyKClcbiAgICAgIH0gZWxzZSBpZiAoU1RBVEUgPT09IEFUVFJJQl9TVEFURV9DT05TVEFOVCkge1xuICAgICAgICBlbWl0Q29uc3RhbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUoJ2lmKCcsIFNUQVRFLCAnPT09JywgQVRUUklCX1NUQVRFX1BPSU5URVIsICcpeycpXG4gICAgICAgIGVtaXRCdWZmZXIoKVxuICAgICAgICBzY29wZSgnfWVsc2V7JylcbiAgICAgICAgZW1pdENvbnN0YW50KClcbiAgICAgICAgc2NvcGUoJ30nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICB2YXIgYXJnID0gYXJncy5hdHRyaWJ1dGVzW25hbWVdXG4gICAgICB2YXIgcmVjb3JkXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICByZWNvcmQgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWZpbHRlcihTQ09QRV9ERUNMKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgc2NvcGVBdHRyaWIgKyAnLnN0YXRlJyxcbiAgICAgICAgICAgICdtaXNzaW5nIGF0dHJpYnV0ZSAnICsgbmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgcmVjb3JkID0ge31cbiAgICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZWNvcmRba2V5XSA9IHNjb3BlLmRlZihzY29wZUF0dHJpYiwgJy4nLCBrZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbWl0QmluZEF0dHJpYnV0ZShcbiAgICAgICAgZW52LmxpbmsoYXR0cmlidXRlKSwgdHlwZUxlbmd0aChhdHRyaWJ1dGUuaW5mby50eXBlKSwgcmVjb3JkKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0VW5pZm9ybXMgKGVudiwgc2NvcGUsIGFyZ3MsIHVuaWZvcm1zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuXG4gICAgdmFyIGluZml4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1tpXVxuICAgICAgdmFyIG5hbWUgPSB1bmlmb3JtLm5hbWVcbiAgICAgIHZhciB0eXBlID0gdW5pZm9ybS5pbmZvLnR5cGVcbiAgICAgIHZhciBhcmcgPSBhcmdzLnVuaWZvcm1zW25hbWVdXG4gICAgICB2YXIgVU5JRk9STSA9IGVudi5saW5rKHVuaWZvcm0pXG4gICAgICB2YXIgTE9DQVRJT04gPSBVTklGT1JNICsgJy5sb2NhdGlvbidcblxuICAgICAgdmFyIFZBTFVFXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0YXRpYyhhcmcpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICdtaXNzaW5nIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIGlmICh0eXBlID09PSBHTF9TQU1QTEVSXzJEIHx8IHR5cGUgPT09IEdMX1NBTVBMRVJfQ1VCRSkge1xuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKCh0eXBlID09PSBHTF9TQU1QTEVSXzJEICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmUyZCcgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpKSB8fFxuICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmVDdWJlJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9yZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyQ3ViZScpKSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIHRleHR1cmUgZm9yIHVuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgdmFyIFRFWF9WQUxVRSA9IGVudi5saW5rKHZhbHVlLl90ZXh0dXJlIHx8IHZhbHVlLmNvbG9yWzBdLl90ZXh0dXJlKVxuICAgICAgICAgICAgc2NvcGUoR0wsICcudW5pZm9ybTFpKCcsIExPQ0FUSU9OLCAnLCcsIFRFWF9WQUxVRSArICcuYmluZCgpKTsnKVxuICAgICAgICAgICAgc2NvcGUuZXhpdChURVhfVkFMVUUsICcudW5iaW5kKCk7JylcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUNCkge1xuICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChpc0FycmF5TGlrZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbWF0cml4IGZvciB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICh0eXBlID09PSBHTF9GTE9BVF9NQVQyICYmIHZhbHVlLmxlbmd0aCA9PT0gNCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMyAmJiB2YWx1ZS5sZW5ndGggPT09IDkpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQgJiYgdmFsdWUubGVuZ3RoID09PSAxNiksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbGVuZ3RoIGZvciBtYXRyaXggdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFyIE1BVF9WQUxVRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KFsnICtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpICsgJ10pJylcbiAgICAgICAgICAgIHZhciBkaW0gPSAyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMykge1xuICAgICAgICAgICAgICBkaW0gPSAzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQpIHtcbiAgICAgICAgICAgICAgZGltID0gNFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAgIEdMLCAnLnVuaWZvcm1NYXRyaXgnLCBkaW0sICdmdignLFxuICAgICAgICAgICAgICBMT0NBVElPTiwgJyxmYWxzZSwnLCBNQVRfVkFMVUUsICcpOycpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ251bWJlcicsICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcxZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcyZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzM6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0ZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0JPT0w6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nLCAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMWknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzJpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDMsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAzLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzRpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtJywgaW5maXgsICcoJywgTE9DQVRJT04sICcsJyxcbiAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpIDogdmFsdWUsXG4gICAgICAgICAgICAgICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVkFMVUUgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmlsdGVyKFNDT1BFX0RFQ0wpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBWQUxVRSA9IHNjb3BlLmRlZihzaGFyZWQudW5pZm9ybXMsICdbJywgc3RyaW5nU3RvcmUuaWQobmFtZSksICddJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IEdMX1NBTVBMRVJfMkQpIHtcbiAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IHNwZWNpZnkgYSBzY2FsYXIgcHJvcCBmb3IgdGV4dHVyZXMnKVxuICAgICAgICBzY29wZShcbiAgICAgICAgICAnaWYoJywgVkFMVUUsICcmJicsIFZBTFVFLCAnLl9yZWdsVHlwZT09PVwiZnJhbWVidWZmZXJcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBzcGVjaWZ5IGEgc2NhbGFyIHByb3AgZm9yIGN1YmUgbWFwcycpXG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyYmJywgVkFMVUUsICcuX3JlZ2xUeXBlPT09XCJmcmFtZWJ1ZmZlckN1YmVcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgLy8gcGVyZm9ybSB0eXBlIHZhbGlkYXRpb25cbiAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBlbWl0Q2hlY2sgKHByZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBwcmVkLFxuICAgICAgICAgICAgJ2JhZCBkYXRhIG9yIG1pc3NpbmcgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIi4gICcgKyBtZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tUeXBlICh0eXBlKSB7XG4gICAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IG5vdCBzcGVjaWZ5IGFuIGFycmF5IHR5cGUgZm9yIHVuaWZvcm0nKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiJyArIHR5cGUgKyAnXCInLFxuICAgICAgICAgICAgJ2ludmFsaWQgdHlwZSwgZXhwZWN0ZWQgJyArIHR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZlY3RvciAobiwgdHlwZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFZBTFVFKSkge1xuICAgICAgICAgICAgY2hlY2skMShWQUxVRS5sZW5ndGggPT09IG4sICdtdXN0IGhhdmUgbGVuZ3RoICcgKyBuKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0Q2hlY2soXG4gICAgICAgICAgICAgIHNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIFZBTFVFICsgJykmJicgKyBWQUxVRSArICcubGVuZ3RoPT09JyArIG4sXG4gICAgICAgICAgICAgICdpbnZhbGlkIHZlY3Rvciwgc2hvdWxkIGhhdmUgbGVuZ3RoICcgKyBuLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1RleHR1cmUgKHRhcmdldCkge1xuICAgICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBub3Qgc3BlY2lmeSBhIHZhbHVlIHR5cGUnKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiZnVuY3Rpb25cIiYmJyArXG4gICAgICAgICAgICBWQUxVRSArICcuX3JlZ2xUeXBlPT09XCJ0ZXh0dXJlJyArXG4gICAgICAgICAgICAodGFyZ2V0ID09PSBHTF9URVhUVVJFXzJEJDMgPyAnMmQnIDogJ0N1YmUnKSArICdcIicsXG4gICAgICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgR0xfSU5UJDM6XG4gICAgICAgICAgICBjaGVja1R5cGUoJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVQkODpcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgICAgY2hlY2tUeXBlKCdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnYm9vbGVhbicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDQsICdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDksICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigxNiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl8yRDpcbiAgICAgICAgICAgIGNoZWNrVGV4dHVyZShHTF9URVhUVVJFXzJEJDMpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl9DVUJFOlxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfQ1VCRV9NQVAkMilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHZhciB1bnJvbGwgPSAxXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBHTF9TQU1QTEVSXzJEOlxuICAgICAgICBjYXNlIEdMX1NBTVBMRVJfQ1VCRTpcbiAgICAgICAgICB2YXIgVEVYID0gc2NvcGUuZGVmKFZBTFVFLCAnLl90ZXh0dXJlJylcbiAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtMWkoJywgTE9DQVRJT04sICcsJywgVEVYLCAnLmJpbmQoKSk7JylcbiAgICAgICAgICBzY29wZS5leGl0KFRFWCwgJy51bmJpbmQoKTsnKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgdW5yb2xsID0gMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgdW5yb2xsID0gM1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVCQ4OlxuICAgICAgICAgIGluZml4ID0gJzFmJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgIGluZml4ID0gJzJmJ1xuICAgICAgICAgIHVucm9sbCA9IDJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICB1bnJvbGwgPSAzXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGYnXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgIGluZml4ID0gJ01hdHJpeDJmdidcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICBpbmZpeCA9ICdNYXRyaXgzZnYnXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgaW5maXggPSAnTWF0cml4NGZ2J1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0nLCBpbmZpeCwgJygnLCBMT0NBVElPTiwgJywnKVxuICAgICAgaWYgKGluZml4LmNoYXJBdCgwKSA9PT0gJ00nKSB7XG4gICAgICAgIHZhciBtYXRTaXplID0gTWF0aC5wb3codHlwZSAtIEdMX0ZMT0FUX01BVDIgKyAyLCAyKVxuICAgICAgICB2YXIgU1RPUkFHRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KCcsIG1hdFNpemUsICcpJylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoVkFMVUUpKSB7XG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnZmFsc2UsKCcsXG4gICAgICAgICAgICBsb29wKG1hdFNpemUsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVE9SQUdFICsgJ1snICsgaSArICddPScgKyBWQUxVRVtpXVxuICAgICAgICAgICAgfSksICcsJywgU1RPUkFHRSwgJyknKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgJ2ZhbHNlLChBcnJheS5pc0FycmF5KCcsIFZBTFVFLCAnKXx8JywgVkFMVUUsICcgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpPycsIFZBTFVFLCAnOignLFxuICAgICAgICAgICAgbG9vcChtYXRTaXplLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gU1RPUkFHRSArICdbJyArIGkgKyAnXT0nICsgVkFMVUUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICB9KSwgJywnLCBTVE9SQUdFLCAnKScpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodW5yb2xsID4gMSkge1xuICAgICAgICBzY29wZShsb29wKHVucm9sbCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShWQUxVRSkgPyBWQUxVRVtpXSA6IFZBTFVFICsgJ1snICsgaSArICddJ1xuICAgICAgICB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAndW5pZm9ybSB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBhcnJheScpXG4gICAgICAgIHNjb3BlKFZBTFVFKVxuICAgICAgfVxuICAgICAgc2NvcGUoJyk7JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0RHJhdyAoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuICAgIHZhciBEUkFXX1NUQVRFID0gc2hhcmVkLmRyYXdcblxuICAgIHZhciBkcmF3T3B0aW9ucyA9IGFyZ3MuZHJhd1xuXG4gICAgZnVuY3Rpb24gZW1pdEVsZW1lbnRzICgpIHtcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuZWxlbWVudHNcbiAgICAgIHZhciBFTEVNRU5UU1xuICAgICAgdmFyIHNjb3BlID0gb3V0ZXJcbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIGlmICgoZGVmbi5jb250ZXh0RGVwICYmIGFyZ3MuY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcCkge1xuICAgICAgICAgIHNjb3BlID0gaW5uZXJcbiAgICAgICAgfVxuICAgICAgICBFTEVNRU5UUyA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFTEVNRU5UUyA9IHNjb3BlLmRlZihEUkFXX1NUQVRFLCAnLicsIFNfRUxFTUVOVFMpXG4gICAgICB9XG4gICAgICBpZiAoRUxFTUVOVFMpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcgKyBFTEVNRU5UUyArICcpJyArXG4gICAgICAgICAgR0wgKyAnLmJpbmRCdWZmZXIoJyArIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSJDEgKyAnLCcgKyBFTEVNRU5UUyArICcuYnVmZmVyLmJ1ZmZlcik7JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBFTEVNRU5UU1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRDb3VudCAoKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zLmNvdW50XG4gICAgICB2YXIgQ09VTlRcbiAgICAgIHZhciBzY29wZSA9IG91dGVyXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICBzY29wZSA9IGlubmVyXG4gICAgICAgIH1cbiAgICAgICAgQ09VTlQgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGVmbi5NSVNTSU5HKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KG91dGVyLCAnZmFsc2UnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmbi5EWU5BTUlDKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBDT1VOVCArICc+PTAnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENPVU5UID0gc2NvcGUuZGVmKERSQVdfU1RBVEUsICcuJywgU19DT1VOVClcbiAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW52LmFzc2VydChzY29wZSwgQ09VTlQgKyAnPj0wJywgJ21pc3NpbmcgdmVydGV4IGNvdW50JylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBDT1VOVFxuICAgIH1cblxuICAgIHZhciBFTEVNRU5UUyA9IGVtaXRFbGVtZW50cygpXG4gICAgZnVuY3Rpb24gZW1pdFZhbHVlIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBpbm5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBvdXRlcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG91dGVyLmRlZihEUkFXX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFBSSU1JVElWRSA9IGVtaXRWYWx1ZShTX1BSSU1JVElWRSlcbiAgICB2YXIgT0ZGU0VUID0gZW1pdFZhbHVlKFNfT0ZGU0VUKVxuXG4gICAgdmFyIENPVU5UID0gZW1pdENvdW50KClcbiAgICBpZiAodHlwZW9mIENPVU5UID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKENPVU5UID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lcignaWYoJywgQ09VTlQsICcpeycpXG4gICAgICBpbm5lci5leGl0KCd9JylcbiAgICB9XG5cbiAgICB2YXIgSU5TVEFOQ0VTLCBFWFRfSU5TVEFOQ0lOR1xuICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICBJTlNUQU5DRVMgPSBlbWl0VmFsdWUoU19JTlNUQU5DRVMpXG4gICAgICBFWFRfSU5TVEFOQ0lORyA9IGVudi5pbnN0YW5jaW5nXG4gICAgfVxuXG4gICAgdmFyIEVMRU1FTlRfVFlQRSA9IEVMRU1FTlRTICsgJy50eXBlJ1xuXG4gICAgdmFyIGVsZW1lbnRzU3RhdGljID0gZHJhd09wdGlvbnMuZWxlbWVudHMgJiYgaXNTdGF0aWMoZHJhd09wdGlvbnMuZWxlbWVudHMpXG5cbiAgICBmdW5jdGlvbiBlbWl0SW5zdGFuY2luZyAoKSB7XG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMgKCkge1xuICAgICAgICBpbm5lcihFWFRfSU5TVEFOQ0lORywgJy5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSgnLCBbXG4gICAgICAgICAgUFJJTUlUSVZFLFxuICAgICAgICAgIENPVU5ULFxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcbiAgICAgICAgICBPRkZTRVQgKyAnPDwoKCcgKyBFTEVNRU5UX1RZUEUgKyAnLScgKyBHTF9VTlNJR05FRF9CWVRFJDggKyAnKT4+MSknLFxuICAgICAgICAgIElOU1RBTkNFU1xuICAgICAgICBdLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3QXJyYXlzICgpIHtcbiAgICAgICAgaW5uZXIoRVhUX0lOU1RBTkNJTkcsICcuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCcsXG4gICAgICAgICAgW1BSSU1JVElWRSwgT0ZGU0VULCBDT1VOVCwgSU5TVEFOQ0VTXSwgJyk7JylcbiAgICAgIH1cblxuICAgICAgaWYgKEVMRU1FTlRTKSB7XG4gICAgICAgIGlmICghZWxlbWVudHNTdGF0aWMpIHtcbiAgICAgICAgICBpbm5lcignaWYoJywgRUxFTUVOVFMsICcpeycpXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgICBpbm5lcignfWVsc2V7JylcbiAgICAgICAgICBkcmF3QXJyYXlzKClcbiAgICAgICAgICBpbm5lcignfScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFJlZ3VsYXIgKCkge1xuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzICgpIHtcbiAgICAgICAgaW5uZXIoR0wgKyAnLmRyYXdFbGVtZW50cygnICsgW1xuICAgICAgICAgIFBSSU1JVElWRSxcbiAgICAgICAgICBDT1VOVCxcbiAgICAgICAgICBFTEVNRU5UX1RZUEUsXG4gICAgICAgICAgT0ZGU0VUICsgJzw8KCgnICsgRUxFTUVOVF9UWVBFICsgJy0nICsgR0xfVU5TSUdORURfQllURSQ4ICsgJyk+PjEpJ1xuICAgICAgICBdICsgJyk7JylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd0FycmF5cyAoKSB7XG4gICAgICAgIGlubmVyKEdMICsgJy5kcmF3QXJyYXlzKCcgKyBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5UXSArICcpOycpXG4gICAgICB9XG5cbiAgICAgIGlmIChFTEVNRU5UUykge1xuICAgICAgICBpZiAoIWVsZW1lbnRzU3RhdGljKSB7XG4gICAgICAgICAgaW5uZXIoJ2lmKCcsIEVMRU1FTlRTLCAnKXsnKVxuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgICAgaW5uZXIoJ31lbHNleycpXG4gICAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICAgICAgaW5uZXIoJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXdBcnJheXMoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRJbnN0YW5jaW5nICYmICh0eXBlb2YgSU5TVEFOQ0VTICE9PSAnbnVtYmVyJyB8fCBJTlNUQU5DRVMgPj0gMCkpIHtcbiAgICAgIGlmICh0eXBlb2YgSU5TVEFOQ0VTID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbm5lcignaWYoJywgSU5TVEFOQ0VTLCAnPjApeycpXG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgICAgaW5uZXIoJ31lbHNlIGlmKCcsIElOU1RBTkNFUywgJzwwKXsnKVxuICAgICAgICBlbWl0UmVndWxhcigpXG4gICAgICAgIGlubmVyKCd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFJlZ3VsYXIoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvZHkgKGVtaXRCb2R5LCBwYXJlbnRFbnYsIGFyZ3MsIHByb2dyYW0sIGNvdW50KSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ2JvZHknLCBjb3VudClcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5jb21tYW5kU3RyID0gcGFyZW50RW52LmNvbW1hbmRTdHJcbiAgICAgIGVudi5jb21tYW5kID0gZW52LmxpbmsocGFyZW50RW52LmNvbW1hbmRTdHIpXG4gICAgfSlcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgZW52Lmluc3RhbmNpbmcgPSBzY29wZS5kZWYoXG4gICAgICAgIGVudi5zaGFyZWQuZXh0ZW5zaW9ucywgJy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgICB9XG4gICAgZW1pdEJvZHkoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSlcbiAgICByZXR1cm4gZW52LmNvbXBpbGUoKS5ib2R5XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERSQVcgUFJPQ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXREcmF3Qm9keSAoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtKSB7XG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGRyYXcpXG4gICAgaWYgKGFyZ3MudXNlVkFPKSB7XG4gICAgICBpZiAoYXJncy5kcmF3VkFPKSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBkcmF3KSwgJyk7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8obnVsbCk7JylcbiAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgZHJhdywgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgICBlbWl0VW5pZm9ybXMoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtLnVuaWZvcm1zLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgZW1pdERyYXcoZW52LCBkcmF3LCBkcmF3LCBhcmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdERyYXdQcm9jIChlbnYsIGFyZ3MpIHtcbiAgICB2YXIgZHJhdyA9IGVudi5wcm9jKCdkcmF3JywgMSlcblxuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBkcmF3KVxuXG4gICAgZW1pdENvbnRleHQoZW52LCBkcmF3LCBhcmdzLmNvbnRleHQpXG4gICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGRyYXcsIGFyZ3MuZnJhbWVidWZmZXIpXG5cbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgZHJhdywgYXJncylcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGRyYXcsIGFyZ3Muc3RhdGUpXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIGRyYXcsIGFyZ3MsIGZhbHNlLCB0cnVlKVxuXG4gICAgdmFyIHByb2dyYW0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGRyYXcpXG4gICAgZHJhdyhlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgcHJvZ3JhbSwgJy5wcm9ncmFtKTsnKVxuXG4gICAgaWYgKGFyZ3Muc2hhZGVyLnByb2dyYW0pIHtcbiAgICAgIGVtaXREcmF3Qm9keShlbnYsIGRyYXcsIGFyZ3MsIGFyZ3Muc2hhZGVyLnByb2dyYW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKG51bGwpOycpXG4gICAgICB2YXIgZHJhd0NhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9JylcbiAgICAgIHZhciBQUk9HX0lEID0gZHJhdy5kZWYocHJvZ3JhbSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBkcmF3LmRlZihkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ10nKVxuICAgICAgZHJhdyhcbiAgICAgICAgZW52LmNvbmQoQ0FDSEVEX1BST0MpXG4gICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwKTsnKVxuICAgICAgICAgIC5lbHNlKFxuICAgICAgICAgICAgQ0FDSEVEX1BST0MsICc9JywgZHJhd0NhY2hlLCAnWycsIFBST0dfSUQsICddPScsXG4gICAgICAgICAgICBlbnYubGluayhmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0RHJhd0JvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMSlcbiAgICAgICAgICAgIH0pLCAnKCcsIHByb2dyYW0sICcpOycsXG4gICAgICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTApOycpKVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhhcmdzLnN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICBkcmF3KGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBCQVRDSCBQUk9DXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBlbWl0QmF0Y2hEeW5hbWljU2hhZGVyQm9keSAoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSkge1xuICAgIGVudi5iYXRjaElkID0gJ2ExJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIHNjb3BlKVxuXG4gICAgZnVuY3Rpb24gYWxsICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZW1pdEF0dHJpYnV0ZXMoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBhbGwpXG4gICAgZW1pdFVuaWZvcm1zKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGFsbClcbiAgICBlbWl0RHJhdyhlbnYsIHNjb3BlLCBzY29wZSwgYXJncylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRCYXRjaEJvZHkgKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0pIHtcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpXG5cbiAgICB2YXIgY29udGV4dER5bmFtaWMgPSBhcmdzLmNvbnRleHREZXBcblxuICAgIHZhciBCQVRDSF9JRCA9IHNjb3BlLmRlZigpXG4gICAgdmFyIFBST1BfTElTVCA9ICdhMCdcbiAgICB2YXIgTlVNX1BST1BTID0gJ2ExJ1xuICAgIHZhciBQUk9QUyA9IHNjb3BlLmRlZigpXG4gICAgZW52LnNoYXJlZC5wcm9wcyA9IFBST1BTXG4gICAgZW52LmJhdGNoSWQgPSBCQVRDSF9JRFxuXG4gICAgdmFyIG91dGVyID0gZW52LnNjb3BlKClcbiAgICB2YXIgaW5uZXIgPSBlbnYuc2NvcGUoKVxuXG4gICAgc2NvcGUoXG4gICAgICBvdXRlci5lbnRyeSxcbiAgICAgICdmb3IoJywgQkFUQ0hfSUQsICc9MDsnLCBCQVRDSF9JRCwgJzwnLCBOVU1fUFJPUFMsICc7KysnLCBCQVRDSF9JRCwgJyl7JyxcbiAgICAgIFBST1BTLCAnPScsIFBST1BfTElTVCwgJ1snLCBCQVRDSF9JRCwgJ107JyxcbiAgICAgIGlubmVyLFxuICAgICAgJ30nLFxuICAgICAgb3V0ZXIuZXhpdClcblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKChkZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc091dGVyRGVmbiAoZGVmbikge1xuICAgICAgcmV0dXJuICFpc0lubmVyRGVmbihkZWZuKVxuICAgIH1cblxuICAgIGlmIChhcmdzLm5lZWRzQ29udGV4dCkge1xuICAgICAgZW1pdENvbnRleHQoZW52LCBpbm5lciwgYXJncy5jb250ZXh0KVxuICAgIH1cbiAgICBpZiAoYXJncy5uZWVkc0ZyYW1lYnVmZmVyKSB7XG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgaW5uZXIsIGFyZ3MuZnJhbWVidWZmZXIpXG4gICAgfVxuICAgIGVtaXRTZXRPcHRpb25zKGVudiwgaW5uZXIsIGFyZ3Muc3RhdGUsIGlzSW5uZXJEZWZuKVxuXG4gICAgaWYgKGFyZ3MucHJvZmlsZSAmJiBpc0lubmVyRGVmbihhcmdzLnByb2ZpbGUpKSB7XG4gICAgICBlbWl0UHJvZmlsZShlbnYsIGlubmVyLCBhcmdzLCBmYWxzZSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIHZhciBwcm9nQ2FjaGUgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgICAgdmFyIFBST0dSQU0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGlubmVyKVxuICAgICAgdmFyIFBST0dfSUQgPSBpbm5lci5kZWYoUFJPR1JBTSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBpbm5lci5kZWYocHJvZ0NhY2hlLCAnWycsIFBST0dfSUQsICddJylcbiAgICAgIGlubmVyKFxuICAgICAgICBlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgUFJPR1JBTSwgJy5wcm9ncmFtKTsnLFxuICAgICAgICAnaWYoIScsIENBQ0hFRF9QUk9DLCAnKXsnLFxuICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBwcm9nQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShcbiAgICAgICAgICAgIGVtaXRCYXRjaER5bmFtaWNTaGFkZXJCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpO30nLFxuICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTBbJywgQkFUQ0hfSUQsICddLCcsIEJBVENIX0lELCAnKTsnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy51c2VWQU8pIHtcbiAgICAgICAgaWYgKGFyZ3MuZHJhd1ZBTykge1xuICAgICAgICAgIGlmIChpc0lubmVyRGVmbihhcmdzLmRyYXdWQU8pKSB7XG4gICAgICAgICAgICAvLyB2YW8gaXMgYSBwcm9wXG4gICAgICAgICAgICBpbm5lcihlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgYXJncy5kcmF3VkFPLmFwcGVuZChlbnYsIGlubmVyKSwgJyk7JylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmFvIGlzIGludmFyaWFudFxuICAgICAgICAgICAgb3V0ZXIoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBvdXRlciksICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNjb3BlZCB2YW8gYmluZGluZ1xuICAgICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTygnLCBlbnYuc2hhcmVkLnZhbywgJy50YXJnZXRWQU8pOycpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIG91dGVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIGlubmVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzSW5uZXJEZWZuKVxuICAgICAgfVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgaW5uZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzSW5uZXJEZWZuKVxuICAgICAgZW1pdERyYXcoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEJhdGNoUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIGJhdGNoID0gZW52LnByb2MoJ2JhdGNoJywgMilcbiAgICBlbnYuYmF0Y2hJZCA9ICcwJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGJhdGNoKVxuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGNvbnRleHQgdmFyaWFibGVzIGRlcGVuZCBvbiBwcm9wc1xuICAgIHZhciBjb250ZXh0RHluYW1pYyA9IGZhbHNlXG4gICAgdmFyIG5lZWRzQ29udGV4dCA9IHRydWVcbiAgICBPYmplY3Qua2V5cyhhcmdzLmNvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gY29udGV4dER5bmFtaWMgfHwgYXJncy5jb250ZXh0W25hbWVdLnByb3BEZXBcbiAgICB9KVxuICAgIGlmICghY29udGV4dER5bmFtaWMpIHtcbiAgICAgIGVtaXRDb250ZXh0KGVudiwgYmF0Y2gsIGFyZ3MuY29udGV4dClcbiAgICAgIG5lZWRzQ29udGV4dCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZnJhbWVidWZmZXIgc3RhdGUgYWZmZWN0cyBmcmFtZWJ1ZmZlcldpZHRoL2hlaWdodCBjb250ZXh0IHZhcnNcbiAgICB2YXIgZnJhbWVidWZmZXIgPSBhcmdzLmZyYW1lYnVmZmVyXG4gICAgdmFyIG5lZWRzRnJhbWVidWZmZXIgPSBmYWxzZVxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKGZyYW1lYnVmZmVyLnByb3BEZXApIHtcbiAgICAgICAgY29udGV4dER5bmFtaWMgPSBuZWVkc0ZyYW1lYnVmZmVyID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChmcmFtZWJ1ZmZlci5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB7XG4gICAgICAgIG5lZWRzRnJhbWVidWZmZXIgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIW5lZWRzRnJhbWVidWZmZXIpIHtcbiAgICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBmcmFtZWJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBudWxsKVxuICAgIH1cblxuICAgIC8vIHZpZXdwb3J0IGlzIHdlaXJkIGJlY2F1c2UgaXQgY2FuIGFmZmVjdCBjb250ZXh0IHZhcnNcbiAgICBpZiAoYXJncy5zdGF0ZS52aWV3cG9ydCAmJiBhcmdzLnN0YXRlLnZpZXdwb3J0LnByb3BEZXApIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKGRlZm4uY29udGV4dERlcCAmJiBjb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwXG4gICAgfVxuXG4gICAgLy8gc2V0IHdlYmdsIG9wdGlvbnNcbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgYmF0Y2gsIGFyZ3MpXG4gICAgZW1pdFNldE9wdGlvbnMoZW52LCBiYXRjaCwgYXJncy5zdGF0ZSwgZnVuY3Rpb24gKGRlZm4pIHtcbiAgICAgIHJldHVybiAhaXNJbm5lckRlZm4oZGVmbilcbiAgICB9KVxuXG4gICAgaWYgKCFhcmdzLnByb2ZpbGUgfHwgIWlzSW5uZXJEZWZuKGFyZ3MucHJvZmlsZSkpIHtcbiAgICAgIGVtaXRQcm9maWxlKGVudiwgYmF0Y2gsIGFyZ3MsIGZhbHNlLCAnYTEnKVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlc2UgdmFsdWVzIHRvIGFyZ3Mgc28gdGhhdCB0aGUgYmF0Y2ggYm9keSByb3V0aW5lIGNhbiB1c2UgdGhlbVxuICAgIGFyZ3MuY29udGV4dERlcCA9IGNvbnRleHREeW5hbWljXG4gICAgYXJncy5uZWVkc0NvbnRleHQgPSBuZWVkc0NvbnRleHRcbiAgICBhcmdzLm5lZWRzRnJhbWVidWZmZXIgPSBuZWVkc0ZyYW1lYnVmZmVyXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgc2hhZGVyIGlzIGR5bmFtaWNcbiAgICB2YXIgcHJvZ0RlZm4gPSBhcmdzLnNoYWRlci5wcm9nVmFyXG4gICAgaWYgKChwcm9nRGVmbi5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB8fCBwcm9nRGVmbi5wcm9wRGVwKSB7XG4gICAgICBlbWl0QmF0Y2hCb2R5KFxuICAgICAgICBlbnYsXG4gICAgICAgIGJhdGNoLFxuICAgICAgICBhcmdzLFxuICAgICAgICBudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgUFJPR1JBTSA9IHByb2dEZWZuLmFwcGVuZChlbnYsIGJhdGNoKVxuICAgICAgYmF0Y2goZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIFBST0dSQU0sICcucHJvZ3JhbSk7JylcbiAgICAgIGlmIChhcmdzLnNoYWRlci5wcm9ncmFtKSB7XG4gICAgICAgIGVtaXRCYXRjaEJvZHkoXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgYXJncy5zaGFkZXIucHJvZ3JhbSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICB2YXIgYmF0Y2hDYWNoZSA9IGVudi5nbG9iYWwuZGVmKCd7fScpXG4gICAgICAgIHZhciBQUk9HX0lEID0gYmF0Y2guZGVmKFBST0dSQU0sICcuaWQnKVxuICAgICAgICB2YXIgQ0FDSEVEX1BST0MgPSBiYXRjaC5kZWYoYmF0Y2hDYWNoZSwgJ1snLCBQUk9HX0lELCAnXScpXG4gICAgICAgIGJhdGNoKFxuICAgICAgICAgIGVudi5jb25kKENBQ0hFRF9QUk9DKVxuICAgICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwLGExKTsnKVxuICAgICAgICAgICAgLmVsc2UoXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnPScsIGJhdGNoQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0QmF0Y2hCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpOycsXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCxhMSk7JykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGJhdGNoKGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTQ09QRSBDT01NQU5EXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW1pdFNjb3BlUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ3Njb3BlJywgMylcbiAgICBlbnYuYmF0Y2hJZCA9ICdhMidcblxuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuXG4gICAgZW1pdENvbnRleHQoZW52LCBzY29wZSwgYXJncy5jb250ZXh0KVxuXG4gICAgaWYgKGFyZ3MuZnJhbWVidWZmZXIpIHtcbiAgICAgIGFyZ3MuZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfVxuXG4gICAgc29ydFN0YXRlKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGFyZ3Muc3RhdGVbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICBzY29wZS5zZXQoZW52Lm5leHRbbmFtZV0sICdbJyArIGkgKyAnXScsIHYpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLm5leHQsICcuJyArIG5hbWUsIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIHNjb3BlLCBhcmdzLCB0cnVlLCB0cnVlKVxuXG4gICAgO1tTX0VMRU1FTlRTLCBTX09GRlNFVCwgU19DT1VOVCwgU19JTlNUQU5DRVMsIFNfUFJJTUlUSVZFXS5mb3JFYWNoKFxuICAgICAgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICB2YXIgdmFyaWFibGUgPSBhcmdzLmRyYXdbb3B0XVxuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuc2V0KHNoYXJlZC5kcmF3LCAnLicgKyBvcHQsICcnICsgdmFyaWFibGUuYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MudW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJncy51bmlmb3Jtc1tvcHRdLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gJ1snICsgdmFsdWUuam9pbigpICsgJ10nXG4gICAgICB9XG4gICAgICBzY29wZS5zZXQoXG4gICAgICAgIHNoYXJlZC51bmlmb3JtcyxcbiAgICAgICAgJ1snICsgc3RyaW5nU3RvcmUuaWQob3B0KSArICddJyxcbiAgICAgICAgdmFsdWUpXG4gICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IGFyZ3MuYXR0cmlidXRlc1tuYW1lXS5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHNjb3BlLnNldChzY29wZUF0dHJpYiwgJy4nICsgcHJvcCwgcmVjb3JkW3Byb3BdKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGFyZ3Muc2NvcGVWQU8pIHtcbiAgICAgIHNjb3BlLnNldChzaGFyZWQudmFvLCAnLnRhcmdldFZBTycsIGFyZ3Muc2NvcGVWQU8uYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVTaGFkZXIgKG5hbWUpIHtcbiAgICAgIHZhciBzaGFkZXIgPSBhcmdzLnNoYWRlcltuYW1lXVxuICAgICAgaWYgKHNoYWRlcikge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLnNoYWRlciwgJy4nICsgbmFtZSwgc2hhZGVyLmFwcGVuZChlbnYsIHNjb3BlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2F2ZVNoYWRlcihTX1ZFUlQpXG4gICAgc2F2ZVNoYWRlcihTX0ZSQUcpXG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT10cnVlOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcuZGlydHk9dHJ1ZTsnKVxuICAgIH1cblxuICAgIHNjb3BlKCdhMSgnLCBlbnYuc2hhcmVkLmNvbnRleHQsICcsYTAsJywgZW52LmJhdGNoSWQsICcpOycpXG4gIH1cblxuICBmdW5jdGlvbiBpc0R5bmFtaWNPYmplY3QgKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5TGlrZShvYmplY3QpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyhvYmplY3RbcHJvcHNbaV1dKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGF0T2JqZWN0IChlbnYsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgICBpZiAoIW9iamVjdCB8fCAhaXNEeW5hbWljT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBnbG9iYWxzID0gZW52Lmdsb2JhbFxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIHZhciB0aGlzRGVwID0gZmFsc2VcbiAgICB2YXIgY29udGV4dERlcCA9IGZhbHNlXG4gICAgdmFyIHByb3BEZXAgPSBmYWxzZVxuICAgIHZhciBvYmplY3RSZWYgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSA9IGR5bmFtaWMudW5ib3godmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHMgPSBjcmVhdGVEeW5hbWljRGVjbCh2YWx1ZSwgbnVsbClcbiAgICAgICAgdGhpc0RlcCA9IHRoaXNEZXAgfHwgZGVwcy50aGlzRGVwXG4gICAgICAgIHByb3BEZXAgPSBwcm9wRGVwIHx8IGRlcHMucHJvcERlcFxuICAgICAgICBjb250ZXh0RGVwID0gY29udGV4dERlcCB8fCBkZXBzLmNvbnRleHREZXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHMob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBnbG9iYWxzKHZhbHVlKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgZ2xvYmFscygnXCInLCB2YWx1ZSwgJ1wiJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBnbG9iYWxzKCdbJywgdmFsdWUuam9pbigpLCAnXScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnbG9iYWxzKGVudi5saW5rKHZhbHVlKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFscygnOycpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIGFwcGVuZEJsb2NrIChlbnYsIGJsb2NrKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgICBpZiAoIWR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBlbnYuaW52b2tlKGJsb2NrLCB2YWx1ZSlcbiAgICAgICAgYmxvY2sob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nLCByZWYsICc7JylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb3B0aW9ucy5keW5hbWljW25hbWVdID0gbmV3IGR5bmFtaWMuRHluYW1pY1ZhcmlhYmxlKERZTl9USFVOSywge1xuICAgICAgdGhpc0RlcDogdGhpc0RlcCxcbiAgICAgIGNvbnRleHREZXA6IGNvbnRleHREZXAsXG4gICAgICBwcm9wRGVwOiBwcm9wRGVwLFxuICAgICAgcmVmOiBvYmplY3RSZWYsXG4gICAgICBhcHBlbmQ6IGFwcGVuZEJsb2NrXG4gICAgfSlcbiAgICBkZWxldGUgb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTUFJTiBEUkFXIENPTU1BTkRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBjb21waWxlQ29tbWFuZCAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIHN0YXRzKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG5cbiAgICAvLyBsaW5rIHN0YXRzLCBzbyB0aGF0IHdlIGNhbiBlYXNpbHkgYWNjZXNzIGl0IGluIHRoZSBwcm9ncmFtLlxuICAgIGVudi5zdGF0cyA9IGVudi5saW5rKHN0YXRzKVxuXG4gICAgLy8gc3BsYXQgb3B0aW9ucyBhbmQgYXR0cmlidXRlcyB0byBhbGxvdyBmb3IgZHluYW1pYyBuZXN0ZWQgcHJvcGVydGllc1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuc3RhdGljKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHNwbGF0T2JqZWN0KGVudiwgYXR0cmlidXRlcywga2V5KVxuICAgIH0pXG4gICAgTkVTVEVEX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgc3BsYXRPYmplY3QoZW52LCBvcHRpb25zLCBuYW1lKVxuICAgIH0pXG5cbiAgICB2YXIgYXJncyA9IHBhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zLCBjb250ZXh0LCBlbnYpXG5cbiAgICBlbWl0RHJhd1Byb2MoZW52LCBhcmdzKVxuICAgIGVtaXRTY29wZVByb2MoZW52LCBhcmdzKVxuICAgIGVtaXRCYXRjaFByb2MoZW52LCBhcmdzKVxuXG4gICAgcmV0dXJuIGV4dGVuZChlbnYuY29tcGlsZSgpLCB7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3Muc2hhZGVyLnByb2dyYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUE9MTCAvIFJFRlJFU0hcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4ge1xuICAgIG5leHQ6IG5leHRTdGF0ZSxcbiAgICBjdXJyZW50OiBjdXJyZW50U3RhdGUsXG4gICAgcHJvY3M6IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KClcbiAgICAgIHZhciBwb2xsID0gZW52LnByb2MoJ3BvbGwnKVxuICAgICAgdmFyIHJlZnJlc2ggPSBlbnYucHJvYygncmVmcmVzaCcpXG4gICAgICB2YXIgY29tbW9uID0gZW52LmJsb2NrKClcbiAgICAgIHBvbGwoY29tbW9uKVxuICAgICAgcmVmcmVzaChjb21tb24pXG5cbiAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICAgIHZhciBORVhUX1NUQVRFID0gc2hhcmVkLm5leHRcbiAgICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcblxuICAgICAgY29tbW9uKENVUlJFTlRfU1RBVEUsICcuZGlydHk9ZmFsc2U7JylcblxuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIHBvbGwpXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgcmVmcmVzaCwgbnVsbCwgdHJ1ZSlcblxuICAgICAgLy8gUmVmcmVzaCB1cGRhdGVzIGFsbCBhdHRyaWJ1dGUgc3RhdGUgY2hhbmdlc1xuICAgICAgdmFyIElOU1RBTkNJTkdcbiAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICAgIElOU1RBTkNJTkcgPSBlbnYubGluayhleHRJbnN0YW5jaW5nKVxuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdmVydGV4IGFycmF5IGJpbmRpbmdzXG4gICAgICBpZiAoZXh0ZW5zaW9ucy5vZXNfdmVydGV4X2FycmF5X29iamVjdCkge1xuICAgICAgICByZWZyZXNoKGVudi5saW5rKGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3QpLCAnLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTsnKVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdHMubWF4QXR0cmlidXRlczsgKytpKSB7XG4gICAgICAgIHZhciBCSU5ESU5HID0gcmVmcmVzaC5kZWYoc2hhcmVkLmF0dHJpYnV0ZXMsICdbJywgaSwgJ10nKVxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKEJJTkRJTkcsICcuYnVmZmVyJylcbiAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgIEdMLCAnLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcuYmluZEJ1ZmZlcignLFxuICAgICAgICAgIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5idWZmZXIuYnVmZmVyKTsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYlBvaW50ZXIoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplLCcsXG4gICAgICAgICAgQklORElORywgJy50eXBlLCcsXG4gICAgICAgICAgQklORElORywgJy5ub3JtYWxpemVkLCcsXG4gICAgICAgICAgQklORElORywgJy5zdHJpZGUsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLm9mZnNldCk7J1xuICAgICAgICApLmVsc2UoXG4gICAgICAgICAgR0wsICcuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliNGYoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy54LCcsXG4gICAgICAgICAgQklORElORywgJy55LCcsXG4gICAgICAgICAgQklORElORywgJy56LCcsXG4gICAgICAgICAgQklORElORywgJy53KTsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuYnVmZmVyPW51bGw7JylcbiAgICAgICAgcmVmcmVzaChpZnRlKVxuICAgICAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgICAgIHJlZnJlc2goXG4gICAgICAgICAgICBJTlNUQU5DSU5HLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLFxuICAgICAgICAgICAgaSwgJywnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWZyZXNoKFxuICAgICAgICBlbnYuc2hhcmVkLnZhbywgJy5jdXJyZW50VkFPPW51bGw7JyxcbiAgICAgICAgZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcblxuICAgICAgT2JqZWN0LmtleXMoR0xfRkxBR1MpLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdmFyIGNhcCA9IEdMX0ZMQUdTW2ZsYWddXG4gICAgICAgIHZhciBORVhUID0gY29tbW9uLmRlZihORVhUX1NUQVRFLCAnLicsIGZsYWcpXG4gICAgICAgIHZhciBibG9jayA9IGVudi5ibG9jaygpXG4gICAgICAgIGJsb2NrKCdpZignLCBORVhULCAnKXsnLFxuICAgICAgICAgIEdMLCAnLmVuYWJsZSgnLCBjYXAsICcpfWVsc2V7JyxcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlKCcsIGNhcCwgJyl9JyxcbiAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIGZsYWcsICc9JywgTkVYVCwgJzsnKVxuICAgICAgICByZWZyZXNoKGJsb2NrKVxuICAgICAgICBwb2xsKFxuICAgICAgICAgICdpZignLCBORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBmbGFnLCAnKXsnLFxuICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICd9JylcbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IEdMX1ZBUklBQkxFU1tuYW1lXVxuICAgICAgICB2YXIgaW5pdCA9IGN1cnJlbnRTdGF0ZVtuYW1lXVxuICAgICAgICB2YXIgTkVYVCwgQ1VSUkVOVFxuICAgICAgICB2YXIgYmxvY2sgPSBlbnYuYmxvY2soKVxuICAgICAgICBibG9jayhHTCwgJy4nLCBmdW5jLCAnKCcpXG4gICAgICAgIGlmIChpc0FycmF5TGlrZShpbml0KSkge1xuICAgICAgICAgIHZhciBuID0gaW5pdC5sZW5ndGhcbiAgICAgICAgICBORVhUID0gZW52Lmdsb2JhbC5kZWYoTkVYVF9TVEFURSwgJy4nLCBuYW1lKVxuICAgICAgICAgIENVUlJFTlQgPSBlbnYuZ2xvYmFsLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBORVhUICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSksICcpOycsXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyBORVhUICsgJ1snICsgaSArICddOydcbiAgICAgICAgICAgIH0pLmpvaW4oJycpKVxuICAgICAgICAgIHBvbGwoXG4gICAgICAgICAgICAnaWYoJywgbG9vcChuLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gTkVYVCArICdbJyArIGkgKyAnXSE9PScgKyBDVVJSRU5UICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSkuam9pbignfHwnKSwgJyl7JyxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE5FWFQgPSBjb21tb24uZGVmKE5FWFRfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgICAgICBDVVJSRU5UID0gY29tbW9uLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBORVhULCAnKTsnLFxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBuYW1lLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgICBwb2xsKFxuICAgICAgICAgICAgJ2lmKCcsIE5FWFQsICchPT0nLCBDVVJSRU5ULCAnKXsnLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAnfScpXG4gICAgICAgIH1cbiAgICAgICAgcmVmcmVzaChibG9jaylcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBlbnYuY29tcGlsZSgpXG4gICAgfSkoKSxcbiAgICBjb21waWxlOiBjb21waWxlQ29tbWFuZFxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXRzICgpIHtcbiAgcmV0dXJuIHtcbiAgICB2YW9Db3VudDogMCxcbiAgICBidWZmZXJDb3VudDogMCxcbiAgICBlbGVtZW50c0NvdW50OiAwLFxuICAgIGZyYW1lYnVmZmVyQ291bnQ6IDAsXG4gICAgc2hhZGVyQ291bnQ6IDAsXG4gICAgdGV4dHVyZUNvdW50OiAwLFxuICAgIGN1YmVDb3VudDogMCxcbiAgICByZW5kZXJidWZmZXJDb3VudDogMCxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IDBcbiAgfVxufVxuXG52YXIgR0xfUVVFUllfUkVTVUxUX0VYVCA9IDB4ODg2NlxudmFyIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUID0gMHg4ODY3XG52YXIgR0xfVElNRV9FTEFQU0VEX0VYVCA9IDB4ODhCRlxuXG52YXIgY3JlYXRlVGltZXIgPSBmdW5jdGlvbiAoZ2wsIGV4dGVuc2lvbnMpIHtcbiAgaWYgKCFleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBRVUVSWSBQT09MIEJFR0lOXG4gIHZhciBxdWVyeVBvb2wgPSBbXVxuICBmdW5jdGlvbiBhbGxvY1F1ZXJ5ICgpIHtcbiAgICByZXR1cm4gcXVlcnlQb29sLnBvcCgpIHx8IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmNyZWF0ZVF1ZXJ5RVhUKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUXVlcnkgKHF1ZXJ5KSB7XG4gICAgcXVlcnlQb29sLnB1c2gocXVlcnkpXG4gIH1cbiAgLy8gUVVFUlkgUE9PTCBFTkRcblxuICB2YXIgcGVuZGluZ1F1ZXJpZXMgPSBbXVxuICBmdW5jdGlvbiBiZWdpblF1ZXJ5IChzdGF0cykge1xuICAgIHZhciBxdWVyeSA9IGFsbG9jUXVlcnkoKVxuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmJlZ2luUXVlcnlFWFQoR0xfVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpXG4gICAgcGVuZGluZ1F1ZXJpZXMucHVzaChxdWVyeSlcbiAgICBwdXNoU2NvcGVTdGF0cyhwZW5kaW5nUXVlcmllcy5sZW5ndGggLSAxLCBwZW5kaW5nUXVlcmllcy5sZW5ndGgsIHN0YXRzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUXVlcnkgKCkge1xuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmVuZFF1ZXJ5RVhUKEdMX1RJTUVfRUxBUFNFRF9FWFQpXG4gIH1cblxuICAvL1xuICAvLyBQZW5kaW5nIHN0YXRzIHBvb2wuXG4gIC8vXG4gIGZ1bmN0aW9uIFBlbmRpbmdTdGF0cyAoKSB7XG4gICAgdGhpcy5zdGFydFF1ZXJ5SW5kZXggPSAtMVxuICAgIHRoaXMuZW5kUXVlcnlJbmRleCA9IC0xXG4gICAgdGhpcy5zdW0gPSAwXG4gICAgdGhpcy5zdGF0cyA9IG51bGxcbiAgfVxuICB2YXIgcGVuZGluZ1N0YXRzUG9vbCA9IFtdXG4gIGZ1bmN0aW9uIGFsbG9jUGVuZGluZ1N0YXRzICgpIHtcbiAgICByZXR1cm4gcGVuZGluZ1N0YXRzUG9vbC5wb3AoKSB8fCBuZXcgUGVuZGluZ1N0YXRzKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUGVuZGluZ1N0YXRzIChwZW5kaW5nU3RhdHMpIHtcbiAgICBwZW5kaW5nU3RhdHNQb29sLnB1c2gocGVuZGluZ1N0YXRzKVxuICB9XG4gIC8vIFBlbmRpbmcgc3RhdHMgcG9vbCBlbmRcblxuICB2YXIgcGVuZGluZ1N0YXRzID0gW11cbiAgZnVuY3Rpb24gcHVzaFNjb3BlU3RhdHMgKHN0YXJ0LCBlbmQsIHN0YXRzKSB7XG4gICAgdmFyIHBzID0gYWxsb2NQZW5kaW5nU3RhdHMoKVxuICAgIHBzLnN0YXJ0UXVlcnlJbmRleCA9IHN0YXJ0XG4gICAgcHMuZW5kUXVlcnlJbmRleCA9IGVuZFxuICAgIHBzLnN1bSA9IDBcbiAgICBwcy5zdGF0cyA9IHN0YXRzXG4gICAgcGVuZGluZ1N0YXRzLnB1c2gocHMpXG4gIH1cblxuICAvLyB3ZSBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZyYW1lLFxuICAvLyBpbiBvcmRlciB0byB1cGRhdGUgZ3B1VGltZVxuICB2YXIgdGltZVN1bSA9IFtdXG4gIHZhciBxdWVyeVB0ciA9IFtdXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdmFyIHB0ciwgaVxuXG4gICAgdmFyIG4gPSBwZW5kaW5nUXVlcmllcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gUmVzZXJ2ZSBzcGFjZVxuICAgIHF1ZXJ5UHRyLmxlbmd0aCA9IE1hdGgubWF4KHF1ZXJ5UHRyLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bS5sZW5ndGggPSBNYXRoLm1heCh0aW1lU3VtLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bVswXSA9IDBcbiAgICBxdWVyeVB0clswXSA9IDBcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyB0aW1lciBxdWVyaWVzXG4gICAgdmFyIHF1ZXJ5VGltZSA9IDBcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdRdWVyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcXVlcnkgPSBwZW5kaW5nUXVlcmllc1tpXVxuICAgICAgaWYgKGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCkpIHtcbiAgICAgICAgcXVlcnlUaW1lICs9IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfRVhUKVxuICAgICAgICBmcmVlUXVlcnkocXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nUXVlcmllc1twdHIrK10gPSBxdWVyeVxuICAgICAgfVxuICAgICAgdGltZVN1bVtpICsgMV0gPSBxdWVyeVRpbWVcbiAgICAgIHF1ZXJ5UHRyW2kgKyAxXSA9IHB0clxuICAgIH1cbiAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSBwdHJcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyBzdGF0IHF1ZXJpZXNcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdTdGF0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN0YXRzID0gcGVuZGluZ1N0YXRzW2ldXG4gICAgICB2YXIgc3RhcnQgPSBzdGF0cy5zdGFydFF1ZXJ5SW5kZXhcbiAgICAgIHZhciBlbmQgPSBzdGF0cy5lbmRRdWVyeUluZGV4XG4gICAgICBzdGF0cy5zdW0gKz0gdGltZVN1bVtlbmRdIC0gdGltZVN1bVtzdGFydF1cbiAgICAgIHZhciBzdGFydFB0ciA9IHF1ZXJ5UHRyW3N0YXJ0XVxuICAgICAgdmFyIGVuZFB0ciA9IHF1ZXJ5UHRyW2VuZF1cbiAgICAgIGlmIChlbmRQdHIgPT09IHN0YXJ0UHRyKSB7XG4gICAgICAgIHN0YXRzLnN0YXRzLmdwdVRpbWUgKz0gc3RhdHMuc3VtIC8gMWU2XG4gICAgICAgIGZyZWVQZW5kaW5nU3RhdHMoc3RhdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0cy5zdGFydFF1ZXJ5SW5kZXggPSBzdGFydFB0clxuICAgICAgICBzdGF0cy5lbmRRdWVyeUluZGV4ID0gZW5kUHRyXG4gICAgICAgIHBlbmRpbmdTdGF0c1twdHIrK10gPSBzdGF0c1xuICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nU3RhdHMubGVuZ3RoID0gcHRyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luUXVlcnk6IGJlZ2luUXVlcnksXG4gICAgZW5kUXVlcnk6IGVuZFF1ZXJ5LFxuICAgIHB1c2hTY29wZVN0YXRzOiBwdXNoU2NvcGVTdGF0cyxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBnZXROdW1QZW5kaW5nUXVlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdRdWVyaWVzLmxlbmd0aFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXJ5UG9vbC5wdXNoLmFwcGx5KHF1ZXJ5UG9vbCwgcGVuZGluZ1F1ZXJpZXMpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5UG9vbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeS5kZWxldGVRdWVyeUVYVChxdWVyeVBvb2xbaV0pXG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSAwXG4gICAgICBxdWVyeVBvb2wubGVuZ3RoID0gMFxuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoID0gMFxuICAgICAgcXVlcnlQb29sLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cbn1cblxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQgPSAxNjM4NFxudmFyIEdMX0RFUFRIX0JVRkZFUl9CSVQgPSAyNTZcbnZhciBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgPSAxMDI0XG5cbnZhciBHTF9BUlJBWV9CVUZGRVIgPSAzNDk2MlxuXG52YXIgQ09OVEVYVF9MT1NUX0VWRU5UID0gJ3dlYmdsY29udGV4dGxvc3QnXG52YXIgQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCA9ICd3ZWJnbGNvbnRleHRyZXN0b3JlZCdcblxudmFyIERZTl9QUk9QID0gMVxudmFyIERZTl9DT05URVhUID0gMlxudmFyIERZTl9TVEFURSA9IDNcblxuZnVuY3Rpb24gZmluZCAoaGF5c3RhY2ssIG5lZWRsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiB3cmFwUkVHTCAoYXJncykge1xuICB2YXIgY29uZmlnID0gcGFyc2VBcmdzKGFyZ3MpXG4gIGlmICghY29uZmlnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBnbCA9IGNvbmZpZy5nbFxuICB2YXIgZ2xBdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKVxuICB2YXIgY29udGV4dExvc3QgPSBnbC5pc0NvbnRleHRMb3N0KClcblxuICB2YXIgZXh0ZW5zaW9uU3RhdGUgPSBjcmVhdGVFeHRlbnNpb25DYWNoZShnbCwgY29uZmlnKVxuICBpZiAoIWV4dGVuc2lvblN0YXRlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBzdHJpbmdTdG9yZSA9IGNyZWF0ZVN0cmluZ1N0b3JlKClcbiAgdmFyIHN0YXRzJCQxID0gc3RhdHMoKVxuICB2YXIgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvblN0YXRlLmV4dGVuc2lvbnNcbiAgdmFyIHRpbWVyID0gY3JlYXRlVGltZXIoZ2wsIGV4dGVuc2lvbnMpXG5cbiAgdmFyIFNUQVJUX1RJTUUgPSBjbG9jaygpXG4gIHZhciBXSURUSCA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aFxuICB2YXIgSEVJR0hUID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuXG4gIHZhciBjb250ZXh0U3RhdGUgPSB7XG4gICAgdGljazogMCxcbiAgICB0aW1lOiAwLFxuICAgIHZpZXdwb3J0V2lkdGg6IFdJRFRILFxuICAgIHZpZXdwb3J0SGVpZ2h0OiBIRUlHSFQsXG4gICAgZnJhbWVidWZmZXJXaWR0aDogV0lEVEgsXG4gICAgZnJhbWVidWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBkcmF3aW5nQnVmZmVyV2lkdGg6IFdJRFRILFxuICAgIGRyYXdpbmdCdWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpb1xuICB9XG4gIHZhciB1bmlmb3JtU3RhdGUgPSB7fVxuICB2YXIgZHJhd1N0YXRlID0ge1xuICAgIGVsZW1lbnRzOiBudWxsLFxuICAgIHByaW1pdGl2ZTogNCwgLy8gR0xfVFJJQU5HTEVTXG4gICAgY291bnQ6IC0xLFxuICAgIG9mZnNldDogMCxcbiAgICBpbnN0YW5jZXM6IC0xXG4gIH1cblxuICB2YXIgbGltaXRzID0gd3JhcExpbWl0cyhnbCwgZXh0ZW5zaW9ucylcbiAgdmFyIGJ1ZmZlclN0YXRlID0gd3JhcEJ1ZmZlclN0YXRlKFxuICAgIGdsLFxuICAgIHN0YXRzJCQxLFxuICAgIGNvbmZpZyxcbiAgICBkZXN0cm95QnVmZmVyKVxuICB2YXIgYXR0cmlidXRlU3RhdGUgPSB3cmFwQXR0cmlidXRlU3RhdGUoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgc3RhdHMkJDEsXG4gICAgYnVmZmVyU3RhdGUpXG4gIGZ1bmN0aW9uIGRlc3Ryb3lCdWZmZXIgKGJ1ZmZlcikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVTdGF0ZS5kZXN0cm95QnVmZmVyKGJ1ZmZlcilcbiAgfVxuICB2YXIgZWxlbWVudFN0YXRlID0gd3JhcEVsZW1lbnRzU3RhdGUoZ2wsIGV4dGVuc2lvbnMsIGJ1ZmZlclN0YXRlLCBzdGF0cyQkMSlcbiAgdmFyIHNoYWRlclN0YXRlID0gd3JhcFNoYWRlclN0YXRlKGdsLCBzdHJpbmdTdG9yZSwgc3RhdHMkJDEsIGNvbmZpZylcbiAgdmFyIHRleHR1cmVTdGF0ZSA9IGNyZWF0ZVRleHR1cmVTZXQoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgZnVuY3Rpb24gKCkgeyBjb3JlLnByb2NzLnBvbGwoKSB9LFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBzdGF0cyQkMSxcbiAgICBjb25maWcpXG4gIHZhciByZW5kZXJidWZmZXJTdGF0ZSA9IHdyYXBSZW5kZXJidWZmZXJzKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzJCQxLCBjb25maWcpXG4gIHZhciBmcmFtZWJ1ZmZlclN0YXRlID0gd3JhcEZCT1N0YXRlKFxuICAgIGdsLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgbGltaXRzLFxuICAgIHRleHR1cmVTdGF0ZSxcbiAgICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgICBzdGF0cyQkMSlcbiAgdmFyIGNvcmUgPSByZWdsQ29yZShcbiAgICBnbCxcbiAgICBzdHJpbmdTdG9yZSxcbiAgICBleHRlbnNpb25zLFxuICAgIGxpbWl0cyxcbiAgICBidWZmZXJTdGF0ZSxcbiAgICBlbGVtZW50U3RhdGUsXG4gICAgdGV4dHVyZVN0YXRlLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgdW5pZm9ybVN0YXRlLFxuICAgIGF0dHJpYnV0ZVN0YXRlLFxuICAgIHNoYWRlclN0YXRlLFxuICAgIGRyYXdTdGF0ZSxcbiAgICBjb250ZXh0U3RhdGUsXG4gICAgdGltZXIsXG4gICAgY29uZmlnKVxuICB2YXIgcmVhZFBpeGVscyA9IHdyYXBSZWFkUGl4ZWxzKFxuICAgIGdsLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgY29yZS5wcm9jcy5wb2xsLFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBnbEF0dHJpYnV0ZXMsIGV4dGVuc2lvbnMsIGxpbWl0cylcblxuICB2YXIgbmV4dFN0YXRlID0gY29yZS5uZXh0XG4gIHZhciBjYW52YXMgPSBnbC5jYW52YXNcblxuICB2YXIgcmFmQ2FsbGJhY2tzID0gW11cbiAgdmFyIGxvc3NDYWxsYmFja3MgPSBbXVxuICB2YXIgcmVzdG9yZUNhbGxiYWNrcyA9IFtdXG4gIHZhciBkZXN0cm95Q2FsbGJhY2tzID0gW2NvbmZpZy5vbkRlc3Ryb3ldXG5cbiAgdmFyIGFjdGl2ZVJBRiA9IG51bGxcbiAgZnVuY3Rpb24gaGFuZGxlUkFGICgpIHtcbiAgICBpZiAocmFmQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzY2hlZHVsZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRilcblxuICAgIC8vIHBvbGwgZm9yIGNoYW5nZXNcbiAgICBwb2xsKClcblxuICAgIC8vIGZpcmUgYSBjYWxsYmFjayBmb3IgYWxsIHBlbmRpbmcgcmFmc1xuICAgIGZvciAodmFyIGkgPSByYWZDYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjYiA9IHJhZkNhbGxiYWNrc1tpXVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKGNvbnRleHRTdGF0ZSwgbnVsbCwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmbHVzaCBhbGwgcGVuZGluZyB3ZWJnbCBjYWxsc1xuICAgIGdsLmZsdXNoKClcblxuICAgIC8vIHBvbGwgR1BVIHRpbWVycyAqYWZ0ZXIqIGdsLmZsdXNoIHNvIHdlIGRvbid0IGRlbGF5IGNvbW1hbmQgZGlzcGF0Y2hcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRSQUYgKCkge1xuICAgIGlmICghYWN0aXZlUkFGICYmIHJhZkNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBhY3RpdmVSQUYgPSByYWYubmV4dChoYW5kbGVSQUYpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFJBRiAoKSB7XG4gICAgaWYgKGFjdGl2ZVJBRikge1xuICAgICAgcmFmLmNhbmNlbChoYW5kbGVSQUYpXG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gc2V0IGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSB0cnVlXG5cbiAgICAvLyBwYXVzZSByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZVxuICAgIHN0b3BSQUYoKVxuXG4gICAgLy8gbG9zZSBjb250ZXh0XG4gICAgbG9zc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0UmVzdG9yZWQgKGV2ZW50KSB7XG4gICAgLy8gY2xlYXIgZXJyb3IgY29kZVxuICAgIGdsLmdldEVycm9yKClcblxuICAgIC8vIGNsZWFyIGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSBmYWxzZVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGV4dGVuc2lvblN0YXRlLnJlc3RvcmUoKVxuICAgIHNoYWRlclN0YXRlLnJlc3RvcmUoKVxuICAgIGJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIHRleHR1cmVTdGF0ZS5yZXN0b3JlKClcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5yZXN0b3JlKClcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIGF0dHJpYnV0ZVN0YXRlLnJlc3RvcmUoKVxuICAgIGlmICh0aW1lcikge1xuICAgICAgdGltZXIucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG5cbiAgICAvLyByZXN0YXJ0IFJBRlxuICAgIHN0YXJ0UkFGKClcblxuICAgIC8vIHJlc3RvcmUgY29udGV4dFxuICAgIHJlc3RvcmVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNhbnZhcykge1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MsIGZhbHNlKVxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICByYWZDYWxsYmFja3MubGVuZ3RoID0gMFxuICAgIHN0b3BSQUYoKVxuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OVEVYVF9MT1NUX0VWRU5ULCBoYW5kbGVDb250ZXh0TG9zcylcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZClcbiAgICB9XG5cbiAgICBzaGFkZXJTdGF0ZS5jbGVhcigpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgcmVuZGVyYnVmZmVyU3RhdGUuY2xlYXIoKVxuICAgIHRleHR1cmVTdGF0ZS5jbGVhcigpXG4gICAgZWxlbWVudFN0YXRlLmNsZWFyKClcbiAgICBidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgYXR0cmlidXRlU3RhdGUuY2xlYXIoKVxuXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci5jbGVhcigpXG4gICAgfVxuXG4gICAgZGVzdHJveUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlUHJvY2VkdXJlIChvcHRpb25zKSB7XG4gICAgY2hlY2skMSghIW9wdGlvbnMsICdpbnZhbGlkIGFyZ3MgdG8gcmVnbCh7Li4ufSknKVxuICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJncyB0byByZWdsKHsuLi59KScpXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuTmVzdGVkT3B0aW9ucyAob3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IGV4dGVuZCh7fSwgb3B0aW9ucylcbiAgICAgIGRlbGV0ZSByZXN1bHQudW5pZm9ybXNcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXR0cmlidXRlc1xuICAgICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0XG4gICAgICBkZWxldGUgcmVzdWx0LnZhb1xuXG4gICAgICBpZiAoJ3N0ZW5jaWwnIGluIHJlc3VsdCAmJiByZXN1bHQuc3RlbmNpbC5vcCkge1xuICAgICAgICByZXN1bHQuc3RlbmNpbC5vcEJhY2sgPSByZXN1bHQuc3RlbmNpbC5vcEZyb250ID0gcmVzdWx0LnN0ZW5jaWwub3BcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zdGVuY2lsLm9wXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlc3VsdCkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHJlc3VsdFtuYW1lXVxuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbbmFtZV1cbiAgICAgICAgICBPYmplY3Qua2V5cyhjaGlsZCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWUgKyAnLicgKyBwcm9wXSA9IGNoaWxkW3Byb3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVyZ2UoJ2JsZW5kJylcbiAgICAgIG1lcmdlKCdkZXB0aCcpXG4gICAgICBtZXJnZSgnY3VsbCcpXG4gICAgICBtZXJnZSgnc3RlbmNpbCcpXG4gICAgICBtZXJnZSgncG9seWdvbk9mZnNldCcpXG4gICAgICBtZXJnZSgnc2Npc3NvcicpXG4gICAgICBtZXJnZSgnc2FtcGxlJylcblxuICAgICAgaWYgKCd2YW8nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LnZhbyA9IG9wdGlvbnMudmFvXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXBhcmF0ZUR5bmFtaWMgKG9iamVjdCwgdXNlQXJyYXlzKSB7XG4gICAgICB2YXIgc3RhdGljSXRlbXMgPSB7fVxuICAgICAgdmFyIGR5bmFtaWNJdGVtcyA9IHt9XG4gICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rbb3B0aW9uXVxuICAgICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XG4gICAgICAgICAgZHluYW1pY0l0ZW1zW29wdGlvbl0gPSBkeW5hbWljLnVuYm94KHZhbHVlLCBvcHRpb24pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodXNlQXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICBkeW5hbWljSXRlbXNbb3B0aW9uXSA9IGR5bmFtaWMudW5ib3godmFsdWUsIG9wdGlvbilcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpY0l0ZW1zW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGR5bmFtaWNJdGVtcyxcbiAgICAgICAgc3RhdGljOiBzdGF0aWNJdGVtc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyZWF0IGNvbnRleHQgdmFyaWFibGVzIHNlcGFyYXRlIGZyb20gb3RoZXIgZHluYW1pYyB2YXJpYWJsZXNcbiAgICB2YXIgY29udGV4dCA9IHNlcGFyYXRlRHluYW1pYyhvcHRpb25zLmNvbnRleHQgfHwge30sIHRydWUpXG4gICAgdmFyIHVuaWZvcm1zID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMudW5pZm9ybXMgfHwge30sIHRydWUpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9LCBmYWxzZSlcbiAgICB2YXIgb3B0cyA9IHNlcGFyYXRlRHluYW1pYyhmbGF0dGVuTmVzdGVkT3B0aW9ucyhvcHRpb25zKSwgZmFsc2UpXG5cbiAgICB2YXIgc3RhdHMkJDEgPSB7XG4gICAgICBncHVUaW1lOiAwLjAsXG4gICAgICBjcHVUaW1lOiAwLjAsXG4gICAgICBjb3VudDogMFxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGNvcmUuY29tcGlsZShvcHRzLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgc3RhdHMkJDEpXG5cbiAgICB2YXIgZHJhdyA9IGNvbXBpbGVkLmRyYXdcbiAgICB2YXIgYmF0Y2ggPSBjb21waWxlZC5iYXRjaFxuICAgIHZhciBzY29wZSA9IGNvbXBpbGVkLnNjb3BlXG5cbiAgICAvLyBGSVhNRTogd2Ugc2hvdWxkIG1vZGlmeSBjb2RlIGdlbmVyYXRpb24gZm9yIGJhdGNoIGNvbW1hbmRzIHNvIHRoaXNcbiAgICAvLyBpc24ndCBuZWNlc3NhcnlcbiAgICB2YXIgRU1QVFlfQVJSQVkgPSBbXVxuICAgIGZ1bmN0aW9uIHJlc2VydmUgKGNvdW50KSB7XG4gICAgICB3aGlsZSAoRU1QVFlfQVJSQVkubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgRU1QVFlfQVJSQVkucHVzaChudWxsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUkVHTENvbW1hbmQgKGFyZ3MsIGJvZHkpIHtcbiAgICAgIHZhciBpXG4gICAgICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBhcmdzLCAwKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3M7ICsraSkge1xuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBib2R5LCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNjb3BlLmNhbGwodGhpcywgYXJnc1tpXSwgYm9keSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmNhbGwodGhpcywgYXJncywgYm9keSwgMClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGFyZ3MgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgcmVzZXJ2ZShhcmdzIHwgMCksIGFyZ3MgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgYXJncywgYXJncy5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkcmF3LmNhbGwodGhpcywgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kKFJFR0xDb21tYW5kLCB7XG4gICAgICBzdGF0czogc3RhdHMkJDEsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBpbGVkLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2V0RkJPID0gZnJhbWVidWZmZXJTdGF0ZS5zZXRGQk8gPSBjb21waWxlUHJvY2VkdXJlKHtcbiAgICBmcmFtZWJ1ZmZlcjogZHluYW1pYy5kZWZpbmUuY2FsbChudWxsLCBEWU5fUFJPUCwgJ2ZyYW1lYnVmZmVyJylcbiAgfSlcblxuICBmdW5jdGlvbiBjbGVhckltcGwgKF8sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xlYXJGbGFncyA9IDBcbiAgICBjb3JlLnByb2NzLnBvbGwoKVxuXG4gICAgdmFyIGMgPSBvcHRpb25zLmNvbG9yXG4gICAgaWYgKGMpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoK2NbMF0gfHwgMCwgK2NbMV0gfHwgMCwgK2NbMl0gfHwgMCwgK2NbM10gfHwgMClcbiAgICAgIGNsZWFyRmxhZ3MgfD0gR0xfQ09MT1JfQlVGRkVSX0JJVFxuICAgIH1cbiAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICBnbC5jbGVhckRlcHRoKCtvcHRpb25zLmRlcHRoKVxuICAgICAgY2xlYXJGbGFncyB8PSBHTF9ERVBUSF9CVUZGRVJfQklUXG4gICAgfVxuICAgIGlmICgnc3RlbmNpbCcgaW4gb3B0aW9ucykge1xuICAgICAgZ2wuY2xlYXJTdGVuY2lsKG9wdGlvbnMuc3RlbmNpbCB8IDApXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX1NURU5DSUxfQlVGRkVSX0JJVFxuICAgIH1cblxuICAgIGNoZWNrJDEoISFjbGVhckZsYWdzLCAnY2FsbGVkIHJlZ2wuY2xlYXIgd2l0aCBubyBidWZmZXIgc3BlY2lmaWVkJylcbiAgICBnbC5jbGVhcihjbGVhckZsYWdzKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIgKG9wdGlvbnMpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG4gICAgICAncmVnbC5jbGVhcigpIHRha2VzIGFuIG9iamVjdCBhcyBpbnB1dCcpXG4gICAgaWYgKCdmcmFtZWJ1ZmZlcicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuZnJhbWVidWZmZXIgJiZcbiAgICAgICAgICBvcHRpb25zLmZyYW1lYnVmZmVyX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXJDdWJlJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgIHNldEZCTyhleHRlbmQoe1xuICAgICAgICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXIuZmFjZXNbaV1cbiAgICAgICAgICB9LCBvcHRpb25zKSwgY2xlYXJJbXBsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRGQk8ob3B0aW9ucywgY2xlYXJJbXBsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhckltcGwobnVsbCwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcmFtZSAoY2IpIHtcbiAgICBjaGVjayQxLnR5cGUoY2IsICdmdW5jdGlvbicsICdyZWdsLmZyYW1lKCkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICByYWZDYWxsYmFja3MucHVzaChjYilcblxuICAgIGZ1bmN0aW9uIGNhbmNlbCAoKSB7XG4gICAgICAvLyBGSVhNRTogIHNob3VsZCB3ZSBjaGVjayBzb21ldGhpbmcgb3RoZXIgdGhhbiBlcXVhbHMgY2IgaGVyZT9cbiAgICAgIC8vIHdoYXQgaWYgYSB1c2VyIGNhbGxzIGZyYW1lIHR3aWNlIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suLi5cbiAgICAgIC8vXG4gICAgICB2YXIgaSA9IGZpbmQocmFmQ2FsbGJhY2tzLCBjYilcbiAgICAgIGNoZWNrJDEoaSA+PSAwLCAnY2Fubm90IGNhbmNlbCBhIGZyYW1lIHR3aWNlJylcbiAgICAgIGZ1bmN0aW9uIHBlbmRpbmdDYW5jZWwgKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kKHJhZkNhbGxiYWNrcywgcGVuZGluZ0NhbmNlbClcbiAgICAgICAgcmFmQ2FsbGJhY2tzW2luZGV4XSA9IHJhZkNhbGxiYWNrc1tyYWZDYWxsYmFja3MubGVuZ3RoIC0gMV1cbiAgICAgICAgcmFmQ2FsbGJhY2tzLmxlbmd0aCAtPSAxXG4gICAgICAgIGlmIChyYWZDYWxsYmFja3MubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBzdG9wUkFGKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFmQ2FsbGJhY2tzW2ldID0gcGVuZGluZ0NhbmNlbFxuICAgIH1cblxuICAgIHN0YXJ0UkFGKClcblxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGNhbmNlbFxuICAgIH1cbiAgfVxuXG4gIC8vIHBvbGwgdmlld3BvcnRcbiAgZnVuY3Rpb24gcG9sbFZpZXdwb3J0ICgpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBuZXh0U3RhdGUudmlld3BvcnRcbiAgICB2YXIgc2Npc3NvckJveCA9IG5leHRTdGF0ZS5zY2lzc29yX2JveFxuICAgIHZpZXdwb3J0WzBdID0gdmlld3BvcnRbMV0gPSBzY2lzc29yQm94WzBdID0gc2Npc3NvckJveFsxXSA9IDBcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZnJhbWVidWZmZXJXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZHJhd2luZ0J1ZmZlcldpZHRoID1cbiAgICAgIHZpZXdwb3J0WzJdID1cbiAgICAgIHNjaXNzb3JCb3hbMl0gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGhcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRIZWlnaHQgPVxuICAgICAgY29udGV4dFN0YXRlLmZyYW1lYnVmZmVySGVpZ2h0ID1cbiAgICAgIGNvbnRleHRTdGF0ZS5kcmF3aW5nQnVmZmVySGVpZ2h0ID1cbiAgICAgIHZpZXdwb3J0WzNdID1cbiAgICAgIHNjaXNzb3JCb3hbM10gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0XG4gIH1cblxuICBmdW5jdGlvbiBwb2xsICgpIHtcbiAgICBjb250ZXh0U3RhdGUudGljayArPSAxXG4gICAgY29udGV4dFN0YXRlLnRpbWUgPSBub3coKVxuICAgIHBvbGxWaWV3cG9ydCgpXG4gICAgY29yZS5wcm9jcy5wb2xsKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgIHRleHR1cmVTdGF0ZS5yZWZyZXNoKClcbiAgICBwb2xsVmlld3BvcnQoKVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci51cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgcmV0dXJuIChjbG9jaygpIC0gU1RBUlRfVElNRSkgLyAxMDAwLjBcbiAgfVxuXG4gIHJlZnJlc2goKVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyIChldmVudCwgY2FsbGJhY2spIHtcbiAgICBjaGVjayQxLnR5cGUoY2FsbGJhY2ssICdmdW5jdGlvbicsICdsaXN0ZW5lciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuXG4gICAgdmFyIGNhbGxiYWNrc1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgcmV0dXJuIGZyYW1lKGNhbGxiYWNrKVxuICAgICAgY2FzZSAnbG9zdCc6XG4gICAgICAgIGNhbGxiYWNrcyA9IGxvc3NDYWxsYmFja3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Jlc3RvcmUnOlxuICAgICAgICBjYWxsYmFja3MgPSByZXN0b3JlQ2FsbGJhY2tzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgY2FsbGJhY2tzID0gZGVzdHJveUNhbGxiYWNrc1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBldmVudCwgbXVzdCBiZSBvbmUgb2YgZnJhbWUsbG9zdCxyZXN0b3JlLGRlc3Ryb3knKVxuICAgIH1cblxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2ldID0gY2FsbGJhY2tzW2NhbGxiYWNrcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgY2FsbGJhY2tzLnBvcCgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcmVnbCA9IGV4dGVuZChjb21waWxlUHJvY2VkdXJlLCB7XG4gICAgLy8gQ2xlYXIgY3VycmVudCBGQk9cbiAgICBjbGVhcjogY2xlYXIsXG5cbiAgICAvLyBTaG9ydCBjdXRzIGZvciBkeW5hbWljIHZhcmlhYmxlc1xuICAgIHByb3A6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1BST1ApLFxuICAgIGNvbnRleHQ6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX0NPTlRFWFQpLFxuICAgIHRoaXM6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1NUQVRFKSxcblxuICAgIC8vIGV4ZWN1dGVzIGFuIGVtcHR5IGRyYXcgY29tbWFuZFxuICAgIGRyYXc6IGNvbXBpbGVQcm9jZWR1cmUoe30pLFxuXG4gICAgLy8gUmVzb3VyY2VzXG4gICAgYnVmZmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGJ1ZmZlclN0YXRlLmNyZWF0ZShvcHRpb25zLCBHTF9BUlJBWV9CVUZGRVIsIGZhbHNlLCBmYWxzZSlcbiAgICB9LFxuICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRTdGF0ZS5jcmVhdGUob3B0aW9ucywgZmFsc2UpXG4gICAgfSxcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQsXG4gICAgY3ViZTogdGV4dHVyZVN0YXRlLmNyZWF0ZUN1YmUsXG4gICAgcmVuZGVyYnVmZmVyOiByZW5kZXJidWZmZXJTdGF0ZS5jcmVhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUuY3JlYXRlLFxuICAgIGZyYW1lYnVmZmVyQ3ViZTogZnJhbWVidWZmZXJTdGF0ZS5jcmVhdGVDdWJlLFxuICAgIHZhbzogYXR0cmlidXRlU3RhdGUuY3JlYXRlVkFPLFxuXG4gICAgLy8gRXhwb3NlIGNvbnRleHQgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXM6IGdsQXR0cmlidXRlcyxcblxuICAgIC8vIEZyYW1lIHJlbmRlcmluZ1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBvbjogYWRkTGlzdGVuZXIsXG5cbiAgICAvLyBTeXN0ZW0gbGltaXRzXG4gICAgbGltaXRzOiBsaW1pdHMsXG4gICAgaGFzRXh0ZW5zaW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YobmFtZS50b0xvd2VyQ2FzZSgpKSA+PSAwXG4gICAgfSxcblxuICAgIC8vIFJlYWQgcGl4ZWxzXG4gICAgcmVhZDogcmVhZFBpeGVscyxcblxuICAgIC8vIERlc3Ryb3kgcmVnbCBhbmQgYWxsIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAgZGVzdHJveTogZGVzdHJveSxcblxuICAgIC8vIERpcmVjdCBHTCBzdGF0ZSBtYW5pcHVsYXRpb25cbiAgICBfZ2w6IGdsLFxuICAgIF9yZWZyZXNoOiByZWZyZXNoLFxuXG4gICAgcG9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbCgpXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgdGltZXIudXBkYXRlKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ3VycmVudCB0aW1lXG4gICAgbm93OiBub3csXG5cbiAgICAvLyByZWdsIFN0YXRpc3RpY3MgSW5mb3JtYXRpb25cbiAgICBzdGF0czogc3RhdHMkJDFcbiAgfSlcblxuICBjb25maWcub25Eb25lKG51bGwsIHJlZ2wpXG5cbiAgcmV0dXJuIHJlZ2xcbn1cblxucmV0dXJuIHdyYXBSRUdMO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnbC5qcy5tYXBcbiIsIm1vZHVsZS5leHBvcnRzID1cbiAgZ2xvYmFsLnBlcmZvcm1hbmNlICYmXG4gIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gIH0gOiBEYXRlLm5vdyB8fCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZVxuICB9XG4iLCJleHBvcnQgY29uc3QgUkVWSVNJT04gPSAnMTU2JztcblxuZXhwb3J0IGNvbnN0IE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmV4cG9ydCBjb25zdCBUT1VDSCA9IHsgUk9UQVRFOiAwLCBQQU46IDEsIERPTExZX1BBTjogMiwgRE9MTFlfUk9UQVRFOiAzIH07XG5leHBvcnQgY29uc3QgQ3VsbEZhY2VOb25lID0gMDtcbmV4cG9ydCBjb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnQgPSAyO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnRCYWNrID0gMztcbmV4cG9ydCBjb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5leHBvcnQgY29uc3QgUENGU2hhZG93TWFwID0gMTtcbmV4cG9ydCBjb25zdCBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcbmV4cG9ydCBjb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuZXhwb3J0IGNvbnN0IEZyb250U2lkZSA9IDA7XG5leHBvcnQgY29uc3QgQmFja1NpZGUgPSAxO1xuZXhwb3J0IGNvbnN0IERvdWJsZVNpZGUgPSAyO1xuZXhwb3J0IGNvbnN0IFR3b1Bhc3NEb3VibGVTaWRlID0gMjsgLy8gcjE0OVxuZXhwb3J0IGNvbnN0IE5vQmxlbmRpbmcgPSAwO1xuZXhwb3J0IGNvbnN0IE5vcm1hbEJsZW5kaW5nID0gMTtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbmV4cG9ydCBjb25zdCBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbmV4cG9ydCBjb25zdCBNdWx0aXBseUJsZW5kaW5nID0gNDtcbmV4cG9ydCBjb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5leHBvcnQgY29uc3QgQWRkRXF1YXRpb24gPSAxMDA7XG5leHBvcnQgY29uc3QgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbmV4cG9ydCBjb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbmV4cG9ydCBjb25zdCBNaW5FcXVhdGlvbiA9IDEwMztcbmV4cG9ydCBjb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcbmV4cG9ydCBjb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuZXhwb3J0IGNvbnN0IE9uZUZhY3RvciA9IDIwMTtcbmV4cG9ydCBjb25zdCBTcmNDb2xvckZhY3RvciA9IDIwMjtcbmV4cG9ydCBjb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhRmFjdG9yID0gMjA0O1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5leHBvcnQgY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5leHBvcnQgY29uc3QgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbmV4cG9ydCBjb25zdCBEc3RDb2xvckZhY3RvciA9IDIwODtcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5leHBvcnQgY29uc3QgTmV2ZXJEZXB0aCA9IDA7XG5leHBvcnQgY29uc3QgQWx3YXlzRGVwdGggPSAxO1xuZXhwb3J0IGNvbnN0IExlc3NEZXB0aCA9IDI7XG5leHBvcnQgY29uc3QgTGVzc0VxdWFsRGVwdGggPSAzO1xuZXhwb3J0IGNvbnN0IEVxdWFsRGVwdGggPSA0O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmV4cG9ydCBjb25zdCBHcmVhdGVyRGVwdGggPSA2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xuZXhwb3J0IGNvbnN0IE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmV4cG9ydCBjb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuZXhwb3J0IGNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XG5leHBvcnQgY29uc3QgTm9Ub25lTWFwcGluZyA9IDA7XG5leHBvcnQgY29uc3QgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xuZXhwb3J0IGNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuZXhwb3J0IGNvbnN0IENpbmVvblRvbmVNYXBwaW5nID0gMztcbmV4cG9ydCBjb25zdCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xuZXhwb3J0IGNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcblxuZXhwb3J0IGNvbnN0IFVWTWFwcGluZyA9IDMwMDtcbmV4cG9ydCBjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5leHBvcnQgY29uc3QgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuZXhwb3J0IGNvbnN0IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuZXhwb3J0IGNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmV4cG9ydCBjb25zdCBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcbmV4cG9ydCBjb25zdCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbmV4cG9ydCBjb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IExpbmVhckZpbHRlciA9IDEwMDY7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyID0gMTAwODtcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuZXhwb3J0IGNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcbmV4cG9ydCBjb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcbmV4cG9ydCBjb25zdCBJbnRUeXBlID0gMTAxMztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuZXhwb3J0IGNvbnN0IEZsb2F0VHlwZSA9IDEwMTU7XG5leHBvcnQgY29uc3QgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG5leHBvcnQgY29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XG5leHBvcnQgY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuZXhwb3J0IGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuZXhwb3J0IGNvbnN0IEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG5leHBvcnQgY29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuZXhwb3J0IGNvbnN0IERlcHRoRm9ybWF0ID0gMTAyNjtcbmV4cG9ydCBjb25zdCBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xuZXhwb3J0IGNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5leHBvcnQgY29uc3QgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XG5leHBvcnQgY29uc3QgUkdGb3JtYXQgPSAxMDMwO1xuZXhwb3J0IGNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5leHBvcnQgY29uc3QgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xuXG5leHBvcnQgY29uc3QgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NjtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAzMzc3OTtcbmV4cG9ydCBjb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuZXhwb3J0IGNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDI7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5leHBvcnQgY29uc3QgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5leHBvcnQgY29uc3QgUkdCX0VUQzJfRm9ybWF0ID0gMzc0OTI7XG5leHBvcnQgY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNHg0X0Zvcm1hdCA9IDM3ODA4O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ181eDRfRm9ybWF0ID0gMzc4MDk7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNng1X0Zvcm1hdCA9IDM3ODExO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ182eDZfRm9ybWF0ID0gMzc4MTI7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg2X0Zvcm1hdCA9IDM3ODE0O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDhfRm9ybWF0ID0gMzc4MTU7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gMzc4MTg7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSAzNzgyMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gMzc4MjE7XG5leHBvcnQgY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuZXhwb3J0IGNvbnN0IFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQgPSAzNjQ5NDtcbmV4cG9ydCBjb25zdCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQgPSAzNjQ5NTtcbmV4cG9ydCBjb25zdCBSRURfUkdUQzFfRm9ybWF0ID0gMzYyODM7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4NDtcbmV4cG9ydCBjb25zdCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ID0gMzYyODU7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NjtcbmV4cG9ydCBjb25zdCBMb29wT25jZSA9IDIyMDA7XG5leHBvcnQgY29uc3QgTG9vcFJlcGVhdCA9IDIyMDE7XG5leHBvcnQgY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5leHBvcnQgY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuZXhwb3J0IGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuZXhwb3J0IGNvbnN0IFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5leHBvcnQgY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5leHBvcnQgY29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSA9IDI1MDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIExpbmVhclNSR0JDb2xvclNwYWNlIG9yIE5vQ29sb3JTcGFjZSBpbiB0aHJlZS5qcyByMTUyKy4gKi9cbmV4cG9ydCBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIFNSR0JDb2xvclNwYWNlIGluIHRocmVlLmpzIHIxNTIrLiAqL1xuZXhwb3J0IGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5leHBvcnQgY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuZXhwb3J0IGNvbnN0IFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xuZXhwb3J0IGNvbnN0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5leHBvcnQgY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXG4vLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cbmV4cG9ydCBjb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcbmV4cG9ydCBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbmV4cG9ydCBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG5leHBvcnQgY29uc3QgRGlzcGxheVAzQ29sb3JTcGFjZSA9ICdkaXNwbGF5LXAzJztcbmV4cG9ydCBjb25zdCBMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlID0gJ2Rpc3BsYXktcDMtbGluZWFyJztcblxuZXhwb3J0IGNvbnN0IFplcm9TdGVuY2lsT3AgPSAwO1xuZXhwb3J0IGNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuZXhwb3J0IGNvbnN0IFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuZXhwb3J0IGNvbnN0IEluY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODI7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcbmV4cG9ydCBjb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU2O1xuZXhwb3J0IGNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cbmV4cG9ydCBjb25zdCBOZXZlclN0ZW5jaWxGdW5jID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcbmV4cG9ydCBjb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcbmV4cG9ydCBjb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuXG5leHBvcnQgY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NDb21wYXJlID0gNTEzO1xuZXhwb3J0IGNvbnN0IEVxdWFsQ29tcGFyZSA9IDUxNDtcbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJDb21wYXJlID0gNTE2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsQ29tcGFyZSA9IDUxNztcbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c0NvbXBhcmUgPSA1MTk7XG5cbmV4cG9ydCBjb25zdCBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcbmV4cG9ydCBjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5leHBvcnQgY29uc3QgU3RyZWFtRHJhd1VzYWdlID0gMzUwNDA7XG5leHBvcnQgY29uc3QgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5leHBvcnQgY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuZXhwb3J0IGNvbnN0IFN0cmVhbVJlYWRVc2FnZSA9IDM1MDQxO1xuZXhwb3J0IGNvbnN0IFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuZXhwb3J0IGNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmV4cG9ydCBjb25zdCBTdHJlYW1Db3B5VXNhZ2UgPSAzNTA0MjtcblxuZXhwb3J0IGNvbnN0IEdMU0wxID0gJzEwMCc7XG5leHBvcnQgY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuZXhwb3J0IGNvbnN0IF9TUkdCQUZvcm1hdCA9IDEwMzU7IC8vIGZhbGxiYWNrIGZvciBXZWJHTCAxXG5cbmV4cG9ydCBjb25zdCBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gPSAyMDAwO1xuZXhwb3J0IGNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IGRlbm9ybWFsaXplLCBub3JtYWxpemUgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UsIEZsb2F0VHlwZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBmcm9tSGFsZkZsb2F0LCB0b0hhbGZGbG9hdCB9IGZyb20gJy4uL2V4dHJhcy9EYXRhVXRpbHMuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5cbmNsYXNzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCA9IGZhbHNlICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblx0XHR0aGlzLmdwdVR5cGUgPSBGbG9hdFR5cGU7XG5cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdH1cblxuXHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9XG5cblx0c2V0VXNhZ2UoIHZhbHVlICkge1xuXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IHNvdXJjZS5ncHVUeXBlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGlmICggdGhpcy5pdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3RvcjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMi5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZKCBpLCBfdmVjdG9yMi54LCBfdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXg0KCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdC8vIE1hdGNoaW5nIEJ1ZmZlckF0dHJpYnV0ZSBjb25zdHJ1Y3RvciwgZG8gbm90IG5vcm1hbGl6ZSB0aGUgYXJyYXkuXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQgKSB7XG5cblx0XHRsZXQgdmFsdWUgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBkZW5vcm1hbGl6ZSggdmFsdWUsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgY29tcG9uZW50LCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRZKCBpbmRleCApIHtcblxuXHRcdGxldCB5ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gZGVub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB3O1xuXG5cdH1cblxuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWSggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaVyggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblx0XHRcdHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0YXJyYXk6IEFycmF5LmZyb20oIHRoaXMuYXJyYXkgKSxcblx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCB0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UgKSBkYXRhLnVzYWdlID0gdGhpcy51c2FnZTtcblx0XHRpZiAoIHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0gMSApIGRhdGEudXBkYXRlUmFuZ2UgPSB0aGlzLnVwZGF0ZVJhbmdlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbi8vXG5cbmNsYXNzIEludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHR0aGlzLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gZGVub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB4O1xuXG5cdH1cblxuXHRzZXRYKCBpbmRleCwgeCApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFkoIGluZGV4ICkge1xuXG5cdFx0bGV0IHkgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WiggaW5kZXggKSB7XG5cblx0XHRsZXQgeiA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBkZW5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHc7XG5cblx0fVxuXG5cdHNldFcoIGluZGV4LCB3ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHRvSGFsZkZsb2F0KCB6ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuY2xhc3MgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8vXG5cbmV4cG9ydCB7XG5cdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckF0dHJpYnV0ZVxufTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4vT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBhcnJheU5lZWRzVWludDMyIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX29iaiA9IC8qQF9fUFVSRV9fKi8gbmV3IE9iamVjdDNEKCk7XG5jb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9ib3hNb3JwaFRhcmdldHMgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0J1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX2lkICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0Z2V0SW5kZXgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblxuXHR9XG5cblx0c2V0SW5kZXgoIGluZGV4ICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kZXggKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEF0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9XG5cblx0c2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWxldGVBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aGFzQXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdICE9PSB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGFkZEdyb3VwKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggPSAwICkge1xuXG5cdFx0dGhpcy5ncm91cHMucHVzaCgge1xuXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNsZWFyR3JvdXBzKCkge1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR9XG5cblx0c2V0RHJhd1JhbmdlKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvc2l0aW9uLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0YW5nZW50ID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cblx0XHRpZiAoIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGFuZ2VudC50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR0YW5nZW50Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdF9tMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHRfbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRfb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9vYmoubWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VudGVyKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBfb2Zmc2V0ICkubmVnYXRlKCk7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggX29mZnNldC54LCBfb2Zmc2V0LnksIF9vZmZzZXQueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCBcIm1lc2guZnJ1c3R1bUN1bGxlZFwiIHRvIFwiZmFsc2VcIi4nLCB0aGlzICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0KFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWluLCBfYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gubWF4ICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5taW4gKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5tYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQoIG5ldyBWZWN0b3IzKCksIEluZmluaXR5ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRfYm94TW9ycGhUYXJnZXRzLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggX2JveC5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCBfYm94Lm1heCwgX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1pbiApO1xuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94LmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaiApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yLmFkZCggX29mZnNldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVUYW5nZW50cygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcblx0XHQvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuXHRcdGlmICggaW5kZXggPT09IG51bGwgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy51diA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXHRcdGNvbnN0IHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG5cblx0XHRjb25zdCBuVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdGlmICggdGhpcy5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNCAqIG5WZXJ0aWNlcyApLCA0ICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoICd0YW5nZW50JyApLmFycmF5O1xuXG5cdFx0Y29uc3QgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBuVmVydGljZXM7IGkgKysgKSB7XG5cblx0XHRcdHRhbjFbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkMgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRcdHNkaXIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dGRpciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cdFx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG5cdFx0XHR1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG5cdFx0XHR1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG5cdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cblx0XHRcdHZCLnN1YiggdkEgKTtcblx0XHRcdHZDLnN1YiggdkEgKTtcblxuXHRcdFx0dXZCLnN1YiggdXZBICk7XG5cdFx0XHR1dkMuc3ViKCB1dkEgKTtcblxuXHRcdFx0Y29uc3QgciA9IDEuMCAvICggdXZCLnggKiB1dkMueSAtIHV2Qy54ICogdXZCLnkgKTtcblxuXHRcdFx0Ly8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cblx0XHRcdGlmICggISBpc0Zpbml0ZSggciApICkgcmV0dXJuO1xuXG5cdFx0XHRzZGlyLmNvcHkoIHZCICkubXVsdGlwbHlTY2FsYXIoIHV2Qy55ICkuYWRkU2NhbGVkVmVjdG9yKCB2QywgLSB1dkIueSApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cdFx0XHR0ZGlyLmNvcHkoIHZDICkubXVsdGlwbHlTY2FsYXIoIHV2Qi54ICkuYWRkU2NhbGVkVmVjdG9yKCB2QiwgLSB1dkMueCApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYiBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRncm91cHMgPSBbIHtcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdFx0fSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoXG5cdFx0XHRcdFx0aW5kaWNlc1sgaiArIDAgXSxcblx0XHRcdFx0XHRpbmRpY2VzWyBqICsgMSBdLFxuXHRcdFx0XHRcdGluZGljZXNbIGogKyAyIF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSwgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksIG4yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdGNvbnN0IHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0Y29uc3QgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRzWyB2ICogNCBdID0gdG1wLng7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDIgXSA9IHRtcC56O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kaWNlc1sgaiArIDAgXSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGljZXNbIGogKyAxIF0gKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0aWYgKCBwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsZXQgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XG5cblx0XHRcdGlmICggbm9ybWFsQXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiAzICksIDMgKTtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFsQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpLCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBuQSA9IG5ldyBWZWN0b3IzKCksIG5CID0gbmV3IFZlY3RvcjMoKSwgbkMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdkEgPSBpbmRleC5nZXRYKCBpICsgMCApO1xuXHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCB2QyA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkEgKTtcblx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkMgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0bkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QSApO1xuXHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRuQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZDICk7XG5cblx0XHRcdFx0XHRuQS5hZGQoIGNiICk7XG5cdFx0XHRcdFx0bkIuYWRkKCBjYiApO1xuXHRcdFx0XHRcdG5DLmFkZCggY2IgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZBLCBuQS54LCBuQS55LCBuQS56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkIsIG5CLngsIG5CLnksIG5CLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QywgbkMueCwgbkMueSwgbkMueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAwICk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxICk7XG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAyICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAwLCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDEsIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMiwgY2IueCwgY2IueSwgY2IueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0bm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0bm9ybWFsaXplTm9ybWFscygpIHtcblxuXHRcdGNvbnN0IG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCBpICk7XG5cblx0XHRcdF92ZWN0b3Iubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvTm9uSW5kZXhlZCgpIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRcdFx0Y29uc3QgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGljZXMgKTtcblxuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2goIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG1vcnBoQXJyYXk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcblxuXHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0gYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRsZXQgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRtb3JwaEF0dHJpYnV0ZXNbIGtleSBdID0gYXJyYXk7XG5cblx0XHRcdFx0aGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNNb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcblx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdC8vIHJlc2V0XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcblxuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdC8vIG5hbWVcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0Ly8gaW5kZXhcblxuXHRcdGNvbnN0IGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdH1cblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgYm94XG5cblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyByYW5nZVxuXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdC8vIHVzZXIgZGF0YVxuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHNvdXJjZS51c2VyRGF0YTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH07XG4iLCIvKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH07XG4iLCJjbGFzcyBMYXllcnMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdHNldCggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xuXG5cdH1cblxuXHRlbmFibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHR9XG5cblx0ZW5hYmxlQWxsKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XG5cblx0fVxuXG5cdHRvZ2dsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRkaXNhYmxlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XG5cblx0fVxuXG5cdGRpc2FibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAwO1xuXG5cdH1cblxuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHRpc0VuYWJsZWQoIGNoYW5uZWwgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IExheWVycyB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcbmltcG9ydCB7IExheWVycyB9IGZyb20gJy4vTGF5ZXJzLmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxubGV0IF9vYmplY3QzRElkID0gMDtcblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ExID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NjYWxlID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xuXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnVwID0gT2JqZWN0M0QuREVGQVVMVF9VUC5jbG9uZSgpO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0Y29uc3Qgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdFx0cXVhdGVybmlvbi5fb25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdH0sXG5cdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cblx0XHRcdH0sXG5cdFx0XHRzY2FsZToge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdFx0fSxcblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdFx0fSxcblx0XHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fVxuXG5cdHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeUF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfekF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdGxvY2FsVG9Xb3JsZCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XG5cblx0fVxuXG5cdGxvb2tBdCggeCwgeSwgeiApIHtcblxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHRfdGFyZ2V0LmNvcHkoIHggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90YXJnZXQuc2V0KCB4LCB5LCB6ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ICkge1xuXG5cdFx0XHRfbTEubG9va0F0KCBfcG9zaXRpb24sIF90YXJnZXQsIHRoaXMudXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF90YXJnZXQsIF9wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0X20xLmV4dHJhY3RSb3RhdGlvbiggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRfcTEuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExLmludmVydCgpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFkZCggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX3JlbW92ZWRFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZUZyb21QYXJlbnQoKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRwYXJlbnQucmVtb3ZlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xlYXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIC4uLiB0aGlzLmNoaWxkcmVuICk7XG5cblx0fVxuXG5cdGF0dGFjaCggb2JqZWN0ICkge1xuXG5cdFx0Ly8gYWRkcyBvYmplY3QgYXMgYSBjaGlsZCBvZiB0aGlzLCB3aGlsZSBtYWludGFpbmluZyB0aGUgb2JqZWN0J3Mgd29ybGQgdHJhbnNmb3JtXG5cblx0XHQvLyBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHNjZW5lIGdyYXBocyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgbm9kZXMocylcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0XHRfbTEubXVsdGlwbHkoIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG5cdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5SWQoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlOYW1lKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRnZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXN1bHQucHVzaCggdGhpcyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZFJlc3VsdCA9IHRoaXMuY2hpbGRyZW5bIGkgXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBjaGlsZFJlc3VsdC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIGNoaWxkUmVzdWx0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGdldFdvcmxkUG9zaXRpb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHRnZXRXb3JsZFF1YXRlcm5pb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCB0YXJnZXQsIF9zY2FsZSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggZVsgOCBdLCBlWyA5IF0sIGVbIDEwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0cmF5Y2FzdCggLyogcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICovICkge31cblxuXHR0cmF2ZXJzZSggY2FsbGJhY2sgKSB7XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICkge1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xuXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGZvcmNlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjaGlsZC51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVXb3JsZE1hdHJpeCggdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4gKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggdXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50Lm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGNvbnN0IG91dHB1dCA9IHt9O1xuXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge30sXG5cdFx0XHRcdHNoYXBlczoge30sXG5cdFx0XHRcdHNrZWxldG9uczoge30sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IHt9LFxuXHRcdFx0XHRub2Rlczoge31cblx0XHRcdH07XG5cblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSApIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICkgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXHRcdG9iamVjdC51cCA9IHRoaXMudXAudG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRpZiAoIHRoaXMuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QudHlwZSA9ICdJbnN0YW5jZWRNZXNoJztcblx0XHRcdG9iamVjdC5jb3VudCA9IHRoaXMuY291bnQ7XG5cdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSB0aGlzLmluc3RhbmNlTWF0cml4LnRvSlNPTigpO1xuXHRcdFx0aWYgKCB0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSBvYmplY3QuaW5zdGFuY2VDb2xvciA9IHRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSAmJiB0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uICk7XG5cblx0XHRcdFx0b2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuYW5pbWF0aW9ucyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdGlmICggYW5pbWF0aW9ucy5sZW5ndGggPiAwICkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSBzb3VyY2Uucm90YXRpb24ub3JkZXI7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cblx0XHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG5cdFx0dGhpcy5hbmltYXRpb25zID0gc291cmNlLmFuaW1hdGlvbnMuc2xpY2UoKTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5PYmplY3QzRC5ERUZBVUxUX1VQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUgPSB0cnVlO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfV09STERfQVVUT19VUERBVEUgPSB0cnVlO1xuXG5leHBvcnQgeyBPYmplY3QzRCB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbi8vIEZhc3QgSGFsZiBGbG9hdCBDb252ZXJzaW9ucywgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuXG5jb25zdCBfdGFibGVzID0gLypAX19QVVJFX18qLyBfZ2VuZXJhdGVUYWJsZXMoKTtcblxuZnVuY3Rpb24gX2dlbmVyYXRlVGFibGVzKCkge1xuXG5cdC8vIGZsb2F0MzIgdG8gZmxvYXQxNiBoZWxwZXJzXG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCA0ICk7XG5cdGNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRjb25zdCB1aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXHRjb25zdCBzaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA1MTIgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyNTY7ICsrIGkgKSB7XG5cblx0XHRjb25zdCBlID0gaSAtIDEyNztcblxuXHRcdC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcblxuXHRcdGlmICggZSA8IC0gMjcgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwMDAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgLSAxNCApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDA0MDAgPj4gKCAtIGUgLSAxNCApO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggMHgwNDAwID4+ICggLSBlIC0gMTQgKSApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gLSBlIC0gMTtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gLSBlIC0gMTtcblxuXHRcdFx0Ly8gbm9ybWFsIG51bWJlclxuXG5cdFx0fSBlbHNlIGlmICggZSA8PSAxNSApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAoIGUgKyAxNSApIDw8IDEwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggKCBlICsgMTUgKSA8PCAxMCApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0XHQvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgMTI4ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XG5cblx0XHRcdC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcblxuXHRjb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCAyMDQ4ICk7XG5cdGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cdGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA2NCApO1xuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDEwMjQ7ICsrIGkgKSB7XG5cblx0XHRsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcblxuXHRcdC8vIG5vcm1hbGl6ZWRcblx0XHR3aGlsZSAoICggbSAmIDB4MDA4MDAwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0bSA8PD0gMTtcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG5cblx0XHR9XG5cblx0XHRtICY9IH4gMHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXHRcdGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuXHRcdG1hbnRpc3NhVGFibGVbIGkgXSA9IG0gfCBlO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDEwMjQ7IGkgPCAyMDQ4OyArKyBpICkge1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gMHgzODAwMDAwMCArICggKCBpIC0gMTAyNCApIDw8IDEzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDMxOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gaSA8PCAyMztcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgMzEgXSA9IDB4NDc4MDAwMDA7XG5cdGV4cG9uZW50VGFibGVbIDMyIF0gPSAweDgwMDAwMDAwO1xuXG5cdGZvciAoIGxldCBpID0gMzM7IGkgPCA2MzsgKysgaSApIHtcblxuXHRcdGV4cG9uZW50VGFibGVbIGkgXSA9IDB4ODAwMDAwMDAgKyAoICggaSAtIDMyICkgPDwgMjMgKTtcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgNjMgXSA9IDB4Yzc4MDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgNjQ7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGkgIT09IDMyICkge1xuXG5cdFx0XHRvZmZzZXRUYWJsZVsgaSBdID0gMTAyNDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRmbG9hdFZpZXc6IGZsb2F0Vmlldyxcblx0XHR1aW50MzJWaWV3OiB1aW50MzJWaWV3LFxuXHRcdGJhc2VUYWJsZTogYmFzZVRhYmxlLFxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG5cdFx0bWFudGlzc2FUYWJsZTogbWFudGlzc2FUYWJsZSxcblx0XHRleHBvbmVudFRhYmxlOiBleHBvbmVudFRhYmxlLFxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxuXHR9O1xuXG59XG5cbi8vIGZsb2F0MzIgdG8gZmxvYXQxNlxuXG5mdW5jdGlvbiB0b0hhbGZGbG9hdCggdmFsICkge1xuXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcblxuXHR2YWwgPSBjbGFtcCggdmFsLCAtIDY1NTA0LCA2NTUwNCApO1xuXG5cdF90YWJsZXMuZmxvYXRWaWV3WyAwIF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbIDAgXTtcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVsgZSBdICsgKCAoIGYgJiAweDAwN2ZmZmZmICkgPj4gX3RhYmxlcy5zaGlmdFRhYmxlWyBlIF0gKTtcblxufVxuXG4vLyBmbG9hdDE2IHRvIGZsb2F0MzJcblxuZnVuY3Rpb24gZnJvbUhhbGZGbG9hdCggdmFsICkge1xuXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XG5cdF90YWJsZXMudWludDMyVmlld1sgMCBdID0gX3RhYmxlcy5tYW50aXNzYVRhYmxlWyBfdGFibGVzLm9mZnNldFRhYmxlWyBtIF0gKyAoIHZhbCAmIDB4M2ZmICkgXSArIF90YWJsZXMuZXhwb25lbnRUYWJsZVsgbSBdO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbIDAgXTtcblxufVxuXG5jb25zdCBEYXRhVXRpbHMgPSB7XG5cdHRvSGFsZkZsb2F0OiB0b0hhbGZGbG9hdCxcblx0ZnJvbUhhbGZGbG9hdDogZnJvbUhhbGZGbG9hdCxcbn07XG5cbmV4cG9ydCB7XG5cdHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0LFxuXHREYXRhVXRpbHNcbn07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgQm94MyB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiA9IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICksIG1heCA9IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICkgKSB7XG5cblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0KCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3Rvci5mcm9tQXJyYXkoIGFycmF5LCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSA9IGZhbHNlICkge1xuXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2JveC5jb3B5KCBvYmplY3QuYm91bmRpbmdCb3ggKTtcblx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy51bmlvbiggX2JveCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIHByZWNpc2UgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkgKS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2JveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXHRcdFx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHRoaXMudW5pb24oIF9ib3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeU9iamVjdCggY2hpbGRyZW5bIGkgXSwgcHJlY2lzZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cblx0fVxuXG5cdGNvbnRhaW5zQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmXG5cdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblxuXHR9XG5cblx0Z2V0UGFyYW1ldGVyKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXG5cdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcblx0XHQpO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcblx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIF92ZWN0b3IgKTtcblxuXHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdHJldHVybiBfdmVjdG9yLmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0dGhpcy5nZXRDZW50ZXIoIF9jZW50ZXIgKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgX2NlbnRlciApO1xuXG5cdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0X3YwLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmEsIF9jZW50ZXIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgX2NlbnRlciApO1xuXHRcdF92Mi5zdWJWZWN0b3JzKCB0cmlhbmdsZS5jLCBfY2VudGVyICk7XG5cblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcblx0XHRfZjAuc3ViVmVjdG9ycyggX3YxLCBfdjAgKTtcblx0XHRfZjEuc3ViVmVjdG9ycyggX3YyLCBfdjEgKTtcblx0XHRfZjIuc3ViVmVjdG9ycyggX3YwLCBfdjIgKTtcblxuXHRcdC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXHRcdGxldCBheGVzID0gW1xuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcblx0XHRcdF9mMC56LCAwLCAtIF9mMC54LCBfZjEueiwgMCwgLSBfZjEueCwgX2YyLnosIDAsIC0gX2YyLngsXG5cdFx0XHQtIF9mMC55LCBfZjAueCwgMCwgLSBfZjEueSwgX2YxLngsIDAsIC0gX2YyLnksIF9mMi54LCAwXG5cdFx0XTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHVzZSBhbHJlYWR5IGV4aXN0aW5nIHRyaWFuZ2xlIGVkZ2UgdmVjdG9ycyBoZXJlXG5cdFx0X3RyaWFuZ2xlTm9ybWFsLmNyb3NzVmVjdG9ycyggX2YwLCBfZjEgKTtcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XG5cblx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciApLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0fVxuXG5cdGdldEJvdW5kaW5nU3BoZXJlKCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmdldENlbnRlciggdGFyZ2V0LmNlbnRlciApO1xuXG5cdFx0XHR0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKCBfdmVjdG9yICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRpbnRlcnNlY3QoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG5cdFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCwgdGhlIHJlc3VsdCBpcyBmdWxseSBlbXB0eSwgbm90IHNsaWdodGx5IGVtcHR5IHdpdGggbm9uLWluZi8raW5mIHZhbHVlcyB0aGF0IHdpbGwgY2F1c2Ugc3Vic2VxdWVuY2UgaW50ZXJzZWN0cyB0byBlcnJvbmVvdXNseSByZXR1cm4gdmFsaWQgdmFsdWVzLlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuXHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0X3BvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdF9wb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcblx0XHRfcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0X3BvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdF9wb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcblx0XHRfcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0X3BvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdF9wb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcblxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggX3BvaW50cyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcG9pbnRzID0gW1xuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKVxuXTtcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcblxuLy8gdHJpYW5nbGUgY2VudGVyZWQgdmVydGljZXNcblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblxuY29uc3QgX2YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfY2VudGVyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2V4dGVudHMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGVOb3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVzdEF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMsIHYwLCB2MSwgdjIsIGV4dGVudHMgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcblxuXHRcdF90ZXN0QXhpcy5mcm9tQXJyYXkoIGF4ZXMsIGkgKTtcblx0XHQvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuXHRcdGNvbnN0IHIgPSBleHRlbnRzLnggKiBNYXRoLmFicyggX3Rlc3RBeGlzLnggKSArIGV4dGVudHMueSAqIE1hdGguYWJzKCBfdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIF90ZXN0QXhpcy56ICk7XG5cdFx0Ly8gcHJvamVjdCBhbGwgMyB2ZXJ0aWNlcyBvZiB0aGUgdHJpYW5nbGUgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgcDAgPSB2MC5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAxID0gdjEuZG90KCBfdGVzdEF4aXMgKTtcblx0XHRjb25zdCBwMiA9IHYyLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Ly8gYWN0dWFsIHRlc3QsIGJhc2ljYWxseSBzZWUgaWYgZWl0aGVyIG9mIHRoZSBtb3N0IGV4dHJlbWUgb2YgdGhlIHRyaWFuZ2xlIHBvaW50cyBpbnRlcnNlY3RzIHJcblx0XHRpZiAoIE1hdGgubWF4KCAtIE1hdGgubWF4KCBwMCwgcDEsIHAyICksIE1hdGgubWluKCBwMCwgcDEsIHAyICkgKSA+IHIgKSB7XG5cblx0XHRcdC8vIHBvaW50cyBvZiB0aGUgcHJvamVjdGVkIHRyaWFuZ2xlIGFyZSBvdXRzaWRlIHRoZSBwcm9qZWN0ZWQgaGFsZi1sZW5ndGggb2YgdGhlIGFhYmJcblx0XHRcdC8vIHRoZSBheGlzIGlzIHNlcGFyYXRpbmcgYW5kIHdlIGNhbiBleGl0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbmV4cG9ydCB7IEJveDMgfTtcbiIsImltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyICk7XG5cblx0fVxuXG5cdHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fVxuXG5cdGVxdWFscyggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fb3JkZXI7XG5cblx0fVxuXG59XG5cbkV1bGVyLkRFRkFVTFRfT1JERVIgPSAnWFlaJztcblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsImNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcztcblxuXHQvLyBNdWxiZXJyeTMyIGdlbmVyYXRvclxuXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcblxuXHR0ID0gTWF0aC5pbXVsKCB0IF4gdCA+Pj4gMTUsIHQgfCAxICk7XG5cblx0dCBePSB0ICsgTWF0aC5pbXVsKCB0IF4gdCA+Pj4gNywgdCB8IDYxICk7XG5cblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgTWF0aFV0aWxzID0ge1xuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59O1xuXG5leHBvcnQge1xuXHRERUcyUkFELFxuXHRSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQsXG5cdGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG8sXG5cdG1hcExpbmVhcixcblx0aW52ZXJzZUxlcnAsXG5cdGxlcnAsXG5cdGRhbXAsXG5cdHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXAsXG5cdHJhbmRJbnQsXG5cdHJhbmRGbG9hdCxcblx0cmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb20sXG5cdGRlZ1RvUmFkLFxuXHRyYWRUb0RlZyxcblx0aXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3byxcblx0Zmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemUsXG5cdGRlbm9ybWFsaXplLFxuXHRNYXRoVXRpbHNcbn07XG4iLCJjbGFzcyBNYXRyaXgzIHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLFxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcblx0XHRcdG4xMyA9IHRlWyA2IF0sIG4yMyA9IHRlWyA3IF0sIG4zMyA9IHRlWyA4IF0sXG5cblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcblxuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGUoIHRoZXRhICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVRyYW5zbGF0aW9uKCB0eCwgdHkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGZvciAyRCBUcmFuc2Zvcm1zXG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCB4LnksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIHksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCxcblx0XHRcdDAsIHksIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vXG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbTMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDMgfTtcbiIsImltcG9ydCB7IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgTWF0cml4NCB7XG5cblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdE1hdHJpeDQucHJvdG90eXBlLmlzTWF0cml4NCA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRdO1xuXG5cdFx0aWYgKCBuMTEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sIDAsXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWCA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuXHRcdGNvbnN0IGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0Y29uc3QgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCBfemVybywgcSwgX29uZSApO1xuXG5cdH1cblxuXHRsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XG5cdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcblx0XHRjb25zdCBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHRjb25zdCBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0Y29uc3QgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZXRlcm1pbmFudCgpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuXHRcdGNvbnN0IG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuXHRcdGNvbnN0IG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHRjb25zdCBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdG40MSAqIChcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0KSArXG5cdFx0XHRuNDIgKiAoXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQzICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40NCAqIChcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0KVxuXG5cdFx0KTtcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGxldCB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UG9zaXRpb24oIHgsIHksIHogKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLCBuNDEgPSB0ZVsgMyBdLFxuXHRcdFx0bjEyID0gdGVbIDQgXSwgbjIyID0gdGVbIDUgXSwgbjMyID0gdGVbIDYgXSwgbjQyID0gdGVbIDcgXSxcblx0XHRcdG4xMyA9IHRlWyA4IF0sIG4yMyA9IHRlWyA5IF0sIG4zMyA9IHRlWyAxMCBdLCBuNDMgPSB0ZVsgMTEgXSxcblx0XHRcdG4xNCA9IHRlWyAxMiBdLCBuMjQgPSB0ZVsgMTMgXSwgbjM0ID0gdGVbIDE0IF0sIG40NCA9IHRlWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHRjb25zdCBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDMgXSA9ICggbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDEyIF0gPSB0MTQgKiBkZXRJbnY7XG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTUgXSA9ICggbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHYgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXhTY2FsZU9uQXhpcygpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdGNvbnN0IHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cblx0fVxuXG5cdG1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgueCxcblx0XHRcdFx0MCwgMSwgMCwgeC55LFxuXHRcdFx0XHQwLCAwLCAxLCB4LnosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25YKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHQwLCBzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25ZKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtIHMsIDAsIGMsIDAsXG5cdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25aKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHRjb25zdCB0ID0gMSAtIGM7XG5cdFx0Y29uc3QgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHRjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNoZWFyKCB4eSwgeHosIHl4LCB5eiwgengsIHp5ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHl4LCB6eCwgMCxcblx0XHRcdHh5LCAxLCB6eSwgMCxcblx0XHRcdHh6LCB5eiwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgeCA9IHF1YXRlcm5pb24uX3gsIHkgPSBxdWF0ZXJuaW9uLl95LCB6ID0gcXVhdGVybmlvbi5feiwgdyA9IHF1YXRlcm5pb24uX3c7XG5cdFx0Y29uc3QgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0Y29uc3QgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6Mjtcblx0XHRjb25zdCB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuXHRcdGNvbnN0IHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHRjb25zdCBzeCA9IHNjYWxlLngsIHN5ID0gc2NhbGUueSwgc3ogPSBzY2FsZS56O1xuXG5cdFx0dGVbIDAgXSA9ICggMSAtICggeXkgKyB6eiApICkgKiBzeDtcblx0XHR0ZVsgMSBdID0gKCB4eSArIHd6ICkgKiBzeDtcblx0XHR0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xuXHRcdHRlWyA1IF0gPSAoIDEgLSAoIHh4ICsgenogKSApICogc3k7XG5cdFx0dGVbIDYgXSA9ICggeXogKyB3eCApICogc3k7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gKCB4eiArIHd5ICkgKiBzejtcblx0XHR0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcblx0XHR0ZVsgMTAgXSA9ICggMSAtICggeHggKyB5eSApICkgKiBzejtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IHBvc2l0aW9uLng7XG5cdFx0dGVbIDEzIF0gPSBwb3NpdGlvbi55O1xuXHRcdHRlWyAxNCBdID0gcG9zaXRpb24uejtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRsZXQgc3ggPSBfdjEuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0aWYgKCBkZXQgPCAwICkgc3ggPSAtIHN4O1xuXG5cdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXHRcdF9tMS5jb3B5KCB0aGlzICk7XG5cblx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRjb25zdCBpbnZTWSA9IDEgLyBzeTtcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuXHRcdF9tMS5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRfbTEuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRsZXQgYywgZDtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSAyICogZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7IFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7IFx0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcbmNvbnN0IF9vbmUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5jb25zdCBfeCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF95ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ogPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbmNsYXNzIFF1YXRlcm5pb24ge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdHRoaXMuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdH1cblxuXHRzdGF0aWMgc2xlcnBGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdGxldCB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG5cdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRpZiAoIHQgPT09IDAgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzE7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcblxuXHRcdFx0bGV0IHMgPSAxIC0gdDtcblx0XHRcdGNvbnN0IGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0eTAgKj0gZjtcblx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0dzAgKj0gZjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG5cdH1cblxuXHRzdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxICkge1xuXG5cdFx0Y29uc3QgeDAgPSBzcmMwWyBzcmNPZmZzZXQwIF07XG5cdFx0Y29uc3QgeTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdO1xuXHRcdGNvbnN0IHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXTtcblx0XHRjb25zdCB3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgXTtcblx0XHRjb25zdCB5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF07XG5cdFx0Y29uc3QgejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdO1xuXHRcdGNvbnN0IHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MCAqIHcxICsgdzAgKiB4MSArIHkwICogejEgLSB6MCAqIHkxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowICogdzEgKyB3MCAqIHoxICsgeDAgKiB5MSAtIHkwICogeDE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MCAqIHcxIC0geDAgKiB4MSAtIHkwICogeTEgLSB6MCAqIHoxO1xuXG5cdFx0cmV0dXJuIGRzdDtcblxuXHR9XG5cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9XG5cblx0c2V0IHkoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHooKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9XG5cblx0c2V0IHooIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9XG5cblx0c2V0IHcoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cblx0Y29weSggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUV1bGVyKCBldWxlciwgdXBkYXRlICkge1xuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdGNvbnN0IGMxID0gY29zKCB4IC8gMiApO1xuXHRcdGNvbnN0IGMyID0gY29zKCB5IC8gMiApO1xuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0Y29uc3QgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XG5cdFx0Y29uc3QgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0bGV0IHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHQvLyB2RnJvbSBhbmQgdlRvIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIE1hdGhVdGlscy5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0Ly8gRGVyaXZlZCBmcm9tIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcblx0XHQvLyBOb3RlLCB0aGlzIHNvdXJjZSB1c2VzIHcsIHgsIHksIHogb3JkZXJpbmcsXG5cdFx0Ly8gc28gd2Ugc3dhcCB0aGUgb3JkZXIgYmVsb3cuXG5cblx0XHRjb25zdCB1MSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3Qgc3FydDF1MSA9IE1hdGguc3FydCggMSAtIHUxICk7XG5cdFx0Y29uc3Qgc3FydHUxID0gTWF0aC5zcXJ0KCB1MSApO1xuXG5cdFx0Y29uc3QgdTIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cblx0XHRjb25zdCB1MyA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzLnNldChcblx0XHRcdHNxcnQxdTEgKiBNYXRoLmNvcyggdTIgKSxcblx0XHRcdHNxcnR1MSAqIE1hdGguc2luKCB1MyApLFxuXHRcdFx0c3FydHUxICogTWF0aC5jb3MoIHUzICksXG5cdFx0XHRzcXJ0MXUxICogTWF0aC5zaW4oIHUyICksXG5cdFx0KTtcblxuXHR9XG5cblx0ZXF1YWxzKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KCk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fdztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4vQm94My5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BoZXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xuXG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0fVxuXG5cdHNldCggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG5cdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2JveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNwaGVyZSApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDwgMCApO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHR0aGlzLnJhZGl1cyA9IC0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Y29uc3QgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNQbGFuZSggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH1cblxuXHRjbGFtcFBvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0dGFyZ2V0LmNvcHkoIHBvaW50ICk7XG5cblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0dGFyZ2V0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0Ly8gRW1wdHkgc3BoZXJlIHByb2R1Y2VzIGVtcHR5IGJvdW5kaW5nIGJveFxuXHRcdFx0dGFyZ2V0Lm1ha2VFbXB0eSgpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuXHRcdHRhcmdldC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdF92MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5jZW50ZXIgKTtcblxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxLmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgbWluaW1hbCBzcGhlcmVcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCBsZW5ndGhTcSApO1xuXG5cdFx0XHRjb25zdCBkZWx0YSA9ICggbGVuZ3RoIC0gdGhpcy5yYWRpdXMgKSAqIDAuNTtcblxuXHRcdFx0dGhpcy5jZW50ZXIuYWRkU2NhbGVkVmVjdG9yKCBfdjEsIGRlbHRhIC8gbGVuZ3RoICk7XG5cblx0XHRcdHRoaXMucmFkaXVzICs9IGRlbHRhO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBzcGhlcmUgKSB7XG5cblx0XHRpZiAoIHNwaGVyZS5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBzcGhlcmUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY2VudGVyLmVxdWFscyggc3BoZXJlLmNlbnRlciApID09PSB0cnVlICkge1xuXG5cdFx0XHQgdGhpcy5yYWRpdXMgPSBNYXRoLm1heCggdGhpcy5yYWRpdXMsIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF92Mi5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuYWRkKCBfdjIgKSApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyZSB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgVmVjdG9yMiB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCApIHtcblxuXHRcdFZlY3RvcjIucHJvdG90eXBlLmlzVmVjdG9yMiA9IHRydWU7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcblxuXHRcdHJldHVybiB0aGlzLng7XG5cblx0fVxuXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnggPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnk7XG5cblx0fVxuXG5cdHNldCBoZWlnaHQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy55ID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldCggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZSggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcblxuXHR9XG5cblx0Zmxvb3IoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZWlsKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnRydW5jKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnRydW5jKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH1cblxuXHRjcm9zcyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdGFuZ2xlKCkge1xuXG5cdFx0Ly8gY29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXNcblxuXHRcdGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMiggLSB0aGlzLnksIC0gdGhpcy54ICkgKyBNYXRoLlBJO1xuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXG5cdH1cblxuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIE1hdGhVdGlscy5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH1cblxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcblxuXHR9XG5cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVBcm91bmQoIGNlbnRlciwgYW5nbGUgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHRjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZlY3RvcjIgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcblxuY2xhc3MgVmVjdG9yMyB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAgKSB7XG5cblx0XHRWZWN0b3IzLnByb3RvdHlwZS5pc1ZlY3RvcjMgPSB0cnVlO1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFgoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFkoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseUV1bGVyKCBldWxlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMoIG0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0Y29uc3QgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC50cnVuYyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IgKTtcblxuXHR9XG5cblx0cmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdH1cblxuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWwoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9XG5cblx0c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKSB7XG5cblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDEyIF07XG5cdFx0dGhpcy55ID0gZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhTY2FsZSggbSApIHtcblxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4M0NvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRzZXRGcm9tRXVsZXIoIGUgKSB7XG5cblx0XHR0aGlzLnggPSBlLl94O1xuXHRcdHRoaXMueSA9IGUuX3k7XG5cdFx0dGhpcy56ID0gZS5fejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ29sb3IoIGMgKSB7XG5cblx0XHR0aGlzLnggPSBjLnI7XG5cdFx0dGhpcy55ID0gYy5nO1xuXHRcdHRoaXMueiA9IGMuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbURpcmVjdGlvbigpIHtcblxuXHRcdC8vIERlcml2ZWQgZnJvbSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXG5cdFx0Y29uc3QgdSA9ICggTWF0aC5yYW5kb20oKSAtIDAuNSApICogMjtcblx0XHRjb25zdCB0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnNxcnQoIDEgLSB1ICoqIDIgKTtcblxuXHRcdHRoaXMueCA9IGYgKiBNYXRoLmNvcyggdCApO1xuXHRcdHRoaXMueSA9IGYgKiBNYXRoLnNpbiggdCApO1xuXHRcdHRoaXMueiA9IHU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5leHBvcnQgeyBWZWN0b3IzIH07XG4iLCJmdW5jdGlvbiBhcnJheU1pbiggYXJyYXkgKSB7XG5cblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gSW5maW5pdHk7XG5cblx0bGV0IG1pbiA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA8IG1pbiApIG1pbiA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtaW47XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlNYXgoIGFycmF5ICkge1xuXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIC0gSW5maW5pdHk7XG5cblx0bGV0IG1heCA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+IG1heCApIG1heCA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtYXg7XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlOZWVkc1VpbnQzMiggYXJyYXkgKSB7XG5cblx0Ly8gYXNzdW1lcyBsYXJnZXIgdmFsdWVzIHVzdWFsbHkgb24gbGFzdFxuXG5cdGZvciAoIGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLSBpICkge1xuXG5cdFx0aWYgKCBhcnJheVsgaSBdID49IDY1NTM1ICkgcmV0dXJuIHRydWU7IC8vIGFjY291bnQgZm9yIFBSSU1JVElWRV9SRVNUQVJUX0ZJWEVEX0lOREVYLCAjMjQ1NjVcblxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmNvbnN0IFRZUEVEX0FSUkFZUyA9IHtcblx0SW50OEFycmF5OiBJbnQ4QXJyYXksXG5cdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcblx0SW50MTZBcnJheTogSW50MTZBcnJheSxcblx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuXHRVaW50MzJBcnJheTogVWludDMyQXJyYXksXG5cdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxufTtcblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheSggdHlwZSwgYnVmZmVyICkge1xuXG5cdHJldHVybiBuZXcgVFlQRURfQVJSQVlTWyB0eXBlIF0oIGJ1ZmZlciApO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyggbmFtZSApIHtcblxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xuXG5cdGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblx0Y2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRyZXR1cm4gY2FudmFzO1xuXG59XG5cbmNvbnN0IF9jYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuT25jZSggbWVzc2FnZSApIHtcblxuXHRpZiAoIG1lc3NhZ2UgaW4gX2NhY2hlICkgcmV0dXJuO1xuXG5cdF9jYWNoZVsgbWVzc2FnZSBdID0gdHJ1ZTtcblxuXHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblxufVxuXG5leHBvcnQgeyBhcnJheU1pbiwgYXJyYXlNYXgsIGFycmF5TmVlZHNVaW50MzIsIGdldFR5cGVkQXJyYXksIGNyZWF0ZUVsZW1lbnROUywgY3JlYXRlQ2FudmFzRWxlbWVudCwgd2Fybk9uY2UgfTtcbiIsIi8vIGhhbmRsZXMgY29kZSBldmFsdWF0aW9uIGFuZCBhdHRhY2hpbmcgcmVsZXZhbnQgb2JqZWN0cyB0byBnbG9iYWwgYW5kIGV2YWx1YXRpb24gY29udGV4dHNcblxuaW1wb3J0IFNhbmRib3ggZnJvbSAnLi9saWIvc2FuZGJveC5qcydcbmltcG9ydCBBcnJheVV0aWxzIGZyb20gJy4vbGliL2FycmF5LXV0aWxzLmpzJ1xuXG5jbGFzcyBFdmFsU2FuZGJveCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFrZUdsb2JhbCwgdXNlclByb3BzID0gW10pIHtcbiAgICB0aGlzLm1ha2VHbG9iYWwgPSBtYWtlR2xvYmFsXG4gICAgdGhpcy5zYW5kYm94ID0gU2FuZGJveChwYXJlbnQpXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRcbiAgICB2YXIgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHBhcmVudClcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB0aGlzLmFkZChwcm9wZXJ0eSkpXG4gICAgdGhpcy51c2VyUHJvcHMgPSB1c2VyUHJvcHNcbiAgfVxuXG4gIGFkZChuYW1lKSB7XG4gICAgaWYodGhpcy5tYWtlR2xvYmFsKSB3aW5kb3dbbmFtZV0gPSB0aGlzLnBhcmVudFtuYW1lXVxuICAgIHRoaXMuc2FuZGJveC5hZGRUb0NvbnRleHQobmFtZSwgYHBhcmVudC4ke25hbWV9YClcbiAgfVxuXG4vLyBzZXRzIG9uIHdpbmRvdyBhcyB3ZWxsIGFzIHN5bnRoIG9iamVjdCBpZiBnbG9iYWwgKG5vdCBuZWVkZWQgZm9yIG9iamVjdHMsIHdoaWNoIGNhbiBiZSBzZXQgZGlyZWN0bHkpXG5cbiAgc2V0KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmKHRoaXMubWFrZUdsb2JhbCkge1xuICAgICAgd2luZG93W3Byb3BlcnR5XSA9IHZhbHVlXG4gICAgfVxuICAgIHRoaXMucGFyZW50W3Byb3BlcnR5XSA9IHZhbHVlXG4gIH1cblxuICB0aWNrKCkge1xuICAgIGlmKHRoaXMubWFrZUdsb2JhbCkge1xuICAgICAgdGhpcy51c2VyUHJvcHMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgdGhpcy5wYXJlbnRbcHJvcGVydHldID0gd2luZG93W3Byb3BlcnR5XVxuICAgICAgfSlcbiAgICAgIC8vICB0aGlzLnBhcmVudC5zcGVlZCA9IHdpbmRvdy5zcGVlZFxuICAgIH0gZWxzZSB7XG5cbiAgICB9XG4gIH1cblxuICBldmFsKGNvZGUpIHtcbiAgICB0aGlzLnNhbmRib3guZXZhbChjb2RlKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2YWxTYW5kYm94XG4iLCJpbXBvcnQgYXJyYXlVdGlscyBmcm9tICcuL2xpYi9hcnJheS11dGlscy5qcydcbmltcG9ydCB7Z2V0TG9va3VwfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXG4vLyBbV0lQXSBob3cgdG8gdHJlYXQgZGlmZmVyZW50IGRpbWVuc2lvbnMgKD8pXG5jb25zdCBERUZBVUxUX0NPTlZFUlNJT05TID0ge1xuICBmbG9hdDoge1xuICAgICd2ZWM0JzogeyBuYW1lOiAnc3VtJywgYXJnczogW1sxLCAxLCAxLCAxXV0gfSxcbiAgICAndmVjMic6IHsgbmFtZTogJ3N1bScsIGFyZ3M6IFtbMSwgMV1dIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaWxsQXJyYXlXaXRoRGVmYXVsdHMoYXJyLCBsZW4pIHtcbiAgLy8gZmlsbCB0aGUgYXJyYXkgd2l0aCBkZWZhdWx0IHZhbHVlcyBpZiBpdCdzIHRvbyBzaG9ydFxuICB3aGlsZSAoYXJyLmxlbmd0aCA8IGxlbikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAzKSB7IC8vIHB1c2ggYSAxIGFzIHRoZSBkZWZhdWx0IGZvciAuYSBpbiB2ZWM0XG4gICAgICBhcnIucHVzaCgxLjApXG4gICAgfSBlbHNlIHtcbiAgICAgIGFyci5wdXNoKDAuMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5zbGljZSgwLCBsZW4pXG59XG5cbmNvbnN0IGVuc3VyZV9kZWNpbWFsX2RvdCA9ICh2YWwpID0+IHtcbiAgdmFsID0gdmFsLnRvU3RyaW5nKClcbiAgaWYgKHZhbC5pbmRleE9mKCcuJykgPCAwKSB7XG4gICAgdmFsICs9ICcuJ1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdEFyZ3VtZW50cyh0cmFuc2Zvcm0sIHN0YXJ0SW5kZXgsIHN5bnRoQ29udGV4dCkge1xuICBjb25zdCBkZWZhdWx0QXJncyA9IHRyYW5zZm9ybS50cmFuc2Zvcm0uaW5wdXRzXG4gIGNvbnN0IHVzZXJBcmdzID0gdHJhbnNmb3JtLnVzZXJBcmdzXG4gIGNvbnN0IHsgZ2VuZXJhdG9ycyB9ID0gdHJhbnNmb3JtLnN5bnRoXG4gIGNvbnN0IHsgc3JjIH0gPSBnZW5lcmF0b3JzIC8vIGRlcGVuZHMgb24gc3ludGggaGF2aW5nIHNyYygpIGZ1bmN0aW9uXG4gIHJldHVybiBkZWZhdWx0QXJncy5tYXAoKGlucHV0LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHR5cGVkQXJnID0ge1xuICAgICAgdmFsdWU6IGlucHV0LmRlZmF1bHQsXG4gICAgICB0eXBlOiBpbnB1dC50eXBlLCAvL1xuICAgICAgaXNVbmlmb3JtOiBmYWxzZSxcbiAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICB2ZWNMZW46IDBcbiAgICAgIC8vICBnZW5lcmF0ZUdsc2w6IG51bGwgLy8gZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGdsc2xcbiAgICB9XG5cbiAgICBpZiAodHlwZWRBcmcudHlwZSA9PT0gJ2Zsb2F0JykgdHlwZWRBcmcudmFsdWUgPSBlbnN1cmVfZGVjaW1hbF9kb3QoaW5wdXQuZGVmYXVsdClcbiAgICBpZiAoaW5wdXQudHlwZS5zdGFydHNXaXRoKCd2ZWMnKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHlwZWRBcmcudmVjTGVuID0gTnVtYmVyLnBhcnNlSW50KGlucHV0LnR5cGUuc3Vic3RyKDMpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgZGV0ZXJtaW5pbmcgbGVuZ3RoIG9mIHZlY3RvciBpbnB1dCB0eXBlICR7aW5wdXQudHlwZX0gKCR7aW5wdXQubmFtZX0pYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB1c2VyIGhhcyBpbnB1dCBzb21ldGhpbmcgZm9yIHRoaXMgYXJndW1lbnRcbiAgICBpZiAodXNlckFyZ3MubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHR5cGVkQXJnLnZhbHVlID0gdXNlckFyZ3NbaW5kZXhdO1xuICAgICAgaWYgKHR5cGVvZiB0eXBlZEFyZy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlZEFyZy52YWx1ZS5uYW1lICE9PSAncmVnbFRleHR1cmUyRCcgJiYgdHlwZWRBcmcudmFsdWUubmFtZSAhPT0gJ3JlZ2xGcmFtZWJ1ZmZlcicpIHtcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR5cGVkQXJnLnZhbHVlLCBpbnB1dCk7XG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAodHlwZWRBcmcudmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0gZ2V0QXJyYXlWYWx1ZSh0eXBlZEFyZy52YWx1ZSwgaW5wdXQsIHR5cGVkQXJnLnZlY0xlbilcbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gdHJ1ZVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0SW5kZXggPCAwKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlZEFyZy52YWx1ZSAmJiB0eXBlZEFyZy52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsX3RyYW5zZm9ybSA9IHR5cGVkQXJnLnZhbHVlLnRyYW5zZm9ybXNbdHlwZWRBcmcudmFsdWUudHJhbnNmb3Jtcy5sZW5ndGggLSAxXVxuXG4gICAgICAgIGlmIChmaW5hbF90cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xfcmV0dXJuX3R5cGUgIT09IGlucHV0LnR5cGUpIHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0cyA9IERFRkFVTFRfQ09OVkVSU0lPTlNbaW5wdXQudHlwZV1cbiAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdF9kZWYgPSBkZWZhdWx0c1tmaW5hbF90cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xfcmV0dXJuX3R5cGVdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRfZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3MgfSA9IGRlZmF1bHRfZGVmXG4gICAgICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gdHlwZWRBcmcudmFsdWVbbmFtZV0oLi4uYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICh0eXBlZEFyZy50eXBlID09PSAnZmxvYXQnICYmIHR5cGVvZiB0eXBlZEFyZy52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBlbnN1cmVfZGVjaW1hbF9kb3QodHlwZWRBcmcudmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVkQXJnLnR5cGUuc3RhcnRzV2l0aCgndmVjJykgJiYgdHlwZW9mIHR5cGVkQXJnLnZhbHVlICE9PSAnZnVuY3Rpb24nICYmICF0eXBlZEFyZy52YWx1ZS5nZXRUZXh0dXJlKSB7XG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGZhbHNlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGVkQXJnLnZhbHVlKSB8fCB0eXBlZEFyZy52YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB0eXBlZEFyZy52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAvLyB0b2RvOiBhY2NlcHQgc21hbGxlciBhcnJheXM/XG4gICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBgJHt0eXBlZEFyZy50eXBlfSgke3R5cGVkQXJnLnZhbHVlLm1hcChlbnN1cmVfZGVjaW1hbF9kb3QpLmpvaW4oJywgJyl9KWBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHlwZWRBcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQodHlwZWRBcmcudHlwZS5zdWJzdHIoLTEpKTtcbiAgICAgICAgICBjb25zdCBhcnIgPSBBcnJheShsZW5ndGgpLmZpbGwodHlwZWRBcmcudmFsdWUpO1xuICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gYCR7dHlwZWRBcmcudHlwZX0oJHthcnIubWFwKGVuc3VyZV9kZWNpbWFsX2RvdCkuam9pbignLCAnKX0pYFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnR5cGUgPT09ICdzYW1wbGVyMkQnKSB7XG4gICAgICAgIC8vIHR5cGVkQXJnLnRleCA9IHR5cGVkQXJnLnZhbHVlXG4gICAgICAgIHZhciB4ID0gdHlwZWRBcmcudmFsdWVcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSB4LmdldFRleHR1cmUgPyAoKSA9PiAoeC5nZXRUZXh0dXJlKCkpIDogeFxuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBwYXNzaW5nIGluIGEgdGV4dHVyZSByZWZlcmVuY2UsIHdoZW4gZnVuY3Rpb24gYXNrcyBmb3IgdmVjNCwgY29udmVydCB0byB2ZWM0XG4gICAgICAgIGlmICh0eXBlZEFyZy52YWx1ZS5nZXRUZXh0dXJlIHx8IHR5cGVkQXJnLnZhbHVlLm5hbWUgPT09ICdyZWdsVGV4dHVyZTJEJykge1xuICAgICAgICAgIHZhciB4MSA9IHR5cGVkQXJnLnZhbHVlXG4gICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICd2ZWM0Jykge1xuICAgICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBzcmMoeDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGdldHRlciA9IGdldExvb2t1cFtpbnB1dC50eXBlXTtcbiAgICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gc3JjKHgxKVtnZXR0ZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0cCB1bmlmb3JtIGFycmF5IGlmIGlzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBhc3MgaW4gYSBkaWZmZXJlbnQgdmFsdWUgb24gZWFjaCByZW5kZXIgZnJhbWUsXG4gICAgICAvLyBvciBhIHRleHR1cmUvIGV4dGVybmFsIHNvdXJjZVxuXG4gICAgICBpZiAoaW5wdXQuaXNVbmlmb3JtKSB0eXBlZEFyZy5pc1VuaWZvcm0gPSBpbnB1dC5pc1VuaWZvcm07XG4gICAgICBpZiAodHlwZWRBcmcuaXNVbmlmb3JtKSB7XG4gICAgICAgIHR5cGVkQXJnLm5hbWUgKz0gc3RhcnRJbmRleFxuICAgICAgICAvLyAgc2hhZGVyUGFyYW1zLnVuaWZvcm1zLnB1c2godHlwZWRBcmcpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlZEFyZ1xuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbHVlLCBpbnB1dCkge1xuICAvLyBpZiAodHlwZWRBcmcudmVjTGVuID4gMCkgeyAvLyBleHBlY3RlZCBpbnB1dCBpcyBhIHZlY3Rvciwgbm90IGEgc2NhbGFyXG4gIC8vICAgIHR5cGVkQXJnLnZhbHVlID0gKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKSA9PiAoZmlsbEFycmF5V2l0aERlZmF1bHRzKHVzZXJBcmdzW2luZGV4XShwcm9wcyksIHR5cGVkQXJnLnZlY0xlbikpXG4gIC8vIH0gZWxzZSB7XG4gIHJldHVybiAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWUocHJvcHMpXG4gICAgICBpZih0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2Z1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIG51bWJlcicsIHZhbHVlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0LmRlZmF1bHRcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VSUk9SJywgZSlcbiAgICAgIHJldHVybiBpbnB1dC5kZWZhdWx0XG4gICAgfVxuICB9XG4gIC8vICB9XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VmFsdWUodmFsdWUsIGlucHV0LCB2ZWNMZW4gPSAwKSB7XG4gIC8vICAgaWYgKHR5cGVkQXJnLnZlY0xlbiA+IDApIHsgLy8gZXhwZWN0ZWQgaW5wdXQgaXMgYSB2ZWN0b3IsIG5vdCBhIHNjYWxhclxuICAvLyAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gdHJ1ZVxuICAvLyAgICAgdHlwZWRBcmcudmFsdWUgPSBmaWxsQXJyYXlXaXRoRGVmYXVsdHModHlwZWRBcmcudmFsdWUsIHR5cGVkQXJnLnZlY0xlbilcbiAgLy8gIH0gZWxzZSB7XG4gIC8vICBjb25zb2xlLmxvZyhcImlzIEFycmF5XCIpXG4gIC8vIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgYXJlIG5vdCBhIG51bWJlclxuICAvLyBjb25zdCBmaWx0ZXJlZEFycmF5ID0gdXNlckFyZ3NbaW5kZXhdLmZpbHRlcigodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcbiAgLy8gdHlwZWRBcmcudmFsdWUgPSAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IGFycmF5VXRpbHMuZ2V0VmFsdWUoZmlsdGVyZWRBcnJheSkocHJvcHMpXG4gIGlmICh2ZWNMZW4pIHtcbiAgICByZXR1cm4gKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheSh2ZWNMZW4pO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHZlY0xlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaW5wdXQuZGVmYXVsdCA/IGlucHV0LmRlZmF1bHQuY29uc3RydWN0b3IgPT09IEFycmF5ID8gaW5wdXQuZGVmYXVsdFtpXSA6IGlucHV0LmRlZmF1bHQgOiAwO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSBnZXRGdW5jdGlvblZhbHVlKHYsIHtkZWZhdWx0OiBkZWZhdWx0VmFsdWV9KShjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IGFycmF5VXRpbHMuZ2V0VmFsdWUodikocHJvcHMpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IGFycmF5VXRpbHMuZ2V0VmFsdWUodmFsdWUpKHByb3BzKVxuICB9XG59IiwiaW1wb3J0IGZvcm1hdEFyZ3VtZW50cyBmcm9tICcuL2Zvcm1hdC1hcmd1bWVudHMuanMnXG5pbXBvcnQge3R5cGVMb29rdXAsIGdldExvb2t1cCwgZ2V0VHlwZUxvb2t1cCwgY2FzdFR5cGV9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbi8vIGNvbnZlcnRzIGEgdHJlZSBvZiBqYXZhc2NyaXB0IGZ1bmN0aW9ucyB0byBhIHNoYWRlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiBnZW5lcmF0ZVBhcmFtcyhjcmVhdGVQYXJhbXMoKSwgc291cmNlLCBzb3VyY2UudHJhbnNmb3Jtcylcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgdW5pZm9ybXM6IFtdLCAvLyBsaXN0IG9mIHVuaWZvcm1zIHVzZWQgaW4gc2hhZGVyXG4gICAgZ2xzbEZ1bmN0aW9uczogW10sIC8vIGxpc3Qgb2YgZnVuY3Rpb25zIHVzZWQgaW4gc2hhZGVyXG4gICAgZnJhZ0NvbG9yOiAnJyxcbiAgICBwb3NpdGlvbjogJycsXG4gIH0sIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGFyYW1zKHNoYWRlclBhcmFtcywgc291cmNlLCB0cmFuc2Zvcm1zKSB7XG4gIGlmICghc2hhZGVyUGFyYW1zLmZyYWdDb2xvcikge1xuICAgIHNoYWRlclBhcmFtcy5mcmFnQ29sb3IgPSBnZW5lcmF0ZUdsc2woc291cmNlLCB0cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMsIHR5cGVMb29rdXBbJ3NyYyddLnJldHVyblR5cGUpKCdzdCcsICd2ZWM0JywgMS4wKVxuICB9XG4gIGlmICghc2hhZGVyUGFyYW1zLnBvc2l0aW9uICYmICFzaGFkZXJQYXJhbXMuY29tYmluZSkge1xuICAgIHNoYWRlclBhcmFtcy5wb3NpdGlvbiA9IGdlbmVyYXRlR2xzbChzb3VyY2UsIHRyYW5zZm9ybXMuZmlsdGVyKCh0cikgPT4ge1xuICAgICAgcmV0dXJuIHRyLnRyYW5zZm9ybS50eXBlICE9PSAnY29tYmluZScgJiYgdHIudHJhbnNmb3JtLnR5cGUgIT09ICdjbGVhcic7XG4gICAgfSksIHNoYWRlclBhcmFtcywgdHlwZUxvb2t1cFsnc3JjJ10ucmV0dXJuVHlwZSkoJ3N0JywgJ3ZlYzQnLCAxLjApXG4gIH1cbiAgLy8gcmVtb3ZlIHVuaWZvcm1zIHdpdGggZHVwbGljYXRlIG5hbWVzXG4gIGlmIChzaGFkZXJQYXJhbXMudW5pZm9ybXMpIHtcbiAgICBsZXQgdW5pZm9ybXMgPSB7fVxuICAgIHNoYWRlclBhcmFtcy51bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtKSA9PiB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybSlcbiAgICBzaGFkZXJQYXJhbXMudW5pZm9ybXMgPSBPYmplY3QudmFsdWVzKHVuaWZvcm1zKVxuICB9XG4gIHJldHVybiBzaGFkZXJQYXJhbXNcbn1cblxuLy8gcmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHNoYWRlciBzdHJpbmcgZnJvbSBvYmplY3QgY29udGFpbmluZyBmdW5jdGlvbnMgYW5kIHVzZXIgYXJndW1lbnRzLiBPcmRlciBvZiBmdW5jdGlvbnMgaW4gc3RyaW5nIGRlcGVuZHMgb24gdHlwZSBvZiBmdW5jdGlvblxuLy8gdG8gZG86IGltcHJvdmUgdmFyaWFibGUgbmFtZXNcbmZ1bmN0aW9uIGdlbmVyYXRlR2xzbCAoc291cmNlLCB0cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpIHtcbiAgLy8gdHJhbnNmb3JtIGZ1bmN0aW9uIHRoYXQgb3V0cHV0cyBhIHNoYWRlciBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBnbF9GcmFnQ29sb3JcbiAgY29uc3QgZW1wdHkgPSAoKSA9PiAnJztcbiAgdmFyIGZyYWdDb2xvciA9IGVtcHR5XG4gIHRyYW5zZm9ybXMubWFwKCh0cmFuc2Zvcm0sIGkpID0+IHtcbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAndmVydCcgJiYgIXNvdXJjZS5nZW9tZXRyeSkge1xuICAgICAgc291cmNlLnNldEdlb21ldHJ5KHRyYW5zZm9ybS51c2VyQXJnc1swXSk7XG4gICAgICB0cmFuc2Zvcm0udXNlckFyZ3MgPSB0cmFuc2Zvcm0udXNlckFyZ3Muc2xpY2UoMSk7XG4gICAgfVxuICAgIHZhciBpbnB1dHMgPSBmb3JtYXRBcmd1bWVudHModHJhbnNmb3JtLCBzaGFkZXJQYXJhbXMudW5pZm9ybXMubGVuZ3RoKVxuICAgIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjbGVhcicpIHtcbiAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdCh7Y2xlYXI6IHRyYW5zZm9ybS50cmFuc2Zvcm0ubmFtZSwgdXNlckFyZ3M6IGlucHV0cy5tYXAoKGkpID0+IGkudmFsdWUpfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZihpbnB1dC5pc1VuaWZvcm0pIHNoYWRlclBhcmFtcy51bmlmb3Jtcy5wdXNoKGlucHV0KVxuICAgIH0pXG5cbiAgICAvLyBhZGQgbmV3IGdsc2wgZnVuY3Rpb24gdG8gcnVubmluZyBsaXN0IG9mIGZ1bmN0aW9uc1xuICAgIGlmKCFjb250YWlucyh0cmFuc2Zvcm0sIHNoYWRlclBhcmFtcy5nbHNsRnVuY3Rpb25zKSkgc2hhZGVyUGFyYW1zLmdsc2xGdW5jdGlvbnMucHVzaCh0cmFuc2Zvcm0pXG5cbiAgICAvLyBjdXJyZW50IGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGZyYWcgY29sb3Igc2hhZGVyIGNvZGVcbiAgICB2YXIgZjAgPSBmcmFnQ29sb3JcbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnc3JjJyB8fCB0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICd2ZXJ0Jykge1xuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29vcmQnKSB7XG4gICAgICBmcmFnQ29sb3IgPSBmMCA9PT0gZW1wdHlcbiAgICAgICAgPyAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtzaGFkZXJTdHJpbmcodXYsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgIDogKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7ZjAoYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCAndmVjMicpfWAsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+ICBgJHtzaGFkZXJTdHJpbmcoYCR7ZjAodXYsICd2ZWM0Jyl9YCwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ2NvbWJpbmUnKSB7XG4gICAgICAvLyBjb21iaW5pbmcgdHdvIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5ncyAoaS5lLiBmb3IgYmxlbmQsIG11bHQsIGFkZCBmdW50aW9ucylcbiAgICAgIGlmIChzb3VyY2UudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCB8fCAoaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS52ZXJ0KSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBzaGFkZXJQYXJhbXMsIHtcbiAgICAgICAgICBmcmFnQ29sb3I6IGZyYWdDb2xvcignc3QnLCAndmVjNCcsIDEuMCkgfHwgJ3ZlYzQoMCknLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzaGFkZXJQYXJhbXMsIGNyZWF0ZVBhcmFtcyh7XG4gICAgICAgICAgZ2xzbEZ1bmN0aW9uczogW3RyYW5zZm9ybV0sXG4gICAgICAgICAgY29tYmluZTogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0cmFucyA9IHNvdXJjZS50cmFuc2Zvcm1zLnNsaWNlKDAsIHNvdXJjZS50cmFuc2Zvcm1zLmluZGV4T2YodHJhbnNmb3JtKSk7XG4gICAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdChzb3VyY2UuY3JlYXRlUGFzcyhnZW5lcmF0ZVBhcmFtcyhwYXJhbXMsIHNvdXJjZSwgdHJhbnMpLCB7ZnJhbWVidWZmZXI6IHNvdXJjZS5vdXRwdXQudGVtcFswXX0pKTtcbiAgICAgICAgY29uc3QgdGVtcDAgPSBzcmMoc291cmNlLm91dHB1dC50ZW1wWzBdKTtcbiAgICAgICAgZjAgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtnZW5lcmF0ZUdsc2wodGVtcDAsIHRlbXAwLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICB9XG4gICAgICB2YXIgZjE7XG4gICAgICBpZiAoaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmIChpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCB8fCBzb3VyY2UudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCkge1xuICAgICAgICAgIGlucHV0c1swXS52YWx1ZS5vdXRwdXQgPSBzb3VyY2Uub3V0cHV0O1xuICAgICAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdCguLi5pbnB1dHNbMF0udmFsdWUuZ2xzbCh7ZnJhbWVidWZmZXI6IHNvdXJjZS5vdXRwdXQudGVtcFsxXX0pKTtcbiAgICAgICAgICBjb25zdCB0ZW1wMSA9IHNyYyhzb3VyY2Uub3V0cHV0LnRlbXBbMV0pO1xuICAgICAgICAgIGYxID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKHRlbXAxLCB0ZW1wMS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGYxID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0c1swXS52YWx1ZSwgaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmMSA9IChpbnB1dHNbMF0uaXNVbmlmb3JtID8gKCkgPT4gaW5wdXRzWzBdLm5hbWUgOiAoKSA9PiBpbnB1dHNbMF0udmFsdWUpXG4gICAgICB9XG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtzaGFkZXJTdHJpbmcoYCR7ZjAodXYsICd2ZWM0Jyl9LCAke2YxKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLnNsaWNlKDEpLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb21iaW5lQ29vcmQnKSB7XG4gICAgICAvLyBjb21iaW5pbmcgdHdvIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5ncyAoaS5lLiBmb3IgbW9kdWxhdGUgZnVuY3Rpb25zKVxuICAgICAgdmFyIGYxID0gaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zXG4gICAgICAgICAgPyAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtnZW5lcmF0ZUdsc2woaW5wdXRzWzBdLnZhbHVlLCBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSh1diwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICAgICAgICA6IChpbnB1dHNbMF0uaXNVbmlmb3JtID8gKCkgPT4gaW5wdXRzWzBdLm5hbWUgOiAoKSA9PiBpbnB1dHNbMF0udmFsdWUpXG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtmMChgJHtzaGFkZXJTdHJpbmcoYCR7dXZ9LCAke2YxKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLnNsaWNlKDEpLCBzaGFkZXJQYXJhbXMsICd2ZWMyJyl9YCwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25vIHN1cHBvcnQgZm9yIHR5cGU6ICcgKyB0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUpXG4gICAgfVxuICB9KVxuICBpZiAoc291cmNlLmdldHRlcikge1xuICAgIHZhciBmMiA9IGZyYWdDb2xvclxuICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGNhc3RUeXBlKGYyKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgKyBgLiR7c291cmNlLmdldHRlcn1gLCBnZXRUeXBlTG9va3VwW3NvdXJjZS5nZXR0ZXJdLCByZXR1cm5UeXBlLCAxLjApXG4gIH1cbiAgcmV0dXJuIGZyYWdDb2xvclxufVxuXG4vLyBhc3NlbWJsZXMgYSBzaGFkZXIgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50cyBhbmQgdGhlIGZ1bmN0aW9uIG5hbWUsIGkuZS4gJ29zYyh1diwgZnJlcXVlbmN5KSdcbmZ1bmN0aW9uIHNoYWRlclN0cmluZyAodXYsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhID0gMC4wKSB7XG4gIGNvbnN0IHN0ciA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0LmlzVW5pZm9ybSkge1xuICAgICAgcmV0dXJuIGlucHV0Lm5hbWVcbiAgICB9IGVsc2UgaWYgKGlucHV0LnZhbHVlICYmIGlucHV0LnZhbHVlLnRyYW5zZm9ybXMpIHtcbiAgICAgIC8vIHRoaXMgYnkgZGVmaW5pdGlvbiBuZWVkcyB0byBiZSBhIGdlbmVyYXRvciwgaGVuY2Ugd2Ugc3RhcnQgd2l0aCAnc3QnIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBnZW5lcmF0aW5nIHRoZSBnbHNsIGZyYWdtZW50XG4gICAgICBpZiAoIWlucHV0LnZhbHVlLmdldHRlciAmJiB0eXBlTG9va3VwW2lucHV0LnZhbHVlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnR5cGVdICE9PSBpbnB1dC50eXBlKSB7XG4gICAgICAgIC8vIHRvZG86IGFkZCBnZXR0ZXIgb25seSBpZiBpbnB1dC50eXBlIGlzIGxhcmdlclxuICAgICAgICBpbnB1dC52YWx1ZS5nZXR0ZXIgPSBnZXRMb29rdXBbaW5wdXQudHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0LnZhbHVlLCBpbnB1dC52YWx1ZS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKCdzdCcsIGlucHV0LnR5cGUpfWBcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnZhbHVlXG4gIH0pLnJlZHVjZSgocCwgYykgPT4gYCR7cH0sICR7Y31gLCAnJylcblxuICB2YXIgZnVuYyA9IGAke3RyYW5zZm9ybS50cmFuc2Zvcm0uZ2xzbE5hbWV9KCR7dXZ9JHtzdHJ9KWBcbiAgcmV0dXJuIGNhc3RUeXBlKGZ1bmMsIHR5cGVMb29rdXBbdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlXS5yZXR1cm5UeXBlLCByZXR1cm5UeXBlLCBhbHBoYSk7XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYXJyYXlcbmZ1bmN0aW9uIGNvbnRhaW5zKG9iamVjdCwgYXJyKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgIGlmKG9iamVjdC5uYW1lID09IGFycltpXS5uYW1lKSByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxuIiwiaW1wb3J0IEdsc2xTb3VyY2UgZnJvbSAnLi9nbHNsLXNvdXJjZS5qcydcbmltcG9ydCBnbHNsRnVuY3Rpb25zIGZyb20gJy4vZ2xzbC9nbHNsLWZ1bmN0aW9ucy5qcydcbmltcG9ydCB2ZXJ0RnVuY3Rpb25zIGZyb20gJy4vZ2xzbC92ZXJ0LWZ1bmN0aW9ucy5qcydcbmltcG9ydCB7dHlwZUxvb2t1cH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblxuY2xhc3MgR2VuZXJhdG9yRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgICBkZWZhdWx0VW5pZm9ybXMsXG4gICAgICBkZWZhdWx0T3V0cHV0LFxuICAgICAgZXh0ZW5kVHJhbnNmb3JtcyA9IFtdLFxuICAgICAgY2hhbmdlTGlzdGVuZXIgPSAoKCkgPT4ge30pXG4gICAgfSA9IHt9XG4gICAgKSB7XG4gICAgdGhpcy5kZWZhdWx0T3V0cHV0ID0gZGVmYXVsdE91dHB1dFxuICAgIHRoaXMuZGVmYXVsdFVuaWZvcm1zID0gZGVmYXVsdFVuaWZvcm1zXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IGNoYW5nZUxpc3RlbmVyXG4gICAgdGhpcy5leHRlbmRUcmFuc2Zvcm1zID0gZXh0ZW5kVHJhbnNmb3Jtc1xuICAgIHRoaXMuZ2VuZXJhdG9ycyA9IHt9XG4gICAgdGhpcy51dGlscyA9IHt9XG4gICAgdGhpcy5pbml0KClcbiAgfVxuICBpbml0ICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbnMgPSBnbHNsRnVuY3Rpb25zKClcbiAgICB0aGlzLmdsc2xUcmFuc2Zvcm1zID0ge31cbiAgICB0aGlzLmdlbmVyYXRvcnMgPSBPYmplY3QuZW50cmllcyh0aGlzLmdlbmVyYXRvcnMpLnJlZHVjZSgocHJldiwgW21ldGhvZCwgdHJhbnNmb3JtXSkgPT4ge1xuICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcih7dHlwZTogJ3JlbW92ZScsIHN5bnRoOiB0aGlzLCBtZXRob2R9KVxuICAgICAgcmV0dXJuIHByZXZcbiAgICB9LCB7fSlcblxuICAgIHRoaXMuc291cmNlQ2xhc3MgPSAoKCkgPT4ge1xuICAgICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgR2xzbFNvdXJjZSB7XG4gICAgICB9XG4gICAgfSkoKVxuXG4gICAgLy8gYWRkIHVzZXIgZGVmaW5pZWQgdHJhbnNmb3Jtc1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXh0ZW5kVHJhbnNmb3JtcykpIHtcbiAgICAgIGZ1bmN0aW9ucy5jb25jYXQodGhpcy5leHRlbmRUcmFuc2Zvcm1zKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyA9PT0gJ29iamVjdCcgJiYgdGhpcy5leHRlbmRUcmFuc2Zvcm1zLnR5cGUpIHtcbiAgICAgIGZ1bmN0aW9ucy5wdXNoKHRoaXMuZXh0ZW5kVHJhbnNmb3JtcylcbiAgICB9XG5cbiAgICBmdW5jdGlvbnMubWFwKCh0cmFuc2Zvcm0pID0+IHRoaXMuc2V0RnVuY3Rpb24odHJhbnNmb3JtKSlcblxuICAgIGNvbnN0IGZ1bmN0aW9uczIgPSB2ZXJ0RnVuY3Rpb25zKHRoaXMuZ2VuZXJhdG9ycyk7IC8vIHNhbmRib3ggaXMgbm90IHJlYWR5IGF0IHRoaXMgbW9tZW50IHlldFxuICAgIGZ1bmN0aW9uczIubWFwKCh0cmFuc2Zvcm0pID0+IHRoaXMuc2V0RnVuY3Rpb24odHJhbnNmb3JtKSlcbiB9XG5cbiBfYWRkTWV0aG9kIChtZXRob2QsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5nbHNsVHJhbnNmb3Jtc1ttZXRob2RdID0gdHJhbnNmb3JtXG4gICAgbGV0IHJldHZhbCA9IHVuZGVmaW5lZFxuICAgIGlmIChbJ3NyYycsICdjb29yZCcsICdjbGVhcicsICd2ZXJ0J10uaW5kZXhPZih0cmFuc2Zvcm0udHlwZSkgPiAtMSkge1xuICAgICAgY29uc3QgZnVuYyA9ICguLi5hcmdzKSA9PiBuZXcgdGhpcy5zb3VyY2VDbGFzcyh7XG4gICAgICAgIG5hbWU6IG1ldGhvZCxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIHVzZXJBcmdzOiBhcmdzLFxuICAgICAgICBkZWZhdWx0T3V0cHV0OiB0aGlzLmRlZmF1bHRPdXRwdXQsXG4gICAgICAgIGRlZmF1bHRVbmlmb3JtczogdGhpcy5kZWZhdWx0VW5pZm9ybXMsXG4gICAgICAgIHN5bnRoOiBzZWxmLFxuICAgICAgICB1dGlsczogdGhpcy51dGlscyxcbiAgICAgIH0pXG4gICAgICB0aGlzLmdlbmVyYXRvcnNbbWV0aG9kXSA9IGZ1bmNcbiAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIoe3R5cGU6ICdhZGQnLCBzeW50aDogdGhpcywgbWV0aG9kfSlcbiAgICAgIHJldHZhbCA9IGZ1bmNcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBwcmV2VHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1zW3RoaXMudHJhbnNmb3Jtcy5sZW5ndGgtMV0udHJhbnNmb3JtO1xuICAgICAgaWYgKHByZXZUcmFuc2Zvcm0udHlwZSA9PT0gJ2NsZWFyJyB8fCAodHJhbnNmb3JtLnR5cGUgIT09ICdzcmMnICYmIHRyYW5zZm9ybS50eXBlICE9PSAndmVydCcpKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKHtuYW1lOiBtZXRob2QsIHRyYW5zZm9ybTogdHJhbnNmb3JtLCB1c2VyQXJnczogYXJncywgc3ludGg6IHNlbGZ9KVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHRyYW5zZm9ybSAke3RyYW5zZm9ybS5uYW1lfSBub3QgYWxsb3dlZCBhZnRlciAke3ByZXZUcmFuc2Zvcm0ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHJldHVybiByZXR2YWxcbiAgfVxuXG4gIHNldEZ1bmN0aW9uKG9iaikge1xuICAgIC8vIHRvZG86IHJlbW92ZSB1dGlscyBhbmQgaW5zdGVhZCBtYW5hZ2UgZnVuY3Rpb24gZGVwZW5kZW5jaWVzXG4gICAgaWYgKG9iai50eXBlID09PSAndXRpbCcpIHRoaXMudXRpbHNbb2JqLm5hbWVdID0gb2JqO1xuICAgIHZhciBwcm9jZXNzZWRHbHNsID0gcHJvY2Vzc0Z1bmN0aW9uKG9iailcbiAgICBpZihwcm9jZXNzZWRHbHNsKSB0aGlzLl9hZGRNZXRob2Qob2JqLm5hbWUsIHByb2Nlc3NlZEdsc2wpXG4gIH1cbn1cblxuLy8gZXhwZWN0cyBnbHNsIG9mIGZvcm1hdFxuLy8ge1xuLy8gICBuYW1lOiAnb3NjJywgLy8gbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBhY2Nlc3MgZnVuY3Rpb24gYXMgd2VsbCBhcyB3aXRoaW4gZ2xzbFxuLy8gICB0eXBlOiAnc3JjJywgLy8gY2FuIGJlIHNyYzogdmVjNCh2ZWMyIF9zdCksIGNvb3JkOiB2ZWMyKHZlYzIgX3N0KSwgY29sb3I6IHZlYzQodmVjNCBfYzApLCBjb21iaW5lOiB2ZWM0KHZlYzQgX2MwLCB2ZWM0IF9jMSksIGNvbWJpbmVDb29yZDogdmVjMih2ZWMyIF9zdCwgdmVjNCBfYzApXG4vLyAgIGlucHV0czogW1xuLy8gICAgIHtcbi8vICAgICAgIG5hbWU6ICdmcmVxJyxcbi8vICAgICAgIHR5cGU6ICdmbG9hdCcsIC8vICdmbG9hdCcgICAvLywgJ3RleHR1cmUnLCAndmVjNCdcbi8vICAgICAgIGRlZmF1bHQ6IDAuMlxuLy8gICAgIH0sXG4vLyAgICAge1xuLy8gICAgICAgICAgIG5hbWU6ICdzeW5jJyxcbi8vICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuLy8gICAgICAgICAgIGRlZmF1bHQ6IDAuMVxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4vLyAgICAgICAgICAgdHlwZTogJ2Zsb2F0Jyxcbi8vICAgICAgICAgICBkZWZhdWx0OiAwLjBcbi8vICAgICAgICAgfVxuLy8gICBdLFxuICAgLy8gIGdsc2w6IGBcbiAgIC8vICAgIHZlYzIgc3QgPSBfc3Q7XG4gICAvLyAgICBmbG9hdCByID0gc2luKChzdC54LW9mZnNldCoyL2ZyZXErdGltZSpzeW5jKSpmcmVxKSowLjUgICsgMC41O1xuICAgLy8gICAgZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbiAgIC8vICAgIGZsb2F0IGIgPSBzaW4oKHN0Lngrb2Zmc2V0L2ZyZXErdGltZSpzeW5jKSpmcmVxKSowLjUgICsgMC41O1xuICAgLy8gICAgcmV0dXJuIHZlYzQociwgZywgYiwgMS4wKTtcbiAgIC8vIGBcbi8vIH1cblxuLy8gLy8gZ2VuZXJhdGVzIGdsc2wgZnVuY3Rpb246XG4vLyBgdmVjNCBvc2ModmVjMiBfc3QsIGZsb2F0IGZyZXEsIGZsb2F0IHN5bmMsIGZsb2F0IG9mZnNldCl7XG4vLyAgdmVjMiBzdCA9IF9zdDtcbi8vICBmbG9hdCByID0gc2luKChzdC54LW9mZnNldCoyL2ZyZXErdGltZSpzeW5jKSpmcmVxKSowLjUgICsgMC41O1xuLy8gIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4vLyAgZmxvYXQgYiA9IHNpbigoc3QueCtvZmZzZXQvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4vLyAgcmV0dXJuIHZlYzQociwgZywgYiwgMS4wKTtcbi8vIH1gXG5cbmZ1bmN0aW9uIHByb2Nlc3NGdW5jdGlvbihvYmopIHtcbiAgb2JqLmdsc2xOYW1lIHx8IChvYmouZ2xzbE5hbWUgPSBvYmoubmFtZSk7XG4gIGlmIChvYmoudHlwZSA9PT0gJ2NsZWFyJykgcmV0dXJuIG9iajtcbiAgZWxzZSBpZiAob2JqLnR5cGUgPT09ICd1dGlsJykge1xuICAgIHJldHVybiBwcm9jZXNzR2xzbChvYmosIG9iai5yZXR1cm5UeXBlKTtcbiAgfVxuICBsZXQgdCA9IHR5cGVMb29rdXBbb2JqLnR5cGVdXG4gIGlmKHQpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dsc2wob2JqLCB0LnJldHVyblR5cGUsIHQuYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKGB0eXBlICR7b2JqLnR5cGV9IG5vdCByZWNvZ25pemVkYCwgb2JqKVxuICB9XG5cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0dsc2wob2JqLCByZXR1cm5UeXBlLCBhcmdzID0gW10pIHtcbiAgICBsZXQgYmFzZUFyZ3MgPSBhcmdzLm1hcCgoYXJnKSA9PiBhcmcpLmpvaW4oXCIsIFwiKVxuICAgIGxldCBjdXN0b21BcmdzID0gKG9iai5pbnB1dHMgfHwgKG9iai5pbnB1dHMgPSBbXSkpLm1hcCgoaW5wdXQpID0+IGAke2lucHV0LnR5cGV9ICR7aW5wdXQubmFtZX1gKS5qb2luKCcsICcpXG4gICAgbGV0IGFsbEFyZ3MgPSBgJHtiYXNlQXJnc30ke2N1c3RvbUFyZ3MubGVuZ3RoID4gMCA/ICcsICcrIGN1c3RvbUFyZ3M6ICcnfWBcblxuICAgIGNvbnN0IGZ1bmMgPSBgJHtyZXR1cm5UeXBlIHx8ICcnfSAke29iai5nbHNsTmFtZX0oJHthbGxBcmdzfWA7XG4gICAgY29uc3QgZml4T3JXcmFwID0gKGdsc2wpID0+IHtcbiAgICAgICAgaWYgKGdsc2wuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChnbHNsLmluZGV4T2YoYCR7cmV0dXJuVHlwZX0gbWFpbigke2FsbEFyZ3N9YCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnbHNsLnJlcGxhY2UoYCR7cmV0dXJuVHlwZX0gbWFpbigke2FsbEFyZ3N9YCwgZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLnByaW1pdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJpbWl0aXZlRm4gPSBvYmoucHJpbWl0aXZlLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xzbC5pbmRleE9mKHByaW1pdGl2ZUZuKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2xzbC5yZXBsYWNlKGAke3JldHVyblR5cGV9ICR7cHJpbWl0aXZlRm59KCR7YWxsQXJnc31gLCBmdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAke2Z1bmN9KSB7XG4gICAgICAke2dsc2x9XG4gIH1cbmBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsc2w7XG4gICAgfVxuICAgIG9iai5nbHNsID0gZml4T3JXcmFwKG9iai5nbHNsKTtcbiAgICBpZiAob2JqLnZlcnQpIHtcbiAgICAgICAgb2JqLnZlcnQgPSBmaXhPcldyYXAob2JqLnZlcnQpO1xuICAgIH1cblxuICAgIC8vIGFkZCBleHRyYSBpbnB1dCB0byBiZWdpbm5pbmcgZm9yIGJhY2t3YXJkIGNvbWJhdGliaWxpdHkgQHRvZG8gdXBkYXRlIGNvbXBpbGVyIHNvIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIGlmKG9iai50eXBlID09PSAnY29tYmluZScgfHwgb2JqLnR5cGUgPT09ICdjb21iaW5lQ29vcmQnKSBvYmouaW5wdXRzLnVuc2hpZnQoe1xuICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICB0eXBlOiAndmVjNCdcbiAgICB9KVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvYmosIHsgcmV0dXJuVHlwZSB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBHZW5lcmF0b3JGYWN0b3J5XG4iLCJpbXBvcnQge0J1ZmZlckdlb21ldHJ5fSBmcm9tIFwidGhyZWUvc3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanNcIjtcbmltcG9ydCBnZW5lcmF0ZUdsc2wgZnJvbSAnLi9nZW5lcmF0ZS1nbHNsLmpzJ1xuaW1wb3J0IHV0aWxpdHlHbHNsIGZyb20gJy4vZ2xzbC91dGlsaXR5LWZ1bmN0aW9ucy5qcydcblxudmFyIEdsc2xTb3VyY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHRoaXMudHJhbnNmb3JtcyA9IFtdXG4gIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG9iailcbiAgdGhpcy5kZWZhdWx0T3V0cHV0ID0gb2JqLmRlZmF1bHRPdXRwdXRcbiAgdGhpcy5vdXRwdXQgPSBudWxsXG4gIHRoaXMuc3ludGggPSBvYmouc3ludGhcbiAgdGhpcy50eXBlID0gJ0dsc2xTb3VyY2UnXG4gIHRoaXMuZGVmYXVsdFVuaWZvcm1zID0gb2JqLmRlZmF1bHRVbmlmb3Jtc1xuICB0aGlzLnV0aWxzID0gT2JqZWN0LmFzc2lnbih7fSwgdXRpbGl0eUdsc2wsIG9iai51dGlscyk7XG4gIHRoaXMuYmxlbmRNb2RlID0gdHlwZW9mKG9iai50cmFuc2Zvcm0uYmxlbmRNb2RlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvYmoudHJhbnNmb3JtLmJsZW5kTW9kZSA6IGZhbHNlO1xuICB0aGlzLmxpbmVXaWR0aCA9IG9iai50cmFuc2Zvcm0ubGluZVdpZHRoIHx8IDE7XG4gIHRoaXMuX3ZpZXdwb3J0ID0ge307XG4gIHJldHVybiB0aGlzXG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmFkZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmopICB7XG4gIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG9iailcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUub3V0ID0gZnVuY3Rpb24gKF9vdXRwdXQpIHtcbiAgdmFyIG91dHB1dCA9IF9vdXRwdXQgfHwgdGhpcy5kZWZhdWx0T3V0cHV0XG4gIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICB2YXIgZ2xzbCA9IHRoaXMuZ2xzbCgpXG4gIHRoaXMuc3ludGguY3VycmVudEZ1bmN0aW9ucyA9IFtdXG4gIGlmKG91dHB1dCkgdHJ5e1xuICAgIG91dHB1dC5yZW5kZXIoZ2xzbClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZygnc2hhZGVyIGNvdWxkIG5vdCBjb21waWxlJywgZXJyb3IpXG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnRleCA9IGZ1bmN0aW9uKF9vdXRwdXQpIHtcbiAgaWYgKCF0aGlzLm91dHB1dCkge1xuICAgIHRoaXMub3V0KF9vdXRwdXQpO1xuICB9XG4gIHJldHVybiB0aGlzLm91dHB1dC5yZW5kZXJUZXh0dXJlKCk7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmdsc2wgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIHRoaXMucGFzc2VzID0gW11cbiAgdGhpcy5wYXNzZXMucHVzaCh0aGlzLmNyZWF0ZVBhc3MoZ2VuZXJhdGVHbHNsKHRoaXMpLCBvcHRpb25zKSlcbiAgcmV0dXJuIHRoaXMucGFzc2VzXG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBzaGFkZXJJbmZvID0gZ2VuZXJhdGVHbHNsKHRoaXMpXG4gICAgdmFyIHVuaWZvcm1zID0ge31cbiAgICBzaGFkZXJJbmZvLnVuaWZvcm1zLmZvckVhY2goKHVuaWZvcm0pID0+IHsgdW5pZm9ybXNbdW5pZm9ybS5uYW1lXSA9IHVuaWZvcm0udmFsdWUgfSlcbiAgICByZXR1cm4ge1xuICAgICAgc2hhZGVySW5mbyxcbiAgICAgIHV0aWxpdHlHbHNsOiB0aGlzLnV0aWxzLFxuICAgICAgLy8gdG9kbzogZGlmZmVycyBmcm9tIGNvbXBpbGVcbiAgICAgIHZlcnQ6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCxcbiAgICAgIC8vIHRvZG86IGRpZmZlcnMgZnJvbSBjb21waWxlXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLmF0dHJpYnV0ZXMsXG4gICAgICAvLyB0b2RvOiBkaWZmZXJzIGZyb20gY29tcGlsZVxuICAgICAgYXR0cmlidXRlc0NvdW50OiB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLmF0dHJpYnV0ZXNDb3VudCxcbiAgICAgIHByaW1pdGl2ZTogdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS5wcmltaXRpdmUsXG4gICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0VW5pZm9ybXMsIHVuaWZvcm1zKVxuICAgIH07XG4gIH1cbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuY3JlYXRlUGFzcyA9IGZ1bmN0aW9uKHNoYWRlckluZm8sIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgdW5pZm9ybXMgPSB7fVxuICBzaGFkZXJJbmZvLnVuaWZvcm1zLmZvckVhY2goKHVuaWZvcm0pID0+IHsgdW5pZm9ybXNbdW5pZm9ybS5uYW1lXSA9IHVuaWZvcm0udmFsdWUgfSlcblxuICBpZiAoc2hhZGVySW5mby5jb21iaW5lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnQ6IEdsc2xTb3VyY2UuY29tcGlsZVZlcnQodGhpcy5kZWZhdWx0T3V0cHV0LnByZWNpc2lvbiwgZmFsc2UsIHtcbiAgICAgICAgZ2xzbE5hbWU6ICdjb21iaW5lJyxcbiAgICAgIH0sIHNoYWRlckluZm8pLFxuICAgICAgdXNlckFyZ3M6IHRoaXMudHJhbnNmb3Jtc1swXS51c2VyQXJncyxcbiAgICAgIC8vIHRvZG86IGZpeCBvciBkZWxldGVcbiAgICAgIC8vIGJsZW5kTW9kZTogdGhpcy5ibGVuZE1vZGUsXG4gICAgICBsaW5lV2lkdGg6IHRoaXMubGluZVdpZHRoLFxuICAgICAgZnJhZzogR2xzbFNvdXJjZS5jb21waWxlRnJhZyh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRVbmlmb3JtcywgdW5pZm9ybXMpLFxuICAgICAgdmlld3BvcnQ6IHRoaXMuX3ZpZXdwb3J0LFxuICAgIH07XG4gIH1cblxuICBjb25zdCB2ZXJ0VHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS50eXBlID09PSAnY2xlYXInID8gdGhpcy50cmFuc2Zvcm1zWzFdIDogdGhpcy50cmFuc2Zvcm1zWzBdO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCB0cnVlLCB2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybSwgc2hhZGVySW5mbywgdGhpcy51dGlscyksXG4gICAgcHJpbWl0aXZlOiB2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5wcmltaXRpdmUsXG4gICAgdXNlckFyZ3M6IHZlcnRUcmFuc2Zvcm0udXNlckFyZ3MsXG4gICAgZ2VvbWV0cnk6IHRoaXMuZ2VvbWV0cnksXG4gICAgYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcbiAgICBsaW5lV2lkdGg6IHRoaXMubGluZVdpZHRoLFxuICAgIGZyYWc6IEdsc2xTb3VyY2UuY29tcGlsZUZyYWcodGhpcy5kZWZhdWx0T3V0cHV0LnByZWNpc2lvbiwgc2hhZGVySW5mbywgdGhpcy51dGlscyksXG4gICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3JtcyksXG4gICAgdmlld3BvcnQ6IHRoaXMuX3ZpZXdwb3J0LFxuICB9LCBvcHRpb25zKVxufVxuXG5HbHNsU291cmNlLmNvbXBpbGVIZWFkZXIgPSBmdW5jdGlvbihwcmVjaXNpb24sIHVuaWZvcm1zID0ge30sIHV0aWxzID0ge30pIHtcbiAgcmV0dXJuIGBcbiAgcHJlY2lzaW9uICR7cHJlY2lzaW9ufSBmbG9hdDtcbiAgJHtPYmplY3QudmFsdWVzKHVuaWZvcm1zKS5tYXAoKHVuaWZvcm0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHVuaWZvcm0udHlwZVxuICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKSB7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtLm5hbWV9O2BcbiAgfSkuam9pbignJyl9XG4gIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gIHZhcnlpbmcgdmVjMiB2dXY7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHByZXZCdWZmZXI7XG4gIFxuICAke09iamVjdC52YWx1ZXModXRpbHMpLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgLy8gIGNvbnNvbGUubG9nKHRyYW5zZm9ybS5nbHNsKVxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgfSkuam9pbignJyl9XG4gIGBcbn1cblxuR2xzbFNvdXJjZS5jb21waWxlRnJhZyA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgc2hhZGVySW5mbywgdXRpbHMpIHtcbiAgY29uc3QgaGVhZGVyID0gdGhpcy5jb21waWxlSGVhZGVyKHByZWNpc2lvbiwgc2hhZGVySW5mby51bmlmb3JtcywgdXRpbHMpO1xuICByZXR1cm4gaGVhZGVyICsgYFxuICBcbiAgJHtzaGFkZXJJbmZvLmdsc2xGdW5jdGlvbnMubWFwKCh0cmFuc2Zvcm0pID0+IHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHt0cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2x9XG4gICAgICAgICAgYFxuICB9KS5qb2luKCcnKX1cblxuICB2b2lkIG1haW4gKCkge1xuICAgIHZlYzQgYyA9IHZlYzQoMSwgMCwgMCwgMSk7XG4gICAgLy92ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3Jlc29sdXRpb24ueHk7XG4gICAgdmVjMiBzdCA9IHZ1djtcbiAgICBnbF9GcmFnQ29sb3IgPSAke3NoYWRlckluZm8uZnJhZ0NvbG9yfTtcbiAgfVxuICBgXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZVZlcnQgPSBmdW5jdGlvbihwcmVjaXNpb24sIHVzZUNhbWVyYSwgdHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB1dGlscykge1xuICBjb25zdCB1c2VVViA9IHR5cGVvZih0cmFuc2Zvcm0udXNlVVYpICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyB0cmFuc2Zvcm0udXNlVVZcbiAgICAgIDogWydwb2ludHMnLCAnbGluZXMnLCAnbGluZSBzdHJpcCcsICdsaW5lIGxvb3AnXS5pbmRleE9mKHRyYW5zZm9ybS5wcmltaXRpdmUpID09PSAtMTtcbiAgbGV0IHZlcnRIZWFkZXIgPSBgXG4gIHByZWNpc2lvbiAke3ByZWNpc2lvbn0gZmxvYXQ7XG4gIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uLCB2aWV3O1xuICBhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcbiAgJHt1c2VVViA/ICdhdHRyaWJ1dGUgdmVjMiB1djsnIDogJyd9XG4gIHZhcnlpbmcgdmVjMiB2dXY7XG4gIGBcbiAgbGV0IHZlcnRGbiA9IGBcbiAgdm9pZCAke3RyYW5zZm9ybS5nbHNsTmFtZX0oKSB7XG4gICAgZ2xfUG9zaXRpb24gPSAke3VzZUNhbWVyYSA/ICdwcm9qZWN0aW9uICogdmlldyAqICcgOiAnJ312ZWM0KHBvc2l0aW9uLCAxLjApO1xuICB9IFxuICBgXG4gIGxldCB2ZXJ0Q2FsbCA9IGAke3RyYW5zZm9ybS5nbHNsTmFtZX0oKTtgO1xuICBpZiAodHJhbnNmb3JtLnZlcnQpIHtcbiAgICB2ZXJ0SGVhZGVyID0gdGhpcy5jb21waWxlSGVhZGVyKHByZWNpc2lvbiwgc2hhZGVySW5mby51bmlmb3JtcywgdXRpbHMpICsgYFxuICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uLCB2aWV3O1xuICAgIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICAgICR7dXNlVVYgPyAnYXR0cmlidXRlIHZlYzIgdXY7JyA6ICcnfVxuICAgIGF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcbiAgICBcbiAgICAke3NoYWRlckluZm8uZ2xzbEZ1bmN0aW9ucy5tYXAoKHRyYW5zKSA9PiB7XG4gICAgICBpZiAodHJhbnMudHJhbnNmb3JtLm5hbWUgIT09IHRyYW5zZm9ybS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zLnRyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKX1cbiAgICBgXG4gICAgdmVydEZuID0gdHJhbnNmb3JtLnZlcnQ7XG4gICAgdmVydENhbGwgPSBgXG4gICAgJHt1c2VVViA/ICd2ZWMyIHN0ID0gdXY7JyA6ICd2ZWMyIHN0ID0gcG9zaXRpb24ueHk7J31cbiAgICB2ZWM0IHBvcyA9ICR7c2hhZGVySW5mby5wb3NpdGlvbn07XG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogdmlldyAqIHBvcztcbiAgICBgO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRIZWFkZXIgKyBgXG4gICAgXG4gICR7dmVydEZufVxuXG4gIHZvaWQgbWFpbiAoKSB7XG4gICAgJHt1c2VVViA/ICd2dXYgPSB1djsnIDogJyd9XG4gICAgJHt2ZXJ0Q2FsbH1cbiAgfWBcbn1cblxuLy8gdG9kbzogbWFrZSBoeWRyYS1zeW50aCBmdW5jdGlvblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuc2V0QmxlbmQgPSBmdW5jdGlvbihibGVuZE1vZGUgPSB0cnVlKSB7XG4gIHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICByZXR1cm4gdGhpcztcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuc2V0TGluZVdpZHRoID0gZnVuY3Rpb24obGluZVdpZHRoKSB7XG4gIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICByZXR1cm4gdGhpcztcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuc2V0R2VvbWV0cnkgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoIWlucHV0KSBpbnB1dCA9IFtdO1xuICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlckdlb21ldHJ5IHx8IGlucHV0LmlzQnVmZmVyR2VvbWV0cnkpKSB7XG4gICAgY29uc3QgdmVydFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udHlwZSA9PT0gJ2NsZWFyJyA/IHRoaXMudHJhbnNmb3Jtc1sxXSA6IHRoaXMudHJhbnNmb3Jtc1swXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSBpbnB1dCA9IFtpbnB1dF07XG4gICAgaWYgKHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLmdlb21ldHJ5ID09PSBHcmlkR2VvbWV0cnkgJiYgdmVydFRyYW5zZm9ybS50cmFuc2Zvcm0ucHJpbWl0aXZlICYmIHR5cGVvZihpbnB1dFswXSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dC51bnNoaWZ0KHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSk7XG4gICAgfVxuICAgIGlucHV0ID0gbmV3ICh2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5nZW9tZXRyeSkoLi4uaW5wdXQpO1xuICB9XG4gIHRoaXMuZ2VvbWV0cnkgPSBpbnB1dDtcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUudmlld3BvcnQgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gIHRoaXMuX3ZpZXdwb3J0ID0ge3gsIHksIHcsIGh9O1xuICByZXR1cm4gdGhpcztcbn1cblxuY29uc3QgZ2xzbFByb3BzID0gWyd4JywgJ3knLCAneicsICd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eScsICd4eXonLCAneHl6dyddO1xuZ2xzbFByb3BzLm1hcCgocHJvcCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR2xzbFNvdXJjZS5wcm90b3R5cGUsIHByb3AsIHtcbiAgICBnZXQoKSB7XG4gICAgICB0aGlzLmdldHRlciA9IHByb3A7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEdsc2xTb3VyY2VcbiIsImltcG9ydCB7QnVmZmVyR2VvbWV0cnl9IGZyb20gXCJ0aHJlZS9zcmMvY29yZS9CdWZmZXJHZW9tZXRyeVwiO1xuaW1wb3J0IHtGbG9hdDMyQnVmZmVyQXR0cmlidXRlfSBmcm9tIFwidGhyZWUvc3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlXCI7XG5cbmNsYXNzIEdyaWRHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy50eXBlID0gJ0dyaWRHZW9tZXRyeSc7XG5cbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgcHJpbWl0aXZlOiB0eXBlLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCB2ZXJ0aWNlcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwb2ludHMnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGggfHwgKHdpZHRoID0gMSk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IHx8IChoZWlnaHQgPSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gRmxvYXQzMkFycmF5LmZyb20oe2xlbmd0aDogY291bnQgKiAzfSwgKHYsIGspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrJTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrKzEpIC8gMyAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKE1hdGguZmxvb3IoKGstMSkgLyAzIC8gd2lkdGgpKzAuNSkgLyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaW5lcyc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgfHwgKGhlaWdodCA9IDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gMiAqICh3aWR0aCArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA8ICh3aWR0aCAqIDYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoayszKSAvIDYgJSB3aWR0aCAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrKSAvIDYgJSB3aWR0aCAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGsrMikgLyA2ICUgaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrLTEpIC8gNiAlIGhlaWdodCAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpbmUgc3RyaXAnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGggfHwgKHdpZHRoID0gMTApO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZWQgPSB0eXBlb2Yob3B0aW9ucykgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiB3aWxsIGJlIE5hTiB3aGVuIHBvaW50c1swXSA9PSAxXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IG1pbmltdW0gMiBwb2ludHM/XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrIC8gMyAlIHdpZHRoIC8gKHdpZHRoLWNsb3NlZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChrLTEpIC8gMyAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGluZSBsb29wJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoIHx8ICh3aWR0aCA9IDEwKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgfHwgKGhlaWdodCA9IDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoayAvIDMgJSB3aWR0aCAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoay0xKSAvIDMgLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgaW52YWxpZCBHcmlkR2VvbWV0cnkgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cbiAgICB9XG59XG5cbmV4cG9ydCB7IEdyaWRHZW9tZXRyeSB9OyIsIi8qXG5Gb3JtYXQgZm9yIGFkZGluZyBmdW5jdGlvbnMgdG8gaHlkcmEuIEZvciBlYWNoIGVudHJ5IGluIHRoaXMgZmlsZSwgaHlkcmEgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgYSBnbHNsIGZ1bmN0aW9uIGFuZCBqYXZhc2NyaXB0IGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZS4gWW91IGNhbiBhbHNvIGFzcyBmdW5jdGlvbnMgZHluYW1pY2FsbHkgdXNpbmcgc2V0RnVuY3Rpb24ob2JqZWN0KS5cblxue1xuICBuYW1lOiAnb3NjJywgLy8gbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBhY2Nlc3MgZnVuY3Rpb24gaW4ganMgYXMgd2VsbCBhcyBpbiBnbHNsXG4gIHR5cGU6ICdzcmMnLCAvLyBjYW4gYmUgJ3NyYycsICdjb2xvcicsICdjb21iaW5lJywgJ2NvbWJpbmVDb29yZHMnLiBzZWUgYmVsb3cgZm9yIG1vcmUgaW5mb1xuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZnJlcScsXG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgZGVmYXVsdDogMC4yXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3luYycsXG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjBcbiAgICB9XG4gIF0sXG4gICAgZ2xzbDogYFxuICAgICAgdmVjMiBzdCA9IF9zdDtcbiAgICAgIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAgICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcSkqMC41ICsgMC41O1xuICAgICAgZmxvYXQgYiA9IHNpbigoc3QueCtvZmZzZXQvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAgICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuICAgYFxufVxuXG4vLyBUaGUgYWJvdmUgY29kZSBnZW5lcmF0ZXMgdGhlIGdsc2wgZnVuY3Rpb246XG5gdmVjNCBvc2ModmVjMiBfc3QsIGZsb2F0IGZyZXEsIGZsb2F0IHN5bmMsIGZsb2F0IG9mZnNldCl7XG4gdmVjMiBzdCA9IF9zdDtcbiBmbG9hdCByID0gc2luKChzdC54LW9mZnNldCoyL2ZyZXErdGltZSpzeW5jKSpmcmVxKSowLjUgICsgMC41O1xuIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4gZmxvYXQgYiA9IHNpbigoc3QueCtvZmZzZXQvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gcmV0dXJuIHZlYzQociwgZywgYiwgMS4wKTtcbn1gXG5cblxuVHlwZXMgYW5kIGRlZmF1bHQgYXJndW1lbnRzIGZvciBoeWRyYSBmdW5jdGlvbnMuXG5UaGUgdmFsdWUgaW4gdGhlICd0eXBlJyBmaWVsZCBsZXRzIHRoZSBwYXJzZXIga25vdyB3aGljaCB0eXBlIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHJldHVybmVkIGFzIHdlbGwgYXMgZGVmYXVsdCBhcmd1bWVudHMuXG5cbmNvbnN0IHR5cGVzID0ge1xuICAnc3JjJzoge1xuICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgfSxcbiAgJ2Nvb3JkJzoge1xuICAgIHJldHVyblR5cGU6ICd2ZWMyJyxcbiAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgfSxcbiAgJ2NvbG9yJzoge1xuICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICBhcmdzOiBbJ3ZlYzQgX2MwJ11cbiAgfSxcbiAgJ2NvbWJpbmUnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjNCBfYzAnLCAndmVjNCBfYzEnXVxuICB9LFxuICAnY29tYmluZUNvb3JkJzoge1xuICAgIHJldHVyblR5cGU6ICd2ZWMyJyxcbiAgICBhcmdzOiBbJ3ZlYzIgX3N0JywgJ3ZlYzQgX2MwJ11cbiAgfVxufVxuXG4qL1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiBbXG4gIHtcbiAgICBuYW1lOiAnY2xlYXInLFxuICAgIHR5cGU6ICdjbGVhcicsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBnbHNsOiBgYCxcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdmYWRlJyxcbiAgICB0eXBlOiAnY2xlYXInLFxuICAgIGlucHV0czogW1xuICAgICAgICB7bmFtZTogJ2Ftb3VudCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6ICcwLjAxJ30sXG4gICAgICAgIHtuYW1lOiAnY2FtZXJhJywgdHlwZTogJ2Jvb2wnLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgXSxcbiAgICBnbHNsOiBgYCxcbiAgfSxcbiAge1xuICBuYW1lOiAnbm9pc2UnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNCh2ZWMzKF9ub2lzZSh2ZWMzKF9zdCpzY2FsZSwgb2Zmc2V0KnRpbWUpKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3Zvcm9ub2knLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdibGVuZGluZycsXG4gICAgICBkZWZhdWx0OiAwLjMsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzMgY29sb3IgPSB2ZWMzKC4wKTtcbiAgIC8vIFNjYWxlXG4gICBfc3QgKj0gc2NhbGU7XG4gICAvLyBUaWxlIHRoZSBzcGFjZVxuICAgdmVjMiBpX3N0ID0gZmxvb3IoX3N0KTtcbiAgIHZlYzIgZl9zdCA9IGZyYWN0KF9zdCk7XG4gICBmbG9hdCBtX2Rpc3QgPSAxMC47ICAvLyBtaW5pbXVuIGRpc3RhbmNlXG4gICB2ZWMyIG1fcG9pbnQ7ICAgICAgICAvLyBtaW5pbXVtIHBvaW50XG4gICBmb3IgKGludCBqPS0xOyBqPD0xOyBqKysgKSB7XG4gICBmb3IgKGludCBpPS0xOyBpPD0xOyBpKysgKSB7XG4gICB2ZWMyIG5laWdoYm9yID0gdmVjMihmbG9hdChpKSxmbG9hdChqKSk7XG4gICB2ZWMyIHAgPSBpX3N0ICsgbmVpZ2hib3I7XG4gICB2ZWMyIHBvaW50ID0gZnJhY3Qoc2luKHZlYzIoZG90KHAsdmVjMigxMjcuMSwzMTEuNykpLGRvdChwLHZlYzIoMjY5LjUsMTgzLjMpKSkpKjQzNzU4LjU0NTMpO1xuICAgcG9pbnQgPSAwLjUgKyAwLjUqc2luKHRpbWUqc3BlZWQgKyA2LjI4MzEqcG9pbnQpO1xuICAgdmVjMiBkaWZmID0gbmVpZ2hib3IgKyBwb2ludCAtIGZfc3Q7XG4gICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpO1xuICAgaWYoIGRpc3QgPCBtX2Rpc3QgKSB7XG4gICBtX2Rpc3QgPSBkaXN0O1xuICAgbV9wb2ludCA9IHBvaW50O1xuICAgfVxuICAgfVxuICAgfVxuICAgLy8gQXNzaWduIGEgY29sb3IgdXNpbmcgdGhlIGNsb3Nlc3QgcG9pbnQgcG9zaXRpb25cbiAgIGNvbG9yICs9IGRvdChtX3BvaW50LHZlYzIoLjMsLjYpKTtcbiAgIGNvbG9yICo9IDEuMCAtIGJsZW5kaW5nKm1fZGlzdDtcbiAgIHJldHVybiB2ZWM0KGNvbG9yLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdvc2MnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdmcmVxdWVuY3knLFxuICAgICAgZGVmYXVsdDogNjAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3luYycsXG4gICAgICBkZWZhdWx0OiAwLjEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3Q7XG4gICBmbG9hdCByID0gc2luKChzdC54LW9mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcXVlbmN5KSowLjUgKyAwLjU7XG4gICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdzaGFwZScsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NpZGVzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzbW9vdGhpbmcnLFxuICAgICAgZGVmYXVsdDogMC4wMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIDIuIC0gMS47XG4gICAvLyBBbmdsZSBhbmQgcmFkaXVzIGZyb20gdGhlIGN1cnJlbnQgcGl4ZWxcbiAgIGZsb2F0IGEgPSBhdGFuKHN0Lngsc3QueSkrMy4xNDE2O1xuICAgZmxvYXQgciA9ICgyLiozLjE0MTYpL3NpZGVzO1xuICAgZmxvYXQgZCA9IGNvcyhmbG9vciguNSthL3IpKnItYSkqbGVuZ3RoKHN0KTtcbiAgIHJldHVybiB2ZWM0KHZlYzMoMS4wLXNtb290aHN0ZXAocmFkaXVzLHJhZGl1cyArIHNtb290aGluZyArIDAuMDAwMDAwMSxkKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ2dyYWRpZW50JyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX3N0LCBzaW4odGltZSpzcGVlZCksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3NyYycsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgIG5hbWU6ICd0ZXgnLFxuICAgICAgZGVmYXVsdDogTmFOLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eS92ZWMyKDEyODAuLCA3MjAuKTtcbiAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCBmcmFjdChfc3QpKTtgXG59LFxue1xuICBuYW1lOiAnc29saWQnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnZycsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2InLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIGEpO2Bcbn0sXG57XG4gIG5hbWU6ICdyb3RhdGUnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2FuZ2xlJyxcbiAgICAgIGRlZmF1bHQ6IDEwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgdmVjMiB4eSA9IF9zdCAtIHZlYzIoMC41KTtcbiAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICBmbG9hdCBhbmcgPSBhbmdsZSAqICgzLjE0MTU5MjY1MzU4OTc5MyAvIDE4MC4wKTtcbiAgIGFuZyA9IGFuZyArIHNwZWVkICp0aW1lO1xuICAgeHkgPSBtYXQyKGNvcyhhbmcpLC1zaW4oYW5nKSwgc2luKGFuZyksY29zKGFuZykpKnh5O1xuICAgeHkgKz0gMC41O1xuICAgcmV0dXJuIHh5O2Bcbn0sXG57XG4gIG5hbWU6ICdzY2FsZScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd4TXVsdCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3lNdWx0JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WScsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSBfc3QgLSB2ZWMyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgeHkqPSgxLjAvdmVjMihhbW91bnQqeE11bHQsIGFtb3VudCp5TXVsdCkpO1xuICAgeHkrPXZlYzIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICByZXR1cm4geHk7XG4gICBgXG59LFxue1xuICBuYW1lOiAncGl4ZWxhdGUnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3BpeGVsWCcsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdwaXhlbFknLFxuICAgICAgZGVmYXVsdDogMjAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSB2ZWMyKHBpeGVsWCwgcGl4ZWxZKTtcbiAgIHJldHVybiAoZmxvb3IoX3N0ICogeHkpICsgMC41KS94eTtgXG59LFxue1xuICBuYW1lOiAncG9zdGVyaXplJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiaW5zJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnZ2FtbWEnLFxuICAgICAgZGVmYXVsdDogMC42LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMyID0gcG93KF9jMCwgdmVjNChnYW1tYSkpO1xuICAgYzIgKj0gdmVjNChiaW5zKTtcbiAgIGMyID0gZmxvb3IoYzIpO1xuICAgYzIvPSB2ZWM0KGJpbnMpO1xuICAgYzIgPSBwb3coYzIsIHZlYzQoMS4wL2dhbW1hKSk7XG4gICByZXR1cm4gdmVjNChjMi54eXosIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnc2hpZnQnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3InLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2cnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYScsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMyID0gdmVjNChfYzApO1xuICAgYzIuciA9IGZyYWN0KGMyLnIgKyByKTtcbiAgIGMyLmcgPSBmcmFjdChjMi5nICsgZyk7XG4gICBjMi5iID0gZnJhY3QoYzIuYiArIGIpO1xuICAgYzIuYSA9IGZyYWN0KGMyLmEgKyBhKTtcbiAgIHJldHVybiB2ZWM0KGMyLnJnYmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdyZXBlYXQnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcGVhdFgnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBlYXRZJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFknLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwZWF0WCwgcmVwZWF0WSk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpICogb2Zmc2V0WDtcbiAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSkgKiBvZmZzZXRZO1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSZXBlYXQnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBlYXRYJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwZWF0WScsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBlYXRYLCByZXBlYXRZKTtcbiAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSkgKyBfYzAuciAqIG9mZnNldFg7XG4gICBzdC55ICs9IHN0ZXAoMS4sIG1vZChzdC54LDIuMCkpICsgX2MwLmcgKiBvZmZzZXRZO1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAncmVwZWF0WCcsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBzLCAxLjApO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC55ICs9IHN0ZXAoMS4sIG1vZChzdC54LDIuMCkpKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJlcGVhdFgnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwcywgMS4wKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKSArIF9jMC5yICogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAncmVwZWF0WScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMigxLjAsIHJlcHMpO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJlcGVhdFknLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwcywgMS4wKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueCArPSBzdGVwKDEuLCBtb2Qoc3QueSwyLjApKSArIF9jMC5yICogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAna2FsZWlkJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICduU2lkZXMnLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdDtcbiAgIHN0IC09IDAuNTtcbiAgIGZsb2F0IHIgPSBsZW5ndGgoc3QpO1xuICAgZmxvYXQgYSA9IGF0YW4oc3QueSwgc3QueCk7XG4gICBmbG9hdCBwaSA9IDIuKjMuMTQxNjtcbiAgIGEgPSBtb2QoYSxwaS9uU2lkZXMpO1xuICAgYSA9IGFicyhhLXBpL25TaWRlcy8yLik7XG4gICByZXR1cm4gcip2ZWMyKGNvcyhhKSwgc2luKGEpKTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVLYWxlaWQnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICduU2lkZXMnLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAtIDAuNTtcbiAgIGZsb2F0IHIgPSBsZW5ndGgoc3QpO1xuICAgZmxvYXQgYSA9IGF0YW4oc3QueSwgc3QueCk7XG4gICBmbG9hdCBwaSA9IDIuKjMuMTQxNjtcbiAgIGEgPSBtb2QoYSxwaS9uU2lkZXMpO1xuICAgYSA9IGFicyhhLXBpL25TaWRlcy8yLik7XG4gICByZXR1cm4gKF9jMC5yK3IpKnZlYzIoY29zKGEpLCBzaW4oYSkpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGwnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkWCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkWScsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmBcbiAgIF9zdC54ICs9IHNjcm9sbFggKyB0aW1lKnNwZWVkWDtcbiAgIF9zdC55ICs9IHNjcm9sbFkgKyB0aW1lKnNwZWVkWTtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGxYJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueCArPSBzY3JvbGxYICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVNjcm9sbFgnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueCArPSBfYzAucipzY3JvbGxYICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGxZJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueSArPSBzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVNjcm9sbFknLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueSArPSBfYzAucipzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdhZGQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiAoX2MwK19jMSkqYW1vdW50ICsgX2MwKigxLjAtYW1vdW50KTtgXG59LFxue1xuICBuYW1lOiAnc3ViJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gKF9jMC1fYzEpKmFtb3VudCArIF9jMCooMS4wLWFtb3VudCk7YFxufSxcbntcbiAgbmFtZTogJ2xheWVyJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcblxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KG1peChfYzAucmdiLCBfYzEucmdiLCBfYzEuYSksIGNsYW1wKF9jMC5hICsgX2MxLmEsIDAuMCwgMS4wKSk7YFxufSxcbntcbiAgbmFtZTogJ2JsZW5kJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpK19jMSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ211bHQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpKyhfYzAqX2MxKSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ2RpZmYnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoYWJzKF9jMC5yZ2ItX2MxLnJnYiksIG1heChfYzAuYSwgX2MxLmEpKTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgcmV0dXJuIGZyYWN0KHN0KyhfYzAueHktMC41KSphbW91bnQpO1xuICAgcmV0dXJuIF9zdCArIF9jMC54eSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2NhbGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgeHkqPSgxLjAvdmVjMihvZmZzZXQgKyBtdWx0aXBsZSpfYzAuciwgb2Zmc2V0ICsgbXVsdGlwbGUqX2MwLmcpKTtcbiAgIHh5Kz12ZWMyKDAuNSk7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUGl4ZWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiB4eSA9IHZlYzIob2Zmc2V0ICsgX2MwLngqbXVsdGlwbGUsIG9mZnNldCArIF9jMC55Km11bHRpcGxlKTtcbiAgIHJldHVybiAoZmxvb3IoX3N0ICogeHkpICsgMC41KS94eTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSb3RhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgZmxvYXQgYW5nbGUgPSBvZmZzZXQgKyBfYzAueCAqIG11bHRpcGxlO1xuICAgeHkgPSBtYXQyKGNvcyhhbmdsZSksLXNpbihhbmdsZSksIHNpbihhbmdsZSksY29zKGFuZ2xlKSkqeHk7XG4gICB4eSArPSAwLjU7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlSHVlJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfc3QgKyAodmVjMihfYzAuZyAtIF9jMC5yLCBfYzAuYiAtIF9jMC5nKSAqIGFtb3VudCAqIDEuMC9yZXNvbHV0aW9uKTtgXG59LFxue1xuICBuYW1lOiAnaW52ZXJ0JyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoKDEuMC1fYzAucmdiKSphbW91bnQgKyBfYzAucmdiKigxLjAtYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb250cmFzdCcsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEuNixcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCBjID0gKF9jMC12ZWM0KDAuNSkpKnZlYzQoYW1vdW50KSArIHZlYzQoMC41KTtcbiAgIHJldHVybiB2ZWM0KGMucmdiLCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ2JyaWdodG5lc3MnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5yZ2IgKyB2ZWMzKGFtb3VudCksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnbWFzaycsXG4gIHR5cGU6ICdjb21iaW5lJyxcbiAgaW5wdXRzOiBbXG5cbiAgXSxcbiAgZ2xzbDpcbiAgYCAgIGZsb2F0IGEgPSBfbHVtaW5hbmNlKF9jMS5yZ2IpO1xuICByZXR1cm4gdmVjNChfYzAucmdiKmEsIGEqX2MwLmEpO2Bcbn0sXG5cbntcbiAgbmFtZTogJ2x1bWEnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3RocmVzaG9sZCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndG9sZXJhbmNlJyxcbiAgICAgIGRlZmF1bHQ6IDAuMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgZmxvYXQgYSA9IHNtb290aHN0ZXAodGhyZXNob2xkLSh0b2xlcmFuY2UrMC4wMDAwMDAxKSwgdGhyZXNob2xkKyh0b2xlcmFuY2UrMC4wMDAwMDAxKSwgX2x1bWluYW5jZShfYzAucmdiKSk7XG4gICByZXR1cm4gdmVjNChfYzAucmdiKmEsIGEpO2Bcbn0sXG57XG4gIG5hbWU6ICd0aHJlc2gnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3RocmVzaG9sZCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndG9sZXJhbmNlJyxcbiAgICAgIGRlZmF1bHQ6IDAuMDQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHZlYzMoc21vb3Roc3RlcCh0aHJlc2hvbGQtKHRvbGVyYW5jZSswLjAwMDAwMDEpLCB0aHJlc2hvbGQrKHRvbGVyYW5jZSswLjAwMDAwMDEpLCBfbHVtaW5hbmNlKF9jMC5yZ2IpKSksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnY29sb3InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3InLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdnJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYicsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2EnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCBjID0gdmVjNChyLCBnLCBiLCBhKTtcbiAgIHZlYzQgcG9zID0gc3RlcCgwLjAsIGMpOyAvLyBkZXRlY3Qgd2hldGhlciBuZWdhdGl2ZVxuICAgLy8gaWYgPiAwLCByZXR1cm4gciAqIF9jMFxuICAgLy8gaWYgPCAwIHJldHVybiAoMS4wLXIpICogX2MwXG4gICByZXR1cm4gdmVjNChtaXgoKDEuMC1fYzApKmFicyhjKSwgYypfYzAsIHBvcykpO2Bcbn0sXG57XG4gIG5hbWU6ICdzYXR1cmF0ZScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIGNvbnN0IHZlYzMgVyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XG4gICB2ZWMzIGludGVuc2l0eSA9IHZlYzMoZG90KF9jMC5yZ2IsIFcpKTtcbiAgIHJldHVybiB2ZWM0KG1peChpbnRlbnNpdHksIF9jMC5yZ2IsIGFtb3VudCksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnaHVlJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdodWUnLFxuICAgICAgZGVmYXVsdDogMC40LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMzIGMgPSBfcmdiVG9Ic3YoX2MwLnJnYik7XG4gICBjLnIgKz0gaHVlO1xuICAgLy8gIGMuciA9IGZyYWN0KGMucik7XG4gICByZXR1cm4gdmVjNChfaHN2VG9SZ2IoYyksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnY29sb3JhbWEnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjAwNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMyBjID0gX3JnYlRvSHN2KF9jMC5yZ2IpO1xuICAgYyArPSB2ZWMzKGFtb3VudCk7XG4gICBjID0gX2hzdlRvUmdiKGMpO1xuICAgYyA9IGZyYWN0KGMpO1xuICAgcmV0dXJuIHZlYzQoYywgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdwcmV2JyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHRleHR1cmUyRChwcmV2QnVmZmVyLCBmcmFjdChfc3QpKTtgXG59LFxue1xuICBuYW1lOiAnc3VtJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ3ZlYzQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzQgdiA9IF9jMCAqIHM7XG4gICByZXR1cm4gdi5yICsgdi5nICsgdi5iICsgdi5hO1xuICAgfVxuICAgZmxvYXQgc3VtKHZlYzIgX3N0LCB2ZWM0IHMpIHsgLy8gdmVjNCBpcyBub3QgYSB0eXBvLCBiZWNhdXNlIGFyZ3VtZW50IHR5cGUgaXMgbm90IG92ZXJsb2FkZWRcbiAgIHZlYzIgdiA9IF9zdC54eSAqIHMueHk7XG4gICByZXR1cm4gdi54ICsgdi55O2Bcbn0sXG57XG4gIG5hbWU6ICdyJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuciAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICBuYW1lOiAnZycsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLmcgKiBzY2FsZSArIG9mZnNldCk7YFxufSxcbntcbiAgbmFtZTogJ2InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5iICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG57XG4gIG5hbWU6ICdhJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuYSAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICAgIG5hbWU6ICdtYXAnLFxuICAgIHR5cGU6ICdjb2xvcicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtuYW1lOiAnc3RhcnQxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogTmFOfSxcbiAgICAgICAge25hbWU6ICdzdG9wMScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IE5hTn0sXG4gICAgICAgIHtuYW1lOiAnc3RhcnQyJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMH0sXG4gICAgICAgIHtuYW1lOiAnc3RvcDInLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICBdLFxuICAgIGdsc2w6IGByZXR1cm4gKF9jMCAtIHN0YXJ0MSkgLyAoc3RvcDEgLSBzdGFydDEpICogKHN0b3AyIC0gc3RhcnQyKSArIHN0YXJ0MjtgXG59LFxuXG4gICAgLy8gdG9kbzogbWFrZSB0aGVzZSB0eXBlOiAndXRpbCcgc28gdGhleSBhcmUgdHlwZSBhZ25vc3RpYz9cbiAgICB7XG4gICAgICAgIG5hbWU6ICdzaW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19zaW4nLFxuICAgICAgICB0eXBlOiAnY29vcmQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZnJlcScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIHNpbihfc3QgKiBUV09fUEkgKiBmcmVxKSAqIGFtcDtgLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnY29zJyxcbiAgICAgICAgZ2xzbE5hbWU6ICdfY29zJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb3MoX3N0ICogVFdPX1BJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3RhbicsXG4gICAgICAgIGdsc2xOYW1lOiAnX3RhbicsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdmcmVxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2F0YW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19hdGFuJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBhdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3BvdycsXG4gICAgICAgIGdsc2xOYW1lOiAnX3BvdycsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3dlcicsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogMn0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gcG93KF9zdCwgcG93ZXIpO2BcbiAgICB9XG5dXG4iLCIvLyBmdW5jdGlvbnMgdGhhdCBhcmUgb25seSB1c2VkIHdpdGhpbiBvdGhlciBmdW5jdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfcGk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYCNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1YCxcbiAgfSxcbiAgX3R3b3BpOiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGAjZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE3OTU4NmAsXG4gIH0sXG4gIF9sdW1pbmFuY2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYGZsb2F0IF9sdW1pbmFuY2UodmVjMyByZ2Ipe1xuICAgICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcbiAgICAgIHJldHVybiBkb3QocmdiLCBXKTtcbiAgICB9YFxuICB9LFxuICBfcGVybXV0ZToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgdmVjNCBfcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31gXG4gIH0sXG4gIF9tb2QyODk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxudmVjMyBfbW9kMjg5KHZlYzMgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cblxudmVjNCBfbW9kMjg5KHZlYzQgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cbmBcbiAgfSxcbiAgX3RheWxvckludlNxcnQ6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzQgX3RheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31gXG4gIH0sXG4gIC8vXHRTaW1wbGV4IDNEIE5vaXNlXG4gIC8vXHRieSBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0c1xuICBfbm9pc2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxuICBmbG9hdCBfbm9pc2UodmVjMyB2KXtcbiAgICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XG4gICAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcblxuICAvLyBGaXJzdCBjb3JuZXJcbiAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcbiAgICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xuXG4gIC8vIE90aGVyIGNvcm5lcnNcbiAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcbiAgICB2ZWMzIGwgPSAxLjAgLSBnO1xuICAgIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xuICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xuXG4gICAgLy8gIHgwID0geDAgLSAwLiArIDAuMCAqIENcbiAgICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xuICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgMi4wICogQy54eHg7XG4gICAgdmVjMyB4MyA9IHgwIC0gMS4gKyAzLjAgKiBDLnh4eDtcblxuICAvLyBQZXJtdXRhdGlvbnNcbiAgICBpID0gbW9kKGksIDI4OS4wICk7XG4gICAgdmVjNCBwID0gX3Blcm11dGUoIF9wZXJtdXRlKCBfcGVybXV0ZShcbiAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XG5cbiAgLy8gR3JhZGllbnRzXG4gIC8vICggTipOIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi4pXG4gICAgZmxvYXQgbl8gPSAxLjAvNy4wOyAvLyBOPTdcbiAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcblxuICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKm5zLnopOyAgLy8gIG1vZChwLE4qTilcblxuICAgIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XG4gICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxuXG4gICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xuICAgIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcbiAgICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XG5cbiAgICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xuICAgIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XG5cbiAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcbiAgICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcbiAgICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcblxuICAgIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcbiAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XG5cbiAgICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xuICAgIHZlYzMgcDEgPSB2ZWMzKGEwLnp3LGgueSk7XG4gICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcbiAgICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xuXG4gIC8vTm9ybWFsaXNlIGdyYWRpZW50c1xuICAgIHZlYzQgbm9ybSA9IF90YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcbiAgICBwMCAqPSBub3JtLng7XG4gICAgcDEgKj0gbm9ybS55O1xuICAgIHAyICo9IG5vcm0uejtcbiAgICBwMyAqPSBub3JtLnc7XG5cbiAgLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXG4gICAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XG4gICAgbSA9IG0gKiBtO1xuICAgIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XG4gIH1cbiAgICBgXG4gIH0sXG5cbiAgX3JnYlRvSHN2OiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGB2ZWMzIF9yZ2JUb0hzdih2ZWMzIGMpe1xuICAgICAgICAgICAgdmVjNCBLID0gdmVjNCgwLjAsIC0xLjAgLyAzLjAsIDIuMCAvIDMuMCwgLTEuMCk7XG4gICAgICAgICAgICB2ZWM0IHAgPSBtaXgodmVjNChjLmJnLCBLLnd6KSwgdmVjNChjLmdiLCBLLnh5KSwgc3RlcChjLmIsIGMuZykpO1xuICAgICAgICAgICAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIGMuciksIHZlYzQoYy5yLCBwLnl6eCksIHN0ZXAocC54LCBjLnIpKTtcblxuICAgICAgICAgICAgZmxvYXQgZCA9IHEueCAtIG1pbihxLncsIHEueSk7XG4gICAgICAgICAgICBmbG9hdCBlID0gMS4wZS0xMDtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzKGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgZSkpLCBkIC8gKHEueCArIGUpLCBxLngpO1xuICAgICAgICB9YFxuICB9LFxuICBfaHN2VG9SZ2I6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzMgX2hzdlRvUmdiKHZlYzMgYyl7XG4gICAgICAgIHZlYzQgSyA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcbiAgICAgICAgdmVjMyBwID0gYWJzKGZyYWN0KGMueHh4ICsgSy54eXopICogNi4wIC0gSy53d3cpO1xuICAgICAgICByZXR1cm4gYy56ICogbWl4KEsueHh4LCBjbGFtcChwIC0gSy54eHgsIDAuMCwgMS4wKSwgYy55KTtcbiAgICB9YFxuICB9XG59XG4iLCJpbXBvcnQgZ2xzbCBmcm9tICdnbHNsaWZ5J1xuaW1wb3J0IHtHcmlkR2VvbWV0cnl9IGZyb20gXCIuL2dlb21ldHJpZXMvR3JpZEdlb21ldHJ5LmpzXCI7XG5cbmNvbnN0IGRvdHNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9kb3RzLmZyYWdcIik7XG5jb25zdCBwb2ludHNWZXJ0ID0gZ2xzbChcIi4vc2hhZGVycy9wb2ludHMudmVydFwiKTtcbmNvbnN0IHNxdWFyZXNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9zcXVhcmVzLmZyYWdcIik7XG5jb25zdCBsaW5lc0ZyYWcgPSBnbHNsKFwiLi9zaGFkZXJzL2xpbmVzLmZyYWdcIik7XG5jb25zdCBsaW5lc1ZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL2xpbmVzLnZlcnRcIik7XG5jb25zdCBsaW5lc3RyaXBGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9saW5lc3RyaXAuZnJhZ1wiKTtcbmNvbnN0IGxpbmVzdHJpcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL2xpbmVzdHJpcC52ZXJ0XCIpO1xuY29uc3QgbGluZWxvb3BGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9saW5lbG9vcC5mcmFnXCIpO1xuY29uc3QgbGluZWxvb3BWZXJ0ID0gZ2xzbChcIi4vc2hhZGVycy9saW5lbG9vcC52ZXJ0XCIpO1xuXG5PYmplY3QuYXNzaWduKHdpbmRvdywge0dyaWRHZW9tZXRyeX0pO1xuXG5leHBvcnQgZGVmYXVsdCAoaHkpID0+IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdkb3RzJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBoeS5ncmFkaWVudCgpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc2l6ZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdmYWRlJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wMjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBkb3RzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnc3F1YXJlcycsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuZ3JhZGllbnQoKX0sXG4gICAgICAgICAgICB7bmFtZTogJ3NpemUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdmYWRlJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wMjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBzcXVhcmVzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbGluZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVzRnJhZyxcbiAgICAgICAgdmVydDogbGluZXNWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdsaW5lcycsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdsaW5lc3RyaXAnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LnNvbGlkKGh5Lm5vaXNlKDEpLngsIGh5Lm5vaXNlKDIpLnksIGh5Lm5vaXNlKDMpLnopLm1hcCgtMSwxLDAsMSl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVzdHJpcEZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzdHJpcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgc3RyaXAnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbGluZWxvb3AnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LnNvbGlkKGh5Lm5vaXNlKDEpLngsIGh5Lm5vaXNlKDIpLnksIGh5Lm5vaXNlKDMpLnopLm1hcCgtMSwxLDAsMSl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGxpbmVsb29wRnJhZyxcbiAgICAgICAgdmVydDogbGluZWxvb3BWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdsaW5lIGxvb3AnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH1cbl07IiwiaW1wb3J0IFdlYmNhbSBmcm9tICcuL2xpYi93ZWJjYW0uanMnXG5pbXBvcnQgU2NyZWVuIGZyb20gJy4vbGliL3NjcmVlbm1lZGlhLmpzJ1xuXG5jbGFzcyBIeWRyYVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yICh7IHJlZ2wsIHdpZHRoLCBoZWlnaHQsIHBiLCBsYWJlbCA9IFwiXCJ9KSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsXG4gICAgdGhpcy5yZWdsID0gcmVnbFxuICAgIHRoaXMuc3JjID0gbnVsbFxuICAgIHRoaXMuZHluYW1pYyA9IHRydWVcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoe1xuICAgICAgLy8gIHNoYXBlOiBbd2lkdGgsIGhlaWdodF1cbiAgICAgIHNoYXBlOiBbIDEsIDEgXVxuICAgIH0pXG4gICAgdGhpcy5wYiA9IHBiXG4gIH1cblxuICBpbml0IChvcHRzLCBwYXJhbXMpIHtcbiAgICBpZiAoJ3NyYycgaW4gb3B0cykge1xuICAgICAgdGhpcy5zcmMgPSBvcHRzLnNyY1xuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXMgfSlcbiAgICB9XG4gICAgaWYgKCdkeW5hbWljJyBpbiBvcHRzKSB0aGlzLmR5bmFtaWMgPSBvcHRzLmR5bmFtaWNcbiAgfVxuXG4gIGluaXRDYW0gKGluZGV4LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIFdlYmNhbShpbmRleClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgc2VsZi5zcmMgPSByZXNwb25zZS52aWRlb1xuICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygnY291bGQgbm90IGdldCBjYW1lcmEnLCBlcnIpKVxuICB9XG5cbiAgaW5pdFZpZGVvICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgLy8gY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCB2aWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgdmlkLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICB2aWQuYXV0b3BsYXkgPSB0cnVlXG4gICAgdmlkLmxvb3AgPSB0cnVlXG4gICAgdmlkLm11dGVkID0gdHJ1ZSAvLyBtdXRlIGluIG9yZGVyIHRvIGxvYWQgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3Qgb25sb2FkID0gdmlkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNyYyA9IHZpZFxuICAgICAgdmlkLnBsYXkoKVxuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgdGhpcy5keW5hbWljID0gdHJ1ZVxuICAgIH0pXG4gICAgdmlkLnNyYyA9IHVybFxuICB9XG5cbiAgaW5pdEltYWdlICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgIGltZy5zcmMgPSB1cmxcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zcmMgPSBpbWdcbiAgICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlXG4gICAgICB0aGlzLnRleCA9IHRoaXMucmVnbC50ZXh0dXJlKHsgZGF0YTogdGhpcy5zcmMsIC4uLnBhcmFtc30pXG4gICAgfVxuICB9XG5cbiAgaW5pdFN0cmVhbSAoc3RyZWFtTmFtZSwgcGFyYW1zKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKFwiaW5pdGluZyBzdHJlYW0hXCIsIHN0cmVhbU5hbWUpXG4gICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgaWYgKHN0cmVhbU5hbWUgJiYgdGhpcy5wYikge1xuICAgICAgdGhpcy5wYi5pbml0U291cmNlKHN0cmVhbU5hbWUpXG5cbiAgICAgIHRoaXMucGIub24oJ2dvdCB2aWRlbycsIGZ1bmN0aW9uIChuaWNrLCB2aWRlbykge1xuICAgICAgICBpZiAobmljayA9PT0gc3RyZWFtTmFtZSkge1xuICAgICAgICAgIHNlbGYuc3JjID0gdmlkZW9cbiAgICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgc2VsZi50ZXggPSBzZWxmLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHNlbGYuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGluZGV4IG9ubHkgcmVsZXZhbnQgaW4gYXRvbS1oeWRyYSArIGRlc2t0b3AgYXBwc1xuICBpbml0U2NyZWVuIChpbmRleCA9IDAsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgU2NyZWVuKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBzZWxmLnNyYyA9IHJlc3BvbnNlLnZpZGVvXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zfSlcbiAgICAgICAgc2VsZi5keW5hbWljID0gdHJ1ZVxuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJyZWNlaXZlZCBzY3JlZW4gaW5wdXRcIilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKCdjb3VsZCBub3QgZ2V0IHNjcmVlbicsIGVycikpXG4gIH1cblxuICByZXNpemUgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNyYyAmJiB0aGlzLnNyYy5zcmNPYmplY3QpIHtcbiAgICAgIGlmICh0aGlzLnNyYy5zcmNPYmplY3QuZ2V0VHJhY2tzKSB7XG4gICAgICAgIHRoaXMuc3JjLnNyY09iamVjdC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcmMgPSBudWxsXG4gICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IHNoYXBlOiBbIDEsIDEgXSB9KVxuICB9XG5cbiAgdGljayAodGltZSkge1xuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnNyYywgdGhpcy50ZXgud2lkdGgsIHRoaXMudGV4LmhlaWdodClcbiAgICBpZiAodGhpcy5zcmMgIT09IG51bGwgJiYgdGhpcy5keW5hbWljID09PSB0cnVlKSB7XG4gICAgICBpZiAodGhpcy5zcmMudmlkZW9XaWR0aCAmJiB0aGlzLnNyYy52aWRlb1dpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICB0aGlzLnNyYy52aWRlb1dpZHRoLFxuICAgICAgICAgIHRoaXMuc3JjLnZpZGVvSGVpZ2h0LFxuICAgICAgICAgIHRoaXMudGV4LndpZHRoLFxuICAgICAgICAgIHRoaXMudGV4LmhlaWdodFxuICAgICAgICApXG4gICAgICAgIHRoaXMudGV4LnJlc2l6ZSh0aGlzLnNyYy52aWRlb1dpZHRoLCB0aGlzLnNyYy52aWRlb0hlaWdodClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3JjLndpZHRoICYmIHRoaXMuc3JjLndpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICB0aGlzLnRleC5yZXNpemUodGhpcy5zcmMud2lkdGgsIHRoaXMuc3JjLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXguc3ViaW1hZ2UodGhpcy5zcmMpXG4gICAgfVxuICB9XG5cbiAgZ2V0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSHlkcmFTb3VyY2VcbiIsIlxuaW1wb3J0IE91dHB1dCBmcm9tICcuL291dHB1dC5qcydcbmltcG9ydCBsb29wIGZyb20gJ3JhZi1sb29wJ1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuL2h5ZHJhLXNvdXJjZS5qcydcbmltcG9ydCBNb3VzZVRvb2xzIGZyb20gJy4vbGliL21vdXNlLmpzJ1xuaW1wb3J0IEF1ZGlvIGZyb20gJy4vbGliL2F1ZGlvLmpzJ1xuaW1wb3J0IFZpZFJlY29yZGVyIGZyb20gJy4vbGliL3ZpZGVvLXJlY29yZGVyLmpzJ1xuaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG4vLyBpbXBvcnQgc3RydWRlbCBmcm9tICcuL2xpYi9zdHJ1ZGVsLmpzJ1xuaW1wb3J0IFNhbmRib3ggZnJvbSAnLi9ldmFsLXNhbmRib3guanMnXG5pbXBvcnQgR2VuZXJhdG9yIGZyb20gJy4vZ2VuZXJhdG9yLWZhY3RvcnkuanMnXG5pbXBvcnQgcmVnbCBmcm9tICdyZWdsJ1xuLy8gY29uc3Qgd2luZG93ID0gZ2xvYmFsLndpbmRvd1xuXG5cblxuY29uc3QgTW91c2UgPSBNb3VzZVRvb2xzKClcbi8vIHRvIGRvOiBhZGQgYWJpbGl0eSB0byBwYXNzIGluIGNlcnRhaW4gdW5pZm9ybXMgYW5kIHRyYW5zZm9ybXNcbmNsYXNzIEh5ZHJhUmVuZGVyZXIge1xuXG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcGIgPSBudWxsLFxuICAgIHdpZHRoID0gMTI4MCxcbiAgICBoZWlnaHQgPSA3MjAsXG4gICAgbnVtU291cmNlcyA9IDQsXG4gICAgbnVtT3V0cHV0cyA9IDQsXG4gICAgbWFrZUdsb2JhbCA9IHRydWUsXG4gICAgYXV0b0xvb3AgPSB0cnVlLFxuICAgIGRldGVjdEF1ZGlvID0gdHJ1ZSxcbiAgICBlbmFibGVTdHJlYW1DYXB0dXJlID0gdHJ1ZSxcbiAgICBjYW52YXMsXG4gICAgcHJlY2lzaW9uLFxuICAgIGV4dGVuZFRyYW5zZm9ybXMgPSB7fSAvLyBhZGQgeW91ciBvd24gZnVuY3Rpb25zIG9uIGluaXRcbiAgfSA9IHt9KSB7XG5cbiAgICBBcnJheVV0aWxzLmluaXQoKVxuXG4gICAgdGhpcy5wYiA9IHBiXG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMucmVuZGVyQWxsID0gZmFsc2VcbiAgICB0aGlzLmRldGVjdEF1ZGlvID0gZGV0ZWN0QXVkaW9cblxuICAgIHRoaXMuX2luaXRDYW52YXMoY2FudmFzKVxuXG4gICAgZ2xvYmFsLndpbmRvdy50ZXN0ID0gJ2hpJ1xuICAgIC8vIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBtYWRlIGF2YWlsYWJsZSBvbiB0aGUgZ2xvYmFsIGNvbnRleHQgYW5kIGR1cmluZyBsb2NhbCBldmFsdWF0aW9uXG4gICAgdGhpcy5zeW50aCA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICBicG06IDMwLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnBzOiB1bmRlZmluZWQsXG4gICAgICBzdGF0czoge1xuICAgICAgICBmcHM6IDBcbiAgICAgIH0sXG4gICAgICBzcGVlZDogMSxcbiAgICAgIG1vdXNlOiBNb3VzZSxcbiAgICAgIHJlbmRlcjogdGhpcy5fcmVuZGVyLmJpbmQodGhpcyksXG4gICAgICBzZXRSZXNvbHV0aW9uOiB0aGlzLnNldFJlc29sdXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZTogKGR0KSA9PiB7fSwvLyB1c2VyIGRlZmluZWQgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBodXNoOiB0aGlzLmh1c2guYmluZCh0aGlzKSxcbiAgICAgIHRpY2s6IHRoaXMudGljay5iaW5kKHRoaXMpXG4gICAgfVxuXG4gICAgaWYgKG1ha2VHbG9iYWwpIHdpbmRvdy5sb2FkU2NyaXB0ID0gdGhpcy5sb2FkU2NyaXB0XG5cblxuICAgIHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA9IDBcbiAgICB0aGlzLl90aW1lID0gMCAvLyBmb3IgaW50ZXJuYWwgdXNlLCBvbmx5IHRvIHVzZSBmb3IgZGVjaWRpbmcgd2hlbiB0byByZW5kZXIgZnJhbWVzXG5cbiAgICAvLyBvbmx5IGFsbG93IHZhbGlkIHByZWNpc2lvbiBvcHRpb25zXG4gICAgbGV0IHByZWNpc2lvbk9wdGlvbnMgPSBbJ2xvd3AnLCdtZWRpdW1wJywnaGlnaHAnXVxuICAgIGlmKHByZWNpc2lvbiAmJiBwcmVjaXNpb25PcHRpb25zLmluY2x1ZGVzKHByZWNpc2lvbi50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb24udG9Mb3dlckNhc2UoKVxuICAgICAgLy9cbiAgICAgIC8vIGlmKCFwcmVjaXNpb25WYWxpZCl7XG4gICAgICAvLyAgIGNvbnNvbGUud2FybignW2h5ZHJhLXN5bnRoIHdhcm5pbmddXFxuQ29uc3RydWN0b3Igd2FzIHByb3ZpZGVkIGFuIGludmFsaWQgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIHZhbHVlIG9mIFwiJyArIHByZWNpc2lvbiArICdcIi4gVXNpbmcgZGVmYXVsdCB2YWx1ZSBvZiBcIm1lZGl1bXBcIiBpbnN0ZWFkLicpXG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpc0lPUyA9XG4gICAgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHxcbiAgICAgIChuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSkpICYmXG4gICAgIXdpbmRvdy5NU1N0cmVhbTtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gaXNJT1MgPyAnaGlnaHAnIDogJ21lZGl1bXAnXG4gICAgfVxuXG5cblxuICAgIHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyA9IGV4dGVuZFRyYW5zZm9ybXNcblxuICAgIC8vIGJvb2xlYW4gdG8gc3RvcmUgd2hlbiB0byBzYXZlIHNjcmVlbnNob3RcbiAgICB0aGlzLnNhdmVGcmFtZSA9IGZhbHNlXG5cbiAgICAvLyBpZiBzdHJlYW0gY2FwdHVyZSBpcyBlbmFibGVkLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgY2FwdHVyZSBzdHJlYW1cbiAgICB0aGlzLmNhcHR1cmVTdHJlYW0gPSBudWxsXG5cbiAgICB0aGlzLmdlbmVyYXRvciA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5faW5pdFJlZ2woKVxuICAgIHRoaXMuX2luaXRPdXRwdXRzKG51bU91dHB1dHMpXG4gICAgdGhpcy5faW5pdFNvdXJjZXMobnVtU291cmNlcylcbiAgICB0aGlzLl9nZW5lcmF0ZUdsc2xUcmFuc2Zvcm1zKClcblxuICAgIHRoaXMuc3ludGguc2NyZWVuY2FwID0gKCkgPT4ge1xuICAgICAgdGhpcy5zYXZlRnJhbWUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZVN0cmVhbUNhcHR1cmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZVN0cmVhbSA9IHRoaXMuY2FudmFzLmNhcHR1cmVTdHJlYW0oMjUpXG4gICAgICAgIC8vIHRvIGRvOiBlbmFibGUgY2FwdHVyZSBzdHJlYW0gb2Ygc3BlY2lmaWMgc291cmNlcyBhbmQgb3V0cHV0c1xuICAgICAgICB0aGlzLnN5bnRoLnZpZFJlY29yZGVyID0gbmV3IFZpZFJlY29yZGVyKHRoaXMuY2FwdHVyZVN0cmVhbSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbaHlkcmEtc3ludGggd2FybmluZ11cXG5uZXcgTWVkaWFTb3VyY2UoKSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBvbiBpT1MuJylcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRldGVjdEF1ZGlvKSB0aGlzLl9pbml0QXVkaW8oKVxuXG4gICAgaWYoYXV0b0xvb3ApIGxvb3AodGhpcy50aWNrLmJpbmQodGhpcykpLnN0YXJ0KClcblxuICAgIC8vIGZpbmFsIGFyZ3VtZW50IGlzIHByb3BlcnRpZXMgdGhhdCB0aGUgdXNlciBjYW4gc2V0LCBhbGwgb3RoZXJzIGFyZSB0cmVhdGVkIGFzIHJlYWQtb25seVxuICAgIHRoaXMuc2FuZGJveCA9IG5ldyBTYW5kYm94KHRoaXMuc3ludGgsIG1ha2VHbG9iYWwsIFsnc3BlZWQnLCAndXBkYXRlJywgJ2JwbScsICdmcHMnXSlcbiAgfVxuXG4gIGV2YWwoY29kZSkge1xuICAgIHRoaXMuc2FuZGJveC5ldmFsKGNvZGUpXG4gIH1cblxuICBnZXRTY3JlZW5JbWFnZShjYWxsYmFjaykge1xuICAgIHRoaXMuaW1hZ2VDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5zYXZlRnJhbWUgPSB0cnVlXG4gIH1cblxuICBodXNoKCkge1xuICAgIHRoaXMucy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgIHNvdXJjZS5jbGVhcigpXG4gICAgfSlcbiAgICB0aGlzLm8uZm9yRWFjaCgob3V0cHV0KSA9PiB7XG4gICAgICB0aGlzLnN5bnRoLnNvbGlkKDAsIDAsIDAsIDApLm91dChvdXRwdXQpXG4gICAgfSlcbiAgICB0aGlzLnN5bnRoLnJlbmRlcih0aGlzLm9bMF0pXG4gICAgLy8gdGhpcy5zeW50aC51cGRhdGUgPSAoZHQpID0+IHt9XG4gICAgdGhpcy5zYW5kYm94LnNldCgndXBkYXRlJywgKGR0KSA9PiB7fSlcbiAgfVxuXG4gIGxvYWRTY3JpcHQodXJsID0gXCJcIiwgb25jZSA9IHRydWUpIHtcbiAgIGNvbnN0IHNlbGYgPSB0aGlzIHx8IHdpbmRvdztcbiAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgaWYgKG9uY2UpIHtcbiAgICAgICBzZWxmLmxvYWRlZFNjcmlwdHMgfHwgKHNlbGYubG9hZGVkU2NyaXB0cyA9IHt9KTtcbiAgICAgICBpZiAoc2VsZi5sb2FkZWRTY3JpcHRzW3VybF0pIHtcbiAgICAgICAgIHJlcygpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgIH1cbiAgICAgfVxuICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICBjb25zb2xlLmxvZyhgbG9hZGVkIHNjcmlwdCAke3VybH1gKTtcbiAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgc2VsZi5sb2FkZWRTY3JpcHRzW3VybF0gPSB0cnVlO1xuICAgICAgIH1cbiAgICAgICByZXMoKTtcbiAgICAgfTtcbiAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgY29uc29sZS5sb2coYGVycm9yIGxvYWRpbmcgc2NyaXB0ICR7dXJsfWAsIFwibG9nLWVycm9yXCIpO1xuICAgICAgIHJlcygpXG4gICAgIH07XG4gICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgIH0pO1xuICAgcmV0dXJuIHA7XG4gfVxuXG4gIHNldFJlc29sdXRpb24od2lkdGgsIGhlaWdodCkge1xuICAvLyAgY29uc29sZS5sb2cod2lkdGgsIGhlaWdodClcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8vID9cbiAgICB0aGlzLnNhbmRib3guc2V0KCd3aWR0aCcsIHdpZHRoKVxuICAgIHRoaXMuc2FuZGJveC5zZXQoJ2hlaWdodCcsIGhlaWdodClcbiAgICB0aGlzLm8uZm9yRWFjaCgob3V0cHV0KSA9PiB7XG4gICAgICBvdXRwdXQucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgICB0aGlzLnMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBzb3VyY2UucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgICB0aGlzLnJlZ2wuX3JlZnJlc2goKVxuICAgICBjb25zb2xlLmxvZyh0aGlzLmNhbnZhcy53aWR0aClcbiAgfVxuXG4gIGNhbnZhc1RvSW1hZ2UgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgbGV0IGQgPSBuZXcgRGF0ZSgpXG4gICAgYS5kb3dubG9hZCA9IGBoeWRyYS0ke2QuZ2V0RnVsbFllYXIoKX0tJHtkLmdldE1vbnRoKCkgKyAxfS0ke2QuZ2V0RGF0ZSgpfS0ke2QuZ2V0SG91cnMoKX0uJHtkLmdldE1pbnV0ZXMoKX0uJHtkLmdldFNlY29uZHMoKX0ucG5nYFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSlcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLmNhbnZhcy50b0Jsb2IoIChibG9iKSA9PiB7XG4gICAgICAgIGlmKHNlbGYuaW1hZ2VDYWxsYmFjayl7XG4gICAgICAgICAgc2VsZi5pbWFnZUNhbGxiYWNrKGJsb2IpXG4gICAgICAgICAgZGVsZXRlIHNlbGYuaW1hZ2VDYWxsYmFja1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgICBjb25zb2xlLmxvZyhhLmhyZWYpXG4gICAgICAgICAgYS5jbGljaygpXG4gICAgICAgIH1cbiAgICB9LCAnaW1hZ2UvcG5nJylcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChhLmhyZWYpO1xuICAgIH0sIDMwMCk7XG4gIH1cblxuICBfaW5pdEF1ZGlvICgpIHtcbiAgICBjb25zdCB0aGF0ID0gdGhpc1xuICAgIHRoaXMuc3ludGguYSA9IG5ldyBBdWRpbyh7XG4gICAgICBudW1CaW5zOiA0LFxuICAgICAgcGFyZW50RWw6IHRoaXMuY2FudmFzLnBhcmVudE5vZGVcbiAgICAgIC8vIGNoYW5nZUxpc3RlbmVyOiAoe2F1ZGlvfSkgPT4ge1xuICAgICAgLy8gICB0aGF0LmEgPSBhdWRpby5iaW5zLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAvLyAgICAgKHNjYWxlID0gMSwgb2Zmc2V0ID0gMCkgPT4gKCkgPT4gKGF1ZGlvLmZmdFtpbmRleF0gKiBzY2FsZSArIG9mZnNldClcbiAgICAgIC8vICAgKVxuICAgICAgLy9cbiAgICAgIC8vICAgaWYgKHRoYXQubWFrZUdsb2JhbCkge1xuICAgICAgLy8gICAgIHRoYXQuYS5mb3JFYWNoKChhLCBpbmRleCkgPT4ge1xuICAgICAgLy8gICAgICAgY29uc3QgYW5hbWUgPSBgYSR7aW5kZXh9YFxuICAgICAgLy8gICAgICAgd2luZG93W2FuYW1lXSA9IGFcbiAgICAgIC8vICAgICB9KVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGNyZWF0ZSBtYWluIG91dHB1dCBjYW52YXMgYW5kIGFkZCB0byBzY3JlZW5cbiAgX2luaXRDYW52YXMgKGNhbnZhcykge1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgICB0aGlzLndpZHRoID0gY2FudmFzLndpZHRoXG4gICAgICB0aGlzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoXG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodFxuICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAncGl4ZWxhdGVkJ1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcbiAgICB9XG4gIH1cblxuICBfaW5pdFJlZ2wgKCkge1xuICAgIHRoaXMucmVnbCA9IHJlZ2woe1xuICAgIC8vICBwcm9maWxlOiB0cnVlLFxuICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcyxcbiAgICAgIHBpeGVsUmF0aW86IDEvLyxcbiAgICAgIC8vIGV4dGVuc2lvbnM6IFtcbiAgICAgIC8vICAgJ29lc190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAgICAgLy8gICAnb2VzX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInXG4gICAgICAvLyBdLFxuICAgICAgLy8gb3B0aW9uYWxFeHRlbnNpb25zOiBbXG4gICAgICAvLyAgICdvZXNfdGV4dHVyZV9mbG9hdCcsXG4gICAgICAvLyAgICdvZXNfdGV4dHVyZV9mbG9hdF9saW5lYXInXG4gICAgIC8vXVxuICAgfSlcblxuICAgIC8vIFRoaXMgY2xlYXJzIHRoZSBjb2xvciBidWZmZXIgdG8gYmxhY2sgYW5kIHRoZSBkZXB0aCBidWZmZXIgdG8gMVxuICAgIHRoaXMucmVnbC5jbGVhcih7XG4gICAgICBjb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyQWxsID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgxO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDM7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzIgc3QgPSB2ZWMyKDEuMCAtIHV2LngsIHV2LnkpO1xuICAgICAgICBzdCo9IHZlYzIoMik7XG4gICAgICAgIHZlYzIgcSA9IGZsb29yKHN0KS54eSoodmVjMigyLjAsIDEuMCkpO1xuICAgICAgICBpbnQgcXVhZCA9IGludChxLngpICsgaW50KHEueSk7XG4gICAgICAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSk7XG4gICAgICAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSk7XG4gICAgICAgIHN0ID0gZnJhY3Qoc3QpO1xuICAgICAgICBpZihxdWFkPT0wKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgc3QpO1xuICAgICAgICB9IGVsc2UgaWYocXVhZD09MSl7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDEsIHN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkPT0yKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4Miwgc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgzLCBzdCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgdGV4MTogdGhpcy5yZWdsLnByb3AoJ3RleDEnKSxcbiAgICAgICAgdGV4MjogdGhpcy5yZWdsLnByb3AoJ3RleDInKSxcbiAgICAgICAgdGV4MzogdGhpcy5yZWdsLnByb3AoJ3RleDMnKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyRmJvID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDAsIHZlYzIoMS4wIC0gdXYueCwgdXYueSkpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZWdsLnByb3AoJ3Jlc29sdXRpb24nKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcbiAgfVxuXG4gIF9pbml0T3V0cHV0cyAobnVtT3V0cHV0cykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5vID0gKEFycmF5KG51bU91dHB1dHMpKS5maWxsKCkubWFwKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBvID0gbmV3IE91dHB1dChpbmRleCwgdGhpcylcbiAgICAgIHNlbGYuc3ludGhbJ28nK2luZGV4XSA9IG9cbiAgICAgIHJldHVybiBvXG4gICAgfSlcblxuICAgIC8vIHNldCBkZWZhdWx0IG91dHB1dFxuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vWzBdXG4gIH1cblxuICBfaW5pdFNvdXJjZXMgKG51bVNvdXJjZXMpIHtcbiAgICB0aGlzLnMgPSBbXVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspIHtcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKGkpXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU291cmNlIChpKSB7XG4gICAgbGV0IHMgPSBuZXcgU291cmNlKHtyZWdsOiB0aGlzLnJlZ2wsIHBiOiB0aGlzLnBiLCB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCwgbGFiZWw6IGBzJHtpfWB9KVxuICAgIHRoaXMuc3ludGhbJ3MnICsgdGhpcy5zLmxlbmd0aF0gPSBzXG4gICAgdGhpcy5zLnB1c2gocylcbiAgICByZXR1cm4gc1xuICB9XG5cbiAgX2dlbmVyYXRlR2xzbFRyYW5zZm9ybXMgKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gbmV3IEdlbmVyYXRvcih7XG4gICAgICBkZWZhdWx0T3V0cHV0OiB0aGlzLm9bMF0sXG4gICAgICBkZWZhdWx0VW5pZm9ybXM6IHRoaXMub1swXS51bmlmb3JtcyxcbiAgICAgIGV4dGVuZFRyYW5zZm9ybXM6IHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyxcbiAgICAgIGNoYW5nZUxpc3RlbmVyOiAoe3R5cGUsIG1ldGhvZCwgc3ludGh9KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBzZWxmLnN5bnRoW21ldGhvZF0gPSBzeW50aC5nZW5lcmF0b3JzW21ldGhvZF1cbiAgICAgICAgICAgIGlmKHNlbGYuc2FuZGJveCkgc2VsZi5zYW5kYm94LmFkZChtZXRob2QpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgLy8gd2hhdCB0byBkbyBoZXJlPyBkYW5nZXJvdXNseSBkZWxldGluZyB3aW5kb3cgbWV0aG9kc1xuICAgICAgICAgICAgLy9kZWxldGUgd2luZG93W21ldGhvZF1cbiAgICAgICAgICB9XG4gICAgICAvLyAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zeW50aC5zZXRGdW5jdGlvbiA9IHRoaXMuZ2VuZXJhdG9yLnNldEZ1bmN0aW9uLmJpbmQodGhpcy5nZW5lcmF0b3IpXG4gIH1cblxuICBfcmVuZGVyIChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dFxuICAgICAgdGhpcy5pc1JlbmRlcmluZ0FsbCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmdBbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3JlbmRlck91dCAoaSkge1xuICAgIHRoaXMub1tpXS50aWNrKHtcbiAgICAgIHRpbWU6IHRoaXMuc3ludGgudGltZSxcbiAgICAgIG1vdXNlOiB0aGlzLnN5bnRoLm1vdXNlLFxuICAgICAgYnBtOiB0aGlzLnN5bnRoLmJwbSxcbiAgICAgIHJlc29sdXRpb246IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XVxuICAgIH0pXG4gIH1cblxuICAvLyBkdCBpbiBtc1xuICB0aWNrIChkdCwgdW5pZm9ybXMpIHtcbiAgICB0aGlzLnNhbmRib3gudGljaygpXG4gICAgaWYodGhpcy5kZXRlY3RBdWRpbyA9PT0gdHJ1ZSkgdGhpcy5zeW50aC5hLnRpY2soKVxuICAvLyAgbGV0IHVwZGF0ZUludGVydmFsID0gMTAwMC90aGlzLnN5bnRoLmZwcyAvLyBtc1xuICAgIHRoaXMuc2FuZGJveC5zZXQoJ3RpbWUnLCB0aGlzLnN5bnRoLnRpbWUgKz0gZHQgKiAwLjAwMSAqIHRoaXMuc3ludGguc3BlZWQpXG4gICAgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlICs9IGR0XG4gICAgaWYoIXRoaXMuc3ludGguZnBzIHx8IHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA+PSAxMDAwL3RoaXMuc3ludGguZnBzKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKDEwMDAvdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlKVxuICAgICAgdGhpcy5zeW50aC5zdGF0cy5mcHMgPSBNYXRoLmNlaWwoMTAwMC90aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpXG4gICAgICBpZih0aGlzLnN5bnRoLnVwZGF0ZSkge1xuICAgICAgICB0cnkgeyB0aGlzLnN5bnRoLnVwZGF0ZSh0aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSkgfVxuICAgICAgfVxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnN5bnRoLnNwZWVkLCB0aGlzLnN5bnRoLnRpbWUpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNbaV0udGljayh0aGlzLnN5bnRoLnRpbWUpXG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuby5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW5kZXJPdXQoaSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0FsbCkge1xuICAgICAgICB0aGlzLnJlbmRlckFsbCh7XG4gICAgICAgICAgdGV4MDogdGhpcy5vWzBdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICB0ZXgxOiB0aGlzLm9bMV0uZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHRleDI6IHRoaXMub1syXS5nZXRDdXJyZW50KCksXG4gICAgICAgICAgdGV4MzogdGhpcy5vWzNdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJGYm8oe1xuICAgICAgICAgIHRleDA6IHRoaXMub3V0cHV0LmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA9IDBcbiAgICB9XG4gICAgaWYodGhpcy5zYXZlRnJhbWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2FudmFzVG9JbWFnZSgpXG4gICAgICB0aGlzLnNhdmVGcmFtZSA9IGZhbHNlXG4gICAgfVxuICAvLyAgdGhpcy5yZWdsLnBvbGwoKVxuICB9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBIeWRyYVJlbmRlcmVyXG4iLCJpbXBvcnQgU3ludGggZnJvbSAnLi9oeWRyYS1zeW50aC5qcydcbi8vaW1wb3J0IFNoYWRlckdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc2hhZGVyLWdlbmVyYXRvci5qcycpXG4vLyBhbGVydCgnaGknKVxuLy8gZXhwb3J0IGRlZmF1bHQgU3ludGhcbm1vZHVsZS5leHBvcnRzID0gU3ludGhcbiIsIi8vIFdJUCB1dGlscyBmb3Igd29ya2luZyB3aXRoIGFycmF5c1xuLy8gUG9zc2libHkgc2hvdWxkIGJlIGludGVncmF0ZWQgd2l0aCBsZm8gZXh0ZW5zaW9uLCBldGMuXG4vLyB0byBkbzogdHJhbnNmb3JtIHRpbWUgcmF0aGVyIHRoYW4gYXJyYXkgdmFsdWVzLCBzaW1pbGFyIHRvIHdvcmtpbmcgd2l0aCBjb29yZGluYXRlcyBpbiBoeWRyYVxuXG5pbXBvcnQgZWFzaW5nIGZyb20gJy4vZWFzaW5nLWZ1bmN0aW9ucy5qcydcblxudmFyIG1hcCA9IChudW0sIGluX21pbiwgaW5fbWF4LCBvdXRfbWluLCBvdXRfbWF4KSA9PiB7XG4gIHJldHVybiAobnVtIC0gaW5fbWluKSAqIChvdXRfbWF4IC0gb3V0X21pbikgLyAoaW5fbWF4IC0gaW5fbWluKSArIG91dF9taW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogKCkgPT4ge1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZhc3QgPSBmdW5jdGlvbihzcGVlZCA9IDEpIHtcbiAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnNtb290aCA9IGZ1bmN0aW9uKHNtb290aCA9IDEpIHtcbiAgICAgIHRoaXMuX3Ntb290aCA9IHNtb290aFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGVhc2UgPSAnbGluZWFyJykge1xuICAgICAgaWYgKHR5cGVvZiBlYXNlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzZVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWFzaW5nW2Vhc2VdKXtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzaW5nW2Vhc2VdXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbihvZmZzZXQgPSAwLjUpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldCUxLjBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLmJvdW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgdGhpcy5tb2RpZmllcnMuYm91bmNlID0gdHJ1ZVxuICAgIC8vICAgcmV0dXJuIHRoaXNcbiAgICAvLyB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24obG93ID0gMCwgaGlnaCA9MSkge1xuICAgICAgbGV0IGxvd2VzdCA9IE1hdGgubWluKC4uLnRoaXMpXG4gICAgICBsZXQgaGlnaGVzdCA9ICBNYXRoLm1heCguLi50aGlzKVxuICAgICAgdmFyIG5ld0FyciA9IHRoaXMubWFwKChudW0pID0+IG1hcChudW0sIGxvd2VzdCwgaGlnaGVzdCwgbG93LCBoaWdoKSlcbiAgICAgIG5ld0Fyci5fc3BlZWQgPSB0aGlzLl9zcGVlZFxuICAgICAgbmV3QXJyLl9zbW9vdGggPSB0aGlzLl9zbW9vdGhcbiAgICAgIG5ld0Fyci5fZWFzZSA9IHRoaXMuX2Vhc2VcbiAgICAgIHJldHVybiBuZXdBcnJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmFsdWU6IChhcnIgPSBbXSkgPT4gKHt0aW1lLCBicG19KSA9PntcbiAgICBsZXQgc3BlZWQgPSBhcnIuX3NwZWVkID8gYXJyLl9zcGVlZCA6IDFcbiAgICBsZXQgc21vb3RoID0gYXJyLl9zbW9vdGggPyBhcnIuX3Ntb290aCA6IDBcbiAgICBsZXQgaW5kZXggPSB0aW1lICogc3BlZWQgKiAoYnBtIC8gNjApICsgKGFyci5fb2Zmc2V0IHx8IDApXG5cbiAgICBpZiAoc21vb3RoIT09MCkge1xuICAgICAgbGV0IGVhc2UgPSBhcnIuX2Vhc2UgPyBhcnIuX2Vhc2UgOiBlYXNpbmdbJ2xpbmVhciddXG4gICAgICBsZXQgX2luZGV4ID0gaW5kZXggLSAoc21vb3RoIC8gMilcbiAgICAgIGxldCBjdXJyVmFsdWUgPSBhcnJbTWF0aC5mbG9vcihfaW5kZXggJSAoYXJyLmxlbmd0aCkpXVxuICAgICAgbGV0IG5leHRWYWx1ZSA9IGFycltNYXRoLmZsb29yKChfaW5kZXggKyAxKSAlIChhcnIubGVuZ3RoKSldXG4gICAgICBsZXQgdCA9IE1hdGgubWluKChfaW5kZXglMSkvc21vb3RoLDEpXG4gICAgICByZXR1cm4gZWFzZSh0KSAqIChuZXh0VmFsdWUgLSBjdXJyVmFsdWUpICsgY3VyclZhbHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGFycltNYXRoLmZsb29yKGluZGV4ICUgKGFyci5sZW5ndGgpKV1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBNZXlkYSBmcm9tICdtZXlkYSdcblxuY2xhc3MgQXVkaW8ge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIG51bUJpbnMgPSA0LFxuICAgIGN1dG9mZiA9IDIsXG4gICAgc21vb3RoID0gMC40LFxuICAgIG1heCA9IDE1LFxuICAgIHNjYWxlID0gMTAsXG4gICAgaXNEcmF3aW5nID0gZmFsc2UsXG4gICAgcGFyZW50RWwgPSBkb2N1bWVudC5ib2R5XG4gIH0pIHtcbiAgICB0aGlzLnZvbCA9IDBcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMuY3V0b2ZmID0gY3V0b2ZmXG4gICAgdGhpcy5zbW9vdGggPSBzbW9vdGhcbiAgICB0aGlzLnNldEJpbnMobnVtQmlucylcblxuICAgIC8vIGJlYXQgZGV0ZWN0aW9uIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS90aGVyZXdhc2FndXkvcDUtbXVzaWMtdml6L2Jsb2IvZ2gtcGFnZXMvZGVtb3MvMDFkX2JlYXRfZGV0ZWN0X2FtcGxpdHVkZS9za2V0Y2guanNcbiAgICB0aGlzLmJlYXQgPSB7XG4gICAgICBob2xkRnJhbWVzOiAyMCxcbiAgICAgIHRocmVzaG9sZDogNDAsXG4gICAgICBfY3V0b2ZmOiAwLCAvLyBhZGFwdGl2ZSBiYXNlZCBvbiBzb3VuZCBzdGF0ZVxuICAgICAgZGVjYXk6IDAuOTgsXG4gICAgICBfZnJhbWVzU2luY2VCZWF0OiAwIC8vIGtlZXBzIHRyYWNrIG9mIGZyYW1lc1xuICAgIH1cblxuICAgIHRoaXMub25CZWF0ID0gKCkgPT4ge1xuICAgIC8vICBjb25zb2xlLmxvZyhcImJlYXRcIilcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAxMDBcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSA4MFxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDBweFwiXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCI4MHB4XCJcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9ICcwcHgnXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gJzBweCdcbiAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcblxuICAgIHRoaXMuaXNEcmF3aW5nID0gaXNEcmF3aW5nXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlPVwiI0RGRkZGRlwiXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGU9XCIjMGZmXCJcbiAgICB0aGlzLmN0eC5saW5lV2lkdGg9MC41XG4gICAgaWYod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOiBmYWxzZSwgYXVkaW86IHRydWV9KVxuICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgLy8gIGNvbnNvbGUubG9nKCdnb3QgbWljIHN0cmVhbScsIHN0cmVhbSlcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICAgIC8vICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgICAgbGV0IGF1ZGlvX3N0cmVhbSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG5cbiAgICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMubWV5ZGEgPSBNZXlkYS5jcmVhdGVNZXlkYUFuYWx5emVyKHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBzb3VyY2U6IGF1ZGlvX3N0cmVhbSxcbiAgICAgICAgICBmZWF0dXJlRXh0cmFjdG9yczogW1xuICAgICAgICAgICAgJ2xvdWRuZXNzJyxcbiAgICAgICAgICAgIC8vICAncGVyY2VwdHVhbFNwcmVhZCcsXG4gICAgICAgICAgICAvLyAgJ3BlcmNlcHR1YWxTaGFycG5lc3MnLFxuICAgICAgICAgICAgLy8gICdzcGVjdHJhbENlbnRyb2lkJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coJ0VSUk9SJywgZXJyKSlcbiAgICB9XG4gIH1cblxuICBkZXRlY3RCZWF0IChsZXZlbCkge1xuICAgIC8vY29uc29sZS5sb2cobGV2ZWwsICAgdGhpcy5iZWF0Ll9jdXRvZmYpXG4gICAgaWYgKGxldmVsID4gdGhpcy5iZWF0Ll9jdXRvZmYgJiYgbGV2ZWwgPiB0aGlzLmJlYXQudGhyZXNob2xkKSB7XG4gICAgICB0aGlzLm9uQmVhdCgpXG4gICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IGxldmVsICoxLjJcbiAgICAgIHRoaXMuYmVhdC5fZnJhbWVzU2luY2VCZWF0ID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5iZWF0Ll9mcmFtZXNTaW5jZUJlYXQgPD0gdGhpcy5iZWF0LmhvbGRGcmFtZXMpe1xuICAgICAgICB0aGlzLmJlYXQuX2ZyYW1lc1NpbmNlQmVhdCArKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmVhdC5fY3V0b2ZmICo9IHRoaXMuYmVhdC5kZWNheVxuICAgICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IE1hdGgubWF4KCAgdGhpcy5iZWF0Ll9jdXRvZmYsIHRoaXMuYmVhdC50aHJlc2hvbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICBpZih0aGlzLm1leWRhKXtcbiAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5tZXlkYS5nZXQoKVxuICAgICBpZihmZWF0dXJlcyAmJiBmZWF0dXJlcyAhPT0gbnVsbCl7XG4gICAgICAgdGhpcy52b2wgPSBmZWF0dXJlcy5sb3VkbmVzcy50b3RhbFxuICAgICAgIHRoaXMuZGV0ZWN0QmVhdCh0aGlzLnZvbClcbiAgICAgICAvLyByZWR1Y2UgbG91ZG5lc3MgYXJyYXkgdG8gbnVtYmVyIG9mIGJpbnNcbiAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlO1xuICAgICAgIGxldCBzcGFjaW5nID0gTWF0aC5mbG9vcihmZWF0dXJlcy5sb3VkbmVzcy5zcGVjaWZpYy5sZW5ndGgvdGhpcy5iaW5zLmxlbmd0aClcbiAgICAgICB0aGlzLnByZXZCaW5zID0gdGhpcy5iaW5zLnNsaWNlKDApXG4gICAgICAgdGhpcy5iaW5zID0gdGhpcy5iaW5zLm1hcCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmxvdWRuZXNzLnNwZWNpZmljLnNsaWNlKGluZGV4ICogc3BhY2luZywgKGluZGV4ICsgMSkqc3BhY2luZykucmVkdWNlKHJlZHVjZXIpXG4gICAgICAgfSkubWFwKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAvLyBtYXAgdG8gc3BlY2lmaWVkIHJhbmdlXG5cbiAgICAgICAgLy8gcmV0dXJuIChiaW4gKiAoMS4wIC0gdGhpcy5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNtb290aClcbiAgICAgICAgICByZXR1cm4gKGJpbiAqICgxLjAgLSB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpXG4gICAgICAgfSlcbiAgICAgICAvLyB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICAgIC8vIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgLy8gdGhpcy5jdHgubW92ZVRvKGluZGV4KnNwYWNpbmcsIHkpXG4gICAgICAgLy8gdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICAgIC8vIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgICAgLy9cbiAgICAgICAvLyB2YXIgeU1heCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKih0aGlzLnNldHRpbmdzW2luZGV4XS5zY2FsZSArIHRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZilcbiAgICAgICB0aGlzLmZmdCA9IHRoaXMuYmlucy5tYXAoKGJpbiwgaW5kZXgpID0+IChcbiAgICAgICAgLy8gTWF0aC5tYXgoMCwgKGJpbiAtIHRoaXMuY3V0b2ZmKSAvICh0aGlzLm1heCAtIHRoaXMuY3V0b2ZmKSlcbiAgICAgICAgIE1hdGgubWF4KDAsIChiaW4gLSB0aGlzLnNldHRpbmdzW2luZGV4XS5jdXRvZmYpL3RoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlKVxuICAgICAgICkpXG4gICAgICAgaWYodGhpcy5pc0RyYXdpbmcpIHRoaXMuZHJhdygpXG4gICAgIH1cbiAgIH1cbiAgfVxuXG4gIHNldEN1dG9mZiAoY3V0b2ZmKSB7XG4gICAgdGhpcy5jdXRvZmYgPSBjdXRvZmZcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5jdXRvZmYgPSBjdXRvZmZcbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG4gIH1cblxuICBzZXRTbW9vdGggKHNtb290aCkge1xuICAgIHRoaXMuc21vb3RoID0gc21vb3RoXG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MubWFwKChlbCkgPT4ge1xuICAgICAgZWwuc21vb3RoID0gc21vb3RoXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0QmlucyAobnVtQmlucykge1xuICAgIHRoaXMuYmlucyA9IEFycmF5KG51bUJpbnMpLmZpbGwoMClcbiAgICB0aGlzLnByZXZCaW5zID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuZmZ0ID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuc2V0dGluZ3MgPSBBcnJheShudW1CaW5zKS5maWxsKDApLm1hcCgoKSA9PiAoe1xuICAgICAgY3V0b2ZmOiB0aGlzLmN1dG9mZixcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgc21vb3RoOiB0aGlzLnNtb290aFxuICAgIH0pKVxuICAgIC8vIHRvIGRvOiB3aGF0IHRvIGRvIGluIG5vbi1nbG9iYWwgbW9kZT9cbiAgICB0aGlzLmJpbnMuZm9yRWFjaCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgd2luZG93WydhJyArIGluZGV4XSA9IChzY2FsZSA9IDEsIG9mZnNldCA9IDApID0+ICgpID0+IChhLmZmdFtpbmRleF0gKiBzY2FsZSArIG9mZnNldClcbiAgICB9KVxuICAvLyAgY29uc29sZS5sb2codGhpcy5zZXR0aW5ncylcbiAgfVxuXG4gIHNldFNjYWxlKHNjYWxlKXtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5zY2FsZSA9IHNjYWxlXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0TWF4KG1heCkge1xuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgY29uc29sZS5sb2coJ3NldCBtYXggaXMgZGVwcmVjYXRlZCcpXG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IHRydWVcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gIH1cblxuICBkcmF3ICgpIHtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB2YXIgc3BhY2luZyA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5iaW5zLmxlbmd0aFxuICAgIHZhciBzY2FsZSA9IHRoaXMuY2FudmFzLmhlaWdodCAvICh0aGlzLm1heCAqIDIpXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLmJpbnMpXG4gICAgdGhpcy5iaW5zLmZvckVhY2goKGJpbiwgaW5kZXgpID0+IHtcblxuICAgICAgdmFyIGhlaWdodCA9IGJpbiAqIHNjYWxlXG5cbiAgICAgdGhpcy5jdHguZmlsbFJlY3QoaW5kZXggKiBzcGFjaW5nLCB0aGlzLmNhbnZhcy5oZWlnaHQgLSBoZWlnaHQsIHNwYWNpbmcsIGhlaWdodClcblxuICAvLyAgIGNvbnNvbGUubG9nKHRoaXMuc2V0dGluZ3NbaW5kZXhdKVxuICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeSlcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuXG4gICAgIHZhciB5TWF4ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqKHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlICsgdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmKVxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeU1heClcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5TWF4KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuICAgIH0pXG5cblxuICAgIC8qdmFyIHkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLmN1dG9mZlxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHkpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgdmFyIHlNYXggPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLm1heFxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHlNYXgpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5TWF4KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpKi9cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1xuIiwiLy8gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCooMi10KSB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyAyKnQqdCA6IC0xKyg0LTIqdCkqdCB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKC0tdCkqdCp0KzEgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDQqdCp0KnQgOiAodC0xKSooMip0LTIpKigyKnQtMikrMSB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxLSgtLXQpKnQqdCp0IH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyA4KnQqdCp0KnQgOiAxLTgqKC0tdCkqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQqdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdCB9LFxuICAvLyBzaW4gc2hhcGVcbiAgc2luOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKDEgKyBNYXRoLnNpbihNYXRoLlBJKnQtTWF0aC5QSS8yKSkvMiB9XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1ldmVudFxuXG5jb25zdCBtb3VzZSA9IHt9XG5cbmZ1bmN0aW9uIG1vdXNlQnV0dG9ucyhldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYuYnV0dG9uc1xuICAgIH0gZWxzZSBpZignd2hpY2gnIGluIGV2KSB7XG4gICAgICB2YXIgYiA9IGV2LndoaWNoXG4gICAgICBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiA0XG4gICAgICB9IGVsc2UgaWYoYiA9PT0gMykge1xuICAgICAgICByZXR1cm4gMlxuICAgICAgfSBlbHNlIGlmKGIgPiAwKSB7XG4gICAgICAgIHJldHVybiAxPDwoYi0xKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZignYnV0dG9uJyBpbiBldikge1xuICAgICAgdmFyIGIgPSBldi5idXR0b25cbiAgICAgIGlmKGIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDRcbiAgICAgIH0gZWxzZSBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgICB9IGVsc2UgaWYoYiA+PSAwKSB7XG4gICAgICAgIHJldHVybiAxPDxiXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS5idXR0b25zID0gbW91c2VCdXR0b25zXG5cbmZ1bmN0aW9uIG1vdXNlRWxlbWVudChldikge1xuICByZXR1cm4gZXYudGFyZ2V0IHx8IGV2LnNyY0VsZW1lbnQgfHwgd2luZG93XG59XG5tb3VzZS5lbGVtZW50ID0gbW91c2VFbGVtZW50XG5cbmZ1bmN0aW9uIG1vdXNlUmVsYXRpdmVYKGV2KSB7XG4gIGlmKHR5cGVvZiBldiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZigncGFnZVgnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYucGFnZVhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbm1vdXNlLnggPSBtb3VzZVJlbGF0aXZlWFxuXG5mdW5jdGlvbiBtb3VzZVJlbGF0aXZlWShldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ3BhZ2VZJyBpbiBldikge1xuICAgICAgcmV0dXJuIGV2LnBhZ2VZXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS55ID0gbW91c2VSZWxhdGl2ZVlcblxuZXhwb3J0IGRlZmF1bHQgbW91c2UiLCIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1jaGFuZ2VcblxuZXhwb3J0IGRlZmF1bHQgbW91c2VMaXN0ZW5cblxuaW1wb3J0IG1vdXNlIGZyb20gJy4vbW91c2UtZXZlbnQuanMnXG5cbmZ1bmN0aW9uIG1vdXNlTGlzdGVuIChlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBlbGVtZW50XG4gICAgZWxlbWVudCA9IHdpbmRvd1xuICB9XG5cbiAgdmFyIGJ1dHRvblN0YXRlID0gMFxuICB2YXIgeCA9IDBcbiAgdmFyIHkgPSAwXG4gIHZhciBtb2RzID0ge1xuICAgIHNoaWZ0OiBmYWxzZSxcbiAgICBhbHQ6IGZhbHNlLFxuICAgIGNvbnRyb2w6IGZhbHNlLFxuICAgIG1ldGE6IGZhbHNlXG4gIH1cbiAgdmFyIGF0dGFjaGVkID0gZmFsc2VcblxuICBmdW5jdGlvbiB1cGRhdGVNb2RzIChldikge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2VcbiAgICBpZiAoJ2FsdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LmFsdEtleSAhPT0gbW9kcy5hbHRcbiAgICAgIG1vZHMuYWx0ID0gISFldi5hbHRLZXlcbiAgICB9XG4gICAgaWYgKCdzaGlmdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LnNoaWZ0S2V5ICE9PSBtb2RzLnNoaWZ0XG4gICAgICBtb2RzLnNoaWZ0ID0gISFldi5zaGlmdEtleVxuICAgIH1cbiAgICBpZiAoJ2N0cmxLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5jdHJsS2V5ICE9PSBtb2RzLmNvbnRyb2xcbiAgICAgIG1vZHMuY29udHJvbCA9ICEhZXYuY3RybEtleVxuICAgIH1cbiAgICBpZiAoJ21ldGFLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5tZXRhS2V5ICE9PSBtb2RzLm1ldGFcbiAgICAgIG1vZHMubWV0YSA9ICEhZXYubWV0YUtleVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZFxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG5leHRCdXR0b25zLCBldikge1xuICAgIHZhciBuZXh0WCA9IG1vdXNlLngoZXYpXG4gICAgdmFyIG5leHRZID0gbW91c2UueShldilcbiAgICBpZiAoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICBuZXh0QnV0dG9ucyA9IGV2LmJ1dHRvbnMgfCAwXG4gICAgfVxuICAgIGlmIChuZXh0QnV0dG9ucyAhPT0gYnV0dG9uU3RhdGUgfHxcbiAgICAgIG5leHRYICE9PSB4IHx8XG4gICAgICBuZXh0WSAhPT0geSB8fFxuICAgICAgdXBkYXRlTW9kcyhldikpIHtcbiAgICAgIGJ1dHRvblN0YXRlID0gbmV4dEJ1dHRvbnMgfCAwXG4gICAgICB4ID0gbmV4dFggfHwgMFxuICAgICAgeSA9IG5leHRZIHx8IDBcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1dHRvblN0YXRlLCB4LCB5LCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGUgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoMCwgZXYpXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCbHVyICgpIHtcbiAgICBpZiAoYnV0dG9uU3RhdGUgfHxcbiAgICAgIHggfHxcbiAgICAgIHkgfHxcbiAgICAgIG1vZHMuc2hpZnQgfHxcbiAgICAgIG1vZHMuYWx0IHx8XG4gICAgICBtb2RzLm1ldGEgfHxcbiAgICAgIG1vZHMuY29udHJvbCkge1xuICAgICAgeCA9IHkgPSAwXG4gICAgICBidXR0b25TdGF0ZSA9IDBcbiAgICAgIG1vZHMuc2hpZnQgPSBtb2RzLmFsdCA9IG1vZHMuY29udHJvbCA9IG1vZHMubWV0YSA9IGZhbHNlXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygwLCAwLCAwLCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vZHMgKGV2KSB7XG4gICAgaWYgKHVwZGF0ZU1vZHMoZXYpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidXR0b25TdGF0ZSwgeCwgeSwgbW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUgKGV2KSB7XG4gICAgaWYgKG1vdXNlLmJ1dHRvbnMoZXYpID09PSAwKSB7XG4gICAgICBoYW5kbGVFdmVudCgwLCBldilcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUsIGV2KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93biAoZXYpIHtcbiAgICBoYW5kbGVFdmVudChidXR0b25TdGF0ZSB8IG1vdXNlLmJ1dHRvbnMoZXYpLCBldilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUgJiB+bW91c2UuYnV0dG9ucyhldiksIGV2KVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXJzICgpIHtcbiAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IHRydWVcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgY2xlYXJTdGF0ZSlcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBoYW5kbGVNb2RzKVxuXG4gICAgaWYgKGVsZW1lbnQgIT09IHdpbmRvdykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hMaXN0ZW5lcnMgKCkge1xuICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IGZhbHNlXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSlcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcClcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGNsZWFyU3RhdGUpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGNsZWFyU3RhdGUpXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZU1vZHMpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcblxuICAgIGlmIChlbGVtZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cilcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZU1vZHMpXG4gICAgfVxuICB9XG5cbiAgLy8gQXR0YWNoIGxpc3RlbmVyc1xuICBhdHRhY2hMaXN0ZW5lcnMoKVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzdWx0LCB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdHRhY2hlZCB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGF0dGFjaExpc3RlbmVycygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWNoTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIGJ1dHRvbnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnV0dG9uU3RhdGUgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geCB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB5IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBtb2RzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHMgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiLy8gYXR0ZW1wdCBjdXN0b20gZXZhbHVhdGlvbiBzYW5kYm94IGZvciBoeWRyYSBmdW5jdGlvbnNcbi8vIGZvciBub3csIGp1c3QgYXZvaWRzIHBvbGx1dGluZyB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuLy8gc2hvdWxkIHByb2JhYmx5IGJlIHJlcGxhY2VkIHdpdGggYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWVcblxuZXhwb3J0IGRlZmF1bHQgKHBhcmVudCkgPT4ge1xuICB2YXIgaW5pdGlhbENvZGUgPSBgYFxuXG4gIHZhciBzYW5kYm94ID0gY3JlYXRlU2FuZGJveChpbml0aWFsQ29kZSlcblxuICB2YXIgYWRkVG9Db250ZXh0ID0gKG5hbWUsIG9iamVjdCkgPT4ge1xuICAgIGluaXRpYWxDb2RlICs9IGBcbiAgICAgIHZhciAke25hbWV9ID0gJHtvYmplY3R9XG4gICAgYFxuICAgIHNhbmRib3ggPSBjcmVhdGVTYW5kYm94KGluaXRpYWxDb2RlKVxuICB9XG5cblxuICByZXR1cm4ge1xuICAgIGFkZFRvQ29udGV4dDogYWRkVG9Db250ZXh0LFxuICAgIGV2YWw6IChjb2RlKSA9PiBzYW5kYm94LmV2YWwoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNhbmRib3ggKGluaXRpYWwpIHtcbiAgICBldmFsKGluaXRpYWwpXG4gICAgLy8gb3B0aW9uYWwgcGFyYW1zXG4gICAgdmFyIGxvY2FsRXZhbCA9IGZ1bmN0aW9uIChjb2RlKSAge1xuICAgICAgZXZhbChjb2RlKVxuICAgIH1cblxuICAgIC8vIEFQSS9kYXRhIGZvciBlbmQtdXNlclxuICAgIHJldHVybiB7XG4gICAgICBldmFsOiBsb2NhbEV2YWxcbiAgICB9XG4gIH1cbn1cbiIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vICBhc3luYyBmdW5jdGlvbiBzdGFydENhcHR1cmUoZGlzcGxheU1lZGlhT3B0aW9ucykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKG9wdGlvbnMpLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICB2aWRlby5wbGF5KClcbiAgICAgICAgcmVzb2x2ZSh7dmlkZW86IHZpZGVvfSlcbiAgICAgIH0pXG4gICAgfSkuY2F0Y2goKGVycikgPT4gcmVqZWN0KGVycikpXG4gIH0pXG59XG4iLCJjbGFzcyBWaWRlb1JlY29yZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpXG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cblxuICAgIC8vIHRlc3RpbmcgdXNpbmcgYSByZWNvcmRpbmcgYXMgaW5wdXRcbiAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbiAgICB0aGlzLm91dHB1dC5hdXRvcGxheSA9IHRydWVcbiAgICB0aGlzLm91dHB1dC5sb29wID0gdHJ1ZVxuXG4gICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ01lZGlhU291cmNlIG9wZW5lZCcpO1xuICAgICAgc2VsZi5zb3VyY2VCdWZmZXIgPSBzZWxmLm1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcigndmlkZW8vd2VibTsgY29kZWNzPVwidnA4XCInKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTb3VyY2UgYnVmZmVyOiAnLCBzb3VyY2VCdWZmZXIpO1xuICAgIH0pXG4gIH1cblxuICBzdGFydCgpIHtcbiAgLy8gIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibSd9O1xuXG4vLyAgIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibTtjb2RlY3M9aDI2NCd9O1xuICAgbGV0IG9wdGlvbnMgPSB7bWltZVR5cGU6ICd2aWRlby93ZWJtO2NvZGVjcz12cDknfTtcblxuICAgIHRoaXMucmVjb3JkZWRCbG9icyA9IFtdXG4gICAgdHJ5IHtcbiAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgfSBjYXRjaCAoZTApIHtcbiAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBjcmVhdGUgTWVkaWFSZWNvcmRlciB3aXRoIG9wdGlvbnMgT2JqZWN0OiAnLCBlMClcbiAgICAgdHJ5IHtcbiAgICAgICBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibSxjb2RlY3M9dnA5J31cbiAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcih0aGlzLnN0cmVhbSwgb3B0aW9ucylcbiAgICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGNyZWF0ZSBNZWRpYVJlY29yZGVyIHdpdGggb3B0aW9ucyBPYmplY3Q6ICcsIGUxKVxuICAgICAgIHRyeSB7XG4gICAgICAgICBvcHRpb25zID0gJ3ZpZGVvL3ZwOCcgLy8gQ2hyb21lIDQ3XG4gICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcih0aGlzLnN0cmVhbSwgb3B0aW9ucylcbiAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgYWxlcnQoJ01lZGlhUmVjb3JkZXIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuXFxuJyArXG4gICAgICAgICAgICdUcnkgRmlyZWZveCAyOSBvciBsYXRlciwgb3IgQ2hyb21lIDQ3IG9yIGxhdGVyLCAnICtcbiAgICAgICAgICAgJ3dpdGggRW5hYmxlIGV4cGVyaW1lbnRhbCBXZWIgUGxhdGZvcm0gZmVhdHVyZXMgZW5hYmxlZCBmcm9tIGNocm9tZTovL2ZsYWdzLicpXG4gICAgICAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgTWVkaWFSZWNvcmRlcjonLCBlMilcbiAgICAgICAgIHJldHVyblxuICAgICAgIH1cbiAgICAgfVxuICAgfVxuICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgTWVkaWFSZWNvcmRlcicsIHRoaXMubWVkaWFSZWNvcmRlciwgJ3dpdGggb3B0aW9ucycsIG9wdGlvbnMpO1xuICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uc3RvcCA9IHRoaXMuX2hhbmRsZVN0b3AuYmluZCh0aGlzKVxuICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uZGF0YWF2YWlsYWJsZSA9IHRoaXMuX2hhbmRsZURhdGFBdmFpbGFibGUuYmluZCh0aGlzKVxuICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KDEwMCkgLy8gY29sbGVjdCAxMDBtcyBvZiBkYXRhXG4gICBjb25zb2xlLmxvZygnTWVkaWFSZWNvcmRlciBzdGFydGVkJywgdGhpcy5tZWRpYVJlY29yZGVyKVxuIH1cblxuICBcbiAgIHN0b3AoKXtcbiAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0b3AoKVxuICAgfVxuXG4gX2hhbmRsZVN0b3AoKSB7XG4gICAvL2NvbnN0IHN1cGVyQnVmZmVyID0gbmV3IEJsb2IocmVjb3JkZWRCbG9icywge3R5cGU6ICd2aWRlby93ZWJtJ30pXG4gICAvLyBjb25zdCBibG9iID0gbmV3IEJsb2IodGhpcy5yZWNvcmRlZEJsb2JzLCB7dHlwZTogJ3ZpZGVvL3dlYm07Y29kZWNzPWgyNjQnfSlcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkZWRCbG9icywge3R5cGU6IHRoaXMubWVkaWFSZWNvcmRlci5taW1lVHlwZX0pXG4gICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgdGhpcy5vdXRwdXQuc3JjID0gdXJsXG5cbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgYS5ocmVmID0gdXJsXG4gICAgbGV0IGQgPSBuZXcgRGF0ZSgpXG4gICAgYS5kb3dubG9hZCA9IGBoeWRyYS0ke2QuZ2V0RnVsbFllYXIoKX0tJHtkLmdldE1vbnRoKCkgKyAxfS0ke2QuZ2V0RGF0ZSgpfS0ke2QuZ2V0SG91cnMoKX0uJHtkLmdldE1pbnV0ZXMoKX0uJHtkLmdldFNlY29uZHMoKX0ud2VibWBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpXG4gICAgYS5jbGljaygpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICB9LCAzMDApO1xuICB9XG5cbiAgX2hhbmRsZURhdGFBdmFpbGFibGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLnJlY29yZGVkQmxvYnMucHVzaChldmVudC5kYXRhKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9SZWNvcmRlclxuIiwiLy9jb25zdCBlbnVtZXJhdGVEZXZpY2VzID0gcmVxdWlyZSgnZW51bWVyYXRlLWRldmljZXMnKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgLnRoZW4oZGV2aWNlcyA9PiBkZXZpY2VzLmZpbHRlcihkZXZpY2VzID0+IGRldmljZXMua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSlcbiAgICAudGhlbihjYW1lcmFzID0+IHtcbiAgICAgIGxldCBjb25zdHJhaW50cyA9IHsgYXVkaW86IGZhbHNlLCB2aWRlbzogdHJ1ZX1cbiAgICAgIGlmIChjYW1lcmFzW2RldmljZUlkXSkge1xuICAgICAgICBjb25zdHJhaW50c1sndmlkZW8nXSA9IHtcbiAgICAgICAgICBkZXZpY2VJZDogeyBleGFjdDogY2FtZXJhc1tkZXZpY2VJZF0uZGV2aWNlSWQgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKGNhbWVyYXMpXG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIH0pXG4gICAgLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICcnKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICcnKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICcnKVxuICAgICAgLy8gIHZpZGVvLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSlcbiAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgdmlkZW8ucGxheSgpLnRoZW4oKCkgPT4gcmVzb2x2ZSh7dmlkZW86IHZpZGVvfSkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpXG59XG4iLCJpbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCJnbC1tYXQ0XCI7XG5pbXBvcnQgR2xzbFNvdXJjZSBmcm9tIFwiLi9nbHNsLXNvdXJjZS5qc1wiO1xuXG52YXIgT3V0cHV0ID0gZnVuY3Rpb24gKGluZGV4LCBzeW50aCkge1xuICB0aGlzLmlkID0gaW5kZXg7XG4gIHRoaXMuc3ludGggPSBzeW50aDtcbiAgdGhpcy53aWR0aCA9IHN5bnRoLndpZHRoXG4gIHRoaXMuaGVpZ2h0ID0gc3ludGguaGVpZ2h0XG4gIHRoaXMucmVnbCA9IHN5bnRoLnJlZ2xcbiAgdGhpcy5wcmVjaXNpb24gPSBzeW50aC5wcmVjaXNpb25cbiAgdGhpcy5sYWJlbCA9IGBvJHtpbmRleH1gXG4gIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLnJlZ2wuYnVmZmVyKFtcbiAgICBbLTUsIC0xLCAwXSxcbiAgICBbLTEsIC01LCAwXSxcbiAgICBbMywgMywgMF1cbiAgXSlcbiAgdGhpcy51dkJ1ZmZlciA9IHRoaXMucmVnbC5idWZmZXIoW1xuICAgIFstMiwgMF0sXG4gICAgWzAsIC0yXSxcbiAgICBbMiwgMl1cbiAgXSlcblxuICB0aGlzLmRyYXcgPSBbXVxuICB0aGlzLmluaXQoKVxuICB0aGlzLnBpbmdQb25nSW5kZXggPSAwXG5cbiAgLy8gZm9yIGVhY2ggb3V0cHV0LCBjcmVhdGUgdHdvIGZib3MgZm9yIHBpbmdwb25naW5nXG4gIHRoaXMuZmJvcyA9IChBcnJheSgyKSkuZmlsbCgpLm1hcCgoKSA9PiB0aGlzLl9pbml0RmJvKCkpXG5cbiAgLy8gZm9yIGVhY2ggb3V0cHV0LCBjcmVhdGUgdHdvIHRlbXAgYnVmZmVyc1xuICB0aGlzLnRlbXAgPSAoQXJyYXkoMikpLmZpbGwoKS5tYXAoKCkgPT4gdGhpcy5faW5pdEZibygpKVxuXG4gIHRoaXMuY29weVBhc3MgPSB0aGlzLnJlZ2woe1xuICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgwLCB1dik7XG4gICAgICB9XG4gICAgICBgLFxuICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMi4wICogcG9zaXRpb24gLSAxLjAsIDAsIDEpO1xuICAgICAgfWAsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgcG9zaXRpb246IFtcbiAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgWzAsIC0yXSxcbiAgICAgICAgWzIsIDJdXG4gICAgICBdXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICB9LFxuICAgIGNvdW50OiAzLFxuICAgIGRlcHRoOiB7IGVuYWJsZTogZmFsc2UgfSxcbiAgICBmcmFtZWJ1ZmZlcjogKCkgPT4gdGhpcy5nZXRUZXh0dXJlKCksXG4gIH0pXG59XG5cbk91dHB1dC5wcm90b3R5cGUuX2luaXRGYm8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVnbC5mcmFtZWJ1ZmZlcih7XG4gICAgY29sb3I6IHRoaXMucmVnbC50ZXh0dXJlKHtcbiAgICAgIG1hZzogJ25lYXJlc3QnLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZm9ybWF0OiAncmdiYSdcbiAgICB9KSxcbiAgICBkZXB0aFN0ZW5jaWw6IGZhbHNlXG4gIH0pXG59XG5cbk91dHB1dC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLmZib3MuZm9yRWFjaCgoZmJvKSA9PiB7XG4gICAgZmJvLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxuICB0aGlzLnRlbXAuZm9yRWFjaCgodG1wKSA9PiB7XG4gICAgdG1wLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxufVxuXG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmJvc1t0aGlzLnBpbmdQb25nSW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBpbmRleCA9IHRoaXMucGluZ1BvbmdJbmRleCA/IDAgOiAxXG4gIHJldHVybiB0aGlzLmZib3NbaW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uQnVmZmVyLFxuICAgIHV2OiB0aGlzLnV2QnVmZmVyLFxuICB9XG4gIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgdGltZTogdGhpcy5yZWdsLnByb3AoJ3RpbWUnKSxcbiAgICByZXNvbHV0aW9uOiB0aGlzLnJlZ2wucHJvcCgncmVzb2x1dGlvbicpLFxuICB9XG5cbiAgdGhpcy5pbml0Q2FtZXJhKCk7XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5pbml0Q2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhbWVyYSA9IHRoaXMucmVnbCh7XG4gICAgY29udGV4dDoge1xuICAgICAgcHJvamVjdGlvbjogbWF0NC5pZGVudGl0eShbXSksXG4gICAgICB2aWV3OiBtYXQ0LmlkZW50aXR5KFtdKSxcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB2aWV3OiB0aGlzLnJlZ2wuY29udGV4dCgndmlldycpLFxuICAgICAgcHJvamVjdGlvbjogdGhpcy5yZWdsLmNvbnRleHQoJ3Byb2plY3Rpb24nKVxuICAgIH1cbiAgfSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuY2FtZXJhID0gZnVuY3Rpb24oZXllLCB0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgZm92eTogTWF0aC5QSSAvIDQsXG4gICAgbmVhcjogMC4xLFxuICAgIGZhcjogMTAwMC4wLFxuICB9LCBvcHRpb25zKTtcbiAgdGhpcy5leWUgPSBleWU7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICBpZiAoZXllICYmIHRhcmdldCkge1xuICAgIHRoaXMuX2NhbWVyYSA9IHRoaXMucmVnbCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIHByb2plY3Rpb246IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3BlcnNwZWN0aXZlJykge1xuICAgICAgICAgICAgcmV0dXJuIG1hdDQucGVyc3BlY3RpdmUoW10sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3Z5LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXNwZWN0IHx8IChjb250ZXh0LnZpZXdwb3J0V2lkdGggLyBjb250ZXh0LnZpZXdwb3J0SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLm5lYXIsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mYXIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hdDQub3J0aG8oW10sIC0xLjAsIDEuMCwgLTEuMCwgMS4wLCBvcHRpb25zLm5lYXIsIG9wdGlvbnMuZmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIChjb250ZXh0LCBwcm9wcykge1xuICAgICAgICAgIHJldHVybiBtYXQ0Lmxvb2tBdChbXSxcbiAgICAgICAgICAgICAgcHJvcHMuZXllLFxuICAgICAgICAgICAgICBwcm9wcy50YXJnZXQsXG4gICAgICAgICAgICAgIFswLCAxLCAwXSlcbiAgICAgICAgfSxcbiAgICAgICAgZXllOiB0aGlzLnJlZ2wucHJvcCgnZXllJyksXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdmlldzogdGhpcy5yZWdsLmNvbnRleHQoJ3ZpZXcnKSxcbiAgICAgICAgcHJvamVjdGlvbjogdGhpcy5yZWdsLmNvbnRleHQoJ3Byb2plY3Rpb24nKSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmluaXRDYW1lcmEoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGV5ZSwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3R5cGU6ICdwZXJzcGVjdGl2ZSd9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuY2FtZXJhKGV5ZSwgdGFyZ2V0LCBvcHRpb25zKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5vcnRobyA9IGZ1bmN0aW9uKGV5ZSwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3R5cGU6ICdvcnRobyd9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuY2FtZXJhKGV5ZSwgdGFyZ2V0LCBvcHRpb25zKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFzc2VzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIGVuc3VyZSBib3RoIGZibydzIGhhdmUgbGFzdCBmcmFtZVxuICB0aGlzLmNvcHlQYXNzKHtcbiAgICB0ZXgwOiB0aGlzLmdldEN1cnJlbnQoKSxcbiAgfSk7XG4gIHNlbGYuZHJhdyA9IFtdO1xuICBmb3IgKGxldCBpPTA7IGk8cGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhc3MgPSBwYXNzZXNbaV1cbiAgICBpZiAocGFzcy5jbGVhcikge1xuICAgICAgc3dpdGNoIChwYXNzLmNsZWFyKSB7XG4gICAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgICBzZWxmLmRyYXcucHVzaCguLi50aGlzLmNsZWFyKGZhbHNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZhZGUnOiB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gdHlwZW9mKHBhc3MudXNlckFyZ3NbMF0pID09PSAnb2JqZWN0JyA/IHBhc3MudXNlckFyZ3NbMF0gOiB7YW1vdW50OiBwYXNzLnVzZXJBcmdzWzBdfTtcbiAgICAgICAgICBvcHQubm93ID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5kcmF3LnB1c2godGhpcy5mYWRlKG9wdCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKGB1bnJlY29nbml6ZWQgY2xlYXI6ICR7cGFzcy5jbGVhcn0oJHtwYXNzLnVzZXJBcmdzLmpvaW4oXCIsIFwiKX0pYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7YXR0cmlidXRlcywgZWxlbWVudHMsIHByaW1pdGl2ZX0gPSB0aGlzLmdldEF0dHJpYnV0ZXMocGFzcy5wcmltaXRpdmUsIHBhc3MuZ2VvbWV0cnkpO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy5nZXRVbmlmb3JtcyhwYXNzLnVuaWZvcm1zKTtcbiAgICBjb25zdCBibGVuZCA9IHRoaXMuZ2V0QmxlbmQocGFzcy5ibGVuZE1vZGUpO1xuICAgIGNvbnN0IGRyYXcgPSBzZWxmLnJlZ2woe1xuICAgICAgZnJhZzogcGFzcy5mcmFnLFxuICAgICAgdmVydDogcGFzcy52ZXJ0LFxuICAgICAgdmlld3BvcnQ6IHR5cGVvZihwYXNzLnZpZXdwb3J0LngpICE9PSAndW5kZWZpbmVkJyA/IHtcbiAgICAgICAgeDogcGFzcy52aWV3cG9ydC54ICogdGhpcy5mYm9zWzBdLndpZHRoLFxuICAgICAgICB5OiBwYXNzLnZpZXdwb3J0LnkgKiB0aGlzLmZib3NbMF0uaGVpZ2h0LFxuICAgICAgICB3aWR0aDogcGFzcy52aWV3cG9ydC53ICogdGhpcy5mYm9zWzBdLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhc3Mudmlld3BvcnQuaCAqIHRoaXMuZmJvc1swXS5oZWlnaHQsXG4gICAgICB9IDoge30sXG4gICAgICBjdWxsOiB7XG4gICAgICAgIGVuYWJsZTogISFwYXNzLmdlb21ldHJ5LFxuICAgICAgICBmYWNlOiAnYmFjaydcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcHJpbWl0aXZlLFxuICAgICAgdW5pZm9ybXMsXG4gICAgICBjb3VudDogdHlwZW9mKGVsZW1lbnRzKSA9PT0gJ251bWJlcicgPyBlbGVtZW50cyA6IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnRzOiB0eXBlb2YoZWxlbWVudHMpID09PSAnbnVtYmVyJyA/IG51bGwgOiBlbGVtZW50cyxcbiAgICAgIGJsZW5kLFxuICAgICAgbGluZVdpZHRoOiBwYXNzLmxpbmVXaWR0aCxcbiAgICAgIGZyYW1lYnVmZmVyOiBwYXNzLmZyYW1lYnVmZmVyIHx8ICgoKSA9PiB7XG4gICAgICAgIHNlbGYucGluZ1BvbmdJbmRleCA9IHNlbGYucGluZ1BvbmdJbmRleCA/IDAgOiAxXG4gICAgICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XVxuICAgICAgfSksXG4gICAgfSlcbiAgICBzZWxmLmRyYXcucHVzaChkcmF3KVxuICB9XG59XG5cbk91dHB1dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihub3cgPSB0cnVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFt0aGlzLmZib3NbMF0sIHRoaXMuZmJvc1sxXSwgdGhpcy50ZW1wWzBdLCB0aGlzLnRlbXBbMV1dLm1hcCgoZmJvKSA9PiB7XG4gICAgY29uc3QgY2xlYXIgPSAoKSA9PiB0aGlzLnJlZ2wuY2xlYXIoe1xuICAgICAgY29sb3I6IFswLCAwLCAwLCAwXSxcbiAgICAgIGZyYW1lYnVmZmVyOiBmYm8sXG4gICAgfSk7XG4gICAgaWYgKG5vdykgY2xlYXIoKTtcbiAgICBlbHNlIHJldHVybiBjbGVhcjtcbiAgfSk7XG4gIGlmIChub3cpIHJldHVybiB0aGlzO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmZhZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGxldCBhbW91bnQgPSBvcHRpb25zO1xuICBsZXQgY2FtZXJhID0gZmFsc2U7XG4gIGxldCBub3cgPSB0cnVlO1xuICBpZiAodHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgICh7YW1vdW50LCBjYW1lcmF9ID0gb3B0aW9ucyk7XG4gICAgbm93ID0gdHlwZW9mKG9wdGlvbnMubm93KSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5ub3c7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIC8vIHRvZG86IGRvIHdlIG5lZWQgdG8gZmFkZSBhbHNvIHRlbXAgYnVmZmVycz9cbiAgY29uc3QgZmFkZSA9IHNlbGYucmVnbCh7XG4gICAgZnJhZzogYFxuICAgICAgICAgIHByZWNpc2lvbiAke3NlbGYucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdnV2O1xuICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHByZXZCdWZmZXI7XG4gICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgdmVjNCBjb2xvciA9IG1peCh0ZXh0dXJlMkQocHJldkJ1ZmZlciwgdnV2KSwgdmVjNCgwKSwgJHthbW91bnR9KTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICB2ZXJ0OiBHbHNsU291cmNlLmNvbXBpbGVWZXJ0KHRoaXMucHJlY2lzaW9uLCBjYW1lcmEsIHsgZ2xzbE5hbWU6ICdjbGVhcicgfSksXG4gICAgYXR0cmlidXRlczogc2VsZi5hdHRyaWJ1dGVzLFxuICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIHByZXZCdWZmZXI6ICgpID0+ICB7IHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XSB9LFxuICAgIH0sIHRoaXMudW5pZm9ybXMpLFxuICAgIGNvdW50OiAzLFxuICAgIC8vIG5leHQgZnJhbWVidWZmZXJcbiAgICBmcmFtZWJ1ZmZlcjogKCkgPT4ge1xuICAgICAgcmV0dXJuIHNlbGYuZmJvc1tzZWxmLnBpbmdQb25nSW5kZXggPyAwIDogMV1cbiAgICB9XG4gIH0pO1xuICBpZiAobm93KSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIGZhZGU7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKHByaW1pdGl2ZSwgZ2VvbWV0cnkpIHtcbiAgbGV0IGVsZW1lbnRzID0gMztcbiAgbGV0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gIGlmIChnZW9tZXRyeSkge1xuICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChrZXkpID0+IGF0dHJpYnV0ZXNba2V5XSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNba2V5XS5hcnJheSk7XG4gICAgZWxlbWVudHMgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICBwcmltaXRpdmUgfHwgKHByaW1pdGl2ZSA9IGdlb21ldHJ5LnBhcmFtZXRlcnMucHJpbWl0aXZlKTtcbiAgfVxuICBwcmltaXRpdmUgfHwgKHByaW1pdGl2ZSA9ICd0cmlhbmdsZXMnKTtcbiAgcmV0dXJuIHthdHRyaWJ1dGVzLCBlbGVtZW50cywgcHJpbWl0aXZlfTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKHVuaWZvcm1zKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICB1bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24odW5pZm9ybXMsIHsgcHJldkJ1ZmZlcjogICgpID0+ICB7XG4gICAgLy8gdG9kbzogY2hhbmdlZCwgb3JpZ2luYWxseTpcbiAgICAvLyByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleF1cbiAgICByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleCA/IDAgOiAxXVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVuaWZvcm1zKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSB0eXBlb2YodW5pZm9ybXNba2V5XSkgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh1bmlmb3Jtc1trZXldKSA6IHVuaWZvcm1zW2tleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldEJsZW5kID0gZnVuY3Rpb24oYmxlbmRNb2RlKSB7XG4gIGxldCBmdW5jO1xuICBzd2l0Y2ggKGJsZW5kTW9kZSkge1xuICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdjdXN0b20nLCAgLy8gRGVmaW5lIHlvdXIgY3VzdG9tIGJsZW5kaW5nIGZ1bmN0aW9uIGhlcmVcbiAgICAgICAgZHN0UkdCOiAnY3VzdG9tJyxcbiAgICAgICAgc3JjQWxwaGE6ICdjdXN0b20nLFxuICAgICAgICBkc3RBbHBoYTogJ2N1c3RvbScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdkc3QgY29sb3InLFxuICAgICAgICBkc3RSR0I6ICdvbmUgbWludXMgc3JjIGNvbG9yJyxcbiAgICAgICAgc3JjQWxwaGE6ICdkc3QgYWxwaGEnLFxuICAgICAgICBkc3RBbHBoYTogJ29uZSBtaW51cyBzcmMgYWxwaGEnLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdvbmUgbWludXMgZHN0IGNvbG9yJyxcbiAgICAgICAgZHN0UkdCOiAnb25lJyxcbiAgICAgICAgc3JjQWxwaGE6ICdvbmUgbWludXMgZHN0IGFscGhhJyxcbiAgICAgICAgZHN0QWxwaGE6ICdvbmUnLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ2RzdCBjb2xvcicsXG4gICAgICAgIGRzdFJHQjogJ3plcm8nLFxuICAgICAgICBzcmNBbHBoYTogJ2RzdCBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAnemVybycsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWRkJzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ29uZScsXG4gICAgICAgIGRzdFJHQjogJ29uZScsXG4gICAgICAgIHNyY0FscGhhOiAnb25lJyxcbiAgICAgICAgZHN0QWxwaGE6ICdvbmUnLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FscGhhJzpcbiAgICBkZWZhdWx0OlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnc3JjIGFscGhhJyxcbiAgICAgICAgc3JjQWxwaGE6IDEsXG4gICAgICAgIGRzdFJHQjogJ29uZSBtaW51cyBzcmMgYWxwaGEnLFxuICAgICAgICBkc3RBbHBoYTogMVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW5hYmxlOiBibGVuZE1vZGUgPyAodHlwZW9mKGJsZW5kTW9kZSkgPT09ICdzdHJpbmcnID8gYmxlbmRNb2RlICE9PSAnZGlzYWJsZWQnIDogYmxlbmRNb2RlKSA6IGZhbHNlLFxuICAgIGZ1bmMsXG4gIH07XG59XG5cbk91dHB1dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uIChwcm9wcykge1xuICBjb25zdCBkb0RyYXcgPSAoKSA9PiB0aGlzLmRyYXcubWFwKChmbikgPT4gZm4ocHJvcHMpKTtcbiAgdGhpcy5fY2FtZXJhKHtcbiAgICBleWU6IHRoaXMuZXllLFxuICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gIH0sIGZ1bmN0aW9uKCkge1xuICAgIGRvRHJhdygpO1xuICB9KTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5yZW5kZXJUZXh0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3ludGguX3JlbmRlck91dCh0aGlzLmlkKTtcbiAgY29uc3QgY29sb3JUZXggPSB0aGlzLmZib3NbdGhpcy5waW5nUG9uZ0luZGV4XS5jb2xvcjtcbiAgdGhpcy5mYm9zW3RoaXMucGluZ1BvbmdJbmRleF0gPSB0aGlzLl9pbml0RmJvKCk7XG4gIHJldHVybiBjb2xvclRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgT3V0cHV0XG4iLCJjb25zdCB0eXBlTG9va3VwID0ge1xuICAgICdzcmMnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICAgICAgYXJnczogWyd2ZWMyIF9zdCddXG4gICAgfSxcbiAgICAndmVydCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgICB9LFxuICAgICdjb29yZCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgICB9LFxuICAgICdjb2xvcic6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzQgX2MwJ11cbiAgICB9LFxuICAgICdjb21iaW5lJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgICAgIGFyZ3M6IFsndmVjNCBfYzAnLCAndmVjNCBfYzEnXVxuICAgIH0sXG4gICAgJ2NvbWJpbmVDb29yZCc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0JywgJ3ZlYzQgX2MwJ11cbiAgICB9XG59XG5cbmNvbnN0IGdldExvb2t1cCA9IHtmbG9hdDogJ3gnLCB2ZWMyOiAneHknLCB2ZWMzOiAneHl6JywgdmVjNDogJ3h5encnfTtcblxuY29uc3QgZ2V0VHlwZUxvb2t1cCA9IHtcbiAgICB4OiAnZmxvYXQnLCB5OiAnZmxvYXQnLCB6OiAnZmxvYXQnLFxuICAgIHh5OiAndmVjMicsIHl4OiAndmVjMicsXG4gICAgeHl6OiAndmVjMycsIHh6eTogJ3ZlYzMnLCB5eng6ICd2ZWMzJywgeXh6OiAndmVjMycsIHp4eTogJ3ZlYzMnLCB6eXg6ICd2ZWMzJyxcbiAgICB4eXp3OiAndmVjNCcsXG59O1xuXG5jb25zdCBjYXN0VHlwZSA9IChmdW5jLCBmcm9tVHlwZSwgdG9UeXBlLCBhbHBoYSA9IDAuMCkgPT4ge1xuICAgIGNvbnN0IGZyb21MZW4gPSBmcm9tVHlwZSA9PT0gJ2Zsb2F0JyA/IDEgOiBmcm9tVHlwZS5zdWJzdHJpbmcoMyk7XG4gICAgY29uc3QgdG9MZW4gPSAodG9UeXBlID09PSAnZmxvYXQnID8gMSA6IHRvVHlwZS5zdWJzdHJpbmcoMykpO1xuICAgIGlmIChmcm9tTGVuIDwgdG9MZW4pIHtcbiAgICAgICAgbGV0IGRpZmYgPSB0b0xlbiAtIGZyb21MZW47XG4gICAgICAgIGxldCBsYXN0ID0gJyc7XG4gICAgICAgIGlmICh0b1R5cGUgPT09ICd2ZWM0Jykge1xuICAgICAgICAgICAgZGlmZiAtPSAxO1xuICAgICAgICAgICAgbGFzdCA9ICcsICcrYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuYyA9IGB2ZWMke3RvTGVufSgke2Z1bmN9JHsnLCAwLjAnLnJlcGVhdChkaWZmKX0ke2xhc3R9KWA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xufVxuXG5leHBvcnQgeyB0eXBlTG9va3VwLCBnZXRMb29rdXAsIGdldFR5cGVMb29rdXAsIGNhc3RUeXBlIH07Il19
