(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hydra = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = add

function add(a, b) {
  return rationalize(
    a[0].mul(b[1]).add(b[0].mul(a[1])),
    a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],3:[function(require,module,exports){
'use strict'

module.exports = cmp

function cmp(a, b) {
    return a[0].mul(b[1]).cmp(b[0].mul(a[1]))
}

},{}],4:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = div

function div(a, b) {
  return rationalize(a[0].mul(b[1]), a[1].mul(b[0]))
}

},{"./lib/rationalize":12}],5:[function(require,module,exports){
'use strict'

var isRat = require('./is-rat')
var isBN = require('./lib/is-bn')
var num2bn = require('./lib/num-to-bn')
var str2bn = require('./lib/str-to-bn')
var rationalize = require('./lib/rationalize')
var div = require('./div')

module.exports = makeRational

function makeRational(numer, denom) {
  if(isRat(numer)) {
    if(denom) {
      return div(numer, makeRational(denom))
    }
    return [numer[0].clone(), numer[1].clone()]
  }
  var shift = 0
  var a, b
  if(isBN(numer)) {
    a = numer.clone()
  } else if(typeof numer === 'string') {
    a = str2bn(numer)
  } else if(numer === 0) {
    return [num2bn(0), num2bn(1)]
  } else if(numer === Math.floor(numer)) {
    a = num2bn(numer)
  } else {
    while(numer !== Math.floor(numer)) {
      numer = numer * Math.pow(2, 256)
      shift -= 256
    }
    a = num2bn(numer)
  }
  if(isRat(denom)) {
    a.mul(denom[1])
    b = denom[0].clone()
  } else if(isBN(denom)) {
    b = denom.clone()
  } else if(typeof denom === 'string') {
    b = str2bn(denom)
  } else if(!denom) {
    b = num2bn(1)
  } else if(denom === Math.floor(denom)) {
    b = num2bn(denom)
  } else {
    while(denom !== Math.floor(denom)) {
      denom = denom * Math.pow(2, 256)
      shift += 256
    }
    b = num2bn(denom)
  }
  if(shift > 0) {
    a = a.ushln(shift)
  } else if(shift < 0) {
    b = b.ushln(-shift)
  }
  return rationalize(a, b)
}

},{"./div":4,"./is-rat":6,"./lib/is-bn":10,"./lib/num-to-bn":11,"./lib/rationalize":12,"./lib/str-to-bn":13}],6:[function(require,module,exports){
'use strict'

var isBN = require('./lib/is-bn')

module.exports = isRat

function isRat(x) {
  return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1])
}

},{"./lib/is-bn":10}],7:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = sign

function sign (x) {
  return x.cmp(new BN(0))
}

},{"bn.js":15}],8:[function(require,module,exports){
'use strict'

var sign = require('./bn-sign')

module.exports = bn2num

//TODO: Make this better
function bn2num(b) {
  var l = b.length
  var words = b.words
  var out = 0
  if (l === 1) {
    out = words[0]
  } else if (l === 2) {
    out = words[0] + (words[1] * 0x4000000)
  } else {
    for (var i = 0; i < l; i++) {
      var w = words[i]
      out += w * Math.pow(0x4000000, i)
    }
  }
  return sign(b) * out
}

},{"./bn-sign":7}],9:[function(require,module,exports){
'use strict'

var db = require('double-bits')
var ctz = require('bit-twiddle').countTrailingZeros

module.exports = ctzNumber

//Counts the number of trailing zeros
function ctzNumber(x) {
  var l = ctz(db.lo(x))
  if(l < 32) {
    return l
  }
  var h = ctz(db.hi(x))
  if(h > 20) {
    return 52
  }
  return h + 32
}

},{"bit-twiddle":20,"double-bits":42}],10:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = isBN

//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x) {
  return x && typeof x === 'object' && Boolean(x.words)
}

},{"bn.js":15}],11:[function(require,module,exports){
'use strict'

var BN = require('bn.js')
var db = require('double-bits')

module.exports = num2bn

function num2bn(x) {
  var e = db.exponent(x)
  if(e < 52) {
    return new BN(x)
  } else {
    return (new BN(x * Math.pow(2, 52-e))).ushln(e-52)
  }
}

},{"bn.js":15,"double-bits":42}],12:[function(require,module,exports){
'use strict'

var num2bn = require('./num-to-bn')
var sign = require('./bn-sign')

module.exports = rationalize

function rationalize(numer, denom) {
  var snumer = sign(numer)
  var sdenom = sign(denom)
  if(snumer === 0) {
    return [num2bn(0), num2bn(1)]
  }
  if(sdenom === 0) {
    return [num2bn(0), num2bn(0)]
  }
  if(sdenom < 0) {
    numer = numer.neg()
    denom = denom.neg()
  }
  var d = numer.gcd(denom)
  if(d.cmpn(1)) {
    return [ numer.div(d), denom.div(d) ]
  }
  return [ numer, denom ]
}

},{"./bn-sign":7,"./num-to-bn":11}],13:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = str2BN

function str2BN(x) {
  return new BN(x)
}

},{"bn.js":15}],14:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = mul

function mul(a, b) {
  return rationalize(a[0].mul(b[0]), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],15:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":28}],16:[function(require,module,exports){
'use strict'

var bnsign = require('./lib/bn-sign')

module.exports = sign

function sign(x) {
  return bnsign(x[0]) * bnsign(x[1])
}

},{"./lib/bn-sign":7}],17:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = sub

function sub(a, b) {
  return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],18:[function(require,module,exports){
'use strict'

var bn2num = require('./lib/bn-to-num')
var ctz = require('./lib/ctz')

module.exports = roundRat

// Round a rational to the closest float
function roundRat (f) {
  var a = f[0]
  var b = f[1]
  if (a.cmpn(0) === 0) {
    return 0
  }
  var h = a.abs().divmod(b.abs())
  var iv = h.div
  var x = bn2num(iv)
  var ir = h.mod
  var sgn = (a.negative !== b.negative) ? -1 : 1
  if (ir.cmpn(0) === 0) {
    return sgn * x
  }
  if (x) {
    var s = ctz(x) + 4
    var y = bn2num(ir.ushln(s).divRound(b))
    return sgn * (x + y * Math.pow(2, -s))
  } else {
    var ybits = b.bitLength() - ir.bitLength() + 53
    var y = bn2num(ir.ushln(ybits).divRound(b))
    if (ybits < 1023) {
      return sgn * y * Math.pow(2, -ybits)
    }
    y *= Math.pow(2, -1023)
    return sgn * y * Math.pow(2, 1023 - ybits)
  }
}

},{"./lib/bn-to-num":8,"./lib/ctz":9}],19:[function(require,module,exports){
"use strict"

// (a, y, c, l, h) = (array, y[, cmp, lo, hi])

function ge(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p >= 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function gt(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p > 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function lt(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p < 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function le(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p <= 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function eq(a, y, c, l, h) {
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p === 0) { return m }
    if (p <= 0) { l = m + 1 } else { h = m - 1 }
  }
  return -1;
};

function norm(a, y, c, l, h, f) {
  if (typeof c === 'function') {
    return f(a, y, c, (l === undefined) ? 0 : l | 0, (h === undefined) ? a.length - 1 : h | 0);
  }
  return f(a, y, undefined, (c === undefined) ? 0 : c | 0, (l === undefined) ? a.length - 1 : l | 0);
}

module.exports = {
  ge: function(a, y, c, l, h) { return norm(a, y, c, l, h, ge)},
  gt: function(a, y, c, l, h) { return norm(a, y, c, l, h, gt)},
  lt: function(a, y, c, l, h) { return norm(a, y, c, l, h, lt)},
  le: function(a, y, c, l, h) { return norm(a, y, c, l, h, le)},
  eq: function(a, y, c, l, h) { return norm(a, y, c, l, h, eq)}
}

},{}],20:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],21:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":23,"./lib/sweep":27,"typedarray-pool":180}],22:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],23:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK.length < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":22,"./median":24,"./partition":25,"./sweep":27,"bit-twiddle":20,"typedarray-pool":180}],24:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":25}],25:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],26:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],27:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":26,"bit-twiddle":20,"typedarray-pool":180}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],30:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":30,"ieee754":78}],31:[function(require,module,exports){
'use strict'

var monotoneTriangulate = require('./lib/monotone')
var makeIndex = require('./lib/triangulation')
var delaunayFlip = require('./lib/delaunay')
var filterTriangulation = require('./lib/filter')

module.exports = cdt2d

function canonicalizeEdge(e) {
  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]
}

function compareEdge(a, b) {
  return a[0]-b[0] || a[1]-b[1]
}

function canonicalizeEdges(edges) {
  return edges.map(canonicalizeEdge).sort(compareEdge)
}

function getDefault(options, property, dflt) {
  if(property in options) {
    return options[property]
  }
  return dflt
}

function cdt2d(points, edges, options) {

  if(!Array.isArray(edges)) {
    options = edges || {}
    edges = []
  } else {
    options = options || {}
    edges = edges || []
  }

  //Parse out options
  var delaunay = !!getDefault(options, 'delaunay', true)
  var interior = !!getDefault(options, 'interior', true)
  var exterior = !!getDefault(options, 'exterior', true)
  var infinity = !!getDefault(options, 'infinity', false)

  //Handle trivial case
  if((!interior && !exterior) || points.length === 0) {
    return []
  }

  //Construct initial triangulation
  var cells = monotoneTriangulate(points, edges)

  //If delaunay refinement needed, then improve quality by edge flipping
  if(delaunay || interior !== exterior || infinity) {

    //Index all of the cells to support fast neighborhood queries
    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))
    for(var i=0; i<cells.length; ++i) {
      var f = cells[i]
      triangulation.addTriangle(f[0], f[1], f[2])
    }

    //Run edge flipping
    if(delaunay) {
      delaunayFlip(points, triangulation)
    }

    //Filter points
    if(!exterior) {
      return filterTriangulation(triangulation, -1)
    } else if(!interior) {
      return filterTriangulation(triangulation,  1, infinity)
    } else if(infinity) {
      return filterTriangulation(triangulation, 0, infinity)
    } else {
      return triangulation.cells()
    }
    
  } else {
    return cells
  }
}

},{"./lib/delaunay":32,"./lib/filter":33,"./lib/monotone":34,"./lib/triangulation":35}],32:[function(require,module,exports){
'use strict'

var inCircle = require('robust-in-sphere')[4]
var bsearch = require('binary-search-bounds')

module.exports = delaunayRefine

function testFlip(points, triangulation, stack, a, b, x) {
  var y = triangulation.opposite(a, b)

  //Test boundary edge
  if(y < 0) {
    return
  }

  //Swap edge if order flipped
  if(b < a) {
    var tmp = a
    a = b
    b = tmp
    tmp = x
    x = y
    y = tmp
  }

  //Test if edge is constrained
  if(triangulation.isConstraint(a, b)) {
    return
  }

  //Test if edge is delaunay
  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
    stack.push(a, b)
  }
}

//Assume edges are sorted lexicographically
function delaunayRefine(points, triangulation) {
  var stack = []

  var numPoints = points.length
  var stars = triangulation.stars
  for(var a=0; a<numPoints; ++a) {
    var star = stars[a]
    for(var j=1; j<star.length; j+=2) {
      var b = star[j]

      //If order is not consistent, then skip edge
      if(b < a) {
        continue
      }

      //Check if edge is constrained
      if(triangulation.isConstraint(a, b)) {
        continue
      }

      //Find opposite edge
      var x = star[j-1], y = -1
      for(var k=1; k<star.length; k+=2) {
        if(star[k-1] === b) {
          y = star[k]
          break
        }
      }

      //If this is a boundary edge, don't flip it
      if(y < 0) {
        continue
      }

      //If edge is in circle, flip it
      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b)
      }
    }
  }

  while(stack.length > 0) {
    var b = stack.pop()
    var a = stack.pop()

    //Find opposite pairs
    var x = -1, y = -1
    var star = stars[a]
    for(var i=1; i<star.length; i+=2) {
      var s = star[i-1]
      var t = star[i]
      if(s === b) {
        y = t
      } else if(t === b) {
        x = s
      }
    }

    //If x/y are both valid then skip edge
    if(x < 0 || y < 0) {
      continue
    }

    //If edge is now delaunay, then don't flip it
    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {
      continue
    }

    //Flip the edge
    triangulation.flip(a, b)

    //Test flipping neighboring edges
    testFlip(points, triangulation, stack, x, a, y)
    testFlip(points, triangulation, stack, a, y, x)
    testFlip(points, triangulation, stack, y, b, x)
    testFlip(points, triangulation, stack, b, x, y)
  }
}

},{"binary-search-bounds":19,"robust-in-sphere":104}],33:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = classifyFaces

function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
  this.cells       = cells
  this.neighbor    = neighbor
  this.flags       = flags
  this.constraint  = constraint
  this.active      = active
  this.next        = next
  this.boundary    = boundary
}

var proto = FaceIndex.prototype

function compareCell(a, b) {
  return a[0] - b[0] ||
         a[1] - b[1] ||
         a[2] - b[2]
}

proto.locate = (function() {
  var key = [0,0,0]
  return function(a, b, c) {
    var x = a, y = b, z = c
    if(b < c) {
      if(b < a) {
        x = b
        y = c
        z = a
      }
    } else if(c < a) {
      x = c
      y = a
      z = b
    }
    if(x < 0) {
      return -1
    }
    key[0] = x
    key[1] = y
    key[2] = z
    return bsearch.eq(this.cells, key, compareCell)
  }
})()

function indexCells(triangulation, infinity) {
  //First get cells and canonicalize
  var cells = triangulation.cells()
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    var x = c[0], y = c[1], z = c[2]
    if(y < z) {
      if(y < x) {
        c[0] = y
        c[1] = z
        c[2] = x
      }
    } else if(z < x) {
      c[0] = z
      c[1] = x
      c[2] = y
    }
  }
  cells.sort(compareCell)

  //Initialize flag array
  var flags = new Array(nc)
  for(var i=0; i<flags.length; ++i) {
    flags[i] = 0
  }

  //Build neighbor index, initialize queues
  var active = []
  var next   = []
  var neighbor = new Array(3*nc)
  var constraint = new Array(3*nc)
  var boundary = null
  if(infinity) {
    boundary = []
  }
  var index = new FaceIndex(
    cells,
    neighbor,
    constraint,
    flags,
    active,
    next,
    boundary)
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<3; ++j) {
      var x = c[j], y = c[(j+1)%3]
      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))
      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)
      if(a < 0) {
        if(b) {
          next.push(i)
        } else {
          active.push(i)
          flags[i] = 1
        }
        if(infinity) {
          boundary.push([y, x, -1])
        }
      }
    }
  }
  return index
}

function filterCells(cells, flags, target) {
  var ptr = 0
  for(var i=0; i<cells.length; ++i) {
    if(flags[i] === target) {
      cells[ptr++] = cells[i]
    }
  }
  cells.length = ptr
  return cells
}

function classifyFaces(triangulation, target, infinity) {
  var index = indexCells(triangulation, infinity)

  if(target === 0) {
    if(infinity) {
      return index.cells.concat(index.boundary)
    } else {
      return index.cells
    }
  }

  var side = 1
  var active = index.active
  var next = index.next
  var flags = index.flags
  var cells = index.cells
  var constraint = index.constraint
  var neighbor = index.neighbor

  while(active.length > 0 || next.length > 0) {
    while(active.length > 0) {
      var t = active.pop()
      if(flags[t] === -side) {
        continue
      }
      flags[t] = side
      var c = cells[t]
      for(var j=0; j<3; ++j) {
        var f = neighbor[3*t+j]
        if(f >= 0 && flags[f] === 0) {
          if(constraint[3*t+j]) {
            next.push(f)
          } else {
            active.push(f)
            flags[f] = side
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next
    next = active
    active = tmp
    next.length = 0
    side = -side
  }

  var result = filterCells(cells, flags, target)
  if(infinity) {
    return result.concat(index.boundary)
  }
  return result
}

},{"binary-search-bounds":19}],34:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')
var orient = require('robust-orientation')[3]

var EVENT_POINT = 0
var EVENT_END   = 1
var EVENT_START = 2

module.exports = monotoneTriangulate

//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a, b, idx, lowerIds, upperIds) {
  this.a = a
  this.b = b
  this.idx = idx
  this.lowerIds = lowerIds
  this.upperIds = upperIds
}

//An event in the sweep line procedure
function Event(a, b, type, idx) {
  this.a    = a
  this.b    = b
  this.type = type
  this.idx  = idx
}

//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a, b) {
  var d =
    (a.a[0] - b.a[0]) ||
    (a.a[1] - b.a[1]) ||
    (a.type - b.type)
  if(d) { return d }
  if(a.type !== EVENT_POINT) {
    d = orient(a.a, a.b, b.b)
    if(d) { return d }
  }
  return a.idx - b.idx
}

function testPoint(hull, p) {
  return orient(hull.a, hull.b, p)
}

function addPoint(cells, hulls, points, p, idx) {
  var lo = bsearch.lt(hulls, p, testPoint)
  var hi = bsearch.gt(hulls, p, testPoint)
  for(var i=lo; i<hi; ++i) {
    var hull = hulls[i]

    //Insert p into lower hull
    var lowerIds = hull.lowerIds
    var m = lowerIds.length
    while(m > 1 && orient(
        points[lowerIds[m-2]],
        points[lowerIds[m-1]],
        p) > 0) {
      cells.push(
        [lowerIds[m-1],
         lowerIds[m-2],
         idx])
      m -= 1
    }
    lowerIds.length = m
    lowerIds.push(idx)

    //Insert p into upper hull
    var upperIds = hull.upperIds
    var m = upperIds.length
    while(m > 1 && orient(
        points[upperIds[m-2]],
        points[upperIds[m-1]],
        p) < 0) {
      cells.push(
        [upperIds[m-2],
         upperIds[m-1],
         idx])
      m -= 1
    }
    upperIds.length = m
    upperIds.push(idx)
  }
}

function findSplit(hull, edge) {
  var d
  if(hull.a[0] < edge.a[0]) {
    d = orient(hull.a, hull.b, edge.a)
  } else {
    d = orient(edge.b, edge.a, hull.a)
  }
  if(d) { return d }
  if(edge.b[0] < hull.b[0]) {
    d = orient(hull.a, hull.b, edge.b)
  } else {
    d = orient(edge.b, edge.a, hull.b)
  }
  return d || hull.idx - edge.idx
}

function splitHulls(hulls, points, event) {
  var splitIdx = bsearch.le(hulls, event, findSplit)
  var hull = hulls[splitIdx]
  var upperIds = hull.upperIds
  var x = upperIds[upperIds.length-1]
  hull.upperIds = [x]
  hulls.splice(splitIdx+1, 0,
    new PartialHull(event.a, event.b, event.idx, [x], upperIds))
}


function mergeHulls(hulls, points, event) {
  //Swap pointers for merge search
  var tmp = event.a
  event.a = event.b
  event.b = tmp
  var mergeIdx = bsearch.eq(hulls, event, findSplit)
  var upper = hulls[mergeIdx]
  var lower = hulls[mergeIdx-1]
  lower.upperIds = upper.upperIds
  hulls.splice(mergeIdx, 1)
}


function monotoneTriangulate(points, edges) {

  var numPoints = points.length
  var numEdges = edges.length

  var events = []

  //Create point events
  for(var i=0; i<numPoints; ++i) {
    events.push(new Event(
      points[i],
      null,
      EVENT_POINT,
      i))
  }

  //Create edge events
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    if(a[0] < b[0]) {
      events.push(
        new Event(a, b, EVENT_START, i),
        new Event(b, a, EVENT_END, i))
    } else if(a[0] > b[0]) {
      events.push(
        new Event(b, a, EVENT_START, i),
        new Event(a, b, EVENT_END, i))
    }
  }

  //Sort events
  events.sort(compareEvent)

  //Initialize hull
  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)
  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]

  //Process events in order
  var cells = []
  for(var i=0, numEvents=events.length; i<numEvents; ++i) {
    var event = events[i]
    var type = event.type
    if(type === EVENT_POINT) {
      addPoint(cells, hull, points, event.a, event.idx)
    } else if(type === EVENT_START) {
      splitHulls(hull, points, event)
    } else {
      mergeHulls(hull, points, event)
    }
  }

  //Return triangulation
  return cells
}

},{"binary-search-bounds":19,"robust-orientation":105}],35:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = createTriangulation

function Triangulation(stars, edges) {
  this.stars = stars
  this.edges = edges
}

var proto = Triangulation.prototype

function removePair(list, j, k) {
  for(var i=1, n=list.length; i<n; i+=2) {
    if(list[i-1] === j && list[i] === k) {
      list[i-1] = list[n-2]
      list[i] = list[n-1]
      list.length = n - 2
      return
    }
  }
}

proto.isConstraint = (function() {
  var e = [0,0]
  function compareLex(a, b) {
    return a[0] - b[0] || a[1] - b[1]
  }
  return function(i, j) {
    e[0] = Math.min(i,j)
    e[1] = Math.max(i,j)
    return bsearch.eq(this.edges, e, compareLex) >= 0
  }
})()

proto.removeTriangle = function(i, j, k) {
  var stars = this.stars
  removePair(stars[i], j, k)
  removePair(stars[j], k, i)
  removePair(stars[k], i, j)
}

proto.addTriangle = function(i, j, k) {
  var stars = this.stars
  stars[i].push(j, k)
  stars[j].push(k, i)
  stars[k].push(i, j)
}

proto.opposite = function(j, i) {
  var list = this.stars[i]
  for(var k=1, n=list.length; k<n; k+=2) {
    if(list[k] === j) {
      return list[k-1]
    }
  }
  return -1
}

proto.flip = function(i, j) {
  var a = this.opposite(i, j)
  var b = this.opposite(j, i)
  this.removeTriangle(i, j, a)
  this.removeTriangle(j, i, b)
  this.addTriangle(i, b, a)
  this.addTriangle(j, a, b)
}

proto.edges = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      result.push([list[j], list[j+1]])
    }
  }
  return result
}

proto.cells = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      var s = list[j]
      var t = list[j+1]
      if(i < Math.min(s, t)) {
        result.push([i, s, t])
      }
    }
  }
  return result
}

function createTriangulation(numVerts, edges) {
  var stars = new Array(numVerts)
  for(var i=0; i<numVerts; ++i) {
    stars[i] = []
  }
  return new Triangulation(stars, edges)
}

},{"binary-search-bounds":19}],36:[function(require,module,exports){
'use strict'

module.exports = cleanPSLG

var UnionFind = require('union-find')
var boxIntersect = require('box-intersect')
var segseg = require('robust-segment-intersect')
var rat = require('big-rat')
var ratCmp = require('big-rat/cmp')
var ratToFloat = require('big-rat/to-float')
var ratVec = require('rat-vec')
var nextafter = require('nextafter')

var solveIntersection = require('./lib/rat-seg-intersect')

// Bounds on a rational number when rounded to a float
function boundRat (r) {
  var f = ratToFloat(r)
  return [
    nextafter(f, -Infinity),
    nextafter(f, Infinity)
  ]
}

// Convert a list of edges in a pslg to bounding boxes
function boundEdges (points, edges) {
  var bounds = new Array(edges.length)
  for (var i = 0; i < edges.length; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    bounds[i] = [
      nextafter(Math.min(a[0], b[0]), -Infinity),
      nextafter(Math.min(a[1], b[1]), -Infinity),
      nextafter(Math.max(a[0], b[0]), Infinity),
      nextafter(Math.max(a[1], b[1]), Infinity)
    ]
  }
  return bounds
}

// Convert a list of points into bounding boxes by duplicating coords
function boundPoints (points) {
  var bounds = new Array(points.length)
  for (var i = 0; i < points.length; ++i) {
    var p = points[i]
    bounds[i] = [
      nextafter(p[0], -Infinity),
      nextafter(p[1], -Infinity),
      nextafter(p[0], Infinity),
      nextafter(p[1], Infinity)
    ]
  }
  return bounds
}

// Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings (points, edges, edgeBounds) {
  var result = []
  boxIntersect(edgeBounds, function (i, j) {
    var e = edges[i]
    var f = edges[j]
    if (e[0] === f[0] || e[0] === f[1] ||
      e[1] === f[0] || e[1] === f[1]) {
      return
    }
    var a = points[e[0]]
    var b = points[e[1]]
    var c = points[f[0]]
    var d = points[f[1]]
    if (segseg(a, b, c, d)) {
      result.push([i, j])
    }
  })
  return result
}

// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions (points, edges, edgeBounds, vertBounds) {
  var result = []
  boxIntersect(edgeBounds, vertBounds, function (i, v) {
    var e = edges[i]
    if (e[0] === v || e[1] === v) {
      return
    }
    var p = points[v]
    var a = points[e[0]]
    var b = points[e[1]]
    if (segseg(a, b, p, p)) {
      result.push([i, v])
    }
  })
  return result
}

// Cut edges along crossings/tjunctions
function cutEdges (floatPoints, edges, crossings, junctions, useColor) {
  var i, e

  // Convert crossings into tjunctions by constructing rational points
  var ratPoints = floatPoints.map(function(p) {
      return [
          rat(p[0]),
          rat(p[1])
      ]
  })
  for (i = 0; i < crossings.length; ++i) {
    var crossing = crossings[i]
    e = crossing[0]
    var f = crossing[1]
    var ee = edges[e]
    var ef = edges[f]
    var x = solveIntersection(
      ratVec(floatPoints[ee[0]]),
      ratVec(floatPoints[ee[1]]),
      ratVec(floatPoints[ef[0]]),
      ratVec(floatPoints[ef[1]]))
    if (!x) {
      // Segments are parallel, should already be handled by t-junctions
      continue
    }
    var idx = floatPoints.length
    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])])
    ratPoints.push(x)
    junctions.push([e, idx], [f, idx])
  }

  // Sort tjunctions
  junctions.sort(function (a, b) {
    if (a[0] !== b[0]) {
      return a[0] - b[0]
    }
    var u = ratPoints[a[1]]
    var v = ratPoints[b[1]]
    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])
  })

  // Split edges along junctions
  for (i = junctions.length - 1; i >= 0; --i) {
    var junction = junctions[i]
    e = junction[0]

    var edge = edges[e]
    var s = edge[0]
    var t = edge[1]

    // Check if edge is not lexicographically sorted
    var a = floatPoints[s]
    var b = floatPoints[t]
    if (((a[0] - b[0]) || (a[1] - b[1])) < 0) {
      var tmp = s
      s = t
      t = tmp
    }

    // Split leading edge
    edge[0] = s
    var last = edge[1] = junction[1]

    // If we are grouping edges by color, remember to track data
    var color
    if (useColor) {
      color = edge[2]
    }

    // Split other edges
    while (i > 0 && junctions[i - 1][0] === e) {
      var junction = junctions[--i]
      var next = junction[1]
      if (useColor) {
        edges.push([last, next, color])
      } else {
        edges.push([last, next])
      }
      last = next
    }

    // Add final edge
    if (useColor) {
      edges.push([last, t, color])
    } else {
      edges.push([last, t])
    }
  }

  // Return constructed rational points
  return ratPoints
}

// Merge overlapping points
function dedupPoints (floatPoints, ratPoints, floatBounds) {
  var numPoints = ratPoints.length
  var uf = new UnionFind(numPoints)

  // Compute rational bounds
  var bounds = []
  for (var i = 0; i < ratPoints.length; ++i) {
    var p = ratPoints[i]
    var xb = boundRat(p[0])
    var yb = boundRat(p[1])
    bounds.push([
      nextafter(xb[0], -Infinity),
      nextafter(yb[0], -Infinity),
      nextafter(xb[1], Infinity),
      nextafter(yb[1], Infinity)
    ])
  }

  // Link all points with over lapping boxes
  boxIntersect(bounds, function (i, j) {
    uf.link(i, j)
  })

  // Do 1 pass over points to combine points in label sets
  var noDupes = true
  var labels = new Array(numPoints)
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j !== i) {
      // Clear no-dupes flag, zero out label
      noDupes = false
      // Make each point the top-left point from its cell
      floatPoints[j] = [
        Math.min(floatPoints[i][0], floatPoints[j][0]),
        Math.min(floatPoints[i][1], floatPoints[j][1])
      ]
    }
  }

  // If no duplicates, return null to signal termination
  if (noDupes) {
    return null
  }

  var ptr = 0
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j === i) {
      labels[i] = ptr
      floatPoints[ptr++] = floatPoints[i]
    } else {
      labels[i] = -1
    }
  }

  floatPoints.length = ptr

  // Do a second pass to fix up missing labels
  for (var i = 0; i < numPoints; ++i) {
    if (labels[i] < 0) {
      labels[i] = labels[uf.find(i)]
    }
  }

  // Return resulting union-find data structure
  return labels
}

function compareLex2 (a, b) { return (a[0] - b[0]) || (a[1] - b[1]) }
function compareLex3 (a, b) {
  var d = (a[0] - b[0]) || (a[1] - b[1])
  if (d) {
    return d
  }
  if (a[2] < b[2]) {
    return -1
  } else if (a[2] > b[2]) {
    return 1
  }
  return 0
}

// Remove duplicate edge labels
function dedupEdges (edges, labels, useColor) {
  if (edges.length === 0) {
    return
  }
  if (labels) {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = labels[e[0]]
      var b = labels[e[1]]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  } else {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = e[0]
      var b = e[1]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  }
  if (useColor) {
    edges.sort(compareLex3)
  } else {
    edges.sort(compareLex2)
  }
  var ptr = 1
  for (var i = 1; i < edges.length; ++i) {
    var prev = edges[i - 1]
    var next = edges[i]
    if (next[0] === prev[0] && next[1] === prev[1] &&
      (!useColor || next[2] === prev[2])) {
      continue
    }
    edges[ptr++] = next
  }
  edges.length = ptr
}

function preRound (points, edges, useColor) {
  var labels = dedupPoints(points, [], boundPoints(points))
  dedupEdges(edges, labels, useColor)
  return !!labels
}

// Repeat until convergence
function snapRound (points, edges, useColor) {
  // 1. find edge crossings
  var edgeBounds = boundEdges(points, edges)
  var crossings = getCrossings(points, edges, edgeBounds)

  // 2. find t-junctions
  var vertBounds = boundPoints(points)
  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)

  // 3. cut edges, construct rational points
  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor)

  // 4. dedupe verts
  var labels = dedupPoints(points, ratPoints, vertBounds)

  // 5. dedupe edges
  dedupEdges(edges, labels, useColor)

  // 6. check termination
  if (!labels) {
    return (crossings.length > 0 || tjunctions.length > 0)
  }

  // More iterations necessary
  return true
}

// Main loop, runs PSLG clean up until completion
function cleanPSLG (points, edges, colors) {
  // If using colors, augment edges with color data
  var prevEdges
  if (colors) {
    prevEdges = edges
    var augEdges = new Array(edges.length)
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      augEdges[i] = [e[0], e[1], colors[i]]
    }
    edges = augEdges
  }

  // First round: remove duplicate edges and points
  var modified = preRound(points, edges, !!colors)

  // Run snap rounding until convergence
  while (snapRound(points, edges, !!colors)) {
    modified = true
  }

  // Strip color tags
  if (!!colors && modified) {
    prevEdges.length = 0
    colors.length = 0
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      prevEdges.push([e[0], e[1]])
      colors.push(e[2])
    }
  }

  return modified
}

},{"./lib/rat-seg-intersect":37,"big-rat":5,"big-rat/cmp":3,"big-rat/to-float":18,"box-intersect":21,"nextafter":87,"rat-vec":99,"robust-segment-intersect":108,"union-find":181}],37:[function(require,module,exports){
'use strict'

module.exports = solveIntersection

var ratMul = require('big-rat/mul')
var ratDiv = require('big-rat/div')
var ratSub = require('big-rat/sub')
var ratSign = require('big-rat/sign')
var rvSub = require('rat-vec/sub')
var rvAdd = require('rat-vec/add')
var rvMuls = require('rat-vec/muls')

function ratPerp (a, b) {
  return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]))
}

// Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)

function solveIntersection (a, b, c, d) {
  var ba = rvSub(b, a)
  var dc = rvSub(d, c)

  var baXdc = ratPerp(ba, dc)

  if (ratSign(baXdc) === 0) {
    return null
  }

  var ac = rvSub(a, c)
  var dcXac = ratPerp(dc, ac)

  var t = ratDiv(dcXac, baXdc)
  var s = rvMuls(ba, t)
  var r = rvAdd(a, s)

  return r
}

},{"big-rat/div":4,"big-rat/mul":14,"big-rat/sign":16,"big-rat/sub":17,"rat-vec/add":98,"rat-vec/muls":100,"rat-vec/sub":101}],38:[function(require,module,exports){
"use strict"

module.exports = compareAngle

var orient = require("robust-orientation")
var sgn = require("signum")
var twoSum = require("two-sum")
var robustProduct = require("robust-product")
var robustSum = require("robust-sum")

function testInterior(a, b, c) {
  var x0 = twoSum(a[0], -b[0])
  var y0 = twoSum(a[1], -b[1])
  var x1 = twoSum(c[0], -b[0])
  var y1 = twoSum(c[1], -b[1])

  var d = robustSum(
    robustProduct(x0, x1),
    robustProduct(y0, y1))

  return d[d.length-1] >= 0
}

function compareAngle(a, b, c, d) {
  var bcd = orient(b, c, d)
  if(bcd === 0) {
    //Handle degenerate cases
    var sabc = sgn(orient(a, b, c))
    var sabd = sgn(orient(a, b, d))
    if(sabc === sabd) {
      if(sabc === 0) {
        var ic = testInterior(a, b, c)
        var id = testInterior(a, b, d)
        if(ic === id) {
          return 0
        } else if(ic) {
          return 1
        } else {
          return -1
        }
      }
      return 0
    } else if(sabd === 0) {
      if(sabc > 0) {
        return -1
      } else if(testInterior(a, b, d)) {
        return -1
      } else {
        return 1
      }
    } else if(sabc === 0) {
      if(sabd > 0) {
        return 1
      } else if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
    return sgn(sabd - sabc)
  }
  var abc = orient(a, b, c)
  if(abc > 0) {
    if(bcd > 0 && orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else if(abc < 0) {
    if(bcd > 0 || orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else {
    var abd = orient(a, b, d)
    if(abd > 0) {
      return 1
    } else {
      if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
  }
}
},{"robust-orientation":105,"robust-product":106,"robust-sum":110,"signum":111,"two-sum":179}],39:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":41}],40:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":182}],41:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":40}],42:[function(require,module,exports){
(function (Buffer){(function (){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":30}],43:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],44:[function(require,module,exports){
"use strict"

module.exports = edgeToAdjacency

var uniq = require("uniq")

function edgeToAdjacency(edges, numVertices) {
  var numEdges = edges.length
  if(typeof numVertices !== "number") {
    numVertices = 0
    for(var i=0; i<numEdges; ++i) {
      var e = edges[i]
      numVertices = Math.max(numVertices, e[0], e[1])
    }
    numVertices = (numVertices|0) + 1
  }
  numVertices = numVertices|0
  var adj = new Array(numVertices)
  for(var i=0; i<numVertices; ++i) {
    adj[i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    adj[e[0]].push(e[1])
    adj[e[1]].push(e[0])
  }
  for(var j=0; j<numVertices; ++j) {
    uniq(adj[j], function(a, b) {
      return a - b
    })
  }
  return adj
}
},{"uniq":182}],45:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}],46:[function(require,module,exports){
// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
];

var g_ln = 607/128;
var p_ln = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.21743961811521264320e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.26190838401581408670e-4,
    0.36899182659531622704e-5
];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if(z < 0) return Number('0/0');
    var x = p_ln[0];
    for(var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5*Math.log(2*Math.PI)+(z+.5)*Math.log(t)-t+Math.log(x)-Math.log(z);
}

module.exports = function gamma (z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    }
    else if(z > 100) return Math.exp(lngamma(z));
    else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI)
            * Math.pow(t, z + 0.5)
            * Math.exp(-t)
            * x
        ;
    }
};

module.exports.log = lngamma;

},{}],47:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],48:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],49:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],50:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],51:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],52:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],53:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],54:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],55:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],56:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],57:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],58:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],59:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],60:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],61:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],62:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":47,"./clone":48,"./copy":49,"./create":50,"./determinant":51,"./fromQuat":52,"./fromRotation":53,"./fromRotationTranslation":54,"./fromScaling":55,"./fromTranslation":56,"./fromXRotation":57,"./fromYRotation":58,"./fromZRotation":59,"./frustum":60,"./identity":61,"./invert":63,"./lookAt":64,"./multiply":65,"./ortho":66,"./perspective":67,"./perspectiveFromFieldOfView":68,"./rotate":69,"./rotateX":70,"./rotateY":71,"./rotateZ":72,"./scale":73,"./str":74,"./translate":75,"./transpose":76}],63:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],64:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":61}],65:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],66:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],69:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],71:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],72:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],73:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],74:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],75:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],76:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],77:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],78:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],79:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],80:[function(require,module,exports){
"use strict"

var bounds = require("binary-search-bounds")

var NOT_FOUND = 0
var SUCCESS = 1
var EMPTY = 2

module.exports = createWrapper

function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
  this.mid = mid
  this.left = left
  this.right = right
  this.leftPoints = leftPoints
  this.rightPoints = rightPoints
  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length
}

var proto = IntervalTreeNode.prototype

function copy(a, b) {
  a.mid = b.mid
  a.left = b.left
  a.right = b.right
  a.leftPoints = b.leftPoints
  a.rightPoints = b.rightPoints
  a.count = b.count
}

function rebuild(node, intervals) {
  var ntree = createIntervalTree(intervals)
  node.mid = ntree.mid
  node.left = ntree.left
  node.right = ntree.right
  node.leftPoints = ntree.leftPoints
  node.rightPoints = ntree.rightPoints
  node.count = ntree.count
}

function rebuildWithInterval(node, interval) {
  var intervals = node.intervals([])
  intervals.push(interval)
  rebuild(node, intervals)    
}

function rebuildWithoutInterval(node, interval) {
  var intervals = node.intervals([])
  var idx = intervals.indexOf(interval)
  if(idx < 0) {
    return NOT_FOUND
  }
  intervals.splice(idx, 1)
  rebuild(node, intervals)
  return SUCCESS
}

proto.intervals = function(result) {
  result.push.apply(result, this.leftPoints)
  if(this.left) {
    this.left.intervals(result)
  }
  if(this.right) {
    this.right.intervals(result)
  }
  return result
}

proto.insert = function(interval) {
  var weight = this.count - this.leftPoints.length
  this.count += 1
  if(interval[1] < this.mid) {
    if(this.left) {
      if(4*(this.left.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.left.insert(interval)
      }
    } else {
      this.left = createIntervalTree([interval])
    }
  } else if(interval[0] > this.mid) {
    if(this.right) {
      if(4*(this.right.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.right.insert(interval)
      }
    } else {
      this.right = createIntervalTree([interval])
    }
  } else {
    var l = bounds.ge(this.leftPoints, interval, compareBegin)
    var r = bounds.ge(this.rightPoints, interval, compareEnd)
    this.leftPoints.splice(l, 0, interval)
    this.rightPoints.splice(r, 0, interval)
  }
}

proto.remove = function(interval) {
  var weight = this.count - this.leftPoints
  if(interval[1] < this.mid) {
    if(!this.left) {
      return NOT_FOUND
    }
    var rw = this.right ? this.right.count : 0
    if(4 * rw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.left.remove(interval)
    if(r === EMPTY) {
      this.left = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else if(interval[0] > this.mid) {
    if(!this.right) {
      return NOT_FOUND
    }
    var lw = this.left ? this.left.count : 0
    if(4 * lw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.right.remove(interval)
    if(r === EMPTY) {
      this.right = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else {
    if(this.count === 1) {
      if(this.leftPoints[0] === interval) {
        return EMPTY
      } else {
        return NOT_FOUND
      }
    }
    if(this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
      if(this.left && this.right) {
        var p = this
        var n = this.left
        while(n.right) {
          p = n
          n = n.right
        }
        if(p === this) {
          n.right = this.right
        } else {
          var l = this.left
          var r = this.right
          p.count -= n.count
          p.right = n.left
          n.left = l
          n.right = r
        }
        copy(this, n)
        this.count = (this.left?this.left.count:0) + (this.right?this.right.count:0) + this.leftPoints.length
      } else if(this.left) {
        copy(this, this.left)
      } else {
        copy(this, this.right)
      }
      return SUCCESS
    }
    for(var l = bounds.ge(this.leftPoints, interval, compareBegin); l<this.leftPoints.length; ++l) {
      if(this.leftPoints[l][0] !== interval[0]) {
        break
      }
      if(this.leftPoints[l] === interval) {
        this.count -= 1
        this.leftPoints.splice(l, 1)
        for(var r = bounds.ge(this.rightPoints, interval, compareEnd); r<this.rightPoints.length; ++r) {
          if(this.rightPoints[r][1] !== interval[1]) {
            break
          } else if(this.rightPoints[r] === interval) {
            this.rightPoints.splice(r, 1)
            return SUCCESS
          }
        }
      }
    }
    return NOT_FOUND
  }
}

function reportLeftRange(arr, hi, cb) {
  for(var i=0; i<arr.length && arr[i][0] <= hi; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRightRange(arr, lo, cb) {
  for(var i=arr.length-1; i>=0 && arr[i][1] >= lo; --i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRange(arr, cb) {
  for(var i=0; i<arr.length; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

proto.queryPoint = function(x, cb) {
  if(x < this.mid) {
    if(this.left) {
      var r = this.left.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportLeftRange(this.leftPoints, x, cb)
  } else if(x > this.mid) {
    if(this.right) {
      var r = this.right.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportRightRange(this.rightPoints, x, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

proto.queryInterval = function(lo, hi, cb) {
  if(lo < this.mid && this.left) {
    var r = this.left.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi > this.mid && this.right) {
    var r = this.right.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi < this.mid) {
    return reportLeftRange(this.leftPoints, hi, cb)
  } else if(lo > this.mid) {
    return reportRightRange(this.rightPoints, lo, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

function compareNumbers(a, b) {
  return a - b
}

function compareBegin(a, b) {
  var d = a[0] - b[0]
  if(d) { return d }
  return a[1] - b[1]
}

function compareEnd(a, b) {
  var d = a[1] - b[1]
  if(d) { return d }
  return a[0] - b[0]
}

function createIntervalTree(intervals) {
  if(intervals.length === 0) {
    return null
  }
  var pts = []
  for(var i=0; i<intervals.length; ++i) {
    pts.push(intervals[i][0], intervals[i][1])
  }
  pts.sort(compareNumbers)

  var mid = pts[pts.length>>1]

  var leftIntervals = []
  var rightIntervals = []
  var centerIntervals = []
  for(var i=0; i<intervals.length; ++i) {
    var s = intervals[i]
    if(s[1] < mid) {
      leftIntervals.push(s)
    } else if(mid < s[0]) {
      rightIntervals.push(s)
    } else {
      centerIntervals.push(s)
    }
  }

  //Split center intervals
  var leftPoints = centerIntervals
  var rightPoints = centerIntervals.slice()
  leftPoints.sort(compareBegin)
  rightPoints.sort(compareEnd)

  return new IntervalTreeNode(mid, 
    createIntervalTree(leftIntervals),
    createIntervalTree(rightIntervals),
    leftPoints,
    rightPoints)
}

//User friendly wrapper that makes it possible to support empty trees
function IntervalTree(root) {
  this.root = root
}

var tproto = IntervalTree.prototype

tproto.insert = function(interval) {
  if(this.root) {
    this.root.insert(interval)
  } else {
    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval])
  }
}

tproto.remove = function(interval) {
  if(this.root) {
    var r = this.root.remove(interval)
    if(r === EMPTY) {
      this.root = null
    }
    return r !== NOT_FOUND
  }
  return false
}

tproto.queryPoint = function(p, cb) {
  if(this.root) {
    return this.root.queryPoint(p, cb)
  }
}

tproto.queryInterval = function(lo, hi, cb) {
  if(lo <= hi && this.root) {
    return this.root.queryInterval(lo, hi, cb)
  }
}

Object.defineProperty(tproto, "count", {
  get: function() {
    if(this.root) {
      return this.root.count
    }
    return 0
  }
})

Object.defineProperty(tproto, "intervals", {
  get: function() {
    if(this.root) {
      return this.root.intervals([])
    }
    return []
  }
})

function createWrapper(intervals) {
  if(!intervals || intervals.length === 0) {
    return new IntervalTree(null)
  }
  return new IntervalTree(createIntervalTree(intervals))
}

},{"binary-search-bounds":19}],81:[function(require,module,exports){
"use strict"

function invertPermutation(pi, result) {
  result = result || new Array(pi.length)
  for(var i=0; i<pi.length; ++i) {
    result[pi[i]] = i
  }
  return result
}

module.exports = invertPermutation
},{}],82:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],83:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],84:[function(require,module,exports){
!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(r="undefined"!=typeof globalThis?globalThis:r||self).Meyda=t()}(this,(function(){"use strict";function r(r,t,e){if(e||2===arguments.length)for(var a,n=0,o=t.length;n<o;n++)!a&&n in t||(a||(a=Array.prototype.slice.call(t,0,n)),a[n]=t[n]);return r.concat(a||Array.prototype.slice.call(t))}var t=Object.freeze({__proto__:null,blackman:function(r){for(var t=new Float32Array(r),e=2*Math.PI/(r-1),a=2*e,n=0;n<r/2;n++)t[n]=.42-.5*Math.cos(n*e)+.08*Math.cos(n*a);for(n=Math.ceil(r/2);n>0;n--)t[r-n]=t[n-1];return t},sine:function(r){for(var t=Math.PI/(r-1),e=new Float32Array(r),a=0;a<r;a++)e[a]=Math.sin(t*a);return e},hanning:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.5-.5*Math.cos(2*Math.PI*e/(r-1));return t},hamming:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.54-.46*Math.cos(2*Math.PI*(e/r-1));return t}}),e={};function a(r){for(;r%2==0&&r>1;)r/=2;return 1===r}function n(r,a){if("rect"!==a){if(""!==a&&a||(a="hanning"),e[a]||(e[a]={}),!e[a][r.length])try{e[a][r.length]=t[a](r.length)}catch(r){throw new Error("Invalid windowing function")}r=function(r,t){for(var e=[],a=0;a<Math.min(r.length,t.length);a++)e[a]=r[a]*t[a];return e}(r,e[a][r.length])}return r}function o(r,t,e){for(var a=new Float32Array(r),n=0;n<a.length;n++)a[n]=n*t/e,a[n]=13*Math.atan(a[n]/1315.8)+3.5*Math.atan(Math.pow(a[n]/7518,2));return a}function i(r){return Float32Array.from(r)}function u(r){return 1125*Math.log(1+r/700)}function f(r,t,e){for(var a,n=new Float32Array(r+2),o=new Float32Array(r+2),i=t/2,f=u(0),c=(u(i)-f)/(r+1),l=new Array(r+2),s=0;s<n.length;s++)n[s]=s*c,o[s]=(a=n[s],700*(Math.exp(a/1125)-1)),l[s]=Math.floor((e+1)*o[s]/t);for(var m=new Array(r),p=0;p<m.length;p++){m[p]=new Array(e/2+1).fill(0);for(s=l[p];s<l[p+1];s++)m[p][s]=(s-l[p])/(l[p+1]-l[p]);for(s=l[p+1];s<l[p+2];s++)m[p][s]=(l[p+2]-s)/(l[p+2]-l[p+1])}return m}function c(t,e,a,n,o,i,u){void 0===n&&(n=5),void 0===o&&(o=2),void 0===i&&(i=!0),void 0===u&&(u=440);var f=Math.floor(a/2)+1,c=new Array(a).fill(0).map((function(r,n){return t*function(r,t){return Math.log2(16*r/t)}(e*n/a,u)}));c[0]=c[1]-1.5*t;var l,s,m,p=c.slice(1).map((function(r,t){return Math.max(r-c[t])}),1).concat([1]),h=Math.round(t/2),g=new Array(t).fill(0).map((function(r,e){return c.map((function(r){return(10*t+h+r-e)%t-h}))})),w=g.map((function(r,t){return r.map((function(r,e){return Math.exp(-.5*Math.pow(2*g[t][e]/p[e],2))}))}));if(s=(l=w)[0].map((function(){return 0})),m=l.reduce((function(r,t){return t.forEach((function(t,e){r[e]+=Math.pow(t,2)})),r}),s).map(Math.sqrt),w=l.map((function(r,t){return r.map((function(r,t){return r/(m[t]||1)}))})),o){var v=c.map((function(r){return Math.exp(-.5*Math.pow((r/t-n)/o,2))}));w=w.map((function(r){return r.map((function(r,t){return r*v[t]}))}))}return i&&(w=r(r([],w.slice(3),!0),w.slice(0,3),!0)),w.map((function(r){return r.slice(0,f)}))}function l(r,t){for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.pow(n,r)*Math.abs(t[n]),a+=t[n];return e/a}function s(r){var t=r.ampSpectrum,e=r.barkScale,a=r.numberOfBarkBands,n=void 0===a?24:a;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;var o=n,i=new Float32Array(o),u=0,f=t,c=new Int32Array(o+1);c[0]=0;for(var l=e[f.length-1]/o,s=1,m=0;m<f.length;m++)for(;e[m]>l;)c[s++]=m,l=s*e[f.length-1]/o;c[o]=f.length-1;for(m=0;m<o;m++){for(var p=0,h=c[m];h<c[m+1];h++)p+=f[h];i[m]=Math.pow(p,.23)}for(m=0;m<i.length;m++)u+=i[m];return{specific:i,total:u}}function m(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=new Float32Array(t.length),a=0;a<e.length;a++)e[a]=Math.pow(t[a],2);return e}function p(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.bufferSize;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate melBands");if("object"!=typeof e)throw new TypeError("Valid melFilterBank is required to generate melBands");for(var n=m({ampSpectrum:t}),o=e.length,i=Array(o),u=new Float32Array(o),f=0;f<u.length;f++){i[f]=new Float32Array(a/2),u[f]=0;for(var c=0;c<a/2;c++)i[f][c]=e[f][c]*n[c],u[f]+=i[f][c];u[f]=Math.log(u[f]+1)}return Array.prototype.slice.call(u)}function h(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var g={exports:{}},w=null;var v=function(r,t){var e=r.length;return t=t||2,w&&w[e]||function(r){(w=w||{})[r]=new Array(r*r);for(var t=Math.PI/r,e=0;e<r;e++)for(var a=0;a<r;a++)w[r][a+e*r]=Math.cos(t*(a+.5)*e)}(e),r.map((function(){return 0})).map((function(a,n){return t*r.reduce((function(r,t,a,o){return r+t*w[e][a+n*e]}),0)}))};!function(r){r.exports=v}(g);var d=h(g.exports);var y=Object.freeze({__proto__:null,buffer:function(r){return r.signal},rms:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(t[a],2);return e/=t.length,e=Math.sqrt(e)},energy:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(Math.abs(t[a]),2);return e},complexSpectrum:function(r){return r.complexSpectrum},spectralSlope:function(r){var t=r.ampSpectrum,e=r.sampleRate,a=r.bufferSize;if("object"!=typeof t)throw new TypeError;for(var n=0,o=0,i=new Float32Array(t.length),u=0,f=0,c=0;c<t.length;c++){n+=t[c];var l=c*e/a;i[c]=l,u+=l*l,o+=l,f+=l*t[c]}return(t.length*f-o*n)/(n*(u-Math.pow(o,2)))},spectralCentroid:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return l(1,t)},spectralRolloff:function(r){var t=r.ampSpectrum,e=r.sampleRate;if("object"!=typeof t)throw new TypeError;for(var a=t,n=e/(2*(a.length-1)),o=0,i=0;i<a.length;i++)o+=a[i];for(var u=.99*o,f=a.length-1;o>u&&f>=0;)o-=a[f],--f;return(f+1)*n},spectralFlatness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.log(t[n]),a+=t[n];return Math.exp(e/t.length)*t.length/a},spectralSpread:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return Math.sqrt(l(2,t)-Math.pow(l(1,t),2))},spectralSkewness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=l(1,t),a=l(2,t),n=l(3,t);return(2*Math.pow(e,3)-3*e*a+n)/Math.pow(Math.sqrt(a-Math.pow(e,2)),3)},spectralKurtosis:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=t,a=l(1,e),n=l(2,e),o=l(3,e),i=l(4,e);return(-3*Math.pow(a,4)+6*a*n-4*a*o+i)/Math.pow(Math.sqrt(n-Math.pow(a,2)),4)},amplitudeSpectrum:function(r){return r.ampSpectrum},zcr:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=1;a<t.length;a++)(t[a-1]>=0&&t[a]<0||t[a-1]<0&&t[a]>=0)&&e++;return e},loudness:s,perceptualSpread:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=0,a=0;a<t.specific.length;a++)t.specific[a]>e&&(e=t.specific[a]);return Math.pow((t.total-e)/t.total,2)},perceptualSharpness:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=t.specific,a=0,n=0;n<e.length;n++)a+=n<15?(n+1)*e[n+1]:.066*Math.exp(.171*(n+1));return a*=.11/t.total},powerSpectrum:m,mfcc:function(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.numberOfMFCCCoefficients,n=r.bufferSize,o=Math.min(40,Math.max(1,a||13));if(e.length<o)throw new Error("Insufficient filter bank for requested number of coefficients");var i=p({ampSpectrum:t,melFilterBank:e,bufferSize:n});return d(i).slice(0,o)},chroma:function(r){var t=r.ampSpectrum,e=r.chromaFilterBank;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate chroma");if("object"!=typeof e)throw new TypeError("Valid chromaFilterBank is required to generate chroma");var a=e.map((function(r,e){return t.reduce((function(t,e,a){return t+e*r[a]}),0)})),n=Math.max.apply(Math,a);return n?a.map((function(r){return r/n})):a},spectralFlux:function(r){var t=r.signal,e=r.previousSignal,a=r.bufferSize;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;for(var n=0,o=-a/2;o<t.length/2-1;o++)x=Math.abs(t[o])-Math.abs(e[o]),n+=(x+Math.abs(x))/2;return n},spectralCrest:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=0,a=-1/0;return t.forEach((function(r){e+=Math.pow(r,2),a=r>a?r:a})),e/=t.length,e=Math.sqrt(e),a/e},melBands:p});function S(r){if(Array.isArray(r)){for(var t=0,e=Array(r.length);t<r.length;t++)e[t]=r[t];return e}return Array.from(r)}var _={},b={},M={bitReverseArray:function(r){if(void 0===_[r]){for(var t=(r-1).toString(2).length,e="0".repeat(t),a={},n=0;n<r;n++){var o=n.toString(2);o=e.substr(o.length)+o,o=[].concat(S(o)).reverse().join(""),a[n]=parseInt(o,2)}_[r]=a}return _[r]},multiply:function(r,t){return{real:r.real*t.real-r.imag*t.imag,imag:r.real*t.imag+r.imag*t.real}},add:function(r,t){return{real:r.real+t.real,imag:r.imag+t.imag}},subtract:function(r,t){return{real:r.real-t.real,imag:r.imag-t.imag}},euler:function(r,t){var e=-2*Math.PI*r/t;return{real:Math.cos(e),imag:Math.sin(e)}},conj:function(r){return r.imag*=-1,r},constructComplexArray:function(r){var t={};t.real=void 0===r.real?r.slice():r.real.slice();var e=t.real.length;return void 0===b[e]&&(b[e]=Array.apply(null,Array(e)).map(Number.prototype.valueOf,0)),t.imag=b[e].slice(),t}},F=function(r){var t={};void 0===r.real||void 0===r.imag?t=M.constructComplexArray(r):(t.real=r.real.slice(),t.imag=r.imag.slice());var e=t.real.length,a=Math.log2(e);if(Math.round(a)!=a)throw new Error("Input size must be a power of 2.");if(t.real.length!=t.imag.length)throw new Error("Real and imaginary components must have the same length.");for(var n=M.bitReverseArray(e),o={real:[],imag:[]},i=0;i<e;i++)o.real[n[i]]=t.real[i],o.imag[n[i]]=t.imag[i];for(var u=0;u<e;u++)t.real[u]=o.real[u],t.imag[u]=o.imag[u];for(var f=1;f<=a;f++)for(var c=Math.pow(2,f),l=0;l<c/2;l++)for(var s=M.euler(l,c),m=0;m<e/c;m++){var p=c*m+l,h=c*m+l+c/2,g={real:t.real[p],imag:t.imag[p]},w={real:t.real[h],imag:t.imag[h]},v=M.multiply(s,w),d=M.subtract(g,v);t.real[h]=d.real,t.imag[h]=d.imag;var y=M.add(v,g);t.real[p]=y.real,t.imag[p]=y.imag}return t},A=F,E=function(){function r(r,t){var e=this;if(this._m=t,!r.audioContext)throw this._m.errors.noAC;if(r.bufferSize&&!a(r.bufferSize))throw this._m._errors.notPow2;if(!r.source)throw this._m._errors.noSource;this._m.audioContext=r.audioContext,this._m.bufferSize=r.bufferSize||this._m.bufferSize||256,this._m.hopSize=r.hopSize||this._m.hopSize||this._m.bufferSize,this._m.sampleRate=r.sampleRate||this._m.audioContext.sampleRate||44100,this._m.callback=r.callback,this._m.windowingFunction=r.windowingFunction||"hanning",this._m.featureExtractors=y,this._m.EXTRACTION_STARTED=r.startImmediately||!1,this._m.channel="number"==typeof r.channel?r.channel:0,this._m.inputs=r.inputs||1,this._m.outputs=r.outputs||1,this._m.numberOfMFCCCoefficients=r.numberOfMFCCCoefficients||this._m.numberOfMFCCCoefficients||13,this._m.numberOfBarkBands=r.numberOfBarkBands||this._m.numberOfBarkBands||24,this._m.spn=this._m.audioContext.createScriptProcessor(this._m.bufferSize,this._m.inputs,this._m.outputs),this._m.spn.connect(this._m.audioContext.destination),this._m._featuresToExtract=r.featureExtractors||[],this._m.barkScale=o(this._m.bufferSize,this._m.sampleRate,this._m.bufferSize),this._m.melFilterBank=f(Math.max(this._m.melBands,this._m.numberOfMFCCCoefficients),this._m.sampleRate,this._m.bufferSize),this._m.inputData=null,this._m.previousInputData=null,this._m.frame=null,this._m.previousFrame=null,this.setSource(r.source),this._m.spn.onaudioprocess=function(r){var t;null!==e._m.inputData&&(e._m.previousInputData=e._m.inputData),e._m.inputData=r.inputBuffer.getChannelData(e._m.channel),e._m.previousInputData?((t=new Float32Array(e._m.previousInputData.length+e._m.inputData.length-e._m.hopSize)).set(e._m.previousInputData.slice(e._m.hopSize)),t.set(e._m.inputData,e._m.previousInputData.length-e._m.hopSize)):t=e._m.inputData,function(r,t,e){if(r.length<t)throw new Error("Buffer is too short for frame length");if(e<1)throw new Error("Hop length cannot be less that 1");if(t<1)throw new Error("Frame length cannot be less that 1");var a=1+Math.floor((r.length-t)/e);return new Array(a).fill(0).map((function(a,n){return r.slice(n*e,n*e+t)}))}(t,e._m.bufferSize,e._m.hopSize).forEach((function(r){e._m.frame=r;var t=e._m.extract(e._m._featuresToExtract,e._m.frame,e._m.previousFrame);"function"==typeof e._m.callback&&e._m.EXTRACTION_STARTED&&e._m.callback(t),e._m.previousFrame=e._m.frame}))}}return r.prototype.start=function(r){this._m._featuresToExtract=r||this._m._featuresToExtract,this._m.EXTRACTION_STARTED=!0},r.prototype.stop=function(){this._m.EXTRACTION_STARTED=!1},r.prototype.setSource=function(r){this._m.source&&this._m.source.disconnect(this._m.spn),this._m.source=r,this._m.source.connect(this._m.spn)},r.prototype.setChannel=function(r){r<=this._m.inputs?this._m.channel=r:console.error("Channel ".concat(r," does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r," when instantiating the MeydaAnalyzer"))},r.prototype.get=function(r){return this._m.inputData?this._m.extract(r||this._m._featuresToExtract,this._m.inputData,this._m.previousInputData):null},r}(),C={audioContext:null,spn:null,bufferSize:512,sampleRate:44100,melBands:26,chromaBands:12,callback:null,windowingFunction:"hanning",featureExtractors:y,EXTRACTION_STARTED:!1,numberOfMFCCCoefficients:13,numberOfBarkBands:24,_featuresToExtract:[],windowing:n,_errors:{notPow2:new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"),featureUndef:new Error("Meyda: No features defined."),invalidFeatureFmt:new Error("Meyda: Invalid feature format"),invalidInput:new Error("Meyda: Invalid input."),noAC:new Error("Meyda: No AudioContext specified."),noSource:new Error("Meyda: No source node specified.")},createMeydaAnalyzer:function(r){return new E(r,Object.assign({},C))},listAvailableFeatureExtractors:function(){return Object.keys(this.featureExtractors)},extract:function(r,t,e){var n=this;if(!t)throw this._errors.invalidInput;if("object"!=typeof t)throw this._errors.invalidInput;if(!r)throw this._errors.featureUndef;if(!a(t.length))throw this._errors.notPow2;void 0!==this.barkScale&&this.barkScale.length==this.bufferSize||(this.barkScale=o(this.bufferSize,this.sampleRate,this.bufferSize)),void 0!==this.melFilterBank&&this.barkScale.length==this.bufferSize&&this.melFilterBank.length==this.melBands||(this.melFilterBank=f(Math.max(this.melBands,this.numberOfMFCCCoefficients),this.sampleRate,this.bufferSize)),void 0!==this.chromaFilterBank&&this.chromaFilterBank.length==this.chromaBands||(this.chromaFilterBank=c(this.chromaBands,this.sampleRate,this.bufferSize)),"buffer"in t&&void 0===t.buffer?this.signal=i(t):this.signal=t;var u=k(t,this.windowingFunction,this.bufferSize);if(this.signal=u.windowedSignal,this.complexSpectrum=u.complexSpectrum,this.ampSpectrum=u.ampSpectrum,e){var l=k(e,this.windowingFunction,this.bufferSize);this.previousSignal=l.windowedSignal,this.previousComplexSpectrum=l.complexSpectrum,this.previousAmpSpectrum=l.ampSpectrum}var s=function(r){return n.featureExtractors[r]({ampSpectrum:n.ampSpectrum,chromaFilterBank:n.chromaFilterBank,complexSpectrum:n.complexSpectrum,signal:n.signal,bufferSize:n.bufferSize,sampleRate:n.sampleRate,barkScale:n.barkScale,melFilterBank:n.melFilterBank,previousSignal:n.previousSignal,previousAmpSpectrum:n.previousAmpSpectrum,previousComplexSpectrum:n.previousComplexSpectrum,numberOfMFCCCoefficients:n.numberOfMFCCCoefficients,numberOfBarkBands:n.numberOfBarkBands})};if("object"==typeof r)return r.reduce((function(r,t){var e;return Object.assign({},r,((e={})[t]=s(t),e))}),{});if("string"==typeof r)return s(r);throw this._errors.invalidFeatureFmt}},k=function(r,t,e){var a={};void 0===r.buffer?a.signal=i(r):a.signal=r,a.windowedSignal=n(a.signal,t),a.complexSpectrum=A(a.windowedSignal),a.ampSpectrum=new Float32Array(e/2);for(var o=0;o<e/2;o++)a.ampSpectrum[o]=Math.sqrt(Math.pow(a.complexSpectrum.real[o],2)+Math.pow(a.complexSpectrum.imag[o],2));return a};return"undefined"!=typeof window&&(window.Meyda=C),C}));


},{}],85:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")

module.exports = createSurfaceExtractor

//Helper macros
function array(i) {
  return "a" + i
}
function data(i) {
  return "d" + i
}
function cube(i,bitmask) {
  return "c" + i + "_" + bitmask
}
function shape(i) {
  return "s" + i
}
function stride(i,j) {
  return "t" + i + "_" + j
}
function offset(i) {
  return "o" + i
}
function scalar(i) {
  return "x" + i
}
function pointer(i) {
  return "p" + i
}
function delta(i,bitmask) {
  return "d" + i + "_" + bitmask
}
function index(i) {
  return "i" + i
}
function step(i,j) {
  return "u" + i + "_" + j
}
function pcube(bitmask) {
  return "b" + bitmask
}
function qcube(bitmask) {
  return "y" + bitmask
}
function pdelta(bitmask) {
  return "e" + bitmask
}
function vert(i) {
  return "v" + i
}
var VERTEX_IDS = "V"
var PHASES = "P"
var VERTEX_COUNT = "N"
var POOL_SIZE = "Q"
var POINTER = "X"
var TEMPORARY = "T"

function permBitmask(dimension, mask, order) {
  var r = 0
  for(var i=0; i<dimension; ++i) {
    if(mask & (1<<i)) {
      r |= (1<<order[i])
    }
  }
  return r
}

//Generates the surface procedure
function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {
  var arrayArgs = typesig.length
  var dimension = order.length

  if(dimension < 2) {
    throw new Error("ndarray-extract-contour: Dimension must be at least 2")
  }

  var funcName = "extractContour" + order.join("_")
  var code = []
  var vars = []
  var args = []

  //Assemble arguments
  for(var i=0; i<arrayArgs; ++i) {
    args.push(array(i))  
  }
  for(var i=0; i<scalarArgs; ++i) {
    args.push(scalar(i))
  }

  //Shape
  for(var i=0; i<dimension; ++i) {
    vars.push(shape(i) + "=" + array(0) + ".shape[" + i + "]|0")
  }
  //Data, stride, offset pointers
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(data(i) + "=" + array(i) + ".data",
              offset(i) + "=" + array(i) + ".offset|0")
    for(var j=0; j<dimension; ++j) {
      vars.push(stride(i,j) + "=" + array(i) + ".stride[" + j + "]|0")
    }
  }
  //Pointer, delta and cube variables
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(pointer(i) + "=" + offset(i))
    vars.push(cube(i,0))
    for(var j=1; j<(1<<dimension); ++j) {
      var ptrStr = []
      for(var k=0; k<dimension; ++k) {
        if(j & (1<<k)) {
          ptrStr.push("-" + stride(i,k))
        }
      }
      vars.push(delta(i,j) + "=(" + ptrStr.join("") + ")|0")
      vars.push(cube(i,j) + "=0")
    }
  }
  //Create step variables
  for(var i=0; i<arrayArgs; ++i) {
    for(var j=0; j<dimension; ++j) {
      var stepVal = [ stride(i,order[j]) ]
      if(j > 0) {
        stepVal.push(stride(i, order[j-1]) + "*" + shape(order[j-1]) )
      }
      vars.push(step(i,order[j]) + "=(" + stepVal.join("-") + ")|0")
    }
  }
  //Create index variables
  for(var i=0; i<dimension; ++i) {
    vars.push(index(i) + "=0")
  }
  //Vertex count
  vars.push(VERTEX_COUNT + "=0")
  //Compute pool size, initialize pool step
  var sizeVariable = ["2"]
  for(var i=dimension-2; i>=0; --i) {
    sizeVariable.push(shape(order[i]))
  }
  //Previous phases and vertex_ids
  vars.push(POOL_SIZE + "=(" + sizeVariable.join("*") + ")|0",
            PHASES + "=mallocUint32(" + POOL_SIZE + ")",
            VERTEX_IDS + "=mallocUint32(" + POOL_SIZE + ")",
            POINTER + "=0")
  //Create cube variables for phases
  vars.push(pcube(0) + "=0")
  for(var j=1; j<(1<<dimension); ++j) {
    var cubeDelta = []
    var cubeStep = [ ]
    for(var k=0; k<dimension; ++k) {
      if(j & (1<<k)) {
        if(cubeStep.length === 0) {
          cubeDelta.push("1")
        } else {
          cubeDelta.unshift(cubeStep.join("*"))
        }
      }
      cubeStep.push(shape(order[k]))
    }
    var signFlag = ""
    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {
      signFlag = "-"
    }
    var jperm = permBitmask(dimension, j, order)
    vars.push(pdelta(jperm) + "=(-" + cubeDelta.join("-") + ")|0",
              qcube(jperm) + "=(" + signFlag + cubeDelta.join("-") + ")|0",
              pcube(jperm) + "=0")
  }
  vars.push(vert(0) + "=0", TEMPORARY + "=0")

  function forLoopBegin(i, start) {
    code.push("for(", index(order[i]), "=", start, ";",
      index(order[i]), "<", shape(order[i]), ";",
      "++", index(order[i]), "){")
  }

  function forLoopEnd(i) {
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    code.push("}")
  }

  function fillEmptySlice(k) {
    for(var i=k-1; i>=0; --i) {
      forLoopBegin(i, 0) 
    }
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        phaseFuncArgs.push(data(i) + ".get(" + pointer(i) + ")")
      } else {
        phaseFuncArgs.push(data(i) + "[" + pointer(i) + "]")
      }
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    code.push(PHASES, "[", POINTER, "++]=phase(", phaseFuncArgs.join(), ");")
    for(var i=0; i<k; ++i) {
      forLoopEnd(i)
    }
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[k]), ";")
    }
  }

  function processGridCell(mask) {
    //Read in local data
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        code.push(cube(i,0), "=", data(i), ".get(", pointer(i), ");")
      } else {
        code.push(cube(i,0), "=", data(i), "[", pointer(i), "];")
      }
    }

    //Read in phase
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      phaseFuncArgs.push(cube(i,0))
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    
    code.push(pcube(0), "=", PHASES, "[", POINTER, "]=phase(", phaseFuncArgs.join(), ");")
    
    //Read in other cube data
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(pcube(j), "=", PHASES, "[", POINTER, "+", pdelta(j), "];")
    }

    //Check for boundary crossing
    var vertexPredicate = []
    for(var j=1; j<(1<<dimension); ++j) {
      vertexPredicate.push("(" + pcube(0) + "!==" + pcube(j) + ")")
    }
    code.push("if(", vertexPredicate.join("||"), "){")

    //Read in boundary data
    var vertexArgs = []
    for(var i=0; i<dimension; ++i) {
      vertexArgs.push(index(i))
    }
    for(var i=0; i<arrayArgs; ++i) {
      vertexArgs.push(cube(i,0))
      for(var j=1; j<(1<<dimension); ++j) {
        if(typesig[i]) {
          code.push(cube(i,j), "=", data(i), ".get(", pointer(i), "+", delta(i,j), ");")
        } else {
          code.push(cube(i,j), "=", data(i), "[", pointer(i), "+", delta(i,j), "];")
        }
        vertexArgs.push(cube(i,j))
      }
    }
    for(var i=0; i<(1<<dimension); ++i) {
      vertexArgs.push(pcube(i))
    }
    for(var i=0; i<scalarArgs; ++i) {
      vertexArgs.push(scalar(i))
    }

    //Generate vertex
    code.push("vertex(", vertexArgs.join(), ");",
      vert(0), "=", VERTEX_IDS, "[", POINTER, "]=", VERTEX_COUNT, "++;")

    //Check for face crossings
    var base = (1<<dimension)-1
    var corner = pcube(base)
    for(var j=0; j<dimension; ++j) {
      if((mask & ~(1<<j))===0) {
        //Check face
        var subset = base^(1<<j)
        var edge = pcube(subset)
        var faceArgs = [ ]
        for(var k=subset; k>0; k=(k-1)&subset) {
          faceArgs.push(VERTEX_IDS + "[" + POINTER + "+" + pdelta(k) + "]")
        }
        faceArgs.push(vert(0))
        for(var k=0; k<arrayArgs; ++k) {
          if(j&1) {
            faceArgs.push(cube(k,base), cube(k,subset))
          } else {
            faceArgs.push(cube(k,subset), cube(k,base))
          }
        }
        if(j&1) {
          faceArgs.push(corner, edge)
        } else {
          faceArgs.push(edge, corner)
        }
        for(var k=0; k<scalarArgs; ++k) {
          faceArgs.push(scalar(k))
        }
        code.push("if(", corner, "!==", edge, "){",
          "face(", faceArgs.join(), ")}")
      }
    }
    
    //Increment pointer, close off if statement
    code.push("}",
      POINTER, "+=1;")
  }

  function flip() {
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(TEMPORARY, "=", pdelta(j), ";",
                pdelta(j), "=", qcube(j), ";",
                qcube(j), "=", TEMPORARY, ";")
    }
  }

  function createLoop(i, mask) {
    if(i < 0) {
      processGridCell(mask)
      return
    }
    fillEmptySlice(i)
    code.push("if(", shape(order[i]), ">0){",
      index(order[i]), "=1;")
    createLoop(i-1, mask|(1<<order[i]))

    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    if(i === dimension-1) {
      code.push(POINTER, "=0;")
      flip()
    }
    forLoopBegin(i, 2)
    createLoop(i-1, mask)
    if(i === dimension-1) {
      code.push("if(", index(order[dimension-1]), "&1){",
        POINTER, "=0;}")
      flip()
    }
    forLoopEnd(i)
    code.push("}")
  }

  createLoop(dimension-1, 0)

  //Release scratch memory
  code.push("freeUint32(", VERTEX_IDS, ");freeUint32(", PHASES, ");")

  //Compile and link procedure
  var procedureCode = [
    "'use strict';",
    "function ", funcName, "(", args.join(), "){",
      "var ", vars.join(), ";",
      code.join(""),
    "}",
    "return ", funcName ].join("")

  var proc = new Function(
    "vertex", 
    "face", 
    "phase", 
    "mallocUint32", 
    "freeUint32",
    procedureCode)
  return proc(
    vertexFunc, 
    faceFunc, 
    phaseFunc, 
    pool.mallocUint32, 
    pool.freeUint32)
}

function createSurfaceExtractor(args) {
  function error(msg) {
    throw new Error("ndarray-extract-contour: " + msg)
  }
  if(typeof args !== "object") {
    error("Must specify arguments")
  }
  var order = args.order
  if(!Array.isArray(order)) {
    error("Must specify order")
  }
  var arrays = args.arrayArguments||1
  if(arrays < 1) {
    error("Must have at least one array argument")
  }
  var scalars = args.scalarArguments||0
  if(scalars < 0) {
    error("Scalar arg count must be > 0")
  }
  if(typeof args.vertex !== "function") {
    error("Must specify vertex creation function")
  }
  if(typeof args.cell !== "function") {
    error("Must specify cell creation function")
  }
  if(typeof args.phase !== "function") {
    error("Must specify phase function")
  }
  var getters = args.getters || []
  var typesig = new Array(arrays)
  for(var i=0; i<arrays; ++i) {
    if(getters.indexOf(i) >= 0) {
      typesig[i] = true
    } else {
      typesig[i] = false
    }
  }
  return compileSurfaceProcedure(
    args.vertex,
    args.cell,
    args.phase,
    scalars,
    order,
    typesig)
}
},{"typedarray-pool":180}],86:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":82,"is-buffer":83}],87:[function(require,module,exports){
"use strict"

var doubleBits = require("double-bits")

var SMALLEST_DENORM = Math.pow(2, -1074)
var UINT_MAX = (-1)>>>0

module.exports = nextafter

function nextafter(x, y) {
  if(isNaN(x) || isNaN(y)) {
    return NaN
  }
  if(x === y) {
    return x
  }
  if(x === 0) {
    if(y < 0) {
      return -SMALLEST_DENORM
    } else {
      return SMALLEST_DENORM
    }
  }
  var hi = doubleBits.hi(x)
  var lo = doubleBits.lo(x)
  if((y > x) === (x > 0)) {
    if(lo === UINT_MAX) {
      hi += 1
      lo = 0
    } else {
      lo += 1
    }
  } else {
    if(lo === 0) {
      lo = UINT_MAX
      hi -= 1
    } else {
      lo -= 1
    }
  }
  return doubleBits.pack(lo, hi)
}
},{"double-bits":42}],88:[function(require,module,exports){
(function (process){(function (){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this)}).call(this,require('_process'))

},{"_process":95}],89:[function(require,module,exports){
"use strict"

module.exports = permutationSign

var BRUTE_FORCE_CUTOFF = 32

var pool = require("typedarray-pool")

function permutationSign(p) {
  var n = p.length
  if(n < BRUTE_FORCE_CUTOFF) {
    //Use quadratic algorithm for small n
    var sgn = 1
    for(var i=0; i<n; ++i) {
      for(var j=0; j<i; ++j) {
        if(p[i] < p[j]) {
          sgn = -sgn
        } else if(p[i] === p[j]) {
          return 0
        }
      }
    }
    return sgn
  } else {
    //Otherwise use linear time algorithm
    var visited = pool.mallocUint8(n)
    for(var i=0; i<n; ++i) {
      visited[i] = 0
    }
    var sgn = 1
    for(var i=0; i<n; ++i) {
      if(!visited[i]) {
        var count = 1
        visited[i] = 1
        for(var j=p[i]; j!==i; j=p[j]) {
          if(visited[j]) {
            pool.freeUint8(visited)
            return 0
          }
          count += 1
          visited[j] = 1
        }
        if(!(count & 1)) {
          sgn = -sgn
        }
      }
    }
    pool.freeUint8(visited)
    return sgn
  }
}
},{"typedarray-pool":180}],90:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var inverse = require("invert-permutation")

function rank(permutation) {
  var n = permutation.length
  switch(n) {
    case 0:
    case 1:
      return 0
    case 2:
      return permutation[1]
    default:
      break
  }
  var p = pool.mallocUint32(n)
  var pinv = pool.mallocUint32(n)
  var r = 0, s, t, i
  inverse(permutation, pinv)
  for(i=0; i<n; ++i) {
    p[i] = permutation[i]
  }
  for(i=n-1; i>0; --i) {
    t = pinv[i]
    s = p[i]
    p[i] = p[t]
    p[t] = s
    pinv[i] = pinv[s]
    pinv[s] = t
    r = (r + s) * i
  }
  pool.freeUint32(pinv)
  pool.freeUint32(p)
  return r
}

function unrank(n, r, p) {
  switch(n) {
    case 0:
      if(p) { return p }
      return []
    case 1:
      if(p) {
        p[0] = 0
        return p
      } else {
        return [0]
      }
    case 2:
      if(p) {
        if(r) {
          p[0] = 0
          p[1] = 1
        } else {
          p[0] = 1
          p[1] = 0
        }
        return p
      } else {
        return r ? [0,1] : [1,0]
      }
    default:
      break
  }
  p = p || new Array(n)
  var s, t, i, nf=1
  p[0] = 0
  for(i=1; i<n; ++i) {
    p[i] = i
    nf = (nf*i)|0
  }
  for(i=n-1; i>0; --i) {
    s = (r / nf)|0
    r = (r - s * nf)|0
    nf = (nf / i)|0
    t = p[i]|0
    p[i] = p[s]|0
    p[s] = t|0
  }
  return p
}

exports.rank = rank
exports.unrank = unrank

},{"invert-permutation":81,"typedarray-pool":180}],91:[function(require,module,exports){
"use strict"

module.exports = planarDual

var compareAngle = require("compare-angle")

function planarDual(cells, positions) {

  var numVertices = positions.length|0
  var numEdges = cells.length
  var adj = [new Array(numVertices), new Array(numVertices)]
  for(var i=0; i<numVertices; ++i) {
    adj[0][i] = []
    adj[1][i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var c = cells[i]
    adj[0][c[0]].push(c)
    adj[1][c[1]].push(c)
  }

  var cycles = []

  //Add isolated vertices as trivial case
  for(var i=0; i<numVertices; ++i) {
    if(adj[0][i].length + adj[1][i].length === 0) {
      cycles.push( [i] )
    }
  }

  //Remove a half edge
  function cut(c, i) {
    var a = adj[i][c[i]]
    a.splice(a.indexOf(c), 1)
  }

  //Find next vertex and cut edge
  function next(a, b, noCut) {
    var nextCell, nextVertex, nextDir
    for(var i=0; i<2; ++i) {
      if(adj[i][b].length > 0) {
        nextCell = adj[i][b][0]
        nextDir = i
        break
      }
    }
    nextVertex = nextCell[nextDir^1]

    for(var dir=0; dir<2; ++dir) {
      var nbhd = adj[dir][b]
      for(var k=0; k<nbhd.length; ++k) {
        var e = nbhd[k]
        var p = e[dir^1]
        var cmp = compareAngle(
            positions[a], 
            positions[b], 
            positions[nextVertex],
            positions[p])
        if(cmp > 0) {
          nextCell = e
          nextVertex = p
          nextDir = dir
        }
      }
    }
    if(noCut) {
      return nextVertex
    }
    if(nextCell) {
      cut(nextCell, nextDir)
    }
    return nextVertex
  }

  function extractCycle(v, dir) {
    var e0 = adj[dir][v][0]
    var cycle = [v]
    cut(e0, dir)
    var u = e0[dir^1]
    var d0 = dir
    while(true) {
      while(u !== v) {
        cycle.push(u)
        u = next(cycle[cycle.length-2], u, false)
      }
      if(adj[0][v].length + adj[1][v].length === 0) {
        break
      }
      var a = cycle[cycle.length-1]
      var b = v
      var c = cycle[1]
      var d = next(a, b, true)
      if(compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {
        break
      }
      cycle.push(v)
      u = next(a, b)
    }
    return cycle
  }

  function shouldGlue(pcycle, ncycle) {
    return (ncycle[1] === ncycle[ncycle.length-1])
  }

  for(var i=0; i<numVertices; ++i) {
    for(var j=0; j<2; ++j) {
      var pcycle = []
      while(adj[j][i].length > 0) {
        var ni = adj[0][i].length
        var ncycle = extractCycle(i,j)
        if(shouldGlue(pcycle, ncycle)) {
          //Glue together trivial cycles
          pcycle.push.apply(pcycle, ncycle)
        } else {
          if(pcycle.length > 0) {
            cycles.push(pcycle)
          }
          pcycle = ncycle
        }
      }
      if(pcycle.length > 0) {
        cycles.push(pcycle)
      }
    }
  }

  //Combine paths and loops together
  return cycles
}
},{"compare-angle":38}],92:[function(require,module,exports){
'use strict'

module.exports = trimLeaves

var e2a = require('edges-to-adjacency-list')

function trimLeaves(edges, positions) {
  var adj = e2a(edges, positions.length)
  var live = new Array(positions.length)
  var nbhd = new Array(positions.length)

  var dead = []
  for(var i=0; i<positions.length; ++i) {
    var count = adj[i].length
    nbhd[i] = count
    live[i] = true
    if(count <= 1) {
      dead.push(i)
    }
  }

  while(dead.length > 0) {
    var v = dead.pop()
    live[v] = false
    var n = adj[v]
    for(var i=0; i<n.length; ++i) {
      var u = n[i]
      if(--nbhd[u] === 0) {
        dead.push(u)
      }
    }
  }

  var newIndex = new Array(positions.length)
  var npositions = []
  for(var i=0; i<positions.length; ++i) {
    if(live[i]) {
      var v = npositions.length
      newIndex[i] = v
      npositions.push(positions[i])
    } else {
      newIndex[i] = -1
    }
  }

  var nedges = []
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    if(live[e[0]] && live[e[1]]) {
      nedges.push([ newIndex[e[0]], newIndex[e[1]] ])
    }
  }
  
  return [ nedges, npositions ]
}
},{"edges-to-adjacency-list":44}],93:[function(require,module,exports){
'use strict'

module.exports = planarGraphToPolyline

var e2a = require('edges-to-adjacency-list')
var planarDual = require('planar-dual')
var preprocessPolygon = require('point-in-big-polygon')
var twoProduct = require('two-product')
var robustSum = require('robust-sum')
var uniq = require('uniq')
var trimLeaves = require('./lib/trim-leaves')

function makeArray(length, fill) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = fill
  }
  return result
}

function makeArrayOfArrays(length) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = []
  }
  return result
}


function planarGraphToPolyline(edges, positions) {

  //Trim leaves
  var result = trimLeaves(edges, positions)
  edges = result[0]
  positions = result[1]

  var numVertices = positions.length
  var numEdges = edges.length

  //Calculate adjacency list, check manifold
  var adj = e2a(edges, positions.length)
  for(var i=0; i<numVertices; ++i) {
    if(adj[i].length % 2 === 1) {
      throw new Error('planar-graph-to-polyline: graph must be manifold')
    }
  }

  //Get faces
  var faces = planarDual(edges, positions)

  //Check orientation of a polygon using exact arithmetic
  function ccw(c) {
    var n = c.length
    var area = [0]
    for(var j=0; j<n; ++j) {
      var a = positions[c[j]]
      var b = positions[c[(j+1)%n]]
      var t00 = twoProduct(-a[0], a[1])
      var t01 = twoProduct(-a[0], b[1])
      var t10 = twoProduct( b[0], a[1])
      var t11 = twoProduct( b[0], b[1])
      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))
    }
    return area[area.length-1] > 0
  }

  //Extract all clockwise faces
  faces = faces.filter(ccw)

  //Detect which loops are contained in one another to handle parent-of relation
  var numFaces = faces.length
  var parent = new Array(numFaces)
  var containment = new Array(numFaces)
  for(var i=0; i<numFaces; ++i) {
    parent[i] = i
    var row = new Array(numFaces)
    var loopVertices = faces[i].map(function(v) {
      return positions[v]
    })
    var pmc = preprocessPolygon([loopVertices])
    var count = 0
    outer:
    for(var j=0; j<numFaces; ++j) {
      row[j] = 0
      if(i === j) {
        continue
      }
      var c = faces[j]
      var n = c.length
      for(var k=0; k<n; ++k) {
        var d = pmc(positions[c[k]])
        if(d !== 0) {
          if(d < 0) {
            row[j] = 1
            count += 1
          }
          continue outer
        }
      }
      row[j] = 1
      count += 1
    }
    containment[i] = [count, i, row]
  }
  containment.sort(function(a,b) {
    return b[0] - a[0]
  })
  for(var i=0; i<numFaces; ++i) {
    var row = containment[i]
    var idx = row[1]
    var children = row[2]
    for(var j=0; j<numFaces; ++j) {
      if(children[j]) {
        parent[j] = idx
      }
    }
  }

  //Initialize face adjacency list
  var fadj = makeArrayOfArrays(numFaces)
  for(var i=0; i<numFaces; ++i) {
    fadj[i].push(parent[i])
    fadj[parent[i]].push(i)
  }

  //Build adjacency matrix for edges
  var edgeAdjacency = {}
  var internalVertices = makeArray(numVertices, false)
  for(var i=0; i<numFaces; ++i) {
    var c = faces[i]
    var n = c.length
    for(var j=0; j<n; ++j) {
      var a = c[j]
      var b = c[(j+1)%n]
      var key = Math.min(a,b) + ":" + Math.max(a,b)
      if(key in edgeAdjacency) {
        var neighbor = edgeAdjacency[key]
        fadj[neighbor].push(i)
        fadj[i].push(neighbor)
        internalVertices[a] = internalVertices[b] = true
      } else {
        edgeAdjacency[key] = i
      }
    }
  }

  function sharedBoundary(c) {
    var n = c.length
    for(var i=0; i<n; ++i) {
      if(!internalVertices[c[i]]) {
        return false
      }
    }
    return true
  }

  var toVisit = []
  var parity = makeArray(numFaces, -1)
  for(var i=0; i<numFaces; ++i) {
    if(parent[i] === i && !sharedBoundary(faces[i])) {
      toVisit.push(i)
      parity[i] = 0
    } else {
      parity[i] = -1
    }
  }

  //Using face adjacency, classify faces as in/out
  var result = []
  while(toVisit.length > 0) {
    var top = toVisit.pop()
    var nbhd = fadj[top]
    uniq(nbhd, function(a,b) {
      return a-b
    })
    var nnbhr = nbhd.length
    var p = parity[top]
    var polyline
    if(p === 0) {
      var c = faces[top]
      polyline = [c]
    }
    for(var i=0; i<nnbhr; ++i) {
      var f = nbhd[i]
      if(parity[f] >= 0) {
        continue
      }
      parity[f] = p^1
      toVisit.push(f)
      if(p === 0) {
        var c = faces[f]
        if(!sharedBoundary(c)) {
          c.reverse()
          polyline.push(c)
        }
      }
    }
    if(p === 0) {
      result.push(polyline)
    }
  }

  return result
}
},{"./lib/trim-leaves":92,"edges-to-adjacency-list":44,"planar-dual":91,"point-in-big-polygon":94,"robust-sum":110,"two-product":178,"uniq":182}],94:[function(require,module,exports){
module.exports = preprocessPolygon

var orient = require('robust-orientation')[3]
var makeSlabs = require('slab-decomposition')
var makeIntervalTree = require('interval-tree-1d')
var bsearch = require('binary-search-bounds')

function visitInterval() {
  return true
}

function intervalSearch(table) {
  return function(x, y) {
    var tree = table[x]
    if(tree) {
      return !!tree.queryPoint(y, visitInterval)
    }
    return false
  }
}

function buildVerticalIndex(segments) {
  var table = {}
  for(var i=0; i<segments.length; ++i) {
    var s = segments[i]
    var x = s[0][0]
    var y0 = s[0][1]
    var y1 = s[1][1]
    var p = [ Math.min(y0, y1), Math.max(y0, y1) ]
    if(x in table) {
      table[x].push(p)
    } else {
      table[x] = [ p ]
    }
  }
  var intervalTable = {}
  var keys = Object.keys(table)
  for(var i=0; i<keys.length; ++i) {
    var segs = table[keys[i]]
    intervalTable[keys[i]] = makeIntervalTree(segs)
  }
  return intervalSearch(intervalTable)
}

function buildSlabSearch(slabs, coordinates) {
  return function(p) {
    var bucket = bsearch.le(coordinates, p[0])
    if(bucket < 0) {
      return 1
    }
    var root = slabs[bucket]
    if(!root) {
      if(bucket > 0 && coordinates[bucket] === p[0]) {
        root = slabs[bucket-1]
      } else {
        return 1
      }
    }
    var lastOrientation = 1
    while(root) {
      var s = root.key
      var o = orient(p, s[0], s[1])
      if(s[0][0] < s[1][0]) {
        if(o < 0) {
          root = root.left
        } else if(o > 0) {
          lastOrientation = -1
          root = root.right
        } else {
          return 0
        }
      } else {
        if(o > 0) {
          root = root.left
        } else if(o < 0) {
          lastOrientation = 1
          root = root.right
        } else {
          return 0
        }
      }
    }
    return lastOrientation
  }
}

function classifyEmpty(p) {
  return 1
}

function createClassifyVertical(testVertical) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return 1
  }
}

function createClassifyPointDegen(testVertical, testNormal) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return testNormal(p)
  }
}

function preprocessPolygon(loops) {
  //Compute number of loops
  var numLoops = loops.length

  //Unpack segments
  var segments = []
  var vsegments = []
  var ptr = 0
  for(var i=0; i<numLoops; ++i) {
    var loop = loops[i]
    var numVertices = loop.length
    for(var s=numVertices-1,t=0; t<numVertices; s=(t++)) {
      var a = loop[s]
      var b = loop[t]
      if(a[0] === b[0]) {
        vsegments.push([a,b])
      } else {
        segments.push([a,b])
      }
    }
  }

  //Degenerate case: All loops are empty
  if(segments.length === 0) {
    if(vsegments.length === 0) {
      return classifyEmpty
    } else {
      return createClassifyVertical(buildVerticalIndex(vsegments))
    }
  }

  //Build slab decomposition
  var slabs = makeSlabs(segments)
  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates)

  if(vsegments.length === 0) {
    return testSlab
  } else {
    return createClassifyPointDegen(
      buildVerticalIndex(vsegments),
      testSlab)
  }
}
},{"binary-search-bounds":19,"interval-tree-1d":80,"robust-orientation":105,"slab-decomposition":117}],95:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],96:[function(require,module,exports){
var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter
var now = require('right-now')
var raf = require('raf')

module.exports = Engine
function Engine(fn) {
    if (!(this instanceof Engine)) 
        return new Engine(fn)
    this.running = false
    this.last = now()
    this._frame = 0
    this._tick = this.tick.bind(this)

    if (fn)
        this.on('tick', fn)
}

inherits(Engine, EventEmitter)

Engine.prototype.start = function() {
    if (this.running) 
        return
    this.running = true
    this.last = now()
    this._frame = raf(this._tick)
    return this
}

Engine.prototype.stop = function() {
    this.running = false
    if (this._frame !== 0)
        raf.cancel(this._frame)
    this._frame = 0
    return this
}

Engine.prototype.tick = function() {
    this._frame = raf(this._tick)
    var time = now()
    var dt = time - this.last
    this.emit('tick', dt)
    this.last = time
}
},{"events":29,"inherits":79,"raf":97,"right-now":103}],97:[function(require,module,exports){
(function (global){(function (){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":88}],98:[function(require,module,exports){
'use strict'

var bnadd = require('big-rat/add')

module.exports = add

function add (a, b) {
  var n = a.length
  var r = new Array(n)
  for (var i=0; i<n; ++i) {
    r[i] = bnadd(a[i], b[i])
  }
  return r
}

},{"big-rat/add":2}],99:[function(require,module,exports){
'use strict'

module.exports = float2rat

var rat = require('big-rat')

function float2rat(v) {
  var result = new Array(v.length)
  for(var i=0; i<v.length; ++i) {
    result[i] = rat(v[i])
  }
  return result
}

},{"big-rat":5}],100:[function(require,module,exports){
'use strict'

var rat = require('big-rat')
var mul = require('big-rat/mul')

module.exports = muls

function muls(a, x) {
  var s = rat(x)
  var n = a.length
  var r = new Array(n)
  for(var i=0; i<n; ++i) {
    r[i] = mul(a[i], s)
  }
  return r
}

},{"big-rat":5,"big-rat/mul":14}],101:[function(require,module,exports){
'use strict'

var bnsub = require('big-rat/sub')

module.exports = sub

function sub(a, b) {
  var n = a.length
  var r = new Array(n)
    for(var i=0; i<n; ++i) {
    r[i] = bnsub(a[i], b[i])
  }
  return r
}

},{"big-rat/sub":17}],102:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.createREGL = factory());
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map((y, i) => unbox(y, path + '[' + i + ']')))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
    extend(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])

      if (!limits.npotTextureCube) {
        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
      }

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              if (colorTexture) {
                check$1.oneOf(
                  options.colorFormat, colorTextureFormats,
                  'invalid color format for texture')
              } else {
                check$1.oneOf(
                  options.colorFormat, colorRenderbufferFormats,
                  'invalid color format for renderbuffer')
              }
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = this
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (attributes) {
      check$1(Array.isArray(attributes), 'arguments to vertex array constructor must be an array')
      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0
      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      if (extensions.oes_texture_float) {
        check$1(
          type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
          'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

        if (type === GL_FLOAT$7) {
          check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
        }
      } else {
        check$1(
          type === GL_UNSIGNED_BYTE$7,
          'Reading from a framebuffer is only allowed for the type \'uint8\'')
      }
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        if (isBufferArgs(elements)) {
          elements = elementState.getElements(elementState.create(elements, true))
        } else if (elements) {
          elements = elementState.getElements(elements)
          check$1.command(elements, 'invalid elements', env.commandStr)
        }
        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      }

      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset && elements) {
        return createStaticDecl(function (env, scope) {
          env.OFFSET = '0'
          return 0
        })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      }
      return null
    }

    return {
      elements: elements,
      primitive: parsePrimitive(),
      count: parseVertCount(),
      instances: parseParam(S_INSTANCES, false),
      offset: OFFSET
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            if ('divisor' in value) {
              check$1.command(divisor === 0 || extInstancing,
                'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
              check$1.command(divisor >= 0,
                'invalid divisor for attribute "' + attribute + '"', env.commandStr)
            }

            check$1.optional(function () {
              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseVAO (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic
    if (S_VAO in staticOptions) {
      var vao = staticOptions[S_VAO]
      if (vao !== null && attributeState.getVAO(vao) === null) {
        vao = attributeState.createVAO(vao)
      }
      return createStaticDecl(function (env) {
        return env.link(attributeState.getVAO(vao))
      })
    } else if (S_VAO in dynamicOptions) {
      var dyn = dynamicOptions[S_VAO]
      return createDynamicDecl(dyn, function (env, scope) {
        var vaoRef = env.invoke(scope, dyn)
        return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
      })
    }
    return null
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = parseVAO(options, env)
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO(staticBindings))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      scope(GL, '.uniform', infix, '(', LOCATION, ',')
      if (infix.charAt(0) === 'M') {
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
      } else if (unroll > 1) {
        scope(loop(unroll, function (i) {
          return Array.isArray(VALUE) ? VALUE[i] : VALUE + '[' + i + ']'
        }))
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        scope(VALUE)
      }
      scope(');')
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
      } else {
        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS)
      }
      if (ELEMENTS) {
        scope(
          'if(' + ELEMENTS + ')' +
          GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements)

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    })
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()
    attributeState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));


},{}],103:[function(require,module,exports){
(function (global){(function (){
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],104:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustDiff = require("robust-subtract")
var robustScale = require("robust-scale")

var NUM_EXPAND = 6

function orientation(n) {
  var fn =
    n === 3 ? inSphere3 :
    n === 4 ? inSphere4 :
    n === 5 ? inSphere5 : inSphere6;

  return fn(robustSum, robustDiff, twoProduct, robustScale)
}

function inSphere0() { return 0 }
function inSphere1() { return 0 }
function inSphere2() { return 0 }

function inSphere3(sum, diff, prod, scale) {
  function exactInSphere3(m0, m1, m2) {
    var w0 = prod(m0[0], m0[0])
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w1 = prod(m1[0], m1[0])
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w2 = prod(m2[0], m2[0])
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var p = sum(diff(w2m1, w1m2), diff(w1m0, w0m1))
    var n = diff(w2m0, w0m2)
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere3
}

function inSphere4(sum, diff, prod, scale) {
  function exactInSphere4(m0, m1, m2, m3) {
    var w0 = sum(prod(m0[0], m0[0]), prod(m0[1], m0[1]))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w1 = sum(prod(m1[0], m1[0]), prod(m1[1], m1[1]))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w2 = sum(prod(m2[0], m2[0]), prod(m2[1], m2[1]))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w3 = sum(prod(m3[0], m3[0]), prod(m3[1], m3[1]))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var p = sum(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))))
    var n = sum(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere4
}


function inSphere5(sum, diff, prod, scale) {
  function exactInSphere5(m0, m1, m2, m3, m4) {
    var w0 = sum(prod(m0[0], m0[0]), sum(prod(m0[1], m0[1]), prod(m0[2], m0[2])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w1 = sum(prod(m1[0], m1[0]), sum(prod(m1[1], m1[1]), prod(m1[2], m1[2])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w2 = sum(prod(m2[0], m2[0]), sum(prod(m2[1], m2[1]), prod(m2[2], m2[2])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w3 = sum(prod(m3[0], m3[0]), sum(prod(m3[1], m3[1]), prod(m3[2], m3[2])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w4 = sum(prod(m4[0], m4[0]), sum(prod(m4[1], m4[1]), prod(m4[2], m4[2])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var p = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])))), sum(sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2])))))
    var n = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }

    return exactInSphere5
}

function inSphere6(sum, diff, prod, scale) {
  function exactInSphere6(m0, m1, m2, m3, m4, m5) {
    var w0 = sum(sum(prod(m0[0], m0[0]), prod(m0[1], m0[1])), sum(prod(m0[2], m0[2]), prod(m0[3], m0[3])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w0m5 = scale(w0, m5[0])
    var w1 = sum(sum(prod(m1[0], m1[0]), prod(m1[1], m1[1])), sum(prod(m1[2], m1[2]), prod(m1[3], m1[3])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w1m5 = scale(w1, m5[0])
    var w2 = sum(sum(prod(m2[0], m2[0]), prod(m2[1], m2[1])), sum(prod(m2[2], m2[2]), prod(m2[3], m2[3])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w2m5 = scale(w2, m5[0])
    var w3 = sum(sum(prod(m3[0], m3[0]), prod(m3[1], m3[1])), sum(prod(m3[2], m3[2]), prod(m3[3], m3[3])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w3m5 = scale(w3, m5[0])
    var w4 = sum(sum(prod(m4[0], m4[0]), prod(m4[1], m4[1])), sum(prod(m4[2], m4[2]), prod(m4[3], m4[3])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var w4m5 = scale(w4, m5[0])
    var w5 = sum(sum(prod(m5[0], m5[0]), prod(m5[1], m5[1])), sum(prod(m5[2], m5[2]), prod(m5[3], m5[3])))
    var w5m0 = scale(w5, m0[0])
    var w5m1 = scale(w5, m1[0])
    var w5m2 = scale(w5, m2[0])
    var w5m3 = scale(w5, m3[0])
    var w5m4 = scale(w5, m4[0])
    var p = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m1[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m3[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m5[3])))))
    var n = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m0[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m4[3])))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere6
}

var CACHED = [
  inSphere0,
  inSphere1,
  inSphere2
]

function slowInSphere(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc(slow, o0, o1, o2, o3, o4, o5, o6) {
  function testInSphere(a0, a1, a2, a3, a4, a5) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
      case 6:
        return o6(a0, a1, a2, a3, a4, a5)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
  return testInSphere
}

function generateInSphereTest() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }

  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateInSphereTest()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":178}],105:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function orientation_3(sum, prod, scale, sub) {
  return function orientation3Exact(m0, m1, m2) {
    var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])))
    var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_4(sum, prod, scale, sub) {
  return function orientation4Exact(m0, m1, m2, m3) {
    var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))))
    var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_5(sum, prod, scale, sub) {
  return function orientation5Exact(m0, m1, m2, m3, m4) {
    var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))))
    var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation(n) {
  var fn =
    n === 3 ? orientation_3 :
    n === 4 ? orientation_4 : orientation_5

  return fn(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) {
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy)
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc (slow, o0, o1, o2, o3, o4, o5) {
  return function getOrientation(a0, a1, a2, a3, a4) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":178}],106:[function(require,module,exports){
"use strict"

var robustSum = require("robust-sum")
var robustScale = require("robust-scale")

module.exports = robustProduct

function robustProduct(a, b) {
  if(a.length === 1) {
    return robustScale(b, a[0])
  }
  if(b.length === 1) {
    return robustScale(a, b[0])
  }
  if(a.length === 0 || b.length === 0) {
    return [0]
  }
  var r = [0]
  if(a.length < b.length) {
    for(var i=0; i<a.length; ++i) {
      r = robustSum(r, robustScale(b, a[i]))
    }
  } else {
    for(var i=0; i<b.length; ++i) {
      r = robustSum(r, robustScale(a, b[i]))
    }    
  }
  return r
}
},{"robust-scale":107,"robust-sum":110}],107:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":178,"two-sum":179}],108:[function(require,module,exports){
"use strict"

module.exports = segmentsIntersect

var orient = require("robust-orientation")[3]

function checkCollinear(a0, a1, b0, b1) {

  for(var d=0; d<2; ++d) {
    var x0 = a0[d]
    var y0 = a1[d]
    var l0 = Math.min(x0, y0)
    var h0 = Math.max(x0, y0)    

    var x1 = b0[d]
    var y1 = b1[d]
    var l1 = Math.min(x1, y1)
    var h1 = Math.max(x1, y1)    

    if(h1 < l0 || h0 < l1) {
      return false
    }
  }

  return true
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1)
  var y0 = orient(a1, b0, b1)
  if((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {
    return false
  }

  var x1 = orient(b0, a0, a1)
  var y1 = orient(b1, a0, a1)
  if((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {
    return false
  }

  //Check for degenerate collinear case
  if(x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1)
  }

  return true
}
},{"robust-orientation":105}],109:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],110:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],111:[function(require,module,exports){
"use strict"

module.exports = function signum(x) {
  if(x < 0) { return -1 }
  if(x > 0) { return 1 }
  return 0.0
}
},{}],112:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],113:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

UnionFind.prototype.length = function() {
  return this.roots.length;
}

UnionFind.prototype.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

UnionFind.prototype.find = function(x) {
  var roots = this.roots;
  while(roots[x] !== x) {
    var y = roots[x];
    roots[x] = roots[y];
    x = y;
  }
  return x;
}

UnionFind.prototype.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}


},{}],114:[function(require,module,exports){
"use strict"; "use restrict";

var bits      = require("bit-twiddle")
  , UnionFind = require("union-find")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents

},{"bit-twiddle":112,"union-find":113}],115:[function(require,module,exports){
"use strict"

module.exports = simplifyPolygon

var orient = require("robust-orientation")
var sc = require("simplicial-complex")

function errorWeight(base, a, b) {
  var area = Math.abs(orient(base, a, b))
  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))
  return area / perim
}

function simplifyPolygon(cells, positions, minArea) {

  var n = positions.length
  var nc = cells.length
  var inv = new Array(n)
  var outv = new Array(n)
  var weights = new Array(n)
  var dead = new Array(n)
  
  //Initialize tables
  for(var i=0; i<n; ++i) {
    inv[i] = outv[i] = -1
    weights[i] = Infinity
    dead[i] = false
  }

  //Compute neighbors
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.length !== 2) {
      throw new Error("Input must be a graph")
    }
    var s = c[1]
    var t = c[0]
    if(outv[t] !== -1) {
      outv[t] = -2
    } else {
      outv[t] = s
    }
    if(inv[s] !== -1) {
      inv[s] = -2
    } else {
      inv[s] = t
    }
  }

  //Updates the weight for vertex i
  function computeWeight(i) {
    if(dead[i]) {
      return Infinity
    }
    //TODO: Check that the line segment doesn't cross once simplified
    var s = inv[i]
    var t = outv[i]
    if((s<0) || (t<0)) {
      return Infinity
    } else {
      return errorWeight(positions[i], positions[s], positions[t])
    }
  }

  //Swaps two nodes on the heap (i,j) are the index of the nodes
  function heapSwap(i,j) {
    var a = heap[i]
    var b = heap[j]
    heap[i] = b
    heap[j] = a
    index[a] = j
    index[b] = i
  }

  //Returns the weight of node i on the heap
  function heapWeight(i) {
    return weights[heap[i]]
  }

  function heapParent(i) {
    if(i & 1) {
      return (i - 1) >> 1
    }
    return (i >> 1) - 1
  }

  //Bubble element i down the heap
  function heapDown(i) {
    var w = heapWeight(i)
    while(true) {
      var tw = w
      var left  = 2*i + 1
      var right = 2*(i + 1)
      var next = i
      if(left < heapCount) {
        var lw = heapWeight(left)
        if(lw < tw) {
          next = left
          tw = lw
        }
      }
      if(right < heapCount) {
        var rw = heapWeight(right)
        if(rw < tw) {
          next = right
        }
      }
      if(next === i) {
        return i
      }
      heapSwap(i, next)
      i = next      
    }
  }

  //Bubbles element i up the heap
  function heapUp(i) {
    var w = heapWeight(i)
    while(i > 0) {
      var parent = heapParent(i)
      if(parent >= 0) {
        var pw = heapWeight(parent)
        if(w < pw) {
          heapSwap(i, parent)
          i = parent
          continue
        }
      }
      return i
    }
  }

  //Pop minimum element
  function heapPop() {
    if(heapCount > 0) {
      var head = heap[0]
      heapSwap(0, heapCount-1)
      heapCount -= 1
      heapDown(0)
      return head
    }
    return -1
  }

  //Update heap item i
  function heapUpdate(i, w) {
    var a = heap[i]
    if(weights[a] === w) {
      return i
    }
    weights[a] = -Infinity
    heapUp(i)
    heapPop()
    weights[a] = w
    heapCount += 1
    return heapUp(heapCount-1)
  }

  //Kills a vertex (assume vertex already removed from heap)
  function kill(i) {
    if(dead[i]) {
      return
    }
    //Kill vertex
    dead[i] = true
    //Fixup topology
    var s = inv[i]
    var t = outv[i]
    if(inv[t] >= 0) {
      inv[t] = s
    }
    if(outv[s] >= 0) {
      outv[s] = t
    }

    //Update weights on s and t
    if(index[s] >= 0) {
      heapUpdate(index[s], computeWeight(s))
    }
    if(index[t] >= 0) {
      heapUpdate(index[t], computeWeight(t))
    }
  }

  //Initialize weights and heap
  var heap = []
  var index = new Array(n)
  for(var i=0; i<n; ++i) {
    var w = weights[i] = computeWeight(i)
    if(w < Infinity) {
      index[i] = heap.length
      heap.push(i)
    } else {
      index[i] = -1
    }
  }
  var heapCount = heap.length
  for(var i=heapCount>>1; i>=0; --i) {
    heapDown(i)
  }
  
  //Kill vertices
  while(true) {
    var hmin = heapPop()
    if((hmin < 0) || (weights[hmin] > minArea)) {
      break
    }
    kill(hmin)
  }

  //Build collapsed vertex table
  var npositions = []
  for(var i=0; i<n; ++i) {
    if(!dead[i]) {
      index[i] = npositions.length
      npositions.push(positions[i].slice())
    }
  }
  var nv = npositions.length

  function tortoiseHare(seq, start) {
    if(seq[start] < 0) {
      return start
    }
    var t = start
    var h = start
    do {
      //Walk two steps with h
      var nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh
      nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh

      //Walk one step with t
      t = seq[t]
    } while(t !== h)
    //Compress cycles
    for(var v=start; v!==h; v = seq[v]) {
      seq[v] = h
    }
    return h
  }

  var ncells = []
  cells.forEach(function(c) {
    var tin = tortoiseHare(inv, c[0])
    var tout = tortoiseHare(outv, c[1])
    if(tin >= 0 && tout >= 0 && tin !== tout) {
      var cin = index[tin]
      var cout = index[tout]
      if(cin !== cout) {
        ncells.push([ cin, cout ])
      }
    }
  })

  //Normalize result
  sc.unique(sc.normalize(ncells))

  //Return final list of cells
  return {
    positions: npositions,
    edges: ncells
  }
}
},{"robust-orientation":105,"simplicial-complex":114}],116:[function(require,module,exports){
"use strict"

module.exports = orderSegments

var orient = require("robust-orientation")

function horizontalOrder(a, b) {
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    var alo = Math.min(a[0][1], a[1][1])
    var ahi = Math.max(a[0][1], a[1][1])
    var blo = Math.min(b[0][1], b[1][1])
    var bhi = Math.max(b[0][1], b[1][1])
    if(ahi < blo) {
      return ahi - blo
    }
    if(alo > bhi) {
      return alo - bhi
    }
    return ahi - bhi
  }
  var al, ar
  if(a[0][1] < a[1][1]) {
    al = a[0]
    ar = a[1]
  } else {
    al = a[1]
    ar = a[0]
  }
  var d = orient(br, bl, al)
  if(d) {
    return d
  }
  d = orient(br, bl, ar)
  if(d) {
    return d
  }
  return ar - br
}

function orderSegments(b, a) {
  var al, ar
  if(a[0][0] < a[1][0]) {
    al = a[0]
    ar = a[1]
  } else if(a[0][0] > a[1][0]) {
    al = a[1]
    ar = a[0]
  } else {
    return horizontalOrder(a, b)
  }
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    return -horizontalOrder(b, a)
  }
  var d1 = orient(al, ar, br)
  var d2 = orient(al, ar, bl)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  d1 = orient(br, bl, ar)
  d2 = orient(br, bl, al)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  return ar[0] - br[0]
}
},{"robust-orientation":105}],117:[function(require,module,exports){
"use strict"

module.exports = createSlabDecomposition

var bounds = require("binary-search-bounds")
var createRBTree = require("functional-red-black-tree")
var orient = require("robust-orientation")
var orderSegments = require("./lib/order-segments")

function SlabDecomposition(slabs, coordinates, horizontal) {
  this.slabs = slabs
  this.coordinates = coordinates
  this.horizontal = horizontal
}

var proto = SlabDecomposition.prototype

function compareHorizontal(e, y) {
  return e.y - y
}

function searchBucket(root, p) {
  var lastNode = null
  while(root) {
    var seg = root.key
    var l, r
    if(seg[0][0] < seg[1][0]) {
      l = seg[0]
      r = seg[1]
    } else {
      l = seg[1]
      r = seg[0]
    }
    var o = orient(l, r, p)
    if(o < 0) {
      root = root.left
    } else if(o > 0) {
      if(p[0] !== seg[1][0]) {
        lastNode = root
        root = root.right
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    } else {
      if(p[0] !== seg[1][0]) {
        return root
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    }
  }
  return lastNode
}

proto.castUp = function(p) {
  var bucket = bounds.le(this.coordinates, p[0])
  if(bucket < 0) {
    return -1
  }
  var root = this.slabs[bucket]
  var hitNode = searchBucket(this.slabs[bucket], p)
  var lastHit = -1
  if(hitNode) {
    lastHit = hitNode.value
  }
  //Edge case: need to handle horizontal segments (sucks)
  if(this.coordinates[bucket] === p[0]) {
    var lastSegment = null
    if(hitNode) {
      lastSegment = hitNode.key
    }
    if(bucket > 0) {
      var otherHitNode = searchBucket(this.slabs[bucket-1], p)
      if(otherHitNode) {
        if(lastSegment) {
          if(orderSegments(otherHitNode.key, lastSegment) > 0) {
            lastSegment = otherHitNode.key
            lastHit = otherHitNode.value
          }
        } else {
          lastHit = otherHitNode.value
          lastSegment = otherHitNode.key
        }
      }
    }
    var horiz = this.horizontal[bucket]
    if(horiz.length > 0) {
      var hbucket = bounds.ge(horiz, p[1], compareHorizontal)
      if(hbucket < horiz.length) {
        var e = horiz[hbucket]
        if(p[1] === e.y) {
          if(e.closed) {
            return e.index
          } else {
            while(hbucket < horiz.length-1 && horiz[hbucket+1].y === p[1]) {
              hbucket = hbucket+1
              e = horiz[hbucket]
              if(e.closed) {
                return e.index
              }
            }
            if(e.y === p[1] && !e.start) {
              hbucket = hbucket+1
              if(hbucket >= horiz.length) {
                return lastHit
              }
              e = horiz[hbucket]
            }
          }
        }
        //Check if e is above/below last segment
        if(e.start) {
          if(lastSegment) {
            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y])
            if(lastSegment[0][0] > lastSegment[1][0]) {
              o = -o
            }
            if(o > 0) {
              lastHit = e.index
            }
          } else {
            lastHit = e.index
          }
        } else if(e.y !== p[1]) {
          lastHit = e.index
        }
      }
    }
  }
  return lastHit
}

function IntervalSegment(y, index, start, closed) {
  this.y = y
  this.index = index
  this.start = start
  this.closed = closed
}

function Event(x, segment, create, index) {
  this.x = x
  this.segment = segment
  this.create = create
  this.index = index
}


function createSlabDecomposition(segments) {
  var numSegments = segments.length
  var numEvents = 2 * numSegments
  var events = new Array(numEvents)
  for(var i=0; i<numSegments; ++i) {
    var s = segments[i]
    var f = s[0][0] < s[1][0]
    events[2*i] = new Event(s[0][0], s, f, i)
    events[2*i+1] = new Event(s[1][0], s, !f, i)
  }
  events.sort(function(a,b) {
    var d = a.x - b.x
    if(d) {
      return d
    }
    d = a.create - b.create
    if(d) {
      return d
    }
    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1])
  })
  var tree = createRBTree(orderSegments)
  var slabs = []
  var lines = []
  var horizontal = []
  var lastX = -Infinity
  for(var i=0; i<numEvents; ) {
    var x = events[i].x
    var horiz = []
    while(i < numEvents) {
      var e = events[i]
      if(e.x !== x) {
        break
      }
      i += 1
      if(e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
        if(e.create) {
          if(e.segment[0][1] < e.segment[1][1]) {
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                true,
                true))
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                false,
                false))
          } else {
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                true,
                false))
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                false,
                true))
          }
        }
      } else {
        if(e.create) {
          tree = tree.insert(e.segment, e.index)
        } else {
          tree = tree.remove(e.segment)
        }
      }
    }
    slabs.push(tree.root)
    lines.push(x)
    horizontal.push(horiz)
  }
  return new SlabDecomposition(slabs, lines, horizontal)
}
},{"./lib/order-segments":116,"binary-search-bounds":19,"functional-red-black-tree":45,"robust-orientation":105}],118:[function(require,module,exports){
"use strict"

module.exports = surfaceNets

var generateContourExtractor = require("ndarray-extract-contour")
var triangulateCube = require("triangulate-hypercube")
var zeroCrossings = require("zero-crossings")

function buildSurfaceNets(order, dtype) {
  var dimension = order.length
  var code = ["'use strict';"]
  var funcName = "surfaceNets" + order.join("_") + "d" + dtype

  //Contour extraction function
  code.push(
    "var contour=genContour({",
      "order:[", order.join(), "],",
      "scalarArguments: 3,",
      "phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },")
  if(dtype === "generic") {
    code.push("getters:[0],")
  }

  //Generate vertex function
  var cubeArgs = []
  var extraArgs = []
  for(var i=0; i<dimension; ++i) {
    cubeArgs.push("d" + i)
    extraArgs.push("d" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("v" + i)
    extraArgs.push("v" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("p" + i)
    extraArgs.push("p" + i)
  }
  cubeArgs.push("a", "b", "c")
  extraArgs.push("a", "c")
  code.push("vertex:function vertexFunc(", cubeArgs.join(), "){")
  //Mask args together
  var maskStr = []
  for(var i=0; i<(1<<dimension); ++i) {
    maskStr.push("(p" + i + "<<" + i + ")")
  }
  //Generate variables and giganto switch statement
  code.push("var m=(", maskStr.join("+"), ")|0;if(m===0||m===", (1<<(1<<dimension))-1, "){return}")
  var extraFuncs = []
  var currentFunc = []
  if(1<<(1<<dimension) <= 128) {
    code.push("switch(m){")
    currentFunc = code
  } else {
    code.push("switch(m>>>7){")
  }
  for(var i=0; i<1<<(1<<dimension); ++i) {
    if(1<<(1<<dimension) > 128) {
      if((i%128)===0) {
        if(extraFuncs.length > 0) {
          currentFunc.push("}}")
        }
        var efName = "vExtra" + extraFuncs.length
        code.push("case ", (i>>>7), ":", efName, "(m&0x7f,", extraArgs.join(), ");break;")
        currentFunc = [
          "function ", efName, "(m,", extraArgs.join(), "){switch(m){"
        ]
        extraFuncs.push(currentFunc)
      }  
    }
    currentFunc.push("case ", (i&0x7f), ":")
    var crossings = new Array(dimension)
    var denoms = new Array(dimension)
    var crossingCount = new Array(dimension)
    var bias = new Array(dimension)
    var totalCrossings = 0
    for(var j=0; j<dimension; ++j) {
      crossings[j] = []
      denoms[j] = []
      crossingCount[j] = 0
      bias[j] = 0
    }
    for(var j=0; j<(1<<dimension); ++j) {
      for(var k=0; k<dimension; ++k) {
        var u = j ^ (1<<k)
        if(u > j) {
          continue
        }
        if(!(i&(1<<u)) !== !(i&(1<<j))) {
          var sign = 1
          if(i&(1<<u)) {
            denoms[k].push("v" + u + "-v" + j)
          } else {
            denoms[k].push("v" + j + "-v" + u)
            sign = -sign
          }
          if(sign < 0) {
            crossings[k].push("-v" + j + "-v" + u)
            crossingCount[k] += 2
          } else {
            crossings[k].push("v" + j + "+v" + u)
            crossingCount[k] -= 2            
          }
          totalCrossings += 1
          for(var l=0; l<dimension; ++l) {
            if(l === k) {
              continue
            }
            if(u&(1<<l)) {
              bias[l] += 1
            } else {
              bias[l] -= 1
            }
          }
        }
      }
    }
    var vertexStr = []
    for(var k=0; k<dimension; ++k) {
      if(crossings[k].length === 0) {
        vertexStr.push("d" + k + "-0.5")
      } else {
        var cStr = ""
        if(crossingCount[k] < 0) {
          cStr = crossingCount[k] + "*c"
        } else if(crossingCount[k] > 0) {
          cStr = "+" + crossingCount[k] + "*c"
        }
        var weight = 0.5 * (crossings[k].length / totalCrossings)
        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings)
        vertexStr.push("d" + k + "-" + shift + "-" + weight + "*(" + crossings[k].join("+") + cStr + ")/(" + denoms[k].join("+") + ")")
        
      }
    }
    currentFunc.push("a.push([", vertexStr.join(), "]);",
      "break;")
  }
  code.push("}},")
  if(extraFuncs.length > 0) {
    currentFunc.push("}}")
  }

  //Create face function
  var faceArgs = []
  for(var i=0; i<(1<<(dimension-1)); ++i) {
    faceArgs.push("v" + i)
  }
  faceArgs.push("c0", "c1", "p0", "p1", "a", "b", "c")
  code.push("cell:function cellFunc(", faceArgs.join(), "){")

  var facets = triangulateCube(dimension-1)
  code.push("if(p0){b.push(",
    facets.map(function(f) {
      return "[" + f.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(), ")}else{b.push(",
    facets.map(function(f) {
      var e = f.slice()
      e.reverse()
      return "[" + e.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(),
    ")}}});function ", funcName, "(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return ", funcName, ";")

  for(var i=0; i<extraFuncs.length; ++i) {
    code.push(extraFuncs[i].join(""))
  }

  //Compile and link
  var proc = new Function("genContour", code.join(""))
  return proc(generateContourExtractor)
}

//1D case: Need to handle specially
function mesh1D(array, level) {
  var zc = zeroCrossings(array, level)
  var n = zc.length
  var npos = new Array(n)
  var ncel = new Array(n)
  for(var i=0; i<n; ++i) {
    npos[i] = [ zc[i] ]
    ncel[i] = [ i ]
  }
  return {
    positions: npos,
    cells: ncel
  }
}

var CACHE = {}

function surfaceNets(array,level) {
  if(array.dimension <= 0) {
    return { positions: [], cells: [] }
  } else if(array.dimension === 1) {
    return mesh1D(array, level)
  }
  var typesig = array.order.join() + "-" + array.dtype
  var proc = CACHE[typesig]
  var level = (+level) || 0.0
  if(!proc) {
    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype)
  }
  return proc(array,level)
}
},{"ndarray-extract-contour":85,"triangulate-hypercube":177,"zero-crossings":186}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LinearDisplayP3ColorSpace = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.FrontSide = exports.FloatType = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DisplayP3ColorSpace = exports.DepthStencilFormat = exports.DepthFormat = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.ByteType = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.sRGBEncoding = exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WebGPUCoordinateSystem = exports.WebGLCoordinateSystem = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UVMapping = exports.TwoPassDoubleSide = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.ShortType = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = void 0;
const REVISION = '156';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const TwoPassDoubleSide = 2; // r149

exports.TwoPassDoubleSide = TwoPassDoubleSide;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const RGB_BPTC_SIGNED_Format = 36494;
exports.RGB_BPTC_SIGNED_Format = RGB_BPTC_SIGNED_Format;
const RGB_BPTC_UNSIGNED_Format = 36495;
exports.RGB_BPTC_UNSIGNED_Format = RGB_BPTC_UNSIGNED_Format;
const RED_RGTC1_Format = 36283;
exports.RED_RGTC1_Format = RED_RGTC1_Format;
const SIGNED_RED_RGTC1_Format = 36284;
exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
const RED_GREEN_RGTC2_Format = 36285;
exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */

exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
/** @deprecated Use SRGBColorSpace in three.js r152+. */

exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const NoColorSpace = '';
exports.NoColorSpace = NoColorSpace;
const SRGBColorSpace = 'srgb';
exports.SRGBColorSpace = SRGBColorSpace;
const LinearSRGBColorSpace = 'srgb-linear';
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
const DisplayP3ColorSpace = 'display-p3';
exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
const LinearDisplayP3ColorSpace = 'display-p3-linear';
exports.LinearDisplayP3ColorSpace = LinearDisplayP3ColorSpace;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const NeverCompare = 512;
exports.NeverCompare = NeverCompare;
const LessCompare = 513;
exports.LessCompare = LessCompare;
const EqualCompare = 514;
exports.EqualCompare = EqualCompare;
const LessEqualCompare = 515;
exports.LessEqualCompare = LessEqualCompare;
const GreaterCompare = 516;
exports.GreaterCompare = GreaterCompare;
const NotEqualCompare = 517;
exports.NotEqualCompare = NotEqualCompare;
const GreaterEqualCompare = 518;
exports.GreaterEqualCompare = GreaterEqualCompare;
const AlwaysCompare = 519;
exports.AlwaysCompare = AlwaysCompare;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';
exports.GLSL3 = GLSL3;
const _SRGBAFormat = 1035; // fallback for WebGL 1

exports._SRGBAFormat = _SRGBAFormat;
const WebGLCoordinateSystem = 2000;
exports.WebGLCoordinateSystem = WebGLCoordinateSystem;
const WebGPUCoordinateSystem = 2001;
exports.WebGPUCoordinateSystem = WebGPUCoordinateSystem;

},{}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.BufferAttribute = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _MathUtils = require("../math/MathUtils.js");

var _constants = require("../constants.js");

var _DataUtils = require("../extras/DataUtils.js");

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _vector2 = /*@__PURE__*/new _Vector2.Vector2();

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = _constants.StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.gpuType = _constants.FloatType;
    this.version = 0;
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  copyArray(array) {
    this.array.set(array);
    return this;
  }

  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);

        _vector2.applyMatrix3(m);

        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector.fromBufferAttribute(this, i);

        _vector.applyMatrix3(m);

        this.setXYZ(i, _vector.x, _vector.y, _vector.z);
      }
    }

    return this;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyMatrix4(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyNormalMatrix(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.transformDirection(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  set(value, offset = 0) {
    // Matching BufferAttribute constructor, do not normalize the array.
    this.array.set(value, offset);
    return this;
  }

  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = (0, _MathUtils.denormalize)(value, this.array);
    return value;
  }

  setComponent(index, component, value) {
    if (this.normalized) value = (0, _MathUtils.normalize)(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }

  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }

  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }

  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }

  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }

  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== '') data.name = this.name;
    if (this.usage !== _constants.StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }

} //


exports.BufferAttribute = BufferAttribute;

class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }

}

exports.Int8BufferAttribute = Int8BufferAttribute;

class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }

}

exports.Uint8BufferAttribute = Uint8BufferAttribute;

class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }

}

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }

}

exports.Int16BufferAttribute = Int16BufferAttribute;

class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Uint16BufferAttribute = Uint16BufferAttribute;

class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }

}

exports.Int32BufferAttribute = Int32BufferAttribute;

class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }

}

exports.Uint32BufferAttribute = Uint32BufferAttribute;

class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }

  getX(index) {
    let x = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize]);
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = (0, _DataUtils.toHalfFloat)(x);
    return this;
  }

  getY(index) {
    let y = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  getZ(index) {
    let z = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  getW(index) {
    let w = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    this.array[index + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

}

exports.Float16BufferAttribute = Float16BufferAttribute;

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }

}

exports.Float32BufferAttribute = Float32BufferAttribute;

class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }

} //


exports.Float64BufferAttribute = Float64BufferAttribute;

},{"../constants.js":119,"../extras/DataUtils.js":125,"../math/MathUtils.js":168,"../math/Vector2.js":174,"../math/Vector3.js":175}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferGeometry = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _Box = require("../math/Box3.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _BufferAttribute = require("./BufferAttribute.js");

var _Sphere = require("../math/Sphere.js");

var _Object3D = require("./Object3D.js");

var _Matrix = require("../math/Matrix4.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _utils = require("../utils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _id = 0;

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _obj = /*@__PURE__*/new _Object3D.Object3D();

const _offset = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new _Box.Box3();

const _boxMorphTargets = /*@__PURE__*/new _Box.Box3();

const _vector = /*@__PURE__*/new _Vector.Vector3();

class BufferGeometry extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, 'id', {
      value: _id++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new ((0, _utils.arrayNeedsUint32)(index) ? _BufferAttribute.Uint32BufferAttribute : _BufferAttribute.Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }

  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }

  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  }

  clearGroups() {
    this.groups = [];
  }

  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }

  applyMatrix4(matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new _Matrix2.Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  }

  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  }

  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }

  setFromPoints(points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(position, 3));
    return this;
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new _Box.Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new _Vector.Vector3(-Infinity, -Infinity, -Infinity), new _Vector.Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(this.boundingBox.min, _box.min);

            this.boundingBox.expandByPoint(_vector);

            _vector.addVectors(this.boundingBox.max, _box.max);

            this.boundingBox.expandByPoint(_vector);
          } else {
            this.boundingBox.expandByPoint(_box.min);
            this.boundingBox.expandByPoint(_box.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new _Sphere.Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new _Vector.Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(_box.min, _boxMorphTargets.min);

            _box.expandByPoint(_vector);

            _vector.addVectors(_box.max, _boxMorphTargets.max);

            _box.expandByPoint(_vector);
          } else {
            _box.expandByPoint(_boxMorphTargets.min);

            _box.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }

  computeTangents() {
    const index = this.index;
    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;

    if (this.hasAttribute('tangent') === false) {
      this.setAttribute('tangent', new _BufferAttribute.BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    const tangents = this.getAttribute('tangent').array;
    const tan1 = [],
          tan2 = [];

    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new _Vector.Vector3();
      tan2[i] = new _Vector.Vector3();
    }

    const vA = new _Vector.Vector3(),
          vB = new _Vector.Vector3(),
          vC = new _Vector.Vector3(),
          uvA = new _Vector2.Vector2(),
          uvB = new _Vector2.Vector2(),
          uvC = new _Vector2.Vector2(),
          sdir = new _Vector.Vector3(),
          tdir = new _Vector.Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    let groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    const tmp = new _Vector.Vector3(),
          tmp2 = new _Vector.Vector3();
    const n = new _Vector.Vector3(),
          n2 = new _Vector.Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }

  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new _BufferAttribute.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new _Vector.Vector3(),
            pB = new _Vector.Vector3(),
            pC = new _Vector.Vector3();
      const nA = new _Vector.Vector3(),
            nB = new _Vector.Vector3(),
            nC = new _Vector.Vector3();
      const cb = new _Vector.Vector3(),
            ab = new _Vector.Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }

  normalizeNormals() {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector.fromBufferAttribute(normals, i);

      _vector.normalize();

      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
  }

  toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices[i] * itemSize;
        }

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new _BufferAttribute.BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.BufferGeometry = BufferGeometry;

},{"../math/Box3.js":166,"../math/MathUtils.js":168,"../math/Matrix3.js":169,"../math/Matrix4.js":170,"../math/Sphere.js":172,"../math/Vector2.js":174,"../math/Vector3.js":175,"../utils.js":176,"./BufferAttribute.js":120,"./EventDispatcher.js":122,"./Object3D.js":124}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventDispatcher = void 0;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  hasEventListener(type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }

      event.target = null;
    }
  }

}

exports.EventDispatcher = EventDispatcher;

},{}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layers = void 0;

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }

}

exports.Layers = Layers;

},{}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Object3D = void 0;

var _Quaternion = require("../math/Quaternion.js");

var _Vector = require("../math/Vector3.js");

var _Matrix = require("../math/Matrix4.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _Euler = require("../math/Euler.js");

var _Layers = require("./Layers.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _object3DId = 0;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _q1 = /*@__PURE__*/new _Quaternion.Quaternion();

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _target = /*@__PURE__*/new _Vector.Vector3();

const _position = /*@__PURE__*/new _Vector.Vector3();

const _scale = /*@__PURE__*/new _Vector.Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

const _xAxis = /*@__PURE__*/new _Vector.Vector3(1, 0, 0);

const _yAxis = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);

const _zAxis = /*@__PURE__*/new _Vector.Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

class Object3D extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new _Vector.Vector3();
    const rotation = new _Euler.Euler();
    const quaternion = new _Quaternion.Quaternion();
    const scale = new _Vector.Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new _Matrix.Matrix4()
      },
      normalMatrix: {
        value: new _Matrix2.Matrix3()
      }
    });
    this.matrix = new _Matrix.Matrix4();
    this.matrixWorld = new _Matrix.Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

    this.layers = new _Layers.Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }

  onBeforeRender() {}

  onAfterRender() {}

  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }

  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }

  setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  }

  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }

  setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  }

  setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  }

  rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  }

  rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  }

  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }

  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }

  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }

  translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1.multiplyScalar(distance));
    return this;
  }

  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }

  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }

  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }

  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }

  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  }

  lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1);

    if (parent) {
      _m1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1);

      this.quaternion.premultiply(_q1.invert());
    }
  }

  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  }

  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  }

  removeFromParent() {
    const parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  }

  clear() {
    return this.remove(...this.children);
  }

  attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
    this.updateWorldMatrix(true, false);

    _m1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }

  getObjectById(id) {
    return this.getObjectByProperty('id', id);
  }

  getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  }

  getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  }

  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value) result.push(this);

    for (let i = 0, l = this.children.length; i < l; i++) {
      const childResult = this.children[i].getObjectsByProperty(name, value);

      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }

    return result;
  }

  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }

  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  }

  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  }

  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }

  raycast() {}

  traverse(callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }

  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }

  traverseAncestors(callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }

  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }

  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];

      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }

  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];

        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }

  toJSON(meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }

      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  }

  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }

  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }

}

exports.Object3D = Object3D;
Object3D.DEFAULT_UP = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

},{"../math/Euler.js":167,"../math/MathUtils.js":168,"../math/Matrix3.js":169,"../math/Matrix4.js":170,"../math/Quaternion.js":171,"../math/Vector3.js":175,"./EventDispatcher.js":122,"./Layers.js":123}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataUtils = void 0;
exports.fromHalfFloat = fromHalfFloat;
exports.toHalfFloat = toHalfFloat;

var _MathUtils = require("../math/MathUtils.js");

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
const _tables = /*@__PURE__*/_generateTables();

function _generateTables() {
  // float32 to float16 helpers
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);

  for (let i = 0; i < 256; ++i) {
    const e = i - 127; // very small number (0, -0)

    if (e < -27) {
      baseTable[i] = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // small number (denorm)
    } else if (e < -14) {
      baseTable[i] = 0x0400 >> -e - 14;
      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
      shiftTable[i] = -e - 1;
      shiftTable[i | 0x100] = -e - 1; // normal number
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
    } else if (e < 128) {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
    } else {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;
    }
  } // float16 to float32 helpers


  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);

  for (let i = 1; i < 1024; ++i) {
    let m = i << 13; // zero pad mantissa bits

    let e = 0; // zero exponent
    // normalized

    while ((m & 0x00800000) === 0) {
      m <<= 1;
      e -= 0x00800000; // decrement exponent
    }

    m &= ~0x00800000; // clear leading 1 bit

    e += 0x38800000; // adjust bias

    mantissaTable[i] = m | e;
  }

  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
  }

  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }

  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;

  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 0x80000000 + (i - 32 << 23);
  }

  exponentTable[63] = 0xc7800000;

  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }

  return {
    floatView: floatView,
    uint32View: uint32View,
    baseTable: baseTable,
    shiftTable: shiftTable,
    mantissaTable: mantissaTable,
    exponentTable: exponentTable,
    offsetTable: offsetTable
  };
} // float32 to float16


function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
  val = (0, _MathUtils.clamp)(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 0x1ff;
  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
} // float16 to float32


function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}

const DataUtils = {
  toHalfFloat: toHalfFloat,
  fromHalfFloat: fromHalfFloat
};
exports.DataUtils = DataUtils;

},{"../math/MathUtils.js":168}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Earcut = void 0;

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */
const Earcut = {
  triangulate: function (data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

exports.Earcut = Earcut;

function linkedList(data, start, end, dim, clockwise) {
  let i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  const ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;

  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  const ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy; // z-order range for the current triangle bbox;

  const minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    const a = p.prev,
          b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and link it


function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);

  if (!bridge) {
    return outerNode;
  }

  const bridgeReverse = splitPolygon(bridge, hole); // filter collinear points around the cuts

  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  let p = outerNode,
      qx = -Infinity,
      m;
  const hx = hole.x,
        hy = hole.y; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null; // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  const stop = m,
        mx = m.x,
        my = m.y;
  let tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  let i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  let p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  let p = a,
      inside = false;
  const px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = 0; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  let sum = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}

},{}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeUtils = void 0;

var _Earcut = require("./Earcut.js");

class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0.0;

    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  }

  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }

  static triangulateShape(contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    const holeIndices = []; // array of hole indices

    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    const triangles = _Earcut.Earcut.triangulate(vertices, holeIndices); //


    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }

}

exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  const l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}

},{"./Earcut.js":126}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Curve = void 0;

var MathUtils = _interopRequireWildcard(require("../../math/MathUtils.js"));

var _Vector = require("../../math/Vector2.js");

var _Vector2 = require("../../math/Vector3.js");

var _Matrix = require("../../math/Matrix4.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/
class Curve {
  constructor() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  } // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]


  getPoint() {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  } // Get point at relative position in curve according to arc length
  // - u [0 .. 1]


  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  } // Get sequence of points using getPoint( t )


  getPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  } // Get sequence of points using getPointAt( u )


  getSpacedPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  } // Get total curve arc length


  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  } // Get list of cumulative segment lengths


  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    const cache = [];
    let current,
        last = this.getPoint(0);
    let sum = 0;
    cache.push(0);

    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  }

  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    let low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  } // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation


  getTangent(t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new _Vector.Vector2() : new _Vector2.Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }

  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }

  computeFrenetFrames(segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    const normal = new _Vector2.Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new _Vector2.Vector3();
    const mat = new _Matrix.Matrix4(); // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new _Vector2.Vector3());
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new _Vector2.Vector3();
    binormals[0] = new _Vector2.Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }

  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }

}

exports.Curve = Curve;

},{"../../math/MathUtils.js":168,"../../math/Matrix4.js":170,"../../math/Vector2.js":174,"../../math/Vector3.js":175}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurvePath = void 0;

var _Curve = require("./Curve.js");

var Curves = _interopRequireWildcard(require("../curves/Curves.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/
class CurvePath extends _Curve.Curve {
  constructor() {
    super();
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
  }

  add(curve) {
    this.curves.push(curve);
  }

  closePath() {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));
    }
  } // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')


  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  } // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength


  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  } // cacheLengths must be recalculated.


  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  } // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.


  getCurveLengths() {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    const lengths = [];
    let sums = 0;

    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  }

  getSpacedPoints(divisions = 40) {
    const points = [];

    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  }

  getPoints(divisions = 12) {
    const points = [];
    let last;

    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);

      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  }

  copy(source) {
    super.copy(source);
    this.curves = [];

    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];

    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }

}

exports.CurvePath = CurvePath;

},{"../curves/Curves.js":137,"./Curve.js":128}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatmullRom = CatmullRom;
exports.CubicBezier = CubicBezier;
exports.QuadraticBezier = QuadraticBezier;

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

},{}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Path = void 0;

var _Vector = require("../../math/Vector2.js");

var _CurvePath = require("./CurvePath.js");

var _EllipseCurve = require("../curves/EllipseCurve.js");

var _SplineCurve = require("../curves/SplineCurve.js");

var _CubicBezierCurve = require("../curves/CubicBezierCurve.js");

var _QuadraticBezierCurve = require("../curves/QuadraticBezierCurve.js");

var _LineCurve = require("../curves/LineCurve.js");

class Path extends _CurvePath.CurvePath {
  constructor(points) {
    super();
    this.type = 'Path';
    this.currentPoint = new _Vector.Vector2();

    if (points) {
      this.setFromPoints(points);
    }
  }

  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);

    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }

    return this;
  }

  moveTo(x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  }

  lineTo(x, y) {
    const curve = new _LineCurve.LineCurve(this.currentPoint.clone(), new _Vector.Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }

  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new _QuadraticBezierCurve.QuadraticBezierCurve(this.currentPoint.clone(), new _Vector.Vector2(aCPx, aCPy), new _Vector.Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new _CubicBezierCurve.CubicBezierCurve(this.currentPoint.clone(), new _Vector.Vector2(aCP1x, aCP1y), new _Vector.Vector2(aCP2x, aCP2y), new _Vector.Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  splineThru(pts
  /*Array of Vector*/
  ) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new _SplineCurve.SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }

  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }

  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new _EllipseCurve.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }

  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }

}

exports.Path = Path;

},{"../../math/Vector2.js":174,"../curves/CubicBezierCurve.js":135,"../curves/EllipseCurve.js":138,"../curves/LineCurve.js":139,"../curves/QuadraticBezierCurve.js":141,"../curves/SplineCurve.js":143,"./CurvePath.js":129}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Shape = void 0;

var _Path = require("./Path.js");

var MathUtils = _interopRequireWildcard(require("../../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Shape extends _Path.Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = 'Shape';
    this.holes = [];
  }

  getPointsHoles(divisions) {
    const holesPts = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  } // get points of shape and holes (keypoints based on segments parameter)


  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }

  copy(source) {
    super.copy(source);
    this.holes = [];

    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];

    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new _Path.Path().fromJSON(hole));
    }

    return this;
  }

}

exports.Shape = Shape;

},{"../../math/MathUtils.js":168,"./Path.js":131}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArcCurve = void 0;

var _EllipseCurve = require("./EllipseCurve.js");

class ArcCurve extends _EllipseCurve.EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = 'ArcCurve';
  }

}

exports.ArcCurve = ArcCurve;

},{"./EllipseCurve.js":138}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatmullRomCurve3 = void 0;

var _Vector = require("../../math/Vector3.js");

var _Curve = require("../core/Curve.js");

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/
function CubicPoly() {
  let c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


const tmp = /*@__PURE__*/new _Vector.Vector3();
const px = /*@__PURE__*/new CubicPoly();
const py = /*@__PURE__*/new CubicPoly();
const pz = /*@__PURE__*/new CubicPoly();

class CatmullRomCurve3 extends _Curve.Curve {
  constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = 'CatmullRomCurve3';
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;

    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }

    let p0, p3; // 4 points (p1 & p2 defined below)

    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      // extrapolate first point
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }

    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];

    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      // extrapolate last point
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }

    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
      // init Centripetal / Chordal Catmull-Rom
      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

      if (dt1 < 1e-4) dt1 = 1.0;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }

    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new _Vector.Vector3().fromArray(point));
    }

    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }

}

exports.CatmullRomCurve3 = CatmullRomCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicBezierCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class CubicBezierCurve extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector2(), v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2(), v3 = new _Vector.Vector2()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = 'CubicBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set((0, _Interpolations.CubicBezier)(t, v0.x, v1.x, v2.x, v3.x), (0, _Interpolations.CubicBezier)(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve = CubicBezierCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicBezierCurve3 = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector3.js");

class CubicBezierCurve3 extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector3(), v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3(), v3 = new _Vector.Vector3()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = 'CubicBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set((0, _Interpolations.CubicBezier)(t, v0.x, v1.x, v2.x, v3.x), (0, _Interpolations.CubicBezier)(t, v0.y, v1.y, v2.y, v3.y), (0, _Interpolations.CubicBezier)(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve3 = CubicBezierCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128,"../core/Interpolations.js":130}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcCurve", {
  enumerable: true,
  get: function () {
    return _ArcCurve.ArcCurve;
  }
});
Object.defineProperty(exports, "CatmullRomCurve3", {
  enumerable: true,
  get: function () {
    return _CatmullRomCurve.CatmullRomCurve3;
  }
});
Object.defineProperty(exports, "CubicBezierCurve", {
  enumerable: true,
  get: function () {
    return _CubicBezierCurve.CubicBezierCurve;
  }
});
Object.defineProperty(exports, "CubicBezierCurve3", {
  enumerable: true,
  get: function () {
    return _CubicBezierCurve2.CubicBezierCurve3;
  }
});
Object.defineProperty(exports, "EllipseCurve", {
  enumerable: true,
  get: function () {
    return _EllipseCurve.EllipseCurve;
  }
});
Object.defineProperty(exports, "LineCurve", {
  enumerable: true,
  get: function () {
    return _LineCurve.LineCurve;
  }
});
Object.defineProperty(exports, "LineCurve3", {
  enumerable: true,
  get: function () {
    return _LineCurve2.LineCurve3;
  }
});
Object.defineProperty(exports, "QuadraticBezierCurve", {
  enumerable: true,
  get: function () {
    return _QuadraticBezierCurve.QuadraticBezierCurve;
  }
});
Object.defineProperty(exports, "QuadraticBezierCurve3", {
  enumerable: true,
  get: function () {
    return _QuadraticBezierCurve2.QuadraticBezierCurve3;
  }
});
Object.defineProperty(exports, "SplineCurve", {
  enumerable: true,
  get: function () {
    return _SplineCurve.SplineCurve;
  }
});

var _ArcCurve = require("./ArcCurve.js");

var _CatmullRomCurve = require("./CatmullRomCurve3.js");

var _CubicBezierCurve = require("./CubicBezierCurve.js");

var _CubicBezierCurve2 = require("./CubicBezierCurve3.js");

var _EllipseCurve = require("./EllipseCurve.js");

var _LineCurve = require("./LineCurve.js");

var _LineCurve2 = require("./LineCurve3.js");

var _QuadraticBezierCurve = require("./QuadraticBezierCurve.js");

var _QuadraticBezierCurve2 = require("./QuadraticBezierCurve3.js");

var _SplineCurve = require("./SplineCurve.js");

},{"./ArcCurve.js":133,"./CatmullRomCurve3.js":134,"./CubicBezierCurve.js":135,"./CubicBezierCurve3.js":136,"./EllipseCurve.js":138,"./LineCurve.js":139,"./LineCurve3.js":140,"./QuadraticBezierCurve.js":141,"./QuadraticBezierCurve3.js":142,"./SplineCurve.js":143}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EllipseCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Vector = require("../../math/Vector2.js");

class EllipseCurve extends _Curve.Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = 'EllipseCurve';
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }

  getPoint(t, optionalTarget) {
    const point = optionalTarget || new _Vector.Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

    while (deltaAngle < 0) deltaAngle += twoPi;

    while (deltaAngle > twoPi) deltaAngle -= twoPi;

    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }

    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }

    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);

    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY; // Rotate the point about the center of the ellipse.

      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }

    return point.set(x, y);
  }

  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }

}

exports.EllipseCurve = EllipseCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineCurve = void 0;

var _Vector = require("../../math/Vector2.js");

var _Curve = require("../core/Curve.js");

class LineCurve extends _Curve.Curve {
  constructor(v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = 'LineCurve';
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  getTangent(t, optionalTarget = new _Vector.Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }

  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve = LineCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineCurve3 = void 0;

var _Vector = require("../../math/Vector3.js");

var _Curve = require("../core/Curve.js");

class LineCurve3 extends _Curve.Curve {
  constructor(v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3()) {
    super();
    this.isLineCurve3 = true;
    this.type = 'LineCurve3';
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  getTangent(t, optionalTarget = new _Vector.Vector3()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }

  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve3 = LineCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadraticBezierCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class QuadraticBezierCurve extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector2(), v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set((0, _Interpolations.QuadraticBezier)(t, v0.x, v1.x, v2.x), (0, _Interpolations.QuadraticBezier)(t, v0.y, v1.y, v2.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve = QuadraticBezierCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadraticBezierCurve3 = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector3.js");

class QuadraticBezierCurve3 extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector3(), v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set((0, _Interpolations.QuadraticBezier)(t, v0.x, v1.x, v2.x), (0, _Interpolations.QuadraticBezier)(t, v0.y, v1.y, v2.y), (0, _Interpolations.QuadraticBezier)(t, v0.z, v1.z, v2.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128,"../core/Interpolations.js":130}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SplineCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class SplineCurve extends _Curve.Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = 'SplineCurve';
    this.points = points;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set((0, _Interpolations.CatmullRom)(weight, p0.x, p1.x, p2.x, p3.x), (0, _Interpolations.CatmullRom)(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new _Vector.Vector2().fromArray(point));
    }

    return this;
  }

}

exports.SplineCurve = SplineCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class BoxGeometry extends _BufferGeometry.BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this; // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let numberOfVertices = 0;
    let groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new _Vector.Vector3(); // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;

        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }

}

exports.BoxGeometry = BoxGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CapsuleGeometry = void 0;

var _Path = require("../extras/core/Path.js");

var _LatheGeometry = require("./LatheGeometry.js");

class CapsuleGeometry extends _LatheGeometry.LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new _Path.Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = 'CapsuleGeometry';
    this.parameters = {
      radius: radius,
      length: length,
      capSegments: capSegments,
      radialSegments: radialSegments
    };
  }

  static fromJSON(data) {
    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }

}

exports.CapsuleGeometry = CapsuleGeometry;

},{"../extras/core/Path.js":131,"./LatheGeometry.js":154}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class CircleGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new _Vector.Vector3();
    const uv = new _Vector2.Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }

}

exports.CircleGeometry = CircleGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConeGeometry = void 0;

var _CylinderGeometry = require("./CylinderGeometry.js");

class ConeGeometry extends _CylinderGeometry.CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }

}

exports.ConeGeometry = ConeGeometry;

},{"./CylinderGeometry.js":148}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CylinderGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class CylinderGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0; // generate geometry

    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      const normal = new _Vector.Vector3();
      const vertex = new _Vector.Vector3();
      let groupCount = 0; // this will be used to calculate the normal

      const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments; // calculate the radius of the current row

        const radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta); // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z); // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z); // uv

          uvs.push(u, 1 - v); // save index of vertex in respective row

          indexRow.push(index++);
        } // now save vertices of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          // we use the index array to access the correct indices
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1]; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // update group counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

      groupStart += groupCount;
    }

    function generateCap(top) {
      // save the index of the first center vertex
      const centerIndexStart = index;
      const uv = new _Vector2.Vector2();
      const vertex = new _Vector.Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (let x = 1; x <= radialSegments; x++) {
        // vertex
        vertices.push(0, halfHeight * sign, 0); // normal

        normals.push(0, sign, 0); // uv

        uvs.push(0.5, 0.5); // increase index

        index++;
      } // save the index of the last center vertex


      const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, sign, 0); // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y); // increase index

        index++;
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;

        if (top === true) {
          // face top
          indices.push(i, i + 1, c);
        } else {
          // face bottom
          indices.push(i + 1, i, c);
        }

        groupCount += 3;
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

      groupStart += groupCount;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }

}

exports.CylinderGeometry = CylinderGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DodecahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class DodecahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [// (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }

}

exports.DodecahedronGeometry = DodecahedronGeometry;

},{"./PolyhedronGeometry.js":157}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EdgesGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _Triangle = require("../math/Triangle.js");

var _Vector = require("../math/Vector3.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _normal = /*@__PURE__*/new _Vector.Vector3();

const _triangle = /*@__PURE__*/new _Triangle.Triangle();

class EdgesGeometry extends _BufferGeometry.BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = 'EdgesGeometry';
    this.parameters = {
      geometry: geometry,
      thresholdAngle: thresholdAngle
    };

    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute('position');
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ['a', 'b', 'c'];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];

      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }

        const {
          a,
          b,
          c
        } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);

        _triangle.getNormal(_normal); // create hashes for the edge from the vertices


        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles

        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        } // iterate over every edge


        for (let j = 0; j < 3; j++) {
          // get the first and next vertex making up the edge
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;

          if (reverseHash in edgeData && edgeData[reverseHash]) {
            // if we found a sibling edge add it into the vertex array if
            // it meets the angle threshold and delete the edge from the map.
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }

            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            // if we've already got an edge here then skip adding a new one
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      } // iterate over all remaining, unmatched edges and add them to the vertex array


      for (const key in edgeData) {
        if (edgeData[key]) {
          const {
            index0,
            index1
          } = edgeData[key];

          _v0.fromBufferAttribute(positionAttr, index0);

          _v1.fromBufferAttribute(positionAttr, index1);

          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1.x, _v1.y, _v1.z);
        }
      }

      this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

}

exports.EdgesGeometry = EdgesGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/MathUtils.js":168,"../math/Triangle.js":173,"../math/Vector3.js":175}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtrudeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var Curves = _interopRequireWildcard(require("../extras/curves/Curves.js"));

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

var _Shape = require("../extras/core/Shape.js");

var _ShapeUtils = require("../extras/ShapeUtils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
class ExtrudeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(shapes = new _Shape.Shape([new _Vector.Vector2(0.5, 0.5), new _Vector.Vector2(-0.5, 0.5), new _Vector.Vector2(-0.5, -0.5), new _Vector.Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];

    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    } // build geometry


    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals(); // functions

    function addShape(shape) {
      const placeholder = []; // options

      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      const steps = options.steps !== undefined ? options.steps : 1;
      const depth = options.depth !== undefined ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; //

      let extrudePts,
          extrudeByPath = false;
      let splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new _Vector2.Vector3();
        normal = new _Vector2.Vector3();
        position2 = new _Vector2.Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !_ShapeUtils.ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];

          if (_ShapeUtils.ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      const faces = _ShapeUtils.ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */


      const contour = vertices; // vertices has all points but contour has only points of circumference

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return pt.clone().addScaledVector(vec, size);
      }

      const vlen = vertices.length,
            flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        const v_prev_x = inPt.x - inPrev.x,
              v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
              v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new _Vector.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          let direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new _Vector.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      const contourMovements = [];

      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }

      const holesMovements = [];
      let oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];

        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0; //  (j)---(i)---(k)

          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (let b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }

      const bs = bevelSize + bevelOffset; // Back facing vertices

      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        const start = verticesArray.length / 3;

        if (bevelEnabled) {
          let layer = 0; // steps + 1

          let offset = vlen * layer; // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          // Bottom faces
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          } // Top faces


          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset); //, true

          layeroffset += ahole.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        let i = contour.length;

        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
                  b = layeroffset + k + slen1,
                  c = layeroffset + k + slen2,
                  d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }

  static fromJSON(data, shapes) {
    const geometryShapes = [];

    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    const extrudePath = data.options.extrudePath;

    if (extrudePath !== undefined) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }

    return new ExtrudeGeometry(geometryShapes, data.options);
  }

}

exports.ExtrudeGeometry = ExtrudeGeometry;
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new _Vector.Vector2(a_x, a_y), new _Vector.Vector2(b_x, b_y), new _Vector.Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new _Vector.Vector2(a_x, 1 - a_z), new _Vector.Vector2(b_x, 1 - b_z), new _Vector.Vector2(c_x, 1 - c_z), new _Vector.Vector2(d_x, 1 - d_z)];
    } else {
      return [new _Vector.Vector2(a_y, 1 - a_z), new _Vector.Vector2(b_y, 1 - b_z), new _Vector.Vector2(c_y, 1 - c_z), new _Vector.Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  data.options = Object.assign({}, options);
  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/ShapeUtils.js":127,"../extras/core/Shape.js":132,"../extras/curves/Curves.js":137,"../math/Vector2.js":174,"../math/Vector3.js":175}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BoxGeometry = require("./BoxGeometry.js");

Object.keys(_BoxGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _BoxGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BoxGeometry[key];
    }
  });
});

var _CapsuleGeometry = require("./CapsuleGeometry.js");

Object.keys(_CapsuleGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CapsuleGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CapsuleGeometry[key];
    }
  });
});

var _CircleGeometry = require("./CircleGeometry.js");

Object.keys(_CircleGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CircleGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CircleGeometry[key];
    }
  });
});

var _ConeGeometry = require("./ConeGeometry.js");

Object.keys(_ConeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ConeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ConeGeometry[key];
    }
  });
});

var _CylinderGeometry = require("./CylinderGeometry.js");

Object.keys(_CylinderGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CylinderGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CylinderGeometry[key];
    }
  });
});

var _DodecahedronGeometry = require("./DodecahedronGeometry.js");

Object.keys(_DodecahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _DodecahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DodecahedronGeometry[key];
    }
  });
});

var _EdgesGeometry = require("./EdgesGeometry.js");

Object.keys(_EdgesGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _EdgesGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _EdgesGeometry[key];
    }
  });
});

var _ExtrudeGeometry = require("./ExtrudeGeometry.js");

Object.keys(_ExtrudeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ExtrudeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ExtrudeGeometry[key];
    }
  });
});

var _IcosahedronGeometry = require("./IcosahedronGeometry.js");

Object.keys(_IcosahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _IcosahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _IcosahedronGeometry[key];
    }
  });
});

var _LatheGeometry = require("./LatheGeometry.js");

Object.keys(_LatheGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _LatheGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LatheGeometry[key];
    }
  });
});

var _OctahedronGeometry = require("./OctahedronGeometry.js");

Object.keys(_OctahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _OctahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _OctahedronGeometry[key];
    }
  });
});

var _PlaneGeometry = require("./PlaneGeometry.js");

Object.keys(_PlaneGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PlaneGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PlaneGeometry[key];
    }
  });
});

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

Object.keys(_PolyhedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PolyhedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PolyhedronGeometry[key];
    }
  });
});

var _RingGeometry = require("./RingGeometry.js");

Object.keys(_RingGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _RingGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _RingGeometry[key];
    }
  });
});

var _ShapeGeometry = require("./ShapeGeometry.js");

Object.keys(_ShapeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ShapeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ShapeGeometry[key];
    }
  });
});

var _SphereGeometry = require("./SphereGeometry.js");

Object.keys(_SphereGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _SphereGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _SphereGeometry[key];
    }
  });
});

var _TetrahedronGeometry = require("./TetrahedronGeometry.js");

Object.keys(_TetrahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TetrahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TetrahedronGeometry[key];
    }
  });
});

var _TorusGeometry = require("./TorusGeometry.js");

Object.keys(_TorusGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TorusGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TorusGeometry[key];
    }
  });
});

var _TorusKnotGeometry = require("./TorusKnotGeometry.js");

Object.keys(_TorusKnotGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TorusKnotGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TorusKnotGeometry[key];
    }
  });
});

var _TubeGeometry = require("./TubeGeometry.js");

Object.keys(_TubeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TubeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TubeGeometry[key];
    }
  });
});

var _WireframeGeometry = require("./WireframeGeometry.js");

Object.keys(_WireframeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _WireframeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WireframeGeometry[key];
    }
  });
});

},{"./BoxGeometry.js":144,"./CapsuleGeometry.js":145,"./CircleGeometry.js":146,"./ConeGeometry.js":147,"./CylinderGeometry.js":148,"./DodecahedronGeometry.js":149,"./EdgesGeometry.js":150,"./ExtrudeGeometry.js":151,"./IcosahedronGeometry.js":153,"./LatheGeometry.js":154,"./OctahedronGeometry.js":155,"./PlaneGeometry.js":156,"./PolyhedronGeometry.js":157,"./RingGeometry.js":158,"./ShapeGeometry.js":159,"./SphereGeometry.js":160,"./TetrahedronGeometry.js":161,"./TorusGeometry.js":162,"./TorusKnotGeometry.js":163,"./TubeGeometry.js":164,"./WireframeGeometry.js":165}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IcosahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class IcosahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }

}

exports.IcosahedronGeometry = IcosahedronGeometry;

},{"./PolyhedronGeometry.js":157}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LatheGeometry = void 0;

var _BufferAttribute = require("../core/BufferAttribute.js");

var _BufferGeometry = require("../core/BufferGeometry.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class LatheGeometry extends _BufferGeometry.BufferGeometry {
  constructor(points = [new _Vector2.Vector2(0, -0.5), new _Vector2.Vector2(0.5, 0), new _Vector2.Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = []; // helper variables

    const inverseSegments = 1.0 / segments;
    const vertex = new _Vector.Vector3();
    const uv = new _Vector2.Vector2();
    const normal = new _Vector.Vector3();
    const curNormal = new _Vector.Vector3();
    const prevNormal = new _Vector.Vector3();
    let dx = 0;
    let dy = 0; // pre-compute normals for initial "meridian"

    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          // special handling for 1st vertex on path
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;

        case points.length - 1:
          // special handling for last Vertex on path
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;

        default:
          // default handling for all vertices in between
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    } // generate vertices, uvs and normals


    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);

      for (let j = 0; j <= points.length - 1; j++) {
        // vertex
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y); // normal

        const x = initNormals[3 * j + 0] * sin;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y, z);
      }
    } // indices


    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }

}

exports.LatheGeometry = LatheGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/MathUtils.js":168,"../math/Vector2.js":174,"../math/Vector3.js":175}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OctahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class OctahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }

}

exports.OctahedronGeometry = OctahedronGeometry;

},{"./PolyhedronGeometry.js":157}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlaneGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

class PlaneGeometry extends _BufferGeometry.BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY; //

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;

      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }

    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }

}

exports.PlaneGeometry = PlaneGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolyhedronGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class PolyhedronGeometry extends _BufferGeometry.BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    }; // default buffer data

    const vertexBuffer = [];
    const uvBuffer = []; // the subdivision creates the vertex buffer data

    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius); // finally, create the uv data

    generateUVs(); // build non-indexed geometry

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      this.computeVertexNormals(); // flat normals
    } else {
      this.normalizeNormals(); // smooth normals
    } // helper functions


    function subdivide(detail) {
      const a = new _Vector.Vector3();
      const b = new _Vector.Vector3();
      const c = new _Vector.Vector3(); // iterate over all faces and apply a subdivision with the given detail value

      for (let i = 0; i < indices.length; i += 3) {
        // get the vertices of the face
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c); // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

      const v = []; // construct all of the vertices for this subdivision

      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;

        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      } // construct all of the faces


      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);

          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      const vertex = new _Vector.Vector3(); // iterate over the entire buffer and apply the radius to each vertex

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }

    function generateUVs() {
      const vertex = new _Vector.Vector3();

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      // handle case when face straddles the seam, see #3269
      for (let i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      const a = new _Vector.Vector3();
      const b = new _Vector.Vector3();
      const c = new _Vector.Vector3();
      const centroid = new _Vector.Vector3();
      const uvA = new _Vector2.Vector2();
      const uvB = new _Vector2.Vector2();
      const uvC = new _Vector2.Vector2();

      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    } // Angle around the Y axis, counter-clockwise when looking from above.


    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    } // Angle above the XZ plane.


    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }

}

exports.PolyhedronGeometry = PolyhedronGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

class RingGeometry extends _BufferGeometry.BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // some helper variables

    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new _Vector2.Vector3();
    const uv = new _Vector.Vector2(); // generate vertices, normals and uvs

    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside
        const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);

      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }

}

exports.RingGeometry = RingGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Shape = require("../extras/core/Shape.js");

var _ShapeUtils = require("../extras/ShapeUtils.js");

var _Vector = require("../math/Vector2.js");

class ShapeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(shapes = new _Shape.Shape([new _Vector.Vector2(0, 0.5), new _Vector.Vector2(-0.5, -0.5), new _Vector.Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = 'ShapeGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    }; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let groupStart = 0;
    let groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // helper functions

    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes; // check direction of vertices

      if (_ShapeUtils.ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];

        if (_ShapeUtils.ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }

      const faces = _ShapeUtils.ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array


      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      } // vertices, normals, uvs


      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      } // indices


      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }

  static fromJSON(data, shapes) {
    const geometryShapes = [];

    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }

}

exports.ShapeGeometry = ShapeGeometry;

function toJSON(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/ShapeUtils.js":127,"../extras/core/Shape.js":132,"../math/Vector2.js":174}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SphereGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class SphereGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3(); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // generate vertices, normals and uvs

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments; // special case for the poles

      let uOffset = 0;

      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }

}

exports.SphereGeometry = SphereGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TetrahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class TetrahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }

}

exports.TetrahedronGeometry = TetrahedronGeometry;

},{"./PolyhedronGeometry.js":157}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TorusGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class TorusGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const center = new _Vector.Vector3();
    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3(); // generate vertices, normals and uvs

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        // indices
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }

}

exports.TorusGeometry = TorusGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TorusKnotGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class TorusKnotGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3();
    const P1 = new _Vector.Vector3();
    const P2 = new _Vector.Vector3();
    const B = new _Vector.Vector3();
    const T = new _Vector.Vector3();
    const N = new _Vector.Vector3(); // generate vertices, normals and uvs

    for (let i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
      const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for (let j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v); // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        // indices
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q / p * u;
      const cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }

}

exports.TorusKnotGeometry = TorusKnotGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TubeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var Curves = _interopRequireWildcard(require("../extras/curves/Curves.js"));

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class TubeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(path = new Curves['QuadraticBezierCurve3'](new _Vector2.Vector3(-1, -1, 0), new _Vector2.Vector3(-1, 1, 0), new _Vector2.Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals; // helper variables

    const vertex = new _Vector2.Vector3();
    const normal = new _Vector2.Vector3();
    const uv = new _Vector.Vector2();
    let P = new _Vector2.Vector3(); // buffer

    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = []; // create buffer data

    generateBufferData(); // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // functions

    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      } // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs(); // finally create faces

      generateIndices();
    }

    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path
      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

      const N = frames.normals[i];
      const B = frames.binormals[i]; // generate normals and vertices for the current segment

      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v); // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z); // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i; // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }

  static fromJSON(data) {
    // This only works for built-in curves (e.g. CatmullRomCurve3).
    // User defined curves or instances of CurvePath will not be deserialized.
    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
  }

}

exports.TubeGeometry = TubeGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/curves/Curves.js":137,"../math/Vector2.js":174,"../math/Vector3.js":175}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WireframeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class WireframeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = 'WireframeGeometry';
    this.parameters = {
      geometry: geometry
    };

    if (geometry !== null) {
      // buffer
      const vertices = [];
      const edges = new Set(); // helper variables

      const start = new _Vector.Vector3();
      const end = new _Vector.Vector3();

      if (geometry.index !== null) {
        // indexed BufferGeometry
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;

        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        } // create a data structure that contains all edges without duplicates


        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;

          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);

              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        // non-indexed BufferGeometry
        const position = geometry.attributes.position;

        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);

            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      } // build geometry


      this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

}

exports.WireframeGeometry = WireframeGeometry;

function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box3 = void 0;

var _Vector = require("./Vector3.js");

class Box3 {
  constructor(min = new _Vector.Vector3(+Infinity, +Infinity, +Infinity), max = new _Vector.Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    this.makeEmpty();

    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector.fromArray(array, i));
    }

    return this;
  }

  setFromBufferAttribute(attribute) {
    this.makeEmpty();

    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector.fromBufferAttribute(attribute, i));
    }

    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object, precise = false) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);

    if (object.boundingBox !== undefined) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }

      _box.copy(object.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    } else {
      const geometry = object.geometry;

      if (geometry !== undefined) {
        if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
          const position = geometry.attributes.position;

          for (let i = 0, l = position.count; i < l; i++) {
            _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }

          _box.copy(geometry.boundingBox);

          _box.applyMatrix4(object.matrixWorld);

          this.union(_box);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1, _v0);

    _f1.subVectors(_v2, _v1);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }

  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    return this.clampPoint(point, _vector).distanceTo(point);
  }

  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector).length() * 0.5;
    }

    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;
const _points = [/*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3()];

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new Box3(); // triangle centered vertices


const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3(); // triangle edge vectors


const _f0 = /*@__PURE__*/new _Vector.Vector3();

const _f1 = /*@__PURE__*/new _Vector.Vector3();

const _f2 = /*@__PURE__*/new _Vector.Vector3();

const _center = /*@__PURE__*/new _Vector.Vector3();

const _extents = /*@__PURE__*/new _Vector.Vector3();

const _triangleNormal = /*@__PURE__*/new _Vector.Vector3();

const _testAxis = /*@__PURE__*/new _Vector.Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the separating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }

  return true;
}

},{"./Vector3.js":175}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Euler = void 0;

var _Quaternion = require("./Quaternion.js");

var _Matrix = require("./Matrix4.js");

var _MathUtils = require("./MathUtils.js");

const _matrix = /*@__PURE__*/new _Matrix.Matrix4();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order = this._order, update = true) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    switch (order) {
      case 'XYZ':
        this._y = Math.asin((0, _MathUtils.clamp)(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-(0, _MathUtils.clamp)(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin((0, _MathUtils.clamp)(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-(0, _MathUtils.clamp)(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin((0, _MathUtils.clamp)(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-(0, _MathUtils.clamp)(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion.setFromEuler(this);

    return this.setFromQuaternion(_quaternion, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }

}

exports.Euler = Euler;
Euler.DEFAULT_ORDER = 'XYZ';

},{"./MathUtils.js":168,"./Matrix4.js":170,"./Quaternion.js":171}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RAD2DEG = exports.MathUtils = exports.DEG2RAD = void 0;
exports.ceilPowerOfTwo = ceilPowerOfTwo;
exports.clamp = clamp;
exports.damp = damp;
exports.degToRad = degToRad;
exports.denormalize = denormalize;
exports.euclideanModulo = euclideanModulo;
exports.floorPowerOfTwo = floorPowerOfTwo;
exports.generateUUID = generateUUID;
exports.inverseLerp = inverseLerp;
exports.isPowerOfTwo = isPowerOfTwo;
exports.lerp = lerp;
exports.mapLinear = mapLinear;
exports.normalize = normalize;
exports.pingpong = pingpong;
exports.radToDeg = radToDeg;
exports.randFloat = randFloat;
exports.randFloatSpread = randFloatSpread;
exports.randInt = randInt;
exports.seededRandom = seededRandom;
exports.setQuaternionFromProperEuler = setQuaternionFromProperEuler;
exports.smootherstep = smootherstep;
exports.smoothstep = smoothstep;
const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
exports.DEG2RAD = DEG2RAD;
const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

exports.RAD2DEG = RAD2DEG;

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.

  return uuid.toLowerCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s; // Mulberry32 generator

  let t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return value / 4294967295.0;

    case Uint16Array:
      return value / 65535.0;

    case Uint8Array:
      return value / 255.0;

    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);

    case Int16Array:
      return Math.max(value / 32767.0, -1.0);

    case Int8Array:
      return Math.max(value / 127.0, -1.0);

    default:
      throw new Error('Invalid component type.');
  }
}

function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return Math.round(value * 4294967295.0);

    case Uint16Array:
      return Math.round(value * 65535.0);

    case Uint8Array:
      return Math.round(value * 255.0);

    case Int32Array:
      return Math.round(value * 2147483647.0);

    case Int16Array:
      return Math.round(value * 32767.0);

    case Int8Array:
      return Math.round(value * 127.0);

    default:
      throw new Error('Invalid component type.');
  }
}

const MathUtils = {
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize
};
exports.MathUtils = MathUtils;

},{}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix3 = void 0;

class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  invert() {
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  } //


  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }

  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }

  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  } // for 2D Transforms


  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
    }

    return this;
  }

  makeRotation(theta) {
    // counterclockwise
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y) {
    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  } //


  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

}

exports.Matrix3 = Matrix3;

const _m3 = /*@__PURE__*/new Matrix3();

},{}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix4 = void 0;

var _constants = require("../constants.js");

var _Vector = require("./Vector3.js");

class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }

    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1.set(te[0], te[1], te[2]).length();

    const sy = _v1.set(te[4], te[5], te[6]).length();

    const sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _m1 = /*@__PURE__*/new Matrix4();

const _zero = /*@__PURE__*/new _Vector.Vector3(0, 0, 0);

const _one = /*@__PURE__*/new _Vector.Vector3(1, 1, 1);

const _x = /*@__PURE__*/new _Vector.Vector3();

const _y = /*@__PURE__*/new _Vector.Vector3();

const _z = /*@__PURE__*/new _Vector.Vector3();

},{"../constants.js":119,"./Vector3.js":175}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quaternion = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }

    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }

  random() {
    // Derived from http://planning.cs.uiuc.edu/node198.html
    // Note, this source uses w, x, y, z ordering,
    // so we swap the order below.
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  toJSON() {
    return this.toArray();
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }

}

exports.Quaternion = Quaternion;

},{"./MathUtils.js":168}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sphere = void 0;

var _Box = require("./Box3.js");

var _Vector = require("./Vector3.js");

const _box = /*@__PURE__*/new _Box.Box3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

class Sphere {
  constructor(center = new _Vector.Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }

    _v1.subVectors(point, this.center);

    const lengthSq = _v1.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      // calculate the minimal sphere
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1, delta / length);
      this.radius += delta;
    }

    return this;
  }

  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }

    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }

    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);

      this.expandByPoint(_v1.copy(sphere.center).add(_v2));
      this.expandByPoint(_v1.copy(sphere.center).sub(_v2));
    }

    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Sphere = Sphere;

},{"./Box3.js":166,"./Vector3.js":175}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Triangle = void 0;

var _Vector = require("./Vector3.js");

const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

const _v3 = /*@__PURE__*/new _Vector.Vector3();

const _vab = /*@__PURE__*/new _Vector.Vector3();

const _vac = /*@__PURE__*/new _Vector.Vector3();

const _vbc = /*@__PURE__*/new _Vector.Vector3();

const _vap = /*@__PURE__*/new _Vector.Vector3();

const _vbp = /*@__PURE__*/new _Vector.Vector3();

const _vcp = /*@__PURE__*/new _Vector.Vector3();

let warnedGetUV = false;

class Triangle {
  constructor(a = new _Vector.Vector3(), b = new _Vector.Vector3(), c = new _Vector.Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }

  static getNormal(a, b, c, target) {
    target.subVectors(c, b);

    _v0.subVectors(a, b);

    target.cross(_v0);
    const targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  } // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html


  static getBarycoord(point, a, b, c, target) {
    _v0.subVectors(c, a);

    _v1.subVectors(b, a);

    _v2.subVectors(point, a);

    const dot00 = _v0.dot(_v0);

    const dot01 = _v0.dot(_v1);

    const dot02 = _v0.dot(_v2);

    const dot11 = _v1.dot(_v1);

    const dot12 = _v1.dot(_v2);

    const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  }

  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }

  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    // @deprecated, r151
    if (warnedGetUV === false) {
      console.warn('THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().');
      warnedGetUV = true;
    }

    return this.getInterpolation(point, p1, p2, p3, uv1, uv2, uv3, target);
  }

  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.setScalar(0);
    target.addScaledVector(v1, _v3.x);
    target.addScaledVector(v2, _v3.y);
    target.addScaledVector(v3, _v3.z);
    return target;
  }

  static isFrontFacing(a, b, c, direction) {
    _v0.subVectors(c, b);

    _v1.subVectors(a, b); // strictly front facing


    return _v0.cross(_v1).dot(direction) < 0 ? true : false;
  }

  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }

  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }

  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }

  getArea() {
    _v0.subVectors(this.c, this.b);

    _v1.subVectors(this.a, this.b);

    return _v0.cross(_v1).length() * 0.5;
  }

  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }

  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }

  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }

  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }

  getUV(point, uv1, uv2, uv3, target) {
    // @deprecated, r151
    if (warnedGetUV === false) {
      console.warn('THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().');
      warnedGetUV = true;
    }

    return Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }

  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }

  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }

  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }

  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }

  closestPointToPoint(p, target) {
    const a = this.a,
          b = this.b,
          c = this.c;
    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    const d1 = _vab.dot(_vap);

    const d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    const d3 = _vab.dot(_vbp);

    const d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    const vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    const d5 = _vab.dot(_vcp);

    const d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    const vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    const va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    const denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }

  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }

}

exports.Triangle = Triangle;

},{"./Vector3.js":175}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector2 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }

}

exports.Vector2 = Vector2;

},{"./MathUtils.js":168}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector3 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

var _Quaternion = require("./Quaternion.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v) {
    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }

  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

  randomDirection() {
    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }

}

exports.Vector3 = Vector3;

const _vector = /*@__PURE__*/new Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

},{"./MathUtils.js":168,"./Quaternion.js":171}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMax = arrayMax;
exports.arrayMin = arrayMin;
exports.arrayNeedsUint32 = arrayNeedsUint32;
exports.createCanvasElement = createCanvasElement;
exports.createElementNS = createElementNS;
exports.getTypedArray = getTypedArray;
exports.warnOnce = warnOnce;

function arrayMin(array) {
  if (array.length === 0) return Infinity;
  let min = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] < min) min = array[i];
  }

  return min;
}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

function arrayNeedsUint32(array) {
  // assumes larger values usually on last
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }

  return false;
}

const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function createCanvasElement() {
  const canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}

const _cache = {};

function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}

},{}],177:[function(require,module,exports){
"use strict"

module.exports = triangulateCube

var perm = require("permutation-rank")
var sgn = require("permutation-parity")
var gamma = require("gamma")

function triangulateCube(dimension) {
  if(dimension < 0) {
    return [ ]
  }
  if(dimension === 0) {
    return [ [0] ]
  }
  var dfactorial = Math.round(gamma(dimension+1))|0
  var result = []
  for(var i=0; i<dfactorial; ++i) {
    var p = perm.unrank(dimension, i)
    var cell = [ 0 ]
    var v = 0
    for(var j=0; j<p.length; ++j) {
      v += (1<<p[j])
      cell.push(v)
    }
    if(sgn(p) < 1) {
      cell[0] = v
      cell[dimension] = 0
    }
    result.push(cell)
  }
  return result
}
},{"gamma":46,"permutation-parity":89,"permutation-rank":90}],178:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],179:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],180:[function(require,module,exports){
(function (global){(function (){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')
var Buffer = require('buffer').Buffer

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined'
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0])
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeBigUint64 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeBigInt64 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigUint64 = mallocBigUint64

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigInt64 = mallocBigInt64

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.BIGUINT64[i].length = 0
    POOL.BIGINT64[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"bit-twiddle":20,"buffer":30,"dup":43}],181:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],182:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],183:[function(require,module,exports){
"use strict"

module.exports = createText

var vectorizeText = require("./lib/vtext")
var defaultCanvas = null
var defaultContext = null

if(typeof document !== 'undefined') {
  defaultCanvas = document.createElement('canvas')
  defaultCanvas.width = 8192
  defaultCanvas.height = 1024
  defaultContext = defaultCanvas.getContext("2d")
}

function createText(str, options) {
  if((typeof options !== "object") || (options === null)) {
    options = {}
  }
  return vectorizeText(
    str,
    options.canvas || defaultCanvas,
    options.context || defaultContext,
    options)
}

},{"./lib/vtext":184}],184:[function(require,module,exports){
module.exports = vectorizeText
module.exports.processPixels = processPixels

var surfaceNets = require('surface-nets')
var ndarray = require('ndarray')
var simplify = require('simplify-planar-graph')
var cleanPSLG = require('clean-pslg')
var cdt2d = require('cdt2d')
var toPolygonCrappy = require('planar-graph-to-polyline')

var TAG_bold = "b"
var CHR_bold = 'b|'

var TAG_italic = "i"
var CHR_italic = 'i|'

var TAG_super = "sup"
var CHR_super0 = '+'
var CHR_super = '+1'

var TAG_sub = "sub"
var CHR_sub0 = '-'
var CHR_sub = '-1'

function parseTag(tag, TAG_CHR, str, map) {

  var opnTag =  "<"  + tag + ">"
  var clsTag =  "</" + tag + ">"

  var nOPN = opnTag.length
  var nCLS = clsTag.length

  var isRecursive = (TAG_CHR[0] === CHR_super0) ||
                    (TAG_CHR[0] === CHR_sub0);

  var a = 0
  var b = -nCLS
  while (a > -1) {
    a = str.indexOf(opnTag, a)
    if(a === -1) break

    b = str.indexOf(clsTag, a + nOPN)
    if(b === -1) break

    if(b <= a) break

    for(var i = a; i < b + nCLS; ++i){
      if((i < a + nOPN) || (i >= b)) {
        map[i] = null
        str = str.substr(0, i) + " " + str.substr(i + 1)
      } else {
        if(map[i] !== null) {
          var pos = map[i].indexOf(TAG_CHR[0])
          if(pos === -1) {
            map[i] += TAG_CHR
          } else { // i.e. to handle multiple sub/super-scripts
            if(isRecursive) {
              // i.e to increase the sub/sup number
              map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2)
            }
          }
        }
      }
    }

    var start = a + nOPN
    var remainingStr = str.substr(start, b - start)

    var c = remainingStr.indexOf(opnTag)
    if(c !== -1) a = c
    else a = b + nCLS
  }

  return map
}

function transformPositions(positions, options, size) {
  var align = options.textAlign || "start"
  var baseline = options.textBaseline || "alphabetic"

  var lo = [1<<30, 1<<30]
  var hi = [0,0]
  var n = positions.length
  for(var i=0; i<n; ++i) {
    var p = positions[i]
    for(var j=0; j<2; ++j) {
      lo[j] = Math.min(lo[j], p[j])|0
      hi[j] = Math.max(hi[j], p[j])|0
    }
  }

  var xShift = 0
  switch(align) {
    case "center":
      xShift = -0.5 * (lo[0] + hi[0])
    break

    case "right":
    case "end":
      xShift = -hi[0]
    break

    case "left":
    case "start":
      xShift = -lo[0]
    break

    default:
      throw new Error("vectorize-text: Unrecognized textAlign: '" + align + "'")
  }

  var yShift = 0
  switch(baseline) {
    case "hanging":
    case "top":
      yShift = -lo[1]
    break

    case "middle":
      yShift = -0.5 * (lo[1] + hi[1])
    break

    case "alphabetic":
    case "ideographic":
      yShift = -3 * size
    break

    case "bottom":
      yShift = -hi[1]
    break

    default:
      throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'")
  }

  var scale = 1.0 / size
  if("lineHeight" in options) {
    scale *= +options.lineHeight
  } else if("width" in options) {
    scale = options.width / (hi[0] - lo[0])
  } else if("height" in options) {
    scale = options.height / (hi[1] - lo[1])
  }

  return positions.map(function(p) {
    return [ scale * (p[0] + xShift), scale * (p[1] + yShift) ]
  })
}

function getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {

  rawString = rawString.replace(/\n/g, '') // don't accept \n in the input

  if(styletags.breaklines === true) {
    rawString = rawString.replace(/\<br\>/g, '\n') // replace <br> tags with \n in the string
  } else {
    rawString = rawString.replace(/\<br\>/g, ' ') // don't accept <br> tags in the input and replace with space in this case
  }

  var activeStyle = ""
  var map = []
  for(j = 0; j < rawString.length; ++j) {
    map[j] = activeStyle
  }

  if(styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map)
  if(styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map)
  if(styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map)
  if(styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map)

  var allStyles = []
  var plainText = ""
  for(j = 0; j < rawString.length; ++j) {
    if(map[j] !== null) {
      plainText += rawString[j]
      allStyles.push(map[j])
    }
  }

  var allTexts = plainText.split('\n')

  var numberOfLines = allTexts.length
  var lineHeight = Math.round(lineSpacing * fontSize)
  var offsetX = fontSize
  var offsetY = fontSize * 2
  var maxWidth = 0
  var minHeight = numberOfLines * lineHeight + offsetY

  if(canvas.height < minHeight) {
    canvas.height = minHeight
  }

  context.fillStyle = "#000"
  context.fillRect(0, 0, canvas.width, canvas.height)

  context.fillStyle = "#fff"
  var i, j, xPos, yPos, zPos
  var nDone = 0

  var buffer = ""
  function writeBuffer() {
    if(buffer !== "") {
      var delta = context.measureText(buffer).width

      context.fillText(buffer, offsetX + xPos, offsetY + yPos)
      xPos += delta
    }
  }

  function getTextFontSize() {
    return "" + Math.round(zPos) + "px ";
  }

  function changeStyle(oldStyle, newStyle) {
    var ctxFont = "" + context.font;

    if(styletags.subscripts === true) {
      var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);
      var newIndex_Sub = newStyle.indexOf(CHR_sub0);

      var oldSub = (oldIndex_Sub > -1) ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;
      var newSub = (newIndex_Sub > -1) ? parseInt(newStyle[1 + newIndex_Sub]) : 0;

      if(oldSub !== newSub) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSub - oldSub))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos += 0.25 * lineHeight * (newSub - oldSub);
    }

    if(styletags.superscripts === true) {
      var oldIndex_Super = oldStyle.indexOf(CHR_super0);
      var newIndex_Super = newStyle.indexOf(CHR_super0);

      var oldSuper = (oldIndex_Super > -1) ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;
      var newSuper = (newIndex_Super > -1) ? parseInt(newStyle[1 + newIndex_Super]) : 0;

      if(oldSuper !== newSuper) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSuper - oldSuper))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos -= 0.25 * lineHeight * (newSuper - oldSuper);
    }

    if(styletags.bolds === true) {
      var wasBold = (oldStyle.indexOf(CHR_bold) > -1)
      var is_Bold = (newStyle.indexOf(CHR_bold) > -1)

      if(!wasBold && is_Bold) {
        if(wasItalic) {
          ctxFont = ctxFont.replace("italic ", "italic bold ")
        } else {
          ctxFont = "bold " + ctxFont
        }
      }
      if(wasBold && !is_Bold) {
        ctxFont = ctxFont.replace("bold ", '')
      }
    }

    if(styletags.italics === true) {
      var wasItalic = (oldStyle.indexOf(CHR_italic) > -1)
      var is_Italic = (newStyle.indexOf(CHR_italic) > -1)

      if(!wasItalic && is_Italic) {
        ctxFont = "italic " + ctxFont
      }
      if(wasItalic && !is_Italic) {
        ctxFont = ctxFont.replace("italic ", '')
      }
    }
    context.font = ctxFont
  }

  for(i = 0; i < numberOfLines; ++i) {
    var txt = allTexts[i] + '\n'
    xPos = 0
    yPos = i * lineHeight
    zPos = fontSize

    buffer = ""
    
    for(j = 0; j < txt.length; ++j) {
      var style = (j + nDone < allStyles.length) ? allStyles[j + nDone] : allStyles[allStyles.length - 1]
      if(activeStyle === style) {
        buffer += txt[j]
      } else {
        writeBuffer()
        buffer = txt[j]

        if(style !== undefined) {
          changeStyle(activeStyle, style)
          activeStyle = style
        }
      }
    }
    writeBuffer()

    nDone += txt.length

    var width = Math.round(xPos + 2 * offsetX) | 0
    if(maxWidth < width) maxWidth = width
  }

  //Cut pixels from image
  var xCut = maxWidth
  var yCut = offsetY + lineHeight * numberOfLines
  var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4])
  return pixels.pick(-1, -1, 0).transpose(1, 0)
}

function getContour(pixels, doSimplify) {
  var contour = surfaceNets(pixels, 128)
  if(doSimplify) {
    return simplify(contour.cells, contour.positions, 0.25)
  }
  return {
    edges: contour.cells,
    positions: contour.positions
  }
}

function processPixelsImpl(pixels, options, size, simplify) {
  //Extract contour
  var contour = getContour(pixels, simplify)

  //Apply warp to positions
  var positions = transformPositions(contour.positions, options, size)
  var edges     = contour.edges
  var flip = "ccw" === options.orientation

  //Clean up the PSLG, resolve self intersections, etc.
  cleanPSLG(positions, edges)

  //If triangulate flag passed, triangulate the result
  if(options.polygons || options.polygon || options.polyline) {
    var result = toPolygonCrappy(edges, positions)
    var nresult = new Array(result.length)
    for(var i=0; i<result.length; ++i) {
      var loops = result[i]
      var nloops = new Array(loops.length)
      for(var j=0; j<loops.length; ++j) {
        var loop = loops[j]
        var nloop = new Array(loop.length)
        for(var k=0; k<loop.length; ++k) {
          nloop[k] = positions[loop[k]].slice()
        }
        if(flip) {
          nloop.reverse()
        }
        nloops[j] = nloop
      }
      nresult[i] = nloops
    }
    return nresult
  } else if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: cdt2d(positions, edges, {
        delaunay: false,
        exterior: false,
        interior: true
      }),
      positions: positions
    }
  } else {
    return {
      edges:     edges,
      positions: positions
    }
  }
}

function processPixels(pixels, options, size) {
  try {
    return processPixelsImpl(pixels, options, size, true)
  } catch(e) {}
  try {
    return processPixelsImpl(pixels, options, size, false)
  } catch(e) {}
  if(options.polygons || options.polyline || options.polygon) {
    return []
  }
  if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: [],
      positions: []
    }
  }
  return {
    edges: [],
    positions: []
  }
}

function vectorizeText(str, canvas, context, options) {
  var size = 64
  var lineSpacing = 1.25
  var styletags = {
    breaklines: false,
    bolds: false,
    italics: false,
    subscripts: false,
    superscripts: false
  }

  if(options) {

    if(options.size &&
       options.size > 0) size =
       options.size

    if(options.lineSpacing &&
       options.lineSpacing > 0) lineSpacing =
       options.lineSpacing

    if(options.styletags &&
       options.styletags.breaklines) styletags.breaklines =
       options.styletags.breaklines ? true : false

    if(options.styletags &&
       options.styletags.bolds) styletags.bolds =
       options.styletags.bolds ? true : false

    if(options.styletags &&
       options.styletags.italics) styletags.italics =
       options.styletags.italics ? true : false

    if(options.styletags &&
       options.styletags.subscripts) styletags.subscripts =
       options.styletags.subscripts ? true : false

    if(options.styletags &&
       options.styletags.superscripts) styletags.superscripts =
       options.styletags.superscripts ? true : false
  }

  context.font = [
    options.fontStyle,
    options.fontVariant,
    options.fontWeight,
    size + "px",
    options.font
  ].filter(function(d) {return d}).join(" ")
  context.textAlign = "start"
  context.textBaseline = "alphabetic"
  context.direction = "ltr"

  var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags)

  return processPixels(pixels, options, size)
}

},{"cdt2d":31,"clean-pslg":36,"ndarray":86,"planar-graph-to-polyline":93,"simplify-planar-graph":115,"surface-nets":118}],185:[function(require,module,exports){
module.exports = require('cwise-compiler')({
    args: ['array', {
        offset: [1],
        array: 0
    }, 'scalar', 'scalar', 'index'],
    pre: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    post: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    body: {
        "body": "{\n        var _inline_1_da = _inline_1_arg0_ - _inline_1_arg3_\n        var _inline_1_db = _inline_1_arg1_ - _inline_1_arg3_\n        if((_inline_1_da >= 0) !== (_inline_1_db >= 0)) {\n          _inline_1_arg2_.push(_inline_1_arg4_[0] + 0.5 + 0.5 * (_inline_1_da + _inline_1_db) / (_inline_1_da - _inline_1_db))\n        }\n      }",
        "args": [{
            "name": "_inline_1_arg0_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg1_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg2_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg3_",
            "lvalue": false,
            "rvalue": true,
            "count": 2
        }, {
            "name": "_inline_1_arg4_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }],
        "thisVars": [],
        "localVars": ["_inline_1_da", "_inline_1_db"]
    },
    funcName: 'zeroCrossings'
})

},{"cwise-compiler":39}],186:[function(require,module,exports){
"use strict"

module.exports = findZeroCrossings

var core = require("./lib/zc-core")

function findZeroCrossings(array, level) {
  var cross = []
  level = +level || 0.0
  core(array.hi(array.shape[0]-1), cross, level)
  return cross
}
},{"./lib/zc-core":185}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sandbox = _interopRequireDefault(require("./lib/sandbox.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// handles code evaluation and attaching relevant objects to global and evaluation contexts
class EvalSandbox {
  constructor(parent, makeGlobal, userProps = []) {
    this.makeGlobal = makeGlobal;
    this.sandbox = (0, _sandbox.default)(parent);
    this.parent = parent;
    var properties = Object.keys(parent);
    properties.forEach(property => this.add(property));
    this.userProps = userProps;
  }

  add(name) {
    if (this.makeGlobal) window[name] = this.parent[name]; // this.sandbox.addToContext(name, `parent.${name}`)
  } // sets on window as well as synth object if global (not needed for objects, which can be set directly)


  set(property, value) {
    if (this.makeGlobal) {
      window[property] = value;
    }

    this.parent[property] = value;
  }

  tick() {
    if (this.makeGlobal) {
      this.userProps.forEach(property => {
        this.parent[property] = window[property];
      }); //  this.parent.speed = window.speed
    } else {}
  }

  eval(code) {
    this.sandbox.eval(code);
  }

}

var _default = EvalSandbox;
exports.default = _default;

},{"./lib/array-utils.js":199,"./lib/sandbox.js":204}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatArguments;

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [WIP] how to treat different dimensions (?)
const DEFAULT_CONVERSIONS = {
  float: {
    'vec4': {
      name: 'sum',
      args: [[1, 1, 1, 1]]
    },
    'vec2': {
      name: 'sum',
      args: [[1, 1]]
    }
  }
};

function fillArrayWithDefaults(arr, len) {
  // fill the array with default values if it's too short
  while (arr.length < len) {
    if (arr.length === 3) {
      // push a 1 as the default for .a in vec4
      arr.push(1.0);
    } else {
      arr.push(0.0);
    }
  }

  return arr.slice(0, len);
}

const ensure_decimal_dot = val => {
  val = val.toString();

  if (val.indexOf('.') < 0) {
    val += '.';
  }

  return val;
};

function formatArguments(transform, startIndex, synthContext) {
  const defaultArgs = transform.transform.inputs;
  const userArgs = transform.userArgs;
  const {
    generators
  } = transform.synth;
  const {
    src
  } = generators; // depends on synth having src() function

  return defaultArgs.map((input, index) => {
    const typedArg = {
      value: input.default,
      type: input.type,
      //
      isUniform: false,
      name: input.name,
      vecLen: 0 //  generateGlsl: null // function for creating glsl

    };
    if (typedArg.type === 'float') typedArg.value = ensure_decimal_dot(input.default);

    if (input.type.startsWith('vec')) {
      try {
        typedArg.vecLen = Number.parseInt(input.type.substr(3));
      } catch (e) {
        console.log(`Error determining length of vector input type ${input.type} (${input.name})`);
      }
    } // if user has input something for this argument


    if (userArgs.length > index) {
      typedArg.value = userArgs[index];

      if (typeof typedArg.value === 'function' && typedArg.value.name !== 'reglTexture2D' && typedArg.value.name !== 'reglFramebuffer') {
        typedArg.value = getFunctionValue(typedArg.value, input);
        typedArg.isUniform = true;
      } else if (typedArg.value.constructor === Array) {
        typedArg.value = getArrayValue(typedArg.value, input, typedArg.vecLen);
        typedArg.isUniform = true; // }
      }
    }

    if (startIndex < 0) {} else {
      if (typedArg.value && typedArg.value.transforms) {
        const final_transform = typedArg.value.transforms[typedArg.value.transforms.length - 1];

        if (final_transform.transform.glsl_return_type !== input.type) {
          const defaults = DEFAULT_CONVERSIONS[input.type];

          if (typeof defaults !== 'undefined') {
            const default_def = defaults[final_transform.transform.glsl_return_type];

            if (typeof default_def !== 'undefined') {
              const {
                name,
                args
              } = default_def;
              typedArg.value = typedArg.value[name](...args);
            }
          }
        }

        typedArg.isUniform = false;
      } else if (typedArg.type === 'float' && typeof typedArg.value === 'number') {
        typedArg.value = ensure_decimal_dot(typedArg.value);
      } else if (typedArg.type.startsWith('vec') && typeof typedArg.value !== 'function' && !typedArg.value.getTexture) {
        typedArg.isUniform = false;

        if (Array.isArray(typedArg.value) || typedArg.value instanceof Float32Array || typedArg.value instanceof Uint8Array) {
          // todo: accept smaller arrays?
          typedArg.value = `${typedArg.type}(${typedArg.value.map(ensure_decimal_dot).join(', ')})`;
        } else if (typeof typedArg.value === 'number') {
          const length = parseInt(typedArg.type.substr(-1));
          const arr = Array(length).fill(typedArg.value);
          typedArg.value = `${typedArg.type}(${arr.map(ensure_decimal_dot).join(', ')})`;
        }
      } else if (input.type === 'sampler2D') {
        // typedArg.tex = typedArg.value
        var x = typedArg.value;
        typedArg.value = x.getTexture ? () => x.getTexture() : x;
        typedArg.isUniform = true;
      } else {
        // if passing in a texture reference, when function asks for vec4, convert to vec4
        if (typedArg.value.getTexture || typedArg.value.name === 'reglTexture2D') {
          var x1 = typedArg.value;

          if (input.type === 'vec4') {
            typedArg.value = src(x1);
          } else {
            let getter = _types.getLookup[input.type];
            typedArg.value = src(x1)[getter];
          }

          typedArg.isUniform = false;
        }
      } // add tp uniform array if is a function that will pass in a different value on each render frame,
      // or a texture/ external source


      if (input.isUniform) typedArg.isUniform = input.isUniform;

      if (typedArg.isUniform) {
        typedArg.name += startIndex; //  shaderParams.uniforms.push(typedArg)
      }
    }

    return typedArg;
  });
}

function getFunctionValue(value, input) {
  // if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //    typedArg.value = (context, props, batchId) => (fillArrayWithDefaults(userArgs[index](props), typedArg.vecLen))
  // } else {
  return (context, props, batchId) => {
    try {
      const val = value(props);

      if (typeof val === 'number') {
        return val;
      } else {
        console.warn('function does not return a number', value);
      }

      return input.default;
    } catch (e) {
      console.warn('ERROR', e);
      return input.default;
    }
  }; //  }
}

function getArrayValue(value, input, vecLen = 0) {
  //   if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //     typedArg.isUniform = true
  //     typedArg.value = fillArrayWithDefaults(typedArg.value, typedArg.vecLen)
  //  } else {
  //  console.log("is Array")
  // filter out values that are not a number
  // const filteredArray = userArgs[index].filter((val) => typeof val === 'number')
  // typedArg.value = (context, props, batchId) => arrayUtils.getValue(filteredArray)(props)
  if (vecLen) {
    return (context, props, batchId) => {
      const values = Array(vecLen);

      for (let i = 0; i < vecLen; i++) {
        const v = value[i];
        const defaultValue = input.default ? input.default.constructor === Array ? input.default[i] : input.default : 0;

        if (typeof v === 'function') {
          values[i] = getFunctionValue(v, {
            default: defaultValue
          })(context, props, batchId);
        } else if (Array.isArray(v)) {
          values[i] = _arrayUtils.default.getValue(v)(props);
        } else if (typeof v !== 'undefined') {
          values[i] = v;
        } else {
          values[i] = defaultValue;
        }
      }

      return values;
    };
  } else {
    return (context, props, batchId) => _arrayUtils.default.getValue(value)(props);
  }
}

},{"./lib/array-utils.js":199,"./types.js":209}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatArguments = _interopRequireDefault(require("./format-arguments.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// converts a tree of javascript functions to a shader
function _default(source) {
  return generateParams(createParams(), source, source.transforms);
}

function createParams(options = {}) {
  return Object.assign({
    uniforms: [],
    // list of uniforms used in shader
    glslFunctions: [],
    // list of functions used in shader
    fragColor: '',
    position: ''
  }, options);
}

function generateParams(shaderParams, source, transforms) {
  if (!shaderParams.fragColor) {
    shaderParams.fragColor = generateGlsl(source, transforms, shaderParams, _types.typeLookup['src'].returnType)('st', 'vec4', 1.0);
  }

  if (!shaderParams.position && !shaderParams.combine) {
    shaderParams.position = generateGlsl(source, transforms.filter(tr => {
      return tr.transform.type !== 'combine' && tr.transform.type !== 'clear';
    }), shaderParams, _types.typeLookup['src'].returnType)('st', 'vec4', 1.0);
  } // remove uniforms with duplicate names


  if (shaderParams.uniforms) {
    let uniforms = {};
    shaderParams.uniforms.forEach(uniform => uniforms[uniform.name] = uniform);
    shaderParams.uniforms = Object.values(uniforms);
  }

  return shaderParams;
} // recursive function for generating shader string from object containing functions and user arguments. Order of functions in string depends on type of function
// to do: improve variable names


function generateGlsl(source, transforms, shaderParams) {
  // transform function that outputs a shader string corresponding to gl_FragColor
  const empty = () => '';

  var fragColor = empty;
  transforms.map((transform, i) => {
    if (transform.transform.type === 'vert' && !source.geometry) {
      source.setGeometry(transform.userArgs[0]);
      transform.userArgs = transform.userArgs.slice(1);
    }

    var inputs = (0, _formatArguments.default)(transform, shaderParams.uniforms.length);

    if (transform.transform.type === 'clear') {
      source.passes.unshift({
        clear: transform.transform.name,
        userArgs: inputs.map(i => i.value)
      });
      return;
    }

    inputs.forEach(input => {
      if (input.isUniform) shaderParams.uniforms.push(input);
    }); // add new glsl function to running list of functions

    if (!contains(transform, shaderParams.glslFunctions)) shaderParams.glslFunctions.push(transform); // current function for generating frag color shader code

    var f0 = fragColor;

    if (transform.transform.type === 'src' || transform.transform.type === 'vert') {
      fragColor = (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'coord') {
      fragColor = f0 === empty ? (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}` : (uv, returnType, alpha) => `${f0(`${shaderString(uv, transform, inputs, shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else if (transform.transform.type === 'color') {
      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}`, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combine') {
      // combining two generated shader strings (i.e. for blend, mult, add funtions)
      if (source.transforms[0].transform.vert || inputs[0].value && inputs[0].value.transforms && inputs[0].value.transforms[0].transform.vert) {
        const params = Object.assign({}, shaderParams, {
          fragColor: fragColor('st', 'vec4', 1.0) || 'vec4(0)'
        });
        Object.assign(shaderParams, createParams({
          glslFunctions: [transform],
          combine: true
        }));
        const trans = source.transforms.slice(0, source.transforms.indexOf(transform));
        source.passes.unshift(source.createPass(generateParams(params, source, trans), {
          framebuffer: source.output.temp[0]
        }));
        const temp0 = src(source.output.temp[0]);

        f0 = (uv, returnType, alpha) => `${generateGlsl(temp0, temp0.transforms, shaderParams)(uv, returnType, alpha)}`;
      }

      var f1;

      if (inputs[0].value && inputs[0].value.transforms) {
        if (inputs[0].value.transforms[0].transform.vert || source.transforms[0].transform.vert) {
          inputs[0].value.output = source.output;
          source.passes.unshift(...inputs[0].value.glsl({
            framebuffer: source.output.temp[1]
          }));
          const temp1 = src(source.output.temp[1]);

          f1 = (uv, returnType, alpha) => `${generateGlsl(temp1, temp1.transforms, shaderParams)(uv, returnType, alpha)}`;
        } else {
          f1 = (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}`;
        }
      } else {
        f1 = inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;
      }

      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combineCoord') {
      // combining two generated shader strings (i.e. for modulate functions)
      var f1 = inputs[0].value && inputs[0].value.transforms ? (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}` : inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;

      fragColor = (uv, returnType, alpha) => `${f0(`${shaderString(`${uv}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else {
      console.warn('no support for type: ' + transform.transform.type);
    }
  });

  if (source.getter) {
    var f2 = fragColor;

    fragColor = (uv, returnType, alpha) => (0, _types.castType)(f2(uv, returnType, alpha) + `.${source.getter}`, _types.getTypeLookup[source.getter], returnType, 1.0);
  }

  return fragColor;
} // assembles a shader string containing the arguments and the function name, i.e. 'osc(uv, frequency)'


function shaderString(uv, transform, inputs, shaderParams, returnType, alpha = 0.0) {
  const str = inputs.map(input => {
    if (input.isUniform) {
      return input.name;
    } else if (input.value && input.value.transforms) {
      // this by definition needs to be a generator, hence we start with 'st' as the initial value for generating the glsl fragment
      if (!input.value.getter && _types.typeLookup[input.value.transforms[0].transform.type] !== input.type) {
        // todo: add getter only if input.type is larger
        input.value.getter = _types.getLookup[input.type];
      }

      return `${generateGlsl(input.value, input.value.transforms, shaderParams)('st', input.type)}`;
    }

    return input.value;
  }).reduce((p, c) => `${p}, ${c}`, '');
  var func = `${transform.transform.glslName}(${uv}${str})`;
  return (0, _types.castType)(func, _types.typeLookup[transform.transform.type].returnType, returnType, alpha);
} // check whether array


function contains(object, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (object.name == arr[i].name) return true;
  }

  return false;
}

},{"./format-arguments.js":188,"./types.js":209}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

var _glslFunctions = _interopRequireDefault(require("./glsl/glsl-functions.js"));

var _vertFunctions = _interopRequireDefault(require("./glsl/vert-functions.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GeneratorFactory {
  constructor({
    defaultUniforms,
    defaultOutput,
    extendTransforms = [],
    changeListener = () => {}
  } = {}) {
    this.defaultOutput = defaultOutput;
    this.defaultUniforms = defaultUniforms;
    this.changeListener = changeListener;
    this.extendTransforms = extendTransforms;
    this.generators = {};
    this.utils = {};
    this.init();
  }

  init() {
    const functions = (0, _glslFunctions.default)();
    this.glslTransforms = {};
    this.generators = Object.entries(this.generators).reduce((prev, [method, transform]) => {
      this.changeListener({
        type: 'remove',
        synth: this,
        method
      });
      return prev;
    }, {});

    this.sourceClass = (() => {
      return class extends _glslSource.default {};
    })(); // add user definied transforms


    if (Array.isArray(this.extendTransforms)) {
      functions.concat(this.extendTransforms);
    } else if (typeof this.extendTransforms === 'object' && this.extendTransforms.type) {
      functions.push(this.extendTransforms);
    }

    functions.map(transform => this.setFunction(transform));
    const functions2 = (0, _vertFunctions.default)(this.generators); // sandbox is not ready at this moment yet

    functions2.map(transform => this.setFunction(transform));
  }

  _addMethod(method, transform) {
    const self = this;
    this.glslTransforms[method] = transform;
    let retval = undefined;

    if (['src', 'coord', 'clear', 'vert'].indexOf(transform.type) > -1) {
      const func = (...args) => new this.sourceClass({
        name: method,
        transform: transform,
        userArgs: args,
        defaultOutput: this.defaultOutput,
        defaultUniforms: this.defaultUniforms,
        synth: self,
        utils: this.utils
      });

      this.generators[method] = func;
      this.changeListener({
        type: 'add',
        synth: this,
        method
      });
      retval = func;
    }

    this.sourceClass.prototype[method] = function (...args) {
      const prevTransform = this.transforms[this.transforms.length - 1].transform;

      if (prevTransform.type === 'clear' || transform.type !== 'src' && transform.type !== 'vert') {
        this.transforms.push({
          name: method,
          transform: transform,
          userArgs: args,
          synth: self
        });
      } else {
        console.error(`transform ${transform.name} not allowed after ${prevTransform.name}`);
      }

      return this;
    };

    return retval;
  }

  setFunction(obj) {
    // todo: remove utils and instead manage function dependencies
    if (obj.type === 'util') this.utils[obj.name] = obj;
    var processedGlsl = processFunction(obj);
    if (processedGlsl) this._addMethod(obj.name, processedGlsl);
  }

} // expects glsl of format
// {
//   name: 'osc', // name that will be used to access function as well as within glsl
//   type: 'src', // can be src: vec4(vec2 _st), coord: vec2(vec2 _st), color: vec4(vec4 _c0), combine: vec4(vec4 _c0, vec4 _c1), combineCoord: vec2(vec2 _st, vec4 _c0)
//   inputs: [
//     {
//       name: 'freq',
//       type: 'float', // 'float'   //, 'texture', 'vec4'
//       default: 0.2
//     },
//     {
//           name: 'sync',
//           type: 'float',
//           default: 0.1
//         },
//         {
//           name: 'offset',
//           type: 'float',
//           default: 0.0
//         }
//   ],
//  glsl: `
//    vec2 st = _st;
//    float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//    float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//    float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//    return vec4(r, g, b, 1.0);
// `
// }
// // generates glsl function:
// `vec4 osc(vec2 _st, float freq, float sync, float offset){
//  vec2 st = _st;
//  float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//  float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//  float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//  return vec4(r, g, b, 1.0);
// }`


function processFunction(obj) {
  obj.glslName || (obj.glslName = obj.name);
  if (obj.type === 'clear') return obj;else if (obj.type === 'util') {
    return processGlsl(obj, obj.returnType);
  }
  let t = _types.typeLookup[obj.type];

  if (t) {
    return processGlsl(obj, t.returnType, t.args);
  } else {
    console.warn(`type ${obj.type} not recognized`, obj);
  }
}

function processGlsl(obj, returnType, args = []) {
  let baseArgs = args.map(arg => arg).join(", ");
  let customArgs = (obj.inputs || (obj.inputs = [])).map(input => `${input.type} ${input.name}`).join(', ');
  let allArgs = `${baseArgs}${customArgs.length > 0 ? ', ' + customArgs : ''}`;
  const func = `${returnType || ''} ${obj.glslName}(${allArgs}`;

  const fixOrWrap = glsl => {
    if (glsl.indexOf(func) === -1) {
      if (glsl.indexOf(`${returnType} main(${allArgs}`) > -1) {
        return glsl.replace(`${returnType} main(${allArgs}`, func);
      } else {
        if (obj.primitive) {
          let primitiveFn = obj.primitive.split(" ").join("");

          if (glsl.indexOf(primitiveFn) > -1) {
            return glsl.replace(`${returnType} ${primitiveFn}(${allArgs}`, func);
          }
        }

        if (returnType) {
          return `
  ${func}) {
      ${glsl}
  }
`;
        }
      }
    }

    return glsl;
  };

  obj.glsl = fixOrWrap(obj.glsl);

  if (obj.vert) {
    obj.vert = fixOrWrap(obj.vert);
  } // add extra input to beginning for backward combatibility @todo update compiler so this is no longer necessary


  if (obj.type === 'combine' || obj.type === 'combineCoord') obj.inputs.unshift({
    name: 'color',
    type: 'vec4'
  });
  return Object.assign({}, obj, {
    returnType
  });
}

var _default = GeneratorFactory;
exports.default = _default;

},{"./glsl-source.js":191,"./glsl/glsl-functions.js":193,"./glsl/vert-functions.js":195,"./types.js":209}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _generateGlsl = _interopRequireDefault(require("./generate-glsl.js"));

var _utilityFunctions = _interopRequireDefault(require("./glsl/utility-functions.js"));

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GlslSource = function (obj) {
  this.transforms = [];
  this.transforms.push(obj);
  this.defaultOutput = obj.defaultOutput;
  this.output = null;
  this.synth = obj.synth;
  this.type = 'GlslSource';
  this.defaultUniforms = obj.defaultUniforms;
  this.utils = Object.assign({}, _utilityFunctions.default, obj.utils);
  this.blendMode = typeof obj.transform.blendMode !== 'undefined' ? obj.transform.blendMode : false;
  this.lineWidth = obj.transform.lineWidth || 1;
  this._viewport = {};
  return this;
};

GlslSource.prototype.addTransform = function (obj) {
  this.transforms.push(obj);
};

GlslSource.prototype.out = function (_output) {
  var output = _output || this.defaultOutput;
  this.output = output;
  var glsl = this.glsl();
  this.synth.currentFunctions = [];
  if (output) try {
    output.render(glsl);
  } catch (error) {
    console.log('shader could not compile', error);
  }
  return this;
};

GlslSource.prototype.tex = function (_output) {
  if (!this.output) {
    this.out(_output);
  }

  return this.output.renderTexture();
};

GlslSource.prototype.glsl = function (options = {}) {
  this.passes = [];
  this.passes.push(this.createPass((0, _generateGlsl.default)(this), options));
  return this.passes;
};

GlslSource.prototype.getInfo = function () {
  if (this.transforms.length > 0) {
    var shaderInfo = (0, _generateGlsl.default)(this);
    var uniforms = {};
    shaderInfo.uniforms.forEach(uniform => {
      uniforms[uniform.name] = uniform.value;
    });
    return {
      shaderInfo,
      utilityGlsl: this.utils,
      // todo: differs from compile
      vert: this.transforms[0].transform.vert,
      // todo: differs from compile
      attributes: this.transforms[0].transform.attributes,
      // todo: differs from compile
      attributesCount: this.transforms[0].transform.attributesCount,
      primitive: this.transforms[0].transform.primitive,
      uniforms: Object.assign({}, this.defaultUniforms, uniforms)
    };
  }
};

GlslSource.prototype.createPass = function (shaderInfo, options = {}) {
  var uniforms = {};
  shaderInfo.uniforms.forEach(uniform => {
    uniforms[uniform.name] = uniform.value;
  });

  if (shaderInfo.combine) {
    return {
      vert: GlslSource.compileVert(this.defaultOutput.precision, false, {
        glslName: 'combine'
      }, shaderInfo),
      userArgs: this.transforms[0].userArgs,
      // todo: fix or delete
      // blendMode: this.blendMode,
      lineWidth: this.lineWidth,
      frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
      uniforms: Object.assign({}, this.defaultUniforms, uniforms),
      viewport: this._viewport
    };
  }

  const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
  return Object.assign({
    vert: GlslSource.compileVert(this.defaultOutput.precision, true, vertTransform.transform, shaderInfo, this.utils),
    primitive: vertTransform.transform.primitive,
    userArgs: vertTransform.userArgs,
    geometry: this.geometry,
    blendMode: this.blendMode,
    lineWidth: this.lineWidth,
    frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
    uniforms: Object.assign({}, this.defaultUniforms, uniforms),
    viewport: this._viewport
  }, options);
};

GlslSource.compileHeader = function (precision, uniforms = {}, utils = {}) {
  return `
  precision ${precision} float;
  ${Object.values(uniforms).map(uniform => {
    let type = uniform.type;

    switch (uniform.type) {
      case 'texture':
        type = 'sampler2D';
        break;
    }

    return `
      uniform ${type} ${uniform.name};`;
  }).join('')}
  uniform float time;
  uniform vec2 resolution;
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  uniform sampler2D prevBuffer;
  
  ${Object.values(utils).map(transform => {
    //  console.log(transform.glsl)
    return `
            ${transform.glsl}
          `;
  }).join('')}
  `;
};

GlslSource.compileFrag = function (precision, shaderInfo, utils) {
  const header = this.compileHeader(precision, shaderInfo.uniforms, utils);
  return header + `
  
  ${shaderInfo.glslFunctions.map(transform => {
    return `
            ${transform.transform.glsl}
          `;
  }).join('')}

  void main () {
    vec4 c = vec4(1, 0, 0, 1);
    //vec2 st = gl_FragCoord.xy/resolution.xy;
    vec2 st = vuv;
    gl_FragColor = ${shaderInfo.fragColor};
  }
  `;
};

GlslSource.compileVert = function (precision, useCamera, transform, shaderInfo, utils) {
  const useUV = typeof transform.useUV !== 'undefined' ? transform.useUV : !transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1;
  const useNormal = typeof transform.useNormal !== 'undefined' ? transform.useNormal : transform.type === 'vert' && (!transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1);
  let vertHeader = `
  precision ${precision} float;
  uniform mat4 projection, view;
  attribute vec3 position;
  ${useUV ? 'attribute vec2 uv;' : ''}
  ${useNormal ? 'attribute vec3 normal;' : ''}
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  `;
  let vertFn = `
  void ${transform.glslName}() {
    vposition = position;
    gl_Position = ${useCamera ? 'projection * view * ' : ''}vec4(position, 1.0);
  } 
  `;
  let vertCall = `${transform.glslName}();`;

  if (transform.vert) {
    vertHeader = this.compileHeader(precision, shaderInfo.uniforms, utils) + `
    uniform mat4 projection, view;
    attribute vec3 position;
    ${useUV ? 'attribute vec2 uv;' : ''}
    ${useNormal ? 'attribute vec3 normal;' : ''}
    
    ${shaderInfo.glslFunctions.map(trans => {
      if (trans.transform.name !== transform.name) {
        return `
            ${trans.transform.glsl}
          `;
      }
    }).join('')}
    `;
    vertFn = transform.vert;
    vertCall = `
    ${useUV ? 'vec2 st = uv;' : 'vec2 st = position.xy;'}
    vposition = ${shaderInfo.position};
    gl_Position = projection * view * vposition;
    `;
  }

  return vertHeader + `
    
  ${vertFn}

  void main () {
    ${useUV ? 'vuv = uv;' : ''}
    ${useNormal ? 'vnormal = normal;' : ''}
    ${vertCall}
  }`;
}; // todo: make hydra-synth function


GlslSource.prototype.setBlend = function (blendMode = true) {
  this.blendMode = blendMode;
  return this;
};

GlslSource.prototype.setLineWidth = function (lineWidth) {
  this.lineWidth = lineWidth;
  return this;
};

GlslSource.prototype.setGeometry = function (input) {
  const isGeometry = v => v.isBufferGeometry || v.positions && v.edges;

  const isClass = v => typeof v === 'function' && /^\s*class\s+/.test(v.toString());

  if (!input) input = [];

  if (!isGeometry(input)) {
    const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
    if (!Array.isArray(input)) input = [input];

    if (isClass(vertTransform.transform.geometry)) {
      if (vertTransform.transform.geometry === GridGeometry && vertTransform.transform.primitive && typeof input[0] !== 'string') {
        input.unshift(vertTransform.transform.primitive);
      }

      input = new vertTransform.transform.geometry(...input);
    } else {
      if (vertTransform.transform.geometry === _vectorizeText.default && input.length === 1) {
        input.push({
          textAlign: 'center',
          textBaseline: 'middle' // font: 'arial',
          // triangles: true, // todo: make it work

        });
      }

      input = vertTransform.transform.geometry(...input);
    }
  }

  this.geometry = input;
};

GlslSource.prototype.viewport = function (x, y, w, h) {
  this._viewport = {
    x,
    y,
    w,
    h
  };
  return this;
};

const glslProps = ['x', 'y', 'z', 'xy', 'xz', 'yx', 'yz', 'zx', 'zy', 'xyz', 'xyzw'];
glslProps.map(prop => {
  Object.defineProperty(GlslSource.prototype, prop, {
    get() {
      this.getter = prop;
      return this;
    }

  });
});
var _default = GlslSource;
exports.default = _default;

},{"./generate-glsl.js":189,"./glsl/utility-functions.js":194,"vectorize-text":183}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridGeometry = void 0;

var _BufferGeometry = require("three/src/core/BufferGeometry");

var _BufferAttribute = require("three/src/core/BufferAttribute");

class GridGeometry extends _BufferGeometry.BufferGeometry {
  constructor(type, width, height, options) {
    super();
    this.type = 'GridGeometry';
    this.parameters = {
      primitive: type,
      width: width,
      height: height,
      options: options
    };
    let vertices;

    switch (type) {
      case 'points':
        {
          width || (width = 1);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return (k + 1) / 3 % width / width;

              case 1:
                return (Math.floor((k - 1) / 3 / width) + 0.5) / height;

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'lines':
        {
          width || (width = 1);
          height || (height = 1);
          const count = 2 * (width + height);
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            if (k < width * 6) {
              switch (k % 6) {
                case 0:
                  return (k + 3) / 6 % width / width;

                case 1:
                  return 0.0001;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return k / 6 % width / width;

                case 4:
                  return 0.9999;
              }
            } else {
              switch (k % 6) {
                case 0:
                  return 0.0001;

                case 1:
                  return (k + 2) / 6 % height / height;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return 0.9999;

                case 4:
                  return (k - 1) / 6 % height / height;
              }
            }
          });
          break;
        }

      case 'line strip':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          const closed = typeof options === 'undefined' ? true : options;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            // todo: will be NaN when points[0] == 1
            // todo: minimum 2 points?
            switch (k % 3) {
              case 0:
                return k / 3 % width / (width - closed);

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'line loop':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return k / 3 % width / width;

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      default:
        console.error(`invalid GridGeometry type: ${type}`);
        break;
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
  }

}

exports.GridGeometry = GridGeometry;

},{"three/src/core/BufferAttribute":120,"three/src/core/BufferGeometry":121}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
Format for adding functions to hydra. For each entry in this file, hydra automatically generates a glsl function and javascript function with the same name. You can also ass functions dynamically using setFunction(object).

{
  name: 'osc', // name that will be used to access function in js as well as in glsl
  type: 'src', // can be 'src', 'color', 'combine', 'combineCoords'. see below for more info
  inputs: [
    {
      name: 'freq',
      type: 'float',
      default: 0.2
    },
    {
      name: 'sync',
      type: 'float',
      default: 0.1
    },
    {
      name: 'offset',
      type: 'float',
      default: 0.0
    }
  ],
    glsl: `
      vec2 st = _st;
      float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
      float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
      float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
      return vec4(r, g, b, 1.0);
   `
}

// The above code generates the glsl function:
`vec4 osc(vec2 _st, float freq, float sync, float offset){
 vec2 st = _st;
 float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
 float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
 float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
 return vec4(r, g, b, 1.0);
}`


Types and default arguments for hydra functions.
The value in the 'type' field lets the parser know which type the function will be returned as well as default arguments.

const types = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
}

*/
var _default = () => [{
  name: 'clear',
  type: 'clear',
  inputs: [],
  glsl: ``
}, {
  name: 'fade',
  type: 'clear',
  inputs: [{
    name: 'amount',
    type: 'float',
    default: '0.01'
  }, {
    name: 'camera',
    type: 'bool',
    default: false
  }],
  glsl: ``
}, {
  name: 'noise',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 0.1
  }],
  glsl: `   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);`
}, {
  name: 'voronoi',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 5
  }, {
    type: 'float',
    name: 'speed',
    default: 0.3
  }, {
    type: 'float',
    name: 'blending',
    default: 0.3
  }],
  glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
}, {
  name: 'osc',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'frequency',
    default: 60
  }, {
    type: 'float',
    name: 'sync',
    default: 0.1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
}, {
  name: 'shape',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'sides',
    default: 3
  }, {
    type: 'float',
    name: 'radius',
    default: 0.3
  }, {
    type: 'float',
    name: 'smoothing',
    default: 0.01
  }],
  glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
}, {
  name: 'gradient',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   return vec4(_st, sin(time*speed), 1.0);`
}, {
  name: 'src',
  type: 'src',
  inputs: [{
    type: 'sampler2D',
    name: 'tex',
    default: NaN
  }],
  glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
}, {
  name: 'solid',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   return vec4(r, g, b, a);`
}, {
  name: 'rotate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'angle',
    default: 10
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `  vec2 xy = _st - vec2(0.5);
   // Convert degrees to radians
   float ang = angle * (3.141592653589793 / 180.0);
   ang = ang + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'scale',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.5
  }, {
    type: 'float',
    name: 'xMult',
    default: 1
  }, {
    type: 'float',
    name: 'yMult',
    default: 1
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
}, {
  name: 'pixelate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'pixelX',
    default: 20
  }, {
    type: 'float',
    name: 'pixelY',
    default: 20
  }],
  glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'posterize',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'bins',
    default: 3
  }, {
    type: 'float',
    name: 'gamma',
    default: 0.6
  }],
  glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
}, {
  name: 'shift',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0.5
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 0
  }],
  glsl: `   vec4 c2 = vec4(_c0);
   c2.r = fract(c2.r + r);
   c2.g = fract(c2.g + g);
   c2.b = fract(c2.b + b);
   c2.a = fract(c2.a + a);
   return vec4(c2.rgba);`
}, {
  name: 'repeat',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) * offsetX;
   st.y += step(1., mod(st.x,2.0)) * offsetY;
   return fract(st);`
}, {
  name: 'modulateRepeat',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
}, {
  name: 'repeatX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'repeatY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'kaleid',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
}, {
  name: 'modulateKaleid',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
}, {
  name: 'scroll',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speedX',
    default: 0
  }, {
    type: 'float',
    name: 'speedY',
    default: 0
  }],
  glsl: `
   _st.x += scrollX + time*speedX;
   _st.y += scrollY + time*speedY;
   return fract(_st);`
}, {
  name: 'scrollX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'scrollY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'add',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0+_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'sub',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0-_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'layer',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));`
}, {
  name: 'blend',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.5
  }],
  glsl: `   return _c0*(1.0-amount)+_c1*amount;`
}, {
  name: 'mult',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _c0*(1.0-amount)+(_c0*_c1)*amount;`
}, {
  name: 'diff',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));`
}, {
  name: 'modulate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.1
  }],
  glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
}, {
  name: 'modulateScale',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 1
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
}, {
  name: 'modulatePixelate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 3
  }],
  glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'modulateRotate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'modulateHue',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);`
}, {
  name: 'invert',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);`
}, {
  name: 'contrast',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.6
  }],
  glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
}, {
  name: 'brightness',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.4
  }],
  glsl: `   return vec4(_c0.rgb + vec3(amount), _c0.a);`
}, {
  name: 'mask',
  type: 'combine',
  inputs: [],
  glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
}, {
  name: 'luma',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.1
  }],
  glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
}, {
  name: 'thresh',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.04
  }],
  glsl: `   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);`
}, {
  name: 'color',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 1
  }, {
    type: 'float',
    name: 'g',
    default: 1
  }, {
    type: 'float',
    name: 'b',
    default: 1
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
}, {
  name: 'saturate',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 2
  }],
  glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
}, {
  name: 'hue',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'hue',
    default: 0.4
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
}, {
  name: 'colorama',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.005
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
}, {
  name: 'prev',
  type: 'src',
  inputs: [],
  glsl: `   return texture2D(prevBuffer, fract(_st));`
}, {
  name: 'sum',
  type: 'color',
  inputs: [{
    type: 'vec4',
    name: 'scale',
    default: 1
  }],
  glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
}, {
  name: 'r',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.r * scale + offset);`
}, {
  name: 'g',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.g * scale + offset);`
}, {
  name: 'b',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.b * scale + offset);`
}, {
  name: 'a',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.a * scale + offset);`
}, {
  name: 'map',
  type: 'color',
  inputs: [{
    name: 'start1',
    type: 'float',
    default: NaN
  }, {
    name: 'stop1',
    type: 'float',
    default: NaN
  }, {
    name: 'start2',
    type: 'float',
    default: 0
  }, {
    name: 'stop2',
    type: 'float',
    default: 1
  }],
  glsl: `return (_c0 - start1) / (stop1 - start1) * (stop2 - start2) + start2;`
}, // todo: make these type agnostic (new type: 'util'?)
{
  name: 'sin',
  glslName: '_sin',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return sin(_st * TWO_PI * freq) * amp;`
}, {
  name: 'cos',
  glslName: '_cos',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return cos(_st * TWO_PI * freq) * amp;`
}, {
  name: 'tan',
  glslName: '_tan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return tan(_st * PI * freq) * amp;`
}, {
  name: 'atan',
  glslName: '_atan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return atan(_st * PI * freq) * amp;`
}, {
  name: 'pow',
  glslName: '_pow',
  type: 'coord',
  inputs: [{
    name: 'power',
    type: 'vec2',
    default: 2
  }],
  glsl: `return pow(_st, power);`
}];

exports.default = _default;

},{}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// functions that are only used within other functions
var _default = {
  _pi: {
    type: 'util',
    glsl: `#define PI 3.1415926535897932384626433832795`
  },
  _twopi: {
    type: 'util',
    glsl: `#define TWO_PI 6.283185307179586`
  },
  _luminance: {
    type: 'util',
    glsl: `float _luminance(vec3 rgb){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      return dot(rgb, W);
    }`
  },
  _permute: {
    type: 'util',
    glsl: `vec4 _permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}`
  },
  _mod289: {
    type: 'util',
    glsl: `
vec3 _mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 _mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}
`
  },
  _taylorInvSqrt: {
    type: 'util',
    glsl: `vec4 _taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}`
  },
  //	Simplex 3D Noise
  //	by Ian McEwan, Ashima Arts
  _noise: {
    type: 'util',
    glsl: `
  float _noise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = _permute( _permute( _permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
    `
  },
  _rgbToHsv: {
    type: 'util',
    glsl: `vec3 _rgbToHsv(vec3 c){
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }`
  },
  _hsvToRgb: {
    type: 'util',
    glsl: `vec3 _hsvToRgb(vec3 c){
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }`
  }
};
exports.default = _default;

},{}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GridGeometry = require("./geometries/GridGeometry.js");

var THREE = _interopRequireWildcard(require("three/src/geometries/Geometries.js"));

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const glsl = require("glslify");

const pointsVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_POINTS\nvec4 points(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vPos = pos;\n    vSize = size;\n    vColor = color;\n    gl_PointSize = vSize;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linesVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_LINES\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linestripVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const lineloopVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const pdotsFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 pdots(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist = 0.5;\n    outColor.a = (1.0 - smoothstep(maxDist - fade, maxDist, dist)) * outColor.a;\n    if (outColor.a <= 0.0 || dist >= maxDist) {\n        discard;\n    }\n    return outColor;\n}"]);
const psquaresFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 psquares(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist;\n    // todo: need to be based on angle\n    //maxDist = length(vec2(0.5, 0.5));\n    //outColor.a = 1.0 - smoothstep(maxDist - fade, maxDist, dist);\n    return outColor;\n}"]);
const plinesFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 plines(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    return outColor;\n}"]);
const plinestripFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const plineloopFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const planeVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec4 vColor;\n\nvec4 plane(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const phongFrag = glsl(["#define GLSLIFY 1\nvec4 phong(vec4 _c0, vec3 lightDirection, vec3 lightColor, vec3 ambientColor, vec3 specularColor, float shininess) {\n    vec3 normal = normalize(vnormal);\n    vec3 lightDir = normalize(-lightDirection);\n    vec3 viewDir = normalize(-vposition);\n    vec3 reflectDir = reflect(-lightDir, normal);\n\n    // Ambient component\n    vec3 ambient = ambientColor * lightColor;\n\n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = _c0.rgb * lightColor * diff;\n\n    // Specular component\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = specularColor * lightColor * spec;\n\n    return vec4(ambient + diffuse + specular, _c0.a);\n}\n"]);
const lambertFrag = glsl(["#define GLSLIFY 1\nvec4 lambert(vec4 _c0, float intensity, vec3 lightDirection) {\n  vec3 normal = normalize(vnormal);\n  vec3 lightDir = normalize(-lightDirection);\n  float diff = max(dot(normal, lightDir), 0.0);\n  return vec4(_c0.rgb * diff * intensity, _c0.a);\n}"]); // todo: respect makeGlobal?

Object.assign(window, {
  GridGeometry: _GridGeometry.GridGeometry,
  vectorizeText: _vectorizeText.default
});
Object.assign(window, THREE);

var _default = hy => [{
  name: 'pdots',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 10
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: pdotsFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'psquares',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 1
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: psquaresFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plines',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plinesFrag,
  vert: linesVert,
  primitive: 'lines',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plinestrip',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plinestripFrag,
  vert: linestripVert,
  primitive: 'line strip',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plineloop',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plineloopFrag,
  vert: lineloopVert,
  primitive: 'line loop',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plane',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  vert: planeVert,
  primitive: 'triangles',
  geometry: THREE.PlaneGeometry
}, {
  name: 'box',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.BoxGeometry
}, {
  name: 'sphere',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.SphereGeometry
}, {
  name: 'cylinder',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.CylinderGeometry
}, {
  name: 'cone',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.ConeGeometry
}, {
  name: 'edges',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'lines',
  geometry: THREE.EdgesGeometry
}, {
  name: 'text',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  geometry: _vectorizeText.default,
  useUV: false,
  useNormal: false
}, // lighting related functions
{
  name: 'lambert',
  type: 'color',
  inputs: [{
    name: 'intensity',
    type: 'float',
    default: 1
  }, {
    name: 'lightDirection',
    type: 'vec3',
    default: [1.0, 1.0, -1.0]
  }],
  glsl: lambertFrag
}, {
  name: 'phong',
  type: 'color',
  inputs: [{
    name: 'shininess',
    type: 'float',
    default: 4
  }, {
    name: 'lightDirection',
    type: 'vec3',
    default: [1.0, 1.0, -1.0]
  }, {
    name: 'lightColor',
    type: 'vec3',
    default: [1.0, 1.0, 1.0]
  }, {
    name: 'ambientColor',
    type: 'vec3',
    default: [0.1, 0.1, 0.1]
  }, {
    name: 'specularColor',
    type: 'vec3',
    default: [1.0, 1.0, 1.0]
  }],
  glsl: phongFrag
}, {
  name: 'normal',
  type: 'src',
  glsl: `return vec4(vnormal, 1.0);`
}];

exports.default = _default;

},{"./geometries/GridGeometry.js":192,"glslify":77,"three/src/geometries/Geometries.js":152,"vectorize-text":183}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _webcam = _interopRequireDefault(require("./lib/webcam.js"));

var _screenmedia = _interopRequireDefault(require("./lib/screenmedia.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HydraSource {
  constructor({
    regl,
    width,
    height,
    pb,
    label = ""
  }) {
    this.label = label;
    this.regl = regl;
    this.src = null;
    this.dynamic = true;
    this.width = width;
    this.height = height;
    this.tex = this.regl.texture({
      //  shape: [width, height]
      shape: [1, 1]
    });
    this.pb = pb;
  }

  init(opts, params) {
    if ('src' in opts) {
      this.src = opts.src;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    }

    if ('dynamic' in opts) this.dynamic = opts.dynamic;
  }

  initCam(index, params) {
    const self = this;
    (0, _webcam.default)(index).then(response => {
      self.src = response.video;
      self.dynamic = true;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
    }).catch(err => console.log('could not get camera', err));
  }

  initVideo(url = '', params) {
    // const self = this
    const vid = document.createElement('video');
    vid.crossOrigin = 'anonymous';
    vid.autoplay = true;
    vid.loop = true;
    vid.muted = true; // mute in order to load without user interaction

    const onload = vid.addEventListener('loadeddata', () => {
      this.src = vid;
      vid.play();
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
      this.dynamic = true;
    });
    vid.src = url;
  }

  initImage(url = '', params) {
    const img = document.createElement('img');
    img.crossOrigin = 'anonymous';
    img.src = url;

    img.onload = () => {
      this.src = img;
      this.dynamic = false;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    };
  }

  initStream(streamName, params) {
    //  console.log("initing stream!", streamName)
    let self = this;

    if (streamName && this.pb) {
      this.pb.initSource(streamName);
      this.pb.on('got video', function (nick, video) {
        if (nick === streamName) {
          self.src = video;
          self.dynamic = true;
          self.tex = self.regl.texture({
            data: self.src,
            ...params
          });
        }
      });
    }
  } // index only relevant in atom-hydra + desktop apps


  initScreen(index = 0, params) {
    const self = this;
    (0, _screenmedia.default)().then(function (response) {
      self.src = response.video;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
      self.dynamic = true; //  console.log("received screen input")
    }).catch(err => console.log('could not get screen', err));
  }

  resize(width, height) {
    this.width = width;
    this.height = height;
  }

  clear() {
    if (this.src && this.src.srcObject) {
      if (this.src.srcObject.getTracks) {
        this.src.srcObject.getTracks().forEach(track => track.stop());
      }
    }

    this.src = null;
    this.tex = this.regl.texture({
      shape: [1, 1]
    });
  }

  tick(time) {
    //  console.log(this.src, this.tex.width, this.tex.height)
    if (this.src !== null && this.dynamic === true) {
      if (this.src.videoWidth && this.src.videoWidth !== this.tex.width) {
        console.log(this.src.videoWidth, this.src.videoHeight, this.tex.width, this.tex.height);
        this.tex.resize(this.src.videoWidth, this.src.videoHeight);
      }

      if (this.src.width && this.src.width !== this.tex.width) {
        this.tex.resize(this.src.width, this.src.height);
      }

      this.tex.subimage(this.src);
    }
  }

  getTexture() {
    return this.tex;
  }

}

var _default = HydraSource;
exports.default = _default;

},{"./lib/screenmedia.js":205,"./lib/webcam.js":207}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _output = _interopRequireDefault(require("./output.js"));

var _rafLoop = _interopRequireDefault(require("raf-loop"));

var _hydraSource = _interopRequireDefault(require("./hydra-source.js"));

var _mouse = _interopRequireDefault(require("./lib/mouse.js"));

var _audio = _interopRequireDefault(require("./lib/audio.js"));

var _videoRecorder = _interopRequireDefault(require("./lib/video-recorder.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _evalSandbox = _interopRequireDefault(require("./eval-sandbox.js"));

var _generatorFactory = _interopRequireDefault(require("./generator-factory.js"));

var _regl = _interopRequireDefault(require("regl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import strudel from './lib/strudel.js'
// const window = global.window
const Mouse = (0, _mouse.default)(); // to do: add ability to pass in certain uniforms and transforms

class HydraRenderer {
  constructor({
    pb = null,
    width = 1280,
    height = 720,
    numSources = 4,
    numOutputs = 4,
    makeGlobal = true,
    autoLoop = true,
    detectAudio = true,
    enableStreamCapture = true,
    canvas,
    precision,
    extendTransforms = {} // add your own functions on init

  } = {}) {
    _arrayUtils.default.init();

    this.pb = pb;
    this.width = width;
    this.height = height;
    this.renderAll = false;
    this.detectAudio = detectAudio;

    this._initCanvas(canvas); //global.window.test = 'hi'
    // object that contains all properties that will be made available on the global context and during local evaluation


    this.synth = {
      time: 0,
      bpm: 30,
      width: this.width,
      height: this.height,
      fps: undefined,
      stats: {
        fps: 0
      },
      speed: 1,
      mouse: Mouse,
      render: this._render.bind(this),
      setResolution: this.setResolution.bind(this),
      update: dt => {},
      // user defined update function
      hush: this.hush.bind(this),
      tick: this.tick.bind(this)
    };
    if (makeGlobal) window.loadScript = this.loadScript;
    this.timeSinceLastUpdate = 0;
    this._time = 0; // for internal use, only to use for deciding when to render frames
    // only allow valid precision options

    let precisionOptions = ['lowp', 'mediump', 'highp'];

    if (precision && precisionOptions.includes(precision.toLowerCase())) {
      this.precision = precision.toLowerCase(); //
      // if(!precisionValid){
      //   console.warn('[hydra-synth warning]\nConstructor was provided an invalid floating point precision value of "' + precision + '". Using default value of "mediump" instead.')
      // }
    } else {
      let isIOS = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream;
      this.precision = isIOS ? 'highp' : 'mediump';
    }

    this.extendTransforms = extendTransforms; // boolean to store when to save screenshot

    this.saveFrame = false; // if stream capture is enabled, this object contains the capture stream

    this.captureStream = null;
    this.generator = undefined;

    this._initRegl();

    this._initOutputs(numOutputs);

    this._initSources(numSources);

    this._generateGlslTransforms();

    this.synth.screencap = () => {
      this.saveFrame = true;
    };

    if (enableStreamCapture) {
      try {
        this.captureStream = this.canvas.captureStream(25); // to do: enable capture stream of specific sources and outputs

        this.synth.vidRecorder = new _videoRecorder.default(this.captureStream);
      } catch (e) {
        console.warn('[hydra-synth warning]\nnew MediaSource() is not currently supported on iOS.');
        console.error(e);
      }
    }

    if (detectAudio) this._initAudio();
    if (autoLoop) (0, _rafLoop.default)(this.tick.bind(this)).start(); // final argument is properties that the user can set, all others are treated as read-only

    this.sandbox = new _evalSandbox.default(this.synth, makeGlobal, ['speed', 'update', 'bpm', 'fps']);
  }

  eval(code) {
    this.sandbox.eval(code);
  }

  getScreenImage(callback) {
    this.imageCallback = callback;
    this.saveFrame = true;
  }

  hush() {
    this.s.forEach(source => {
      source.clear();
    });
    this.o.forEach(output => {
      this.synth.solid(0, 0, 0, 0).out(output);
    });
    this.synth.render(this.o[0]); // this.synth.update = (dt) => {}

    this.sandbox.set('update', dt => {});
  }

  loadScript(url = "", once = true) {
    const self = this || window;
    const p = new Promise((res, rej) => {
      if (once) {
        self.loadedScripts || (self.loadedScripts = {});

        if (self.loadedScripts[url]) {
          res();
          return;
        }
      }

      var script = document.createElement("script");

      script.onload = function () {
        console.log(`loaded script ${url}`);

        if (once) {
          self.loadedScripts[url] = true;
        }

        res();
      };

      script.onerror = err => {
        console.log(`error loading script ${url}`, "log-error");
        res();
      };

      script.src = url;
      document.head.appendChild(script);
    });
    return p;
  }

  setResolution(width, height) {
    //  console.log(width, height)
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width; // is this necessary?

    this.height = height; // ?

    this.sandbox.set('width', width);
    this.sandbox.set('height', height);
    this.o.forEach(output => {
      output.resize(width, height);
    });
    this.s.forEach(source => {
      source.resize(width, height);
    });

    this.regl._refresh();

    console.log(this.canvas.width);
  }

  canvasToImage(callback) {
    const a = document.createElement('a');
    a.style.display = 'none';
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.png`;
    document.body.appendChild(a);
    var self = this;
    this.canvas.toBlob(blob => {
      if (self.imageCallback) {
        self.imageCallback(blob);
        delete self.imageCallback;
      } else {
        a.href = URL.createObjectURL(blob);
        console.log(a.href);
        a.click();
      }
    }, 'image/png');
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(a.href);
    }, 300);
  }

  _initAudio() {
    const that = this;
    this.synth.a = new _audio.default({
      numBins: 4,
      parentEl: this.canvas.parentNode // changeListener: ({audio}) => {
      //   that.a = audio.bins.map((_, index) =>
      //     (scale = 1, offset = 0) => () => (audio.fft[index] * scale + offset)
      //   )
      //
      //   if (that.makeGlobal) {
      //     that.a.forEach((a, index) => {
      //       const aname = `a${index}`
      //       window[aname] = a
      //     })
      //   }
      // }

    });
  } // create main output canvas and add to screen


  _initCanvas(canvas) {
    if (canvas) {
      this.canvas = canvas;
      this.width = canvas.width;
      this.height = canvas.height;
    } else {
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.canvas.style.imageRendering = 'pixelated';
      document.body.appendChild(this.canvas);
    }
  }

  _initRegl() {
    this.regl = (0, _regl.default)({
      //  profile: true,
      canvas: this.canvas,
      pixelRatio: 1 //,
      // extensions: [
      //   'oes_texture_half_float',
      //   'oes_texture_half_float_linear'
      // ],
      // optionalExtensions: [
      //   'oes_texture_float',
      //   'oes_texture_float_linear'
      //]

    }); // This clears the color buffer to black and the depth buffer to 1

    this.regl.clear({
      color: [0, 0, 0, 1]
    });
    this.renderAll = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;
      uniform sampler2D tex1;
      uniform sampler2D tex2;
      uniform sampler2D tex3;

      void main () {
        vec2 st = vec2(1.0 - uv.x, uv.y);
        st*= vec2(2);
        vec2 q = floor(st).xy*(vec2(2.0, 1.0));
        int quad = int(q.x) + int(q.y);
        st.x += step(1., mod(st.y,2.0));
        st.y += step(1., mod(st.x,2.0));
        st = fract(st);
        if(quad==0){
          gl_FragColor = texture2D(tex0, st);
        } else if(quad==1){
          gl_FragColor = texture2D(tex1, st);
        } else if (quad==2){
          gl_FragColor = texture2D(tex2, st);
        } else {
          gl_FragColor = texture2D(tex3, st);
        }

      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        tex1: this.regl.prop('tex1'),
        tex2: this.regl.prop('tex2'),
        tex3: this.regl.prop('tex3')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
    this.renderFbo = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform vec2 resolution;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, vec2(1.0 - uv.x, uv.y));
      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        resolution: this.regl.prop('resolution')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
  }

  _initOutputs(numOutputs) {
    const self = this;
    this.o = Array(numOutputs).fill().map((el, index) => {
      var o = new _output.default(index, this);
      self.synth['o' + index] = o;
      return o;
    }); // set default output

    this.output = this.o[0];
  }

  _initSources(numSources) {
    this.s = [];

    for (var i = 0; i < numSources; i++) {
      this.createSource(i);
    }
  }

  createSource(i) {
    let s = new _hydraSource.default({
      regl: this.regl,
      pb: this.pb,
      width: this.width,
      height: this.height,
      label: `s${i}`
    });
    this.synth['s' + this.s.length] = s;
    this.s.push(s);
    return s;
  }

  _generateGlslTransforms() {
    var self = this;
    this.generator = new _generatorFactory.default({
      defaultOutput: this.o[0],
      defaultUniforms: this.o[0].uniforms,
      extendTransforms: this.extendTransforms,
      changeListener: ({
        type,
        method,
        synth
      }) => {
        if (type === 'add') {
          self.synth[method] = synth.generators[method];
          if (self.sandbox) self.sandbox.add(method);
        } else if (type === 'remove') {// what to do here? dangerously deleting window methods
          //delete window[method]
        } //  }

      }
    });
    this.synth.setFunction = this.generator.setFunction.bind(this.generator);
  }

  _render(output) {
    if (output) {
      this.output = output;
      this.isRenderingAll = false;
    } else {
      this.isRenderingAll = true;
    }
  }

  _renderOut(i) {
    this.o[i].tick({
      time: this.synth.time,
      mouse: this.synth.mouse,
      bpm: this.synth.bpm,
      resolution: [this.canvas.width, this.canvas.height]
    });
  } // dt in ms


  tick(dt, uniforms) {
    this.sandbox.tick();
    if (this.detectAudio === true) this.synth.a.tick(); //  let updateInterval = 1000/this.synth.fps // ms

    this.sandbox.set('time', this.synth.time += dt * 0.001 * this.synth.speed);
    this.timeSinceLastUpdate += dt;

    if (!this.synth.fps || this.timeSinceLastUpdate >= 1000 / this.synth.fps) {
      //  console.log(1000/this.timeSinceLastUpdate)
      this.synth.stats.fps = Math.ceil(1000 / this.timeSinceLastUpdate);

      if (this.synth.update) {
        try {
          this.synth.update(this.timeSinceLastUpdate);
        } catch (e) {
          console.log(e);
        }
      } //  console.log(this.synth.speed, this.synth.time)


      for (let i = 0; i < this.s.length; i++) {
        this.s[i].tick(this.synth.time);
      } //  console.log(this.canvas.width, this.canvas.height)


      for (let i = 0; i < this.o.length; i++) {
        this._renderOut(i);
      }

      if (this.isRenderingAll) {
        this.renderAll({
          tex0: this.o[0].getCurrent(),
          tex1: this.o[1].getCurrent(),
          tex2: this.o[2].getCurrent(),
          tex3: this.o[3].getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      } else {
        this.renderFbo({
          tex0: this.output.getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      }

      this.timeSinceLastUpdate = 0;
    }

    if (this.saveFrame === true) {
      this.canvasToImage();
      this.saveFrame = false;
    } //  this.regl.poll()

  }

}

var _default = HydraRenderer;
exports.default = _default;

},{"./eval-sandbox.js":187,"./generator-factory.js":190,"./hydra-source.js":196,"./lib/array-utils.js":199,"./lib/audio.js":200,"./lib/mouse.js":203,"./lib/video-recorder.js":206,"./output.js":208,"raf-loop":96,"regl":102}],198:[function(require,module,exports){
"use strict";

var _hydraSynth = _interopRequireDefault(require("./hydra-synth.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import ShaderGenerator = require('./shader-generator.js')
// alert('hi')
// export default Synth
module.exports = _hydraSynth.default;

},{"./hydra-synth.js":197}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _easingFunctions = _interopRequireDefault(require("./easing-functions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// WIP utils for working with arrays
// Possibly should be integrated with lfo extension, etc.
// to do: transform time rather than array values, similar to working with coordinates in hydra
var map = (num, in_min, in_max, out_min, out_max) => {
  return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};

var _default = {
  init: () => {
    Array.prototype.fast = function (speed = 1) {
      this._speed = speed;
      return this;
    };

    Array.prototype.smooth = function (smooth = 1) {
      this._smooth = smooth;
      return this;
    };

    Array.prototype.ease = function (ease = 'linear') {
      if (typeof ease == 'function') {
        this._smooth = 1;
        this._ease = ease;
      } else if (_easingFunctions.default[ease]) {
        this._smooth = 1;
        this._ease = _easingFunctions.default[ease];
      }

      return this;
    };

    Array.prototype.offset = function (offset = 0.5) {
      this._offset = offset % 1.0;
      return this;
    }; // Array.prototype.bounce = function() {
    //   this.modifiers.bounce = true
    //   return this
    // }


    Array.prototype.fit = function (low = 0, high = 1) {
      let lowest = Math.min(...this);
      let highest = Math.max(...this);
      var newArr = this.map(num => map(num, lowest, highest, low, high));
      newArr._speed = this._speed;
      newArr._smooth = this._smooth;
      newArr._ease = this._ease;
      return newArr;
    };
  },
  getValue: (arr = []) => ({
    time,
    bpm
  }) => {
    let speed = arr._speed ? arr._speed : 1;
    let smooth = arr._smooth ? arr._smooth : 0;
    let index = time * speed * (bpm / 60) + (arr._offset || 0);

    if (smooth !== 0) {
      let ease = arr._ease ? arr._ease : _easingFunctions.default['linear'];

      let _index = index - smooth / 2;

      let currValue = arr[Math.floor(_index % arr.length)];
      let nextValue = arr[Math.floor((_index + 1) % arr.length)];
      let t = Math.min(_index % 1 / smooth, 1);
      return ease(t) * (nextValue - currValue) + currValue;
    } else {
      return arr[Math.floor(index % arr.length)];
    }
  }
};
exports.default = _default;

},{"./easing-functions.js":201}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _meyda = _interopRequireDefault(require("meyda"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Audio {
  constructor({
    numBins = 4,
    cutoff = 2,
    smooth = 0.4,
    max = 15,
    scale = 10,
    isDrawing = false,
    parentEl = document.body
  }) {
    this.vol = 0;
    this.scale = scale;
    this.max = max;
    this.cutoff = cutoff;
    this.smooth = smooth;
    this.setBins(numBins); // beat detection from: https://github.com/therewasaguy/p5-music-viz/blob/gh-pages/demos/01d_beat_detect_amplitude/sketch.js

    this.beat = {
      holdFrames: 20,
      threshold: 40,
      _cutoff: 0,
      // adaptive based on sound state
      decay: 0.98,
      _framesSinceBeat: 0 // keeps track of frames

    };

    this.onBeat = () => {//  console.log("beat")
    };

    this.canvas = document.createElement('canvas');
    this.canvas.width = 100;
    this.canvas.height = 80;
    this.canvas.style.width = "100px";
    this.canvas.style.height = "80px";
    this.canvas.style.position = 'absolute';
    this.canvas.style.right = '0px';
    this.canvas.style.bottom = '0px';
    parentEl.appendChild(this.canvas);
    this.isDrawing = isDrawing;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.fillStyle = "#DFFFFF";
    this.ctx.strokeStyle = "#0ff";
    this.ctx.lineWidth = 0.5;

    if (window.navigator.mediaDevices) {
      window.navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      }).then(stream => {
        //  console.log('got mic stream', stream)
        this.stream = stream;
        this.context = new AudioContext(); //  this.context = new AudioContext()

        let audio_stream = this.context.createMediaStreamSource(stream); //  console.log(this.context)

        this.meyda = _meyda.default.createMeydaAnalyzer({
          audioContext: this.context,
          source: audio_stream,
          featureExtractors: ['loudness' //  'perceptualSpread',
          //  'perceptualSharpness',
          //  'spectralCentroid'
          ]
        });
      }).catch(err => console.log('ERROR', err));
    }
  }

  detectBeat(level) {
    //console.log(level,   this.beat._cutoff)
    if (level > this.beat._cutoff && level > this.beat.threshold) {
      this.onBeat();
      this.beat._cutoff = level * 1.2;
      this.beat._framesSinceBeat = 0;
    } else {
      if (this.beat._framesSinceBeat <= this.beat.holdFrames) {
        this.beat._framesSinceBeat++;
      } else {
        this.beat._cutoff *= this.beat.decay;
        this.beat._cutoff = Math.max(this.beat._cutoff, this.beat.threshold);
      }
    }
  }

  tick() {
    if (this.meyda) {
      var features = this.meyda.get();

      if (features && features !== null) {
        this.vol = features.loudness.total;
        this.detectBeat(this.vol); // reduce loudness array to number of bins

        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        let spacing = Math.floor(features.loudness.specific.length / this.bins.length);
        this.prevBins = this.bins.slice(0);
        this.bins = this.bins.map((bin, index) => {
          return features.loudness.specific.slice(index * spacing, (index + 1) * spacing).reduce(reducer);
        }).map((bin, index) => {
          // map to specified range
          // return (bin * (1.0 - this.smooth) + this.prevBins[index] * this.smooth)
          return bin * (1.0 - this.settings[index].smooth) + this.prevBins[index] * this.settings[index].smooth;
        }); // var y = this.canvas.height - scale*this.settings[index].cutoff
        // this.ctx.beginPath()
        // this.ctx.moveTo(index*spacing, y)
        // this.ctx.lineTo((index+1)*spacing, y)
        // this.ctx.stroke()
        //
        // var yMax = this.canvas.height - scale*(this.settings[index].scale + this.settings[index].cutoff)

        this.fft = this.bins.map((bin, index) => // Math.max(0, (bin - this.cutoff) / (this.max - this.cutoff))
        Math.max(0, (bin - this.settings[index].cutoff) / this.settings[index].scale));
        if (this.isDrawing) this.draw();
      }
    }
  }

  setCutoff(cutoff) {
    this.cutoff = cutoff;
    this.settings = this.settings.map(el => {
      el.cutoff = cutoff;
      return el;
    });
  }

  setSmooth(smooth) {
    this.smooth = smooth;
    this.settings = this.settings.map(el => {
      el.smooth = smooth;
      return el;
    });
  }

  setBins(numBins) {
    this.bins = Array(numBins).fill(0);
    this.prevBins = Array(numBins).fill(0);
    this.fft = Array(numBins).fill(0);
    this.settings = Array(numBins).fill(0).map(() => ({
      cutoff: this.cutoff,
      scale: this.scale,
      smooth: this.smooth
    })); // to do: what to do in non-global mode?

    this.bins.forEach((bin, index) => {
      window['a' + index] = (scale = 1, offset = 0) => () => a.fft[index] * scale + offset;
    }); //  console.log(this.settings)
  }

  setScale(scale) {
    this.scale = scale;
    this.settings = this.settings.map(el => {
      el.scale = scale;
      return el;
    });
  }

  setMax(max) {
    this.max = max;
    console.log('set max is deprecated');
  }

  hide() {
    this.isDrawing = false;
    this.canvas.style.display = 'none';
  }

  show() {
    this.isDrawing = true;
    this.canvas.style.display = 'block';
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    var spacing = this.canvas.width / this.bins.length;
    var scale = this.canvas.height / (this.max * 2); //  console.log(this.bins)

    this.bins.forEach((bin, index) => {
      var height = bin * scale;
      this.ctx.fillRect(index * spacing, this.canvas.height - height, spacing, height); //   console.log(this.settings[index])

      var y = this.canvas.height - scale * this.settings[index].cutoff;
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, y);
      this.ctx.lineTo((index + 1) * spacing, y);
      this.ctx.stroke();
      var yMax = this.canvas.height - scale * (this.settings[index].scale + this.settings[index].cutoff);
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, yMax);
      this.ctx.lineTo((index + 1) * spacing, yMax);
      this.ctx.stroke();
    });
    /*var y = this.canvas.height - scale*this.cutoff
    this.ctx.beginPath()
    this.ctx.moveTo(0, y)
    this.ctx.lineTo(this.canvas.width, y)
    this.ctx.stroke()
    var yMax = this.canvas.height - scale*this.max
    this.ctx.beginPath()
    this.ctx.moveTo(0, yMax)
    this.ctx.lineTo(this.canvas.width, yMax)
    this.ctx.stroke()*/
  }

}

var _default = Audio;
exports.default = _default;

},{"meyda":84}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// from https://gist.github.com/gre/1650294
var _default = {
  // no easing, no acceleration
  linear: function (t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function (t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  },
  // sin shape
  sin: function (t) {
    return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;
  }
};
exports.default = _default;

},{}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// https://github.com/mikolalysenko/mouse-event
const mouse = {};

function mouseButtons(ev) {
  if (typeof ev === 'object') {
    if ('buttons' in ev) {
      return ev.buttons;
    } else if ('which' in ev) {
      var b = ev.which;

      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ('button' in ev) {
      var b = ev.button;

      if (b === 1) {
        return 4;
      } else if (b === 2) {
        return 2;
      } else if (b >= 0) {
        return 1 << b;
      }
    }
  }

  return 0;
}

mouse.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window;
}

mouse.element = mouseElement;

function mouseRelativeX(ev) {
  if (typeof ev === 'object') {
    if ('pageX' in ev) {
      return ev.pageX;
    }
  }

  return 0;
}

mouse.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if (typeof ev === 'object') {
    if ('pageY' in ev) {
      return ev.pageY;
    }
  }

  return 0;
}

mouse.y = mouseRelativeY;
var _default = mouse;
exports.default = _default;

},{}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mouseEvent = _interopRequireDefault(require("./mouse-event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://github.com/mikolalysenko/mouse-change
var _default = mouseListen;
exports.default = _default;

function mouseListen(element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods(ev) {
    var changed = false;

    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }

    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }

    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }

    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }

    return changed;
  }

  function handleEvent(nextButtons, ev) {
    var nextX = _mouseEvent.default.x(ev);

    var nextY = _mouseEvent.default.y(ev);

    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }

    if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState(ev) {
    handleEvent(0, ev);
  }

  function handleBlur() {
    if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods(ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove(ev) {
    if (_mouseEvent.default.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown(ev) {
    handleEvent(buttonState | _mouseEvent.default.buttons(ev), ev);
  }

  function handleMouseUp(ev) {
    handleEvent(buttonState & ~_mouseEvent.default.buttons(ev), ev);
  }

  function attachListeners() {
    if (attached) {
      return;
    }

    attached = true;
    element.addEventListener('mousemove', handleMouseMove);
    element.addEventListener('mousedown', handleMouseDown);
    element.addEventListener('mouseup', handleMouseUp);
    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);
    element.addEventListener('blur', handleBlur);
    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);
      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners() {
    if (!attached) {
      return;
    }

    attached = false;
    element.removeEventListener('mousemove', handleMouseMove);
    element.removeEventListener('mousedown', handleMouseDown);
    element.removeEventListener('mouseup', handleMouseUp);
    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);
    element.removeEventListener('blur', handleBlur);
    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  } // Attach listeners


  attachListeners();
  var result = {
    element: element
  };
  Object.defineProperties(result, {
    enabled: {
      get: function () {
        return attached;
      },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () {
        return buttonState;
      },
      enumerable: true
    },
    x: {
      get: function () {
        return x;
      },
      enumerable: true
    },
    y: {
      get: function () {
        return y;
      },
      enumerable: true
    },
    mods: {
      get: function () {
        return mods;
      },
      enumerable: true
    }
  });
  return result;
}

},{"./mouse-event.js":202}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// attempt custom evaluation sandbox for hydra functions
// for now, just avoids polluting the global namespace
// should probably be replaced with an abstract syntax tree
var _default = parent => {
  var initialCode = ``;
  var sandbox = createSandbox(initialCode);

  var addToContext = (name, object) => {
    initialCode += `
      var ${name} = ${object}
    `;
    sandbox = createSandbox(initialCode);
  };

  return {
    addToContext: addToContext,
    eval: code => sandbox.eval(code)
  };

  function createSandbox(initial) {
    globalThis.eval(initial); // optional params

    var localEval = function (code) {
      globalThis.eval(code);
    }; // API/data for end-user


    return {
      eval: localEval
    };
  }
};

exports.default = _default;

},{}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(options) {
  return new Promise(function (resolve, reject) {
    //  async function startCapture(displayMediaOptions) {
    navigator.mediaDevices.getDisplayMedia(options).then(stream => {
      const video = document.createElement('video');
      video.srcObject = stream;
      video.addEventListener('loadedmetadata', () => {
        video.play();
        resolve({
          video: video
        });
      });
    }).catch(err => reject(err));
  });
}

},{}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class VideoRecorder {
  constructor(stream) {
    this.mediaSource = new MediaSource();
    this.stream = stream; // testing using a recording as input

    this.output = document.createElement('video');
    this.output.autoplay = true;
    this.output.loop = true;
    let self = this;
    this.mediaSource.addEventListener('sourceopen', () => {
      console.log('MediaSource opened');
      self.sourceBuffer = self.mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      console.log('Source buffer: ', sourceBuffer);
    });
  }

  start() {
    //  let options = {mimeType: 'video/webm'};
    //   let options = {mimeType: 'video/webm;codecs=h264'};
    let options = {
      mimeType: 'video/webm;codecs=vp9'
    };
    this.recordedBlobs = [];

    try {
      this.mediaRecorder = new MediaRecorder(this.stream, options);
    } catch (e0) {
      console.log('Unable to create MediaRecorder with options Object: ', e0);

      try {
        options = {
          mimeType: 'video/webm,codecs=vp9'
        };
        this.mediaRecorder = new MediaRecorder(this.stream, options);
      } catch (e1) {
        console.log('Unable to create MediaRecorder with options Object: ', e1);

        try {
          options = 'video/vp8'; // Chrome 47

          this.mediaRecorder = new MediaRecorder(this.stream, options);
        } catch (e2) {
          alert('MediaRecorder is not supported by this browser.\n\n' + 'Try Firefox 29 or later, or Chrome 47 or later, ' + 'with Enable experimental Web Platform features enabled from chrome://flags.');
          console.error('Exception while creating MediaRecorder:', e2);
          return;
        }
      }
    }

    console.log('Created MediaRecorder', this.mediaRecorder, 'with options', options);
    this.mediaRecorder.onstop = this._handleStop.bind(this);
    this.mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this.mediaRecorder.start(100); // collect 100ms of data

    console.log('MediaRecorder started', this.mediaRecorder);
  }

  stop() {
    this.mediaRecorder.stop();
  }

  _handleStop() {
    //const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'})
    // const blob = new Blob(this.recordedBlobs, {type: 'video/webm;codecs=h264'})
    const blob = new Blob(this.recordedBlobs, {
      type: this.mediaRecorder.mimeType
    });
    const url = window.URL.createObjectURL(blob);
    this.output.src = url;
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.webm`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 300);
  }

  _handleDataAvailable(event) {
    if (event.data && event.data.size > 0) {
      this.recordedBlobs.push(event.data);
    }
  }

}

var _default = VideoRecorder;
exports.default = _default;

},{}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

//const enumerateDevices = require('enumerate-devices')
function _default(deviceId) {
  return navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(devices => devices.kind === 'videoinput')).then(cameras => {
    let constraints = {
      audio: false,
      video: true
    };

    if (cameras[deviceId]) {
      constraints['video'] = {
        deviceId: {
          exact: cameras[deviceId].deviceId
        }
      };
    } //  console.log(cameras)


    return window.navigator.mediaDevices.getUserMedia(constraints);
  }).then(stream => {
    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.setAttribute('playsinline', ''); //  video.src = window.URL.createObjectURL(stream)

    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.addEventListener('loadedmetadata', () => {
        video.play().then(() => resolve({
          video: video
        }));
      });
    });
  }).catch(console.log.bind(console));
}

},{}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var mat4 = _interopRequireWildcard(require("gl-mat4"));

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Output = function (index, synth) {
  this.id = index;
  this.synth = synth;
  this.width = synth.width;
  this.height = synth.height;
  this.regl = synth.regl;
  this.precision = synth.precision;
  this.label = `o${index}`;
  this.positionBuffer = this.regl.buffer([[-5, -1, 0], [-1, -5, 0], [3, 3, 0]]);
  this.uvBuffer = this.regl.buffer([[-2, 0], [0, -2], [2, 2]]);
  this.draw = [];
  this.init();
  this.pingPongIndex = 0; // for each output, create two fbos for pingponging

  this.fbos = Array(2).fill().map(() => this._initFbo()); // for each output, create two temp buffers

  this.temp = Array(2).fill().map(() => this._initFbo());
  this.copyPass = this.regl({
    frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, uv);
      }
      `,
    vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(2.0 * position - 1.0, 0, 1);
      }`,
    attributes: {
      position: [[-2, 0], [0, -2], [2, 2]]
    },
    uniforms: {
      tex0: this.regl.prop('tex0')
    },
    count: 3,
    depth: {
      enable: false
    },
    framebuffer: () => this.getTexture()
  });
};

Output.prototype._initFbo = function () {
  return this.regl.framebuffer({
    color: this.regl.texture({
      mag: 'nearest',
      width: this.width,
      height: this.height,
      format: 'rgba'
    }),
    depthStencil: false
  });
};

Output.prototype.resize = function (width, height) {
  this.width = width;
  this.height = height;
  this.fbos.forEach(fbo => {
    fbo.resize(width, height);
  });
  this.temp.forEach(tmp => {
    tmp.resize(width, height);
  });
};

Output.prototype.getCurrent = function () {
  return this.fbos[this.pingPongIndex];
};

Output.prototype.getTexture = function () {
  var index = this.pingPongIndex ? 0 : 1;
  return this.fbos[index];
};

Output.prototype.init = function () {
  this.attributes = {
    position: this.positionBuffer,
    uv: this.uvBuffer
  };
  this.uniforms = {
    time: this.regl.prop('time'),
    resolution: this.regl.prop('resolution')
  };
  this.initCamera();
  return this;
};

Output.prototype.initCamera = function () {
  this._camera = this.regl({
    context: {
      projection: mat4.identity([]),
      view: mat4.identity([])
    },
    uniforms: {
      view: this.regl.context('view'),
      projection: this.regl.context('projection')
    }
  });
};

Output.prototype.camera = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    fovy: Math.PI / 4,
    near: 0.1,
    far: 1000.0
  }, options);
  this.eye = eye;
  this.target = target;

  if (eye && target) {
    this._camera = this.regl({
      context: {
        projection: function (context) {
          if (options.type === 'perspective') {
            return mat4.perspective([], options.fovy, options.aspect || context.viewportWidth / context.viewportHeight, options.near, options.far);
          } else {
            return mat4.ortho([], -1.0, 1.0, -1.0, 1.0, options.near, options.far);
          }
        },
        view: function (context, props) {
          return mat4.lookAt([], props.eye, props.target, [0, 1, 0]);
        },
        eye: this.regl.prop('eye')
      },
      uniforms: {
        view: this.regl.context('view'),
        projection: this.regl.context('projection')
      }
    });
  } else {
    this.initCamera();
  }

  return this;
};

Output.prototype.perspective = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'perspective'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.ortho = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'ortho'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.render = function (passes) {
  const self = this; // ensure both fbo's have last frame

  this.copyPass({
    tex0: this.getCurrent()
  });
  self.draw = [];

  for (let i = 0; i < passes.length; i++) {
    let pass = passes[i];

    if (pass.clear) {
      switch (pass.clear) {
        case 'clear':
          self.draw.push(...this.clear(false));
          break;

        case 'fade':
          {
            const opt = typeof pass.userArgs[0] === 'object' ? pass.userArgs[0] : {
              amount: pass.userArgs[0]
            };
            opt.now = false;
            self.draw.push(this.fade(opt));
            break;
          }

        default:
          console.warn(`unrecognized clear: ${pass.clear}(${pass.userArgs.join(", ")})`);
          break;
      }

      continue;
    }

    const {
      attributes,
      elements,
      primitive
    } = this.getAttributes(pass.primitive, pass.geometry);
    const uniforms = this.getUniforms(pass.uniforms);
    const blend = this.getBlend(pass.blendMode);
    const draw = self.regl({
      frag: pass.frag,
      vert: pass.vert,
      viewport: typeof pass.viewport.x !== 'undefined' ? {
        x: pass.viewport.x * this.fbos[0].width,
        y: pass.viewport.y * this.fbos[0].height,
        width: pass.viewport.w * this.fbos[0].width,
        height: pass.viewport.h * this.fbos[0].height
      } : {},
      cull: {
        enable: !!pass.geometry,
        face: 'back'
      },
      attributes,
      primitive,
      uniforms,
      count: typeof elements === 'number' ? elements : elements.length,
      elements: typeof elements === 'number' ? null : elements,
      blend,
      lineWidth: pass.lineWidth,
      framebuffer: pass.framebuffer || (() => {
        self.pingPongIndex = self.pingPongIndex ? 0 : 1;
        return self.fbos[self.pingPongIndex];
      })
    });
    self.draw.push(draw);
  }
};

Output.prototype.clear = function (now = true) {
  const result = [this.fbos[0], this.fbos[1], this.temp[0], this.temp[1]].map(fbo => {
    const clear = () => this.regl.clear({
      color: [0, 0, 0, 0],
      framebuffer: fbo
    });

    if (now) clear();else return clear;
  });
  if (now) return this;
  return result;
};

Output.prototype.fade = function (options) {
  let amount = options;
  let camera = false;
  let now = true;

  if (typeof options === 'object') {
    ({
      amount,
      camera
    } = options);
    now = typeof options.now === 'undefined' ? true : options.now;
  }

  const self = this; // todo: do we need to fade also temp buffers?

  const fade = self.regl({
    frag: `
          precision ${self.precision} float;
          varying vec2 vuv;
          uniform sampler2D prevBuffer;
          void main() {
            vec4 color = mix(texture2D(prevBuffer, vuv), vec4(0), ${amount});
            gl_FragColor = color;
          }
        `,
    vert: _glslSource.default.compileVert(this.precision, camera, {
      glslName: 'clear'
    }),
    attributes: self.attributes,
    primitive: 'triangles',
    uniforms: Object.assign({}, {
      prevBuffer: () => {
        return self.fbos[self.pingPongIndex];
      }
    }, this.uniforms),
    count: 3,
    // next framebuffer
    framebuffer: () => {
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  if (now) return this;
  return fade;
};

Output.prototype.getAttributes = function (primitive, geometry) {
  let elements = 3;
  let attributes = this.attributes;

  if (geometry) {
    attributes = {};

    if (geometry.isBufferGeometry) {
      Object.keys(geometry.attributes).forEach(key => attributes[key] = geometry.attributes[key].array);
      elements = geometry.index ? geometry.index.array : geometry.attributes.position.count;
      primitive || (primitive = geometry.parameters.primitive);
    } else if (geometry.positions && (geometry.edges || geometry.cells)) {
      attributes.position = []; // todo: should be Float32Array

      geometry.positions.map((v, k) => attributes.position.push(v[0], v[1], 0));
      elements = geometry.edges ? geometry.edges : geometry.cells;
      primitive = geometry.edges ? 'lines' : 'triangles';
    }
  }

  primitive || (primitive = 'triangles');
  return {
    attributes,
    elements,
    primitive
  };
};

Output.prototype.getUniforms = function (uniforms) {
  const self = this;
  uniforms = Object.assign(uniforms, {
    prevBuffer: () => {
      // todo: changed, originally:
      // return self.fbos[self.pingPongIndex]
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  return Object.keys(uniforms).reduce((acc, key) => {
    acc[key] = typeof uniforms[key] === 'string' ? parseFloat(uniforms[key]) : uniforms[key];
    return acc;
  }, {});
};

Output.prototype.getBlend = function (blendMode) {
  let func;

  switch (blendMode) {
    case 'custom':
      func = {
        srcRGB: 'custom',
        // Define your custom blending function here
        dstRGB: 'custom',
        srcAlpha: 'custom',
        dstAlpha: 'custom'
      };
      break;

    case 'overlay':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'one minus src color',
        srcAlpha: 'dst alpha',
        dstAlpha: 'one minus src alpha'
      };
      break;

    case 'screen':
      func = {
        srcRGB: 'one minus dst color',
        dstRGB: 'one',
        srcAlpha: 'one minus dst alpha',
        dstAlpha: 'one'
      };
      break;

    case 'multiply':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'zero',
        srcAlpha: 'dst alpha',
        dstAlpha: 'zero'
      };
      break;

    case 'add':
      func = {
        srcRGB: 'one',
        dstRGB: 'one',
        srcAlpha: 'one',
        dstAlpha: 'one'
      };
      break;

    case 'alpha':
    default:
      func = {
        srcRGB: 'src alpha',
        srcAlpha: 1,
        dstRGB: 'one minus src alpha',
        dstAlpha: 1
      };
      break;
  }

  return {
    enable: blendMode ? typeof blendMode === 'string' ? blendMode !== 'disabled' : blendMode : false,
    func
  };
};

Output.prototype.tick = function (props) {
  const doDraw = () => this.draw.map(fn => fn(props));

  this._camera({
    eye: this.eye,
    target: this.target
  }, function () {
    doDraw();
  });
};

Output.prototype.renderTexture = function () {
  this.synth._renderOut(this.id);

  const colorTex = this.fbos[this.pingPongIndex].color;
  this.fbos[this.pingPongIndex] = this._initFbo();
  return colorTex;
};

var _default = Output;
exports.default = _default;

},{"./glsl-source.js":191,"gl-mat4":62}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeLookup = exports.getTypeLookup = exports.getLookup = exports.castType = void 0;
const typeLookup = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'vert': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
};
exports.typeLookup = typeLookup;
const getLookup = {
  float: 'x',
  vec2: 'xy',
  vec3: 'xyz',
  vec4: 'xyzw'
};
exports.getLookup = getLookup;
const getTypeLookup = {
  x: 'float',
  y: 'float',
  z: 'float',
  xy: 'vec2',
  yx: 'vec2',
  xyz: 'vec3',
  xzy: 'vec3',
  yzx: 'vec3',
  yxz: 'vec3',
  zxy: 'vec3',
  zyx: 'vec3',
  xyzw: 'vec4'
};
exports.getTypeLookup = getTypeLookup;

const castType = (func, fromType, toType, alpha = 0.0) => {
  const fromLen = fromType === 'float' ? 1 : fromType.substring(3);
  const toLen = toType === 'float' ? 1 : toType.substring(3);

  if (fromLen < toLen) {
    let diff = toLen - fromLen;
    let last = '';

    if (toType === 'vec4') {
      diff -= 1;
      last = ', ' + alpha;
    }

    func = `vec${toLen}(${func}${', 0.0'.repeat(diff)}${last})`;
  }

  return func;
};

exports.castType = castType;

},{}]},{},[198])(198)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvY21wLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvZGl2LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9pcy1yYXQuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvYm4tc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9ibi10by1udW0uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvY3R6LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL2lzLWJuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL251bS10by1ibi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9yYXRpb25hbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9zdHItdG8tYm4uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9tdWwuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3N1Yi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3RvLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2JpbmFyeS1zZWFyY2gtYm91bmRzL3NlYXJjaC1ib3VuZHMuanMiLCJub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2JydXRlLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2ludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9tZWRpYW4uanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvcGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3NvcnQuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvc3dlZXAuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2NkdDJkLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9kZWxhdW5heS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9tb25vdG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvdHJpYW5ndWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL2NsZWFuLXBzbGcuanMiLCJub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9saWIvcmF0LXNlZy1pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvY29tcGFyZS1hbmdsZS9jbXBhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanMiLCJub2RlX21vZHVsZXMvZG91YmxlLWJpdHMvZG91YmxlLmpzIiwibm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZWRnZXMtdG8tYWRqYWNlbmN5LWxpc3QvZTJhLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uYWwtcmVkLWJsYWNrLXRyZWUvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2dhbW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW50ZXJ2YWwtdHJlZS0xZC9pbnRlcnZhbC10cmVlLmpzIiwibm9kZV9tb2R1bGVzL2ludmVydC1wZXJtdXRhdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21leWRhL2Rpc3Qvd2ViL21leWRhLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LWV4dHJhY3QtY29udG91ci9jb250b3VyLmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9uZXh0YWZ0ZXIvbmV4dGFmdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXBhcml0eS9wZXJtdXRhdGlvbi1zaWduLmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXJhbmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWR1YWwvbG9vcHMuanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWdyYXBoLXRvLXBvbHlsaW5lL2xpYi90cmltLWxlYXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9wbGFuYXItZ3JhcGgtdG8tcG9seWxpbmUvcGcycGwuanMiLCJub2RlX21vZHVsZXMvcG9pbnQtaW4tYmlnLXBvbHlnb24vcG5wLWJpZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmLWxvb3AvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmF0LXZlYy9tdWxzLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvc3ViLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2wvZGlzdC9yZWdsLmpzIiwibm9kZV9tb2R1bGVzL3JpZ2h0LW5vdy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1pbi1zcGhlcmUvaW4tc3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3QtcHJvZHVjdC9wcm9kdWN0LmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1zY2FsZS9yb2J1c3Qtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXNlZ21lbnQtaW50ZXJzZWN0L3NlZ3NlZy5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3Qtc3VidHJhY3Qvcm9idXN0LWRpZmYuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXN1bS9yb2J1c3Qtc3VtLmpzIiwibm9kZV9tb2R1bGVzL3NpZ251bS9zZ24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxpY2lhbC1jb21wbGV4L25vZGVfbW9kdWxlcy91bmlvbi1maW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC90b3BvbG9neS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGlmeS1wbGFuYXItZ3JhcGgvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvc2xhYi1kZWNvbXBvc2l0aW9uL2xpYi9vcmRlci1zZWdtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zbGFiLWRlY29tcG9zaXRpb24vc2xhYnMuanMiLCJub2RlX21vZHVsZXMvc3VyZmFjZS1uZXRzL3N1cmZhY2VuZXRzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9MYXllcnMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvT2JqZWN0M0QuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9EYXRhVXRpbHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9FYXJjdXQuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY29yZS9DdXJ2ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY29yZS9JbnRlcnBvbGF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvU2hhcGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0NhcHN1bGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Db25lR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9HZW9tZXRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0ljb3NhaGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvVGV0cmFoZWRyb25HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9Cb3gzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0V1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdGhVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRyaXgzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDQuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9TcGhlcmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVHJpYW5nbGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9WZWN0b3IzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy90cmlhbmd1bGF0ZS1oeXBlcmN1YmUvdHJpYW5ndWxhdGUtY3ViZS5qcyIsIm5vZGVfbW9kdWxlcy90d28tcHJvZHVjdC90d28tcHJvZHVjdC5qcyIsIm5vZGVfbW9kdWxlcy90d28tc3VtL3R3by1zdW0uanMiLCJub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvdW5pb24tZmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yaXplLXRleHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVjdG9yaXplLXRleHQvbGliL3Z0ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3plcm8tY3Jvc3NpbmdzL2xpYi96Yy1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3plcm8tY3Jvc3NpbmdzL3pjLmpzIiwic3JjL2V2YWwtc2FuZGJveC5qcyIsInNyYy9mb3JtYXQtYXJndW1lbnRzLmpzIiwic3JjL2dlbmVyYXRlLWdsc2wuanMiLCJzcmMvZ2VuZXJhdG9yLWZhY3RvcnkuanMiLCJzcmMvZ2xzbC1zb3VyY2UuanMiLCJzcmMvZ2xzbC9nZW9tZXRyaWVzL0dyaWRHZW9tZXRyeS5qcyIsInNyYy9nbHNsL2dsc2wtZnVuY3Rpb25zLmpzIiwic3JjL2dsc2wvdXRpbGl0eS1mdW5jdGlvbnMuanMiLCJzcmMvZ2xzbC92ZXJ0LWZ1bmN0aW9ucy5qcyIsInNyYy9oeWRyYS1zb3VyY2UuanMiLCJzcmMvaHlkcmEtc3ludGguanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGliL2FycmF5LXV0aWxzLmpzIiwic3JjL2xpYi9hdWRpby5qcyIsInNyYy9saWIvZWFzaW5nLWZ1bmN0aW9ucy5qcyIsInNyYy9saWIvbW91c2UtZXZlbnQuanMiLCJzcmMvbGliL21vdXNlLmpzIiwic3JjL2xpYi9zYW5kYm94LmpzIiwic3JjL2xpYi9zY3JlZW5tZWRpYS5qcyIsInNyYy9saWIvdmlkZW8tcmVjb3JkZXIuanMiLCJzcmMvbGliL3dlYmNhbS5qcyIsInNyYy9vdXRwdXQuanMiLCJzcmMvdHlwZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbitCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3K1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOzs7Ozs7Ozs7O0FD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bEQsRUFBd0QsSUFBeEQsRUFBOEQsSUFBOUQsRUFBb0UsSUFBcEUsRUFBMEUsSUFBMUUsRUFBZ0YsSUFBaEYsRUFBc0YsSUFBdEYsRUFBNEYsSUFBNUYsRUFBa0csSUFBbEcsRUFBd0csSUFBeEcsRUFBOEcsSUFBOUcsRUFBb0gsSUFBcEgsRUFBMEgsSUFBMUgsRUFBZ0ksSUFBaEksRUFBc0ksSUFBdEksRUFBNEksSUFBNUksRUFBa0osSUFBbEosRUFBd0osSUFBeEosRUFBOEosSUFBOUosRUFBb0ssSUFBcEssRUFBMEssSUFBMUssRUFBZ0wsSUFBaEwsRUFBc0wsSUFBdEwsRUFBNEwsSUFBNUwsRUFBa00sSUFBbE0sRUFBd00sSUFBeE0sRUFBOE0sSUFBOU0sRUFBb04sSUFBcE4sRUFBME4sSUFBMU4sRUFBZ08sSUFBaE8sRUFBc08sSUFBdE8sRUFBNE8sSUFBNU8sRUFBa1AsSUFBbFAsRUFBd1AsSUFBeFAsRUFBOFAsSUFBOVAsRUFBb1EsSUFBcFEsRUFBMFEsSUFBMVEsRUFBZ1IsSUFBaFIsRUFBc1IsSUFBdFIsRUFBNFIsSUFBNVIsRUFBa1MsSUFBbFMsRUFBd1MsSUFBeFMsRUFBOFMsSUFBOVMsRUFBb1QsSUFBcFQsRUFBMFQsSUFBMVQsRUFBZ1UsSUFBaFUsRUFBc1UsSUFBdFUsRUFBNFUsSUFBNVUsRUFBa1YsSUFBbFYsRUFBd1YsSUFBeFYsRUFBOFYsSUFBOVYsRUFBb1csSUFBcFcsRUFBMFcsSUFBMVcsRUFBZ1gsSUFBaFgsRUFBc1gsSUFBdFgsRUFBNFgsSUFBNVgsRUFBa1ksSUFBbFksRUFBd1ksSUFBeFksRUFBOFksSUFBOVksRUFBb1osSUFBcFosRUFBMFosSUFBMVosRUFBZ2EsSUFBaGEsRUFBc2EsSUFBdGEsRUFBNGEsSUFBNWEsRUFBa2IsSUFBbGIsRUFBd2IsSUFBeGIsRUFBOGIsSUFBOWIsRUFBb2MsSUFBcGMsRUFBMGMsSUFBMWMsRUFBZ2QsSUFBaGQsRUFBc2QsSUFBdGQsRUFBNGQsSUFBNWQsRUFBa2UsSUFBbGUsRUFBd2UsSUFBeGUsRUFBOGUsSUFBOWUsRUFBb2YsSUFB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QUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0E7O01BRUQsS0FBSyxLQUFMO1FBQ0MsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBOztNQUVELEtBQUssS0FBTDtRQUNDLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QWQsRUFBcUI7SUFDakIsSUFBSSxJQUFJLEdBQUcsS0FBSyxHQUFHLE9BQW5CO0lBQ0EsSUFBSSxJQUFJLEdBQUcsRUFBWDs7SUFDQSxJQUFJLE1BQU0sS0FBSyxNQUFmLEVBQXVCO01BQ25CLElBQUksSUFBSSxDQUFSO01BQ0EsSUFBSSxHQUFHLE9BQUssS0FBWjtJQUNIOztJQUNELElBQUksR0FBSSxNQUFLLEtBQU0sSUFBRyxJQUFLLEdBQUUsUUFBUSxNQUFSLENBQWUsSUFBZixDQUFxQixHQUFFLElBQUssR0FBekQ7RUFDSDs7RUFDRCxPQUFPLElBQVA7QUFDSCxDQWJEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoXG4gICAgYVswXS5tdWwoYlsxXSkuYWRkKGJbMF0ubXVsKGFbMV0pKSxcbiAgICBhWzFdLm11bChiWzFdKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuXG5mdW5jdGlvbiBjbXAoYSwgYikge1xuICAgIHJldHVybiBhWzBdLm11bChiWzFdKS5jbXAoYlswXS5tdWwoYVsxXSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpdlxuXG5mdW5jdGlvbiBkaXYoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoYVswXS5tdWwoYlsxXSksIGFbMV0ubXVsKGJbMF0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBpc1JhdCA9IHJlcXVpcmUoJy4vaXMtcmF0JylcbnZhciBpc0JOID0gcmVxdWlyZSgnLi9saWIvaXMtYm4nKVxudmFyIG51bTJibiA9IHJlcXVpcmUoJy4vbGliL251bS10by1ibicpXG52YXIgc3RyMmJuID0gcmVxdWlyZSgnLi9saWIvc3RyLXRvLWJuJylcbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcbnZhciBkaXYgPSByZXF1aXJlKCcuL2RpdicpXG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZVJhdGlvbmFsXG5cbmZ1bmN0aW9uIG1ha2VSYXRpb25hbChudW1lciwgZGVub20pIHtcbiAgaWYoaXNSYXQobnVtZXIpKSB7XG4gICAgaWYoZGVub20pIHtcbiAgICAgIHJldHVybiBkaXYobnVtZXIsIG1ha2VSYXRpb25hbChkZW5vbSkpXG4gICAgfVxuICAgIHJldHVybiBbbnVtZXJbMF0uY2xvbmUoKSwgbnVtZXJbMV0uY2xvbmUoKV1cbiAgfVxuICB2YXIgc2hpZnQgPSAwXG4gIHZhciBhLCBiXG4gIGlmKGlzQk4obnVtZXIpKSB7XG4gICAgYSA9IG51bWVyLmNsb25lKClcbiAgfSBlbHNlIGlmKHR5cGVvZiBudW1lciA9PT0gJ3N0cmluZycpIHtcbiAgICBhID0gc3RyMmJuKG51bWVyKVxuICB9IGVsc2UgaWYobnVtZXIgPT09IDApIHtcbiAgICByZXR1cm4gW251bTJibigwKSwgbnVtMmJuKDEpXVxuICB9IGVsc2UgaWYobnVtZXIgPT09IE1hdGguZmxvb3IobnVtZXIpKSB7XG4gICAgYSA9IG51bTJibihudW1lcilcbiAgfSBlbHNlIHtcbiAgICB3aGlsZShudW1lciAhPT0gTWF0aC5mbG9vcihudW1lcikpIHtcbiAgICAgIG51bWVyID0gbnVtZXIgKiBNYXRoLnBvdygyLCAyNTYpXG4gICAgICBzaGlmdCAtPSAyNTZcbiAgICB9XG4gICAgYSA9IG51bTJibihudW1lcilcbiAgfVxuICBpZihpc1JhdChkZW5vbSkpIHtcbiAgICBhLm11bChkZW5vbVsxXSlcbiAgICBiID0gZGVub21bMF0uY2xvbmUoKVxuICB9IGVsc2UgaWYoaXNCTihkZW5vbSkpIHtcbiAgICBiID0gZGVub20uY2xvbmUoKVxuICB9IGVsc2UgaWYodHlwZW9mIGRlbm9tID09PSAnc3RyaW5nJykge1xuICAgIGIgPSBzdHIyYm4oZGVub20pXG4gIH0gZWxzZSBpZighZGVub20pIHtcbiAgICBiID0gbnVtMmJuKDEpXG4gIH0gZWxzZSBpZihkZW5vbSA9PT0gTWF0aC5mbG9vcihkZW5vbSkpIHtcbiAgICBiID0gbnVtMmJuKGRlbm9tKVxuICB9IGVsc2Uge1xuICAgIHdoaWxlKGRlbm9tICE9PSBNYXRoLmZsb29yKGRlbm9tKSkge1xuICAgICAgZGVub20gPSBkZW5vbSAqIE1hdGgucG93KDIsIDI1NilcbiAgICAgIHNoaWZ0ICs9IDI1NlxuICAgIH1cbiAgICBiID0gbnVtMmJuKGRlbm9tKVxuICB9XG4gIGlmKHNoaWZ0ID4gMCkge1xuICAgIGEgPSBhLnVzaGxuKHNoaWZ0KVxuICB9IGVsc2UgaWYoc2hpZnQgPCAwKSB7XG4gICAgYiA9IGIudXNobG4oLXNoaWZ0KVxuICB9XG4gIHJldHVybiByYXRpb25hbGl6ZShhLCBiKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBpc0JOID0gcmVxdWlyZSgnLi9saWIvaXMtYm4nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUmF0XG5cbmZ1bmN0aW9uIGlzUmF0KHgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIgJiYgaXNCTih4WzBdKSAmJiBpc0JOKHhbMV0pXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpZ25cblxuZnVuY3Rpb24gc2lnbiAoeCkge1xuICByZXR1cm4geC5jbXAobmV3IEJOKDApKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBzaWduID0gcmVxdWlyZSgnLi9ibi1zaWduJylcblxubW9kdWxlLmV4cG9ydHMgPSBibjJudW1cblxuLy9UT0RPOiBNYWtlIHRoaXMgYmV0dGVyXG5mdW5jdGlvbiBibjJudW0oYikge1xuICB2YXIgbCA9IGIubGVuZ3RoXG4gIHZhciB3b3JkcyA9IGIud29yZHNcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGwgPT09IDEpIHtcbiAgICBvdXQgPSB3b3Jkc1swXVxuICB9IGVsc2UgaWYgKGwgPT09IDIpIHtcbiAgICBvdXQgPSB3b3Jkc1swXSArICh3b3Jkc1sxXSAqIDB4NDAwMDAwMClcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHcgPSB3b3Jkc1tpXVxuICAgICAgb3V0ICs9IHcgKiBNYXRoLnBvdygweDQwMDAwMDAsIGkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzaWduKGIpICogb3V0XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGRiID0gcmVxdWlyZSgnZG91YmxlLWJpdHMnKVxudmFyIGN0eiA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJykuY291bnRUcmFpbGluZ1plcm9zXG5cbm1vZHVsZS5leHBvcnRzID0gY3R6TnVtYmVyXG5cbi8vQ291bnRzIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGN0ek51bWJlcih4KSB7XG4gIHZhciBsID0gY3R6KGRiLmxvKHgpKVxuICBpZihsIDwgMzIpIHtcbiAgICByZXR1cm4gbFxuICB9XG4gIHZhciBoID0gY3R6KGRiLmhpKHgpKVxuICBpZihoID4gMjApIHtcbiAgICByZXR1cm4gNTJcbiAgfVxuICByZXR1cm4gaCArIDMyXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQk5cblxuLy9UZXN0IGlmIHggaXMgYSBiaWdudW1iZXJcbi8vRklYTUU6IG9idmlvdXNseSB0aGlzIGlzIHRoZSB3cm9uZyB3YXkgdG8gZG8gaXRcbmZ1bmN0aW9uIGlzQk4oeCkge1xuICByZXR1cm4geCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgQm9vbGVhbih4LndvcmRzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBkYiA9IHJlcXVpcmUoJ2RvdWJsZS1iaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBudW0yYm5cblxuZnVuY3Rpb24gbnVtMmJuKHgpIHtcbiAgdmFyIGUgPSBkYi5leHBvbmVudCh4KVxuICBpZihlIDwgNTIpIHtcbiAgICByZXR1cm4gbmV3IEJOKHgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChuZXcgQk4oeCAqIE1hdGgucG93KDIsIDUyLWUpKSkudXNobG4oZS01MilcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBudW0yYm4gPSByZXF1aXJlKCcuL251bS10by1ibicpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gcmF0aW9uYWxpemVcblxuZnVuY3Rpb24gcmF0aW9uYWxpemUobnVtZXIsIGRlbm9tKSB7XG4gIHZhciBzbnVtZXIgPSBzaWduKG51bWVyKVxuICB2YXIgc2Rlbm9tID0gc2lnbihkZW5vbSlcbiAgaWYoc251bWVyID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigxKV1cbiAgfVxuICBpZihzZGVub20gPT09IDApIHtcbiAgICByZXR1cm4gW251bTJibigwKSwgbnVtMmJuKDApXVxuICB9XG4gIGlmKHNkZW5vbSA8IDApIHtcbiAgICBudW1lciA9IG51bWVyLm5lZygpXG4gICAgZGVub20gPSBkZW5vbS5uZWcoKVxuICB9XG4gIHZhciBkID0gbnVtZXIuZ2NkKGRlbm9tKVxuICBpZihkLmNtcG4oMSkpIHtcbiAgICByZXR1cm4gWyBudW1lci5kaXYoZCksIGRlbm9tLmRpdihkKSBdXG4gIH1cbiAgcmV0dXJuIFsgbnVtZXIsIGRlbm9tIF1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyMkJOXG5cbmZ1bmN0aW9uIHN0cjJCTih4KSB7XG4gIHJldHVybiBuZXcgQk4oeClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0aW9uYWxpemUgPSByZXF1aXJlKCcuL2xpYi9yYXRpb25hbGl6ZScpXG5cbm1vZHVsZS5leHBvcnRzID0gbXVsXG5cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gIHJldHVybiByYXRpb25hbGl6ZShhWzBdLm11bChiWzBdKSwgYVsxXS5tdWwoYlsxXSkpXG59XG4iLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4NEJpdHMgKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAvLyAnQScgLSAnRidcbiAgICBpZiAoYyA+PSA2NSAmJiBjIDw9IDcwKSB7XG4gICAgICByZXR1cm4gYyAtIDU1O1xuICAgIC8vICdhJyAtICdmJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA5NyAmJiBjIDw9IDEwMikge1xuICAgICAgcmV0dXJuIGMgLSA4NztcbiAgICAvLyAnMCcgLSAnOSdcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChjIC0gNDgpICYgMHhmO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfTtcblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuICAgIHZhciBiLCBpO1xuICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW2ldID0gYjtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDwgbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5zdHJpcCgpO1xuICAgIH1cbiAgICBhLnN0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIEJOIHY0IGluc3RhbmNlXG4gICAgICAgIHIuc3RyaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHIgaXMgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibnNpZ24gPSByZXF1aXJlKCcuL2xpYi9ibi1zaWduJylcblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4gYm5zaWduKHhbMF0pICogYm5zaWduKHhbMV0pXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YlxuXG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoYVswXS5tdWwoYlsxXSkuc3ViKGFbMV0ubXVsKGJbMF0pKSwgYVsxXS5tdWwoYlsxXSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJuMm51bSA9IHJlcXVpcmUoJy4vbGliL2JuLXRvLW51bScpXG52YXIgY3R6ID0gcmVxdWlyZSgnLi9saWIvY3R6JylcblxubW9kdWxlLmV4cG9ydHMgPSByb3VuZFJhdFxuXG4vLyBSb3VuZCBhIHJhdGlvbmFsIHRvIHRoZSBjbG9zZXN0IGZsb2F0XG5mdW5jdGlvbiByb3VuZFJhdCAoZikge1xuICB2YXIgYSA9IGZbMF1cbiAgdmFyIGIgPSBmWzFdXG4gIGlmIChhLmNtcG4oMCkgPT09IDApIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHZhciBoID0gYS5hYnMoKS5kaXZtb2QoYi5hYnMoKSlcbiAgdmFyIGl2ID0gaC5kaXZcbiAgdmFyIHggPSBibjJudW0oaXYpXG4gIHZhciBpciA9IGgubW9kXG4gIHZhciBzZ24gPSAoYS5uZWdhdGl2ZSAhPT0gYi5uZWdhdGl2ZSkgPyAtMSA6IDFcbiAgaWYgKGlyLmNtcG4oMCkgPT09IDApIHtcbiAgICByZXR1cm4gc2duICogeFxuICB9XG4gIGlmICh4KSB7XG4gICAgdmFyIHMgPSBjdHooeCkgKyA0XG4gICAgdmFyIHkgPSBibjJudW0oaXIudXNobG4ocykuZGl2Um91bmQoYikpXG4gICAgcmV0dXJuIHNnbiAqICh4ICsgeSAqIE1hdGgucG93KDIsIC1zKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgeWJpdHMgPSBiLmJpdExlbmd0aCgpIC0gaXIuYml0TGVuZ3RoKCkgKyA1M1xuICAgIHZhciB5ID0gYm4ybnVtKGlyLnVzaGxuKHliaXRzKS5kaXZSb3VuZChiKSlcbiAgICBpZiAoeWJpdHMgPCAxMDIzKSB7XG4gICAgICByZXR1cm4gc2duICogeSAqIE1hdGgucG93KDIsIC15Yml0cylcbiAgICB9XG4gICAgeSAqPSBNYXRoLnBvdygyLCAtMTAyMylcbiAgICByZXR1cm4gc2duICogeSAqIE1hdGgucG93KDIsIDEwMjMgLSB5Yml0cylcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gKGEsIHksIGMsIGwsIGgpID0gKGFycmF5LCB5WywgY21wLCBsbywgaGldKVxuXG5mdW5jdGlvbiBnZShhLCB5LCBjLCBsLCBoKSB7XG4gIHZhciBpID0gaCArIDE7XG4gIHdoaWxlIChsIDw9IGgpIHtcbiAgICB2YXIgbSA9IChsICsgaCkgPj4+IDEsIHggPSBhW21dO1xuICAgIHZhciBwID0gKGMgIT09IHVuZGVmaW5lZCkgPyBjKHgsIHkpIDogKHggLSB5KTtcbiAgICBpZiAocCA+PSAwKSB7IGkgPSBtOyBoID0gbSAtIDEgfSBlbHNlIHsgbCA9IG0gKyAxIH1cbiAgfVxuICByZXR1cm4gaTtcbn07XG5cbmZ1bmN0aW9uIGd0KGEsIHksIGMsIGwsIGgpIHtcbiAgdmFyIGkgPSBoICsgMTtcbiAgd2hpbGUgKGwgPD0gaCkge1xuICAgIHZhciBtID0gKGwgKyBoKSA+Pj4gMSwgeCA9IGFbbV07XG4gICAgdmFyIHAgPSAoYyAhPT0gdW5kZWZpbmVkKSA/IGMoeCwgeSkgOiAoeCAtIHkpO1xuICAgIGlmIChwID4gMCkgeyBpID0gbTsgaCA9IG0gLSAxIH0gZWxzZSB7IGwgPSBtICsgMSB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBsdChhLCB5LCBjLCBsLCBoKSB7XG4gIHZhciBpID0gbCAtIDE7XG4gIHdoaWxlIChsIDw9IGgpIHtcbiAgICB2YXIgbSA9IChsICsgaCkgPj4+IDEsIHggPSBhW21dO1xuICAgIHZhciBwID0gKGMgIT09IHVuZGVmaW5lZCkgPyBjKHgsIHkpIDogKHggLSB5KTtcbiAgICBpZiAocCA8IDApIHsgaSA9IG07IGwgPSBtICsgMSB9IGVsc2UgeyBoID0gbSAtIDEgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gbGUoYSwgeSwgYywgbCwgaCkge1xuICB2YXIgaSA9IGwgLSAxO1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPD0gMCkgeyBpID0gbTsgbCA9IG0gKyAxIH0gZWxzZSB7IGggPSBtIC0gMSB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBlcShhLCB5LCBjLCBsLCBoKSB7XG4gIHdoaWxlIChsIDw9IGgpIHtcbiAgICB2YXIgbSA9IChsICsgaCkgPj4+IDEsIHggPSBhW21dO1xuICAgIHZhciBwID0gKGMgIT09IHVuZGVmaW5lZCkgPyBjKHgsIHkpIDogKHggLSB5KTtcbiAgICBpZiAocCA9PT0gMCkgeyByZXR1cm4gbSB9XG4gICAgaWYgKHAgPD0gMCkgeyBsID0gbSArIDEgfSBlbHNlIHsgaCA9IG0gLSAxIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5mdW5jdGlvbiBub3JtKGEsIHksIGMsIGwsIGgsIGYpIHtcbiAgaWYgKHR5cGVvZiBjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGYoYSwgeSwgYywgKGwgPT09IHVuZGVmaW5lZCkgPyAwIDogbCB8IDAsIChoID09PSB1bmRlZmluZWQpID8gYS5sZW5ndGggLSAxIDogaCB8IDApO1xuICB9XG4gIHJldHVybiBmKGEsIHksIHVuZGVmaW5lZCwgKGMgPT09IHVuZGVmaW5lZCkgPyAwIDogYyB8IDAsIChsID09PSB1bmRlZmluZWQpID8gYS5sZW5ndGggLSAxIDogbCB8IDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2U6IGZ1bmN0aW9uKGEsIHksIGMsIGwsIGgpIHsgcmV0dXJuIG5vcm0oYSwgeSwgYywgbCwgaCwgZ2UpfSxcbiAgZ3Q6IGZ1bmN0aW9uKGEsIHksIGMsIGwsIGgpIHsgcmV0dXJuIG5vcm0oYSwgeSwgYywgbCwgaCwgZ3QpfSxcbiAgbHQ6IGZ1bmN0aW9uKGEsIHksIGMsIGwsIGgpIHsgcmV0dXJuIG5vcm0oYSwgeSwgYywgbCwgaCwgbHQpfSxcbiAgbGU6IGZ1bmN0aW9uKGEsIHksIGMsIGwsIGgpIHsgcmV0dXJuIG5vcm0oYSwgeSwgYywgbCwgaCwgbGUpfSxcbiAgZXE6IGZ1bmN0aW9uKGEsIHksIGMsIGwsIGgpIHsgcmV0dXJuIG5vcm0oYSwgeSwgYywgbCwgaCwgZXEpfVxufVxuIiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RXcmFwcGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vbGliL3N3ZWVwJylcbnZhciBib3hJbnRlcnNlY3RJdGVyID0gcmVxdWlyZSgnLi9saWIvaW50ZXJzZWN0JylcblxuZnVuY3Rpb24gYm94RW1wdHkoZCwgYm94KSB7XG4gIGZvcih2YXIgaj0wOyBqPGQ7ICsraikge1xuICAgIGlmKCEoYm94W2pdIDw9IGJveFtqK2RdKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vVW5wYWNrIGJveGVzIGludG8gYSBmbGF0IHR5cGVkIGFycmF5LCByZW1vdmUgZW1wdHkgYm94ZXNcbmZ1bmN0aW9uIGNvbnZlcnRCb3hlcyhib3hlcywgZCwgZGF0YSwgaWRzKSB7XG4gIHZhciBwdHIgPSAwXG4gIHZhciBjb3VudCA9IDBcbiAgZm9yKHZhciBpPTAsIG49Ym94ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBiID0gYm94ZXNbaV1cbiAgICBpZihib3hFbXB0eShkLCBiKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8MipkOyArK2opIHtcbiAgICAgIGRhdGFbcHRyKytdID0gYltqXVxuICAgIH1cbiAgICBpZHNbY291bnQrK10gPSBpXG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbi8vUGVyZm9ybSB0eXBlIGNvbnZlcnNpb25zLCBjaGVjayBib3VuZHNcbmZ1bmN0aW9uIGJveEludGVyc2VjdChyZWQsIGJsdWUsIHZpc2l0LCBmdWxsKSB7XG4gIHZhciBuID0gcmVkLmxlbmd0aFxuICB2YXIgbSA9IGJsdWUubGVuZ3RoXG5cbiAgLy9JZiBlaXRoZXIgYXJyYXkgaXMgZW1wdHksIHRoZW4gd2UgY2FuIHNraXAgdGhpcyB3aG9sZSB0aGluZ1xuICBpZihuIDw9IDAgfHwgbSA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0NvbXB1dGUgZGltZW5zaW9uLCBpZiBpdCBpcyAwIHRoZW4gd2Ugc2tpcFxuICB2YXIgZCA9IChyZWRbMF0ubGVuZ3RoKT4+PjFcbiAgaWYoZCA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcmV0dmFsXG5cbiAgLy9Db252ZXJ0IHJlZCBib3hlc1xuICB2YXIgcmVkTGlzdCAgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbilcbiAgdmFyIHJlZElkcyAgID0gcG9vbC5tYWxsb2NJbnQzMihuKVxuICBuID0gY29udmVydEJveGVzKHJlZCwgZCwgcmVkTGlzdCwgcmVkSWRzKVxuXG4gIGlmKG4gPiAwKSB7XG4gICAgaWYoZCA9PT0gMSAmJiBmdWxsKSB7XG4gICAgICAvL1NwZWNpYWwgY2FzZTogMWQgY29tcGxldGVcbiAgICAgIHN3ZWVwLmluaXQobilcbiAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzLFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMpXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy9Db252ZXJ0IGJsdWUgYm94ZXNcbiAgICAgIHZhciBibHVlTGlzdCA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCptKVxuICAgICAgdmFyIGJsdWVJZHMgID0gcG9vbC5tYWxsb2NJbnQzMihtKVxuICAgICAgbSA9IGNvbnZlcnRCb3hlcyhibHVlLCBkLCBibHVlTGlzdCwgYmx1ZUlkcylcblxuICAgICAgaWYobSA+IDApIHtcbiAgICAgICAgc3dlZXAuaW5pdChuK20pXG5cbiAgICAgICAgaWYoZCA9PT0gMSkge1xuICAgICAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBiaXBhcnRpdGVcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgICAgIDAsIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICAwLCBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0dlbmVyYWwgY2FzZTogIGQ+MVxuICAgICAgICAgIHJldHZhbCA9IGJveEludGVyc2VjdEl0ZXIoXG4gICAgICAgICAgICBkLCB2aXNpdCwgICAgZnVsbCxcbiAgICAgICAgICAgIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfVxuXG4gICAgICAgIHBvb2wuZnJlZShibHVlTGlzdClcbiAgICAgICAgcG9vbC5mcmVlKGJsdWVJZHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9vbC5mcmVlKHJlZExpc3QpXG4gICAgcG9vbC5mcmVlKHJlZElkcylcbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuXG52YXIgUkVTVUxUXG5cbmZ1bmN0aW9uIGFwcGVuZEl0ZW0oaSxqKSB7XG4gIFJFU1VMVC5wdXNoKFtpLGpdKVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RGdWxsQXJyYXkoeCkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeCwgYXBwZW5kSXRlbSwgdHJ1ZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheSh4LCB5KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB5LCBhcHBlbmRJdGVtLCBmYWxzZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG4vL1VzZXItZnJpZW5kbHkgd3JhcHBlciwgaGFuZGxlIGZ1bGwgaW5wdXQgYW5kIG5vLXZpc2l0b3IgY2FzZXNcbmZ1bmN0aW9uIGJveEludGVyc2VjdFdyYXBwZXIoYXJnMCwgYXJnMSwgYXJnMikge1xuICB2YXIgcmVzdWx0XG4gIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGludGVyc2VjdEZ1bGxBcnJheShhcmcwKVxuICAgIGNhc2UgMjpcbiAgICAgIGlmKHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMCwgYXJnMSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheShhcmcwLCBhcmcxKVxuICAgICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMSwgYXJnMiwgZmFsc2UpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYm94LWludGVyc2VjdDogSW52YWxpZCBhcmd1bWVudHMnKVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBESU1FTlNJT04gICA9ICdkJ1xudmFyIEFYSVMgICAgICAgID0gJ2F4J1xudmFyIFZJU0lUICAgICAgID0gJ3Z2J1xudmFyIEZMSVAgICAgICAgID0gJ2ZwJ1xuXG52YXIgRUxFTV9TSVpFICAgPSAnZXMnXG5cbnZhciBSRURfU1RBUlQgICA9ICdycydcbnZhciBSRURfRU5EICAgICA9ICdyZSdcbnZhciBSRURfQk9YRVMgICA9ICdyYidcbnZhciBSRURfSU5ERVggICA9ICdyaSdcbnZhciBSRURfUFRSICAgICA9ICdycCdcblxudmFyIEJMVUVfU1RBUlQgID0gJ2JzJ1xudmFyIEJMVUVfRU5EICAgID0gJ2JlJ1xudmFyIEJMVUVfQk9YRVMgID0gJ2JiJ1xudmFyIEJMVUVfSU5ERVggID0gJ2JpJ1xudmFyIEJMVUVfUFRSICAgID0gJ2JwJ1xuXG52YXIgUkVUVkFMICAgICAgPSAncnYnXG5cbnZhciBJTk5FUl9MQUJFTCA9ICdRJ1xuXG52YXIgQVJHUyA9IFtcbiAgRElNRU5TSU9OLFxuICBBWElTLFxuICBWSVNJVCxcbiAgUkVEX1NUQVJULFxuICBSRURfRU5ELFxuICBSRURfQk9YRVMsXG4gIFJFRF9JTkRFWCxcbiAgQkxVRV9TVEFSVCxcbiAgQkxVRV9FTkQsXG4gIEJMVUVfQk9YRVMsXG4gIEJMVUVfSU5ERVhcbl1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIFxuICAgIChyZWRNYWpvciA/ICdSZWQnIDogJ0JsdWUnKSArIFxuICAgIChmbGlwID8gJ0ZsaXAnIDogJycpICtcbiAgICAoZnVsbCA/ICdGdWxsJyA6ICcnKVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnLCBmdW5jTmFtZSwgJygnLCBBUkdTLmpvaW4oKSwgJyl7JyxcbiAgICAndmFyICcsIEVMRU1fU0laRSwgJz0yKicsIERJTUVOU0lPTiwgJzsnXVxuXG4gIHZhciByZWRMb29wID0gXG4gICAgJ2Zvcih2YXIgaT0nICsgUkVEX1NUQVJUICsgJywnICsgUkVEX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIFJFRF9TVEFSVCArICc7JyArXG4gICAgICAgICdpPCcgKyBSRURfRU5EICsnOycgK1xuICAgICAgICAnKytpLCcgKyBSRURfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHgwPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICddLCcgK1xuICAgICAgICAgICAgJ3gxPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgK1xuICAgICAgICAgICAgJ3hpPScgKyBSRURfSU5ERVggKyAnW2ldOydcblxuICB2YXIgYmx1ZUxvb3AgPSBcbiAgICAnZm9yKHZhciBqPScgKyBCTFVFX1NUQVJUICsgJywnICsgQkxVRV9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBCTFVFX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2o8JyArIEJMVUVfRU5EICsgJzsnICtcbiAgICAgICAgJysraiwnICsgQkxVRV9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeTA9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgIChmdWxsID8gJ3kxPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyA6ICcnKSArXG4gICAgICAgICAgICAneWk9JyArIEJMVUVfSU5ERVggKyAnW2pdOydcblxuICBpZihyZWRNYWpvcikge1xuICAgIGNvZGUucHVzaChyZWRMb29wLCBJTk5FUl9MQUJFTCwgJzonLCBibHVlTG9vcClcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goYmx1ZUxvb3AsIElOTkVSX0xBQkVMLCAnOicsIHJlZExvb3ApXG4gIH1cblxuICBpZihmdWxsKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MTx4MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPD14MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdmb3IodmFyIGs9JytBWElTKycrMTtrPCcrRElNRU5TSU9OKyc7KytrKXsnK1xuICAgICd2YXIgcjA9JytSRURfQk9YRVMrJ1trKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAncjE9JytSRURfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytSRURfUFRSKyddLCcrXG4gICAgICAgICdiMD0nK0JMVUVfQk9YRVMrJ1trKycrQkxVRV9QVFIrJ10sJytcbiAgICAgICAgJ2IxPScrQkxVRV9CT1hFUysnW2srJytESU1FTlNJT04rJysnK0JMVUVfUFRSKyddOycrXG4gICAgICAnaWYocjE8YjB8fGIxPHIwKWNvbnRpbnVlICcgKyBJTk5FUl9MQUJFTCArICc7fScgK1xuICAgICAgJ3ZhciAnICsgUkVUVkFMICsgJz0nICsgVklTSVQgKyAnKCcpXG5cbiAgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgneWkseGknKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgneGkseWknKVxuICB9XG5cbiAgY29kZS5wdXNoKCcpO2lmKCcgKyBSRVRWQUwgKyAnIT09dm9pZCAwKXJldHVybiAnICsgUkVUVkFMICsgJzt9fX0nKVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogZnVuY05hbWUsIFxuICAgIGNvZGU6IGNvZGUuam9pbignJylcbiAgfVxufVxuXG5mdW5jdGlvbiBicnV0ZUZvcmNlUGxhbm5lcihmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIChmdWxsID8gJ0Z1bGwnIDogJ1BhcnRpYWwnKVxuICB2YXIgcHJlZml4ID0gW11cbiAgdmFyIGZhcmdzID0gQVJHUy5zbGljZSgpXG4gIGlmKCFmdWxsKSB7XG4gICAgZmFyZ3Muc3BsaWNlKDMsIDAsIEZMSVApXG4gIH1cblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJyArIGZ1bmNOYW1lICsgJygnICsgZmFyZ3Muam9pbigpICsgJyl7J11cblxuICBmdW5jdGlvbiBpbnZva2UocmVkTWFqb3IsIGZsaXApIHtcbiAgICB2YXIgcmVzID0gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKVxuICAgIHByZWZpeC5wdXNoKHJlcy5jb2RlKVxuICAgIGNvZGUucHVzaCgncmV0dXJuICcgKyByZXMubmFtZSArICcoJyArIEFSR1Muam9pbigpICsgJyk7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnaWYoJyArIFJFRF9FTkQgKyAnLScgKyBSRURfU1RBUlQgKyAnPicgK1xuICAgICAgICAgICAgICAgICAgICBCTFVFX0VORCArICctJyArIEJMVUVfU1RBUlQgKyAnKXsnKVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKHRydWUsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ319ZWxzZXtpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKGZhbHNlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfScpXG4gIH1cbiAgY29kZS5wdXNoKCd9fXJldHVybiAnICsgZnVuY05hbWUpXG5cbiAgdmFyIGNvZGVTdHIgPSBwcmVmaXguam9pbignJykgKyBjb2RlLmpvaW4oJycpXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKGNvZGVTdHIpXG4gIHJldHVybiBwcm9jKClcbn1cblxuXG5leHBvcnRzLnBhcnRpYWwgPSBicnV0ZUZvcmNlUGxhbm5lcihmYWxzZSlcbmV4cG9ydHMuZnVsbCAgICA9IGJydXRlRm9yY2VQbGFubmVyKHRydWUpIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0SXRlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBicnV0ZUZvcmNlID0gcmVxdWlyZSgnLi9icnV0ZScpXG52YXIgYnJ1dGVGb3JjZVBhcnRpYWwgPSBicnV0ZUZvcmNlLnBhcnRpYWxcbnZhciBicnV0ZUZvcmNlRnVsbCA9IGJydXRlRm9yY2UuZnVsbFxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9zd2VlcCcpXG52YXIgZmluZE1lZGlhbiA9IHJlcXVpcmUoJy4vbWVkaWFuJylcbnZhciBnZW5QYXJ0aXRpb24gPSByZXF1aXJlKCcuL3BhcnRpdGlvbicpXG5cbi8vVHdpZGRsZSBwYXJhbWV0ZXJzXG52YXIgQlJVVEVfRk9SQ0VfQ1VUT0ZGICAgID0gMTI4ICAgICAgIC8vQ3V0IG9mZiBmb3IgYnJ1dGUgZm9yY2Ugc2VhcmNoXG52YXIgU0NBTl9DVVRPRkYgICAgICAgICAgID0gKDE8PDIyKSAgIC8vQ3V0IG9mZiBmb3IgdHdvIHdheSBzY2FuXG52YXIgU0NBTl9DT01QTEVURV9DVVRPRkYgID0gKDE8PDIyKSAgXG5cbi8vUGFydGl0aW9uIGZ1bmN0aW9uc1xudmFyIHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbCA9IGdlblBhcnRpdGlvbihcbiAgJyEobG8+PXAwKSYmIShwMT49aGkpJywgXG4gIFsncDAnLCAncDEnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0RXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdsbz09PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uRW5kTGVzc1RoYW5FcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2hpPD1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzw9cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG4vL0ZyYW1lIHNpemUgZm9yIGl0ZXJhdGl2ZSBsb29wXG52YXIgSUZSQU1FX1NJWkUgPSA2XG52YXIgREZSQU1FX1NJWkUgPSAyXG5cbi8vRGF0YSBmb3IgYm94IHN0YXRja1xudmFyIElOSVRfQ0FQQUNJVFkgPSAxMDI0XG52YXIgQk9YX0lTVEFDSyAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQk9YX0RTVEFDSyAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZKVxuXG4vL0luaXRpYWxpemUgaXRlcmF0aXZlIGxvb3AgcXVldWVcbmZ1bmN0aW9uIGl0ZXJJbml0KGQsIGNvdW50KSB7XG4gIHZhciBsZXZlbHMgPSAoOCAqIGJpdHMubG9nMihjb3VudCsxKSAqIChkKzEpKXwwXG4gIHZhciBtYXhJbnRzID0gYml0cy5uZXh0UG93MihJRlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9JU1RBQ0subGVuZ3RoIDwgbWF4SW50cykge1xuICAgIHBvb2wuZnJlZShCT1hfSVNUQUNLKVxuICAgIEJPWF9JU1RBQ0sgPSBwb29sLm1hbGxvY0ludDMyKG1heEludHMpXG4gIH1cbiAgdmFyIG1heERvdWJsZXMgPSBiaXRzLm5leHRQb3cyKERGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0RTVEFDSy5sZW5ndGggPCBtYXhEb3VibGVzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9EU1RBQ0spXG4gICAgQk9YX0RTVEFDSyA9IHBvb2wubWFsbG9jRG91YmxlKG1heERvdWJsZXMpXG4gIH1cbn1cblxuLy9BcHBlbmQgaXRlbSB0byBxdWV1ZVxuZnVuY3Rpb24gaXRlclB1c2gocHRyLFxuICBheGlzLCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgXG4gIHN0YXRlLCBcbiAgbG8sIGhpKSB7XG5cbiAgdmFyIGlwdHIgPSBJRlJBTUVfU0laRSAqIHB0clxuICBCT1hfSVNUQUNLW2lwdHJdICAgPSBheGlzXG4gIEJPWF9JU1RBQ0tbaXB0cisxXSA9IHJlZFN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cisyXSA9IHJlZEVuZFxuICBCT1hfSVNUQUNLW2lwdHIrM10gPSBibHVlU3RhcnRcbiAgQk9YX0lTVEFDS1tpcHRyKzRdID0gYmx1ZUVuZFxuICBCT1hfSVNUQUNLW2lwdHIrNV0gPSBzdGF0ZVxuXG4gIHZhciBkcHRyID0gREZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0RTVEFDS1tkcHRyXSAgID0gbG9cbiAgQk9YX0RTVEFDS1tkcHRyKzFdID0gaGlcbn1cblxuLy9TcGVjaWFsIGNhc2U6ICBJbnRlcnNlY3Qgc2luZ2xlIHBvaW50IHdpdGggbGlzdCBvZiBpbnRlcnZhbHNcbmZ1bmN0aW9uIG9uZVBvaW50UGFydGlhbChcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVPZmZzZXQsIGJsdWUsIGJsdWVJZCkge1xuXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBibHVlUHRyICA9IGJsdWVPZmZzZXQgKiBlbGVtU2l6ZVxuICB2YXIgYmx1ZVggICAgPSBibHVlW2JsdWVQdHIgKyBheGlzXVxuXG5yZWRfbG9vcDpcbiAgZm9yKHZhciBpPXJlZFN0YXJ0LCByZWRQdHI9cmVkU3RhcnQqZWxlbVNpemU7IGk8cmVkRW5kOyArK2ksIHJlZFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZihmbGlwICYmIGJsdWVYID09PSByMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbFxuICAgIGlmKGZsaXApIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgfVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IG9uZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludEZ1bGwoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG4gIH1cbn1cblxuLy9UaGUgbWFpbiBib3ggaW50ZXJzZWN0aW9uIHJvdXRpbmVcbmZ1bmN0aW9uIGJveEludGVyc2VjdEl0ZXIoXG4gIGQsIHZpc2l0LCBpbml0RnVsbCxcbiAgeFNpemUsIHhCb3hlcywgeEluZGV4LFxuICB5U2l6ZSwgeUJveGVzLCB5SW5kZXgpIHtcblxuICAvL1Jlc2VydmUgbWVtb3J5IGZvciBzdGFja1xuICBpdGVySW5pdChkLCB4U2l6ZSArIHlTaXplKVxuXG4gIHZhciB0b3AgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgcmV0dmFsXG5cbiAgaXRlclB1c2godG9wKyssXG4gICAgICAwLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIGluaXRGdWxsID8gMTYgOiAwLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIGlmKCFpbml0RnVsbCkge1xuICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHlTaXplLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAxLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIH1cblxuICB3aGlsZSh0b3AgPiAwKSB7XG4gICAgdG9wICAtPSAxXG5cbiAgICB2YXIgaXB0ciA9IHRvcCAqIElGUkFNRV9TSVpFXG4gICAgdmFyIGF4aXMgICAgICA9IEJPWF9JU1RBQ0tbaXB0cl1cbiAgICB2YXIgcmVkU3RhcnQgID0gQk9YX0lTVEFDS1tpcHRyKzFdXG4gICAgdmFyIHJlZEVuZCAgICA9IEJPWF9JU1RBQ0tbaXB0cisyXVxuICAgIHZhciBibHVlU3RhcnQgPSBCT1hfSVNUQUNLW2lwdHIrM11cbiAgICB2YXIgYmx1ZUVuZCAgID0gQk9YX0lTVEFDS1tpcHRyKzRdXG4gICAgdmFyIHN0YXRlICAgICA9IEJPWF9JU1RBQ0tbaXB0cis1XVxuXG4gICAgdmFyIGRwdHIgPSB0b3AgKiBERlJBTUVfU0laRVxuICAgIHZhciBsbyAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHJdXG4gICAgdmFyIGhpICAgICAgICA9IEJPWF9EU1RBQ0tbZHB0cisxXVxuXG4gICAgLy9VbnBhY2sgc3RhdGUgaW5mb1xuICAgIHZhciBmbGlwICAgICAgPSAoc3RhdGUgJiAxKVxuICAgIHZhciBmdWxsICAgICAgPSAhIShzdGF0ZSAmIDE2KVxuXG4gICAgLy9VbnBhY2sgaW5kaWNlc1xuICAgIHZhciByZWQgICAgICAgPSB4Qm94ZXNcbiAgICB2YXIgcmVkSW5kZXggID0geEluZGV4XG4gICAgdmFyIGJsdWUgICAgICA9IHlCb3hlc1xuICAgIHZhciBibHVlSW5kZXggPSB5SW5kZXhcbiAgICBpZihmbGlwKSB7XG4gICAgICByZWQgICAgICAgICA9IHlCb3hlc1xuICAgICAgcmVkSW5kZXggICAgPSB5SW5kZXhcbiAgICAgIGJsdWUgICAgICAgID0geEJveGVzXG4gICAgICBibHVlSW5kZXggICA9IHhJbmRleFxuICAgIH1cblxuICAgIGlmKHN0YXRlICYgMikge1xuICAgICAgcmVkRW5kID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgaGkpXG4gICAgICBpZihyZWRTdGFydCA+PSByZWRFbmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc3RhdGUgJiA0KSB7XG4gICAgICByZWRTdGFydCA9IHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGxvKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciByZWRDb3VudCAgPSByZWRFbmQgIC0gcmVkU3RhcnRcbiAgICB2YXIgYmx1ZUNvdW50ID0gYmx1ZUVuZCAtIGJsdWVTdGFydFxuXG4gICAgaWYoZnVsbCkge1xuICAgICAgaWYoZCAqIHJlZENvdW50ICogKHJlZENvdW50ICsgYmx1ZUNvdW50KSA8IFNDQU5fQ09NUExFVEVfQ1VUT0ZGKSB7XG4gICAgICAgIHJldHZhbCA9IHN3ZWVwLnNjYW5Db21wbGV0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZCAqIE1hdGgubWluKHJlZENvdW50LCBibHVlQ291bnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgc21hbGwsIHRoZW4gdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VQYXJ0aWFsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gICAgICAgICAgICByZWRTdGFydCwgIHJlZEVuZCwgIHJlZCwgIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYoZCAqIHJlZENvdW50ICogYmx1ZUNvdW50IDwgU0NBTl9DVVRPRkYpIHtcbiAgICAgICAgLy9JZiBpbnB1dCBtZWRpdW0gc2l6ZWQsIHRoZW4gdXNlIHN3ZWVwIGFuZCBwcnVuZVxuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQmlwYXJ0aXRlKFxuICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLCBcbiAgICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvL0ZpcnN0LCBmaW5kIGFsbCByZWQgaW50ZXJ2YWxzIHdob3NlIGludGVyaW9yIGNvbnRhaW5zIChsbyxoaSlcbiAgICB2YXIgcmVkMCA9IHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbChcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgIGxvLCBoaSlcblxuICAgIC8vTG93ZXIgZGltZW5zaW9uYWwgY2FzZVxuICAgIGlmKHJlZFN0YXJ0IDwgcmVkMCkge1xuXG4gICAgICBpZihkICogKHJlZDAgLSByZWRTdGFydCkgPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAgICAgLy9TcGVjaWFsIGNhc2UgZm9yIHNtYWxsIGlucHV0czogdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VGdWxsKFxuICAgICAgICAgIGQsIGF4aXMrMSwgdmlzaXQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgfVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcysxLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCxcbiAgICAgICAgICBmbGlwLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsXG4gICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9EaXZpZGUgYW5kIGNvbnF1ZXIgcGhhc2VcbiAgICBpZihyZWQwIDwgcmVkRW5kKSB7XG5cbiAgICAgIC8vQ3V0IGJsdWUgaW50byAzIHBhcnRzOlxuICAgICAgLy9cbiAgICAgIC8vICBQb2ludHMgPCBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPSBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPiBtaWQgcG9pbnRcbiAgICAgIC8vXG4gICAgICB2YXIgYmx1ZTAgPSBmaW5kTWVkaWFuKFxuICAgICAgICBkLCBheGlzLCBcbiAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICB2YXIgbWlkID0gYmx1ZVtlbGVtU2l6ZSAqIGJsdWUwICsgYXhpc11cbiAgICAgIHZhciBibHVlMSA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIGJsdWUwLCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgIG1pZClcblxuICAgICAgLy9SaWdodCBjYXNlXG4gICAgICBpZihibHVlMSA8IGJsdWVFbmQpIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcyxcbiAgICAgICAgICByZWQwLCByZWRFbmQsXG4gICAgICAgICAgYmx1ZTEsIGJsdWVFbmQsXG4gICAgICAgICAgKGZsaXB8NCkgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbWlkLCBoaSlcbiAgICAgIH1cblxuICAgICAgLy9MZWZ0IGNhc2VcbiAgICAgIGlmKGJsdWVTdGFydCA8IGJsdWUwKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZTAsXG4gICAgICAgICAgKGZsaXB8MikgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbG8sIG1pZClcbiAgICAgIH1cblxuICAgICAgLy9DZW50ZXIgY2FzZSAodGhlIGhhcmQgcGFydClcbiAgICAgIGlmKGJsdWUwICsgMSA9PT0gYmx1ZTEpIHtcbiAgICAgICAgLy9PcHRpbWl6YXRpb246IFJhbmdlIHdpdGggZXhhY3RseSAxIHBvaW50LCB1c2UgYSBicnV0ZSBmb3JjZSBzY2FuXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludEZ1bGwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHZhbCA9IG9uZVBvaW50UGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZTAsIGJsdWUsIGJsdWVJbmRleFtibHVlMF0pXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihibHVlMCA8IGJsdWUxKSB7XG4gICAgICAgIHZhciByZWQxXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICAvL0lmIGZ1bGwgaW50ZXJzZWN0aW9uLCBuZWVkIHRvIGhhbmRsZSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBtaWQpXG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIHZhciByZWRYID0gcGFydGl0aW9uU3RhcnRFcXVhbChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgICAgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgICAgICAgIC8vRGVnZW5lcmF0ZSBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkMCwgcmVkWF0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWQwIDwgcmVkWCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vTm9ybWFsIHN3ZWVwIGludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgLy8gIFtyZWRYLCByZWQxXSB3aXRoIFtibHVlMCwgYmx1ZTFdXG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAxNixcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYocmVkWCA8IHJlZDEpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlcihcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50KFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgcmVkMCwgcmVkMSxcbiAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgZmxpcCxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmluZE1lZGlhblxuXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbignbG88cDAnLCBbJ3AwJ10pXG5cbnZhciBQQVJUSVRJT05fVEhSRVNIT0xEID0gOCAgIC8vQ3V0IG9mZiBmb3IgdXNpbmcgaW5zZXJ0aW9uIHNvcnQgaW4gZmluZE1lZGlhblxuXG4vL0Jhc2UgY2FzZSBmb3IgbWVkaWFuIGZpbmRpbmc6ICBVc2UgaW5zZXJ0aW9uIHNvcnRcbmZ1bmN0aW9uIGluc2VydGlvblNvcnQoZCwgYXhpcywgc3RhcnQsIGVuZCwgYm94ZXMsIGlkcykge1xuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYm94UHRyID0gZWxlbVNpemUgKiAoc3RhcnQrMSkgKyBheGlzXG4gIGZvcih2YXIgaT1zdGFydCsxOyBpPGVuZDsgKytpLCBib3hQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHggPSBib3hlc1tib3hQdHJdXG4gICAgZm9yKHZhciBqPWksIHB0cj1lbGVtU2l6ZSooaS0xKTsgXG4gICAgICAgIGo+c3RhcnQgJiYgYm94ZXNbcHRyK2F4aXNdID4geDsgXG4gICAgICAgIC0taiwgcHRyLT1lbGVtU2l6ZSkge1xuICAgICAgLy9Td2FwXG4gICAgICB2YXIgYVB0ciA9IHB0clxuICAgICAgdmFyIGJQdHIgPSBwdHIrZWxlbVNpemVcbiAgICAgIGZvcih2YXIgaz0wOyBrPGVsZW1TaXplOyArK2ssICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICAgIHZhciB5ID0gYm94ZXNbYVB0cl1cbiAgICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgICBib3hlc1tiUHRyXSA9IHlcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBpZHNbal1cbiAgICAgIGlkc1tqXSA9IGlkc1tqLTFdXG4gICAgICBpZHNbai0xXSA9IHRtcFxuICAgIH1cbiAgfVxufVxuXG4vL0ZpbmQgbWVkaWFuIHVzaW5nIHF1aWNrIHNlbGVjdCBhbGdvcml0aG1cbi8vICB0YWtlcyBPKG4pIHRpbWUgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG5mdW5jdGlvbiBmaW5kTWVkaWFuKGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgaWYoZW5kIDw9IHN0YXJ0KzEpIHtcbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIHZhciBsbyAgICAgICA9IHN0YXJ0XG4gIHZhciBoaSAgICAgICA9IGVuZFxuICB2YXIgbWlkICAgICAgPSAoKGVuZCArIHN0YXJ0KSA+Pj4gMSlcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBwaXZvdCAgICA9IG1pZFxuICB2YXIgdmFsdWUgICAgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgXG4gIHdoaWxlKGxvIDwgaGkpIHtcbiAgICBpZihoaSAtIGxvIDwgUEFSVElUSU9OX1RIUkVTSE9MRCkge1xuICAgICAgaW5zZXJ0aW9uU29ydChkLCBheGlzLCBsbywgaGksIGJveGVzLCBpZHMpXG4gICAgICB2YWx1ZSA9IGJveGVzW2VsZW1TaXplKm1pZCtheGlzXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgLy9TZWxlY3QgcGl2b3QgdXNpbmcgbWVkaWFuLW9mLTNcbiAgICB2YXIgY291bnQgID0gaGkgLSBsb1xuICAgIHZhciBwaXZvdDAgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTAgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDAgKyBheGlzXVxuICAgIHZhciBwaXZvdDEgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTEgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDEgKyBheGlzXVxuICAgIHZhciBwaXZvdDIgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTIgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDIgKyBheGlzXVxuICAgIGlmKHZhbHVlMCA8PSB2YWx1ZTEpIHtcbiAgICAgIGlmKHZhbHVlMiA+PSB2YWx1ZTEpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTFcbiAgICAgIH0gZWxzZSBpZih2YWx1ZTAgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QwXG4gICAgICAgIHZhbHVlID0gdmFsdWUwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXZvdCA9IHBpdm90MlxuICAgICAgICB2YWx1ZSA9IHZhbHVlMlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih2YWx1ZTEgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUyID49IHZhbHVlMCkge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1N3YXAgcGl2b3QgdG8gZW5kIG9mIGFycmF5XG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vUGFydGl0aW9uIHVzaW5nIHBpdm90XG4gICAgcGl2b3QgPSBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgICAgZCwgYXhpcywgXG4gICAgICBsbywgaGktMSwgYm94ZXMsIGlkcyxcbiAgICAgIHZhbHVlKVxuXG4gICAgLy9Td2FwIHBpdm90IGJhY2tcbiAgICB2YXIgYVB0ciA9IGVsZW1TaXplICogKGhpLTEpXG4gICAgdmFyIGJQdHIgPSBlbGVtU2l6ZSAqIHBpdm90XG4gICAgZm9yKHZhciBpPTA7IGk8ZWxlbVNpemU7ICsraSwgKythUHRyLCArK2JQdHIpIHtcbiAgICAgIHZhciB4ID0gYm94ZXNbYVB0cl1cbiAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgIGJveGVzW2JQdHJdID0geFxuICAgIH1cbiAgICB2YXIgeSA9IGlkc1toaS0xXVxuICAgIGlkc1toaS0xXSA9IGlkc1twaXZvdF1cbiAgICBpZHNbcGl2b3RdID0geVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGxhc3QgcGl2b3RcbiAgICBpZihtaWQgPCBwaXZvdCkge1xuICAgICAgaGkgPSBwaXZvdC0xXG4gICAgICB3aGlsZShsbyA8IGhpICYmIFxuICAgICAgICBib3hlc1tlbGVtU2l6ZSooaGktMSkrYXhpc10gPT09IHZhbHVlKSB7XG4gICAgICAgIGhpIC09IDFcbiAgICAgIH1cbiAgICAgIGhpICs9IDFcbiAgICB9IGVsc2UgaWYocGl2b3QgPCBtaWQpIHtcbiAgICAgIGxvID0gcGl2b3QgKyAxXG4gICAgICB3aGlsZShsbyA8IGhpICYmXG4gICAgICAgIGJveGVzW2VsZW1TaXplKmxvK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBsbyArPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy9NYWtlIHN1cmUgcGl2b3QgaXMgYXQgc3RhcnRcbiAgcmV0dXJuIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgZCwgYXhpcywgXG4gICAgc3RhcnQsIG1pZCwgYm94ZXMsIGlkcyxcbiAgICBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc10pXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuUGFydGl0aW9uXG5cbnZhciBjb2RlID0gJ2Zvcih2YXIgaj0yKmEsaz1qKmMsbD1rLG09YyxuPWIsbz1hK2IscD1jO2Q+cDsrK3Asays9ail7dmFyIF87aWYoJClpZihtPT09cCltKz0xLGwrPWo7ZWxzZXtmb3IodmFyIHM9MDtqPnM7KytzKXt2YXIgdD1lW2src107ZVtrK3NdPWVbbF0sZVtsKytdPXR9dmFyIHU9ZltwXTtmW3BdPWZbbV0sZlttKytdPXV9fXJldHVybiBtJ1xuXG5mdW5jdGlvbiBnZW5QYXJ0aXRpb24ocHJlZGljYXRlLCBhcmdzKSB7XG4gIHZhciBmYXJncyA9J2FiY2RlZicuc3BsaXQoJycpLmNvbmNhdChhcmdzKVxuICB2YXIgcmVhZHMgPSBbXVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignbG8nKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnbG89ZVtrK25dJylcbiAgfVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignaGknKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnaGk9ZVtrK29dJylcbiAgfVxuICBmYXJncy5wdXNoKFxuICAgIGNvZGUucmVwbGFjZSgnXycsIHJlYWRzLmpvaW4oKSlcbiAgICAgICAgLnJlcGxhY2UoJyQnLCBwcmVkaWNhdGUpKVxuICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodm9pZCAwLCBmYXJncylcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBjb2RlIGlzIGV4dHJhY3RlZCBmcm9tIG5kYXJyYXktc29ydFxuLy9JdCBpcyBpbmxpbmVkIGhlcmUgYXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZXI7XG5cbnZhciBJTlNFUlRfU09SVF9DVVRPRkYgPSAzMlxuXG5mdW5jdGlvbiB3cmFwcGVyKGRhdGEsIG4wKSB7XG4gIGlmIChuMCA8PSA0KklOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGxlZnQsIHJpZ2h0LCBkYXRhKSB7XG4gIHZhciBwdHIgPSAyKihsZWZ0KzEpXG4gIGZvcih2YXIgaT1sZWZ0KzE7IGk8PXJpZ2h0OyArK2kpIHtcbiAgICB2YXIgYSA9IGRhdGFbcHRyKytdXG4gICAgdmFyIGIgPSBkYXRhW3B0cisrXVxuICAgIHZhciBqID0gaVxuICAgIHZhciBqcHRyID0gcHRyLTJcbiAgICB3aGlsZShqLS0gPiBsZWZ0KSB7XG4gICAgICB2YXIgeCA9IGRhdGFbanB0ci0yXVxuICAgICAgdmFyIHkgPSBkYXRhW2pwdHItMV1cbiAgICAgIGlmKHggPCBhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYoeCA9PT0gYSAmJiB5IDwgYikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGF0YVtqcHRyXSAgID0geFxuICAgICAgZGF0YVtqcHRyKzFdID0geVxuICAgICAganB0ciAtPSAyXG4gICAgfVxuICAgIGRhdGFbanB0cl0gICA9IGFcbiAgICBkYXRhW2pwdHIrMV0gPSBiXG4gIH1cbn1cblxuZnVuY3Rpb24gc3dhcChpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0geFxuICBkYXRhW2orMV0gPSB5XG59XG5cbmZ1bmN0aW9uIG1vdmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxufVxuXG5mdW5jdGlvbiByb3RhdGUoaSwgaiwgaywgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGsgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgdmFyIHkgPSBkYXRhW2krMV1cbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbal0gPSBkYXRhW2tdXG4gIGRhdGFbaisxXSA9IGRhdGFbaysxXVxuICBkYXRhW2tdID0geFxuICBkYXRhW2srMV0gPSB5XG59XG5cbmZ1bmN0aW9uIHNodWZmbGVQaXZvdChpLCBqLCBweCwgcHksIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2pdID0gcHhcbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbaisxXSA9IHB5XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXSxcbiAgICAgIHkgPSBkYXRhW2pdXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIGRhdGFbaSsxXSA+IGRhdGFbaisxXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVQaXZvdChpLCB5LCBiLCBkYXRhKSB7XG4gIGkgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgaWYoeCA8IHkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPCBiXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHF1aWNrU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgc2l4dGggPSAocmlnaHQgLSBsZWZ0ICsgMSkgLyA2IHwgMCwgXG4gICAgICBpbmRleDEgPSBsZWZ0ICsgc2l4dGgsIFxuICAgICAgaW5kZXg1ID0gcmlnaHQgLSBzaXh0aCwgXG4gICAgICBpbmRleDMgPSBsZWZ0ICsgcmlnaHQgPj4gMSwgXG4gICAgICBpbmRleDIgPSBpbmRleDMgLSBzaXh0aCwgXG4gICAgICBpbmRleDQgPSBpbmRleDMgKyBzaXh0aCwgXG4gICAgICBlbDEgPSBpbmRleDEsIFxuICAgICAgZWwyID0gaW5kZXgyLCBcbiAgICAgIGVsMyA9IGluZGV4MywgXG4gICAgICBlbDQgPSBpbmRleDQsIFxuICAgICAgZWw1ID0gaW5kZXg1LCBcbiAgICAgIGxlc3MgPSBsZWZ0ICsgMSwgXG4gICAgICBncmVhdCA9IHJpZ2h0IC0gMSwgXG4gICAgICB0bXAgPSAwXG4gIGlmKGNvbXBhcmUoZWwxLCBlbDIsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWwyXG4gICAgZWwyID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMSwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMywgZWw0LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsM1xuICAgIGVsMyA9IGVsNFxuICAgIGVsNCA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsNCwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsNFxuICAgIGVsNCA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG5cbiAgdmFyIHBpdm90MVggPSBkYXRhWzIqZWwyXVxuICB2YXIgcGl2b3QxWSA9IGRhdGFbMiplbDIrMV1cbiAgdmFyIHBpdm90MlggPSBkYXRhWzIqZWw0XVxuICB2YXIgcGl2b3QyWSA9IGRhdGFbMiplbDQrMV1cblxuICB2YXIgcHRyMCA9IDIgKiBlbDE7XG4gIHZhciBwdHIyID0gMiAqIGVsMztcbiAgdmFyIHB0cjQgPSAyICogZWw1O1xuICB2YXIgcHRyNSA9IDIgKiBpbmRleDE7XG4gIHZhciBwdHI2ID0gMiAqIGluZGV4MztcbiAgdmFyIHB0cjcgPSAyICogaW5kZXg1O1xuICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgMjsgKytpMSkge1xuICAgIHZhciB4ID0gZGF0YVtwdHIwK2kxXTtcbiAgICB2YXIgeSA9IGRhdGFbcHRyMitpMV07XG4gICAgdmFyIHogPSBkYXRhW3B0cjQraTFdO1xuICAgIGRhdGFbcHRyNStpMV0gPSB4O1xuICAgIGRhdGFbcHRyNitpMV0gPSB5O1xuICAgIGRhdGFbcHRyNytpMV0gPSB6O1xuICB9XG5cbiAgbW92ZShpbmRleDIsIGxlZnQsIGRhdGEpXG4gIG1vdmUoaW5kZXg0LCByaWdodCwgZGF0YSlcbiAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7ICsraykge1xuICAgIGlmIChjb21wYXJlUGl2b3QoaywgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgIGlmIChrICE9PSBsZXNzKSB7XG4gICAgICAgIHN3YXAoaywgbGVzcywgZGF0YSlcbiAgICAgIH1cbiAgICAgICsrbGVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjb21wYXJlUGl2b3QoaywgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICgtLWdyZWF0IDwgaykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVBpdm90KGdyZWF0LCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKSkge1xuICAgICAgICAgICAgICByb3RhdGUoaywgbGVzcywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgICsrbGVzcztcbiAgICAgICAgICAgICAgLS1ncmVhdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3YXAoaywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2h1ZmZsZVBpdm90KGxlZnQsIGxlc3MtMSwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSlcbiAgc2h1ZmZsZVBpdm90KHJpZ2h0LCBncmVhdCsxLCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKVxuICBpZiAobGVzcyAtIDIgLSBsZWZ0IDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChsZWZ0LCBsZXNzIC0gMiwgZGF0YSk7XG4gIH1cbiAgaWYgKHJpZ2h0IC0gKGdyZWF0ICsgMikgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChncmVhdCArIDIsIHJpZ2h0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH1cbiAgaWYgKGdyZWF0IC0gbGVzcyA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVzcywgZ3JlYXQsIGRhdGEpO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiAgICAgICAgICAgc3FJbml0LFxuICBzd2VlcEJpcGFydGl0ZTogc3dlZXBCaXBhcnRpdGUsXG4gIHN3ZWVwQ29tcGxldGU6ICBzd2VlcENvbXBsZXRlLFxuICBzY2FuQmlwYXJ0aXRlOiAgc2NhbkJpcGFydGl0ZSxcbiAgc2NhbkNvbXBsZXRlOiAgIHNjYW5Db21wbGV0ZVxufVxuXG52YXIgcG9vbCAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGlzb3J0ID0gcmVxdWlyZSgnLi9zb3J0JylcblxuLy9GbGFnIGZvciBibHVlXG52YXIgQkxVRV9GTEFHID0gKDE8PDI4KVxuXG4vLzFEIHN3ZWVwIGV2ZW50IHF1ZXVlIHN0dWZmICh1c2UgcG9vbCB0byBzYXZlIHNwYWNlKVxudmFyIElOSVRfQ0FQQUNJVFkgICAgICA9IDEwMjRcbnZhciBSRURfU1dFRVBfUVVFVUUgICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgUkVEX1NXRUVQX0lOREVYICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJMVUVfU1dFRVBfUVVFVUUgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX0lOREVYICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBTV0VFUF9FVkVOVFMgICAgICAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZICogOClcblxuLy9SZXNlcnZlcyBtZW1vcnkgZm9yIHRoZSAxRCBzd2VlcCBkYXRhIHN0cnVjdHVyZXNcbmZ1bmN0aW9uIHNxSW5pdChjb3VudCkge1xuICB2YXIgcmNvdW50ID0gYml0cy5uZXh0UG93Mihjb3VudClcbiAgaWYoUkVEX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfUVVFVUUpXG4gICAgUkVEX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoUkVEX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfSU5ERVgpXG4gICAgUkVEX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9RVUVVRSlcbiAgICBCTFVFX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9JTkRFWClcbiAgICBCTFVFX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfUVVFVUUpXG4gICAgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfSU5ERVgpXG4gICAgQ09NTU9OX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgdmFyIGV2ZW50TGVuZ3RoID0gOCAqIHJjb3VudFxuICBpZihTV0VFUF9FVkVOVFMubGVuZ3RoIDwgZXZlbnRMZW5ndGgpIHtcbiAgICBwb29sLmZyZWUoU1dFRVBfRVZFTlRTKVxuICAgIFNXRUVQX0VWRU5UUyA9IHBvb2wubWFsbG9jRG91YmxlKGV2ZW50TGVuZ3RoKVxuICB9XG59XG5cbi8vUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUG9wKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgdmFyIGlkeCA9IGluZGV4W2l0ZW1dXG4gIHZhciB0b3AgPSBxdWV1ZVtjb3VudC0xXVxuICBxdWV1ZVtpZHhdID0gdG9wXG4gIGluZGV4W3RvcF0gPSBpZHhcbn1cblxuLy9JbnNlcnQgYW4gaXRlbSBpbnRvIHRoZSBhY3RpdmUgcXVldWUgaW4gTygxKVxuZnVuY3Rpb24gc3FQdXNoKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgcXVldWVbY291bnRdID0gaXRlbVxuICBpbmRleFtpdGVtXSAgPSBjb3VudFxufVxuXG4vL1JlY3Vyc2lvbiBiYXNlIGNhc2U6IHVzZSAxRCBzd2VlcCBhbGdvcml0aG1cbmZ1bmN0aW9uIHN3ZWVwQmlwYXJ0aXRlKFxuICAgIGQsIHZpc2l0LFxuICAgIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgLy9zdG9yZSBldmVudHMgYXMgcGFpcnMgW2Nvb3JkaW5hdGUsIGlkeF1cbiAgLy9cbiAgLy8gIHJlZCBjcmVhdGU6ICAtKGlkeCsxKVxuICAvLyAgcmVkIGRlc3Ryb3k6IGlkeFxuICAvLyAgYmx1ZSBjcmVhdGU6IC0oaWR4K0JMVUVfRkxBRylcbiAgLy8gIGJsdWUgZGVzdHJveTogaWR4K0JMVUVfRkxBR1xuICAvL1xuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSByZWRJbmRleFtpXVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtKGlkeCsxKVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gYmx1ZUluZGV4W2ldK0JMVUVfRkxBR1xuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICA9IDBcbiAgdmFyIGJsdWVBY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBkZXN0cm95IGV2ZW50XG4gICAgICBlID0gKGUtQkxVRV9GTEFHKXwwXG4gICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGUpXG4gICAgfSBlbHNlIGlmKGUgPj0gMCkge1xuICAgICAgLy9yZWQgZGVzdHJveSBldmVudFxuICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlIDw9IC1CTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBjcmVhdGUgZXZlbnRcbiAgICAgIGUgPSAoLWUtQkxVRV9GTEFHKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBlKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FQdXNoKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUrKywgZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZWQgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLTEpfDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGJsdWVBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoZSwgQkxVRV9TV0VFUF9RVUVVRVtqXSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGUpXG4gICAgfVxuICB9XG59XG5cbi8vQ29tcGxldGUgc3dlZXBcbmZ1bmN0aW9uIHN3ZWVwQ29tcGxldGUoZCwgdmlzaXQsIFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGQtMVxuICB2YXIgaWVuZCAgICAgPSBlbGVtU2l6ZS0xXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChyZWRJbmRleFtpXSsxKTw8MVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAoYmx1ZUluZGV4W2ldKzEpPDwxXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9ICgtaWR4KXwxXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHh8MVxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIHZhciBibHVlQWN0aXZlICAgPSAwXG4gIHZhciBjb21tb25BY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlICAgICA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIHZhciBjb2xvciA9IGUmMVxuICAgIGlmKGkgPCBuLTEgJiYgKGU+PjEpID09PSAoU1dFRVBfRVZFTlRTWzIqaSszXT4+MSkpIHtcbiAgICAgIGNvbG9yID0gMlxuICAgICAgaSArPSAxXG4gICAgfVxuICAgIFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICAvL0NyZWF0ZSBldmVudFxuICAgICAgdmFyIGlkID0gLShlPj4xKSAtIDFcblxuICAgICAgLy9JbnRlcnNlY3Qgd2l0aCBjb21tb25cbiAgICAgIGZvcih2YXIgaj0wOyBqPGNvbW1vbkFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChDT01NT05fU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMCkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIHJlZFxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChSRURfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yICE9PSAxKSB7XG4gICAgICAgIC8vSW50ZXJzZWN0IHdpdGggYmx1ZVxuICAgICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQkxVRV9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDEpIHtcbiAgICAgICAgLy9CbHVlXG4gICAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVB1c2goQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZSsrLCBpZClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9EZXN0cm95IGV2ZW50XG4gICAgICB2YXIgaWQgPSAoZT4+MSkgLSAxXG4gICAgICBpZihjb2xvciA9PT0gMCkge1xuICAgICAgICAvL1JlZFxuICAgICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVBvcChDT01NT05fU1dFRVBfUVVFVUUsIENPTU1PTl9TV0VFUF9JTkRFWCwgY29tbW9uQWN0aXZlLS0sIGlkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1N3ZWVwIGFuZCBwcnVuZS9zY2FubGluZSBhbGdvcml0aG06XG4vLyAgU2NhbiBhbG9uZyBheGlzLCBkZXRlY3QgaW50ZXJzZWN0aW9uc1xuLy8gIEJydXRlIGZvcmNlIGFsbCBib3hlcyBhbG9uZyBheGlzXG5mdW5jdGlvbiBzY2FuQmlwYXJ0aXRlKFxuICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG4gIFxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIHZhciByZWRTaGlmdCAgPSAxXG4gIHZhciBibHVlU2hpZnQgPSAxXG4gIGlmKGZsaXApIHtcbiAgICBibHVlU2hpZnQgPSBCTFVFX0ZMQUdcbiAgfSBlbHNlIHtcbiAgICByZWRTaGlmdCAgPSBCTFVFX0ZMQUdcbiAgfVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgcmVkU2hpZnRcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyBibHVlU2hpZnRcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICB2YXIgaXNSZWQgPSBmYWxzZVxuICAgICAgaWYoaWR4ID49IEJMVUVfRkxBRykge1xuICAgICAgICBpc1JlZCA9ICFmbGlwXG4gICAgICAgIGlkeCAtPSBCTFVFX0ZMQUcgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1JlZCA9ICEhZmxpcFxuICAgICAgICBpZHggLT0gMVxuICAgICAgfVxuICAgICAgaWYoaXNSZWQpIHtcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWR4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG4gICAgICAgIFxuICAgICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIrYXhpcysxXVxuICAgICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIrYXhpcysxK2RdXG5cbnJlZF9sb29wOlxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciBvaWR4ICAgPSBSRURfU1dFRVBfUVVFVUVbal1cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG5cbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkSWQgID0gcmVkSW5kZXhbb2lkeF1cbiAgICAgICAgICB2YXIgcmV0dmFsXG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQoYmx1ZUlkLCByZWRJZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSAtIHJlZFNoaWZ0KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FuQ29tcGxldGUoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgQkxVRV9GTEFHXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgMVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlIDwgMCkge1xuICAgICAgdmFyIGlkeCAgID0gLWVcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgUkVEX1NXRUVQX1FVRVVFW3JlZEFjdGl2ZSsrXSA9IGlkeCAtIEJMVUVfRkxBR1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4IC09IDFcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG5cbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG5cbiAgICAgICAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWRQdHIgPSBlbGVtU2l6ZSAqIG9pZHhcbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgIHJlZFtyZWRQdHIrYXhpcysxK2RdIDwgYjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdICAgPCBibHVlW2JsdWVQdHIgKyBrXSkge1xuICAgICAgICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWR4ID0gZSAtIEJMVUVfRkxBR1xuICAgICAgZm9yKHZhciBqPXJlZEFjdGl2ZS0xOyBqPj0wOyAtLWopIHtcbiAgICAgICAgaWYoUkVEX1NXRUVQX1FVRVVFW2pdID09PSBpZHgpIHtcbiAgICAgICAgICBmb3IodmFyIGs9aisxOyBrPHJlZEFjdGl2ZTsgKytrKSB7XG4gICAgICAgICAgICBSRURfU1dFRVBfUVVFVUVbay0xXSA9IFJFRF9TV0VFUF9RVUVVRVtrXVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAtLXJlZEFjdGl2ZVxuICAgIH1cbiAgfVxufSIsIiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBtb25vdG9uZVRyaWFuZ3VsYXRlID0gcmVxdWlyZSgnLi9saWIvbW9ub3RvbmUnKVxudmFyIG1ha2VJbmRleCA9IHJlcXVpcmUoJy4vbGliL3RyaWFuZ3VsYXRpb24nKVxudmFyIGRlbGF1bmF5RmxpcCA9IHJlcXVpcmUoJy4vbGliL2RlbGF1bmF5JylcbnZhciBmaWx0ZXJUcmlhbmd1bGF0aW9uID0gcmVxdWlyZSgnLi9saWIvZmlsdGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBjZHQyZFxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVFZGdlKGUpIHtcbiAgcmV0dXJuIFtNYXRoLm1pbihlWzBdLCBlWzFdKSwgTWF0aC5tYXgoZVswXSwgZVsxXSldXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVFZGdlKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0tYlswXSB8fCBhWzFdLWJbMV1cbn1cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplRWRnZXMoZWRnZXMpIHtcbiAgcmV0dXJuIGVkZ2VzLm1hcChjYW5vbmljYWxpemVFZGdlKS5zb3J0KGNvbXBhcmVFZGdlKVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0KG9wdGlvbnMsIHByb3BlcnR5LCBkZmx0KSB7XG4gIGlmKHByb3BlcnR5IGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9uc1twcm9wZXJ0eV1cbiAgfVxuICByZXR1cm4gZGZsdFxufVxuXG5mdW5jdGlvbiBjZHQyZChwb2ludHMsIGVkZ2VzLCBvcHRpb25zKSB7XG5cbiAgaWYoIUFycmF5LmlzQXJyYXkoZWRnZXMpKSB7XG4gICAgb3B0aW9ucyA9IGVkZ2VzIHx8IHt9XG4gICAgZWRnZXMgPSBbXVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgZWRnZXMgPSBlZGdlcyB8fCBbXVxuICB9XG5cbiAgLy9QYXJzZSBvdXQgb3B0aW9uc1xuICB2YXIgZGVsYXVuYXkgPSAhIWdldERlZmF1bHQob3B0aW9ucywgJ2RlbGF1bmF5JywgdHJ1ZSlcbiAgdmFyIGludGVyaW9yID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdpbnRlcmlvcicsIHRydWUpXG4gIHZhciBleHRlcmlvciA9ICEhZ2V0RGVmYXVsdChvcHRpb25zLCAnZXh0ZXJpb3InLCB0cnVlKVxuICB2YXIgaW5maW5pdHkgPSAhIWdldERlZmF1bHQob3B0aW9ucywgJ2luZmluaXR5JywgZmFsc2UpXG5cbiAgLy9IYW5kbGUgdHJpdmlhbCBjYXNlXG4gIGlmKCghaW50ZXJpb3IgJiYgIWV4dGVyaW9yKSB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvL0NvbnN0cnVjdCBpbml0aWFsIHRyaWFuZ3VsYXRpb25cbiAgdmFyIGNlbGxzID0gbW9ub3RvbmVUcmlhbmd1bGF0ZShwb2ludHMsIGVkZ2VzKVxuXG4gIC8vSWYgZGVsYXVuYXkgcmVmaW5lbWVudCBuZWVkZWQsIHRoZW4gaW1wcm92ZSBxdWFsaXR5IGJ5IGVkZ2UgZmxpcHBpbmdcbiAgaWYoZGVsYXVuYXkgfHwgaW50ZXJpb3IgIT09IGV4dGVyaW9yIHx8IGluZmluaXR5KSB7XG5cbiAgICAvL0luZGV4IGFsbCBvZiB0aGUgY2VsbHMgdG8gc3VwcG9ydCBmYXN0IG5laWdoYm9yaG9vZCBxdWVyaWVzXG4gICAgdmFyIHRyaWFuZ3VsYXRpb24gPSBtYWtlSW5kZXgocG9pbnRzLmxlbmd0aCwgY2Fub25pY2FsaXplRWRnZXMoZWRnZXMpKVxuICAgIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZiA9IGNlbGxzW2ldXG4gICAgICB0cmlhbmd1bGF0aW9uLmFkZFRyaWFuZ2xlKGZbMF0sIGZbMV0sIGZbMl0pXG4gICAgfVxuXG4gICAgLy9SdW4gZWRnZSBmbGlwcGluZ1xuICAgIGlmKGRlbGF1bmF5KSB7XG4gICAgICBkZWxhdW5heUZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uKVxuICAgIH1cblxuICAgIC8vRmlsdGVyIHBvaW50c1xuICAgIGlmKCFleHRlcmlvcikge1xuICAgICAgcmV0dXJuIGZpbHRlclRyaWFuZ3VsYXRpb24odHJpYW5ndWxhdGlvbiwgLTEpXG4gICAgfSBlbHNlIGlmKCFpbnRlcmlvcikge1xuICAgICAgcmV0dXJuIGZpbHRlclRyaWFuZ3VsYXRpb24odHJpYW5ndWxhdGlvbiwgIDEsIGluZmluaXR5KVxuICAgIH0gZWxzZSBpZihpbmZpbml0eSkge1xuICAgICAgcmV0dXJuIGZpbHRlclRyaWFuZ3VsYXRpb24odHJpYW5ndWxhdGlvbiwgMCwgaW5maW5pdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmlhbmd1bGF0aW9uLmNlbGxzKClcbiAgICB9XG4gICAgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNlbGxzXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaW5DaXJjbGUgPSByZXF1aXJlKCdyb2J1c3QtaW4tc3BoZXJlJylbNF1cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlbGF1bmF5UmVmaW5lXG5cbmZ1bmN0aW9uIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIGEsIGIsIHgpIHtcbiAgdmFyIHkgPSB0cmlhbmd1bGF0aW9uLm9wcG9zaXRlKGEsIGIpXG5cbiAgLy9UZXN0IGJvdW5kYXJ5IGVkZ2VcbiAgaWYoeSA8IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vU3dhcCBlZGdlIGlmIG9yZGVyIGZsaXBwZWRcbiAgaWYoYiA8IGEpIHtcbiAgICB2YXIgdG1wID0gYVxuICAgIGEgPSBiXG4gICAgYiA9IHRtcFxuICAgIHRtcCA9IHhcbiAgICB4ID0geVxuICAgIHkgPSB0bXBcbiAgfVxuXG4gIC8vVGVzdCBpZiBlZGdlIGlzIGNvbnN0cmFpbmVkXG4gIGlmKHRyaWFuZ3VsYXRpb24uaXNDb25zdHJhaW50KGEsIGIpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL1Rlc3QgaWYgZWRnZSBpcyBkZWxhdW5heVxuICBpZihpbkNpcmNsZShwb2ludHNbYV0sIHBvaW50c1tiXSwgcG9pbnRzW3hdLCBwb2ludHNbeV0pIDwgMCkge1xuICAgIHN0YWNrLnB1c2goYSwgYilcbiAgfVxufVxuXG4vL0Fzc3VtZSBlZGdlcyBhcmUgc29ydGVkIGxleGljb2dyYXBoaWNhbGx5XG5mdW5jdGlvbiBkZWxhdW5heVJlZmluZShwb2ludHMsIHRyaWFuZ3VsYXRpb24pIHtcbiAgdmFyIHN0YWNrID0gW11cblxuICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aFxuICB2YXIgc3RhcnMgPSB0cmlhbmd1bGF0aW9uLnN0YXJzXG4gIGZvcih2YXIgYT0wOyBhPG51bVBvaW50czsgKythKSB7XG4gICAgdmFyIHN0YXIgPSBzdGFyc1thXVxuICAgIGZvcih2YXIgaj0xOyBqPHN0YXIubGVuZ3RoOyBqKz0yKSB7XG4gICAgICB2YXIgYiA9IHN0YXJbal1cblxuICAgICAgLy9JZiBvcmRlciBpcyBub3QgY29uc2lzdGVudCwgdGhlbiBza2lwIGVkZ2VcbiAgICAgIGlmKGIgPCBhKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vQ2hlY2sgaWYgZWRnZSBpcyBjb25zdHJhaW5lZFxuICAgICAgaWYodHJpYW5ndWxhdGlvbi5pc0NvbnN0cmFpbnQoYSwgYikpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy9GaW5kIG9wcG9zaXRlIGVkZ2VcbiAgICAgIHZhciB4ID0gc3RhcltqLTFdLCB5ID0gLTFcbiAgICAgIGZvcih2YXIgaz0xOyBrPHN0YXIubGVuZ3RoOyBrKz0yKSB7XG4gICAgICAgIGlmKHN0YXJbay0xXSA9PT0gYikge1xuICAgICAgICAgIHkgPSBzdGFyW2tdXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL0lmIHRoaXMgaXMgYSBib3VuZGFyeSBlZGdlLCBkb24ndCBmbGlwIGl0XG4gICAgICBpZih5IDwgMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvL0lmIGVkZ2UgaXMgaW4gY2lyY2xlLCBmbGlwIGl0XG4gICAgICBpZihpbkNpcmNsZShwb2ludHNbYV0sIHBvaW50c1tiXSwgcG9pbnRzW3hdLCBwb2ludHNbeV0pIDwgMCkge1xuICAgICAgICBzdGFjay5wdXNoKGEsIGIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2hpbGUoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBiID0gc3RhY2sucG9wKClcbiAgICB2YXIgYSA9IHN0YWNrLnBvcCgpXG5cbiAgICAvL0ZpbmQgb3Bwb3NpdGUgcGFpcnNcbiAgICB2YXIgeCA9IC0xLCB5ID0gLTFcbiAgICB2YXIgc3RhciA9IHN0YXJzW2FdXG4gICAgZm9yKHZhciBpPTE7IGk8c3Rhci5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIHZhciBzID0gc3RhcltpLTFdXG4gICAgICB2YXIgdCA9IHN0YXJbaV1cbiAgICAgIGlmKHMgPT09IGIpIHtcbiAgICAgICAgeSA9IHRcbiAgICAgIH0gZWxzZSBpZih0ID09PSBiKSB7XG4gICAgICAgIHggPSBzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9JZiB4L3kgYXJlIGJvdGggdmFsaWQgdGhlbiBza2lwIGVkZ2VcbiAgICBpZih4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvL0lmIGVkZ2UgaXMgbm93IGRlbGF1bmF5LCB0aGVuIGRvbid0IGZsaXAgaXRcbiAgICBpZihpbkNpcmNsZShwb2ludHNbYV0sIHBvaW50c1tiXSwgcG9pbnRzW3hdLCBwb2ludHNbeV0pID49IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy9GbGlwIHRoZSBlZGdlXG4gICAgdHJpYW5ndWxhdGlvbi5mbGlwKGEsIGIpXG5cbiAgICAvL1Rlc3QgZmxpcHBpbmcgbmVpZ2hib3JpbmcgZWRnZXNcbiAgICB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCB4LCBhLCB5KVxuICAgIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIGEsIHksIHgpXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgeSwgYiwgeClcbiAgICB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCBiLCB4LCB5KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLWJvdW5kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3NpZnlGYWNlc1xuXG5mdW5jdGlvbiBGYWNlSW5kZXgoY2VsbHMsIG5laWdoYm9yLCBjb25zdHJhaW50LCBmbGFncywgYWN0aXZlLCBuZXh0LCBib3VuZGFyeSkge1xuICB0aGlzLmNlbGxzICAgICAgID0gY2VsbHNcbiAgdGhpcy5uZWlnaGJvciAgICA9IG5laWdoYm9yXG4gIHRoaXMuZmxhZ3MgICAgICAgPSBmbGFnc1xuICB0aGlzLmNvbnN0cmFpbnQgID0gY29uc3RyYWludFxuICB0aGlzLmFjdGl2ZSAgICAgID0gYWN0aXZlXG4gIHRoaXMubmV4dCAgICAgICAgPSBuZXh0XG4gIHRoaXMuYm91bmRhcnkgICAgPSBib3VuZGFyeVxufVxuXG52YXIgcHJvdG8gPSBGYWNlSW5kZXgucHJvdG90eXBlXG5cbmZ1bmN0aW9uIGNvbXBhcmVDZWxsKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8XG4gICAgICAgICBhWzFdIC0gYlsxXSB8fFxuICAgICAgICAgYVsyXSAtIGJbMl1cbn1cblxucHJvdG8ubG9jYXRlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIga2V5ID0gWzAsMCwwXVxuICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgIHZhciB4ID0gYSwgeSA9IGIsIHogPSBjXG4gICAgaWYoYiA8IGMpIHtcbiAgICAgIGlmKGIgPCBhKSB7XG4gICAgICAgIHggPSBiXG4gICAgICAgIHkgPSBjXG4gICAgICAgIHogPSBhXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGMgPCBhKSB7XG4gICAgICB4ID0gY1xuICAgICAgeSA9IGFcbiAgICAgIHogPSBiXG4gICAgfVxuICAgIGlmKHggPCAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAga2V5WzBdID0geFxuICAgIGtleVsxXSA9IHlcbiAgICBrZXlbMl0gPSB6XG4gICAgcmV0dXJuIGJzZWFyY2guZXEodGhpcy5jZWxscywga2V5LCBjb21wYXJlQ2VsbClcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBpbmRleENlbGxzKHRyaWFuZ3VsYXRpb24sIGluZmluaXR5KSB7XG4gIC8vRmlyc3QgZ2V0IGNlbGxzIGFuZCBjYW5vbmljYWxpemVcbiAgdmFyIGNlbGxzID0gdHJpYW5ndWxhdGlvbi5jZWxscygpXG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICBmb3IodmFyIGk9MDsgaTxuYzsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIHZhciB4ID0gY1swXSwgeSA9IGNbMV0sIHogPSBjWzJdXG4gICAgaWYoeSA8IHopIHtcbiAgICAgIGlmKHkgPCB4KSB7XG4gICAgICAgIGNbMF0gPSB5XG4gICAgICAgIGNbMV0gPSB6XG4gICAgICAgIGNbMl0gPSB4XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHogPCB4KSB7XG4gICAgICBjWzBdID0gelxuICAgICAgY1sxXSA9IHhcbiAgICAgIGNbMl0gPSB5XG4gICAgfVxuICB9XG4gIGNlbGxzLnNvcnQoY29tcGFyZUNlbGwpXG5cbiAgLy9Jbml0aWFsaXplIGZsYWcgYXJyYXlcbiAgdmFyIGZsYWdzID0gbmV3IEFycmF5KG5jKVxuICBmb3IodmFyIGk9MDsgaTxmbGFncy5sZW5ndGg7ICsraSkge1xuICAgIGZsYWdzW2ldID0gMFxuICB9XG5cbiAgLy9CdWlsZCBuZWlnaGJvciBpbmRleCwgaW5pdGlhbGl6ZSBxdWV1ZXNcbiAgdmFyIGFjdGl2ZSA9IFtdXG4gIHZhciBuZXh0ICAgPSBbXVxuICB2YXIgbmVpZ2hib3IgPSBuZXcgQXJyYXkoMypuYylcbiAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgQXJyYXkoMypuYylcbiAgdmFyIGJvdW5kYXJ5ID0gbnVsbFxuICBpZihpbmZpbml0eSkge1xuICAgIGJvdW5kYXJ5ID0gW11cbiAgfVxuICB2YXIgaW5kZXggPSBuZXcgRmFjZUluZGV4KFxuICAgIGNlbGxzLFxuICAgIG5laWdoYm9yLFxuICAgIGNvbnN0cmFpbnQsXG4gICAgZmxhZ3MsXG4gICAgYWN0aXZlLFxuICAgIG5leHQsXG4gICAgYm91bmRhcnkpXG4gIGZvcih2YXIgaT0wOyBpPG5jOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8MzsgKytqKSB7XG4gICAgICB2YXIgeCA9IGNbal0sIHkgPSBjWyhqKzEpJTNdXG4gICAgICB2YXIgYSA9IG5laWdoYm9yWzMqaStqXSA9IGluZGV4LmxvY2F0ZSh5LCB4LCB0cmlhbmd1bGF0aW9uLm9wcG9zaXRlKHksIHgpKVxuICAgICAgdmFyIGIgPSBjb25zdHJhaW50WzMqaStqXSA9IHRyaWFuZ3VsYXRpb24uaXNDb25zdHJhaW50KHgsIHkpXG4gICAgICBpZihhIDwgMCkge1xuICAgICAgICBpZihiKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlLnB1c2goaSlcbiAgICAgICAgICBmbGFnc1tpXSA9IDFcbiAgICAgICAgfVxuICAgICAgICBpZihpbmZpbml0eSkge1xuICAgICAgICAgIGJvdW5kYXJ5LnB1c2goW3ksIHgsIC0xXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cblxuZnVuY3Rpb24gZmlsdGVyQ2VsbHMoY2VsbHMsIGZsYWdzLCB0YXJnZXQpIHtcbiAgdmFyIHB0ciA9IDBcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmbGFnc1tpXSA9PT0gdGFyZ2V0KSB7XG4gICAgICBjZWxsc1twdHIrK10gPSBjZWxsc1tpXVxuICAgIH1cbiAgfVxuICBjZWxscy5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGNlbGxzXG59XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5RmFjZXModHJpYW5ndWxhdGlvbiwgdGFyZ2V0LCBpbmZpbml0eSkge1xuICB2YXIgaW5kZXggPSBpbmRleENlbGxzKHRyaWFuZ3VsYXRpb24sIGluZmluaXR5KVxuXG4gIGlmKHRhcmdldCA9PT0gMCkge1xuICAgIGlmKGluZmluaXR5KSB7XG4gICAgICByZXR1cm4gaW5kZXguY2VsbHMuY29uY2F0KGluZGV4LmJvdW5kYXJ5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5kZXguY2VsbHNcbiAgICB9XG4gIH1cblxuICB2YXIgc2lkZSA9IDFcbiAgdmFyIGFjdGl2ZSA9IGluZGV4LmFjdGl2ZVxuICB2YXIgbmV4dCA9IGluZGV4Lm5leHRcbiAgdmFyIGZsYWdzID0gaW5kZXguZmxhZ3NcbiAgdmFyIGNlbGxzID0gaW5kZXguY2VsbHNcbiAgdmFyIGNvbnN0cmFpbnQgPSBpbmRleC5jb25zdHJhaW50XG4gIHZhciBuZWlnaGJvciA9IGluZGV4Lm5laWdoYm9yXG5cbiAgd2hpbGUoYWN0aXZlLmxlbmd0aCA+IDAgfHwgbmV4dC5sZW5ndGggPiAwKSB7XG4gICAgd2hpbGUoYWN0aXZlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0ID0gYWN0aXZlLnBvcCgpXG4gICAgICBpZihmbGFnc1t0XSA9PT0gLXNpZGUpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGZsYWdzW3RdID0gc2lkZVxuICAgICAgdmFyIGMgPSBjZWxsc1t0XVxuICAgICAgZm9yKHZhciBqPTA7IGo8MzsgKytqKSB7XG4gICAgICAgIHZhciBmID0gbmVpZ2hib3JbMyp0K2pdXG4gICAgICAgIGlmKGYgPj0gMCAmJiBmbGFnc1tmXSA9PT0gMCkge1xuICAgICAgICAgIGlmKGNvbnN0cmFpbnRbMyp0K2pdKSB7XG4gICAgICAgICAgICBuZXh0LnB1c2goZilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goZilcbiAgICAgICAgICAgIGZsYWdzW2ZdID0gc2lkZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vU3dhcCBhcnJheXMgYW5kIGxvb3BcbiAgICB2YXIgdG1wID0gbmV4dFxuICAgIG5leHQgPSBhY3RpdmVcbiAgICBhY3RpdmUgPSB0bXBcbiAgICBuZXh0Lmxlbmd0aCA9IDBcbiAgICBzaWRlID0gLXNpZGVcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBmaWx0ZXJDZWxscyhjZWxscywgZmxhZ3MsIHRhcmdldClcbiAgaWYoaW5maW5pdHkpIHtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChpbmRleC5ib3VuZGFyeSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLWJvdW5kcycpXG52YXIgb3JpZW50ID0gcmVxdWlyZSgncm9idXN0LW9yaWVudGF0aW9uJylbM11cblxudmFyIEVWRU5UX1BPSU5UID0gMFxudmFyIEVWRU5UX0VORCAgID0gMVxudmFyIEVWRU5UX1NUQVJUID0gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vbm90b25lVHJpYW5ndWxhdGVcblxuLy9BIHBhcnRpYWwgY29udmV4IGh1bGwgZnJhZ21lbnQsIG1hZGUgb2YgdHdvIHVuaW1vbm90b25lIHBvbHlnb25zXG5mdW5jdGlvbiBQYXJ0aWFsSHVsbChhLCBiLCBpZHgsIGxvd2VySWRzLCB1cHBlcklkcykge1xuICB0aGlzLmEgPSBhXG4gIHRoaXMuYiA9IGJcbiAgdGhpcy5pZHggPSBpZHhcbiAgdGhpcy5sb3dlcklkcyA9IGxvd2VySWRzXG4gIHRoaXMudXBwZXJJZHMgPSB1cHBlcklkc1xufVxuXG4vL0FuIGV2ZW50IGluIHRoZSBzd2VlcCBsaW5lIHByb2NlZHVyZVxuZnVuY3Rpb24gRXZlbnQoYSwgYiwgdHlwZSwgaWR4KSB7XG4gIHRoaXMuYSAgICA9IGFcbiAgdGhpcy5iICAgID0gYlxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuaWR4ICA9IGlkeFxufVxuXG4vL1RoaXMgaXMgdXNlZCB0byBjb21wYXJlIGV2ZW50cyBmb3IgdGhlIHN3ZWVwIGxpbmUgcHJvY2VkdXJlXG4vLyBQb2ludHMgYXJlOlxuLy8gIDEuIHNvcnRlZCBsZXhpY29ncmFwaGljYWxseVxuLy8gIDIuIHNvcnRlZCBieSB0eXBlICAocG9pbnQgPCBlbmQgPCBzdGFydClcbi8vICAzLiBzZWdtZW50cyBzb3J0ZWQgYnkgd2luZGluZyBvcmRlclxuLy8gIDQuIHNvcnRlZCBieSBpbmRleFxuZnVuY3Rpb24gY29tcGFyZUV2ZW50KGEsIGIpIHtcbiAgdmFyIGQgPVxuICAgIChhLmFbMF0gLSBiLmFbMF0pIHx8XG4gICAgKGEuYVsxXSAtIGIuYVsxXSkgfHxcbiAgICAoYS50eXBlIC0gYi50eXBlKVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgaWYoYS50eXBlICE9PSBFVkVOVF9QT0lOVCkge1xuICAgIGQgPSBvcmllbnQoYS5hLCBhLmIsIGIuYilcbiAgICBpZihkKSB7IHJldHVybiBkIH1cbiAgfVxuICByZXR1cm4gYS5pZHggLSBiLmlkeFxufVxuXG5mdW5jdGlvbiB0ZXN0UG9pbnQoaHVsbCwgcCkge1xuICByZXR1cm4gb3JpZW50KGh1bGwuYSwgaHVsbC5iLCBwKVxufVxuXG5mdW5jdGlvbiBhZGRQb2ludChjZWxscywgaHVsbHMsIHBvaW50cywgcCwgaWR4KSB7XG4gIHZhciBsbyA9IGJzZWFyY2gubHQoaHVsbHMsIHAsIHRlc3RQb2ludClcbiAgdmFyIGhpID0gYnNlYXJjaC5ndChodWxscywgcCwgdGVzdFBvaW50KVxuICBmb3IodmFyIGk9bG87IGk8aGk7ICsraSkge1xuICAgIHZhciBodWxsID0gaHVsbHNbaV1cblxuICAgIC8vSW5zZXJ0IHAgaW50byBsb3dlciBodWxsXG4gICAgdmFyIGxvd2VySWRzID0gaHVsbC5sb3dlcklkc1xuICAgIHZhciBtID0gbG93ZXJJZHMubGVuZ3RoXG4gICAgd2hpbGUobSA+IDEgJiYgb3JpZW50KFxuICAgICAgICBwb2ludHNbbG93ZXJJZHNbbS0yXV0sXG4gICAgICAgIHBvaW50c1tsb3dlcklkc1ttLTFdXSxcbiAgICAgICAgcCkgPiAwKSB7XG4gICAgICBjZWxscy5wdXNoKFxuICAgICAgICBbbG93ZXJJZHNbbS0xXSxcbiAgICAgICAgIGxvd2VySWRzW20tMl0sXG4gICAgICAgICBpZHhdKVxuICAgICAgbSAtPSAxXG4gICAgfVxuICAgIGxvd2VySWRzLmxlbmd0aCA9IG1cbiAgICBsb3dlcklkcy5wdXNoKGlkeClcblxuICAgIC8vSW5zZXJ0IHAgaW50byB1cHBlciBodWxsXG4gICAgdmFyIHVwcGVySWRzID0gaHVsbC51cHBlcklkc1xuICAgIHZhciBtID0gdXBwZXJJZHMubGVuZ3RoXG4gICAgd2hpbGUobSA+IDEgJiYgb3JpZW50KFxuICAgICAgICBwb2ludHNbdXBwZXJJZHNbbS0yXV0sXG4gICAgICAgIHBvaW50c1t1cHBlcklkc1ttLTFdXSxcbiAgICAgICAgcCkgPCAwKSB7XG4gICAgICBjZWxscy5wdXNoKFxuICAgICAgICBbdXBwZXJJZHNbbS0yXSxcbiAgICAgICAgIHVwcGVySWRzW20tMV0sXG4gICAgICAgICBpZHhdKVxuICAgICAgbSAtPSAxXG4gICAgfVxuICAgIHVwcGVySWRzLmxlbmd0aCA9IG1cbiAgICB1cHBlcklkcy5wdXNoKGlkeClcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU3BsaXQoaHVsbCwgZWRnZSkge1xuICB2YXIgZFxuICBpZihodWxsLmFbMF0gPCBlZGdlLmFbMF0pIHtcbiAgICBkID0gb3JpZW50KGh1bGwuYSwgaHVsbC5iLCBlZGdlLmEpXG4gIH0gZWxzZSB7XG4gICAgZCA9IG9yaWVudChlZGdlLmIsIGVkZ2UuYSwgaHVsbC5hKVxuICB9XG4gIGlmKGQpIHsgcmV0dXJuIGQgfVxuICBpZihlZGdlLmJbMF0gPCBodWxsLmJbMF0pIHtcbiAgICBkID0gb3JpZW50KGh1bGwuYSwgaHVsbC5iLCBlZGdlLmIpXG4gIH0gZWxzZSB7XG4gICAgZCA9IG9yaWVudChlZGdlLmIsIGVkZ2UuYSwgaHVsbC5iKVxuICB9XG4gIHJldHVybiBkIHx8IGh1bGwuaWR4IC0gZWRnZS5pZHhcbn1cblxuZnVuY3Rpb24gc3BsaXRIdWxscyhodWxscywgcG9pbnRzLCBldmVudCkge1xuICB2YXIgc3BsaXRJZHggPSBic2VhcmNoLmxlKGh1bGxzLCBldmVudCwgZmluZFNwbGl0KVxuICB2YXIgaHVsbCA9IGh1bGxzW3NwbGl0SWR4XVxuICB2YXIgdXBwZXJJZHMgPSBodWxsLnVwcGVySWRzXG4gIHZhciB4ID0gdXBwZXJJZHNbdXBwZXJJZHMubGVuZ3RoLTFdXG4gIGh1bGwudXBwZXJJZHMgPSBbeF1cbiAgaHVsbHMuc3BsaWNlKHNwbGl0SWR4KzEsIDAsXG4gICAgbmV3IFBhcnRpYWxIdWxsKGV2ZW50LmEsIGV2ZW50LmIsIGV2ZW50LmlkeCwgW3hdLCB1cHBlcklkcykpXG59XG5cblxuZnVuY3Rpb24gbWVyZ2VIdWxscyhodWxscywgcG9pbnRzLCBldmVudCkge1xuICAvL1N3YXAgcG9pbnRlcnMgZm9yIG1lcmdlIHNlYXJjaFxuICB2YXIgdG1wID0gZXZlbnQuYVxuICBldmVudC5hID0gZXZlbnQuYlxuICBldmVudC5iID0gdG1wXG4gIHZhciBtZXJnZUlkeCA9IGJzZWFyY2guZXEoaHVsbHMsIGV2ZW50LCBmaW5kU3BsaXQpXG4gIHZhciB1cHBlciA9IGh1bGxzW21lcmdlSWR4XVxuICB2YXIgbG93ZXIgPSBodWxsc1ttZXJnZUlkeC0xXVxuICBsb3dlci51cHBlcklkcyA9IHVwcGVyLnVwcGVySWRzXG4gIGh1bGxzLnNwbGljZShtZXJnZUlkeCwgMSlcbn1cblxuXG5mdW5jdGlvbiBtb25vdG9uZVRyaWFuZ3VsYXRlKHBvaW50cywgZWRnZXMpIHtcblxuICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aFxuICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGhcblxuICB2YXIgZXZlbnRzID0gW11cblxuICAvL0NyZWF0ZSBwb2ludCBldmVudHNcbiAgZm9yKHZhciBpPTA7IGk8bnVtUG9pbnRzOyArK2kpIHtcbiAgICBldmVudHMucHVzaChuZXcgRXZlbnQoXG4gICAgICBwb2ludHNbaV0sXG4gICAgICBudWxsLFxuICAgICAgRVZFTlRfUE9JTlQsXG4gICAgICBpKSlcbiAgfVxuXG4gIC8vQ3JlYXRlIGVkZ2UgZXZlbnRzXG4gIGZvcih2YXIgaT0wOyBpPG51bUVkZ2VzOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIGlmKGFbMF0gPCBiWzBdKSB7XG4gICAgICBldmVudHMucHVzaChcbiAgICAgICAgbmV3IEV2ZW50KGEsIGIsIEVWRU5UX1NUQVJULCBpKSxcbiAgICAgICAgbmV3IEV2ZW50KGIsIGEsIEVWRU5UX0VORCwgaSkpXG4gICAgfSBlbHNlIGlmKGFbMF0gPiBiWzBdKSB7XG4gICAgICBldmVudHMucHVzaChcbiAgICAgICAgbmV3IEV2ZW50KGIsIGEsIEVWRU5UX1NUQVJULCBpKSxcbiAgICAgICAgbmV3IEV2ZW50KGEsIGIsIEVWRU5UX0VORCwgaSkpXG4gICAgfVxuICB9XG5cbiAgLy9Tb3J0IGV2ZW50c1xuICBldmVudHMuc29ydChjb21wYXJlRXZlbnQpXG5cbiAgLy9Jbml0aWFsaXplIGh1bGxcbiAgdmFyIG1pblggPSBldmVudHNbMF0uYVswXSAtICgxICsgTWF0aC5hYnMoZXZlbnRzWzBdLmFbMF0pKSAqIE1hdGgucG93KDIsIC01MilcbiAgdmFyIGh1bGwgPSBbIG5ldyBQYXJ0aWFsSHVsbChbbWluWCwgMV0sIFttaW5YLCAwXSwgLTEsIFtdLCBbXSwgW10sIFtdKSBdXG5cbiAgLy9Qcm9jZXNzIGV2ZW50cyBpbiBvcmRlclxuICB2YXIgY2VsbHMgPSBbXVxuICBmb3IodmFyIGk9MCwgbnVtRXZlbnRzPWV2ZW50cy5sZW5ndGg7IGk8bnVtRXZlbnRzOyArK2kpIHtcbiAgICB2YXIgZXZlbnQgPSBldmVudHNbaV1cbiAgICB2YXIgdHlwZSA9IGV2ZW50LnR5cGVcbiAgICBpZih0eXBlID09PSBFVkVOVF9QT0lOVCkge1xuICAgICAgYWRkUG9pbnQoY2VsbHMsIGh1bGwsIHBvaW50cywgZXZlbnQuYSwgZXZlbnQuaWR4KVxuICAgIH0gZWxzZSBpZih0eXBlID09PSBFVkVOVF9TVEFSVCkge1xuICAgICAgc3BsaXRIdWxscyhodWxsLCBwb2ludHMsIGV2ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZUh1bGxzKGh1bGwsIHBvaW50cywgZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgLy9SZXR1cm4gdHJpYW5ndWxhdGlvblxuICByZXR1cm4gY2VsbHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUcmlhbmd1bGF0aW9uXG5cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRpb24oc3RhcnMsIGVkZ2VzKSB7XG4gIHRoaXMuc3RhcnMgPSBzdGFyc1xuICB0aGlzLmVkZ2VzID0gZWRnZXNcbn1cblxudmFyIHByb3RvID0gVHJpYW5ndWxhdGlvbi5wcm90b3R5cGVcblxuZnVuY3Rpb24gcmVtb3ZlUGFpcihsaXN0LCBqLCBrKSB7XG4gIGZvcih2YXIgaT0xLCBuPWxpc3QubGVuZ3RoOyBpPG47IGkrPTIpIHtcbiAgICBpZihsaXN0W2ktMV0gPT09IGogJiYgbGlzdFtpXSA9PT0gaykge1xuICAgICAgbGlzdFtpLTFdID0gbGlzdFtuLTJdXG4gICAgICBsaXN0W2ldID0gbGlzdFtuLTFdXG4gICAgICBsaXN0Lmxlbmd0aCA9IG4gLSAyXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbn1cblxucHJvdG8uaXNDb25zdHJhaW50ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgZSA9IFswLDBdXG4gIGZ1bmN0aW9uIGNvbXBhcmVMZXgoYSwgYikge1xuICAgIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXVxuICB9XG4gIHJldHVybiBmdW5jdGlvbihpLCBqKSB7XG4gICAgZVswXSA9IE1hdGgubWluKGksailcbiAgICBlWzFdID0gTWF0aC5tYXgoaSxqKVxuICAgIHJldHVybiBic2VhcmNoLmVxKHRoaXMuZWRnZXMsIGUsIGNvbXBhcmVMZXgpID49IDBcbiAgfVxufSkoKVxuXG5wcm90by5yZW1vdmVUcmlhbmdsZSA9IGZ1bmN0aW9uKGksIGosIGspIHtcbiAgdmFyIHN0YXJzID0gdGhpcy5zdGFyc1xuICByZW1vdmVQYWlyKHN0YXJzW2ldLCBqLCBrKVxuICByZW1vdmVQYWlyKHN0YXJzW2pdLCBrLCBpKVxuICByZW1vdmVQYWlyKHN0YXJzW2tdLCBpLCBqKVxufVxuXG5wcm90by5hZGRUcmlhbmdsZSA9IGZ1bmN0aW9uKGksIGosIGspIHtcbiAgdmFyIHN0YXJzID0gdGhpcy5zdGFyc1xuICBzdGFyc1tpXS5wdXNoKGosIGspXG4gIHN0YXJzW2pdLnB1c2goaywgaSlcbiAgc3RhcnNba10ucHVzaChpLCBqKVxufVxuXG5wcm90by5vcHBvc2l0ZSA9IGZ1bmN0aW9uKGosIGkpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLnN0YXJzW2ldXG4gIGZvcih2YXIgaz0xLCBuPWxpc3QubGVuZ3RoOyBrPG47IGsrPTIpIHtcbiAgICBpZihsaXN0W2tdID09PSBqKSB7XG4gICAgICByZXR1cm4gbGlzdFtrLTFdXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5wcm90by5mbGlwID0gZnVuY3Rpb24oaSwgaikge1xuICB2YXIgYSA9IHRoaXMub3Bwb3NpdGUoaSwgailcbiAgdmFyIGIgPSB0aGlzLm9wcG9zaXRlKGosIGkpXG4gIHRoaXMucmVtb3ZlVHJpYW5nbGUoaSwgaiwgYSlcbiAgdGhpcy5yZW1vdmVUcmlhbmdsZShqLCBpLCBiKVxuICB0aGlzLmFkZFRyaWFuZ2xlKGksIGIsIGEpXG4gIHRoaXMuYWRkVHJpYW5nbGUoaiwgYSwgYilcbn1cblxucHJvdG8uZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJzID0gdGhpcy5zdGFyc1xuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTAsIG49c3RhcnMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBsaXN0ID0gc3RhcnNbaV1cbiAgICBmb3IodmFyIGo9MCwgbT1saXN0Lmxlbmd0aDsgajxtOyBqKz0yKSB7XG4gICAgICByZXN1bHQucHVzaChbbGlzdFtqXSwgbGlzdFtqKzFdXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5wcm90by5jZWxscyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnMgPSB0aGlzLnN0YXJzXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IodmFyIGk9MCwgbj1zdGFycy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGxpc3QgPSBzdGFyc1tpXVxuICAgIGZvcih2YXIgaj0wLCBtPWxpc3QubGVuZ3RoOyBqPG07IGorPTIpIHtcbiAgICAgIHZhciBzID0gbGlzdFtqXVxuICAgICAgdmFyIHQgPSBsaXN0W2orMV1cbiAgICAgIGlmKGkgPCBNYXRoLm1pbihzLCB0KSkge1xuICAgICAgICByZXN1bHQucHVzaChbaSwgcywgdF0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJpYW5ndWxhdGlvbihudW1WZXJ0cywgZWRnZXMpIHtcbiAgdmFyIHN0YXJzID0gbmV3IEFycmF5KG51bVZlcnRzKVxuICBmb3IodmFyIGk9MDsgaTxudW1WZXJ0czsgKytpKSB7XG4gICAgc3RhcnNbaV0gPSBbXVxuICB9XG4gIHJldHVybiBuZXcgVHJpYW5ndWxhdGlvbihzdGFycywgZWRnZXMpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblBTTEdcblxudmFyIFVuaW9uRmluZCA9IHJlcXVpcmUoJ3VuaW9uLWZpbmQnKVxudmFyIGJveEludGVyc2VjdCA9IHJlcXVpcmUoJ2JveC1pbnRlcnNlY3QnKVxudmFyIHNlZ3NlZyA9IHJlcXVpcmUoJ3JvYnVzdC1zZWdtZW50LWludGVyc2VjdCcpXG52YXIgcmF0ID0gcmVxdWlyZSgnYmlnLXJhdCcpXG52YXIgcmF0Q21wID0gcmVxdWlyZSgnYmlnLXJhdC9jbXAnKVxudmFyIHJhdFRvRmxvYXQgPSByZXF1aXJlKCdiaWctcmF0L3RvLWZsb2F0JylcbnZhciByYXRWZWMgPSByZXF1aXJlKCdyYXQtdmVjJylcbnZhciBuZXh0YWZ0ZXIgPSByZXF1aXJlKCduZXh0YWZ0ZXInKVxuXG52YXIgc29sdmVJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9yYXQtc2VnLWludGVyc2VjdCcpXG5cbi8vIEJvdW5kcyBvbiBhIHJhdGlvbmFsIG51bWJlciB3aGVuIHJvdW5kZWQgdG8gYSBmbG9hdFxuZnVuY3Rpb24gYm91bmRSYXQgKHIpIHtcbiAgdmFyIGYgPSByYXRUb0Zsb2F0KHIpXG4gIHJldHVybiBbXG4gICAgbmV4dGFmdGVyKGYsIC1JbmZpbml0eSksXG4gICAgbmV4dGFmdGVyKGYsIEluZmluaXR5KVxuICBdXG59XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIGVkZ2VzIGluIGEgcHNsZyB0byBib3VuZGluZyBib3hlc1xuZnVuY3Rpb24gYm91bmRFZGdlcyAocG9pbnRzLCBlZGdlcykge1xuICB2YXIgYm91bmRzID0gbmV3IEFycmF5KGVkZ2VzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICB2YXIgYSA9IHBvaW50c1tlWzBdXVxuICAgIHZhciBiID0gcG9pbnRzW2VbMV1dXG4gICAgYm91bmRzW2ldID0gW1xuICAgICAgbmV4dGFmdGVyKE1hdGgubWluKGFbMF0sIGJbMF0pLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKE1hdGgubWluKGFbMV0sIGJbMV0pLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKE1hdGgubWF4KGFbMF0sIGJbMF0pLCBJbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIoTWF0aC5tYXgoYVsxXSwgYlsxXSksIEluZmluaXR5KVxuICAgIF1cbiAgfVxuICByZXR1cm4gYm91bmRzXG59XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHBvaW50cyBpbnRvIGJvdW5kaW5nIGJveGVzIGJ5IGR1cGxpY2F0aW5nIGNvb3Jkc1xuZnVuY3Rpb24gYm91bmRQb2ludHMgKHBvaW50cykge1xuICB2YXIgYm91bmRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV1cbiAgICBib3VuZHNbaV0gPSBbXG4gICAgICBuZXh0YWZ0ZXIocFswXSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihwWzFdLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKHBbMF0sIEluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihwWzFdLCBJbmZpbml0eSlcbiAgICBdXG4gIH1cbiAgcmV0dXJuIGJvdW5kc1xufVxuXG4vLyBGaW5kIGFsbCBwYWlycyBvZiBjcm9zc2luZyBlZGdlcyBpbiBhIHBzbGcgKGdpdmVuIGVkZ2UgYm91bmRzKVxuZnVuY3Rpb24gZ2V0Q3Jvc3NpbmdzIChwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBib3hJbnRlcnNlY3QoZWRnZUJvdW5kcywgZnVuY3Rpb24gKGksIGopIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgdmFyIGYgPSBlZGdlc1tqXVxuICAgIGlmIChlWzBdID09PSBmWzBdIHx8IGVbMF0gPT09IGZbMV0gfHxcbiAgICAgIGVbMV0gPT09IGZbMF0gfHwgZVsxXSA9PT0gZlsxXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBhID0gcG9pbnRzW2VbMF1dXG4gICAgdmFyIGIgPSBwb2ludHNbZVsxXV1cbiAgICB2YXIgYyA9IHBvaW50c1tmWzBdXVxuICAgIHZhciBkID0gcG9pbnRzW2ZbMV1dXG4gICAgaWYgKHNlZ3NlZyhhLCBiLCBjLCBkKSkge1xuICAgICAgcmVzdWx0LnB1c2goW2ksIGpdKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBGaW5kIGFsbCBwYWlycyBvZiBjcm9zc2luZyB2ZXJ0aWNlcyBpbiBhIHBzbGcgKGdpdmVuIGVkZ2UvdmVydCBib3VuZHMpXG5mdW5jdGlvbiBnZXRUSnVuY3Rpb25zIChwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzLCB2ZXJ0Qm91bmRzKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBib3hJbnRlcnNlY3QoZWRnZUJvdW5kcywgdmVydEJvdW5kcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgaWYgKGVbMF0gPT09IHYgfHwgZVsxXSA9PT0gdikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBwID0gcG9pbnRzW3ZdXG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIGlmIChzZWdzZWcoYSwgYiwgcCwgcCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtpLCB2XSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gQ3V0IGVkZ2VzIGFsb25nIGNyb3NzaW5ncy90anVuY3Rpb25zXG5mdW5jdGlvbiBjdXRFZGdlcyAoZmxvYXRQb2ludHMsIGVkZ2VzLCBjcm9zc2luZ3MsIGp1bmN0aW9ucywgdXNlQ29sb3IpIHtcbiAgdmFyIGksIGVcblxuICAvLyBDb252ZXJ0IGNyb3NzaW5ncyBpbnRvIHRqdW5jdGlvbnMgYnkgY29uc3RydWN0aW5nIHJhdGlvbmFsIHBvaW50c1xuICB2YXIgcmF0UG9pbnRzID0gZmxvYXRQb2ludHMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICAgcmF0KHBbMF0pLFxuICAgICAgICAgIHJhdChwWzFdKVxuICAgICAgXVxuICB9KVxuICBmb3IgKGkgPSAwOyBpIDwgY3Jvc3NpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNyb3NzaW5nID0gY3Jvc3NpbmdzW2ldXG4gICAgZSA9IGNyb3NzaW5nWzBdXG4gICAgdmFyIGYgPSBjcm9zc2luZ1sxXVxuICAgIHZhciBlZSA9IGVkZ2VzW2VdXG4gICAgdmFyIGVmID0gZWRnZXNbZl1cbiAgICB2YXIgeCA9IHNvbHZlSW50ZXJzZWN0aW9uKFxuICAgICAgcmF0VmVjKGZsb2F0UG9pbnRzW2VlWzBdXSksXG4gICAgICByYXRWZWMoZmxvYXRQb2ludHNbZWVbMV1dKSxcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZlswXV0pLFxuICAgICAgcmF0VmVjKGZsb2F0UG9pbnRzW2VmWzFdXSkpXG4gICAgaWYgKCF4KSB7XG4gICAgICAvLyBTZWdtZW50cyBhcmUgcGFyYWxsZWwsIHNob3VsZCBhbHJlYWR5IGJlIGhhbmRsZWQgYnkgdC1qdW5jdGlvbnNcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciBpZHggPSBmbG9hdFBvaW50cy5sZW5ndGhcbiAgICBmbG9hdFBvaW50cy5wdXNoKFtyYXRUb0Zsb2F0KHhbMF0pLCByYXRUb0Zsb2F0KHhbMV0pXSlcbiAgICByYXRQb2ludHMucHVzaCh4KVxuICAgIGp1bmN0aW9ucy5wdXNoKFtlLCBpZHhdLCBbZiwgaWR4XSlcbiAgfVxuXG4gIC8vIFNvcnQgdGp1bmN0aW9uc1xuICBqdW5jdGlvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhWzBdICE9PSBiWzBdKSB7XG4gICAgICByZXR1cm4gYVswXSAtIGJbMF1cbiAgICB9XG4gICAgdmFyIHUgPSByYXRQb2ludHNbYVsxXV1cbiAgICB2YXIgdiA9IHJhdFBvaW50c1tiWzFdXVxuICAgIHJldHVybiByYXRDbXAodVswXSwgdlswXSkgfHwgcmF0Q21wKHVbMV0sIHZbMV0pXG4gIH0pXG5cbiAgLy8gU3BsaXQgZWRnZXMgYWxvbmcganVuY3Rpb25zXG4gIGZvciAoaSA9IGp1bmN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBqdW5jdGlvbiA9IGp1bmN0aW9uc1tpXVxuICAgIGUgPSBqdW5jdGlvblswXVxuXG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tlXVxuICAgIHZhciBzID0gZWRnZVswXVxuICAgIHZhciB0ID0gZWRnZVsxXVxuXG4gICAgLy8gQ2hlY2sgaWYgZWRnZSBpcyBub3QgbGV4aWNvZ3JhcGhpY2FsbHkgc29ydGVkXG4gICAgdmFyIGEgPSBmbG9hdFBvaW50c1tzXVxuICAgIHZhciBiID0gZmxvYXRQb2ludHNbdF1cbiAgICBpZiAoKChhWzBdIC0gYlswXSkgfHwgKGFbMV0gLSBiWzFdKSkgPCAwKSB7XG4gICAgICB2YXIgdG1wID0gc1xuICAgICAgcyA9IHRcbiAgICAgIHQgPSB0bXBcbiAgICB9XG5cbiAgICAvLyBTcGxpdCBsZWFkaW5nIGVkZ2VcbiAgICBlZGdlWzBdID0gc1xuICAgIHZhciBsYXN0ID0gZWRnZVsxXSA9IGp1bmN0aW9uWzFdXG5cbiAgICAvLyBJZiB3ZSBhcmUgZ3JvdXBpbmcgZWRnZXMgYnkgY29sb3IsIHJlbWVtYmVyIHRvIHRyYWNrIGRhdGFcbiAgICB2YXIgY29sb3JcbiAgICBpZiAodXNlQ29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWRnZVsyXVxuICAgIH1cblxuICAgIC8vIFNwbGl0IG90aGVyIGVkZ2VzXG4gICAgd2hpbGUgKGkgPiAwICYmIGp1bmN0aW9uc1tpIC0gMV1bMF0gPT09IGUpIHtcbiAgICAgIHZhciBqdW5jdGlvbiA9IGp1bmN0aW9uc1stLWldXG4gICAgICB2YXIgbmV4dCA9IGp1bmN0aW9uWzFdXG4gICAgICBpZiAodXNlQ29sb3IpIHtcbiAgICAgICAgZWRnZXMucHVzaChbbGFzdCwgbmV4dCwgY29sb3JdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZXMucHVzaChbbGFzdCwgbmV4dF0pXG4gICAgICB9XG4gICAgICBsYXN0ID0gbmV4dFxuICAgIH1cblxuICAgIC8vIEFkZCBmaW5hbCBlZGdlXG4gICAgaWYgKHVzZUNvbG9yKSB7XG4gICAgICBlZGdlcy5wdXNoKFtsYXN0LCB0LCBjb2xvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIHRdKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBjb25zdHJ1Y3RlZCByYXRpb25hbCBwb2ludHNcbiAgcmV0dXJuIHJhdFBvaW50c1xufVxuXG4vLyBNZXJnZSBvdmVybGFwcGluZyBwb2ludHNcbmZ1bmN0aW9uIGRlZHVwUG9pbnRzIChmbG9hdFBvaW50cywgcmF0UG9pbnRzLCBmbG9hdEJvdW5kcykge1xuICB2YXIgbnVtUG9pbnRzID0gcmF0UG9pbnRzLmxlbmd0aFxuICB2YXIgdWYgPSBuZXcgVW5pb25GaW5kKG51bVBvaW50cylcblxuICAvLyBDb21wdXRlIHJhdGlvbmFsIGJvdW5kc1xuICB2YXIgYm91bmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXRQb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcCA9IHJhdFBvaW50c1tpXVxuICAgIHZhciB4YiA9IGJvdW5kUmF0KHBbMF0pXG4gICAgdmFyIHliID0gYm91bmRSYXQocFsxXSlcbiAgICBib3VuZHMucHVzaChbXG4gICAgICBuZXh0YWZ0ZXIoeGJbMF0sIC1JbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIoeWJbMF0sIC1JbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIoeGJbMV0sIEluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcih5YlsxXSwgSW5maW5pdHkpXG4gICAgXSlcbiAgfVxuXG4gIC8vIExpbmsgYWxsIHBvaW50cyB3aXRoIG92ZXIgbGFwcGluZyBib3hlc1xuICBib3hJbnRlcnNlY3QoYm91bmRzLCBmdW5jdGlvbiAoaSwgaikge1xuICAgIHVmLmxpbmsoaSwgailcbiAgfSlcblxuICAvLyBEbyAxIHBhc3Mgb3ZlciBwb2ludHMgdG8gY29tYmluZSBwb2ludHMgaW4gbGFiZWwgc2V0c1xuICB2YXIgbm9EdXBlcyA9IHRydWVcbiAgdmFyIGxhYmVscyA9IG5ldyBBcnJheShudW1Qb2ludHMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyArK2kpIHtcbiAgICB2YXIgaiA9IHVmLmZpbmQoaSlcbiAgICBpZiAoaiAhPT0gaSkge1xuICAgICAgLy8gQ2xlYXIgbm8tZHVwZXMgZmxhZywgemVybyBvdXQgbGFiZWxcbiAgICAgIG5vRHVwZXMgPSBmYWxzZVxuICAgICAgLy8gTWFrZSBlYWNoIHBvaW50IHRoZSB0b3AtbGVmdCBwb2ludCBmcm9tIGl0cyBjZWxsXG4gICAgICBmbG9hdFBvaW50c1tqXSA9IFtcbiAgICAgICAgTWF0aC5taW4oZmxvYXRQb2ludHNbaV1bMF0sIGZsb2F0UG9pbnRzW2pdWzBdKSxcbiAgICAgICAgTWF0aC5taW4oZmxvYXRQb2ludHNbaV1bMV0sIGZsb2F0UG9pbnRzW2pdWzFdKVxuICAgICAgXVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIGR1cGxpY2F0ZXMsIHJldHVybiBudWxsIHRvIHNpZ25hbCB0ZXJtaW5hdGlvblxuICBpZiAobm9EdXBlcykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgKytpKSB7XG4gICAgdmFyIGogPSB1Zi5maW5kKGkpXG4gICAgaWYgKGogPT09IGkpIHtcbiAgICAgIGxhYmVsc1tpXSA9IHB0clxuICAgICAgZmxvYXRQb2ludHNbcHRyKytdID0gZmxvYXRQb2ludHNbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxzW2ldID0gLTFcbiAgICB9XG4gIH1cblxuICBmbG9hdFBvaW50cy5sZW5ndGggPSBwdHJcblxuICAvLyBEbyBhIHNlY29uZCBwYXNzIHRvIGZpeCB1cCBtaXNzaW5nIGxhYmVsc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgKytpKSB7XG4gICAgaWYgKGxhYmVsc1tpXSA8IDApIHtcbiAgICAgIGxhYmVsc1tpXSA9IGxhYmVsc1t1Zi5maW5kKGkpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiByZXN1bHRpbmcgdW5pb24tZmluZCBkYXRhIHN0cnVjdHVyZVxuICByZXR1cm4gbGFiZWxzXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMZXgyIChhLCBiKSB7IHJldHVybiAoYVswXSAtIGJbMF0pIHx8IChhWzFdIC0gYlsxXSkgfVxuZnVuY3Rpb24gY29tcGFyZUxleDMgKGEsIGIpIHtcbiAgdmFyIGQgPSAoYVswXSAtIGJbMF0pIHx8IChhWzFdIC0gYlsxXSlcbiAgaWYgKGQpIHtcbiAgICByZXR1cm4gZFxuICB9XG4gIGlmIChhWzJdIDwgYlsyXSkge1xuICAgIHJldHVybiAtMVxuICB9IGVsc2UgaWYgKGFbMl0gPiBiWzJdKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBSZW1vdmUgZHVwbGljYXRlIGVkZ2UgbGFiZWxzXG5mdW5jdGlvbiBkZWR1cEVkZ2VzIChlZGdlcywgbGFiZWxzLCB1c2VDb2xvcikge1xuICBpZiAoZWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGxhYmVscykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHZhciBhID0gbGFiZWxzW2VbMF1dXG4gICAgICB2YXIgYiA9IGxhYmVsc1tlWzFdXVxuICAgICAgZVswXSA9IE1hdGgubWluKGEsIGIpXG4gICAgICBlWzFdID0gTWF0aC5tYXgoYSwgYilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgICAgdmFyIGEgPSBlWzBdXG4gICAgICB2YXIgYiA9IGVbMV1cbiAgICAgIGVbMF0gPSBNYXRoLm1pbihhLCBiKVxuICAgICAgZVsxXSA9IE1hdGgubWF4KGEsIGIpXG4gICAgfVxuICB9XG4gIGlmICh1c2VDb2xvcikge1xuICAgIGVkZ2VzLnNvcnQoY29tcGFyZUxleDMpXG4gIH0gZWxzZSB7XG4gICAgZWRnZXMuc29ydChjb21wYXJlTGV4MilcbiAgfVxuICB2YXIgcHRyID0gMVxuICBmb3IgKHZhciBpID0gMTsgaSA8IGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHByZXYgPSBlZGdlc1tpIC0gMV1cbiAgICB2YXIgbmV4dCA9IGVkZ2VzW2ldXG4gICAgaWYgKG5leHRbMF0gPT09IHByZXZbMF0gJiYgbmV4dFsxXSA9PT0gcHJldlsxXSAmJlxuICAgICAgKCF1c2VDb2xvciB8fCBuZXh0WzJdID09PSBwcmV2WzJdKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZWRnZXNbcHRyKytdID0gbmV4dFxuICB9XG4gIGVkZ2VzLmxlbmd0aCA9IHB0clxufVxuXG5mdW5jdGlvbiBwcmVSb3VuZCAocG9pbnRzLCBlZGdlcywgdXNlQ29sb3IpIHtcbiAgdmFyIGxhYmVscyA9IGRlZHVwUG9pbnRzKHBvaW50cywgW10sIGJvdW5kUG9pbnRzKHBvaW50cykpXG4gIGRlZHVwRWRnZXMoZWRnZXMsIGxhYmVscywgdXNlQ29sb3IpXG4gIHJldHVybiAhIWxhYmVsc1xufVxuXG4vLyBSZXBlYXQgdW50aWwgY29udmVyZ2VuY2VcbmZ1bmN0aW9uIHNuYXBSb3VuZCAocG9pbnRzLCBlZGdlcywgdXNlQ29sb3IpIHtcbiAgLy8gMS4gZmluZCBlZGdlIGNyb3NzaW5nc1xuICB2YXIgZWRnZUJvdW5kcyA9IGJvdW5kRWRnZXMocG9pbnRzLCBlZGdlcylcbiAgdmFyIGNyb3NzaW5ncyA9IGdldENyb3NzaW5ncyhwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzKVxuXG4gIC8vIDIuIGZpbmQgdC1qdW5jdGlvbnNcbiAgdmFyIHZlcnRCb3VuZHMgPSBib3VuZFBvaW50cyhwb2ludHMpXG4gIHZhciB0anVuY3Rpb25zID0gZ2V0VEp1bmN0aW9ucyhwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzLCB2ZXJ0Qm91bmRzKVxuXG4gIC8vIDMuIGN1dCBlZGdlcywgY29uc3RydWN0IHJhdGlvbmFsIHBvaW50c1xuICB2YXIgcmF0UG9pbnRzID0gY3V0RWRnZXMocG9pbnRzLCBlZGdlcywgY3Jvc3NpbmdzLCB0anVuY3Rpb25zLCB1c2VDb2xvcilcblxuICAvLyA0LiBkZWR1cGUgdmVydHNcbiAgdmFyIGxhYmVscyA9IGRlZHVwUG9pbnRzKHBvaW50cywgcmF0UG9pbnRzLCB2ZXJ0Qm91bmRzKVxuXG4gIC8vIDUuIGRlZHVwZSBlZGdlc1xuICBkZWR1cEVkZ2VzKGVkZ2VzLCBsYWJlbHMsIHVzZUNvbG9yKVxuXG4gIC8vIDYuIGNoZWNrIHRlcm1pbmF0aW9uXG4gIGlmICghbGFiZWxzKSB7XG4gICAgcmV0dXJuIChjcm9zc2luZ3MubGVuZ3RoID4gMCB8fCB0anVuY3Rpb25zLmxlbmd0aCA+IDApXG4gIH1cblxuICAvLyBNb3JlIGl0ZXJhdGlvbnMgbmVjZXNzYXJ5XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIE1haW4gbG9vcCwgcnVucyBQU0xHIGNsZWFuIHVwIHVudGlsIGNvbXBsZXRpb25cbmZ1bmN0aW9uIGNsZWFuUFNMRyAocG9pbnRzLCBlZGdlcywgY29sb3JzKSB7XG4gIC8vIElmIHVzaW5nIGNvbG9ycywgYXVnbWVudCBlZGdlcyB3aXRoIGNvbG9yIGRhdGFcbiAgdmFyIHByZXZFZGdlc1xuICBpZiAoY29sb3JzKSB7XG4gICAgcHJldkVkZ2VzID0gZWRnZXNcbiAgICB2YXIgYXVnRWRnZXMgPSBuZXcgQXJyYXkoZWRnZXMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIGF1Z0VkZ2VzW2ldID0gW2VbMF0sIGVbMV0sIGNvbG9yc1tpXV1cbiAgICB9XG4gICAgZWRnZXMgPSBhdWdFZGdlc1xuICB9XG5cbiAgLy8gRmlyc3Qgcm91bmQ6IHJlbW92ZSBkdXBsaWNhdGUgZWRnZXMgYW5kIHBvaW50c1xuICB2YXIgbW9kaWZpZWQgPSBwcmVSb3VuZChwb2ludHMsIGVkZ2VzLCAhIWNvbG9ycylcblxuICAvLyBSdW4gc25hcCByb3VuZGluZyB1bnRpbCBjb252ZXJnZW5jZVxuICB3aGlsZSAoc25hcFJvdW5kKHBvaW50cywgZWRnZXMsICEhY29sb3JzKSkge1xuICAgIG1vZGlmaWVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gU3RyaXAgY29sb3IgdGFnc1xuICBpZiAoISFjb2xvcnMgJiYgbW9kaWZpZWQpIHtcbiAgICBwcmV2RWRnZXMubGVuZ3RoID0gMFxuICAgIGNvbG9ycy5sZW5ndGggPSAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgICAgcHJldkVkZ2VzLnB1c2goW2VbMF0sIGVbMV1dKVxuICAgICAgY29sb3JzLnB1c2goZVsyXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW9kaWZpZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHZlSW50ZXJzZWN0aW9uXG5cbnZhciByYXRNdWwgPSByZXF1aXJlKCdiaWctcmF0L211bCcpXG52YXIgcmF0RGl2ID0gcmVxdWlyZSgnYmlnLXJhdC9kaXYnKVxudmFyIHJhdFN1YiA9IHJlcXVpcmUoJ2JpZy1yYXQvc3ViJylcbnZhciByYXRTaWduID0gcmVxdWlyZSgnYmlnLXJhdC9zaWduJylcbnZhciBydlN1YiA9IHJlcXVpcmUoJ3JhdC12ZWMvc3ViJylcbnZhciBydkFkZCA9IHJlcXVpcmUoJ3JhdC12ZWMvYWRkJylcbnZhciBydk11bHMgPSByZXF1aXJlKCdyYXQtdmVjL211bHMnKVxuXG5mdW5jdGlvbiByYXRQZXJwIChhLCBiKSB7XG4gIHJldHVybiByYXRTdWIocmF0TXVsKGFbMF0sIGJbMV0pLCByYXRNdWwoYVsxXSwgYlswXSkpXG59XG5cbi8vIFNvbHZlIGZvciBpbnRlcnNlY3Rpb25cbi8vICB4ID0gYSArIHQgKGItYSlcbi8vICAoeCAtIGMpIF4gKGQtYykgPSAwXG4vLyAgKHQgKiAoYi1hKSArIChhLWMpICkgXiAoZC1jKSA9IDBcbi8vICB0ICogKGItYSleKGQtYykgPSAoZC1jKV4oYS1jKVxuLy8gIHQgPSAoZC1jKV4oYS1jKSAvIChiLWEpXihkLWMpXG5cbmZ1bmN0aW9uIHNvbHZlSW50ZXJzZWN0aW9uIChhLCBiLCBjLCBkKSB7XG4gIHZhciBiYSA9IHJ2U3ViKGIsIGEpXG4gIHZhciBkYyA9IHJ2U3ViKGQsIGMpXG5cbiAgdmFyIGJhWGRjID0gcmF0UGVycChiYSwgZGMpXG5cbiAgaWYgKHJhdFNpZ24oYmFYZGMpID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBhYyA9IHJ2U3ViKGEsIGMpXG4gIHZhciBkY1hhYyA9IHJhdFBlcnAoZGMsIGFjKVxuXG4gIHZhciB0ID0gcmF0RGl2KGRjWGFjLCBiYVhkYylcbiAgdmFyIHMgPSBydk11bHMoYmEsIHQpXG4gIHZhciByID0gcnZBZGQoYSwgcylcblxuICByZXR1cm4gclxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQW5nbGVcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoXCJyb2J1c3Qtb3JpZW50YXRpb25cIilcbnZhciBzZ24gPSByZXF1aXJlKFwic2lnbnVtXCIpXG52YXIgdHdvU3VtID0gcmVxdWlyZShcInR3by1zdW1cIilcbnZhciByb2J1c3RQcm9kdWN0ID0gcmVxdWlyZShcInJvYnVzdC1wcm9kdWN0XCIpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcblxuZnVuY3Rpb24gdGVzdEludGVyaW9yKGEsIGIsIGMpIHtcbiAgdmFyIHgwID0gdHdvU3VtKGFbMF0sIC1iWzBdKVxuICB2YXIgeTAgPSB0d29TdW0oYVsxXSwgLWJbMV0pXG4gIHZhciB4MSA9IHR3b1N1bShjWzBdLCAtYlswXSlcbiAgdmFyIHkxID0gdHdvU3VtKGNbMV0sIC1iWzFdKVxuXG4gIHZhciBkID0gcm9idXN0U3VtKFxuICAgIHJvYnVzdFByb2R1Y3QoeDAsIHgxKSxcbiAgICByb2J1c3RQcm9kdWN0KHkwLCB5MSkpXG5cbiAgcmV0dXJuIGRbZC5sZW5ndGgtMV0gPj0gMFxufVxuXG5mdW5jdGlvbiBjb21wYXJlQW5nbGUoYSwgYiwgYywgZCkge1xuICB2YXIgYmNkID0gb3JpZW50KGIsIGMsIGQpXG4gIGlmKGJjZCA9PT0gMCkge1xuICAgIC8vSGFuZGxlIGRlZ2VuZXJhdGUgY2FzZXNcbiAgICB2YXIgc2FiYyA9IHNnbihvcmllbnQoYSwgYiwgYykpXG4gICAgdmFyIHNhYmQgPSBzZ24ob3JpZW50KGEsIGIsIGQpKVxuICAgIGlmKHNhYmMgPT09IHNhYmQpIHtcbiAgICAgIGlmKHNhYmMgPT09IDApIHtcbiAgICAgICAgdmFyIGljID0gdGVzdEludGVyaW9yKGEsIGIsIGMpXG4gICAgICAgIHZhciBpZCA9IHRlc3RJbnRlcmlvcihhLCBiLCBkKVxuICAgICAgICBpZihpYyA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9IGVsc2UgaWYoaWMpIHtcbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZihzYWJkID09PSAwKSB7XG4gICAgICBpZihzYWJjID4gMCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZih0ZXN0SW50ZXJpb3IoYSwgYiwgZCkpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihzYWJjID09PSAwKSB7XG4gICAgICBpZihzYWJkID4gMCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmKHRlc3RJbnRlcmlvcihhLCBiLCBjKSkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZ24oc2FiZCAtIHNhYmMpXG4gIH1cbiAgdmFyIGFiYyA9IG9yaWVudChhLCBiLCBjKVxuICBpZihhYmMgPiAwKSB7XG4gICAgaWYoYmNkID4gMCAmJiBvcmllbnQoYSwgYiwgZCkgPiAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIGlmKGFiYyA8IDApIHtcbiAgICBpZihiY2QgPiAwIHx8IG9yaWVudChhLCBiLCBkKSA+IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9IGVsc2Uge1xuICAgIHZhciBhYmQgPSBvcmllbnQoYSwgYiwgZClcbiAgICBpZihhYmQgPiAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0ZXN0SW50ZXJpb3IoYSwgYiwgYykpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxuXG5mdW5jdGlvbiBQcm9jZWR1cmUoKSB7XG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxuICB0aGlzLnNoaW1BcmdzID0gW11cbiAgdGhpcy5hcnJheUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QmxvY2tJbmRpY2VzID0gW11cbiAgdGhpcy5zY2FsYXJBcmdzID0gW11cbiAgdGhpcy5vZmZzZXRBcmdzID0gW11cbiAgdGhpcy5vZmZzZXRBcmdJbmRleCA9IFtdXG4gIHRoaXMuaW5kZXhBcmdzID0gW11cbiAgdGhpcy5zaGFwZUFyZ3MgPSBbXVxuICB0aGlzLmZ1bmNOYW1lID0gXCJcIlxuICB0aGlzLnByZSA9IG51bGxcbiAgdGhpcy5ib2R5ID0gbnVsbFxuICB0aGlzLnBvc3QgPSBudWxsXG4gIHRoaXMuZGVidWcgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBjb21waWxlQ3dpc2UodXNlcl9hcmdzKSB7XG4gIC8vQ3JlYXRlIHByb2NlZHVyZVxuICB2YXIgcHJvYyA9IG5ldyBQcm9jZWR1cmUoKVxuICBcbiAgLy9QYXJzZSBibG9ja3NcbiAgcHJvYy5wcmUgICAgPSB1c2VyX2FyZ3MucHJlXG4gIHByb2MuYm9keSAgID0gdXNlcl9hcmdzLmJvZHlcbiAgcHJvYy5wb3N0ICAgPSB1c2VyX2FyZ3MucG9zdFxuXG4gIC8vUGFyc2UgYXJndW1lbnRzXG4gIHZhciBwcm9jX2FyZ3MgPSB1c2VyX2FyZ3MuYXJncy5zbGljZSgwKVxuICBwcm9jLmFyZ1R5cGVzID0gcHJvY19hcmdzXG4gIGZvcih2YXIgaT0wOyBpPHByb2NfYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhcmdfdHlwZSA9IHByb2NfYXJnc1tpXVxuICAgIGlmKGFyZ190eXBlID09PSBcImFycmF5XCIgfHwgKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5ibG9ja0luZGljZXMpKSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJhcnJheVwiXG4gICAgICBwcm9jLmFycmF5QXJncy5wdXNoKGkpXG4gICAgICBwcm9jLmFycmF5QmxvY2tJbmRpY2VzLnB1c2goYXJnX3R5cGUuYmxvY2tJbmRpY2VzID8gYXJnX3R5cGUuYmxvY2tJbmRpY2VzIDogMClcbiAgICAgIHByb2Muc2hpbUFyZ3MucHVzaChcImFycmF5XCIgKyBpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzY2FsYXJcIikge1xuICAgICAgcHJvYy5zY2FsYXJBcmdzLnB1c2goaSlcbiAgICAgIHByb2Muc2hpbUFyZ3MucHVzaChcInNjYWxhclwiICsgaSlcbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwiaW5kZXhcIikge1xuICAgICAgcHJvYy5pbmRleEFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MuYm9keS5hcmdzLmxlbmd0aCAmJiBwcm9jLmJvZHkuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNoYXBlXCIpIHtcbiAgICAgIHByb2Muc2hhcGVBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MuYm9keS5hcmdzLmxlbmd0aCAmJiBwcm9jLmJvZHkuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLm9mZnNldCkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwib2Zmc2V0XCJcbiAgICAgIHByb2Mub2Zmc2V0QXJncy5wdXNoKHsgYXJyYXk6IGFyZ190eXBlLmFycmF5LCBvZmZzZXQ6YXJnX3R5cGUub2Zmc2V0IH0pXG4gICAgICBwcm9jLm9mZnNldEFyZ0luZGV4LnB1c2goaSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFVua25vd24gYXJndW1lbnQgdHlwZSBcIiArIHByb2NfYXJnc1tpXSlcbiAgICB9XG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGF0IGxlYXN0IG9uZSBhcnJheSBhcmd1bWVudCB3YXMgc3BlY2lmaWVkXG4gIGlmKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IE5vIGFycmF5IGFyZ3VtZW50cyBzcGVjaWZpZWRcIilcbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXJndW1lbnRzIGFyZSBjb3JyZWN0XG4gIGlmKHByb2MucHJlLmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcHJlKCkgYmxvY2tcIilcbiAgfVxuICBpZihwcm9jLmJvZHkuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBib2R5KCkgYmxvY2tcIilcbiAgfVxuICBpZihwcm9jLnBvc3QuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwb3N0KCkgYmxvY2tcIilcbiAgfVxuXG4gIC8vQ2hlY2sgZGVidWcgZmxhZ1xuICBwcm9jLmRlYnVnID0gISF1c2VyX2FyZ3MucHJpbnRDb2RlIHx8ICEhdXNlcl9hcmdzLmRlYnVnXG4gIFxuICAvL1JldHJpZXZlIG5hbWVcbiAgcHJvYy5mdW5jTmFtZSA9IHVzZXJfYXJncy5mdW5jTmFtZSB8fCBcImN3aXNlXCJcbiAgXG4gIC8vUmVhZCBpbiBibG9jayBzaXplXG4gIHByb2MuYmxvY2tTaXplID0gdXNlcl9hcmdzLmJsb2NrU2l6ZSB8fCA2NFxuXG4gIHJldHVybiBjcmVhdGVUaHVuayhwcm9jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVDd2lzZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHVuaXEgPSByZXF1aXJlKFwidW5pcVwiKVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyB2ZXJ5IHNpbXBsZSBsb29wcyBhbmFsb2dvdXMgdG8gaG93IHlvdSB0eXBpY2FsbHkgdHJhdmVyc2UgYXJyYXlzICh0aGUgb3V0ZXJtb3N0IGxvb3AgY29ycmVzcG9uZHMgdG8gdGhlIHNsb3dlc3QgY2hhbmdpbmcgaW5kZXgsIHRoZSBpbm5lcm1vc3QgbG9vcCB0byB0aGUgZmFzdGVzdCBjaGFuZ2luZyBpbmRleClcbi8vIFRPRE86IElmIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBzdHJpZGVzIChhbmQgb2Zmc2V0cykgdGhlcmUgaXMgcG90ZW50aWFsIGZvciBkZWNyZWFzaW5nIHRoZSBudW1iZXIgb2YgXCJwb2ludGVyc1wiIGFuZCByZWxhdGVkIHZhcmlhYmxlcy4gVGhlIGRyYXdiYWNrIGlzIHRoYXQgdGhlIHR5cGUgc2lnbmF0dXJlIHdvdWxkIGJlY29tZSBtb3JlIHNwZWNpZmljIGFuZCB0aGF0IHRoZXJlIHdvdWxkIHRodXMgYmUgbGVzcyBwb3RlbnRpYWwgZm9yIGNhY2hpbmcsIGJ1dCBpdCBtaWdodCBzdGlsbCBiZSB3b3J0aCBpdCwgZXNwZWNpYWxseSB3aGVuIGRlYWxpbmcgd2l0aCBsYXJnZSBudW1iZXJzIG9mIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHsgLy8gSXRlcmF0aW9uIHZhcmlhYmxlc1xuICAgIHZhcnMucHVzaChbXCJpXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9Db21wdXRlIHNjYW4gZGVsdGFzXG4gIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHBpZHggPSBpZHhcbiAgICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgICBpZihpID09PSAwKSB7IC8vIFRoZSBpbm5lcm1vc3QvZmFzdGVzdCBkaW1lbnNpb24ncyBkZWx0YSBpcyBzaW1wbHkgaXRzIHN0cmlkZVxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcInBcIixpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2UgeyAvLyBGb3Igb3RoZXIgZGltZW5zaW9ucyB0aGUgZGVsdGEgaXMgYmFzaWNhbGx5IHRoZSBzdHJpZGUgbWludXMgc29tZXRoaW5nIHdoaWNoIGVzc2VudGlhbGx5IFwicmV3aW5kc1wiIHRoZSBwcmV2aW91cyAobW9yZSBpbm5lcikgZGltZW5zaW9uXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH0gIFxuICAvL1NjYW4gbG9vcFxuICBmb3IoaT1kaW1lbnNpb24tMTsgaT49MDsgLS1pKSB7IC8vIFN0YXJ0IGF0IGxhcmdlc3Qgc3RyaWRlIGFuZCB3b3JrIHlvdXIgd2F5IGlud2FyZHNcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGNvZGUucHVzaChbXCJmb3IoaVwiLGksXCI9MDtpXCIsaSxcIjxzXCIsaWR4LFwiOysraVwiLGksXCIpe1wiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcbiAgY29kZS5wdXNoKGJvZHkpXG4gIC8vQWR2YW5jZSBzY2FuIHBvaW50ZXJzXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBwaWR4ID0gaWR4XG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChbXCJwXCIsaixcIis9ZFwiLGosXCJzXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBpZihpID4gMCkge1xuICAgICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIscGlkeCxcIl0tPXNcIixwaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFtcIisraW5kZXhbXCIsaWR4LFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vLyBHZW5lcmF0ZSBcIm91dGVyXCIgbG9vcHMgdGhhdCBsb29wIG92ZXIgYmxvY2tzIG9mIGRhdGEsIGFwcGx5aW5nIFwiaW5uZXJcIiBsb29wcyB0byB0aGUgYmxvY2tzIGJ5IG1hbmlwdWxhdGluZyB0aGUgbG9jYWwgdmFyaWFibGVzIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW5uZXIgbG9vcCBvbmx5IFwic2Vlc1wiIHRoZSBjdXJyZW50IGJsb2NrLlxuLy8gVE9ETzogSWYgdGhpcyBpcyB1c2VkLCB0aGVuIHRoZSBwcmV2aW91cyBkZWNsYXJhdGlvbiAoZG9uZSBieSBnZW5lcmF0ZUN3aXNlT3ApIG9mIHMqIGlzIGVzc2VudGlhbGx5IHVubmVjZXNzYXJ5LlxuLy8gICAgICAgSSBiZWxpZXZlIHRoZSBzKiBhcmUgbm90IHVzZWQgZWxzZXdoZXJlIChpbiBwYXJ0aWN1bGFyLCBJIGRvbid0IHRoaW5rIHRoZXkncmUgdXNlZCBpbiB0aGUgcHJlL3Bvc3QgcGFydHMgYW5kIFwic2hhcGVcIiBpcyBkZWZpbmVkIGluZGVwZW5kZW50bHkpLCBzbyBpdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBtYWtlIGRlZmluaW5nIHRoZSBzKiBkZXBlbmRlbnQgb24gd2hhdCBsb29wIG1ldGhvZCBpcyBiZWluZyB1c2VkLlxuZnVuY3Rpb24gb3V0ZXJGaWxsKG1hdGNoZWQsIG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBibG9ja1NpemUgPSBwcm9jLmJsb2NrU2l6ZVxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMFxuICAgICwgY29kZSA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1widmFyIG9mZnNldFwiLGksXCI9cFwiLGldLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9HZW5lcmF0ZSBsb29wcyBmb3IgdW5tYXRjaGVkIGRpbWVuc2lvbnNcbiAgLy8gVGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGRpbWVuc2lvbnMgYXJlIHRyYXZlcnNlZCBpcyBmYWlybHkgYXJiaXRyYXJ5IChmcm9tIHNtYWxsIHN0cmlkZSB0byBsYXJnZSBzdHJpZGUsIGZvciB0aGUgZmlyc3QgYXJndW1lbnQpXG4gIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGxvb3BzIGFyZSBwbGFjZWQgd291bGQgYWxzbyBiZSBzb21laG93IFwib3B0aW1hbFwiIChhdCB0aGUgdmVyeSBsZWFzdCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpdCByZWFsbHkgZG9lc24ndCBodXJ0IHVzIGlmIHRoZXkncmUgbm90KS5cbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKSAvLyBJdGVyYXRlIGJhY2sgdG8gZnJvbnRcbiAgICBjb2RlLnB1c2goW1wiaWYoalwiLGksXCI8XCIsYmxvY2tTaXplLFwiKXtcIl0uam9pbihcIlwiKSkgLy8gRWl0aGVyIGRlY3JlYXNlIGogYnkgYmxvY2tTaXplIChzID0gYmxvY2tTaXplKSwgb3Igc2V0IGl0IHRvIHplcm8gKGFmdGVyIHNldHRpbmcgcyA9IGopLlxuICAgIGNvZGUucHVzaChbXCJzXCIsb3JkZXJbaV0sXCI9alwiLGldLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wifWVsc2V7c1wiLG9yZGVyW2ldLFwiPVwiLGJsb2NrU2l6ZV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCItPVwiLGJsb2NrU2l6ZSxcIn1cIl0uam9pbihcIlwiKSlcbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixvcmRlcltpXSxcIl09alwiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICB2YXIgaW5kZXhTdHIgPSBbXCJvZmZzZXRcIitpXVxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpbmRleFN0ci5wdXNoKFtcImpcIixqLFwiKnRcIixpLFwicFwiLG9yZGVyW2pdXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpKVxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xuLy8gVGhpcyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IGNvbW1vbiBwcmVmaXggb2YgdGhlIGFycmF5cyBpbiBvcmRlcnMuXG4vLyBFYWNoIGFycmF5IGluIG9yZGVycyBsaXN0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29ycmVzcG9uZCBuZGFycmF5IGluIG9yZGVyIG9mIGluY3JlYXNpbmcgc3RyaWRlLlxuLy8gVGhpcyBpcyB0aHVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaW1lbnNpb25zIHRoYXQgY2FuIGJlIGVmZmljaWVudGx5IHRyYXZlcnNlZCBieSBzaW1wbGUgbmVzdGVkIGxvb3BzIGZvciBhbGwgYXJyYXlzLlxuZnVuY3Rpb24gY291bnRNYXRjaGVzKG9yZGVycykge1xuICB2YXIgbWF0Y2hlZCA9IDAsIGRpbWVuc2lvbiA9IG9yZGVyc1swXS5sZW5ndGhcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGZvcih2YXIgaj0xOyBqPG9yZGVycy5sZW5ndGg7ICsraikge1xuICAgICAgaWYob3JkZXJzW2pdW21hdGNoZWRdICE9PSBvcmRlcnNbMF1bbWF0Y2hlZF0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcbiAgICAgIH1cbiAgICB9XG4gICAgKyttYXRjaGVkXG4gIH1cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLy9Qcm9jZXNzZXMgYSBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEgdHlwZXNcbi8vIFJlcGxhY2VzIHZhcmlhYmxlIG5hbWVzIGJ5IGRpZmZlcmVudCBvbmVzLCBlaXRoZXIgXCJsb2NhbFwiIG9uZXMgKHRoYXQgYXJlIHRoZW4gZmVycmllZCBpbiBhbmQgb3V0IG9mIHRoZSBnaXZlbiBhcnJheSkgb3Igb25lcyBtYXRjaGluZyB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIHVsdGltYXRlIGxvb3Agd2lsbCBhY2NlcHQuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2soYmxvY2ssIHByb2MsIGR0eXBlcykge1xuICB2YXIgY29kZSA9IGJsb2NrLmJvZHlcbiAgdmFyIHByZSA9IFtdXG4gIHZhciBwb3N0ID0gW11cbiAgZm9yKHZhciBpPTA7IGk8YmxvY2suYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjYXJnID0gYmxvY2suYXJnc1tpXVxuICAgIGlmKGNhcmcuY291bnQgPD0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChjYXJnLm5hbWUsIFwiZ1wiKVxuICAgIHZhciBwdHJTdHIgPSBcIlwiXG4gICAgdmFyIGFyck51bSA9IHByb2MuYXJyYXlBcmdzLmluZGV4T2YoaSlcbiAgICBzd2l0Y2gocHJvYy5hcmdUeXBlc1tpXSkge1xuICAgICAgY2FzZSBcIm9mZnNldFwiOlxuICAgICAgICB2YXIgb2ZmQXJnSW5kZXggPSBwcm9jLm9mZnNldEFyZ0luZGV4LmluZGV4T2YoaSlcbiAgICAgICAgdmFyIG9mZkFyZyA9IHByb2Mub2Zmc2V0QXJnc1tvZmZBcmdJbmRleF1cbiAgICAgICAgYXJyTnVtID0gb2ZmQXJnLmFycmF5XG4gICAgICAgIHB0clN0ciA9IFwiK3FcIiArIG9mZkFyZ0luZGV4IC8vIEFkZHMgb2Zmc2V0IHRvIHRoZSBcInBvaW50ZXJcIiBpbiB0aGUgYXJyYXlcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBwdHJTdHIgPSBcInBcIiArIGFyck51bSArIHB0clN0clxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcbiAgICAgICAgdmFyIGFyclN0ciA9IFwiYVwiICsgYXJyTnVtXG4gICAgICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0gPT09IDApIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBqdXN0IGEgc2luZ2xlIHZhbHVlIGZyb20gdGhpcyBhcnJheVxuICAgICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHsgLy8gQXJndW1lbnQvYXJyYXkgdXNlZCBvbmx5IG9uY2UoPylcbiAgICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXT1cIiwgbG9jYWxTdHJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGEgXCJibG9ja1wiXG4gICAgICAgICAgdmFyIHJlU3RyQXJyID0gW2NhcmcubmFtZV0sIHB0clN0ckFyciA9IFtwdHJTdHJdXG4gICAgICAgICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dKTsgaisrKSB7XG4gICAgICAgICAgICByZVN0ckFyci5wdXNoKFwiXFxcXHMqXFxcXFsoW15cXFxcXV0rKVxcXFxdXCIpXG4gICAgICAgICAgICBwdHJTdHJBcnIucHVzaChcIiRcIiArIChqKzEpICsgXCIqdFwiICsgYXJyTnVtICsgXCJiXCIgKyBqKSAvLyBNYXRjaGVkIGluZGV4IHRpbWVzIHN0cmlkZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZSA9IG5ldyBSZWdFeHAocmVTdHJBcnIuam9pbihcIlwiKSwgXCJnXCIpXG4gICAgICAgICAgcHRyU3RyID0gcHRyU3RyQXJyLmpvaW4oXCIrXCIpXG4gICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAvKmlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogR2VuZXJpYyBhcnJheXMgbm90IHN1cHBvcnRlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGJsb2NrcyFcIilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBwcm9kdWNlIGFueSBsb2NhbCB2YXJpYWJsZXMsIGV2ZW4gaWYgdmFyaWFibGVzIGFyZSB1c2VkIG11bHRpcGxlIHRpbWVzLiBJdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBkbyBzbywgYnV0IGl0IHdvdWxkIGNvbXBsaWNhdGUgdGhpbmdzIHF1aXRlIGEgYml0LlxuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcIllcIiArIHByb2Muc2NhbGFyQXJncy5pbmRleE9mKGkpKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcImluZGV4XCIpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwic2hhcGVcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBbcHJlLmpvaW4oXCJcXG5cIiksIGNvZGUsIHBvc3Quam9pbihcIlxcblwiKV0uam9pbihcIlxcblwiKS50cmltKClcbn1cblxuZnVuY3Rpb24gdHlwZVN1bW1hcnkoZHR5cGVzKSB7XG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXG4gIHZhciBhbGxFcXVhbCA9IHRydWVcbiAgZm9yKHZhciBpPTA7IGk8ZHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cbiAgICB2YXIgZGlnaXRzID0gdC5tYXRjaCgvXFxkKy8pXG4gICAgaWYoIWRpZ2l0cykge1xuICAgICAgZGlnaXRzID0gXCJcIlxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgPSBkaWdpdHNbMF1cbiAgICB9XG4gICAgaWYodC5jaGFyQXQoMCkgPT09IDApIHtcbiAgICAgIHN1bW1hcnlbaV0gPSBcInVcIiArIHQuY2hhckF0KDEpICsgZGlnaXRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bW1hcnlbaV0gPSB0LmNoYXJBdCgwKSArIGRpZ2l0c1xuICAgIH1cbiAgICBpZihpID4gMCkge1xuICAgICAgYWxsRXF1YWwgPSBhbGxFcXVhbCAmJiBzdW1tYXJ5W2ldID09PSBzdW1tYXJ5W2ktMV1cbiAgICB9XG4gIH1cbiAgaWYoYWxsRXF1YWwpIHtcbiAgICByZXR1cm4gc3VtbWFyeVswXVxuICB9XG4gIHJldHVybiBzdW1tYXJ5LmpvaW4oXCJcIilcbn1cblxuLy9HZW5lcmF0ZXMgYSBjd2lzZSBvcGVyYXRvclxuZnVuY3Rpb24gZ2VuZXJhdGVDV2lzZU9wKHByb2MsIHR5cGVzaWcpIHtcblxuICAvL0NvbXB1dGUgZGltZW5zaW9uXG4gIC8vIEFycmF5cyBnZXQgcHV0IGZpcnN0IGluIHR5cGVzaWcsIGFuZCB0aGVyZSBhcmUgdHdvIGVudHJpZXMgcGVyIGFycmF5IChkdHlwZSBhbmQgb3JkZXIpLCBzbyB0aGlzIGdldHMgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIHRoZSBmaXJzdCBhcnJheSBhcmcuXG4gIHZhciBkaW1lbnNpb24gPSAodHlwZXNpZ1sxXS5sZW5ndGggLSBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSl8MFxuICB2YXIgb3JkZXJzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgdmFyIGR0eXBlcyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgZHR5cGVzW2ldID0gdHlwZXNpZ1syKmldXG4gICAgb3JkZXJzW2ldID0gdHlwZXNpZ1syKmkrMV1cbiAgfVxuICBcbiAgLy9EZXRlcm1pbmUgd2hlcmUgYmxvY2sgYW5kIGxvb3AgaW5kaWNlcyBzdGFydCBhbmQgZW5kXG4gIHZhciBibG9ja0JlZ2luID0gW10sIGJsb2NrRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgZXhwb3NlZCBhcyBibG9ja3NcbiAgdmFyIGxvb3BCZWdpbiA9IFtdLCBsb29wRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgaXRlcmF0ZWQgb3ZlclxuICB2YXIgbG9vcE9yZGVycyA9IFtdIC8vIG9yZGVycyByZXN0cmljdGVkIHRvIHRoZSBsb29wIGluZGljZXNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXTwwKSB7XG4gICAgICBsb29wQmVnaW4ucHVzaCgwKVxuICAgICAgbG9vcEVuZC5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0VuZC5wdXNoKGRpbWVuc2lvbitwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBsb29wQmVnaW4ucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSAvLyBOb24tbmVnYXRpdmVcbiAgICAgIGxvb3BFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldK2RpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaCgwKVxuICAgICAgYmxvY2tFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH1cbiAgICB2YXIgbmV3T3JkZXIgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9yZGVyc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxvb3BCZWdpbltpXTw9b3JkZXJzW2ldW2pdICYmIG9yZGVyc1tpXVtqXTxsb29wRW5kW2ldKSB7XG4gICAgICAgIG5ld09yZGVyLnB1c2gob3JkZXJzW2ldW2pdLWxvb3BCZWdpbltpXSkgLy8gSWYgdGhpcyBpcyBhIGxvb3AgaW5kZXgsIHB1dCBpdCBpbiBuZXdPcmRlciwgc3VidHJhY3RpbmcgbG9vcEJlZ2luLCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgbG9vcE9yZGVycyBhcmUgdXNpbmcgYSBjb21tb24gc2V0IG9mIGluZGljZXMuXG4gICAgICB9XG4gICAgfVxuICAgIGxvb3BPcmRlcnMucHVzaChuZXdPcmRlcilcbiAgfVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl0gLy8gU1MgaXMgdGhlIG92ZXJhbGwgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gIHZhciB2YXJzID0gW11cbiAgXG4gIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUaGUgbGltaXRzIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcImFcIitpKSAvLyBBY3R1YWwgZGF0YSBhcnJheVxuICAgIGFyZ2xpc3QucHVzaChcInRcIitpKSAvLyBTdHJpZGVzXG4gICAgYXJnbGlzdC5wdXNoKFwicFwiK2kpIC8vIE9mZnNldCBpbiB0aGUgYXJyYXkgYXQgd2hpY2ggdGhlIGRhdGEgc3RhcnRzIChhbHNvIHVzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBkYXRhKVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGxvb3BpbmdcbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcInBcIixqLFwiPXRcIixpLFwiW1wiLGxvb3BCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKTsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGJsb2NrIGl0ZXJhdGlvblxuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwiYlwiLGosXCI9dFwiLGksXCJbXCIsYmxvY2tCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJZXCIgKyBpKVxuICB9XG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJzLnB1c2goXCJzaGFwZT1TUy5zbGljZSgwKVwiKSAvLyBNYWtlcyB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlIGF2YWlsYWJsZSB0byB0aGUgdXNlciBkZWZpbmVkIGZ1bmN0aW9ucyAoc28geW91IGNhbiB1c2Ugd2lkdGgvaGVpZ2h0IGZvciBleGFtcGxlKVxuICB9XG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBQcmVwYXJlIGFuIGFycmF5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIChsb2dpY2FsKSBpbmRpY2VzLCBpbml0aWFsaXplZCB0byBkaW1lbnNpb24gemVyb2VzLlxuICAgIHZhciB6ZXJvcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHplcm9zW2ldID0gXCIwXCJcbiAgICB9XG4gICAgdmFycy5wdXNoKFtcImluZGV4PVtcIiwgemVyb3Muam9pbihcIixcIiksIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Mub2Zmc2V0QXJncy5sZW5ndGg7ICsraSkgeyAvLyBPZmZzZXQgYXJndW1lbnRzIHVzZWQgZm9yIHN0ZW5jaWwgb3BlcmF0aW9uc1xuICAgIHZhciBvZmZfYXJnID0gcHJvYy5vZmZzZXRBcmdzW2ldXG4gICAgdmFyIGluaXRfc3RyaW5nID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvZmZfYXJnLm9mZnNldC5sZW5ndGg7ICsraikge1xuICAgICAgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMSkge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtcInRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtvZmZfYXJnLm9mZnNldFtqXSwgXCIqdFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoaW5pdF9zdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXJzLnB1c2goXCJxXCIgKyBpICsgXCI9MFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLnB1c2goW1wicVwiLCBpLCBcIj1cIiwgaW5pdF9zdHJpbmcuam9pbihcIitcIildLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG5cbiAgLy9QcmVwYXJlIHRoaXMgdmFyaWFibGVzXG4gIHZhciB0aGlzVmFycyA9IHVuaXEoW10uY29uY2F0KHByb2MucHJlLnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5ib2R5LnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5wb3N0LnRoaXNWYXJzKSlcbiAgdmFycyA9IHZhcnMuY29uY2F0KHRoaXNWYXJzKVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGNvZGUucHVzaChcInBcIitpK1wifD0wXCIpXG4gIH1cbiAgXG4gIC8vSW5saW5lIHByZWx1ZGVcbiAgaWYocHJvYy5wcmUuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnByZSwgcHJvYywgZHR5cGVzKSlcbiAgfVxuXG4gIC8vUHJvY2VzcyBib2R5XG4gIHZhciBib2R5ID0gcHJvY2Vzc0Jsb2NrKHByb2MuYm9keSwgcHJvYywgZHR5cGVzKVxuICB2YXIgbWF0Y2hlZCA9IGNvdW50TWF0Y2hlcyhsb29wT3JkZXJzKVxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgY29kZS5wdXNoKG91dGVyRmlsbChtYXRjaGVkLCBsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSkgLy8gVE9ETzogUmF0aGVyIHRoYW4gcGFzc2luZyBsb29wT3JkZXJzWzBdLCBpdCBtaWdodCBiZSBpbnRlcmVzdGluZyB0byBsb29rIGF0IHBhc3NpbmcgYW4gb3JkZXIgdGhhdCByZXByZXNlbnRzIHRoZSBtYWpvcml0eSBvZiB0aGUgYXJndW1lbnRzIGZvciBleGFtcGxlLlxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChpbm5lckZpbGwobG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcbiAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oW1wiZnVuY3Rpb24gXCIsbG9vcE5hbWUsXCIoXCIsIGFyZ2xpc3Quam9pbihcIixcIiksXCIpe1wiLCBjb2RlLmpvaW4oXCJcXG5cIiksXCJ9IHJldHVybiBcIiwgbG9vcE5hbWVdLmpvaW4oXCJcIikpXG4gIHJldHVybiBmKClcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDV2lzZU9wXG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxuLy8gQSBmdW5jdGlvbiBvYmplY3QgaXMgY29uc3RydWN0ZWQgd2hpY2ggYWNjZXB0cyBhcyBhcmd1bWVudCBhIGNvbXBpbGF0aW9uIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24uXG4vLyBJdCBpcyB0aGlzIG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXZlbnR1YWxseSByZXR1cm5lZCBieSBjcmVhdGVUaHVuaywgYW5kIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9uZSB0aGF0IGFjdHVhbGx5XG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cbi8vIFRoZSBjb21waWxhdGlvbiBwYXNzZWQgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIG9iamVjdCBpcyB1c2VkIGZvciBjb21waWxpbmcgbmV3IGZ1bmN0aW9ucy5cbi8vIE9uY2UgdGhpcyBmdW5jdGlvbiBvYmplY3QgaXMgY3JlYXRlZCwgaXQgaXMgY2FsbGVkIHdpdGggY29tcGlsZSBhcyBhcmd1bWVudCwgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbXBpbGVcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cbi8vIFNvIGNyZWF0ZVRodW5rIHJvdWdobHkgd29ya3MgbGlrZSB0aGlzOlxuLy8gZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcbi8vICAgICB2YXIgQ0FDSEVEID0ge31cbi8vICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXlzIGFuZCBzY2FsYXJzKSB7XG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c11cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gZnVuYyhhcnJheXMgYW5kIHNjYWxhcnMpXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQxKHByb2MpKVxuLy8gfVxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIilcblxuZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiLCBcInZhciBDQUNIRUQ9e31cIl1cbiAgdmFyIHZhcnMgPSBbXVxuICB2YXIgdGh1bmtOYW1lID0gcHJvYy5mdW5jTmFtZSArIFwiX2N3aXNlX3RodW5rXCJcbiAgXG4gIC8vQnVpbGQgdGh1bmtcbiAgY29kZS5wdXNoKFtcInJldHVybiBmdW5jdGlvbiBcIiwgdGh1bmtOYW1lLCBcIihcIiwgcHJvYy5zaGltQXJncy5qb2luKFwiLFwiKSwgXCIpe1wiXS5qb2luKFwiXCIpKVxuICB2YXIgdHlwZXNpZyA9IFtdXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXG4gIHZhciBwcm9jX2FyZ3MgPSBbW1wiYXJyYXlcIixwcm9jLmFycmF5QXJnc1swXSxcIi5zaGFwZS5zbGljZShcIiwgLy8gU2xpY2Ugc2hhcGUgc28gdGhhdCB3ZSBvbmx5IHJldGFpbiB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlICh3aGljaCBnZXRzIHBhc3NlZCB0byB0aGUgY3dpc2Ugb3BlcmF0b3IgYXMgU1MpLlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF08MD8oXCIsXCIrcHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIik6XCIpXCJdLmpvaW4oXCJcIildXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cbiAgLy8gUHJvY2VzcyBhcnJheSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgICBpZiAoaT4wKSB7IC8vIEdhdGhlciBjb25kaXRpb25zIHRvIGNoZWNrIGZvciBzaGFwZSBlcXVhbGl0eSAoaWdub3JpbmcgYmxvY2sgaW5kaWNlcylcbiAgICAgIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZS5sZW5ndGgrXCIgKyAoTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkpKVxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XG4gIGlmIChwcm9jLmFycmF5QXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUxlbmd0aENvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHkhJylcIilcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUNvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUhJylcIilcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgLy8gUHJvY2VzcyBzY2FsYXIgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBmdW5jdGlvbiAoYW5kIGlmIG5vdCBwcmVzZW50LCBnZW5lcmF0ZSBpdClcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxuICB2YXJzLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKVxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICBcbiAgY29kZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcbiAgICAgICAgICAgICBcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLCB0eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0pfVwiLFxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxuXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJ2YXIgaGFzVHlwZWRBcnJheXMgPSBmYWxzZVxuaWYodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgRE9VQkxFX1ZJRVcgPSBuZXcgRmxvYXQ2NEFycmF5KDEpXG4gICAgLCBVSU5UX1ZJRVcgICA9IG5ldyBVaW50MzJBcnJheShET1VCTEVfVklFVy5idWZmZXIpXG4gIERPVUJMRV9WSUVXWzBdID0gMS4wXG4gIGhhc1R5cGVkQXJyYXlzID0gdHJ1ZVxuICBpZihVSU5UX1ZJRVdbMV0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBsaXR0bGUgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzTEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMF0sIFVJTlRfVklFV1sxXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlTEUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMF0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzFdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVMRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50TEVcbiAgICBmdW5jdGlvbiBoaWdoVWludExFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50TEVcbiAgfSBlbHNlIGlmKFVJTlRfVklFV1swXSA9PT0gMHgzZmYwMDAwMCkge1xuICAgIC8vVXNlIGJpZyBlbmRpYW5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHNCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBbIFVJTlRfVklFV1sxXSwgVUlOVF9WSUVXWzBdIF1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Eb3VibGVCRShsbywgaGkpIHtcbiAgICAgIFVJTlRfVklFV1sxXSA9IGxvXG4gICAgICBVSU5UX1ZJRVdbMF0gPSBoaVxuICAgICAgcmV0dXJuIERPVUJMRV9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZUJFXG4gICAgZnVuY3Rpb24gbG93VWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRCRVxuICAgIGZ1bmN0aW9uIGhpZ2hVaW50QkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmhpID0gaGlnaFVpbnRCRVxuICB9IGVsc2Uge1xuICAgIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbiAgfVxufVxuaWYoIWhhc1R5cGVkQXJyYXlzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDgpXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0cyhuKSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUobiwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gWyBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpLCBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpIF1cbiAgfVxuICBmdW5jdGlvbiB0b0RvdWJsZShsbywgaGkpIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShsbywgMCwgdHJ1ZSlcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShoaSwgNCwgdHJ1ZSlcbiAgICByZXR1cm4gYnVmZmVyLnJlYWREb3VibGVMRSgwLCB0cnVlKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZSAgXG4gIGZ1bmN0aW9uIGxvd1VpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRcbiAgZnVuY3Rpb24gaGlnaFVpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoNCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50XG59XG5cbm1vZHVsZS5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5oaShuKSA+Pj4gMzFcbn1cblxubW9kdWxlLmV4cG9ydHMuZXhwb25lbnQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICgoYjw8MSkgPj4+IDIxKSAtIDEwMjNcbn1cblxubW9kdWxlLmV4cG9ydHMuZnJhY3Rpb24gPSBmdW5jdGlvbihuKSB7XG4gIHZhciBsbyA9IG1vZHVsZS5leHBvcnRzLmxvKG4pXG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHZhciBiID0gaGkgJiAoKDE8PDIwKSAtIDEpXG4gIGlmKGhpICYgMHg3ZmYwMDAwMCkge1xuICAgIGIgKz0gKDE8PDIwKVxuICB9XG4gIHJldHVybiBbbG8sIGJdXG59XG5cbm1vZHVsZS5leHBvcnRzLmRlbm9ybWFsaXplZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGhpID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICEoaGkgJiAweDdmZjAwMDAwKVxufSIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGVkZ2VUb0FkamFjZW5jeVxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbmZ1bmN0aW9uIGVkZ2VUb0FkamFjZW5jeShlZGdlcywgbnVtVmVydGljZXMpIHtcbiAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoXG4gIGlmKHR5cGVvZiBudW1WZXJ0aWNlcyAhPT0gXCJudW1iZXJcIikge1xuICAgIG51bVZlcnRpY2VzID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPG51bUVkZ2VzOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIG51bVZlcnRpY2VzID0gTWF0aC5tYXgobnVtVmVydGljZXMsIGVbMF0sIGVbMV0pXG4gICAgfVxuICAgIG51bVZlcnRpY2VzID0gKG51bVZlcnRpY2VzfDApICsgMVxuICB9XG4gIG51bVZlcnRpY2VzID0gbnVtVmVydGljZXN8MFxuICB2YXIgYWRqID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKVxuICBmb3IodmFyIGk9MDsgaTxudW1WZXJ0aWNlczsgKytpKSB7XG4gICAgYWRqW2ldID0gW11cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGFkaltlWzBdXS5wdXNoKGVbMV0pXG4gICAgYWRqW2VbMV1dLnB1c2goZVswXSlcbiAgfVxuICBmb3IodmFyIGo9MDsgajxudW1WZXJ0aWNlczsgKytqKSB7XG4gICAgdW5pcShhZGpbal0sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYlxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGFkalxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUkJUcmVlXG5cbnZhciBSRUQgICA9IDBcbnZhciBCTEFDSyA9IDFcblxuZnVuY3Rpb24gUkJOb2RlKGNvbG9yLCBrZXksIHZhbHVlLCBsZWZ0LCByaWdodCwgY291bnQpIHtcbiAgdGhpcy5fY29sb3IgPSBjb2xvclxuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sZWZ0ID0gbGVmdFxuICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgdGhpcy5fY291bnQgPSBjb3VudFxufVxuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICByZXR1cm4gbmV3IFJCTm9kZShub2RlLl9jb2xvciwgbm9kZS5rZXksIG5vZGUudmFsdWUsIG5vZGUubGVmdCwgbm9kZS5yaWdodCwgbm9kZS5fY291bnQpXG59XG5cbmZ1bmN0aW9uIHJlcGFpbnQoY29sb3IsIG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBSQk5vZGUoY29sb3IsIG5vZGUua2V5LCBub2RlLnZhbHVlLCBub2RlLmxlZnQsIG5vZGUucmlnaHQsIG5vZGUuX2NvdW50KVxufVxuXG5mdW5jdGlvbiByZWNvdW50KG5vZGUpIHtcbiAgbm9kZS5fY291bnQgPSAxICsgKG5vZGUubGVmdCA/IG5vZGUubGVmdC5fY291bnQgOiAwKSArIChub2RlLnJpZ2h0ID8gbm9kZS5yaWdodC5fY291bnQgOiAwKVxufVxuXG5mdW5jdGlvbiBSZWRCbGFja1RyZWUoY29tcGFyZSwgcm9vdCkge1xuICB0aGlzLl9jb21wYXJlID0gY29tcGFyZVxuICB0aGlzLnJvb3QgPSByb290XG59XG5cbnZhciBwcm90byA9IFJlZEJsYWNrVHJlZS5wcm90b3R5cGVcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImtleXNcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihrLHYpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGspXG4gICAgfSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJ2YWx1ZXNcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihrLHYpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHYpXG4gICAgfSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn0pXG5cbi8vUmV0dXJucyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuX2NvdW50XG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbn0pXG5cbi8vSW5zZXJ0IGEgbmV3IGl0ZW0gaW50byB0aGUgdHJlZVxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICAvL0ZpbmQgcG9pbnQgdG8gaW5zZXJ0IG5ldyBub2RlIGF0XG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBuX3N0YWNrID0gW11cbiAgdmFyIGRfc3RhY2sgPSBbXVxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBuX3N0YWNrLnB1c2gobilcbiAgICBkX3N0YWNrLnB1c2goZClcbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgLy9SZWJ1aWxkIHBhdGggdG8gbGVhZiBub2RlXG4gIG5fc3RhY2sucHVzaChuZXcgUkJOb2RlKFJFRCwga2V5LCB2YWx1ZSwgbnVsbCwgbnVsbCwgMSkpXG4gIGZvcih2YXIgcz1uX3N0YWNrLmxlbmd0aC0yOyBzPj0wOyAtLXMpIHtcbiAgICB2YXIgbiA9IG5fc3RhY2tbc11cbiAgICBpZihkX3N0YWNrW3NdIDw9IDApIHtcbiAgICAgIG5fc3RhY2tbc10gPSBuZXcgUkJOb2RlKG4uX2NvbG9yLCBuLmtleSwgbi52YWx1ZSwgbl9zdGFja1tzKzFdLCBuLnJpZ2h0LCBuLl9jb3VudCsxKVxuICAgIH0gZWxzZSB7XG4gICAgICBuX3N0YWNrW3NdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgbl9zdGFja1tzKzFdLCBuLl9jb3VudCsxKVxuICAgIH1cbiAgfVxuICAvL1JlYmFsYW5jZSB0cmVlIHVzaW5nIHJvdGF0aW9uc1xuICAvL2NvbnNvbGUubG9nKFwic3RhcnQgaW5zZXJ0XCIsIGtleSwgZF9zdGFjaylcbiAgZm9yKHZhciBzPW5fc3RhY2subGVuZ3RoLTE7IHM+MTsgLS1zKSB7XG4gICAgdmFyIHAgPSBuX3N0YWNrW3MtMV1cbiAgICB2YXIgbiA9IG5fc3RhY2tbc11cbiAgICBpZihwLl9jb2xvciA9PT0gQkxBQ0sgfHwgbi5fY29sb3IgPT09IEJMQUNLKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICB2YXIgcHAgPSBuX3N0YWNrW3MtMl1cbiAgICBpZihwcC5sZWZ0ID09PSBwKSB7XG4gICAgICBpZihwLmxlZnQgPT09IG4pIHtcbiAgICAgICAgdmFyIHkgPSBwcC5yaWdodFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTExyXCIpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHBwLnJpZ2h0ID0gcmVwYWludChCTEFDSywgeSlcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBzIC09IDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTExiXCIpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcHAubGVmdCA9IHAucmlnaHRcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcC5yaWdodCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gcFxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IG5cbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICBpZihzID49IDMpIHtcbiAgICAgICAgICAgIHZhciBwcHAgPSBuX3N0YWNrW3MtM11cbiAgICAgICAgICAgIGlmKHBwcC5sZWZ0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IHBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBwcC5yaWdodCA9IHBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHkgPSBwcC5yaWdodFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTFJyXCIpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHBwLnJpZ2h0ID0gcmVwYWludChCTEFDSywgeSlcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBzIC09IDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTFJiXCIpXG4gICAgICAgICAgcC5yaWdodCA9IG4ubGVmdFxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLmxlZnQgPSBuLnJpZ2h0XG4gICAgICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIG4ubGVmdCA9IHBcbiAgICAgICAgICBuLnJpZ2h0ID0gcHBcbiAgICAgICAgICBuX3N0YWNrW3MtMl0gPSBuXG4gICAgICAgICAgbl9zdGFja1tzLTFdID0gcFxuICAgICAgICAgIHJlY291bnQocHApXG4gICAgICAgICAgcmVjb3VudChwKVxuICAgICAgICAgIHJlY291bnQobilcbiAgICAgICAgICBpZihzID49IDMpIHtcbiAgICAgICAgICAgIHZhciBwcHAgPSBuX3N0YWNrW3MtM11cbiAgICAgICAgICAgIGlmKHBwcC5sZWZ0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBwcC5yaWdodCA9IG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihwLnJpZ2h0ID09PSBuKSB7XG4gICAgICAgIHZhciB5ID0gcHAubGVmdFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUlJyXCIsIHkua2V5KVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5sZWZ0ID0gcmVwYWludChCTEFDSywgeSlcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBzIC09IDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUlJiXCIpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcHAucmlnaHQgPSBwLmxlZnRcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcC5sZWZ0ID0gcHBcbiAgICAgICAgICBuX3N0YWNrW3MtMl0gPSBwXG4gICAgICAgICAgbl9zdGFja1tzLTFdID0gblxuICAgICAgICAgIHJlY291bnQocHApXG4gICAgICAgICAgcmVjb3VudChwKVxuICAgICAgICAgIGlmKHMgPj0gMykge1xuICAgICAgICAgICAgdmFyIHBwcCA9IG5fc3RhY2tbcy0zXVxuICAgICAgICAgICAgaWYocHBwLnJpZ2h0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IHBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHkgPSBwcC5sZWZ0XG4gICAgICAgIGlmKHkgJiYgeS5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSTHJcIilcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcHAubGVmdCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJMYlwiKVxuICAgICAgICAgIHAubGVmdCA9IG4ucmlnaHRcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBwcC5yaWdodCA9IG4ubGVmdFxuICAgICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBuLnJpZ2h0ID0gcFxuICAgICAgICAgIG4ubGVmdCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gblxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IHBcbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICByZWNvdW50KG4pXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAucmlnaHQgPT09IHBwKSB7XG4gICAgICAgICAgICAgIHBwcC5yaWdodCA9IG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBwcC5sZWZ0ID0gblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vUmV0dXJuIG5ldyB0cmVlXG4gIG5fc3RhY2tbMF0uX2NvbG9yID0gQkxBQ0tcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUoY21wLCBuX3N0YWNrWzBdKVxufVxuXG5cbi8vVmlzaXQgYWxsIG5vZGVzIGlub3JkZXJcbmZ1bmN0aW9uIGRvVmlzaXRGdWxsKHZpc2l0LCBub2RlKSB7XG4gIGlmKG5vZGUubGVmdCkge1xuICAgIHZhciB2ID0gZG9WaXNpdEZ1bGwodmlzaXQsIG5vZGUubGVmdClcbiAgICBpZih2KSB7IHJldHVybiB2IH1cbiAgfVxuICB2YXIgdiA9IHZpc2l0KG5vZGUua2V5LCBub2RlLnZhbHVlKVxuICBpZih2KSB7IHJldHVybiB2IH1cbiAgaWYobm9kZS5yaWdodCkge1xuICAgIHJldHVybiBkb1Zpc2l0RnVsbCh2aXNpdCwgbm9kZS5yaWdodClcbiAgfVxufVxuXG4vL1Zpc2l0IGhhbGYgbm9kZXMgaW4gb3JkZXJcbmZ1bmN0aW9uIGRvVmlzaXRIYWxmKGxvLCBjb21wYXJlLCB2aXNpdCwgbm9kZSkge1xuICB2YXIgbCA9IGNvbXBhcmUobG8sIG5vZGUua2V5KVxuICBpZihsIDw9IDApIHtcbiAgICBpZihub2RlLmxlZnQpIHtcbiAgICAgIHZhciB2ID0gZG9WaXNpdEhhbGYobG8sIGNvbXBhcmUsIHZpc2l0LCBub2RlLmxlZnQpXG4gICAgICBpZih2KSB7IHJldHVybiB2IH1cbiAgICB9XG4gICAgdmFyIHYgPSB2aXNpdChub2RlLmtleSwgbm9kZS52YWx1ZSlcbiAgICBpZih2KSB7IHJldHVybiB2IH1cbiAgfVxuICBpZihub2RlLnJpZ2h0KSB7XG4gICAgcmV0dXJuIGRvVmlzaXRIYWxmKGxvLCBjb21wYXJlLCB2aXNpdCwgbm9kZS5yaWdodClcbiAgfVxufVxuXG4vL1Zpc2l0IGFsbCBub2RlcyB3aXRoaW4gYSByYW5nZVxuZnVuY3Rpb24gZG9WaXNpdChsbywgaGksIGNvbXBhcmUsIHZpc2l0LCBub2RlKSB7XG4gIHZhciBsID0gY29tcGFyZShsbywgbm9kZS5rZXkpXG4gIHZhciBoID0gY29tcGFyZShoaSwgbm9kZS5rZXkpXG4gIHZhciB2XG4gIGlmKGwgPD0gMCkge1xuICAgIGlmKG5vZGUubGVmdCkge1xuICAgICAgdiA9IGRvVmlzaXQobG8sIGhpLCBjb21wYXJlLCB2aXNpdCwgbm9kZS5sZWZ0KVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICAgIGlmKGggPiAwKSB7XG4gICAgICB2ID0gdmlzaXQobm9kZS5rZXksIG5vZGUudmFsdWUpXG4gICAgICBpZih2KSB7IHJldHVybiB2IH1cbiAgICB9XG4gIH1cbiAgaWYoaCA+IDAgJiYgbm9kZS5yaWdodCkge1xuICAgIHJldHVybiBkb1Zpc2l0KGxvLCBoaSwgY29tcGFyZSwgdmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuXG5wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gcmJUcmVlRm9yRWFjaCh2aXNpdCwgbG8sIGhpKSB7XG4gIGlmKCF0aGlzLnJvb3QpIHtcbiAgICByZXR1cm5cbiAgfVxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBkb1Zpc2l0RnVsbCh2aXNpdCwgdGhpcy5yb290KVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZG9WaXNpdEhhbGYobG8sIHRoaXMuX2NvbXBhcmUsIHZpc2l0LCB0aGlzLnJvb3QpXG4gICAgYnJlYWtcblxuICAgIGNhc2UgMzpcbiAgICAgIGlmKHRoaXMuX2NvbXBhcmUobG8sIGhpKSA+PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIGRvVmlzaXQobG8sIGhpLCB0aGlzLl9jb21wYXJlLCB2aXNpdCwgdGhpcy5yb290KVxuICAgIGJyZWFrXG4gIH1cbn1cblxuLy9GaXJzdCBpdGVtIGluIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJiZWdpblwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gW11cbiAgICB2YXIgbiA9IHRoaXMucm9vdFxuICAgIHdoaWxlKG4pIHtcbiAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbiAgfVxufSlcblxuLy9MYXN0IGl0ZW0gaW4gbGlzdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImVuZFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gW11cbiAgICB2YXIgbiA9IHRoaXMucm9vdFxuICAgIHdoaWxlKG4pIHtcbiAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG4gIH1cbn0pXG5cbi8vRmluZCB0aGUgaXRoIGl0ZW0gaW4gdGhlIHRyZWVcbnByb3RvLmF0ID0gZnVuY3Rpb24oaWR4KSB7XG4gIGlmKGlkeCA8IDApIHtcbiAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIFtdKVxuICB9XG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBzdGFjayA9IFtdXG4gIHdoaWxlKHRydWUpIHtcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYobi5sZWZ0KSB7XG4gICAgICBpZihpZHggPCBuLmxlZnQuX2NvdW50KSB7XG4gICAgICAgIG4gPSBuLmxlZnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlkeCAtPSBuLmxlZnQuX2NvdW50XG4gICAgfVxuICAgIGlmKCFpZHgpIHtcbiAgICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG4gICAgfVxuICAgIGlkeCAtPSAxXG4gICAgaWYobi5yaWdodCkge1xuICAgICAgaWYoaWR4ID49IG4ucmlnaHQuX2NvdW50KSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBuID0gbi5yaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIFtdKVxufVxuXG5wcm90by5nZSA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB2YXIgbGFzdF9wdHIgPSAwXG4gIHdoaWxlKG4pIHtcbiAgICB2YXIgZCA9IGNtcChrZXksIG4ua2V5KVxuICAgIHN0YWNrLnB1c2gobilcbiAgICBpZihkIDw9IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPD0gMCkge1xuICAgICAgbiA9IG4ubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICBzdGFjay5sZW5ndGggPSBsYXN0X3B0clxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxufVxuXG5wcm90by5ndCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB2YXIgbGFzdF9wdHIgPSAwXG4gIHdoaWxlKG4pIHtcbiAgICB2YXIgZCA9IGNtcChrZXksIG4ua2V5KVxuICAgIHN0YWNrLnB1c2gobilcbiAgICBpZihkIDwgMCkge1xuICAgICAgbGFzdF9wdHIgPSBzdGFjay5sZW5ndGhcbiAgICB9XG4gICAgaWYoZCA8IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8ubHQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA+IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPD0gMCkge1xuICAgICAgbiA9IG4ubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICBzdGFjay5sZW5ndGggPSBsYXN0X3B0clxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxufVxuXG5wcm90by5sZSA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB2YXIgbGFzdF9wdHIgPSAwXG4gIHdoaWxlKG4pIHtcbiAgICB2YXIgZCA9IGNtcChrZXksIG4ua2V5KVxuICAgIHN0YWNrLnB1c2gobilcbiAgICBpZihkID49IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPCAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHN0YWNrLmxlbmd0aCA9IGxhc3RfcHRyXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG59XG5cbi8vRmluZHMgdGhlIGl0ZW0gd2l0aCBrZXkgaWYgaXQgZXhpc3RzXG5wcm90by5maW5kID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBjbXAgPSB0aGlzLl9jb21wYXJlXG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBzdGFjayA9IFtdXG4gIHdoaWxlKG4pIHtcbiAgICB2YXIgZCA9IGNtcChrZXksIG4ua2V5KVxuICAgIHN0YWNrLnB1c2gobilcbiAgICBpZihkID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbn1cblxuLy9SZW1vdmVzIGl0ZW0gd2l0aCBrZXkgZnJvbSB0cmVlXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGl0ZXIgPSB0aGlzLmZpbmQoa2V5KVxuICBpZihpdGVyKSB7XG4gICAgcmV0dXJuIGl0ZXIucmVtb3ZlKClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vL1JldHVybnMgdGhlIGl0ZW0gYXQgYGtleWBcbnByb3RvLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBpZihkID09PSAwKSB7XG4gICAgICByZXR1cm4gbi52YWx1ZVxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgcmV0dXJuXG59XG5cbi8vSXRlcmF0b3IgZm9yIHJlZCBibGFjayB0cmVlXG5mdW5jdGlvbiBSZWRCbGFja1RyZWVJdGVyYXRvcih0cmVlLCBzdGFjaykge1xuICB0aGlzLnRyZWUgPSB0cmVlXG4gIHRoaXMuX3N0YWNrID0gc3RhY2tcbn1cblxudmFyIGlwcm90byA9IFJlZEJsYWNrVHJlZUl0ZXJhdG9yLnByb3RvdHlwZVxuXG4vL1Rlc3QgaWYgaXRlcmF0b3IgaXMgdmFsaWRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwidmFsaWRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjay5sZW5ndGggPiAwXG4gIH1cbn0pXG5cbi8vTm9kZSBvZiB0aGUgaXRlcmF0b3Jcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwibm9kZVwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5fc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aC0xXVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vL01ha2VzIGEgY29weSBvZiBhbiBpdGVyYXRvclxuaXByb3RvLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcy50cmVlLCB0aGlzLl9zdGFjay5zbGljZSgpKVxufVxuXG4vL1N3YXBzIHR3byBub2Rlc1xuZnVuY3Rpb24gc3dhcE5vZGUobiwgdikge1xuICBuLmtleSA9IHYua2V5XG4gIG4udmFsdWUgPSB2LnZhbHVlXG4gIG4ubGVmdCA9IHYubGVmdFxuICBuLnJpZ2h0ID0gdi5yaWdodFxuICBuLl9jb2xvciA9IHYuX2NvbG9yXG4gIG4uX2NvdW50ID0gdi5fY291bnRcbn1cblxuLy9GaXggdXAgYSBkb3VibGUgYmxhY2sgbm9kZSBpbiBhIHRyZWVcbmZ1bmN0aW9uIGZpeERvdWJsZUJsYWNrKHN0YWNrKSB7XG4gIHZhciBuLCBwLCBzLCB6XG4gIGZvcih2YXIgaT1zdGFjay5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgbiA9IHN0YWNrW2ldXG4gICAgaWYoaSA9PT0gMCkge1xuICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJ2aXNpdCBub2RlOlwiLCBuLmtleSwgaSwgc3RhY2tbaV0ua2V5LCBzdGFja1tpLTFdLmtleSlcbiAgICBwID0gc3RhY2tbaS0xXVxuICAgIGlmKHAubGVmdCA9PT0gbikge1xuICAgICAgLy9jb25zb2xlLmxvZyhcImxlZnQgY2hpbGRcIilcbiAgICAgIHMgPSBwLnJpZ2h0XG4gICAgICBpZihzLnJpZ2h0ICYmIHMucmlnaHQuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMTogcmlnaHQgc2libGluZyBjaGlsZCByZWRcIilcbiAgICAgICAgcyA9IHAucmlnaHQgPSBjbG9uZU5vZGUocylcbiAgICAgICAgeiA9IHMucmlnaHQgPSBjbG9uZU5vZGUocy5yaWdodClcbiAgICAgICAgcC5yaWdodCA9IHMubGVmdFxuICAgICAgICBzLmxlZnQgPSBwXG4gICAgICAgIHMucmlnaHQgPSB6XG4gICAgICAgIHMuX2NvbG9yID0gcC5fY29sb3JcbiAgICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHouX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcmVjb3VudChwKVxuICAgICAgICByZWNvdW50KHMpXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLmxlZnQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSBzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZihzLmxlZnQgJiYgcy5sZWZ0Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDE6IGxlZnQgc2libGluZyBjaGlsZCByZWRcIilcbiAgICAgICAgcyA9IHAucmlnaHQgPSBjbG9uZU5vZGUocylcbiAgICAgICAgeiA9IHMubGVmdCA9IGNsb25lTm9kZShzLmxlZnQpXG4gICAgICAgIHAucmlnaHQgPSB6LmxlZnRcbiAgICAgICAgcy5sZWZ0ID0gei5yaWdodFxuICAgICAgICB6LmxlZnQgPSBwXG4gICAgICAgIHoucmlnaHQgPSBzXG4gICAgICAgIHouX2NvbG9yID0gcC5fY29sb3JcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICBzLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcmVjb3VudChwKVxuICAgICAgICByZWNvdW50KHMpXG4gICAgICAgIHJlY291bnQoeilcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgICAgICAgcHAubGVmdCA9IHpcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAucmlnaHQgPSB6XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSB6XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYocy5fY29sb3IgPT09IEJMQUNLKSB7XG4gICAgICAgIGlmKHAuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAyOiBibGFjayBzaWJsaW5nLCByZWQgcGFyZW50XCIsIHAucmlnaHQudmFsdWUpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAucmlnaHQgPSByZXBhaW50KFJFRCwgcylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAyOiBibGFjayBzaWJsaW5nLCBibGFjayBwYXJlbnRcIiwgcC5yaWdodC52YWx1ZSlcbiAgICAgICAgICBwLnJpZ2h0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgY29udGludWUgIFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAzOiByZWQgc2libGluZ1wiKVxuICAgICAgICBzID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHAucmlnaHQgPSBzLmxlZnRcbiAgICAgICAgcy5sZWZ0ID0gcFxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gUkVEXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5sZWZ0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHNcbiAgICAgICAgc3RhY2tbaV0gPSBwXG4gICAgICAgIGlmKGkrMSA8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHN0YWNrW2krMV0gPSBuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sucHVzaChuKVxuICAgICAgICB9XG4gICAgICAgIGkgPSBpKzJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9jb25zb2xlLmxvZyhcInJpZ2h0IGNoaWxkXCIpXG4gICAgICBzID0gcC5sZWZ0XG4gICAgICBpZihzLmxlZnQgJiYgcy5sZWZ0Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDE6IGxlZnQgc2libGluZyBjaGlsZCByZWRcIiwgcC52YWx1ZSwgcC5fY29sb3IpXG4gICAgICAgIHMgPSBwLmxlZnQgPSBjbG9uZU5vZGUocylcbiAgICAgICAgeiA9IHMubGVmdCA9IGNsb25lTm9kZShzLmxlZnQpXG4gICAgICAgIHAubGVmdCA9IHMucmlnaHRcbiAgICAgICAgcy5yaWdodCA9IHBcbiAgICAgICAgcy5sZWZ0ID0gelxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICB6Ll9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5yaWdodCA9PT0gcCkge1xuICAgICAgICAgICAgcHAucmlnaHQgPSBzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSBzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSBzXG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIGlmKHMucmlnaHQgJiYgcy5yaWdodC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiByaWdodCBzaWJsaW5nIGNoaWxkIHJlZFwiKVxuICAgICAgICBzID0gcC5sZWZ0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLnJpZ2h0ID0gY2xvbmVOb2RlKHMucmlnaHQpXG4gICAgICAgIHAubGVmdCA9IHoucmlnaHRcbiAgICAgICAgcy5yaWdodCA9IHoubGVmdFxuICAgICAgICB6LnJpZ2h0ID0gcFxuICAgICAgICB6LmxlZnQgPSBzXG4gICAgICAgIHouX2NvbG9yID0gcC5fY29sb3JcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICBzLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcmVjb3VudChwKVxuICAgICAgICByZWNvdW50KHMpXG4gICAgICAgIHJlY291bnQoeilcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gelxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gelxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gelxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmKHMuX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgICBpZihwLl9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgcmVkIHBhcmVudFwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwLmxlZnQgPSByZXBhaW50KFJFRCwgcylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAyOiBibGFjayBzaWJsaW5nLCBibGFjayBwYXJlbnRcIilcbiAgICAgICAgICBwLmxlZnQgPSByZXBhaW50KFJFRCwgcylcbiAgICAgICAgICBjb250aW51ZSAgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDM6IHJlZCBzaWJsaW5nXCIpXG4gICAgICAgIHMgPSBjbG9uZU5vZGUocylcbiAgICAgICAgcC5sZWZ0ID0gcy5yaWdodFxuICAgICAgICBzLnJpZ2h0ID0gcFxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gUkVEXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5yaWdodCA9PT0gcCkge1xuICAgICAgICAgICAgcHAucmlnaHQgPSBzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSBzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSBzXG4gICAgICAgIHN0YWNrW2ldID0gcFxuICAgICAgICBpZihpKzEgPCBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBzdGFja1tpKzFdID0gblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgICAgfVxuICAgICAgICBpID0gaSsyXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vUmVtb3ZlcyBpdGVtIGF0IGl0ZXJhdG9yIGZyb20gdHJlZVxuaXByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy50cmVlXG4gIH1cbiAgLy9GaXJzdCBjb3B5IHBhdGggdG8gbm9kZVxuICB2YXIgY3N0YWNrID0gbmV3IEFycmF5KHN0YWNrLmxlbmd0aClcbiAgdmFyIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgY3N0YWNrW2NzdGFjay5sZW5ndGgtMV0gPSBuZXcgUkJOb2RlKG4uX2NvbG9yLCBuLmtleSwgbi52YWx1ZSwgbi5sZWZ0LCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgZm9yKHZhciBpPXN0YWNrLmxlbmd0aC0yOyBpPj0wOyAtLWkpIHtcbiAgICB2YXIgbiA9IHN0YWNrW2ldXG4gICAgaWYobi5sZWZ0ID09PSBzdGFja1tpKzFdKSB7XG4gICAgICBjc3RhY2tbaV0gPSBuZXcgUkJOb2RlKG4uX2NvbG9yLCBuLmtleSwgbi52YWx1ZSwgY3N0YWNrW2krMV0sIG4ucmlnaHQsIG4uX2NvdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBjc3RhY2tbaV0gPSBuZXcgUkJOb2RlKG4uX2NvbG9yLCBuLmtleSwgbi52YWx1ZSwgbi5sZWZ0LCBjc3RhY2tbaSsxXSwgbi5fY291bnQpXG4gICAgfVxuICB9XG5cbiAgLy9HZXQgbm9kZVxuICBuID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMV1cbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0IHJlbW92ZTogXCIsIG4udmFsdWUpXG5cbiAgLy9JZiBub3QgbGVhZiwgdGhlbiBzd2FwIHdpdGggcHJldmlvdXMgbm9kZVxuICBpZihuLmxlZnQgJiYgbi5yaWdodCkge1xuICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgdG8gbGVhZlwiKVxuXG4gICAgLy9GaXJzdCB3YWxrIHRvIHByZXZpb3VzIGxlYWZcbiAgICB2YXIgc3BsaXQgPSBjc3RhY2subGVuZ3RoXG4gICAgbiA9IG4ubGVmdFxuICAgIHdoaWxlKG4ucmlnaHQpIHtcbiAgICAgIGNzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICAvL0NvcHkgcGF0aCB0byBsZWFmXG4gICAgdmFyIHYgPSBjc3RhY2tbc3BsaXQtMV1cbiAgICBjc3RhY2sucHVzaChuZXcgUkJOb2RlKG4uX2NvbG9yLCB2LmtleSwgdi52YWx1ZSwgbi5sZWZ0LCBuLnJpZ2h0LCBuLl9jb3VudCkpXG4gICAgY3N0YWNrW3NwbGl0LTFdLmtleSA9IG4ua2V5XG4gICAgY3N0YWNrW3NwbGl0LTFdLnZhbHVlID0gbi52YWx1ZVxuXG4gICAgLy9GaXggdXAgc3RhY2tcbiAgICBmb3IodmFyIGk9Y3N0YWNrLmxlbmd0aC0yOyBpPj1zcGxpdDsgLS1pKSB7XG4gICAgICBuID0gY3N0YWNrW2ldXG4gICAgICBjc3RhY2tbaV0gPSBuZXcgUkJOb2RlKG4uX2NvbG9yLCBuLmtleSwgbi52YWx1ZSwgbi5sZWZ0LCBjc3RhY2tbaSsxXSwgbi5fY291bnQpXG4gICAgfVxuICAgIGNzdGFja1tzcGxpdC0xXS5sZWZ0ID0gY3N0YWNrW3NwbGl0XVxuICB9XG4gIC8vY29uc29sZS5sb2coXCJzdGFjaz1cIiwgY3N0YWNrLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2LnZhbHVlIH0pKVxuXG4gIC8vUmVtb3ZlIGxlYWYgbm9kZVxuICBuID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMV1cbiAgaWYobi5fY29sb3IgPT09IFJFRCkge1xuICAgIC8vRWFzeSBjYXNlOiByZW1vdmluZyByZWQgbGVhZlxuICAgIC8vY29uc29sZS5sb2coXCJSRUQgbGVhZlwiKVxuICAgIHZhciBwID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMl1cbiAgICBpZihwLmxlZnQgPT09IG4pIHtcbiAgICAgIHAubGVmdCA9IG51bGxcbiAgICB9IGVsc2UgaWYocC5yaWdodCA9PT0gbikge1xuICAgICAgcC5yaWdodCA9IG51bGxcbiAgICB9XG4gICAgY3N0YWNrLnBvcCgpXG4gICAgZm9yKHZhciBpPTA7IGk8Y3N0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICBjc3RhY2tbaV0uX2NvdW50LS1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG4gIH0gZWxzZSB7XG4gICAgaWYobi5sZWZ0IHx8IG4ucmlnaHQpIHtcbiAgICAgIC8vU2Vjb25kIGVhc3kgY2FzZTogIFNpbmdsZSBjaGlsZCBibGFjayBwYXJlbnRcbiAgICAgIC8vY29uc29sZS5sb2coXCJCTEFDSyBzaW5nbGUgY2hpbGRcIilcbiAgICAgIGlmKG4ubGVmdCkge1xuICAgICAgICBzd2FwTm9kZShuLCBuLmxlZnQpXG4gICAgICB9IGVsc2UgaWYobi5yaWdodCkge1xuICAgICAgICBzd2FwTm9kZShuLCBuLnJpZ2h0KVxuICAgICAgfVxuICAgICAgLy9DaGlsZCBtdXN0IGJlIHJlZCwgc28gcmVwYWludCBpdCBibGFjayB0byBiYWxhbmNlIGNvbG9yXG4gICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICBmb3IodmFyIGk9MDsgaTxjc3RhY2subGVuZ3RoLTE7ICsraSkge1xuICAgICAgICBjc3RhY2tbaV0uX2NvdW50LS1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKHRoaXMudHJlZS5fY29tcGFyZSwgY3N0YWNrWzBdKVxuICAgIH0gZWxzZSBpZihjc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAvL1RoaXJkIGVhc3kgY2FzZTogcm9vdFxuICAgICAgLy9jb25zb2xlLmxvZyhcIlJPT1RcIilcbiAgICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKHRoaXMudHJlZS5fY29tcGFyZSwgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgLy9IYXJkIGNhc2U6IFJlcGFpbnQgbiwgYW5kIHRoZW4gZG8gc29tZSBuYXN0eSBzdHVmZlxuICAgICAgLy9jb25zb2xlLmxvZyhcIkJMQUNLIGxlYWYgbm8gY2hpbGRyZW5cIilcbiAgICAgIGZvcih2YXIgaT0wOyBpPGNzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICBjc3RhY2tbaV0uX2NvdW50LS1cbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBjc3RhY2tbY3N0YWNrLmxlbmd0aC0yXVxuICAgICAgZml4RG91YmxlQmxhY2soY3N0YWNrKVxuICAgICAgLy9GaXggdXAgbGlua3NcbiAgICAgIGlmKHBhcmVudC5sZWZ0ID09PSBuKSB7XG4gICAgICAgIHBhcmVudC5sZWZ0ID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LnJpZ2h0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIGNzdGFja1swXSlcbn1cblxuLy9SZXR1cm5zIGtleVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGlwcm90bywgXCJrZXlcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV0ua2V5XG4gICAgfVxuICAgIHJldHVyblxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vL1JldHVybnMgdmFsdWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwidmFsdWVcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV0udmFsdWVcbiAgICB9XG4gICAgcmV0dXJuXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cblxuLy9SZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGlzIGl0ZXJhdG9yIGluIHRoZSBzb3J0ZWQgbGlzdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGlwcm90bywgXCJpbmRleFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDBcbiAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICAgIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnRyZWUucm9vdFxuICAgICAgaWYocikge1xuICAgICAgICByZXR1cm4gci5fY291bnRcbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmKHN0YWNrW3N0YWNrLmxlbmd0aC0xXS5sZWZ0KSB7XG4gICAgICBpZHggPSBzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdC5fY291bnRcbiAgICB9XG4gICAgZm9yKHZhciBzPXN0YWNrLmxlbmd0aC0yOyBzPj0wOyAtLXMpIHtcbiAgICAgIGlmKHN0YWNrW3MrMV0gPT09IHN0YWNrW3NdLnJpZ2h0KSB7XG4gICAgICAgICsraWR4XG4gICAgICAgIGlmKHN0YWNrW3NdLmxlZnQpIHtcbiAgICAgICAgICBpZHggKz0gc3RhY2tbc10ubGVmdC5fY291bnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbi8vQWR2YW5jZXMgaXRlcmF0b3IgdG8gbmV4dCBlbGVtZW50IGluIGxpc3Rcbmlwcm90by5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4ucmlnaHQpIHtcbiAgICBuID0gbi5yaWdodFxuICAgIHdoaWxlKG4pIHtcbiAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sucG9wKClcbiAgICB3aGlsZShzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aC0xXS5yaWdodCA9PT0gbikge1xuICAgICAgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgICAgc3RhY2sucG9wKClcbiAgICB9XG4gIH1cbn1cblxuLy9DaGVja3MgaWYgaXRlcmF0b3IgaXMgYXQgZW5kIG9mIHRyZWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaGFzTmV4dFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ucmlnaHQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGZvcih2YXIgcz1zdGFjay5sZW5ndGgtMTsgcz4wOyAtLXMpIHtcbiAgICAgIGlmKHN0YWNrW3MtMV0ubGVmdCA9PT0gc3RhY2tbc10pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pXG5cbi8vVXBkYXRlIHZhbHVlXG5pcHJvdG8udXBkYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXBkYXRlIGVtcHR5IG5vZGUhXCIpXG4gIH1cbiAgdmFyIGNzdGFjayA9IG5ldyBBcnJheShzdGFjay5sZW5ndGgpXG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGNzdGFja1tjc3RhY2subGVuZ3RoLTFdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIHZhbHVlLCBuLmxlZnQsIG4ucmlnaHQsIG4uX2NvdW50KVxuICBmb3IodmFyIGk9c3RhY2subGVuZ3RoLTI7IGk+PTA7IC0taSkge1xuICAgIG4gPSBzdGFja1tpXVxuICAgIGlmKG4ubGVmdCA9PT0gc3RhY2tbaSsxXSkge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIGNzdGFja1tpKzFdLCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIGNzdGFja1swXSlcbn1cblxuLy9Nb3ZlcyBpdGVyYXRvciBiYWNrd2FyZCBvbmUgZWxlbWVudFxuaXByb3RvLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgaWYobi5sZWZ0KSB7XG4gICAgbiA9IG4ubGVmdFxuICAgIHdoaWxlKG4pIHtcbiAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YWNrLnBvcCgpXG4gICAgd2hpbGUoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCA9PT0gbikge1xuICAgICAgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgICAgc3RhY2sucG9wKClcbiAgICB9XG4gIH1cbn1cblxuLy9DaGVja3MgaWYgaXRlcmF0b3IgaXMgYXQgc3RhcnQgb2YgdHJlZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGlwcm90bywgXCJoYXNQcmV2XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICAgIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmKHN0YWNrW3N0YWNrLmxlbmd0aC0xXS5sZWZ0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IodmFyIHM9c3RhY2subGVuZ3RoLTE7IHM+MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzLTFdLnJpZ2h0ID09PSBzdGFja1tzXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSlcblxuLy9EZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb25cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgaWYoYSA8IGIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZihhID4gYikge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9CdWlsZCBhIHRyZWVcbmZ1bmN0aW9uIGNyZWF0ZVJCVHJlZShjb21wYXJlKSB7XG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmUsIG51bGwpXG59IiwiLy8gdHJhbnNsaXRlcmF0ZWQgZnJvbSB0aGUgcHl0aG9uIHNuaXBwZXQgaGVyZTpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuY3pvc19hcHByb3hpbWF0aW9uXG5cbnZhciBnID0gNztcbnZhciBwID0gW1xuICAgIDAuOTk5OTk5OTk5OTk5ODA5OTMsXG4gICAgNjc2LjUyMDM2ODEyMTg4NTEsXG4gICAgLTEyNTkuMTM5MjE2NzIyNDAyOCxcbiAgICA3NzEuMzIzNDI4Nzc3NjUzMTMsXG4gICAgLTE3Ni42MTUwMjkxNjIxNDA1OSxcbiAgICAxMi41MDczNDMyNzg2ODY5MDUsXG4gICAgLTAuMTM4NTcxMDk1MjY1NzIwMTIsXG4gICAgOS45ODQzNjk1NzgwMTk1NzE2ZS02LFxuICAgIDEuNTA1NjMyNzM1MTQ5MzExNmUtN1xuXTtcblxudmFyIGdfbG4gPSA2MDcvMTI4O1xudmFyIHBfbG4gPSBbXG4gICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsXG4gICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAxNC4xMzYwOTc5NzQ3NDE3NDcxNzQsXG4gICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgMC4zMzk5NDY0OTk4NDgxMTg4ODY5OWUtNCxcbiAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgIC0wLjk4Mzc0NDc1MzA0ODc5NTY0Njc3ZS00LFxuICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAtMC4xNjQzMTgxMDY1MzY3NjM4OTAyMmUtMyxcbiAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgIC0wLjI2MTkwODM4NDAxNTgxNDA4NjcwZS00LFxuICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbl07XG5cbi8vIFNwb3VnZSBhcHByb3hpbWF0aW9uIChzdWl0YWJsZSBmb3IgbGFyZ2UgYXJndW1lbnRzKVxuZnVuY3Rpb24gbG5nYW1tYSh6KSB7XG5cbiAgICBpZih6IDwgMCkgcmV0dXJuIE51bWJlcignMC8wJyk7XG4gICAgdmFyIHggPSBwX2xuWzBdO1xuICAgIGZvcih2YXIgaSA9IHBfbG4ubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSkgeCArPSBwX2xuW2ldIC8gKHogKyBpKTtcbiAgICB2YXIgdCA9IHogKyBnX2xuICsgMC41O1xuICAgIHJldHVybiAuNSpNYXRoLmxvZygyKk1hdGguUEkpKyh6Ky41KSpNYXRoLmxvZyh0KS10K01hdGgubG9nKHgpLU1hdGgubG9nKHopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdhbW1hICh6KSB7XG4gICAgaWYgKHogPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIHopICogZ2FtbWEoMSAtIHopKTtcbiAgICB9XG4gICAgZWxzZSBpZih6ID4gMTAwKSByZXR1cm4gTWF0aC5leHAobG5nYW1tYSh6KSk7XG4gICAgZWxzZSB7XG4gICAgICAgIHogLT0gMTtcbiAgICAgICAgdmFyIHggPSBwWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGcgKyAyOyBpKyspIHtcbiAgICAgICAgICAgIHggKz0gcFtpXSAvICh6ICsgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSB6ICsgZyArIDAuNTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKVxuICAgICAgICAgICAgKiBNYXRoLnBvdyh0LCB6ICsgMC41KVxuICAgICAgICAgICAgKiBNYXRoLmV4cCgtdClcbiAgICAgICAgICAgICogeFxuICAgICAgICA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMubG9nID0gbG5nYW1tYTtcbiIsIm1vZHVsZS5leHBvcnRzID0gYWRqb2ludDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVF1YXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciBzLCBjLCB0XG4gIHZhciB4ID0gYXhpc1swXVxuICB2YXIgeSA9IGF4aXNbMV1cbiAgdmFyIHogPSBheGlzWzJdXG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KVxuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgMC4wMDAwMDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGVuID0gMSAvIGxlblxuICB4ICo9IGxlblxuICB5ICo9IGxlblxuICB6ICo9IGxlblxuXG4gIHMgPSBNYXRoLnNpbihyYWQpXG4gIGMgPSBNYXRoLmNvcyhyYWQpXG4gIHQgPSAxIC0gY1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IHggKiB4ICogdCArIGNcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHNcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHNcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogc1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjXG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHNcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHNcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGNcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tU2NhbGluZ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSAwXG4gIG91dFs1XSA9IHZbMV1cbiAgb3V0WzZdID0gMFxuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IDBcbiAgb3V0WzldID0gMFxuICBvdXRbMTBdID0gdlsyXVxuICBvdXRbMTFdID0gMFxuICBvdXRbMTJdID0gMFxuICBvdXRbMTNdID0gMFxuICBvdXRbMTRdID0gMFxuICBvdXRbMTVdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21UcmFuc2xhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSAxXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IDFcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IHZbMF1cbiAgb3V0WzEzXSA9IHZbMV1cbiAgb3V0WzE0XSA9IHZbMl1cbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWFJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gMVxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IDBcbiAgICBvdXRbNV0gPSBjXG4gICAgb3V0WzZdID0gc1xuICAgIG91dFs3XSA9IDBcbiAgICBvdXRbOF0gPSAwXG4gICAgb3V0WzldID0gLXNcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAtc1xuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gMVxuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gc1xuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWlJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IHNcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IC1zXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gMVxuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcnVzdHVtO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgaWRlbnRpdHk6IHJlcXVpcmUoJy4vaWRlbnRpdHknKVxuICAsIHRyYW5zcG9zZTogcmVxdWlyZSgnLi90cmFuc3Bvc2UnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGFkam9pbnQ6IHJlcXVpcmUoJy4vYWRqb2ludCcpXG4gICwgZGV0ZXJtaW5hbnQ6IHJlcXVpcmUoJy4vZGV0ZXJtaW5hbnQnKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCB0cmFuc2xhdGU6IHJlcXVpcmUoJy4vdHJhbnNsYXRlJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZnJvbVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvbicpXG4gICwgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24nKVxuICAsIGZyb21TY2FsaW5nOiByZXF1aXJlKCcuL2Zyb21TY2FsaW5nJylcbiAgLCBmcm9tVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVRyYW5zbGF0aW9uJylcbiAgLCBmcm9tWFJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21YUm90YXRpb24nKVxuICAsIGZyb21ZUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVlSb3RhdGlvbicpXG4gICwgZnJvbVpSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWlJvdGF0aW9uJylcbiAgLCBmcm9tUXVhdDogcmVxdWlyZSgnLi9mcm9tUXVhdCcpXG4gICwgZnJ1c3R1bTogcmVxdWlyZSgnLi9mcnVzdHVtJylcbiAgLCBwZXJzcGVjdGl2ZTogcmVxdWlyZSgnLi9wZXJzcGVjdGl2ZScpXG4gICwgcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcnKVxuICAsIG9ydGhvOiByZXF1aXJlKCcuL29ydGhvJylcbiAgLCBsb29rQXQ6IHJlcXVpcmUoJy4vbG9va0F0JylcbiAgLCBzdHI6IHJlcXVpcmUoJy4vc3RyJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2tBdDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gb3J0aG87XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmU7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWjtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc3RyO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc3RyKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlO1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5ncykge1xuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXG4gIHZhciBleHBycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpXG4gIHZhciBwYXJ0cyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgcGFydHMucHVzaChzdHJpbmdzW2ldLCBleHByc1tpXSB8fCAnJylcbiAgfVxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBib3VuZHMgPSByZXF1aXJlKFwiYmluYXJ5LXNlYXJjaC1ib3VuZHNcIilcblxudmFyIE5PVF9GT1VORCA9IDBcbnZhciBTVUNDRVNTID0gMVxudmFyIEVNUFRZID0gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdyYXBwZXJcblxuZnVuY3Rpb24gSW50ZXJ2YWxUcmVlTm9kZShtaWQsIGxlZnQsIHJpZ2h0LCBsZWZ0UG9pbnRzLCByaWdodFBvaW50cykge1xuICB0aGlzLm1pZCA9IG1pZFxuICB0aGlzLmxlZnQgPSBsZWZ0XG4gIHRoaXMucmlnaHQgPSByaWdodFxuICB0aGlzLmxlZnRQb2ludHMgPSBsZWZ0UG9pbnRzXG4gIHRoaXMucmlnaHRQb2ludHMgPSByaWdodFBvaW50c1xuICB0aGlzLmNvdW50ID0gKGxlZnQgPyBsZWZ0LmNvdW50IDogMCkgKyAocmlnaHQgPyByaWdodC5jb3VudCA6IDApICsgbGVmdFBvaW50cy5sZW5ndGhcbn1cblxudmFyIHByb3RvID0gSW50ZXJ2YWxUcmVlTm9kZS5wcm90b3R5cGVcblxuZnVuY3Rpb24gY29weShhLCBiKSB7XG4gIGEubWlkID0gYi5taWRcbiAgYS5sZWZ0ID0gYi5sZWZ0XG4gIGEucmlnaHQgPSBiLnJpZ2h0XG4gIGEubGVmdFBvaW50cyA9IGIubGVmdFBvaW50c1xuICBhLnJpZ2h0UG9pbnRzID0gYi5yaWdodFBvaW50c1xuICBhLmNvdW50ID0gYi5jb3VudFxufVxuXG5mdW5jdGlvbiByZWJ1aWxkKG5vZGUsIGludGVydmFscykge1xuICB2YXIgbnRyZWUgPSBjcmVhdGVJbnRlcnZhbFRyZWUoaW50ZXJ2YWxzKVxuICBub2RlLm1pZCA9IG50cmVlLm1pZFxuICBub2RlLmxlZnQgPSBudHJlZS5sZWZ0XG4gIG5vZGUucmlnaHQgPSBudHJlZS5yaWdodFxuICBub2RlLmxlZnRQb2ludHMgPSBudHJlZS5sZWZ0UG9pbnRzXG4gIG5vZGUucmlnaHRQb2ludHMgPSBudHJlZS5yaWdodFBvaW50c1xuICBub2RlLmNvdW50ID0gbnRyZWUuY291bnRcbn1cblxuZnVuY3Rpb24gcmVidWlsZFdpdGhJbnRlcnZhbChub2RlLCBpbnRlcnZhbCkge1xuICB2YXIgaW50ZXJ2YWxzID0gbm9kZS5pbnRlcnZhbHMoW10pXG4gIGludGVydmFscy5wdXNoKGludGVydmFsKVxuICByZWJ1aWxkKG5vZGUsIGludGVydmFscykgICAgXG59XG5cbmZ1bmN0aW9uIHJlYnVpbGRXaXRob3V0SW50ZXJ2YWwobm9kZSwgaW50ZXJ2YWwpIHtcbiAgdmFyIGludGVydmFscyA9IG5vZGUuaW50ZXJ2YWxzKFtdKVxuICB2YXIgaWR4ID0gaW50ZXJ2YWxzLmluZGV4T2YoaW50ZXJ2YWwpXG4gIGlmKGlkeCA8IDApIHtcbiAgICByZXR1cm4gTk9UX0ZPVU5EXG4gIH1cbiAgaW50ZXJ2YWxzLnNwbGljZShpZHgsIDEpXG4gIHJlYnVpbGQobm9kZSwgaW50ZXJ2YWxzKVxuICByZXR1cm4gU1VDQ0VTU1xufVxuXG5wcm90by5pbnRlcnZhbHMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLmxlZnRQb2ludHMpXG4gIGlmKHRoaXMubGVmdCkge1xuICAgIHRoaXMubGVmdC5pbnRlcnZhbHMocmVzdWx0KVxuICB9XG4gIGlmKHRoaXMucmlnaHQpIHtcbiAgICB0aGlzLnJpZ2h0LmludGVydmFscyhyZXN1bHQpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5wcm90by5pbnNlcnQgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICB2YXIgd2VpZ2h0ID0gdGhpcy5jb3VudCAtIHRoaXMubGVmdFBvaW50cy5sZW5ndGhcbiAgdGhpcy5jb3VudCArPSAxXG4gIGlmKGludGVydmFsWzFdIDwgdGhpcy5taWQpIHtcbiAgICBpZih0aGlzLmxlZnQpIHtcbiAgICAgIGlmKDQqKHRoaXMubGVmdC5jb3VudCsxKSA+IDMqKHdlaWdodCsxKSkge1xuICAgICAgICByZWJ1aWxkV2l0aEludGVydmFsKHRoaXMsIGludGVydmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChpbnRlcnZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWZ0ID0gY3JlYXRlSW50ZXJ2YWxUcmVlKFtpbnRlcnZhbF0pXG4gICAgfVxuICB9IGVsc2UgaWYoaW50ZXJ2YWxbMF0gPiB0aGlzLm1pZCkge1xuICAgIGlmKHRoaXMucmlnaHQpIHtcbiAgICAgIGlmKDQqKHRoaXMucmlnaHQuY291bnQrMSkgPiAzKih3ZWlnaHQrMSkpIHtcbiAgICAgICAgcmVidWlsZFdpdGhJbnRlcnZhbCh0aGlzLCBpbnRlcnZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KGludGVydmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gY3JlYXRlSW50ZXJ2YWxUcmVlKFtpbnRlcnZhbF0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsID0gYm91bmRzLmdlKHRoaXMubGVmdFBvaW50cywgaW50ZXJ2YWwsIGNvbXBhcmVCZWdpbilcbiAgICB2YXIgciA9IGJvdW5kcy5nZSh0aGlzLnJpZ2h0UG9pbnRzLCBpbnRlcnZhbCwgY29tcGFyZUVuZClcbiAgICB0aGlzLmxlZnRQb2ludHMuc3BsaWNlKGwsIDAsIGludGVydmFsKVxuICAgIHRoaXMucmlnaHRQb2ludHMuc3BsaWNlKHIsIDAsIGludGVydmFsKVxuICB9XG59XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIHZhciB3ZWlnaHQgPSB0aGlzLmNvdW50IC0gdGhpcy5sZWZ0UG9pbnRzXG4gIGlmKGludGVydmFsWzFdIDwgdGhpcy5taWQpIHtcbiAgICBpZighdGhpcy5sZWZ0KSB7XG4gICAgICByZXR1cm4gTk9UX0ZPVU5EXG4gICAgfVxuICAgIHZhciBydyA9IHRoaXMucmlnaHQgPyB0aGlzLnJpZ2h0LmNvdW50IDogMFxuICAgIGlmKDQgKiBydyA+IDMgKiAod2VpZ2h0LTEpKSB7XG4gICAgICByZXR1cm4gcmVidWlsZFdpdGhvdXRJbnRlcnZhbCh0aGlzLCBpbnRlcnZhbClcbiAgICB9XG4gICAgdmFyIHIgPSB0aGlzLmxlZnQucmVtb3ZlKGludGVydmFsKVxuICAgIGlmKHIgPT09IEVNUFRZKSB7XG4gICAgICB0aGlzLmxlZnQgPSBudWxsXG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICAgIHJldHVybiBTVUNDRVNTXG4gICAgfSBlbHNlIGlmKHIgPT09IFNVQ0NFU1MpIHtcbiAgICAgIHRoaXMuY291bnQgLT0gMVxuICAgIH1cbiAgICByZXR1cm4gclxuICB9IGVsc2UgaWYoaW50ZXJ2YWxbMF0gPiB0aGlzLm1pZCkge1xuICAgIGlmKCF0aGlzLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gTk9UX0ZPVU5EXG4gICAgfVxuICAgIHZhciBsdyA9IHRoaXMubGVmdCA/IHRoaXMubGVmdC5jb3VudCA6IDBcbiAgICBpZig0ICogbHcgPiAzICogKHdlaWdodC0xKSkge1xuICAgICAgcmV0dXJuIHJlYnVpbGRXaXRob3V0SW50ZXJ2YWwodGhpcywgaW50ZXJ2YWwpXG4gICAgfVxuICAgIHZhciByID0gdGhpcy5yaWdodC5yZW1vdmUoaW50ZXJ2YWwpXG4gICAgaWYociA9PT0gRU1QVFkpIHtcbiAgICAgIHRoaXMucmlnaHQgPSBudWxsXG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICAgIHJldHVybiBTVUNDRVNTXG4gICAgfSBlbHNlIGlmKHIgPT09IFNVQ0NFU1MpIHtcbiAgICAgIHRoaXMuY291bnQgLT0gMVxuICAgIH1cbiAgICByZXR1cm4gclxuICB9IGVsc2Uge1xuICAgIGlmKHRoaXMuY291bnQgPT09IDEpIHtcbiAgICAgIGlmKHRoaXMubGVmdFBvaW50c1swXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTk9UX0ZPVU5EXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHRoaXMubGVmdFBvaW50cy5sZW5ndGggPT09IDEgJiYgdGhpcy5sZWZ0UG9pbnRzWzBdID09PSBpbnRlcnZhbCkge1xuICAgICAgaWYodGhpcy5sZWZ0ICYmIHRoaXMucmlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzXG4gICAgICAgIHZhciBuID0gdGhpcy5sZWZ0XG4gICAgICAgIHdoaWxlKG4ucmlnaHQpIHtcbiAgICAgICAgICBwID0gblxuICAgICAgICAgIG4gPSBuLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgaWYocCA9PT0gdGhpcykge1xuICAgICAgICAgIG4ucmlnaHQgPSB0aGlzLnJpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGwgPSB0aGlzLmxlZnRcbiAgICAgICAgICB2YXIgciA9IHRoaXMucmlnaHRcbiAgICAgICAgICBwLmNvdW50IC09IG4uY291bnRcbiAgICAgICAgICBwLnJpZ2h0ID0gbi5sZWZ0XG4gICAgICAgICAgbi5sZWZ0ID0gbFxuICAgICAgICAgIG4ucmlnaHQgPSByXG4gICAgICAgIH1cbiAgICAgICAgY29weSh0aGlzLCBuKVxuICAgICAgICB0aGlzLmNvdW50ID0gKHRoaXMubGVmdD90aGlzLmxlZnQuY291bnQ6MCkgKyAodGhpcy5yaWdodD90aGlzLnJpZ2h0LmNvdW50OjApICsgdGhpcy5sZWZ0UG9pbnRzLmxlbmd0aFxuICAgICAgfSBlbHNlIGlmKHRoaXMubGVmdCkge1xuICAgICAgICBjb3B5KHRoaXMsIHRoaXMubGVmdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHkodGhpcywgdGhpcy5yaWdodClcbiAgICAgIH1cbiAgICAgIHJldHVybiBTVUNDRVNTXG4gICAgfVxuICAgIGZvcih2YXIgbCA9IGJvdW5kcy5nZSh0aGlzLmxlZnRQb2ludHMsIGludGVydmFsLCBjb21wYXJlQmVnaW4pOyBsPHRoaXMubGVmdFBvaW50cy5sZW5ndGg7ICsrbCkge1xuICAgICAgaWYodGhpcy5sZWZ0UG9pbnRzW2xdWzBdICE9PSBpbnRlcnZhbFswXSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYodGhpcy5sZWZ0UG9pbnRzW2xdID09PSBpbnRlcnZhbCkge1xuICAgICAgICB0aGlzLmNvdW50IC09IDFcbiAgICAgICAgdGhpcy5sZWZ0UG9pbnRzLnNwbGljZShsLCAxKVxuICAgICAgICBmb3IodmFyIHIgPSBib3VuZHMuZ2UodGhpcy5yaWdodFBvaW50cywgaW50ZXJ2YWwsIGNvbXBhcmVFbmQpOyByPHRoaXMucmlnaHRQb2ludHMubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICBpZih0aGlzLnJpZ2h0UG9pbnRzW3JdWzFdICE9PSBpbnRlcnZhbFsxXSkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2UgaWYodGhpcy5yaWdodFBvaW50c1tyXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRQb2ludHMuc3BsaWNlKHIsIDEpXG4gICAgICAgICAgICByZXR1cm4gU1VDQ0VTU1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTk9UX0ZPVU5EXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0TGVmdFJhbmdlKGFyciwgaGksIGNiKSB7XG4gIGZvcih2YXIgaT0wOyBpPGFyci5sZW5ndGggJiYgYXJyW2ldWzBdIDw9IGhpOyArK2kpIHtcbiAgICB2YXIgciA9IGNiKGFycltpXSlcbiAgICBpZihyKSB7IHJldHVybiByIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBvcnRSaWdodFJhbmdlKGFyciwgbG8sIGNiKSB7XG4gIGZvcih2YXIgaT1hcnIubGVuZ3RoLTE7IGk+PTAgJiYgYXJyW2ldWzFdID49IGxvOyAtLWkpIHtcbiAgICB2YXIgciA9IGNiKGFycltpXSlcbiAgICBpZihyKSB7IHJldHVybiByIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBvcnRSYW5nZShhcnIsIGNiKSB7XG4gIGZvcih2YXIgaT0wOyBpPGFyci5sZW5ndGg7ICsraSkge1xuICAgIHZhciByID0gY2IoYXJyW2ldKVxuICAgIGlmKHIpIHsgcmV0dXJuIHIgfVxuICB9XG59XG5cbnByb3RvLnF1ZXJ5UG9pbnQgPSBmdW5jdGlvbih4LCBjYikge1xuICBpZih4IDwgdGhpcy5taWQpIHtcbiAgICBpZih0aGlzLmxlZnQpIHtcbiAgICAgIHZhciByID0gdGhpcy5sZWZ0LnF1ZXJ5UG9pbnQoeCwgY2IpXG4gICAgICBpZihyKSB7IHJldHVybiByIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydExlZnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIHgsIGNiKVxuICB9IGVsc2UgaWYoeCA+IHRoaXMubWlkKSB7XG4gICAgaWYodGhpcy5yaWdodCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnJpZ2h0LnF1ZXJ5UG9pbnQoeCwgY2IpXG4gICAgICBpZihyKSB7IHJldHVybiByIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydFJpZ2h0UmFuZ2UodGhpcy5yaWdodFBvaW50cywgeCwgY2IpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcG9ydFJhbmdlKHRoaXMubGVmdFBvaW50cywgY2IpXG4gIH1cbn1cblxucHJvdG8ucXVlcnlJbnRlcnZhbCA9IGZ1bmN0aW9uKGxvLCBoaSwgY2IpIHtcbiAgaWYobG8gPCB0aGlzLm1pZCAmJiB0aGlzLmxlZnQpIHtcbiAgICB2YXIgciA9IHRoaXMubGVmdC5xdWVyeUludGVydmFsKGxvLCBoaSwgY2IpXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbiAgaWYoaGkgPiB0aGlzLm1pZCAmJiB0aGlzLnJpZ2h0KSB7XG4gICAgdmFyIHIgPSB0aGlzLnJpZ2h0LnF1ZXJ5SW50ZXJ2YWwobG8sIGhpLCBjYilcbiAgICBpZihyKSB7IHJldHVybiByIH1cbiAgfVxuICBpZihoaSA8IHRoaXMubWlkKSB7XG4gICAgcmV0dXJuIHJlcG9ydExlZnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIGhpLCBjYilcbiAgfSBlbHNlIGlmKGxvID4gdGhpcy5taWQpIHtcbiAgICByZXR1cm4gcmVwb3J0UmlnaHRSYW5nZSh0aGlzLnJpZ2h0UG9pbnRzLCBsbywgY2IpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcG9ydFJhbmdlKHRoaXMubGVmdFBvaW50cywgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICByZXR1cm4gYSAtIGJcbn1cblxuZnVuY3Rpb24gY29tcGFyZUJlZ2luKGEsIGIpIHtcbiAgdmFyIGQgPSBhWzBdIC0gYlswXVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgcmV0dXJuIGFbMV0gLSBiWzFdXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVFbmQoYSwgYikge1xuICB2YXIgZCA9IGFbMV0gLSBiWzFdXG4gIGlmKGQpIHsgcmV0dXJuIGQgfVxuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50ZXJ2YWxUcmVlKGludGVydmFscykge1xuICBpZihpbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgcHRzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8aW50ZXJ2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgcHRzLnB1c2goaW50ZXJ2YWxzW2ldWzBdLCBpbnRlcnZhbHNbaV1bMV0pXG4gIH1cbiAgcHRzLnNvcnQoY29tcGFyZU51bWJlcnMpXG5cbiAgdmFyIG1pZCA9IHB0c1twdHMubGVuZ3RoPj4xXVxuXG4gIHZhciBsZWZ0SW50ZXJ2YWxzID0gW11cbiAgdmFyIHJpZ2h0SW50ZXJ2YWxzID0gW11cbiAgdmFyIGNlbnRlckludGVydmFscyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGludGVydmFscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzID0gaW50ZXJ2YWxzW2ldXG4gICAgaWYoc1sxXSA8IG1pZCkge1xuICAgICAgbGVmdEludGVydmFscy5wdXNoKHMpXG4gICAgfSBlbHNlIGlmKG1pZCA8IHNbMF0pIHtcbiAgICAgIHJpZ2h0SW50ZXJ2YWxzLnB1c2gocylcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVySW50ZXJ2YWxzLnB1c2gocylcbiAgICB9XG4gIH1cblxuICAvL1NwbGl0IGNlbnRlciBpbnRlcnZhbHNcbiAgdmFyIGxlZnRQb2ludHMgPSBjZW50ZXJJbnRlcnZhbHNcbiAgdmFyIHJpZ2h0UG9pbnRzID0gY2VudGVySW50ZXJ2YWxzLnNsaWNlKClcbiAgbGVmdFBvaW50cy5zb3J0KGNvbXBhcmVCZWdpbilcbiAgcmlnaHRQb2ludHMuc29ydChjb21wYXJlRW5kKVxuXG4gIHJldHVybiBuZXcgSW50ZXJ2YWxUcmVlTm9kZShtaWQsIFxuICAgIGNyZWF0ZUludGVydmFsVHJlZShsZWZ0SW50ZXJ2YWxzKSxcbiAgICBjcmVhdGVJbnRlcnZhbFRyZWUocmlnaHRJbnRlcnZhbHMpLFxuICAgIGxlZnRQb2ludHMsXG4gICAgcmlnaHRQb2ludHMpXG59XG5cbi8vVXNlciBmcmllbmRseSB3cmFwcGVyIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gc3VwcG9ydCBlbXB0eSB0cmVlc1xuZnVuY3Rpb24gSW50ZXJ2YWxUcmVlKHJvb3QpIHtcbiAgdGhpcy5yb290ID0gcm9vdFxufVxuXG52YXIgdHByb3RvID0gSW50ZXJ2YWxUcmVlLnByb3RvdHlwZVxuXG50cHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgaWYodGhpcy5yb290KSB7XG4gICAgdGhpcy5yb290Lmluc2VydChpbnRlcnZhbClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJvb3QgPSBuZXcgSW50ZXJ2YWxUcmVlTm9kZShpbnRlcnZhbFswXSwgbnVsbCwgbnVsbCwgW2ludGVydmFsXSwgW2ludGVydmFsXSlcbiAgfVxufVxuXG50cHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgaWYodGhpcy5yb290KSB7XG4gICAgdmFyIHIgPSB0aGlzLnJvb3QucmVtb3ZlKGludGVydmFsKVxuICAgIGlmKHIgPT09IEVNUFRZKSB7XG4gICAgICB0aGlzLnJvb3QgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiByICE9PSBOT1RfRk9VTkRcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxudHByb3RvLnF1ZXJ5UG9pbnQgPSBmdW5jdGlvbihwLCBjYikge1xuICBpZih0aGlzLnJvb3QpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5UG9pbnQocCwgY2IpXG4gIH1cbn1cblxudHByb3RvLnF1ZXJ5SW50ZXJ2YWwgPSBmdW5jdGlvbihsbywgaGksIGNiKSB7XG4gIGlmKGxvIDw9IGhpICYmIHRoaXMucm9vdCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QucXVlcnlJbnRlcnZhbChsbywgaGksIGNiKVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cHJvdG8sIFwiY291bnRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMucm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5jb3VudFxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodHByb3RvLCBcImludGVydmFsc1wiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmludGVydmFscyhbXSlcbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoaW50ZXJ2YWxzKSB7XG4gIGlmKCFpbnRlcnZhbHMgfHwgaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWxUcmVlKG51bGwpXG4gIH1cbiAgcmV0dXJuIG5ldyBJbnRlcnZhbFRyZWUoY3JlYXRlSW50ZXJ2YWxUcmVlKGludGVydmFscykpXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpbnZlcnRQZXJtdXRhdGlvbihwaSwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgQXJyYXkocGkubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwaS5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtwaVtpXV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmVydFBlcm11dGF0aW9uIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW90YShuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpb3RhIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIhZnVuY3Rpb24ocix0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KToocj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnJ8fHNlbGYpLk1leWRhPXQoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHIsdCxlKXtpZihlfHwyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGEsbj0wLG89dC5sZW5ndGg7bjxvO24rKykhYSYmbiBpbiB0fHwoYXx8KGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCwwLG4pKSxhW25dPXRbbl0pO3JldHVybiByLmNvbmNhdChhfHxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KSl9dmFyIHQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsYmxhY2ttYW46ZnVuY3Rpb24ocil7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkociksZT0yKk1hdGguUEkvKHItMSksYT0yKmUsbj0wO248ci8yO24rKyl0W25dPS40Mi0uNSpNYXRoLmNvcyhuKmUpKy4wOCpNYXRoLmNvcyhuKmEpO2ZvcihuPU1hdGguY2VpbChyLzIpO24+MDtuLS0pdFtyLW5dPXRbbi0xXTtyZXR1cm4gdH0sc2luZTpmdW5jdGlvbihyKXtmb3IodmFyIHQ9TWF0aC5QSS8oci0xKSxlPW5ldyBGbG9hdDMyQXJyYXkociksYT0wO2E8cjthKyspZVthXT1NYXRoLnNpbih0KmEpO3JldHVybiBlfSxoYW5uaW5nOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KHIpLGU9MDtlPHI7ZSsrKXRbZV09LjUtLjUqTWF0aC5jb3MoMipNYXRoLlBJKmUvKHItMSkpO3JldHVybiB0fSxoYW1taW5nOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KHIpLGU9MDtlPHI7ZSsrKXRbZV09LjU0LS40NipNYXRoLmNvcygyKk1hdGguUEkqKGUvci0xKSk7cmV0dXJuIHR9fSksZT17fTtmdW5jdGlvbiBhKHIpe2Zvcig7ciUyPT0wJiZyPjE7KXIvPTI7cmV0dXJuIDE9PT1yfWZ1bmN0aW9uIG4ocixhKXtpZihcInJlY3RcIiE9PWEpe2lmKFwiXCIhPT1hJiZhfHwoYT1cImhhbm5pbmdcIiksZVthXXx8KGVbYV09e30pLCFlW2FdW3IubGVuZ3RoXSl0cnl7ZVthXVtyLmxlbmd0aF09dFthXShyLmxlbmd0aCl9Y2F0Y2gocil7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aW5kb3dpbmcgZnVuY3Rpb25cIil9cj1mdW5jdGlvbihyLHQpe2Zvcih2YXIgZT1bXSxhPTA7YTxNYXRoLm1pbihyLmxlbmd0aCx0Lmxlbmd0aCk7YSsrKWVbYV09clthXSp0W2FdO3JldHVybiBlfShyLGVbYV1bci5sZW5ndGhdKX1yZXR1cm4gcn1mdW5jdGlvbiBvKHIsdCxlKXtmb3IodmFyIGE9bmV3IEZsb2F0MzJBcnJheShyKSxuPTA7bjxhLmxlbmd0aDtuKyspYVtuXT1uKnQvZSxhW25dPTEzKk1hdGguYXRhbihhW25dLzEzMTUuOCkrMy41Kk1hdGguYXRhbihNYXRoLnBvdyhhW25dLzc1MTgsMikpO3JldHVybiBhfWZ1bmN0aW9uIGkocil7cmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHIpfWZ1bmN0aW9uIHUocil7cmV0dXJuIDExMjUqTWF0aC5sb2coMStyLzcwMCl9ZnVuY3Rpb24gZihyLHQsZSl7Zm9yKHZhciBhLG49bmV3IEZsb2F0MzJBcnJheShyKzIpLG89bmV3IEZsb2F0MzJBcnJheShyKzIpLGk9dC8yLGY9dSgwKSxjPSh1KGkpLWYpLyhyKzEpLGw9bmV3IEFycmF5KHIrMikscz0wO3M8bi5sZW5ndGg7cysrKW5bc109cypjLG9bc109KGE9bltzXSw3MDAqKE1hdGguZXhwKGEvMTEyNSktMSkpLGxbc109TWF0aC5mbG9vcigoZSsxKSpvW3NdL3QpO2Zvcih2YXIgbT1uZXcgQXJyYXkocikscD0wO3A8bS5sZW5ndGg7cCsrKXttW3BdPW5ldyBBcnJheShlLzIrMSkuZmlsbCgwKTtmb3Iocz1sW3BdO3M8bFtwKzFdO3MrKyltW3BdW3NdPShzLWxbcF0pLyhsW3ArMV0tbFtwXSk7Zm9yKHM9bFtwKzFdO3M8bFtwKzJdO3MrKyltW3BdW3NdPShsW3ArMl0tcykvKGxbcCsyXS1sW3ArMV0pfXJldHVybiBtfWZ1bmN0aW9uIGModCxlLGEsbixvLGksdSl7dm9pZCAwPT09biYmKG49NSksdm9pZCAwPT09byYmKG89Miksdm9pZCAwPT09aSYmKGk9ITApLHZvaWQgMD09PXUmJih1PTQ0MCk7dmFyIGY9TWF0aC5mbG9vcihhLzIpKzEsYz1uZXcgQXJyYXkoYSkuZmlsbCgwKS5tYXAoKGZ1bmN0aW9uKHIsbil7cmV0dXJuIHQqZnVuY3Rpb24ocix0KXtyZXR1cm4gTWF0aC5sb2cyKDE2KnIvdCl9KGUqbi9hLHUpfSkpO2NbMF09Y1sxXS0xLjUqdDt2YXIgbCxzLG0scD1jLnNsaWNlKDEpLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gTWF0aC5tYXgoci1jW3RdKX0pLDEpLmNvbmNhdChbMV0pLGg9TWF0aC5yb3VuZCh0LzIpLGc9bmV3IEFycmF5KHQpLmZpbGwoMCkubWFwKChmdW5jdGlvbihyLGUpe3JldHVybiBjLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuKDEwKnQraCtyLWUpJXQtaH0pKX0pKSx3PWcubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiByLm1hcCgoZnVuY3Rpb24ocixlKXtyZXR1cm4gTWF0aC5leHAoLS41Kk1hdGgucG93KDIqZ1t0XVtlXS9wW2VdLDIpKX0pKX0pKTtpZihzPShsPXcpWzBdLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4gMH0pKSxtPWwucmVkdWNlKChmdW5jdGlvbihyLHQpe3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cltlXSs9TWF0aC5wb3codCwyKX0pKSxyfSkscykubWFwKE1hdGguc3FydCksdz1sLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIHIvKG1bdF18fDEpfSkpfSkpLG8pe3ZhciB2PWMubWFwKChmdW5jdGlvbihyKXtyZXR1cm4gTWF0aC5leHAoLS41Kk1hdGgucG93KChyL3QtbikvbywyKSl9KSk7dz13Lm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuIHIubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiByKnZbdF19KSl9KSl9cmV0dXJuIGkmJih3PXIocihbXSx3LnNsaWNlKDMpLCEwKSx3LnNsaWNlKDAsMyksITApKSx3Lm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuIHIuc2xpY2UoMCxmKX0pKX1mdW5jdGlvbiBsKHIsdCl7Zm9yKHZhciBlPTAsYT0wLG49MDtuPHQubGVuZ3RoO24rKyllKz1NYXRoLnBvdyhuLHIpKk1hdGguYWJzKHRbbl0pLGErPXRbbl07cmV0dXJuIGUvYX1mdW5jdGlvbiBzKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLmJhcmtTY2FsZSxhPXIubnVtYmVyT2ZCYXJrQmFuZHMsbj12b2lkIDA9PT1hPzI0OmE7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3I7dmFyIG89bixpPW5ldyBGbG9hdDMyQXJyYXkobyksdT0wLGY9dCxjPW5ldyBJbnQzMkFycmF5KG8rMSk7Y1swXT0wO2Zvcih2YXIgbD1lW2YubGVuZ3RoLTFdL28scz0xLG09MDttPGYubGVuZ3RoO20rKylmb3IoO2VbbV0+bDspY1tzKytdPW0sbD1zKmVbZi5sZW5ndGgtMV0vbztjW29dPWYubGVuZ3RoLTE7Zm9yKG09MDttPG87bSsrKXtmb3IodmFyIHA9MCxoPWNbbV07aDxjW20rMV07aCsrKXArPWZbaF07aVttXT1NYXRoLnBvdyhwLC4yMyl9Zm9yKG09MDttPGkubGVuZ3RoO20rKyl1Kz1pW21dO3JldHVybntzcGVjaWZpYzppLHRvdGFsOnV9fWZ1bmN0aW9uIG0ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSxhPTA7YTxlLmxlbmd0aDthKyspZVthXT1NYXRoLnBvdyh0W2FdLDIpO3JldHVybiBlfWZ1bmN0aW9uIHAocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bSxlPXIubWVsRmlsdGVyQmFuayxhPXIuYnVmZmVyU2l6ZTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgYW1wU3BlY3RydW0gaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgbWVsQmFuZHNcIik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIG1lbEZpbHRlckJhbmsgaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgbWVsQmFuZHNcIik7Zm9yKHZhciBuPW0oe2FtcFNwZWN0cnVtOnR9KSxvPWUubGVuZ3RoLGk9QXJyYXkobyksdT1uZXcgRmxvYXQzMkFycmF5KG8pLGY9MDtmPHUubGVuZ3RoO2YrKyl7aVtmXT1uZXcgRmxvYXQzMkFycmF5KGEvMiksdVtmXT0wO2Zvcih2YXIgYz0wO2M8YS8yO2MrKylpW2ZdW2NdPWVbZl1bY10qbltjXSx1W2ZdKz1pW2ZdW2NdO3VbZl09TWF0aC5sb2codVtmXSsxKX1yZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodSl9ZnVuY3Rpb24gaChyKXtyZXR1cm4gciYmci5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixcImRlZmF1bHRcIik/ci5kZWZhdWx0OnJ9dmFyIGc9e2V4cG9ydHM6e319LHc9bnVsbDt2YXIgdj1mdW5jdGlvbihyLHQpe3ZhciBlPXIubGVuZ3RoO3JldHVybiB0PXR8fDIsdyYmd1tlXXx8ZnVuY3Rpb24ocil7KHc9d3x8e30pW3JdPW5ldyBBcnJheShyKnIpO2Zvcih2YXIgdD1NYXRoLlBJL3IsZT0wO2U8cjtlKyspZm9yKHZhciBhPTA7YTxyO2ErKyl3W3JdW2ErZSpyXT1NYXRoLmNvcyh0KihhKy41KSplKX0oZSksci5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuIDB9KSkubWFwKChmdW5jdGlvbihhLG4pe3JldHVybiB0KnIucmVkdWNlKChmdW5jdGlvbihyLHQsYSxvKXtyZXR1cm4gcit0KndbZV1bYStuKmVdfSksMCl9KSl9OyFmdW5jdGlvbihyKXtyLmV4cG9ydHM9dn0oZyk7dmFyIGQ9aChnLmV4cG9ydHMpO3ZhciB5PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGJ1ZmZlcjpmdW5jdGlvbihyKXtyZXR1cm4gci5zaWduYWx9LHJtczpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MDthPHQubGVuZ3RoO2ErKyllKz1NYXRoLnBvdyh0W2FdLDIpO3JldHVybiBlLz10Lmxlbmd0aCxlPU1hdGguc3FydChlKX0sZW5lcmd5OmZ1bmN0aW9uKHIpe3ZhciB0PXIuc2lnbmFsO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBlPTAsYT0wO2E8dC5sZW5ndGg7YSsrKWUrPU1hdGgucG93KE1hdGguYWJzKHRbYV0pLDIpO3JldHVybiBlfSxjb21wbGV4U3BlY3RydW06ZnVuY3Rpb24ocil7cmV0dXJuIHIuY29tcGxleFNwZWN0cnVtfSxzcGVjdHJhbFNsb3BlOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLnNhbXBsZVJhdGUsYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIG49MCxvPTAsaT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSx1PTAsZj0wLGM9MDtjPHQubGVuZ3RoO2MrKyl7bis9dFtjXTt2YXIgbD1jKmUvYTtpW2NdPWwsdSs9bCpsLG8rPWwsZis9bCp0W2NdfXJldHVybih0Lmxlbmd0aCpmLW8qbikvKG4qKHUtTWF0aC5wb3cobywyKSkpfSxzcGVjdHJhbENlbnRyb2lkOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtyZXR1cm4gbCgxLHQpfSxzcGVjdHJhbFJvbGxvZmY6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bSxlPXIuc2FtcGxlUmF0ZTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgYT10LG49ZS8oMiooYS5sZW5ndGgtMSkpLG89MCxpPTA7aTxhLmxlbmd0aDtpKyspbys9YVtpXTtmb3IodmFyIHU9Ljk5Km8sZj1hLmxlbmd0aC0xO28+dSYmZj49MDspby09YVtmXSwtLWY7cmV0dXJuKGYrMSkqbn0sc3BlY3RyYWxGbGF0bmVzczpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBlPTAsYT0wLG49MDtuPHQubGVuZ3RoO24rKyllKz1NYXRoLmxvZyh0W25dKSxhKz10W25dO3JldHVybiBNYXRoLmV4cChlL3QubGVuZ3RoKSp0Lmxlbmd0aC9hfSxzcGVjdHJhbFNwcmVhZDpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7cmV0dXJuIE1hdGguc3FydChsKDIsdCktTWF0aC5wb3cobCgxLHQpLDIpKX0sc3BlY3RyYWxTa2V3bmVzczpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7dmFyIGU9bCgxLHQpLGE9bCgyLHQpLG49bCgzLHQpO3JldHVybigyKk1hdGgucG93KGUsMyktMyplKmErbikvTWF0aC5wb3coTWF0aC5zcXJ0KGEtTWF0aC5wb3coZSwyKSksMyl9LHNwZWN0cmFsS3VydG9zaXM6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBlPXQsYT1sKDEsZSksbj1sKDIsZSksbz1sKDMsZSksaT1sKDQsZSk7cmV0dXJuKC0zKk1hdGgucG93KGEsNCkrNiphKm4tNCphKm8raSkvTWF0aC5wb3coTWF0aC5zcXJ0KG4tTWF0aC5wb3coYSwyKSksNCl9LGFtcGxpdHVkZVNwZWN0cnVtOmZ1bmN0aW9uKHIpe3JldHVybiByLmFtcFNwZWN0cnVtfSx6Y3I6ZnVuY3Rpb24ocil7dmFyIHQ9ci5zaWduYWw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9MCxhPTE7YTx0Lmxlbmd0aDthKyspKHRbYS0xXT49MCYmdFthXTwwfHx0W2EtMV08MCYmdFthXT49MCkmJmUrKztyZXR1cm4gZX0sbG91ZG5lc3M6cyxwZXJjZXB0dWFsU3ByZWFkOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1zKHthbXBTcGVjdHJ1bTpyLmFtcFNwZWN0cnVtLGJhcmtTY2FsZTpyLmJhcmtTY2FsZX0pLGU9MCxhPTA7YTx0LnNwZWNpZmljLmxlbmd0aDthKyspdC5zcGVjaWZpY1thXT5lJiYoZT10LnNwZWNpZmljW2FdKTtyZXR1cm4gTWF0aC5wb3coKHQudG90YWwtZSkvdC50b3RhbCwyKX0scGVyY2VwdHVhbFNoYXJwbmVzczpmdW5jdGlvbihyKXtmb3IodmFyIHQ9cyh7YW1wU3BlY3RydW06ci5hbXBTcGVjdHJ1bSxiYXJrU2NhbGU6ci5iYXJrU2NhbGV9KSxlPXQuc3BlY2lmaWMsYT0wLG49MDtuPGUubGVuZ3RoO24rKylhKz1uPDE1PyhuKzEpKmVbbisxXTouMDY2Kk1hdGguZXhwKC4xNzEqKG4rMSkpO3JldHVybiBhKj0uMTEvdC50b3RhbH0scG93ZXJTcGVjdHJ1bTptLG1mY2M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bSxlPXIubWVsRmlsdGVyQmFuayxhPXIubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzLG49ci5idWZmZXJTaXplLG89TWF0aC5taW4oNDAsTWF0aC5tYXgoMSxhfHwxMykpO2lmKGUubGVuZ3RoPG8pdGhyb3cgbmV3IEVycm9yKFwiSW5zdWZmaWNpZW50IGZpbHRlciBiYW5rIGZvciByZXF1ZXN0ZWQgbnVtYmVyIG9mIGNvZWZmaWNpZW50c1wiKTt2YXIgaT1wKHthbXBTcGVjdHJ1bTp0LG1lbEZpbHRlckJhbms6ZSxidWZmZXJTaXplOm59KTtyZXR1cm4gZChpKS5zbGljZSgwLG8pfSxjaHJvbWE6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bSxlPXIuY2hyb21hRmlsdGVyQmFuaztpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgYW1wU3BlY3RydW0gaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgY2hyb21hXCIpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWxpZCBjaHJvbWFGaWx0ZXJCYW5rIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTt2YXIgYT1lLm1hcCgoZnVuY3Rpb24ocixlKXtyZXR1cm4gdC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSxhKXtyZXR1cm4gdCtlKnJbYV19KSwwKX0pKSxuPU1hdGgubWF4LmFwcGx5KE1hdGgsYSk7cmV0dXJuIG4/YS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByL259KSk6YX0sc3BlY3RyYWxGbHV4OmZ1bmN0aW9uKHIpe3ZhciB0PXIuc2lnbmFsLGU9ci5wcmV2aW91c1NpZ25hbCxhPXIuYnVmZmVyU2l6ZTtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8XCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIG49MCxvPS1hLzI7bzx0Lmxlbmd0aC8yLTE7bysrKXg9TWF0aC5hYnModFtvXSktTWF0aC5hYnMoZVtvXSksbis9KHgrTWF0aC5hYnMoeCkpLzI7cmV0dXJuIG59LHNwZWN0cmFsQ3Jlc3Q6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBlPTAsYT0tMS8wO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHIpe2UrPU1hdGgucG93KHIsMiksYT1yPmE/cjphfSkpLGUvPXQubGVuZ3RoLGU9TWF0aC5zcXJ0KGUpLGEvZX0sbWVsQmFuZHM6cH0pO2Z1bmN0aW9uIFMocil7aWYoQXJyYXkuaXNBcnJheShyKSl7Zm9yKHZhciB0PTAsZT1BcnJheShyLmxlbmd0aCk7dDxyLmxlbmd0aDt0KyspZVt0XT1yW3RdO3JldHVybiBlfXJldHVybiBBcnJheS5mcm9tKHIpfXZhciBfPXt9LGI9e30sTT17Yml0UmV2ZXJzZUFycmF5OmZ1bmN0aW9uKHIpe2lmKHZvaWQgMD09PV9bcl0pe2Zvcih2YXIgdD0oci0xKS50b1N0cmluZygyKS5sZW5ndGgsZT1cIjBcIi5yZXBlYXQodCksYT17fSxuPTA7bjxyO24rKyl7dmFyIG89bi50b1N0cmluZygyKTtvPWUuc3Vic3RyKG8ubGVuZ3RoKStvLG89W10uY29uY2F0KFMobykpLnJldmVyc2UoKS5qb2luKFwiXCIpLGFbbl09cGFyc2VJbnQobywyKX1fW3JdPWF9cmV0dXJuIF9bcl19LG11bHRpcGx5OmZ1bmN0aW9uKHIsdCl7cmV0dXJue3JlYWw6ci5yZWFsKnQucmVhbC1yLmltYWcqdC5pbWFnLGltYWc6ci5yZWFsKnQuaW1hZytyLmltYWcqdC5yZWFsfX0sYWRkOmZ1bmN0aW9uKHIsdCl7cmV0dXJue3JlYWw6ci5yZWFsK3QucmVhbCxpbWFnOnIuaW1hZyt0LmltYWd9fSxzdWJ0cmFjdDpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbC10LnJlYWwsaW1hZzpyLmltYWctdC5pbWFnfX0sZXVsZXI6ZnVuY3Rpb24ocix0KXt2YXIgZT0tMipNYXRoLlBJKnIvdDtyZXR1cm57cmVhbDpNYXRoLmNvcyhlKSxpbWFnOk1hdGguc2luKGUpfX0sY29uajpmdW5jdGlvbihyKXtyZXR1cm4gci5pbWFnKj0tMSxyfSxjb25zdHJ1Y3RDb21wbGV4QXJyYXk6ZnVuY3Rpb24ocil7dmFyIHQ9e307dC5yZWFsPXZvaWQgMD09PXIucmVhbD9yLnNsaWNlKCk6ci5yZWFsLnNsaWNlKCk7dmFyIGU9dC5yZWFsLmxlbmd0aDtyZXR1cm4gdm9pZCAwPT09YltlXSYmKGJbZV09QXJyYXkuYXBwbHkobnVsbCxBcnJheShlKSkubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwwKSksdC5pbWFnPWJbZV0uc2xpY2UoKSx0fX0sRj1mdW5jdGlvbihyKXt2YXIgdD17fTt2b2lkIDA9PT1yLnJlYWx8fHZvaWQgMD09PXIuaW1hZz90PU0uY29uc3RydWN0Q29tcGxleEFycmF5KHIpOih0LnJlYWw9ci5yZWFsLnNsaWNlKCksdC5pbWFnPXIuaW1hZy5zbGljZSgpKTt2YXIgZT10LnJlYWwubGVuZ3RoLGE9TWF0aC5sb2cyKGUpO2lmKE1hdGgucm91bmQoYSkhPWEpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMi5cIik7aWYodC5yZWFsLmxlbmd0aCE9dC5pbWFnLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJSZWFsIGFuZCBpbWFnaW5hcnkgY29tcG9uZW50cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlwiKTtmb3IodmFyIG49TS5iaXRSZXZlcnNlQXJyYXkoZSksbz17cmVhbDpbXSxpbWFnOltdfSxpPTA7aTxlO2krKylvLnJlYWxbbltpXV09dC5yZWFsW2ldLG8uaW1hZ1tuW2ldXT10LmltYWdbaV07Zm9yKHZhciB1PTA7dTxlO3UrKyl0LnJlYWxbdV09by5yZWFsW3VdLHQuaW1hZ1t1XT1vLmltYWdbdV07Zm9yKHZhciBmPTE7Zjw9YTtmKyspZm9yKHZhciBjPU1hdGgucG93KDIsZiksbD0wO2w8Yy8yO2wrKylmb3IodmFyIHM9TS5ldWxlcihsLGMpLG09MDttPGUvYzttKyspe3ZhciBwPWMqbStsLGg9YyptK2wrYy8yLGc9e3JlYWw6dC5yZWFsW3BdLGltYWc6dC5pbWFnW3BdfSx3PXtyZWFsOnQucmVhbFtoXSxpbWFnOnQuaW1hZ1toXX0sdj1NLm11bHRpcGx5KHMsdyksZD1NLnN1YnRyYWN0KGcsdik7dC5yZWFsW2hdPWQucmVhbCx0LmltYWdbaF09ZC5pbWFnO3ZhciB5PU0uYWRkKHYsZyk7dC5yZWFsW3BdPXkucmVhbCx0LmltYWdbcF09eS5pbWFnfXJldHVybiB0fSxBPUYsRT1mdW5jdGlvbigpe2Z1bmN0aW9uIHIocix0KXt2YXIgZT10aGlzO2lmKHRoaXMuX209dCwhci5hdWRpb0NvbnRleHQpdGhyb3cgdGhpcy5fbS5lcnJvcnMubm9BQztpZihyLmJ1ZmZlclNpemUmJiFhKHIuYnVmZmVyU2l6ZSkpdGhyb3cgdGhpcy5fbS5fZXJyb3JzLm5vdFBvdzI7aWYoIXIuc291cmNlKXRocm93IHRoaXMuX20uX2Vycm9ycy5ub1NvdXJjZTt0aGlzLl9tLmF1ZGlvQ29udGV4dD1yLmF1ZGlvQ29udGV4dCx0aGlzLl9tLmJ1ZmZlclNpemU9ci5idWZmZXJTaXplfHx0aGlzLl9tLmJ1ZmZlclNpemV8fDI1Nix0aGlzLl9tLmhvcFNpemU9ci5ob3BTaXplfHx0aGlzLl9tLmhvcFNpemV8fHRoaXMuX20uYnVmZmVyU2l6ZSx0aGlzLl9tLnNhbXBsZVJhdGU9ci5zYW1wbGVSYXRlfHx0aGlzLl9tLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlfHw0NDEwMCx0aGlzLl9tLmNhbGxiYWNrPXIuY2FsbGJhY2ssdGhpcy5fbS53aW5kb3dpbmdGdW5jdGlvbj1yLndpbmRvd2luZ0Z1bmN0aW9ufHxcImhhbm5pbmdcIix0aGlzLl9tLmZlYXR1cmVFeHRyYWN0b3JzPXksdGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQ9ci5zdGFydEltbWVkaWF0ZWx5fHwhMSx0aGlzLl9tLmNoYW5uZWw9XCJudW1iZXJcIj09dHlwZW9mIHIuY2hhbm5lbD9yLmNoYW5uZWw6MCx0aGlzLl9tLmlucHV0cz1yLmlucHV0c3x8MSx0aGlzLl9tLm91dHB1dHM9ci5vdXRwdXRzfHwxLHRoaXMuX20ubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzPXIubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzfHx0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50c3x8MTMsdGhpcy5fbS5udW1iZXJPZkJhcmtCYW5kcz1yLm51bWJlck9mQmFya0JhbmRzfHx0aGlzLl9tLm51bWJlck9mQmFya0JhbmRzfHwyNCx0aGlzLl9tLnNwbj10aGlzLl9tLmF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IodGhpcy5fbS5idWZmZXJTaXplLHRoaXMuX20uaW5wdXRzLHRoaXMuX20ub3V0cHV0cyksdGhpcy5fbS5zcG4uY29ubmVjdCh0aGlzLl9tLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbiksdGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3Q9ci5mZWF0dXJlRXh0cmFjdG9yc3x8W10sdGhpcy5fbS5iYXJrU2NhbGU9byh0aGlzLl9tLmJ1ZmZlclNpemUsdGhpcy5fbS5zYW1wbGVSYXRlLHRoaXMuX20uYnVmZmVyU2l6ZSksdGhpcy5fbS5tZWxGaWx0ZXJCYW5rPWYoTWF0aC5tYXgodGhpcy5fbS5tZWxCYW5kcyx0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyksdGhpcy5fbS5zYW1wbGVSYXRlLHRoaXMuX20uYnVmZmVyU2l6ZSksdGhpcy5fbS5pbnB1dERhdGE9bnVsbCx0aGlzLl9tLnByZXZpb3VzSW5wdXREYXRhPW51bGwsdGhpcy5fbS5mcmFtZT1udWxsLHRoaXMuX20ucHJldmlvdXNGcmFtZT1udWxsLHRoaXMuc2V0U291cmNlKHIuc291cmNlKSx0aGlzLl9tLnNwbi5vbmF1ZGlvcHJvY2Vzcz1mdW5jdGlvbihyKXt2YXIgdDtudWxsIT09ZS5fbS5pbnB1dERhdGEmJihlLl9tLnByZXZpb3VzSW5wdXREYXRhPWUuX20uaW5wdXREYXRhKSxlLl9tLmlucHV0RGF0YT1yLmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKGUuX20uY2hhbm5lbCksZS5fbS5wcmV2aW91c0lucHV0RGF0YT8oKHQ9bmV3IEZsb2F0MzJBcnJheShlLl9tLnByZXZpb3VzSW5wdXREYXRhLmxlbmd0aCtlLl9tLmlucHV0RGF0YS5sZW5ndGgtZS5fbS5ob3BTaXplKSkuc2V0KGUuX20ucHJldmlvdXNJbnB1dERhdGEuc2xpY2UoZS5fbS5ob3BTaXplKSksdC5zZXQoZS5fbS5pbnB1dERhdGEsZS5fbS5wcmV2aW91c0lucHV0RGF0YS5sZW5ndGgtZS5fbS5ob3BTaXplKSk6dD1lLl9tLmlucHV0RGF0YSxmdW5jdGlvbihyLHQsZSl7aWYoci5sZW5ndGg8dCl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgaXMgdG9vIHNob3J0IGZvciBmcmFtZSBsZW5ndGhcIik7aWYoZTwxKXRocm93IG5ldyBFcnJvcihcIkhvcCBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhdCAxXCIpO2lmKHQ8MSl0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhdCAxXCIpO3ZhciBhPTErTWF0aC5mbG9vcigoci5sZW5ndGgtdCkvZSk7cmV0dXJuIG5ldyBBcnJheShhKS5maWxsKDApLm1hcCgoZnVuY3Rpb24oYSxuKXtyZXR1cm4gci5zbGljZShuKmUsbiplK3QpfSkpfSh0LGUuX20uYnVmZmVyU2l6ZSxlLl9tLmhvcFNpemUpLmZvckVhY2goKGZ1bmN0aW9uKHIpe2UuX20uZnJhbWU9cjt2YXIgdD1lLl9tLmV4dHJhY3QoZS5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsZS5fbS5mcmFtZSxlLl9tLnByZXZpb3VzRnJhbWUpO1wiZnVuY3Rpb25cIj09dHlwZW9mIGUuX20uY2FsbGJhY2smJmUuX20uRVhUUkFDVElPTl9TVEFSVEVEJiZlLl9tLmNhbGxiYWNrKHQpLGUuX20ucHJldmlvdXNGcmFtZT1lLl9tLmZyYW1lfSkpfX1yZXR1cm4gci5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24ocil7dGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3Q9cnx8dGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsdGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQ9ITB9LHIucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt0aGlzLl9tLkVYVFJBQ1RJT05fU1RBUlRFRD0hMX0sci5wcm90b3R5cGUuc2V0U291cmNlPWZ1bmN0aW9uKHIpe3RoaXMuX20uc291cmNlJiZ0aGlzLl9tLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuX20uc3BuKSx0aGlzLl9tLnNvdXJjZT1yLHRoaXMuX20uc291cmNlLmNvbm5lY3QodGhpcy5fbS5zcG4pfSxyLnByb3RvdHlwZS5zZXRDaGFubmVsPWZ1bmN0aW9uKHIpe3I8PXRoaXMuX20uaW5wdXRzP3RoaXMuX20uY2hhbm5lbD1yOmNvbnNvbGUuZXJyb3IoXCJDaGFubmVsIFwiLmNvbmNhdChyLFwiIGRvZXMgbm90IGV4aXN0LiBNYWtlIHN1cmUgeW91J3ZlIHByb3ZpZGVkIGEgdmFsdWUgZm9yICdpbnB1dHMnIHRoYXQgaXMgZ3JlYXRlciB0aGFuIFwiKS5jb25jYXQocixcIiB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIE1leWRhQW5hbHl6ZXJcIikpfSxyLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuX20uaW5wdXREYXRhP3RoaXMuX20uZXh0cmFjdChyfHx0aGlzLl9tLl9mZWF0dXJlc1RvRXh0cmFjdCx0aGlzLl9tLmlucHV0RGF0YSx0aGlzLl9tLnByZXZpb3VzSW5wdXREYXRhKTpudWxsfSxyfSgpLEM9e2F1ZGlvQ29udGV4dDpudWxsLHNwbjpudWxsLGJ1ZmZlclNpemU6NTEyLHNhbXBsZVJhdGU6NDQxMDAsbWVsQmFuZHM6MjYsY2hyb21hQmFuZHM6MTIsY2FsbGJhY2s6bnVsbCx3aW5kb3dpbmdGdW5jdGlvbjpcImhhbm5pbmdcIixmZWF0dXJlRXh0cmFjdG9yczp5LEVYVFJBQ1RJT05fU1RBUlRFRDohMSxudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6MTMsbnVtYmVyT2ZCYXJrQmFuZHM6MjQsX2ZlYXR1cmVzVG9FeHRyYWN0OltdLHdpbmRvd2luZzpuLF9lcnJvcnM6e25vdFBvdzI6bmV3IEVycm9yKFwiTWV5ZGE6IEJ1ZmZlciBzaXplIG11c3QgYmUgYSBwb3dlciBvZiAyLCBlLmcuIDY0IG9yIDUxMlwiKSxmZWF0dXJlVW5kZWY6bmV3IEVycm9yKFwiTWV5ZGE6IE5vIGZlYXR1cmVzIGRlZmluZWQuXCIpLGludmFsaWRGZWF0dXJlRm10Om5ldyBFcnJvcihcIk1leWRhOiBJbnZhbGlkIGZlYXR1cmUgZm9ybWF0XCIpLGludmFsaWRJbnB1dDpuZXcgRXJyb3IoXCJNZXlkYTogSW52YWxpZCBpbnB1dC5cIiksbm9BQzpuZXcgRXJyb3IoXCJNZXlkYTogTm8gQXVkaW9Db250ZXh0IHNwZWNpZmllZC5cIiksbm9Tb3VyY2U6bmV3IEVycm9yKFwiTWV5ZGE6IE5vIHNvdXJjZSBub2RlIHNwZWNpZmllZC5cIil9LGNyZWF0ZU1leWRhQW5hbHl6ZXI6ZnVuY3Rpb24ocil7cmV0dXJuIG5ldyBFKHIsT2JqZWN0LmFzc2lnbih7fSxDKSl9LGxpc3RBdmFpbGFibGVGZWF0dXJlRXh0cmFjdG9yczpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmZlYXR1cmVFeHRyYWN0b3JzKX0sZXh0cmFjdDpmdW5jdGlvbihyLHQsZSl7dmFyIG49dGhpcztpZighdCl0aHJvdyB0aGlzLl9lcnJvcnMuaW52YWxpZElucHV0O2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkSW5wdXQ7aWYoIXIpdGhyb3cgdGhpcy5fZXJyb3JzLmZlYXR1cmVVbmRlZjtpZighYSh0Lmxlbmd0aCkpdGhyb3cgdGhpcy5fZXJyb3JzLm5vdFBvdzI7dm9pZCAwIT09dGhpcy5iYXJrU2NhbGUmJnRoaXMuYmFya1NjYWxlLmxlbmd0aD09dGhpcy5idWZmZXJTaXplfHwodGhpcy5iYXJrU2NhbGU9byh0aGlzLmJ1ZmZlclNpemUsdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLHZvaWQgMCE9PXRoaXMubWVsRmlsdGVyQmFuayYmdGhpcy5iYXJrU2NhbGUubGVuZ3RoPT10aGlzLmJ1ZmZlclNpemUmJnRoaXMubWVsRmlsdGVyQmFuay5sZW5ndGg9PXRoaXMubWVsQmFuZHN8fCh0aGlzLm1lbEZpbHRlckJhbms9ZihNYXRoLm1heCh0aGlzLm1lbEJhbmRzLHRoaXMubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzKSx0aGlzLnNhbXBsZVJhdGUsdGhpcy5idWZmZXJTaXplKSksdm9pZCAwIT09dGhpcy5jaHJvbWFGaWx0ZXJCYW5rJiZ0aGlzLmNocm9tYUZpbHRlckJhbmsubGVuZ3RoPT10aGlzLmNocm9tYUJhbmRzfHwodGhpcy5jaHJvbWFGaWx0ZXJCYW5rPWModGhpcy5jaHJvbWFCYW5kcyx0aGlzLnNhbXBsZVJhdGUsdGhpcy5idWZmZXJTaXplKSksXCJidWZmZXJcImluIHQmJnZvaWQgMD09PXQuYnVmZmVyP3RoaXMuc2lnbmFsPWkodCk6dGhpcy5zaWduYWw9dDt2YXIgdT1rKHQsdGhpcy53aW5kb3dpbmdGdW5jdGlvbix0aGlzLmJ1ZmZlclNpemUpO2lmKHRoaXMuc2lnbmFsPXUud2luZG93ZWRTaWduYWwsdGhpcy5jb21wbGV4U3BlY3RydW09dS5jb21wbGV4U3BlY3RydW0sdGhpcy5hbXBTcGVjdHJ1bT11LmFtcFNwZWN0cnVtLGUpe3ZhciBsPWsoZSx0aGlzLndpbmRvd2luZ0Z1bmN0aW9uLHRoaXMuYnVmZmVyU2l6ZSk7dGhpcy5wcmV2aW91c1NpZ25hbD1sLndpbmRvd2VkU2lnbmFsLHRoaXMucHJldmlvdXNDb21wbGV4U3BlY3RydW09bC5jb21wbGV4U3BlY3RydW0sdGhpcy5wcmV2aW91c0FtcFNwZWN0cnVtPWwuYW1wU3BlY3RydW19dmFyIHM9ZnVuY3Rpb24ocil7cmV0dXJuIG4uZmVhdHVyZUV4dHJhY3RvcnNbcl0oe2FtcFNwZWN0cnVtOm4uYW1wU3BlY3RydW0sY2hyb21hRmlsdGVyQmFuazpuLmNocm9tYUZpbHRlckJhbmssY29tcGxleFNwZWN0cnVtOm4uY29tcGxleFNwZWN0cnVtLHNpZ25hbDpuLnNpZ25hbCxidWZmZXJTaXplOm4uYnVmZmVyU2l6ZSxzYW1wbGVSYXRlOm4uc2FtcGxlUmF0ZSxiYXJrU2NhbGU6bi5iYXJrU2NhbGUsbWVsRmlsdGVyQmFuazpuLm1lbEZpbHRlckJhbmsscHJldmlvdXNTaWduYWw6bi5wcmV2aW91c1NpZ25hbCxwcmV2aW91c0FtcFNwZWN0cnVtOm4ucHJldmlvdXNBbXBTcGVjdHJ1bSxwcmV2aW91c0NvbXBsZXhTcGVjdHJ1bTpuLnByZXZpb3VzQ29tcGxleFNwZWN0cnVtLG51bWJlck9mTUZDQ0NvZWZmaWNpZW50czpuLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyxudW1iZXJPZkJhcmtCYW5kczpuLm51bWJlck9mQmFya0JhbmRzfSl9O2lmKFwib2JqZWN0XCI9PXR5cGVvZiByKXJldHVybiByLnJlZHVjZSgoZnVuY3Rpb24ocix0KXt2YXIgZTtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxyLCgoZT17fSlbdF09cyh0KSxlKSl9KSx7fSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHIpcmV0dXJuIHMocik7dGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRGZWF0dXJlRm10fX0saz1mdW5jdGlvbihyLHQsZSl7dmFyIGE9e307dm9pZCAwPT09ci5idWZmZXI/YS5zaWduYWw9aShyKTphLnNpZ25hbD1yLGEud2luZG93ZWRTaWduYWw9bihhLnNpZ25hbCx0KSxhLmNvbXBsZXhTcGVjdHJ1bT1BKGEud2luZG93ZWRTaWduYWwpLGEuYW1wU3BlY3RydW09bmV3IEZsb2F0MzJBcnJheShlLzIpO2Zvcih2YXIgbz0wO288ZS8yO28rKylhLmFtcFNwZWN0cnVtW29dPU1hdGguc3FydChNYXRoLnBvdyhhLmNvbXBsZXhTcGVjdHJ1bS5yZWFsW29dLDIpK01hdGgucG93KGEuY29tcGxleFNwZWN0cnVtLmltYWdbb10sMikpO3JldHVybiBhfTtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93Lk1leWRhPUMpLEN9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXlkYS5taW4uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcG9vbCA9IHJlcXVpcmUoXCJ0eXBlZGFycmF5LXBvb2xcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTdXJmYWNlRXh0cmFjdG9yXG5cbi8vSGVscGVyIG1hY3Jvc1xuZnVuY3Rpb24gYXJyYXkoaSkge1xuICByZXR1cm4gXCJhXCIgKyBpXG59XG5mdW5jdGlvbiBkYXRhKGkpIHtcbiAgcmV0dXJuIFwiZFwiICsgaVxufVxuZnVuY3Rpb24gY3ViZShpLGJpdG1hc2spIHtcbiAgcmV0dXJuIFwiY1wiICsgaSArIFwiX1wiICsgYml0bWFza1xufVxuZnVuY3Rpb24gc2hhcGUoaSkge1xuICByZXR1cm4gXCJzXCIgKyBpXG59XG5mdW5jdGlvbiBzdHJpZGUoaSxqKSB7XG4gIHJldHVybiBcInRcIiArIGkgKyBcIl9cIiArIGpcbn1cbmZ1bmN0aW9uIG9mZnNldChpKSB7XG4gIHJldHVybiBcIm9cIiArIGlcbn1cbmZ1bmN0aW9uIHNjYWxhcihpKSB7XG4gIHJldHVybiBcInhcIiArIGlcbn1cbmZ1bmN0aW9uIHBvaW50ZXIoaSkge1xuICByZXR1cm4gXCJwXCIgKyBpXG59XG5mdW5jdGlvbiBkZWx0YShpLGJpdG1hc2spIHtcbiAgcmV0dXJuIFwiZFwiICsgaSArIFwiX1wiICsgYml0bWFza1xufVxuZnVuY3Rpb24gaW5kZXgoaSkge1xuICByZXR1cm4gXCJpXCIgKyBpXG59XG5mdW5jdGlvbiBzdGVwKGksaikge1xuICByZXR1cm4gXCJ1XCIgKyBpICsgXCJfXCIgKyBqXG59XG5mdW5jdGlvbiBwY3ViZShiaXRtYXNrKSB7XG4gIHJldHVybiBcImJcIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHFjdWJlKGJpdG1hc2spIHtcbiAgcmV0dXJuIFwieVwiICsgYml0bWFza1xufVxuZnVuY3Rpb24gcGRlbHRhKGJpdG1hc2spIHtcbiAgcmV0dXJuIFwiZVwiICsgYml0bWFza1xufVxuZnVuY3Rpb24gdmVydChpKSB7XG4gIHJldHVybiBcInZcIiArIGlcbn1cbnZhciBWRVJURVhfSURTID0gXCJWXCJcbnZhciBQSEFTRVMgPSBcIlBcIlxudmFyIFZFUlRFWF9DT1VOVCA9IFwiTlwiXG52YXIgUE9PTF9TSVpFID0gXCJRXCJcbnZhciBQT0lOVEVSID0gXCJYXCJcbnZhciBURU1QT1JBUlkgPSBcIlRcIlxuXG5mdW5jdGlvbiBwZXJtQml0bWFzayhkaW1lbnNpb24sIG1hc2ssIG9yZGVyKSB7XG4gIHZhciByID0gMFxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGlmKG1hc2sgJiAoMTw8aSkpIHtcbiAgICAgIHIgfD0gKDE8PG9yZGVyW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG4vL0dlbmVyYXRlcyB0aGUgc3VyZmFjZSBwcm9jZWR1cmVcbmZ1bmN0aW9uIGNvbXBpbGVTdXJmYWNlUHJvY2VkdXJlKHZlcnRleEZ1bmMsIGZhY2VGdW5jLCBwaGFzZUZ1bmMsIHNjYWxhckFyZ3MsIG9yZGVyLCB0eXBlc2lnKSB7XG4gIHZhciBhcnJheUFyZ3MgPSB0eXBlc2lnLmxlbmd0aFxuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG5cbiAgaWYoZGltZW5zaW9uIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5kYXJyYXktZXh0cmFjdC1jb250b3VyOiBEaW1lbnNpb24gbXVzdCBiZSBhdCBsZWFzdCAyXCIpXG4gIH1cblxuICB2YXIgZnVuY05hbWUgPSBcImV4dHJhY3RDb250b3VyXCIgKyBvcmRlci5qb2luKFwiX1wiKVxuICB2YXIgY29kZSA9IFtdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIC8vQXNzZW1ibGUgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgYXJncy5wdXNoKGFycmF5KGkpKSAgXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8c2NhbGFyQXJnczsgKytpKSB7XG4gICAgYXJncy5wdXNoKHNjYWxhcihpKSlcbiAgfVxuXG4gIC8vU2hhcGVcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB2YXJzLnB1c2goc2hhcGUoaSkgKyBcIj1cIiArIGFycmF5KDApICsgXCIuc2hhcGVbXCIgKyBpICsgXCJdfDBcIilcbiAgfVxuICAvL0RhdGEsIHN0cmlkZSwgb2Zmc2V0IHBvaW50ZXJzXG4gIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgdmFycy5wdXNoKGRhdGEoaSkgKyBcIj1cIiArIGFycmF5KGkpICsgXCIuZGF0YVwiLFxuICAgICAgICAgICAgICBvZmZzZXQoaSkgKyBcIj1cIiArIGFycmF5KGkpICsgXCIub2Zmc2V0fDBcIilcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgdmFycy5wdXNoKHN0cmlkZShpLGopICsgXCI9XCIgKyBhcnJheShpKSArIFwiLnN0cmlkZVtcIiArIGogKyBcIl18MFwiKVxuICAgIH1cbiAgfVxuICAvL1BvaW50ZXIsIGRlbHRhIGFuZCBjdWJlIHZhcmlhYmxlc1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIHZhcnMucHVzaChwb2ludGVyKGkpICsgXCI9XCIgKyBvZmZzZXQoaSkpXG4gICAgdmFycy5wdXNoKGN1YmUoaSwwKSlcbiAgICBmb3IodmFyIGo9MTsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICB2YXIgcHRyU3RyID0gW11cbiAgICAgIGZvcih2YXIgaz0wOyBrPGRpbWVuc2lvbjsgKytrKSB7XG4gICAgICAgIGlmKGogJiAoMTw8aykpIHtcbiAgICAgICAgICBwdHJTdHIucHVzaChcIi1cIiArIHN0cmlkZShpLGspKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXJzLnB1c2goZGVsdGEoaSxqKSArIFwiPShcIiArIHB0clN0ci5qb2luKFwiXCIpICsgXCIpfDBcIilcbiAgICAgIHZhcnMucHVzaChjdWJlKGksaikgKyBcIj0wXCIpXG4gICAgfVxuICB9XG4gIC8vQ3JlYXRlIHN0ZXAgdmFyaWFibGVzXG4gIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIHZhciBzdGVwVmFsID0gWyBzdHJpZGUoaSxvcmRlcltqXSkgXVxuICAgICAgaWYoaiA+IDApIHtcbiAgICAgICAgc3RlcFZhbC5wdXNoKHN0cmlkZShpLCBvcmRlcltqLTFdKSArIFwiKlwiICsgc2hhcGUob3JkZXJbai0xXSkgKVxuICAgICAgfVxuICAgICAgdmFycy5wdXNoKHN0ZXAoaSxvcmRlcltqXSkgKyBcIj0oXCIgKyBzdGVwVmFsLmpvaW4oXCItXCIpICsgXCIpfDBcIilcbiAgICB9XG4gIH1cbiAgLy9DcmVhdGUgaW5kZXggdmFyaWFibGVzXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdmFycy5wdXNoKGluZGV4KGkpICsgXCI9MFwiKVxuICB9XG4gIC8vVmVydGV4IGNvdW50XG4gIHZhcnMucHVzaChWRVJURVhfQ09VTlQgKyBcIj0wXCIpXG4gIC8vQ29tcHV0ZSBwb29sIHNpemUsIGluaXRpYWxpemUgcG9vbCBzdGVwXG4gIHZhciBzaXplVmFyaWFibGUgPSBbXCIyXCJdXG4gIGZvcih2YXIgaT1kaW1lbnNpb24tMjsgaT49MDsgLS1pKSB7XG4gICAgc2l6ZVZhcmlhYmxlLnB1c2goc2hhcGUob3JkZXJbaV0pKVxuICB9XG4gIC8vUHJldmlvdXMgcGhhc2VzIGFuZCB2ZXJ0ZXhfaWRzXG4gIHZhcnMucHVzaChQT09MX1NJWkUgKyBcIj0oXCIgKyBzaXplVmFyaWFibGUuam9pbihcIipcIikgKyBcIil8MFwiLFxuICAgICAgICAgICAgUEhBU0VTICsgXCI9bWFsbG9jVWludDMyKFwiICsgUE9PTF9TSVpFICsgXCIpXCIsXG4gICAgICAgICAgICBWRVJURVhfSURTICsgXCI9bWFsbG9jVWludDMyKFwiICsgUE9PTF9TSVpFICsgXCIpXCIsXG4gICAgICAgICAgICBQT0lOVEVSICsgXCI9MFwiKVxuICAvL0NyZWF0ZSBjdWJlIHZhcmlhYmxlcyBmb3IgcGhhc2VzXG4gIHZhcnMucHVzaChwY3ViZSgwKSArIFwiPTBcIilcbiAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgIHZhciBjdWJlRGVsdGEgPSBbXVxuICAgIHZhciBjdWJlU3RlcCA9IFsgXVxuICAgIGZvcih2YXIgaz0wOyBrPGRpbWVuc2lvbjsgKytrKSB7XG4gICAgICBpZihqICYgKDE8PGspKSB7XG4gICAgICAgIGlmKGN1YmVTdGVwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGN1YmVEZWx0YS5wdXNoKFwiMVwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1YmVEZWx0YS51bnNoaWZ0KGN1YmVTdGVwLmpvaW4oXCIqXCIpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdWJlU3RlcC5wdXNoKHNoYXBlKG9yZGVyW2tdKSlcbiAgICB9XG4gICAgdmFyIHNpZ25GbGFnID0gXCJcIlxuICAgIGlmKGN1YmVEZWx0YVswXS5pbmRleE9mKHNoYXBlKG9yZGVyW2RpbWVuc2lvbi0yXSkpIDwgMCkge1xuICAgICAgc2lnbkZsYWcgPSBcIi1cIlxuICAgIH1cbiAgICB2YXIganBlcm0gPSBwZXJtQml0bWFzayhkaW1lbnNpb24sIGosIG9yZGVyKVxuICAgIHZhcnMucHVzaChwZGVsdGEoanBlcm0pICsgXCI9KC1cIiArIGN1YmVEZWx0YS5qb2luKFwiLVwiKSArIFwiKXwwXCIsXG4gICAgICAgICAgICAgIHFjdWJlKGpwZXJtKSArIFwiPShcIiArIHNpZ25GbGFnICsgY3ViZURlbHRhLmpvaW4oXCItXCIpICsgXCIpfDBcIixcbiAgICAgICAgICAgICAgcGN1YmUoanBlcm0pICsgXCI9MFwiKVxuICB9XG4gIHZhcnMucHVzaCh2ZXJ0KDApICsgXCI9MFwiLCBURU1QT1JBUlkgKyBcIj0wXCIpXG5cbiAgZnVuY3Rpb24gZm9yTG9vcEJlZ2luKGksIHN0YXJ0KSB7XG4gICAgY29kZS5wdXNoKFwiZm9yKFwiLCBpbmRleChvcmRlcltpXSksIFwiPVwiLCBzdGFydCwgXCI7XCIsXG4gICAgICBpbmRleChvcmRlcltpXSksIFwiPFwiLCBzaGFwZShvcmRlcltpXSksIFwiO1wiLFxuICAgICAgXCIrK1wiLCBpbmRleChvcmRlcltpXSksIFwiKXtcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckxvb3BFbmQoaSkge1xuICAgIGZvcih2YXIgaj0wOyBqPGFycmF5QXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocG9pbnRlcihqKSwgXCIrPVwiLCBzdGVwKGosb3JkZXJbaV0pLCBcIjtcIilcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEVtcHR5U2xpY2Uoaykge1xuICAgIGZvcih2YXIgaT1rLTE7IGk+PTA7IC0taSkge1xuICAgICAgZm9yTG9vcEJlZ2luKGksIDApIFxuICAgIH1cbiAgICB2YXIgcGhhc2VGdW5jQXJncyA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIGlmKHR5cGVzaWdbaV0pIHtcbiAgICAgICAgcGhhc2VGdW5jQXJncy5wdXNoKGRhdGEoaSkgKyBcIi5nZXQoXCIgKyBwb2ludGVyKGkpICsgXCIpXCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaGFzZUZ1bmNBcmdzLnB1c2goZGF0YShpKSArIFwiW1wiICsgcG9pbnRlcihpKSArIFwiXVwiKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxzY2FsYXJBcmdzOyArK2kpIHtcbiAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChzY2FsYXIoaSkpXG4gICAgfVxuICAgIGNvZGUucHVzaChQSEFTRVMsIFwiW1wiLCBQT0lOVEVSLCBcIisrXT1waGFzZShcIiwgcGhhc2VGdW5jQXJncy5qb2luKCksIFwiKTtcIilcbiAgICBmb3IodmFyIGk9MDsgaTxrOyArK2kpIHtcbiAgICAgIGZvckxvb3BFbmQoaSlcbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8YXJyYXlBcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChwb2ludGVyKGopLCBcIis9XCIsIHN0ZXAoaixvcmRlcltrXSksIFwiO1wiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NHcmlkQ2VsbChtYXNrKSB7XG4gICAgLy9SZWFkIGluIGxvY2FsIGRhdGFcbiAgICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgICAgaWYodHlwZXNpZ1tpXSkge1xuICAgICAgICBjb2RlLnB1c2goY3ViZShpLDApLCBcIj1cIiwgZGF0YShpKSwgXCIuZ2V0KFwiLCBwb2ludGVyKGkpLCBcIik7XCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLnB1c2goY3ViZShpLDApLCBcIj1cIiwgZGF0YShpKSwgXCJbXCIsIHBvaW50ZXIoaSksIFwiXTtcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1JlYWQgaW4gcGhhc2VcbiAgICB2YXIgcGhhc2VGdW5jQXJncyA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChjdWJlKGksMCkpXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHNjYWxhckFyZ3M7ICsraSkge1xuICAgICAgcGhhc2VGdW5jQXJncy5wdXNoKHNjYWxhcihpKSlcbiAgICB9XG4gICAgXG4gICAgY29kZS5wdXNoKHBjdWJlKDApLCBcIj1cIiwgUEhBU0VTLCBcIltcIiwgUE9JTlRFUiwgXCJdPXBoYXNlKFwiLCBwaGFzZUZ1bmNBcmdzLmpvaW4oKSwgXCIpO1wiKVxuICAgIFxuICAgIC8vUmVhZCBpbiBvdGhlciBjdWJlIGRhdGFcbiAgICBmb3IodmFyIGo9MTsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocGN1YmUoaiksIFwiPVwiLCBQSEFTRVMsIFwiW1wiLCBQT0lOVEVSLCBcIitcIiwgcGRlbHRhKGopLCBcIl07XCIpXG4gICAgfVxuXG4gICAgLy9DaGVjayBmb3IgYm91bmRhcnkgY3Jvc3NpbmdcbiAgICB2YXIgdmVydGV4UHJlZGljYXRlID0gW11cbiAgICBmb3IodmFyIGo9MTsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICB2ZXJ0ZXhQcmVkaWNhdGUucHVzaChcIihcIiArIHBjdWJlKDApICsgXCIhPT1cIiArIHBjdWJlKGopICsgXCIpXCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcImlmKFwiLCB2ZXJ0ZXhQcmVkaWNhdGUuam9pbihcInx8XCIpLCBcIil7XCIpXG5cbiAgICAvL1JlYWQgaW4gYm91bmRhcnkgZGF0YVxuICAgIHZhciB2ZXJ0ZXhBcmdzID0gW11cbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgdmVydGV4QXJncy5wdXNoKGluZGV4KGkpKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgICAgdmVydGV4QXJncy5wdXNoKGN1YmUoaSwwKSlcbiAgICAgIGZvcih2YXIgaj0xOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICAgICAgaWYodHlwZXNpZ1tpXSkge1xuICAgICAgICAgIGNvZGUucHVzaChjdWJlKGksaiksIFwiPVwiLCBkYXRhKGkpLCBcIi5nZXQoXCIsIHBvaW50ZXIoaSksIFwiK1wiLCBkZWx0YShpLGopLCBcIik7XCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS5wdXNoKGN1YmUoaSxqKSwgXCI9XCIsIGRhdGEoaSksIFwiW1wiLCBwb2ludGVyKGkpLCBcIitcIiwgZGVsdGEoaSxqKSwgXCJdO1wiKVxuICAgICAgICB9XG4gICAgICAgIHZlcnRleEFyZ3MucHVzaChjdWJlKGksaikpXG4gICAgICB9XG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICAgIHZlcnRleEFyZ3MucHVzaChwY3ViZShpKSlcbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8c2NhbGFyQXJnczsgKytpKSB7XG4gICAgICB2ZXJ0ZXhBcmdzLnB1c2goc2NhbGFyKGkpKVxuICAgIH1cblxuICAgIC8vR2VuZXJhdGUgdmVydGV4XG4gICAgY29kZS5wdXNoKFwidmVydGV4KFwiLCB2ZXJ0ZXhBcmdzLmpvaW4oKSwgXCIpO1wiLFxuICAgICAgdmVydCgwKSwgXCI9XCIsIFZFUlRFWF9JRFMsIFwiW1wiLCBQT0lOVEVSLCBcIl09XCIsIFZFUlRFWF9DT1VOVCwgXCIrKztcIilcblxuICAgIC8vQ2hlY2sgZm9yIGZhY2UgY3Jvc3NpbmdzXG4gICAgdmFyIGJhc2UgPSAoMTw8ZGltZW5zaW9uKS0xXG4gICAgdmFyIGNvcm5lciA9IHBjdWJlKGJhc2UpXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGlmKChtYXNrICYgfigxPDxqKSk9PT0wKSB7XG4gICAgICAgIC8vQ2hlY2sgZmFjZVxuICAgICAgICB2YXIgc3Vic2V0ID0gYmFzZV4oMTw8ailcbiAgICAgICAgdmFyIGVkZ2UgPSBwY3ViZShzdWJzZXQpXG4gICAgICAgIHZhciBmYWNlQXJncyA9IFsgXVxuICAgICAgICBmb3IodmFyIGs9c3Vic2V0OyBrPjA7IGs9KGstMSkmc3Vic2V0KSB7XG4gICAgICAgICAgZmFjZUFyZ3MucHVzaChWRVJURVhfSURTICsgXCJbXCIgKyBQT0lOVEVSICsgXCIrXCIgKyBwZGVsdGEoaykgKyBcIl1cIilcbiAgICAgICAgfVxuICAgICAgICBmYWNlQXJncy5wdXNoKHZlcnQoMCkpXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPGFycmF5QXJnczsgKytrKSB7XG4gICAgICAgICAgaWYoaiYxKSB7XG4gICAgICAgICAgICBmYWNlQXJncy5wdXNoKGN1YmUoayxiYXNlKSwgY3ViZShrLHN1YnNldCkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhY2VBcmdzLnB1c2goY3ViZShrLHN1YnNldCksIGN1YmUoayxiYXNlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaiYxKSB7XG4gICAgICAgICAgZmFjZUFyZ3MucHVzaChjb3JuZXIsIGVkZ2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZUFyZ3MucHVzaChlZGdlLCBjb3JuZXIpXG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBrPTA7IGs8c2NhbGFyQXJnczsgKytrKSB7XG4gICAgICAgICAgZmFjZUFyZ3MucHVzaChzY2FsYXIoaykpXG4gICAgICAgIH1cbiAgICAgICAgY29kZS5wdXNoKFwiaWYoXCIsIGNvcm5lciwgXCIhPT1cIiwgZWRnZSwgXCIpe1wiLFxuICAgICAgICAgIFwiZmFjZShcIiwgZmFjZUFyZ3Muam9pbigpLCBcIil9XCIpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vSW5jcmVtZW50IHBvaW50ZXIsIGNsb3NlIG9mZiBpZiBzdGF0ZW1lbnRcbiAgICBjb2RlLnB1c2goXCJ9XCIsXG4gICAgICBQT0lOVEVSLCBcIis9MTtcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsaXAoKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgY29kZS5wdXNoKFRFTVBPUkFSWSwgXCI9XCIsIHBkZWx0YShqKSwgXCI7XCIsXG4gICAgICAgICAgICAgICAgcGRlbHRhKGopLCBcIj1cIiwgcWN1YmUoaiksIFwiO1wiLFxuICAgICAgICAgICAgICAgIHFjdWJlKGopLCBcIj1cIiwgVEVNUE9SQVJZLCBcIjtcIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVMb29wKGksIG1hc2spIHtcbiAgICBpZihpIDwgMCkge1xuICAgICAgcHJvY2Vzc0dyaWRDZWxsKG1hc2spXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZmlsbEVtcHR5U2xpY2UoaSlcbiAgICBjb2RlLnB1c2goXCJpZihcIiwgc2hhcGUob3JkZXJbaV0pLCBcIj4wKXtcIixcbiAgICAgIGluZGV4KG9yZGVyW2ldKSwgXCI9MTtcIilcbiAgICBjcmVhdGVMb29wKGktMSwgbWFza3woMTw8b3JkZXJbaV0pKVxuXG4gICAgZm9yKHZhciBqPTA7IGo8YXJyYXlBcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChwb2ludGVyKGopLCBcIis9XCIsIHN0ZXAoaixvcmRlcltpXSksIFwiO1wiKVxuICAgIH1cbiAgICBpZihpID09PSBkaW1lbnNpb24tMSkge1xuICAgICAgY29kZS5wdXNoKFBPSU5URVIsIFwiPTA7XCIpXG4gICAgICBmbGlwKClcbiAgICB9XG4gICAgZm9yTG9vcEJlZ2luKGksIDIpXG4gICAgY3JlYXRlTG9vcChpLTEsIG1hc2spXG4gICAgaWYoaSA9PT0gZGltZW5zaW9uLTEpIHtcbiAgICAgIGNvZGUucHVzaChcImlmKFwiLCBpbmRleChvcmRlcltkaW1lbnNpb24tMV0pLCBcIiYxKXtcIixcbiAgICAgICAgUE9JTlRFUiwgXCI9MDt9XCIpXG4gICAgICBmbGlwKClcbiAgICB9XG4gICAgZm9yTG9vcEVuZChpKVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuXG4gIGNyZWF0ZUxvb3AoZGltZW5zaW9uLTEsIDApXG5cbiAgLy9SZWxlYXNlIHNjcmF0Y2ggbWVtb3J5XG4gIGNvZGUucHVzaChcImZyZWVVaW50MzIoXCIsIFZFUlRFWF9JRFMsIFwiKTtmcmVlVWludDMyKFwiLCBQSEFTRVMsIFwiKTtcIilcblxuICAvL0NvbXBpbGUgYW5kIGxpbmsgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmVDb2RlID0gW1xuICAgIFwiJ3VzZSBzdHJpY3QnO1wiLFxuICAgIFwiZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihcIiwgYXJncy5qb2luKCksIFwiKXtcIixcbiAgICAgIFwidmFyIFwiLCB2YXJzLmpvaW4oKSwgXCI7XCIsXG4gICAgICBjb2RlLmpvaW4oXCJcIiksXG4gICAgXCJ9XCIsXG4gICAgXCJyZXR1cm4gXCIsIGZ1bmNOYW1lIF0uam9pbihcIlwiKVxuXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKFxuICAgIFwidmVydGV4XCIsIFxuICAgIFwiZmFjZVwiLCBcbiAgICBcInBoYXNlXCIsIFxuICAgIFwibWFsbG9jVWludDMyXCIsIFxuICAgIFwiZnJlZVVpbnQzMlwiLFxuICAgIHByb2NlZHVyZUNvZGUpXG4gIHJldHVybiBwcm9jKFxuICAgIHZlcnRleEZ1bmMsIFxuICAgIGZhY2VGdW5jLCBcbiAgICBwaGFzZUZ1bmMsIFxuICAgIHBvb2wubWFsbG9jVWludDMyLCBcbiAgICBwb29sLmZyZWVVaW50MzIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1cmZhY2VFeHRyYWN0b3IoYXJncykge1xuICBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZGFycmF5LWV4dHJhY3QtY29udG91cjogXCIgKyBtc2cpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSBhcmd1bWVudHNcIilcbiAgfVxuICB2YXIgb3JkZXIgPSBhcmdzLm9yZGVyXG4gIGlmKCFBcnJheS5pc0FycmF5KG9yZGVyKSkge1xuICAgIGVycm9yKFwiTXVzdCBzcGVjaWZ5IG9yZGVyXCIpXG4gIH1cbiAgdmFyIGFycmF5cyA9IGFyZ3MuYXJyYXlBcmd1bWVudHN8fDFcbiAgaWYoYXJyYXlzIDwgMSkge1xuICAgIGVycm9yKFwiTXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBhcnJheSBhcmd1bWVudFwiKVxuICB9XG4gIHZhciBzY2FsYXJzID0gYXJncy5zY2FsYXJBcmd1bWVudHN8fDBcbiAgaWYoc2NhbGFycyA8IDApIHtcbiAgICBlcnJvcihcIlNjYWxhciBhcmcgY291bnQgbXVzdCBiZSA+IDBcIilcbiAgfVxuICBpZih0eXBlb2YgYXJncy52ZXJ0ZXggIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVycm9yKFwiTXVzdCBzcGVjaWZ5IHZlcnRleCBjcmVhdGlvbiBmdW5jdGlvblwiKVxuICB9XG4gIGlmKHR5cGVvZiBhcmdzLmNlbGwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVycm9yKFwiTXVzdCBzcGVjaWZ5IGNlbGwgY3JlYXRpb24gZnVuY3Rpb25cIilcbiAgfVxuICBpZih0eXBlb2YgYXJncy5waGFzZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXJyb3IoXCJNdXN0IHNwZWNpZnkgcGhhc2UgZnVuY3Rpb25cIilcbiAgfVxuICB2YXIgZ2V0dGVycyA9IGFyZ3MuZ2V0dGVycyB8fCBbXVxuICB2YXIgdHlwZXNpZyA9IG5ldyBBcnJheShhcnJheXMpXG4gIGZvcih2YXIgaT0wOyBpPGFycmF5czsgKytpKSB7XG4gICAgaWYoZ2V0dGVycy5pbmRleE9mKGkpID49IDApIHtcbiAgICAgIHR5cGVzaWdbaV0gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzaWdbaV0gPSBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGlsZVN1cmZhY2VQcm9jZWR1cmUoXG4gICAgYXJncy52ZXJ0ZXgsXG4gICAgYXJncy5jZWxsLFxuICAgIGFyZ3MucGhhc2UsXG4gICAgc2NhbGFycyxcbiAgICBvcmRlcixcbiAgICB0eXBlc2lnKVxufSIsInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgQmlnSW50NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiYmlnaW50NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgQmlnVWludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ3VpbnQ2NFwiXG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiXG4gIH1cbiAgcmV0dXJuIFwiZ2VuZXJpY1wiXG59XG5cbnZhciBDQUNIRURfQ09OU1RSVUNUT1JTID0ge1xuICBcImZsb2F0MzJcIjpbXSxcbiAgXCJmbG9hdDY0XCI6W10sXG4gIFwiaW50OFwiOltdLFxuICBcImludDE2XCI6W10sXG4gIFwiaW50MzJcIjpbXSxcbiAgXCJ1aW50OFwiOltdLFxuICBcInVpbnQxNlwiOltdLFxuICBcInVpbnQzMlwiOltdLFxuICBcImFycmF5XCI6W10sXG4gIFwidWludDhfY2xhbXBlZFwiOltdLFxuICBcImJpZ2ludDY0XCI6IFtdLFxuICBcImJpZ3VpbnQ2NFwiOiBbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBkb3VibGVCaXRzID0gcmVxdWlyZShcImRvdWJsZS1iaXRzXCIpXG5cbnZhciBTTUFMTEVTVF9ERU5PUk0gPSBNYXRoLnBvdygyLCAtMTA3NClcbnZhciBVSU5UX01BWCA9ICgtMSk+Pj4wXG5cbm1vZHVsZS5leHBvcnRzID0gbmV4dGFmdGVyXG5cbmZ1bmN0aW9uIG5leHRhZnRlcih4LCB5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgcmV0dXJuIE5hTlxuICB9XG4gIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGlmKHggPT09IDApIHtcbiAgICBpZih5IDwgMCkge1xuICAgICAgcmV0dXJuIC1TTUFMTEVTVF9ERU5PUk1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNNQUxMRVNUX0RFTk9STVxuICAgIH1cbiAgfVxuICB2YXIgaGkgPSBkb3VibGVCaXRzLmhpKHgpXG4gIHZhciBsbyA9IGRvdWJsZUJpdHMubG8oeClcbiAgaWYoKHkgPiB4KSA9PT0gKHggPiAwKSkge1xuICAgIGlmKGxvID09PSBVSU5UX01BWCkge1xuICAgICAgaGkgKz0gMVxuICAgICAgbG8gPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvICs9IDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYobG8gPT09IDApIHtcbiAgICAgIGxvID0gVUlOVF9NQVhcbiAgICAgIGhpIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gLT0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gZG91YmxlQml0cy5wYWNrKGxvLCBoaSlcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBub2RlTG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIG1vZHVsZUxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgICB1cFRpbWUgPSBwcm9jZXNzLnVwdGltZSgpICogMWU5O1xuICAgIG5vZGVMb2FkVGltZSA9IG1vZHVsZUxvYWRUaW1lIC0gdXBUaW1lO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmb3JtYW5jZS1ub3cuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcm11dGF0aW9uU2lnblxuXG52YXIgQlJVVEVfRk9SQ0VfQ1VUT0ZGID0gMzJcblxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG5cbmZ1bmN0aW9uIHBlcm11dGF0aW9uU2lnbihwKSB7XG4gIHZhciBuID0gcC5sZW5ndGhcbiAgaWYobiA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgIC8vVXNlIHF1YWRyYXRpYyBhbGdvcml0aG0gZm9yIHNtYWxsIG5cbiAgICB2YXIgc2duID0gMVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgZm9yKHZhciBqPTA7IGo8aTsgKytqKSB7XG4gICAgICAgIGlmKHBbaV0gPCBwW2pdKSB7XG4gICAgICAgICAgc2duID0gLXNnblxuICAgICAgICB9IGVsc2UgaWYocFtpXSA9PT0gcFtqXSkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNnblxuICB9IGVsc2Uge1xuICAgIC8vT3RoZXJ3aXNlIHVzZSBsaW5lYXIgdGltZSBhbGdvcml0aG1cbiAgICB2YXIgdmlzaXRlZCA9IHBvb2wubWFsbG9jVWludDgobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHZpc2l0ZWRbaV0gPSAwXG4gICAgfVxuICAgIHZhciBzZ24gPSAxXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICBpZighdmlzaXRlZFtpXSkge1xuICAgICAgICB2YXIgY291bnQgPSAxXG4gICAgICAgIHZpc2l0ZWRbaV0gPSAxXG4gICAgICAgIGZvcih2YXIgaj1wW2ldOyBqIT09aTsgaj1wW2pdKSB7XG4gICAgICAgICAgaWYodmlzaXRlZFtqXSkge1xuICAgICAgICAgICAgcG9vbC5mcmVlVWludDgodmlzaXRlZClcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICB2aXNpdGVkW2pdID0gMVxuICAgICAgICB9XG4gICAgICAgIGlmKCEoY291bnQgJiAxKSkge1xuICAgICAgICAgIHNnbiA9IC1zZ25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb29sLmZyZWVVaW50OCh2aXNpdGVkKVxuICAgIHJldHVybiBzZ25cbiAgfVxufSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBwb29sID0gcmVxdWlyZShcInR5cGVkYXJyYXktcG9vbFwiKVxudmFyIGludmVyc2UgPSByZXF1aXJlKFwiaW52ZXJ0LXBlcm11dGF0aW9uXCIpXG5cbmZ1bmN0aW9uIHJhbmsocGVybXV0YXRpb24pIHtcbiAgdmFyIG4gPSBwZXJtdXRhdGlvbi5sZW5ndGhcbiAgc3dpdGNoKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIDBcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gcGVybXV0YXRpb25bMV1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWtcbiAgfVxuICB2YXIgcCA9IHBvb2wubWFsbG9jVWludDMyKG4pXG4gIHZhciBwaW52ID0gcG9vbC5tYWxsb2NVaW50MzIobilcbiAgdmFyIHIgPSAwLCBzLCB0LCBpXG4gIGludmVyc2UocGVybXV0YXRpb24sIHBpbnYpXG4gIGZvcihpPTA7IGk8bjsgKytpKSB7XG4gICAgcFtpXSA9IHBlcm11dGF0aW9uW2ldXG4gIH1cbiAgZm9yKGk9bi0xOyBpPjA7IC0taSkge1xuICAgIHQgPSBwaW52W2ldXG4gICAgcyA9IHBbaV1cbiAgICBwW2ldID0gcFt0XVxuICAgIHBbdF0gPSBzXG4gICAgcGludltpXSA9IHBpbnZbc11cbiAgICBwaW52W3NdID0gdFxuICAgIHIgPSAociArIHMpICogaVxuICB9XG4gIHBvb2wuZnJlZVVpbnQzMihwaW52KVxuICBwb29sLmZyZWVVaW50MzIocClcbiAgcmV0dXJuIHJcbn1cblxuZnVuY3Rpb24gdW5yYW5rKG4sIHIsIHApIHtcbiAgc3dpdGNoKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZihwKSB7IHJldHVybiBwIH1cbiAgICAgIHJldHVybiBbXVxuICAgIGNhc2UgMTpcbiAgICAgIGlmKHApIHtcbiAgICAgICAgcFswXSA9IDBcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMF1cbiAgICAgIH1cbiAgICBjYXNlIDI6XG4gICAgICBpZihwKSB7XG4gICAgICAgIGlmKHIpIHtcbiAgICAgICAgICBwWzBdID0gMFxuICAgICAgICAgIHBbMV0gPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcFswXSA9IDFcbiAgICAgICAgICBwWzFdID0gMFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gciA/IFswLDFdIDogWzEsMF1cbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWtcbiAgfVxuICBwID0gcCB8fCBuZXcgQXJyYXkobilcbiAgdmFyIHMsIHQsIGksIG5mPTFcbiAgcFswXSA9IDBcbiAgZm9yKGk9MTsgaTxuOyArK2kpIHtcbiAgICBwW2ldID0gaVxuICAgIG5mID0gKG5mKmkpfDBcbiAgfVxuICBmb3IoaT1uLTE7IGk+MDsgLS1pKSB7XG4gICAgcyA9IChyIC8gbmYpfDBcbiAgICByID0gKHIgLSBzICogbmYpfDBcbiAgICBuZiA9IChuZiAvIGkpfDBcbiAgICB0ID0gcFtpXXwwXG4gICAgcFtpXSA9IHBbc118MFxuICAgIHBbc10gPSB0fDBcbiAgfVxuICByZXR1cm4gcFxufVxuXG5leHBvcnRzLnJhbmsgPSByYW5rXG5leHBvcnRzLnVucmFuayA9IHVucmFua1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBwbGFuYXJEdWFsXG5cbnZhciBjb21wYXJlQW5nbGUgPSByZXF1aXJlKFwiY29tcGFyZS1hbmdsZVwiKVxuXG5mdW5jdGlvbiBwbGFuYXJEdWFsKGNlbGxzLCBwb3NpdGlvbnMpIHtcblxuICB2YXIgbnVtVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RofDBcbiAgdmFyIG51bUVkZ2VzID0gY2VsbHMubGVuZ3RoXG4gIHZhciBhZGogPSBbbmV3IEFycmF5KG51bVZlcnRpY2VzKSwgbmV3IEFycmF5KG51bVZlcnRpY2VzKV1cbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGFkalswXVtpXSA9IFtdXG4gICAgYWRqWzFdW2ldID0gW11cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGFkalswXVtjWzBdXS5wdXNoKGMpXG4gICAgYWRqWzFdW2NbMV1dLnB1c2goYylcbiAgfVxuXG4gIHZhciBjeWNsZXMgPSBbXVxuXG4gIC8vQWRkIGlzb2xhdGVkIHZlcnRpY2VzIGFzIHRyaXZpYWwgY2FzZVxuICBmb3IodmFyIGk9MDsgaTxudW1WZXJ0aWNlczsgKytpKSB7XG4gICAgaWYoYWRqWzBdW2ldLmxlbmd0aCArIGFkalsxXVtpXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGN5Y2xlcy5wdXNoKCBbaV0gKVxuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGEgaGFsZiBlZGdlXG4gIGZ1bmN0aW9uIGN1dChjLCBpKSB7XG4gICAgdmFyIGEgPSBhZGpbaV1bY1tpXV1cbiAgICBhLnNwbGljZShhLmluZGV4T2YoYyksIDEpXG4gIH1cblxuICAvL0ZpbmQgbmV4dCB2ZXJ0ZXggYW5kIGN1dCBlZGdlXG4gIGZ1bmN0aW9uIG5leHQoYSwgYiwgbm9DdXQpIHtcbiAgICB2YXIgbmV4dENlbGwsIG5leHRWZXJ0ZXgsIG5leHREaXJcbiAgICBmb3IodmFyIGk9MDsgaTwyOyArK2kpIHtcbiAgICAgIGlmKGFkaltpXVtiXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRDZWxsID0gYWRqW2ldW2JdWzBdXG4gICAgICAgIG5leHREaXIgPSBpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIG5leHRWZXJ0ZXggPSBuZXh0Q2VsbFtuZXh0RGlyXjFdXG5cbiAgICBmb3IodmFyIGRpcj0wOyBkaXI8MjsgKytkaXIpIHtcbiAgICAgIHZhciBuYmhkID0gYWRqW2Rpcl1bYl1cbiAgICAgIGZvcih2YXIgaz0wOyBrPG5iaGQubGVuZ3RoOyArK2spIHtcbiAgICAgICAgdmFyIGUgPSBuYmhkW2tdXG4gICAgICAgIHZhciBwID0gZVtkaXJeMV1cbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVBbmdsZShcbiAgICAgICAgICAgIHBvc2l0aW9uc1thXSwgXG4gICAgICAgICAgICBwb3NpdGlvbnNbYl0sIFxuICAgICAgICAgICAgcG9zaXRpb25zW25leHRWZXJ0ZXhdLFxuICAgICAgICAgICAgcG9zaXRpb25zW3BdKVxuICAgICAgICBpZihjbXAgPiAwKSB7XG4gICAgICAgICAgbmV4dENlbGwgPSBlXG4gICAgICAgICAgbmV4dFZlcnRleCA9IHBcbiAgICAgICAgICBuZXh0RGlyID0gZGlyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYobm9DdXQpIHtcbiAgICAgIHJldHVybiBuZXh0VmVydGV4XG4gICAgfVxuICAgIGlmKG5leHRDZWxsKSB7XG4gICAgICBjdXQobmV4dENlbGwsIG5leHREaXIpXG4gICAgfVxuICAgIHJldHVybiBuZXh0VmVydGV4XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0Q3ljbGUodiwgZGlyKSB7XG4gICAgdmFyIGUwID0gYWRqW2Rpcl1bdl1bMF1cbiAgICB2YXIgY3ljbGUgPSBbdl1cbiAgICBjdXQoZTAsIGRpcilcbiAgICB2YXIgdSA9IGUwW2Rpcl4xXVxuICAgIHZhciBkMCA9IGRpclxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHdoaWxlKHUgIT09IHYpIHtcbiAgICAgICAgY3ljbGUucHVzaCh1KVxuICAgICAgICB1ID0gbmV4dChjeWNsZVtjeWNsZS5sZW5ndGgtMl0sIHUsIGZhbHNlKVxuICAgICAgfVxuICAgICAgaWYoYWRqWzBdW3ZdLmxlbmd0aCArIGFkalsxXVt2XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gY3ljbGVbY3ljbGUubGVuZ3RoLTFdXG4gICAgICB2YXIgYiA9IHZcbiAgICAgIHZhciBjID0gY3ljbGVbMV1cbiAgICAgIHZhciBkID0gbmV4dChhLCBiLCB0cnVlKVxuICAgICAgaWYoY29tcGFyZUFuZ2xlKHBvc2l0aW9uc1thXSwgcG9zaXRpb25zW2JdLCBwb3NpdGlvbnNbY10sIHBvc2l0aW9uc1tkXSkgPCAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjeWNsZS5wdXNoKHYpXG4gICAgICB1ID0gbmV4dChhLCBiKVxuICAgIH1cbiAgICByZXR1cm4gY3ljbGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEdsdWUocGN5Y2xlLCBuY3ljbGUpIHtcbiAgICByZXR1cm4gKG5jeWNsZVsxXSA9PT0gbmN5Y2xlW25jeWNsZS5sZW5ndGgtMV0pXG4gIH1cblxuICBmb3IodmFyIGk9MDsgaTxudW1WZXJ0aWNlczsgKytpKSB7XG4gICAgZm9yKHZhciBqPTA7IGo8MjsgKytqKSB7XG4gICAgICB2YXIgcGN5Y2xlID0gW11cbiAgICAgIHdoaWxlKGFkaltqXVtpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuaSA9IGFkalswXVtpXS5sZW5ndGhcbiAgICAgICAgdmFyIG5jeWNsZSA9IGV4dHJhY3RDeWNsZShpLGopXG4gICAgICAgIGlmKHNob3VsZEdsdWUocGN5Y2xlLCBuY3ljbGUpKSB7XG4gICAgICAgICAgLy9HbHVlIHRvZ2V0aGVyIHRyaXZpYWwgY3ljbGVzXG4gICAgICAgICAgcGN5Y2xlLnB1c2guYXBwbHkocGN5Y2xlLCBuY3ljbGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYocGN5Y2xlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN5Y2xlcy5wdXNoKHBjeWNsZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcGN5Y2xlID0gbmN5Y2xlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHBjeWNsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN5Y2xlcy5wdXNoKHBjeWNsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0NvbWJpbmUgcGF0aHMgYW5kIGxvb3BzIHRvZ2V0aGVyXG4gIHJldHVybiBjeWNsZXNcbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB0cmltTGVhdmVzXG5cbnZhciBlMmEgPSByZXF1aXJlKCdlZGdlcy10by1hZGphY2VuY3ktbGlzdCcpXG5cbmZ1bmN0aW9uIHRyaW1MZWF2ZXMoZWRnZXMsIHBvc2l0aW9ucykge1xuICB2YXIgYWRqID0gZTJhKGVkZ2VzLCBwb3NpdGlvbnMubGVuZ3RoKVxuICB2YXIgbGl2ZSA9IG5ldyBBcnJheShwb3NpdGlvbnMubGVuZ3RoKVxuICB2YXIgbmJoZCA9IG5ldyBBcnJheShwb3NpdGlvbnMubGVuZ3RoKVxuXG4gIHZhciBkZWFkID0gW11cbiAgZm9yKHZhciBpPTA7IGk8cG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvdW50ID0gYWRqW2ldLmxlbmd0aFxuICAgIG5iaGRbaV0gPSBjb3VudFxuICAgIGxpdmVbaV0gPSB0cnVlXG4gICAgaWYoY291bnQgPD0gMSkge1xuICAgICAgZGVhZC5wdXNoKGkpXG4gICAgfVxuICB9XG5cbiAgd2hpbGUoZGVhZC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHYgPSBkZWFkLnBvcCgpXG4gICAgbGl2ZVt2XSA9IGZhbHNlXG4gICAgdmFyIG4gPSBhZGpbdl1cbiAgICBmb3IodmFyIGk9MDsgaTxuLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdSA9IG5baV1cbiAgICAgIGlmKC0tbmJoZFt1XSA9PT0gMCkge1xuICAgICAgICBkZWFkLnB1c2godSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3SW5kZXggPSBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aClcbiAgdmFyIG5wb3NpdGlvbnMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxwb3NpdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihsaXZlW2ldKSB7XG4gICAgICB2YXIgdiA9IG5wb3NpdGlvbnMubGVuZ3RoXG4gICAgICBuZXdJbmRleFtpXSA9IHZcbiAgICAgIG5wb3NpdGlvbnMucHVzaChwb3NpdGlvbnNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0luZGV4W2ldID0gLTFcbiAgICB9XG4gIH1cblxuICB2YXIgbmVkZ2VzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgaWYobGl2ZVtlWzBdXSAmJiBsaXZlW2VbMV1dKSB7XG4gICAgICBuZWRnZXMucHVzaChbIG5ld0luZGV4W2VbMF1dLCBuZXdJbmRleFtlWzFdXSBdKVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIFsgbmVkZ2VzLCBucG9zaXRpb25zIF1cbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBwbGFuYXJHcmFwaFRvUG9seWxpbmVcblxudmFyIGUyYSA9IHJlcXVpcmUoJ2VkZ2VzLXRvLWFkamFjZW5jeS1saXN0JylcbnZhciBwbGFuYXJEdWFsID0gcmVxdWlyZSgncGxhbmFyLWR1YWwnKVxudmFyIHByZXByb2Nlc3NQb2x5Z29uID0gcmVxdWlyZSgncG9pbnQtaW4tYmlnLXBvbHlnb24nKVxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKCd0d28tcHJvZHVjdCcpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZSgncm9idXN0LXN1bScpXG52YXIgdW5pcSA9IHJlcXVpcmUoJ3VuaXEnKVxudmFyIHRyaW1MZWF2ZXMgPSByZXF1aXJlKCcuL2xpYi90cmltLWxlYXZlcycpXG5cbmZ1bmN0aW9uIG1ha2VBcnJheShsZW5ndGgsIGZpbGwpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPGxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gZmlsbFxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWFrZUFycmF5T2ZBcnJheXMobGVuZ3RoKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IFtdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cbmZ1bmN0aW9uIHBsYW5hckdyYXBoVG9Qb2x5bGluZShlZGdlcywgcG9zaXRpb25zKSB7XG5cbiAgLy9UcmltIGxlYXZlc1xuICB2YXIgcmVzdWx0ID0gdHJpbUxlYXZlcyhlZGdlcywgcG9zaXRpb25zKVxuICBlZGdlcyA9IHJlc3VsdFswXVxuICBwb3NpdGlvbnMgPSByZXN1bHRbMV1cblxuICB2YXIgbnVtVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoXG4gIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aFxuXG4gIC8vQ2FsY3VsYXRlIGFkamFjZW5jeSBsaXN0LCBjaGVjayBtYW5pZm9sZFxuICB2YXIgYWRqID0gZTJhKGVkZ2VzLCBwb3NpdGlvbnMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxudW1WZXJ0aWNlczsgKytpKSB7XG4gICAgaWYoYWRqW2ldLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGxhbmFyLWdyYXBoLXRvLXBvbHlsaW5lOiBncmFwaCBtdXN0IGJlIG1hbmlmb2xkJylcbiAgICB9XG4gIH1cblxuICAvL0dldCBmYWNlc1xuICB2YXIgZmFjZXMgPSBwbGFuYXJEdWFsKGVkZ2VzLCBwb3NpdGlvbnMpXG5cbiAgLy9DaGVjayBvcmllbnRhdGlvbiBvZiBhIHBvbHlnb24gdXNpbmcgZXhhY3QgYXJpdGhtZXRpY1xuICBmdW5jdGlvbiBjY3coYykge1xuICAgIHZhciBuID0gYy5sZW5ndGhcbiAgICB2YXIgYXJlYSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPG47ICsraikge1xuICAgICAgdmFyIGEgPSBwb3NpdGlvbnNbY1tqXV1cbiAgICAgIHZhciBiID0gcG9zaXRpb25zW2NbKGorMSklbl1dXG4gICAgICB2YXIgdDAwID0gdHdvUHJvZHVjdCgtYVswXSwgYVsxXSlcbiAgICAgIHZhciB0MDEgPSB0d29Qcm9kdWN0KC1hWzBdLCBiWzFdKVxuICAgICAgdmFyIHQxMCA9IHR3b1Byb2R1Y3QoIGJbMF0sIGFbMV0pXG4gICAgICB2YXIgdDExID0gdHdvUHJvZHVjdCggYlswXSwgYlsxXSlcbiAgICAgIGFyZWEgPSByb2J1c3RTdW0oYXJlYSwgcm9idXN0U3VtKHJvYnVzdFN1bSh0MDAsIHQwMSksIHJvYnVzdFN1bSh0MTAsIHQxMSkpKVxuICAgIH1cbiAgICByZXR1cm4gYXJlYVthcmVhLmxlbmd0aC0xXSA+IDBcbiAgfVxuXG4gIC8vRXh0cmFjdCBhbGwgY2xvY2t3aXNlIGZhY2VzXG4gIGZhY2VzID0gZmFjZXMuZmlsdGVyKGNjdylcblxuICAvL0RldGVjdCB3aGljaCBsb29wcyBhcmUgY29udGFpbmVkIGluIG9uZSBhbm90aGVyIHRvIGhhbmRsZSBwYXJlbnQtb2YgcmVsYXRpb25cbiAgdmFyIG51bUZhY2VzID0gZmFjZXMubGVuZ3RoXG4gIHZhciBwYXJlbnQgPSBuZXcgQXJyYXkobnVtRmFjZXMpXG4gIHZhciBjb250YWlubWVudCA9IG5ldyBBcnJheShudW1GYWNlcylcbiAgZm9yKHZhciBpPTA7IGk8bnVtRmFjZXM7ICsraSkge1xuICAgIHBhcmVudFtpXSA9IGlcbiAgICB2YXIgcm93ID0gbmV3IEFycmF5KG51bUZhY2VzKVxuICAgIHZhciBsb29wVmVydGljZXMgPSBmYWNlc1tpXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uc1t2XVxuICAgIH0pXG4gICAgdmFyIHBtYyA9IHByZXByb2Nlc3NQb2x5Z29uKFtsb29wVmVydGljZXNdKVxuICAgIHZhciBjb3VudCA9IDBcbiAgICBvdXRlcjpcbiAgICBmb3IodmFyIGo9MDsgajxudW1GYWNlczsgKytqKSB7XG4gICAgICByb3dbal0gPSAwXG4gICAgICBpZihpID09PSBqKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgYyA9IGZhY2VzW2pdXG4gICAgICB2YXIgbiA9IGMubGVuZ3RoXG4gICAgICBmb3IodmFyIGs9MDsgazxuOyArK2spIHtcbiAgICAgICAgdmFyIGQgPSBwbWMocG9zaXRpb25zW2Nba11dKVxuICAgICAgICBpZihkICE9PSAwKSB7XG4gICAgICAgICAgaWYoZCA8IDApIHtcbiAgICAgICAgICAgIHJvd1tqXSA9IDFcbiAgICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWUgb3V0ZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm93W2pdID0gMVxuICAgICAgY291bnQgKz0gMVxuICAgIH1cbiAgICBjb250YWlubWVudFtpXSA9IFtjb3VudCwgaSwgcm93XVxuICB9XG4gIGNvbnRhaW5tZW50LnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgcmV0dXJuIGJbMF0gLSBhWzBdXG4gIH0pXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICB2YXIgcm93ID0gY29udGFpbm1lbnRbaV1cbiAgICB2YXIgaWR4ID0gcm93WzFdXG4gICAgdmFyIGNoaWxkcmVuID0gcm93WzJdXG4gICAgZm9yKHZhciBqPTA7IGo8bnVtRmFjZXM7ICsraikge1xuICAgICAgaWYoY2hpbGRyZW5bal0pIHtcbiAgICAgICAgcGFyZW50W2pdID0gaWR4XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9Jbml0aWFsaXplIGZhY2UgYWRqYWNlbmN5IGxpc3RcbiAgdmFyIGZhZGogPSBtYWtlQXJyYXlPZkFycmF5cyhudW1GYWNlcylcbiAgZm9yKHZhciBpPTA7IGk8bnVtRmFjZXM7ICsraSkge1xuICAgIGZhZGpbaV0ucHVzaChwYXJlbnRbaV0pXG4gICAgZmFkaltwYXJlbnRbaV1dLnB1c2goaSlcbiAgfVxuXG4gIC8vQnVpbGQgYWRqYWNlbmN5IG1hdHJpeCBmb3IgZWRnZXNcbiAgdmFyIGVkZ2VBZGphY2VuY3kgPSB7fVxuICB2YXIgaW50ZXJuYWxWZXJ0aWNlcyA9IG1ha2VBcnJheShudW1WZXJ0aWNlcywgZmFsc2UpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICB2YXIgYyA9IGZhY2VzW2ldXG4gICAgdmFyIG4gPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaj0wOyBqPG47ICsraikge1xuICAgICAgdmFyIGEgPSBjW2pdXG4gICAgICB2YXIgYiA9IGNbKGorMSklbl1cbiAgICAgIHZhciBrZXkgPSBNYXRoLm1pbihhLGIpICsgXCI6XCIgKyBNYXRoLm1heChhLGIpXG4gICAgICBpZihrZXkgaW4gZWRnZUFkamFjZW5jeSkge1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBlZGdlQWRqYWNlbmN5W2tleV1cbiAgICAgICAgZmFkaltuZWlnaGJvcl0ucHVzaChpKVxuICAgICAgICBmYWRqW2ldLnB1c2gobmVpZ2hib3IpXG4gICAgICAgIGludGVybmFsVmVydGljZXNbYV0gPSBpbnRlcm5hbFZlcnRpY2VzW2JdID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZUFkamFjZW5jeVtrZXldID0gaVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZEJvdW5kYXJ5KGMpIHtcbiAgICB2YXIgbiA9IGMubGVuZ3RoXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICBpZighaW50ZXJuYWxWZXJ0aWNlc1tjW2ldXSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciB0b1Zpc2l0ID0gW11cbiAgdmFyIHBhcml0eSA9IG1ha2VBcnJheShudW1GYWNlcywgLTEpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICBpZihwYXJlbnRbaV0gPT09IGkgJiYgIXNoYXJlZEJvdW5kYXJ5KGZhY2VzW2ldKSkge1xuICAgICAgdG9WaXNpdC5wdXNoKGkpXG4gICAgICBwYXJpdHlbaV0gPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcml0eVtpXSA9IC0xXG4gICAgfVxuICB9XG5cbiAgLy9Vc2luZyBmYWNlIGFkamFjZW5jeSwgY2xhc3NpZnkgZmFjZXMgYXMgaW4vb3V0XG4gIHZhciByZXN1bHQgPSBbXVxuICB3aGlsZSh0b1Zpc2l0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdG9wID0gdG9WaXNpdC5wb3AoKVxuICAgIHZhciBuYmhkID0gZmFkalt0b3BdXG4gICAgdW5pcShuYmhkLCBmdW5jdGlvbihhLGIpIHtcbiAgICAgIHJldHVybiBhLWJcbiAgICB9KVxuICAgIHZhciBubmJociA9IG5iaGQubGVuZ3RoXG4gICAgdmFyIHAgPSBwYXJpdHlbdG9wXVxuICAgIHZhciBwb2x5bGluZVxuICAgIGlmKHAgPT09IDApIHtcbiAgICAgIHZhciBjID0gZmFjZXNbdG9wXVxuICAgICAgcG9seWxpbmUgPSBbY11cbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8bm5iaHI7ICsraSkge1xuICAgICAgdmFyIGYgPSBuYmhkW2ldXG4gICAgICBpZihwYXJpdHlbZl0gPj0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcGFyaXR5W2ZdID0gcF4xXG4gICAgICB0b1Zpc2l0LnB1c2goZilcbiAgICAgIGlmKHAgPT09IDApIHtcbiAgICAgICAgdmFyIGMgPSBmYWNlc1tmXVxuICAgICAgICBpZighc2hhcmVkQm91bmRhcnkoYykpIHtcbiAgICAgICAgICBjLnJldmVyc2UoKVxuICAgICAgICAgIHBvbHlsaW5lLnB1c2goYylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZihwID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChwb2x5bGluZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBwcmVwcm9jZXNzUG9seWdvblxuXG52YXIgb3JpZW50ID0gcmVxdWlyZSgncm9idXN0LW9yaWVudGF0aW9uJylbM11cbnZhciBtYWtlU2xhYnMgPSByZXF1aXJlKCdzbGFiLWRlY29tcG9zaXRpb24nKVxudmFyIG1ha2VJbnRlcnZhbFRyZWUgPSByZXF1aXJlKCdpbnRlcnZhbC10cmVlLTFkJylcbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxuXG5mdW5jdGlvbiB2aXNpdEludGVydmFsKCkge1xuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpbnRlcnZhbFNlYXJjaCh0YWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0cmVlID0gdGFibGVbeF1cbiAgICBpZih0cmVlKSB7XG4gICAgICByZXR1cm4gISF0cmVlLnF1ZXJ5UG9pbnQoeSwgdmlzaXRJbnRlcnZhbClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRWZXJ0aWNhbEluZGV4KHNlZ21lbnRzKSB7XG4gIHZhciB0YWJsZSA9IHt9XG4gIGZvcih2YXIgaT0wOyBpPHNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHMgPSBzZWdtZW50c1tpXVxuICAgIHZhciB4ID0gc1swXVswXVxuICAgIHZhciB5MCA9IHNbMF1bMV1cbiAgICB2YXIgeTEgPSBzWzFdWzFdXG4gICAgdmFyIHAgPSBbIE1hdGgubWluKHkwLCB5MSksIE1hdGgubWF4KHkwLCB5MSkgXVxuICAgIGlmKHggaW4gdGFibGUpIHtcbiAgICAgIHRhYmxlW3hdLnB1c2gocClcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVbeF0gPSBbIHAgXVxuICAgIH1cbiAgfVxuICB2YXIgaW50ZXJ2YWxUYWJsZSA9IHt9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFibGUpXG4gIGZvcih2YXIgaT0wOyBpPGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc2VncyA9IHRhYmxlW2tleXNbaV1dXG4gICAgaW50ZXJ2YWxUYWJsZVtrZXlzW2ldXSA9IG1ha2VJbnRlcnZhbFRyZWUoc2VncylcbiAgfVxuICByZXR1cm4gaW50ZXJ2YWxTZWFyY2goaW50ZXJ2YWxUYWJsZSlcbn1cblxuZnVuY3Rpb24gYnVpbGRTbGFiU2VhcmNoKHNsYWJzLCBjb29yZGluYXRlcykge1xuICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgIHZhciBidWNrZXQgPSBic2VhcmNoLmxlKGNvb3JkaW5hdGVzLCBwWzBdKVxuICAgIGlmKGJ1Y2tldCA8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHZhciByb290ID0gc2xhYnNbYnVja2V0XVxuICAgIGlmKCFyb290KSB7XG4gICAgICBpZihidWNrZXQgPiAwICYmIGNvb3JkaW5hdGVzW2J1Y2tldF0gPT09IHBbMF0pIHtcbiAgICAgICAgcm9vdCA9IHNsYWJzW2J1Y2tldC0xXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxhc3RPcmllbnRhdGlvbiA9IDFcbiAgICB3aGlsZShyb290KSB7XG4gICAgICB2YXIgcyA9IHJvb3Qua2V5XG4gICAgICB2YXIgbyA9IG9yaWVudChwLCBzWzBdLCBzWzFdKVxuICAgICAgaWYoc1swXVswXSA8IHNbMV1bMF0pIHtcbiAgICAgICAgaWYobyA8IDApIHtcbiAgICAgICAgICByb290ID0gcm9vdC5sZWZ0XG4gICAgICAgIH0gZWxzZSBpZihvID4gMCkge1xuICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IC0xXG4gICAgICAgICAgcm9vdCA9IHJvb3QucmlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihvID4gMCkge1xuICAgICAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICAgICAgfSBlbHNlIGlmKG8gPCAwKSB7XG4gICAgICAgICAgbGFzdE9yaWVudGF0aW9uID0gMVxuICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFzdE9yaWVudGF0aW9uXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xhc3NpZnlFbXB0eShwKSB7XG4gIHJldHVybiAxXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzaWZ5VmVydGljYWwodGVzdFZlcnRpY2FsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjbGFzc2lmeShwKSB7XG4gICAgaWYodGVzdFZlcnRpY2FsKHBbMF0sIHBbMV0pKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICByZXR1cm4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzaWZ5UG9pbnREZWdlbih0ZXN0VmVydGljYWwsIHRlc3ROb3JtYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsYXNzaWZ5KHApIHtcbiAgICBpZih0ZXN0VmVydGljYWwocFswXSwgcFsxXSkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHJldHVybiB0ZXN0Tm9ybWFsKHApXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1BvbHlnb24obG9vcHMpIHtcbiAgLy9Db21wdXRlIG51bWJlciBvZiBsb29wc1xuICB2YXIgbnVtTG9vcHMgPSBsb29wcy5sZW5ndGhcblxuICAvL1VucGFjayBzZWdtZW50c1xuICB2YXIgc2VnbWVudHMgPSBbXVxuICB2YXIgdnNlZ21lbnRzID0gW11cbiAgdmFyIHB0ciA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bnVtTG9vcHM7ICsraSkge1xuICAgIHZhciBsb29wID0gbG9vcHNbaV1cbiAgICB2YXIgbnVtVmVydGljZXMgPSBsb29wLmxlbmd0aFxuICAgIGZvcih2YXIgcz1udW1WZXJ0aWNlcy0xLHQ9MDsgdDxudW1WZXJ0aWNlczsgcz0odCsrKSkge1xuICAgICAgdmFyIGEgPSBsb29wW3NdXG4gICAgICB2YXIgYiA9IGxvb3BbdF1cbiAgICAgIGlmKGFbMF0gPT09IGJbMF0pIHtcbiAgICAgICAgdnNlZ21lbnRzLnB1c2goW2EsYl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFthLGJdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vRGVnZW5lcmF0ZSBjYXNlOiBBbGwgbG9vcHMgYXJlIGVtcHR5XG4gIGlmKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmKHZzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjbGFzc2lmeUVtcHR5XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGFzc2lmeVZlcnRpY2FsKGJ1aWxkVmVydGljYWxJbmRleCh2c2VnbWVudHMpKVxuICAgIH1cbiAgfVxuXG4gIC8vQnVpbGQgc2xhYiBkZWNvbXBvc2l0aW9uXG4gIHZhciBzbGFicyA9IG1ha2VTbGFicyhzZWdtZW50cylcbiAgdmFyIHRlc3RTbGFiID0gYnVpbGRTbGFiU2VhcmNoKHNsYWJzLnNsYWJzLCBzbGFicy5jb29yZGluYXRlcylcblxuICBpZih2c2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRlc3RTbGFiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsYXNzaWZ5UG9pbnREZWdlbihcbiAgICAgIGJ1aWxkVmVydGljYWxJbmRleCh2c2VnbWVudHMpLFxuICAgICAgdGVzdFNsYWIpXG4gIH1cbn0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIG5vdyA9IHJlcXVpcmUoJ3JpZ2h0LW5vdycpXG52YXIgcmFmID0gcmVxdWlyZSgncmFmJylcblxubW9kdWxlLmV4cG9ydHMgPSBFbmdpbmVcbmZ1bmN0aW9uIEVuZ2luZShmbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbmdpbmUpKSBcbiAgICAgICAgcmV0dXJuIG5ldyBFbmdpbmUoZm4pXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLmxhc3QgPSBub3coKVxuICAgIHRoaXMuX2ZyYW1lID0gMFxuICAgIHRoaXMuX3RpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKVxuXG4gICAgaWYgKGZuKVxuICAgICAgICB0aGlzLm9uKCd0aWNrJywgZm4pXG59XG5cbmluaGVyaXRzKEVuZ2luZSwgRXZlbnRFbWl0dGVyKVxuXG5FbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucnVubmluZykgXG4gICAgICAgIHJldHVyblxuICAgIHRoaXMucnVubmluZyA9IHRydWVcbiAgICB0aGlzLmxhc3QgPSBub3coKVxuICAgIHRoaXMuX2ZyYW1lID0gcmFmKHRoaXMuX3RpY2spXG4gICAgcmV0dXJuIHRoaXNcbn1cblxuRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2VcbiAgICBpZiAodGhpcy5fZnJhbWUgIT09IDApXG4gICAgICAgIHJhZi5jYW5jZWwodGhpcy5fZnJhbWUpXG4gICAgdGhpcy5fZnJhbWUgPSAwXG4gICAgcmV0dXJuIHRoaXNcbn1cblxuRW5naW5lLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZnJhbWUgPSByYWYodGhpcy5fdGljaylcbiAgICB2YXIgdGltZSA9IG5vdygpXG4gICAgdmFyIGR0ID0gdGltZSAtIHRoaXMubGFzdFxuICAgIHRoaXMuZW1pdCgndGljaycsIGR0KVxuICAgIHRoaXMubGFzdCA9IHRpbWVcbn0iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgb2JqZWN0ID0gcm9vdDtcbiAgfVxuICBvYmplY3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIG9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibmFkZCA9IHJlcXVpcmUoJ2JpZy1yYXQvYWRkJylcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRcblxuZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgZm9yICh2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJbaV0gPSBibmFkZChhW2ldLCBiW2ldKVxuICB9XG4gIHJldHVybiByXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmbG9hdDJyYXRcblxudmFyIHJhdCA9IHJlcXVpcmUoJ2JpZy1yYXQnKVxuXG5mdW5jdGlvbiBmbG9hdDJyYXQodikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHYubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTx2Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gcmF0KHZbaV0pXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXQgPSByZXF1aXJlKCdiaWctcmF0JylcbnZhciBtdWwgPSByZXF1aXJlKCdiaWctcmF0L211bCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbXVsc1xuXG5mdW5jdGlvbiBtdWxzKGEsIHgpIHtcbiAgdmFyIHMgPSByYXQoeClcbiAgdmFyIG4gPSBhLmxlbmd0aFxuICB2YXIgciA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByW2ldID0gbXVsKGFbaV0sIHMpXG4gIH1cbiAgcmV0dXJuIHJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5zdWIgPSByZXF1aXJlKCdiaWctcmF0L3N1YicpXG5cbm1vZHVsZS5leHBvcnRzID0gc3ViXG5cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByW2ldID0gYm5zdWIoYVtpXSwgYltpXSlcbiAgfVxuICByZXR1cm4gclxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLmNyZWF0ZVJFR0wgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gKFxuICAgIHggaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICApXG59XG5cbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoYmFzZSwgb3B0cykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdHMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGJhc2Vba2V5c1tpXV0gPSBvcHRzW2tleXNbaV1dXG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn1cblxuLy8gRXJyb3IgY2hlY2tpbmcgYW5kIHBhcmFtZXRlciB2YWxpZGF0aW9uLlxuLy9cbi8vIFN0YXRlbWVudHMgZm9yIHRoZSBmb3JtIGBjaGVjay5zb21lUHJvY2VkdXJlKC4uLilgIGdldCByZW1vdmVkIGJ5XG4vLyBhIGJyb3dzZXJpZnkgdHJhbnNmb3JtIGZvciBvcHRpbWl6ZWQvbWluaWZpZWQgYnVuZGxlcy5cbi8vXG4vKiBnbG9iYWxzIGF0b2IgKi9cbnZhciBlbmRsID0gJ1xcbidcblxuLy8gb25seSB1c2VkIGZvciBleHRyYWN0aW5nIHNoYWRlciBuYW1lcy4gIGlmIGF0b2Igbm90IHByZXNlbnQsIHRoZW4gZXJyb3JzXG4vLyB3aWxsIGJlIHNsaWdodGx5IGNyYXBwaWVyXG5mdW5jdGlvbiBkZWNvZGVCNjQgKHN0cikge1xuICBpZiAodHlwZW9mIGF0b2IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGF0b2Ioc3RyKVxuICB9XG4gIHJldHVybiAnYmFzZTY0OicgKyBzdHJcbn1cblxuZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCcocmVnbCkgJyArIG1lc3NhZ2UpXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gIHRocm93IGVycm9yXG59XG5cbmZ1bmN0aW9uIGNoZWNrIChwcmVkLCBtZXNzYWdlKSB7XG4gIGlmICghcHJlZCkge1xuICAgIHJhaXNlKG1lc3NhZ2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2xvbiAobWVzc2FnZSkge1xuICBpZiAobWVzc2FnZSkge1xuICAgIHJldHVybiAnOiAnICsgbWVzc2FnZVxuICB9XG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlciAocGFyYW0sIHBvc3NpYmlsaXRpZXMsIG1lc3NhZ2UpIHtcbiAgaWYgKCEocGFyYW0gaW4gcG9zc2liaWxpdGllcykpIHtcbiAgICByYWlzZSgndW5rbm93biBwYXJhbWV0ZXIgKCcgKyBwYXJhbSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgICAgICcuIHBvc3NpYmxlIHZhbHVlczogJyArIE9iamVjdC5rZXlzKHBvc3NpYmlsaXRpZXMpLmpvaW4oKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0lzVHlwZWRBcnJheSAoZGF0YSwgbWVzc2FnZSkge1xuICBpZiAoIWlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgIHJhaXNlKFxuICAgICAgJ2ludmFsaWQgcGFyYW1ldGVyIHR5cGUnICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgICAnLiBtdXN0IGJlIGEgdHlwZWQgYXJyYXknKVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YW5kYXJkVHlwZUVoICh2YWx1ZSwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgY2FzZSAnZnVuY3Rpb24nOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG4gICAgY2FzZSAndW5kZWZpbmVkJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICBjYXNlICdzeW1ib2wnOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZU9mICh2YWx1ZSwgdHlwZSwgbWVzc2FnZSkge1xuICBpZiAoIXN0YW5kYXJkVHlwZUVoKHZhbHVlLCB0eXBlKSkge1xuICAgIHJhaXNlKFxuICAgICAgJ2ludmFsaWQgcGFyYW1ldGVyIHR5cGUnICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgICAnLiBleHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgKHR5cGVvZiB2YWx1ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb25OZWdhdGl2ZUludCAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCEoKHZhbHVlID49IDApICYmXG4gICAgICAgICgodmFsdWUgfCAwKSA9PT0gdmFsdWUpKSkge1xuICAgIHJhaXNlKCdpbnZhbGlkIHBhcmFtZXRlciB0eXBlLCAoJyArIHZhbHVlICsgJyknICsgZW5jb2xvbihtZXNzYWdlKSArXG4gICAgICAgICAgJy4gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT25lT2YgKHZhbHVlLCBsaXN0LCBtZXNzYWdlKSB7XG4gIGlmIChsaXN0LmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgIHJhaXNlKCdpbnZhbGlkIHZhbHVlJyArIGVuY29sb24obWVzc2FnZSkgKyAnLiBtdXN0IGJlIG9uZSBvZjogJyArIGxpc3QpXG4gIH1cbn1cblxudmFyIGNvbnN0cnVjdG9yS2V5cyA9IFtcbiAgJ2dsJyxcbiAgJ2NhbnZhcycsXG4gICdjb250YWluZXInLFxuICAnYXR0cmlidXRlcycsXG4gICdwaXhlbFJhdGlvJyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnb3B0aW9uYWxFeHRlbnNpb25zJyxcbiAgJ3Byb2ZpbGUnLFxuICAnb25Eb25lJ1xuXVxuXG5mdW5jdGlvbiBjaGVja0NvbnN0cnVjdG9yIChvYmopIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoY29uc3RydWN0b3JLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgIHJhaXNlKCdpbnZhbGlkIHJlZ2wgY29uc3RydWN0b3IgYXJndW1lbnQgXCInICsga2V5ICsgJ1wiLiBtdXN0IGJlIG9uZSBvZiAnICsgY29uc3RydWN0b3JLZXlzKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbGVmdFBhZCAoc3RyLCBuKSB7XG4gIHN0ciA9IHN0ciArICcnXG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgbikge1xuICAgIHN0ciA9ICcgJyArIHN0clxuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gU2hhZGVyRmlsZSAoKSB7XG4gIHRoaXMubmFtZSA9ICd1bmtub3duJ1xuICB0aGlzLmxpbmVzID0gW11cbiAgdGhpcy5pbmRleCA9IHt9XG4gIHRoaXMuaGFzRXJyb3JzID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gU2hhZGVyTGluZSAobnVtYmVyLCBsaW5lKSB7XG4gIHRoaXMubnVtYmVyID0gbnVtYmVyXG4gIHRoaXMubGluZSA9IGxpbmVcbiAgdGhpcy5lcnJvcnMgPSBbXVxufVxuXG5mdW5jdGlvbiBTaGFkZXJFcnJvciAoZmlsZU51bWJlciwgbGluZU51bWJlciwgbWVzc2FnZSkge1xuICB0aGlzLmZpbGUgPSBmaWxlTnVtYmVyXG4gIHRoaXMubGluZSA9IGxpbmVOdW1iZXJcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBndWVzc0NvbW1hbmQgKCkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKVxuICB2YXIgc3RhY2sgPSAoZXJyb3Iuc3RhY2sgfHwgZXJyb3IpLnRvU3RyaW5nKClcbiAgdmFyIHBhdCA9IC9jb21waWxlUHJvY2VkdXJlLipcXG5cXHMqYXQuKlxcKCguKilcXCkvLmV4ZWMoc3RhY2spXG4gIGlmIChwYXQpIHtcbiAgICByZXR1cm4gcGF0WzFdXG4gIH1cbiAgdmFyIHBhdDIgPSAvY29tcGlsZVByb2NlZHVyZS4qXFxuXFxzKmF0XFxzKyguKikoXFxufCQpLy5leGVjKHN0YWNrKVxuICBpZiAocGF0Mikge1xuICAgIHJldHVybiBwYXQyWzFdXG4gIH1cbiAgcmV0dXJuICd1bmtub3duJ1xufVxuXG5mdW5jdGlvbiBndWVzc0NhbGxTaXRlICgpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKClcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpXG4gIHZhciBwYXQgPSAvYXQgUkVHTENvbW1hbmQuKlxcblxccythdC4qXFwoKC4qKVxcKS8uZXhlYyhzdGFjaylcbiAgaWYgKHBhdCkge1xuICAgIHJldHVybiBwYXRbMV1cbiAgfVxuICB2YXIgcGF0MiA9IC9hdCBSRUdMQ29tbWFuZC4qXFxuXFxzK2F0XFxzKyguKilcXG4vLmV4ZWMoc3RhY2spXG4gIGlmIChwYXQyKSB7XG4gICAgcmV0dXJuIHBhdDJbMV1cbiAgfVxuICByZXR1cm4gJ3Vua25vd24nXG59XG5cbmZ1bmN0aW9uIHBhcnNlU291cmNlIChzb3VyY2UsIGNvbW1hbmQpIHtcbiAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKVxuICB2YXIgbGluZU51bWJlciA9IDFcbiAgdmFyIGZpbGVOdW1iZXIgPSAwXG4gIHZhciBmaWxlcyA9IHtcbiAgICB1bmtub3duOiBuZXcgU2hhZGVyRmlsZSgpLFxuICAgIDA6IG5ldyBTaGFkZXJGaWxlKClcbiAgfVxuICBmaWxlcy51bmtub3duLm5hbWUgPSBmaWxlc1swXS5uYW1lID0gY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKVxuICBmaWxlcy51bmtub3duLmxpbmVzLnB1c2gobmV3IFNoYWRlckxpbmUoMCwgJycpKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXVxuICAgIHZhciBwYXJ0cyA9IC9eXFxzKiNcXHMqKFxcdyspXFxzKyguKylcXHMqJC8uZXhlYyhsaW5lKVxuICAgIGlmIChwYXJ0cykge1xuICAgICAgc3dpdGNoIChwYXJ0c1sxXSkge1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YXIgbGluZU51bWJlckluZm8gPSAvKFxcZCspKFxccytcXGQrKT8vLmV4ZWMocGFydHNbMl0pXG4gICAgICAgICAgaWYgKGxpbmVOdW1iZXJJbmZvKSB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gbGluZU51bWJlckluZm9bMV0gfCAwXG4gICAgICAgICAgICBpZiAobGluZU51bWJlckluZm9bMl0pIHtcbiAgICAgICAgICAgICAgZmlsZU51bWJlciA9IGxpbmVOdW1iZXJJbmZvWzJdIHwgMFxuICAgICAgICAgICAgICBpZiAoIShmaWxlTnVtYmVyIGluIGZpbGVzKSkge1xuICAgICAgICAgICAgICAgIGZpbGVzW2ZpbGVOdW1iZXJdID0gbmV3IFNoYWRlckZpbGUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2RlZmluZSc6XG4gICAgICAgICAgdmFyIG5hbWVJbmZvID0gL1NIQURFUl9OQU1FKF9CNjQpP1xccysoLiopJC8uZXhlYyhwYXJ0c1syXSlcbiAgICAgICAgICBpZiAobmFtZUluZm8pIHtcbiAgICAgICAgICAgIGZpbGVzW2ZpbGVOdW1iZXJdLm5hbWUgPSAobmFtZUluZm9bMV1cbiAgICAgICAgICAgICAgPyBkZWNvZGVCNjQobmFtZUluZm9bMl0pXG4gICAgICAgICAgICAgIDogbmFtZUluZm9bMl0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGZpbGVzW2ZpbGVOdW1iZXJdLmxpbmVzLnB1c2gobmV3IFNoYWRlckxpbmUobGluZU51bWJlcisrLCBsaW5lKSlcbiAgfVxuICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZU51bWJlcikge1xuICAgIHZhciBmaWxlID0gZmlsZXNbZmlsZU51bWJlcl1cbiAgICBmaWxlLmxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGZpbGUuaW5kZXhbbGluZS5udW1iZXJdID0gbGluZVxuICAgIH0pXG4gIH0pXG4gIHJldHVybiBmaWxlc1xufVxuXG5mdW5jdGlvbiBwYXJzZUVycm9yTG9nIChlcnJMb2cpIHtcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGVyckxvZy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAoZXJyTXNnKSB7XG4gICAgaWYgKGVyck1zZy5sZW5ndGggPCA1KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHBhcnRzID0gL15FUlJPUjpcXHMrKFxcZCspOihcXGQrKTpcXHMqKC4qKSQvLmV4ZWMoZXJyTXNnKVxuICAgIGlmIChwYXJ0cykge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IFNoYWRlckVycm9yKFxuICAgICAgICBwYXJ0c1sxXSB8IDAsXG4gICAgICAgIHBhcnRzWzJdIHwgMCxcbiAgICAgICAgcGFydHNbM10udHJpbSgpKSlcbiAgICB9IGVsc2UgaWYgKGVyck1zZy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChuZXcgU2hhZGVyRXJyb3IoJ3Vua25vd24nLCAwLCBlcnJNc2cpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBhbm5vdGF0ZUZpbGVzIChmaWxlcywgZXJyb3JzKSB7XG4gIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBmaWxlID0gZmlsZXNbZXJyb3IuZmlsZV1cbiAgICBpZiAoZmlsZSkge1xuICAgICAgdmFyIGxpbmUgPSBmaWxlLmluZGV4W2Vycm9yLmxpbmVdXG4gICAgICBpZiAobGluZSkge1xuICAgICAgICBsaW5lLmVycm9ycy5wdXNoKGVycm9yKVxuICAgICAgICBmaWxlLmhhc0Vycm9ycyA9IHRydWVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGZpbGVzLnVua25vd24uaGFzRXJyb3JzID0gdHJ1ZVxuICAgIGZpbGVzLnVua25vd24ubGluZXNbMF0uZXJyb3JzLnB1c2goZXJyb3IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrU2hhZGVyRXJyb3IgKGdsLCBzaGFkZXIsIHNvdXJjZSwgdHlwZSwgY29tbWFuZCkge1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICB2YXIgdHlwZU5hbWUgPSB0eXBlID09PSBnbC5GUkFHTUVOVF9TSEFERVIgPyAnZnJhZ21lbnQnIDogJ3ZlcnRleCdcbiAgICBjaGVja0NvbW1hbmRUeXBlKHNvdXJjZSwgJ3N0cmluZycsIHR5cGVOYW1lICsgJyBzaGFkZXIgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnLCBjb21tYW5kKVxuICAgIHZhciBmaWxlcyA9IHBhcnNlU291cmNlKHNvdXJjZSwgY29tbWFuZClcbiAgICB2YXIgZXJyb3JzID0gcGFyc2VFcnJvckxvZyhlcnJMb2cpXG4gICAgYW5ub3RhdGVGaWxlcyhmaWxlcywgZXJyb3JzKVxuXG4gICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOdW1iZXIpIHtcbiAgICAgIHZhciBmaWxlID0gZmlsZXNbZmlsZU51bWJlcl1cbiAgICAgIGlmICghZmlsZS5oYXNFcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJpbmdzID0gWycnXVxuICAgICAgdmFyIHN0eWxlcyA9IFsnJ11cblxuICAgICAgZnVuY3Rpb24gcHVzaCAoc3RyLCBzdHlsZSkge1xuICAgICAgICBzdHJpbmdzLnB1c2goc3RyKVxuICAgICAgICBzdHlsZXMucHVzaChzdHlsZSB8fCAnJylcbiAgICAgIH1cblxuICAgICAgcHVzaCgnZmlsZSBudW1iZXIgJyArIGZpbGVOdW1iZXIgKyAnOiAnICsgZmlsZS5uYW1lICsgJ1xcbicsICdjb2xvcjpyZWQ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtmb250LXdlaWdodDpib2xkJylcblxuICAgICAgZmlsZS5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcHVzaChsZWZ0UGFkKGxpbmUubnVtYmVyLCA0KSArICd8ICAnLCAnYmFja2dyb3VuZC1jb2xvcjp5ZWxsb3c7IGZvbnQtd2VpZ2h0OmJvbGQnKVxuICAgICAgICAgIHB1c2gobGluZS5saW5lICsgZW5kbCwgJ2NvbG9yOnJlZDsgYmFja2dyb3VuZC1jb2xvcjp5ZWxsb3c7IGZvbnQtd2VpZ2h0OmJvbGQnKVxuXG4gICAgICAgICAgLy8gdHJ5IHRvIGd1ZXNzIHRva2VuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDBcbiAgICAgICAgICBsaW5lLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSAvXlxccyonKC4qKSdcXHMqOlxccyooLiopJC8uZXhlYyhtZXNzYWdlKVxuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlblBhdCA9IHRva2VuWzFdXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSB0b2tlblsyXVxuICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuUGF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXNzaWduJzpcbiAgICAgICAgICAgICAgICAgIHRva2VuUGF0ID0gJz0nXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmUubGluZS5pbmRleE9mKHRva2VuUGF0LCBvZmZzZXQpLCAwKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdXNoKGxlZnRQYWQoJ3wgJywgNikpXG4gICAgICAgICAgICBwdXNoKGxlZnRQYWQoJ15eXicsIG9mZnNldCArIDMpICsgZW5kbCwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKVxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpKVxuICAgICAgICAgICAgcHVzaChtZXNzYWdlICsgZW5kbCwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpICsgZW5kbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoKGxlZnRQYWQobGluZS5udW1iZXIsIDQpICsgJ3wgICcpXG4gICAgICAgICAgcHVzaChsaW5lLmxpbmUgKyBlbmRsLCAnY29sb3I6cmVkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuY2hyb21lKSB7XG4gICAgICAgIHN0eWxlc1swXSA9IHN0cmluZ3Muam9pbignJWMnKVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBzdHlsZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhzdHJpbmdzLmpvaW4oJycpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjaGVjay5yYWlzZSgnRXJyb3IgY29tcGlsaW5nICcgKyB0eXBlTmFtZSArICcgc2hhZGVyLCAnICsgZmlsZXNbMF0ubmFtZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0xpbmtFcnJvciAoZ2wsIHByb2dyYW0sIGZyYWdTaGFkZXIsIHZlcnRTaGFkZXIsIGNvbW1hbmQpIHtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxuICAgIHZhciBmcmFnUGFyc2UgPSBwYXJzZVNvdXJjZShmcmFnU2hhZGVyLCBjb21tYW5kKVxuICAgIHZhciB2ZXJ0UGFyc2UgPSBwYXJzZVNvdXJjZSh2ZXJ0U2hhZGVyLCBjb21tYW5kKVxuXG4gICAgdmFyIGhlYWRlciA9ICdFcnJvciBsaW5raW5nIHByb2dyYW0gd2l0aCB2ZXJ0ZXggc2hhZGVyLCBcIicgK1xuICAgICAgdmVydFBhcnNlWzBdLm5hbWUgKyAnXCIsIGFuZCBmcmFnbWVudCBzaGFkZXIgXCInICsgZnJhZ1BhcnNlWzBdLm5hbWUgKyAnXCInXG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coJyVjJyArIGhlYWRlciArIGVuZGwgKyAnJWMnICsgZXJyTG9nLFxuICAgICAgICAnY29sb3I6cmVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Zm9udC13ZWlnaHQ6Ym9sZCcsXG4gICAgICAgICdjb2xvcjpyZWQnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhoZWFkZXIgKyBlbmRsICsgZXJyTG9nKVxuICAgIH1cbiAgICBjaGVjay5yYWlzZShoZWFkZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZUNvbW1hbmRSZWYgKG9iamVjdCkge1xuICBvYmplY3QuX2NvbW1hbmRSZWYgPSBndWVzc0NvbW1hbmQoKVxufVxuXG5mdW5jdGlvbiBzYXZlRHJhd0NvbW1hbmRJbmZvIChvcHRzLCB1bmlmb3JtcywgYXR0cmlidXRlcywgc3RyaW5nU3RvcmUpIHtcbiAgc2F2ZUNvbW1hbmRSZWYob3B0cylcblxuICBmdW5jdGlvbiBpZCAoc3RyKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgcmV0dXJuIHN0cmluZ1N0b3JlLmlkKHN0cilcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuICBvcHRzLl9mcmFnSWQgPSBpZChvcHRzLnN0YXRpYy5mcmFnKVxuICBvcHRzLl92ZXJ0SWQgPSBpZChvcHRzLnN0YXRpYy52ZXJ0KVxuXG4gIGZ1bmN0aW9uIGFkZFByb3BzIChkaWN0LCBzZXQpIHtcbiAgICBPYmplY3Qua2V5cyhzZXQpLmZvckVhY2goZnVuY3Rpb24gKHUpIHtcbiAgICAgIGRpY3Rbc3RyaW5nU3RvcmUuaWQodSldID0gdHJ1ZVxuICAgIH0pXG4gIH1cblxuICB2YXIgdW5pZm9ybVNldCA9IG9wdHMuX3VuaWZvcm1TZXQgPSB7fVxuICBhZGRQcm9wcyh1bmlmb3JtU2V0LCB1bmlmb3Jtcy5zdGF0aWMpXG4gIGFkZFByb3BzKHVuaWZvcm1TZXQsIHVuaWZvcm1zLmR5bmFtaWMpXG5cbiAgdmFyIGF0dHJpYnV0ZVNldCA9IG9wdHMuX2F0dHJpYnV0ZVNldCA9IHt9XG4gIGFkZFByb3BzKGF0dHJpYnV0ZVNldCwgYXR0cmlidXRlcy5zdGF0aWMpXG4gIGFkZFByb3BzKGF0dHJpYnV0ZVNldCwgYXR0cmlidXRlcy5keW5hbWljKVxuXG4gIG9wdHMuX2hhc0NvdW50ID0gKFxuICAgICdjb3VudCcgaW4gb3B0cy5zdGF0aWMgfHxcbiAgICAnY291bnQnIGluIG9wdHMuZHluYW1pYyB8fFxuICAgICdlbGVtZW50cycgaW4gb3B0cy5zdGF0aWMgfHxcbiAgICAnZWxlbWVudHMnIGluIG9wdHMuZHluYW1pYylcbn1cblxuZnVuY3Rpb24gY29tbWFuZFJhaXNlIChtZXNzYWdlLCBjb21tYW5kKSB7XG4gIHZhciBjYWxsU2l0ZSA9IGd1ZXNzQ2FsbFNpdGUoKVxuICByYWlzZShtZXNzYWdlICtcbiAgICAnIGluIGNvbW1hbmQgJyArIChjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpKSArXG4gICAgKGNhbGxTaXRlID09PSAndW5rbm93bicgPyAnJyA6ICcgY2FsbGVkIGZyb20gJyArIGNhbGxTaXRlKSlcbn1cblxuZnVuY3Rpb24gY2hlY2tDb21tYW5kIChwcmVkLCBtZXNzYWdlLCBjb21tYW5kKSB7XG4gIGlmICghcHJlZCkge1xuICAgIGNvbW1hbmRSYWlzZShtZXNzYWdlLCBjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyYW1ldGVyQ29tbWFuZCAocGFyYW0sIHBvc3NpYmlsaXRpZXMsIG1lc3NhZ2UsIGNvbW1hbmQpIHtcbiAgaWYgKCEocGFyYW0gaW4gcG9zc2liaWxpdGllcykpIHtcbiAgICBjb21tYW5kUmFpc2UoXG4gICAgICAndW5rbm93biBwYXJhbWV0ZXIgKCcgKyBwYXJhbSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gcG9zc2libGUgdmFsdWVzOiAnICsgT2JqZWN0LmtleXMocG9zc2liaWxpdGllcykuam9pbigpLFxuICAgICAgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0NvbW1hbmRUeXBlICh2YWx1ZSwgdHlwZSwgbWVzc2FnZSwgY29tbWFuZCkge1xuICBpZiAoIXN0YW5kYXJkVHlwZUVoKHZhbHVlLCB0eXBlKSkge1xuICAgIGNvbW1hbmRSYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpLFxuICAgICAgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvbmFsIChibG9jaykge1xuICBibG9jaygpXG59XG5cbmZ1bmN0aW9uIGNoZWNrRnJhbWVidWZmZXJGb3JtYXQgKGF0dGFjaG1lbnQsIHRleEZvcm1hdHMsIHJiRm9ybWF0cykge1xuICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgY2hlY2tPbmVPZihcbiAgICAgIGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgIHRleEZvcm1hdHMsXG4gICAgICAndW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQgZm9yIGF0dGFjaG1lbnQnKVxuICB9IGVsc2Uge1xuICAgIGNoZWNrT25lT2YoXG4gICAgICBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCxcbiAgICAgIHJiRm9ybWF0cyxcbiAgICAgICd1bnN1cHBvcnRlZCByZW5kZXJidWZmZXIgZm9ybWF0IGZvciBhdHRhY2htZW50JylcbiAgfVxufVxuXG52YXIgR0xfQ0xBTVBfVE9fRURHRSA9IDB4ODEyRlxuXG52YXIgR0xfTkVBUkVTVCA9IDB4MjYwMFxudmFyIEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QgPSAweDI3MDBcbnZhciBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QgPSAweDI3MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIgPSAweDI3MDJcbnZhciBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUiA9IDB4MjcwM1xuXG52YXIgR0xfQllURSA9IDUxMjBcbnZhciBHTF9VTlNJR05FRF9CWVRFID0gNTEyMVxudmFyIEdMX1NIT1JUID0gNTEyMlxudmFyIEdMX1VOU0lHTkVEX1NIT1JUID0gNTEyM1xudmFyIEdMX0lOVCA9IDUxMjRcbnZhciBHTF9VTlNJR05FRF9JTlQgPSA1MTI1XG52YXIgR0xfRkxPQVQgPSA1MTI2XG5cbnZhciBHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80ID0gMHg4MDMzXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDB4ODAzNFxudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81ID0gMHg4MzYzXG52YXIgR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wgPSAweDg0RkFcblxudmFyIEdMX0hBTEZfRkxPQVRfT0VTID0gMHg4RDYxXG5cbnZhciBUWVBFX1NJWkUgPSB7fVxuXG5UWVBFX1NJWkVbR0xfQllURV0gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX0JZVEVdID0gMVxuXG5UWVBFX1NJWkVbR0xfU0hPUlRdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9TSE9SVF0gPVxuVFlQRV9TSVpFW0dMX0hBTEZfRkxPQVRfT0VTXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNV82XzVdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80XSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMV0gPSAyXG5cblRZUEVfU0laRVtHTF9JTlRdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9JTlRdID1cblRZUEVfU0laRVtHTF9GTE9BVF0gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMXSA9IDRcblxuZnVuY3Rpb24gcGl4ZWxTaXplICh0eXBlLCBjaGFubmVscykge1xuICBpZiAodHlwZSA9PT0gR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSB8fFxuICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCB8fFxuICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfU0hPUlRfNV82XzUpIHtcbiAgICByZXR1cm4gMlxuICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMKSB7XG4gICAgcmV0dXJuIDRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gVFlQRV9TSVpFW3R5cGVdICogY2hhbm5lbHNcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BvdzIgKHYpIHtcbiAgcmV0dXJuICEodiAmICh2IC0gMSkpICYmICghIXYpXG59XG5cbmZ1bmN0aW9uIGNoZWNrVGV4dHVyZTJEIChpbmZvLCBtaXBEYXRhLCBsaW1pdHMpIHtcbiAgdmFyIGlcbiAgdmFyIHcgPSBtaXBEYXRhLndpZHRoXG4gIHZhciBoID0gbWlwRGF0YS5oZWlnaHRcbiAgdmFyIGMgPSBtaXBEYXRhLmNoYW5uZWxzXG5cbiAgLy8gQ2hlY2sgdGV4dHVyZSBzaGFwZVxuICBjaGVjayh3ID4gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgICBoID4gMCAmJiBoIDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSxcbiAgJ2ludmFsaWQgdGV4dHVyZSBzaGFwZScpXG5cbiAgLy8gY2hlY2sgd3JhcCBtb2RlXG4gIGlmIChpbmZvLndyYXBTICE9PSBHTF9DTEFNUF9UT19FREdFIHx8IGluZm8ud3JhcFQgIT09IEdMX0NMQU1QX1RPX0VER0UpIHtcbiAgICBjaGVjayhpc1BvdzIodykgJiYgaXNQb3cyKGgpLFxuICAgICAgJ2luY29tcGF0aWJsZSB3cmFwIG1vZGUgZm9yIHRleHR1cmUsIGJvdGggd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIHBvd2VyIG9mIDInKVxuICB9XG5cbiAgaWYgKG1pcERhdGEubWlwbWFzayA9PT0gMSkge1xuICAgIGlmICh3ICE9PSAxICYmIGggIT09IDEpIHtcbiAgICAgIGNoZWNrKFxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCAmJlxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSICYmXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QgJiZcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX0xJTkVBUl9NSVBNQVBfTElORUFSLFxuICAgICAgICAnbWluIGZpbHRlciByZXF1aXJlcyBtaXBtYXAnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0ZXh0dXJlIG11c3QgYmUgcG93ZXIgb2YgMlxuICAgIGNoZWNrKGlzUG93Mih3KSAmJiBpc1BvdzIoaCksXG4gICAgICAndGV4dHVyZSBtdXN0IGJlIGEgc3F1YXJlIHBvd2VyIG9mIDIgdG8gc3VwcG9ydCBtaXBtYXBwaW5nJylcbiAgICBjaGVjayhtaXBEYXRhLm1pcG1hc2sgPT09ICh3IDw8IDEpIC0gMSxcbiAgICAgICdtaXNzaW5nIG9yIGluY29tcGxldGUgbWlwbWFwIGRhdGEnKVxuICB9XG5cbiAgaWYgKG1pcERhdGEudHlwZSA9PT0gR0xfRkxPQVQpIHtcbiAgICBpZiAobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfZmxvYXRfbGluZWFyJykgPCAwKSB7XG4gICAgICBjaGVjayhpbmZvLm1pbkZpbHRlciA9PT0gR0xfTkVBUkVTVCAmJiBpbmZvLm1hZ0ZpbHRlciA9PT0gR0xfTkVBUkVTVCxcbiAgICAgICAgJ2ZpbHRlciBub3Qgc3VwcG9ydGVkLCBtdXN0IGVuYWJsZSBvZXNfdGV4dHVyZV9mbG9hdF9saW5lYXInKVxuICAgIH1cbiAgICBjaGVjayghaW5mby5nZW5NaXBtYXBzLFxuICAgICAgJ21pcG1hcCBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgd2l0aCBmbG9hdCB0ZXh0dXJlcycpXG4gIH1cblxuICAvLyBjaGVjayBpbWFnZSBjb21wbGV0ZVxuICB2YXIgbWlwaW1hZ2VzID0gbWlwRGF0YS5pbWFnZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBpZiAobWlwaW1hZ2VzW2ldKSB7XG4gICAgICB2YXIgbXcgPSB3ID4+IGlcbiAgICAgIHZhciBtaCA9IGggPj4gaVxuICAgICAgY2hlY2sobWlwRGF0YS5taXBtYXNrICYgKDEgPDwgaSksICdtaXNzaW5nIG1pcG1hcCBkYXRhJylcblxuICAgICAgdmFyIGltZyA9IG1pcGltYWdlc1tpXVxuXG4gICAgICBjaGVjayhcbiAgICAgICAgaW1nLndpZHRoID09PSBtdyAmJlxuICAgICAgICBpbWcuaGVpZ2h0ID09PSBtaCxcbiAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIG1pcCBpbWFnZXMnKVxuXG4gICAgICBjaGVjayhcbiAgICAgICAgaW1nLmZvcm1hdCA9PT0gbWlwRGF0YS5mb3JtYXQgJiZcbiAgICAgICAgaW1nLmludGVybmFsZm9ybWF0ID09PSBtaXBEYXRhLmludGVybmFsZm9ybWF0ICYmXG4gICAgICAgIGltZy50eXBlID09PSBtaXBEYXRhLnR5cGUsXG4gICAgICAgICdpbmNvbXBhdGlibGUgdHlwZSBmb3IgbWlwIGltYWdlJylcblxuICAgICAgaWYgKGltZy5jb21wcmVzc2VkKSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIHNpemUgZm9yIGNvbXByZXNzZWQgaW1hZ2VzXG4gICAgICB9IGVsc2UgaWYgKGltZy5kYXRhKSB7XG4gICAgICAgIC8vIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IG13ICogbWggKlxuICAgICAgICAvLyBNYXRoLm1heChwaXhlbFNpemUoaW1nLnR5cGUsIGMpLCBpbWcudW5wYWNrQWxpZ25tZW50KSxcbiAgICAgICAgdmFyIHJvd1NpemUgPSBNYXRoLmNlaWwocGl4ZWxTaXplKGltZy50eXBlLCBjKSAqIG13IC8gaW1nLnVucGFja0FsaWdubWVudCkgKiBpbWcudW5wYWNrQWxpZ25tZW50XG4gICAgICAgIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IHJvd1NpemUgKiBtaCxcbiAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBpbWFnZSwgYnVmZmVyIHNpemUgaXMgaW5jb25zaXN0ZW50IHdpdGggaW1hZ2UgZm9ybWF0JylcbiAgICAgIH0gZWxzZSBpZiAoaW1nLmVsZW1lbnQpIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZWxlbWVudCBjYW4gYmUgbG9hZGVkXG4gICAgICB9IGVsc2UgaWYgKGltZy5jb3B5KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGNvbXBhdGlibGUgZm9ybWF0IGFuZCB0eXBlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICBjaGVjaygobWlwRGF0YS5taXBtYXNrICYgKDEgPDwgaSkpID09PSAwLCAnZXh0cmEgbWlwbWFwIGRhdGEnKVxuICAgIH1cbiAgfVxuXG4gIGlmIChtaXBEYXRhLmNvbXByZXNzZWQpIHtcbiAgICBjaGVjayghaW5mby5nZW5NaXBtYXBzLFxuICAgICAgJ21pcG1hcCBnZW5lcmF0aW9uIGZvciBjb21wcmVzc2VkIGltYWdlcyBub3Qgc3VwcG9ydGVkJylcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1RleHR1cmVDdWJlICh0ZXh0dXJlLCBpbmZvLCBmYWNlcywgbGltaXRzKSB7XG4gIHZhciB3ID0gdGV4dHVyZS53aWR0aFxuICB2YXIgaCA9IHRleHR1cmUuaGVpZ2h0XG4gIHZhciBjID0gdGV4dHVyZS5jaGFubmVsc1xuXG4gIC8vIENoZWNrIHRleHR1cmUgc2hhcGVcbiAgY2hlY2soXG4gICAgdyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiYgaCA+IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsXG4gICAgJ2ludmFsaWQgdGV4dHVyZSBzaGFwZScpXG4gIGNoZWNrKFxuICAgIHcgPT09IGgsXG4gICAgJ2N1YmUgbWFwIG11c3QgYmUgc3F1YXJlJylcbiAgY2hlY2soXG4gICAgaW5mby53cmFwUyA9PT0gR0xfQ0xBTVBfVE9fRURHRSAmJiBpbmZvLndyYXBUID09PSBHTF9DTEFNUF9UT19FREdFLFxuICAgICd3cmFwIG1vZGUgbm90IHN1cHBvcnRlZCBieSBjdWJlIG1hcCcpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmYWNlID0gZmFjZXNbaV1cbiAgICBjaGVjayhcbiAgICAgIGZhY2Uud2lkdGggPT09IHcgJiYgZmFjZS5oZWlnaHQgPT09IGgsXG4gICAgICAnaW5jb25zaXN0ZW50IGN1YmUgbWFwIGZhY2Ugc2hhcGUnKVxuXG4gICAgaWYgKGluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgY2hlY2soIWZhY2UuY29tcHJlc3NlZCxcbiAgICAgICAgJ2NhbiBub3QgZ2VuZXJhdGUgbWlwbWFwIGZvciBjb21wcmVzc2VkIHRleHR1cmVzJylcbiAgICAgIGNoZWNrKGZhY2UubWlwbWFzayA9PT0gMSxcbiAgICAgICAgJ2NhbiBub3Qgc3BlY2lmeSBtaXBtYXBzIGFuZCBnZW5lcmF0ZSBtaXBtYXBzJylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogY2hlY2sgbWlwIGFuZCBmaWx0ZXIgbW9kZVxuICAgIH1cblxuICAgIHZhciBtaXBtYXBzID0gZmFjZS5pbWFnZXNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHZhciBpbWcgPSBtaXBtYXBzW2pdXG4gICAgICBpZiAoaW1nKSB7XG4gICAgICAgIHZhciBtdyA9IHcgPj4galxuICAgICAgICB2YXIgbWggPSBoID4+IGpcbiAgICAgICAgY2hlY2soZmFjZS5taXBtYXNrICYgKDEgPDwgaiksICdtaXNzaW5nIG1pcG1hcCBkYXRhJylcbiAgICAgICAgY2hlY2soXG4gICAgICAgICAgaW1nLndpZHRoID09PSBtdyAmJlxuICAgICAgICAgIGltZy5oZWlnaHQgPT09IG1oLFxuICAgICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBtaXAgaW1hZ2VzJylcbiAgICAgICAgY2hlY2soXG4gICAgICAgICAgaW1nLmZvcm1hdCA9PT0gdGV4dHVyZS5mb3JtYXQgJiZcbiAgICAgICAgICBpbWcuaW50ZXJuYWxmb3JtYXQgPT09IHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgJiZcbiAgICAgICAgICBpbWcudHlwZSA9PT0gdGV4dHVyZS50eXBlLFxuICAgICAgICAgICdpbmNvbXBhdGlibGUgdHlwZSBmb3IgbWlwIGltYWdlJylcblxuICAgICAgICBpZiAoaW1nLmNvbXByZXNzZWQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBzaXplIGZvciBjb21wcmVzc2VkIGltYWdlc1xuICAgICAgICB9IGVsc2UgaWYgKGltZy5kYXRhKSB7XG4gICAgICAgICAgY2hlY2soaW1nLmRhdGEuYnl0ZUxlbmd0aCA9PT0gbXcgKiBtaCAqXG4gICAgICAgICAgICBNYXRoLm1heChwaXhlbFNpemUoaW1nLnR5cGUsIGMpLCBpbWcudW5wYWNrQWxpZ25tZW50KSxcbiAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBpbWFnZSwgYnVmZmVyIHNpemUgaXMgaW5jb25zaXN0ZW50IHdpdGggaW1hZ2UgZm9ybWF0JylcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZWxlbWVudCkge1xuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGVsZW1lbnQgY2FuIGJlIGxvYWRlZFxuICAgICAgICB9IGVsc2UgaWYgKGltZy5jb3B5KSB7XG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgY29tcGF0aWJsZSBmb3JtYXQgYW5kIHR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgY2hlY2skMSA9IGV4dGVuZChjaGVjaywge1xuICBvcHRpb25hbDogY2hlY2tPcHRpb25hbCxcbiAgcmFpc2U6IHJhaXNlLFxuICBjb21tYW5kUmFpc2U6IGNvbW1hbmRSYWlzZSxcbiAgY29tbWFuZDogY2hlY2tDb21tYW5kLFxuICBwYXJhbWV0ZXI6IGNoZWNrUGFyYW1ldGVyLFxuICBjb21tYW5kUGFyYW1ldGVyOiBjaGVja1BhcmFtZXRlckNvbW1hbmQsXG4gIGNvbnN0cnVjdG9yOiBjaGVja0NvbnN0cnVjdG9yLFxuICB0eXBlOiBjaGVja1R5cGVPZixcbiAgY29tbWFuZFR5cGU6IGNoZWNrQ29tbWFuZFR5cGUsXG4gIGlzVHlwZWRBcnJheTogY2hlY2tJc1R5cGVkQXJyYXksXG4gIG5uaTogY2hlY2tOb25OZWdhdGl2ZUludCxcbiAgb25lT2Y6IGNoZWNrT25lT2YsXG4gIHNoYWRlckVycm9yOiBjaGVja1NoYWRlckVycm9yLFxuICBsaW5rRXJyb3I6IGNoZWNrTGlua0Vycm9yLFxuICBjYWxsU2l0ZTogZ3Vlc3NDYWxsU2l0ZSxcbiAgc2F2ZUNvbW1hbmRSZWY6IHNhdmVDb21tYW5kUmVmLFxuICBzYXZlRHJhd0luZm86IHNhdmVEcmF3Q29tbWFuZEluZm8sXG4gIGZyYW1lYnVmZmVyRm9ybWF0OiBjaGVja0ZyYW1lYnVmZmVyRm9ybWF0LFxuICBndWVzc0NvbW1hbmQ6IGd1ZXNzQ29tbWFuZCxcbiAgdGV4dHVyZTJEOiBjaGVja1RleHR1cmUyRCxcbiAgdGV4dHVyZUN1YmU6IGNoZWNrVGV4dHVyZUN1YmVcbn0pO1xuXG52YXIgVkFSSUFCTEVfQ09VTlRFUiA9IDBcblxudmFyIERZTl9GVU5DID0gMFxudmFyIERZTl9DT05TVEFOVCA9IDVcbnZhciBEWU5fQVJSQVkgPSA2XG5cbmZ1bmN0aW9uIER5bmFtaWNWYXJpYWJsZSAodHlwZSwgZGF0YSkge1xuICB0aGlzLmlkID0gKFZBUklBQkxFX0NPVU5URVIrKylcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLmRhdGEgPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0ciAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbn1cblxuZnVuY3Rpb24gc3BsaXRQYXJ0cyAoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICB2YXIgZmlyc3RDaGFyID0gc3RyLmNoYXJBdCgwKVxuICB2YXIgbGFzdENoYXIgPSBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMSAmJlxuICAgICAgZmlyc3RDaGFyID09PSBsYXN0Q2hhciAmJlxuICAgICAgKGZpcnN0Q2hhciA9PT0gJ1wiJyB8fCBmaXJzdENoYXIgPT09IFwiJ1wiKSkge1xuICAgIHJldHVybiBbJ1wiJyArIGVzY2FwZVN0cihzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKSkgKyAnXCInXVxuICB9XG5cbiAgdmFyIHBhcnRzID0gL1xcWyhmYWxzZXx0cnVlfG51bGx8XFxkK3wnW14nXSonfFwiW15cIl0qXCIpXFxdLy5leGVjKHN0cilcbiAgaWYgKHBhcnRzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHNwbGl0UGFydHMoc3RyLnN1YnN0cigwLCBwYXJ0cy5pbmRleCkpXG4gICAgICAgIC5jb25jYXQoc3BsaXRQYXJ0cyhwYXJ0c1sxXSkpXG4gICAgICAgIC5jb25jYXQoc3BsaXRQYXJ0cyhzdHIuc3Vic3RyKHBhcnRzLmluZGV4ICsgcGFydHNbMF0ubGVuZ3RoKSkpXG4gICAgKVxuICB9XG5cbiAgdmFyIHN1YnBhcnRzID0gc3RyLnNwbGl0KCcuJylcbiAgaWYgKHN1YnBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbJ1wiJyArIGVzY2FwZVN0cihzdHIpICsgJ1wiJ11cbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChzcGxpdFBhcnRzKHN1YnBhcnRzW2ldKSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvQWNjZXNzb3JTdHJpbmcgKHN0cikge1xuICByZXR1cm4gJ1snICsgc3BsaXRQYXJ0cyhzdHIpLmpvaW4oJ11bJykgKyAnXSdcbn1cblxuZnVuY3Rpb24gZGVmaW5lRHluYW1pYyAodHlwZSwgZGF0YSkge1xuICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZSh0eXBlLCB0b0FjY2Vzc29yU3RyaW5nKGRhdGEgKyAnJykpXG59XG5cbmZ1bmN0aW9uIGlzRHluYW1pYyAoeCkge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmICF4Ll9yZWdsVHlwZSkgfHwgKHggaW5zdGFuY2VvZiBEeW5hbWljVmFyaWFibGUpXG59XG5cbmZ1bmN0aW9uIHVuYm94ICh4LCBwYXRoKSB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1ZhcmlhYmxlKERZTl9GVU5DLCB4KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoRFlOX0NPTlNUQU5ULCB4KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZShEWU5fQVJSQVksIHgubWFwKCh5LCBpKSA9PiB1bmJveCh5LCBwYXRoICsgJ1snICsgaSArICddJykpKVxuICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBEeW5hbWljVmFyaWFibGUpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGNoZWNrJDEoZmFsc2UsICdpbnZhbGlkIG9wdGlvbiB0eXBlIGluIHVuaWZvcm0gJyArIHBhdGgpXG59XG5cbnZhciBkeW5hbWljID0ge1xuICBEeW5hbWljVmFyaWFibGU6IER5bmFtaWNWYXJpYWJsZSxcbiAgZGVmaW5lOiBkZWZpbmVEeW5hbWljLFxuICBpc0R5bmFtaWM6IGlzRHluYW1pYyxcbiAgdW5ib3g6IHVuYm94LFxuICBhY2Nlc3NvcjogdG9BY2Nlc3NvclN0cmluZ1xufTtcblxuLyogZ2xvYmFscyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lICovXG52YXIgcmFmID0ge1xuICBuZXh0OiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgfVxuICAgIDogZnVuY3Rpb24gKGNiKSB7IHJldHVybiBzZXRUaW1lb3V0KGNiLCAxNikgfSxcbiAgY2FuY2VsOiB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbidcbiAgICA/IGZ1bmN0aW9uIChyYWYpIHsgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZikgfVxuICAgIDogY2xlYXJUaW1lb3V0XG59O1xuXG4vKiBnbG9iYWxzIHBlcmZvcm1hbmNlICovXG52YXIgY2xvY2sgPSAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cpXG4gICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKSB9XG4gICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiArKG5ldyBEYXRlKCkpIH07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1N0b3JlICgpIHtcbiAgdmFyIHN0cmluZ0lkcyA9IHsgJyc6IDAgfVxuICB2YXIgc3RyaW5nVmFsdWVzID0gWycnXVxuICByZXR1cm4ge1xuICAgIGlkOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nSWRzW3N0cl1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gc3RyaW5nSWRzW3N0cl0gPSBzdHJpbmdWYWx1ZXMubGVuZ3RoXG4gICAgICBzdHJpbmdWYWx1ZXMucHVzaChzdHIpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcblxuICAgIHN0cjogZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWVzW2lkXVxuICAgIH1cbiAgfVxufVxuXG4vLyBDb250ZXh0IGFuZCBjYW52YXMgY3JlYXRpb24gaGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY3JlYXRlQ2FudmFzIChlbGVtZW50LCBvbkRvbmUsIHBpeGVsUmF0aW8pIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gIGV4dGVuZChjYW52YXMuc3R5bGUsIHtcbiAgICBib3JkZXI6IDAsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfSlcbiAgZWxlbWVudC5hcHBlbmRDaGlsZChjYW52YXMpXG5cbiAgaWYgKGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgZXh0ZW5kKGVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplICgpIHtcbiAgICB2YXIgdyA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgdmFyIGggPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIHcgPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdFxuICAgICAgaCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wXG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHBpeGVsUmF0aW8gKiB3XG4gICAgY2FudmFzLmhlaWdodCA9IHBpeGVsUmF0aW8gKiBoXG4gICAgZXh0ZW5kKGNhbnZhcy5zdHlsZSwge1xuICAgICAgd2lkdGg6IHcgKyAncHgnLFxuICAgICAgaGVpZ2h0OiBoICsgJ3B4J1xuICAgIH0pXG4gIH1cblxuICB2YXIgcmVzaXplT2JzZXJ2ZXJcbiAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaWdub3JlICdSZXNpemVPYnNlcnZlcicgaXMgbm90IGRlZmluZWRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzZXRUaW1lb3V0IHRvIGF2b2lkIGZsaWNrZXJcbiAgICAgIHNldFRpbWVvdXQocmVzaXplKVxuICAgIH0pXG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUsIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25EZXN0cm95ICgpIHtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKVxuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNhbnZhcylcbiAgfVxuXG4gIHJlc2l6ZSgpXG5cbiAgcmV0dXJuIHtcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBvbkRlc3Ryb3k6IG9uRGVzdHJveVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQgKGNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpIHtcbiAgZnVuY3Rpb24gZ2V0IChuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dChuYW1lLCBjb250ZXh0QXR0cmlidXRlcylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gKFxuICAgIGdldCgnd2ViZ2wnKSB8fFxuICAgIGdldCgnZXhwZXJpbWVudGFsLXdlYmdsJykgfHxcbiAgICBnZXQoJ3dlYmdsLWV4cGVyaW1lbnRhbCcpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iai5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2Ygb2JqLmFwcGVuZENoaWxkID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1dlYkdMQ29udGV4dCAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iai5kcmF3QXJyYXlzID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIG9iai5kcmF3RWxlbWVudHMgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG5mdW5jdGlvbiBwYXJzZUV4dGVuc2lvbnMgKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlucHV0LnNwbGl0KClcbiAgfVxuICBjaGVjayQxKEFycmF5LmlzQXJyYXkoaW5wdXQpLCAnaW52YWxpZCBleHRlbnNpb24gYXJyYXknKVxuICByZXR1cm4gaW5wdXRcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudCAoZGVzYykge1xuICBpZiAodHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnKSB7XG4gICAgY2hlY2skMSh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLCAnbm90IHN1cHBvcnRlZCBvdXRzaWRlIG9mIERPTScpXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGVzYylcbiAgfVxuICByZXR1cm4gZGVzY1xufVxuXG5mdW5jdGlvbiBwYXJzZUFyZ3MgKGFyZ3NfKSB7XG4gIHZhciBhcmdzID0gYXJnc18gfHwge31cbiAgdmFyIGVsZW1lbnQsIGNvbnRhaW5lciwgY2FudmFzLCBnbFxuICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7fVxuICB2YXIgZXh0ZW5zaW9ucyA9IFtdXG4gIHZhciBvcHRpb25hbEV4dGVuc2lvbnMgPSBbXVxuICB2YXIgcGl4ZWxSYXRpbyA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IDEgOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgdmFyIHByb2ZpbGUgPSBmYWxzZVxuICB2YXIgb25Eb25lID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoZXJyKVxuICAgIH1cbiAgfVxuICB2YXIgb25EZXN0cm95ID0gZnVuY3Rpb24gKCkge31cbiAgaWYgKHR5cGVvZiBhcmdzID09PSAnc3RyaW5nJykge1xuICAgIGNoZWNrJDEoXG4gICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgICAgJ3NlbGVjdG9yIHF1ZXJpZXMgb25seSBzdXBwb3J0ZWQgaW4gRE9NIGVudmlyb21lbnRzJylcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcmdzKVxuICAgIGNoZWNrJDEoZWxlbWVudCwgJ2ludmFsaWQgcXVlcnkgc3RyaW5nIGZvciBlbGVtZW50JylcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChhcmdzKSkge1xuICAgICAgZWxlbWVudCA9IGFyZ3NcbiAgICB9IGVsc2UgaWYgKGlzV2ViR0xDb250ZXh0KGFyZ3MpKSB7XG4gICAgICBnbCA9IGFyZ3NcbiAgICAgIGNhbnZhcyA9IGdsLmNhbnZhc1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVjayQxLmNvbnN0cnVjdG9yKGFyZ3MpXG4gICAgICBpZiAoJ2dsJyBpbiBhcmdzKSB7XG4gICAgICAgIGdsID0gYXJncy5nbFxuICAgICAgfSBlbHNlIGlmICgnY2FudmFzJyBpbiBhcmdzKSB7XG4gICAgICAgIGNhbnZhcyA9IGdldEVsZW1lbnQoYXJncy5jYW52YXMpXG4gICAgICB9IGVsc2UgaWYgKCdjb250YWluZXInIGluIGFyZ3MpIHtcbiAgICAgICAgY29udGFpbmVyID0gZ2V0RWxlbWVudChhcmdzLmNvbnRhaW5lcilcbiAgICAgIH1cbiAgICAgIGlmICgnYXR0cmlidXRlcycgaW4gYXJncykge1xuICAgICAgICBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3MuYXR0cmlidXRlc1xuICAgICAgICBjaGVjayQxLnR5cGUoY29udGV4dEF0dHJpYnV0ZXMsICdvYmplY3QnLCAnaW52YWxpZCBjb250ZXh0IGF0dHJpYnV0ZXMnKVxuICAgICAgfVxuICAgICAgaWYgKCdleHRlbnNpb25zJyBpbiBhcmdzKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZUV4dGVuc2lvbnMoYXJncy5leHRlbnNpb25zKVxuICAgICAgfVxuICAgICAgaWYgKCdvcHRpb25hbEV4dGVuc2lvbnMnIGluIGFyZ3MpIHtcbiAgICAgICAgb3B0aW9uYWxFeHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKGFyZ3Mub3B0aW9uYWxFeHRlbnNpb25zKVxuICAgICAgfVxuICAgICAgaWYgKCdvbkRvbmUnIGluIGFyZ3MpIHtcbiAgICAgICAgY2hlY2skMS50eXBlKFxuICAgICAgICAgIGFyZ3Mub25Eb25lLCAnZnVuY3Rpb24nLFxuICAgICAgICAgICdpbnZhbGlkIG9yIG1pc3Npbmcgb25Eb25lIGNhbGxiYWNrJylcbiAgICAgICAgb25Eb25lID0gYXJncy5vbkRvbmVcbiAgICAgIH1cbiAgICAgIGlmICgncHJvZmlsZScgaW4gYXJncykge1xuICAgICAgICBwcm9maWxlID0gISFhcmdzLnByb2ZpbGVcbiAgICAgIH1cbiAgICAgIGlmICgncGl4ZWxSYXRpbycgaW4gYXJncykge1xuICAgICAgICBwaXhlbFJhdGlvID0gK2FyZ3MucGl4ZWxSYXRpb1xuICAgICAgICBjaGVjayQxKHBpeGVsUmF0aW8gPiAwLCAnaW52YWxpZCBwaXhlbCByYXRpbycpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYXJndW1lbnRzIHRvIHJlZ2wnKVxuICB9XG5cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgY2FudmFzID0gZWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIgPSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgaWYgKCFnbCkge1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjaGVjayQxKFxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICAnbXVzdCBtYW51YWxseSBzcGVjaWZ5IHdlYmdsIGNvbnRleHQgb3V0c2lkZSBvZiBET00gZW52aXJvbm1lbnRzJylcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVDYW52YXMoY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksIG9uRG9uZSwgcGl4ZWxSYXRpbylcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBjYW52YXMgPSByZXN1bHQuY2FudmFzXG4gICAgICBvbkRlc3Ryb3kgPSByZXN1bHQub25EZXN0cm95XG4gICAgfVxuICAgIC8vIHdvcmthcm91bmQgZm9yIGNocm9taXVtIGJ1ZywgcHJlbXVsdGlwbGllZCBhbHBoYSB2YWx1ZSBpcyBwbGF0Zm9ybSBkZXBlbmRlbnRcbiAgICBpZiAoY29udGV4dEF0dHJpYnV0ZXMucHJlbXVsdGlwbGllZEFscGhhID09PSB1bmRlZmluZWQpIGNvbnRleHRBdHRyaWJ1dGVzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWVcbiAgICBnbCA9IGNyZWF0ZUNvbnRleHQoY2FudmFzLCBjb250ZXh0QXR0cmlidXRlcylcbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICBvbkRlc3Ryb3koKVxuICAgIG9uRG9uZSgnd2ViZ2wgbm90IHN1cHBvcnRlZCwgdHJ5IHVwZ3JhZGluZyB5b3VyIGJyb3dzZXIgb3IgZ3JhcGhpY3MgZHJpdmVycyBodHRwOi8vZ2V0LndlYmdsLm9yZycpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2w6IGdsLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXG4gICAgb3B0aW9uYWxFeHRlbnNpb25zOiBvcHRpb25hbEV4dGVuc2lvbnMsXG4gICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcbiAgICBwcm9maWxlOiBwcm9maWxlLFxuICAgIG9uRG9uZTogb25Eb25lLFxuICAgIG9uRGVzdHJveTogb25EZXN0cm95XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXh0ZW5zaW9uQ2FjaGUgKGdsLCBjb25maWcpIHtcbiAgdmFyIGV4dGVuc2lvbnMgPSB7fVxuXG4gIGZ1bmN0aW9uIHRyeUxvYWRFeHRlbnNpb24gKG5hbWVfKSB7XG4gICAgY2hlY2skMS50eXBlKG5hbWVfLCAnc3RyaW5nJywgJ2V4dGVuc2lvbiBuYW1lIG11c3QgYmUgc3RyaW5nJylcbiAgICB2YXIgbmFtZSA9IG5hbWVfLnRvTG93ZXJDYXNlKClcbiAgICB2YXIgZXh0XG4gICAgdHJ5IHtcbiAgICAgIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV0gPSBnbC5nZXRFeHRlbnNpb24obmFtZSlcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiAhIWV4dFxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBuYW1lID0gY29uZmlnLmV4dGVuc2lvbnNbaV1cbiAgICBpZiAoIXRyeUxvYWRFeHRlbnNpb24obmFtZSkpIHtcbiAgICAgIGNvbmZpZy5vbkRlc3Ryb3koKVxuICAgICAgY29uZmlnLm9uRG9uZSgnXCInICsgbmFtZSArICdcIiBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBXZWJHTCBjb250ZXh0LCB0cnkgdXBncmFkaW5nIHlvdXIgc3lzdGVtIG9yIGEgZGlmZmVyZW50IGJyb3dzZXInKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjb25maWcub3B0aW9uYWxFeHRlbnNpb25zLmZvckVhY2godHJ5TG9hZEV4dGVuc2lvbilcblxuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0LmtleXMoZXh0ZW5zaW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uc1tuYW1lXSAmJiAhdHJ5TG9hZEV4dGVuc2lvbihuYW1lKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignKHJlZ2wpOiBlcnJvciByZXN0b3JpbmcgZXh0ZW5zaW9uICcgKyBuYW1lKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsb29wIChuLCBmKSB7XG4gIHZhciByZXN1bHQgPSBBcnJheShuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGYoaSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbnZhciBHTF9CWVRFJDEgPSA1MTIwXG52YXIgR0xfVU5TSUdORURfQllURSQyID0gNTEyMVxudmFyIEdMX1NIT1JUJDEgPSA1MTIyXG52YXIgR0xfVU5TSUdORURfU0hPUlQkMSA9IDUxMjNcbnZhciBHTF9JTlQkMSA9IDUxMjRcbnZhciBHTF9VTlNJR05FRF9JTlQkMSA9IDUxMjVcbnZhciBHTF9GTE9BVCQyID0gNTEyNlxuXG5mdW5jdGlvbiBuZXh0UG93MTYgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDE2OyBpIDw9ICgxIDw8IDI4KTsgaSAqPSAxNikge1xuICAgIGlmICh2IDw9IGkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGxvZzIgKHYpIHtcbiAgdmFyIHIsIHNoaWZ0XG4gIHIgPSAodiA+IDB4RkZGRikgPDwgNFxuICB2ID4+Pj0gclxuICBzaGlmdCA9ICh2ID4gMHhGRikgPDwgM1xuICB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnRcbiAgc2hpZnQgPSAodiA+IDB4RikgPDwgMlxuICB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnRcbiAgc2hpZnQgPSAodiA+IDB4MykgPDwgMVxuICB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnRcbiAgcmV0dXJuIHIgfCAodiA+PiAxKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb29sICgpIHtcbiAgdmFyIGJ1ZmZlclBvb2wgPSBsb29wKDgsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW11cbiAgfSlcblxuICBmdW5jdGlvbiBhbGxvYyAobikge1xuICAgIHZhciBzeiA9IG5leHRQb3cxNihuKVxuICAgIHZhciBiaW4gPSBidWZmZXJQb29sW2xvZzIoc3opID4+IDJdXG4gICAgaWYgKGJpbi5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gYmluLnBvcCgpXG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoc3opXG4gIH1cblxuICBmdW5jdGlvbiBmcmVlIChidWYpIHtcbiAgICBidWZmZXJQb29sW2xvZzIoYnVmLmJ5dGVMZW5ndGgpID4+IDJdLnB1c2goYnVmKVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NUeXBlICh0eXBlLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGxcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgR0xfQllURSQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgSW50OEFycmF5KGFsbG9jKG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9CWVRFJDI6XG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGFsbG9jKG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9TSE9SVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgSW50MTZBcnJheShhbGxvYygyICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUJDE6XG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50MTZBcnJheShhbGxvYygyICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEdMX0lOVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgSW50MzJBcnJheShhbGxvYyg0ICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEdMX1VOU0lHTkVEX0lOVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoYWxsb2MoNCAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9GTE9BVCQyOlxuICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGFsbG9jKDQgKiBuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSBuKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnN1YmFycmF5KDAsIG4pXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVUeXBlIChhcnJheSkge1xuICAgIGZyZWUoYXJyYXkuYnVmZmVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxvYzogYWxsb2MsXG4gICAgZnJlZTogZnJlZSxcbiAgICBhbGxvY1R5cGU6IGFsbG9jVHlwZSxcbiAgICBmcmVlVHlwZTogZnJlZVR5cGVcbiAgfVxufVxuXG52YXIgcG9vbCA9IGNyZWF0ZVBvb2woKVxuXG4vLyB6ZXJvIHBvb2wgZm9yIGluaXRpYWwgemVybyBkYXRhXG5wb29sLnplcm8gPSBjcmVhdGVQb29sKClcblxudmFyIEdMX1NVQlBJWEVMX0JJVFMgPSAweDBENTBcbnZhciBHTF9SRURfQklUUyA9IDB4MEQ1MlxudmFyIEdMX0dSRUVOX0JJVFMgPSAweDBENTNcbnZhciBHTF9CTFVFX0JJVFMgPSAweDBENTRcbnZhciBHTF9BTFBIQV9CSVRTID0gMHgwRDU1XG52YXIgR0xfREVQVEhfQklUUyA9IDB4MEQ1NlxudmFyIEdMX1NURU5DSUxfQklUUyA9IDB4MEQ1N1xuXG52YXIgR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFID0gMHg4NDZEXG52YXIgR0xfQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFID0gMHg4NDZFXG5cbnZhciBHTF9NQVhfVEVYVFVSRV9TSVpFID0gMHgwRDMzXG52YXIgR0xfTUFYX1ZJRVdQT1JUX0RJTVMgPSAweDBEM0FcbnZhciBHTF9NQVhfVkVSVEVYX0FUVFJJQlMgPSAweDg4NjlcbnZhciBHTF9NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyA9IDB4OERGQlxudmFyIEdMX01BWF9WQVJZSU5HX1ZFQ1RPUlMgPSAweDhERkNcbnZhciBHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4OEI0RFxudmFyIEdMX01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4OEI0Q1xudmFyIEdMX01BWF9URVhUVVJFX0lNQUdFX1VOSVRTID0gMHg4ODcyXG52YXIgR0xfTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyA9IDB4OERGRFxudmFyIEdMX01BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgPSAweDg1MUNcbnZhciBHTF9NQVhfUkVOREVSQlVGRkVSX1NJWkUgPSAweDg0RThcblxudmFyIEdMX1ZFTkRPUiA9IDB4MUYwMFxudmFyIEdMX1JFTkRFUkVSID0gMHgxRjAxXG52YXIgR0xfVkVSU0lPTiA9IDB4MUYwMlxudmFyIEdMX1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiA9IDB4OEI4Q1xuXG52YXIgR0xfTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUID0gMHg4NEZGXG5cbnZhciBHTF9NQVhfQ09MT1JfQVRUQUNITUVOVFNfV0VCR0wgPSAweDhDREZcbnZhciBHTF9NQVhfRFJBV19CVUZGRVJTX1dFQkdMID0gMHg4ODI0XG5cbnZhciBHTF9URVhUVVJFXzJEID0gMHgwREUxXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUCA9IDB4ODUxM1xudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCA9IDB4ODUxNVxudmFyIEdMX1RFWFRVUkUwID0gMHg4NEMwXG52YXIgR0xfUkdCQSA9IDB4MTkwOFxudmFyIEdMX0ZMT0FUJDEgPSAweDE0MDZcbnZhciBHTF9VTlNJR05FRF9CWVRFJDEgPSAweDE0MDFcbnZhciBHTF9GUkFNRUJVRkZFUiA9IDB4OEQ0MFxudmFyIEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFID0gMHg4Q0Q1XG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAgPSAweDhDRTBcbnZhciBHTF9DT0xPUl9CVUZGRVJfQklUJDEgPSAweDQwMDBcblxudmFyIHdyYXBMaW1pdHMgPSBmdW5jdGlvbiAoZ2wsIGV4dGVuc2lvbnMpIHtcbiAgdmFyIG1heEFuaXNvdHJvcGljID0gMVxuICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcbiAgICBtYXhBbmlzb3Ryb3BpYyA9IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpXG4gIH1cblxuICB2YXIgbWF4RHJhd2J1ZmZlcnMgPSAxXG4gIHZhciBtYXhDb2xvckF0dGFjaG1lbnRzID0gMVxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9kcmF3X2J1ZmZlcnMpIHtcbiAgICBtYXhEcmF3YnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfRFJBV19CVUZGRVJTX1dFQkdMKVxuICAgIG1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0NPTE9SX0FUVEFDSE1FTlRTX1dFQkdMKVxuICB9XG5cbiAgLy8gZGV0ZWN0IGlmIHJlYWRpbmcgZmxvYXQgdGV4dHVyZXMgaXMgYXZhaWxhYmxlIChTYWZhcmkgZG9lc24ndCBzdXBwb3J0KVxuICB2YXIgcmVhZEZsb2F0ID0gISFleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0XG4gIGlmIChyZWFkRmxvYXQpIHtcbiAgICB2YXIgcmVhZEZsb2F0VGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQsIHJlYWRGbG9hdFRleHR1cmUpXG4gICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFXzJELCAwLCBHTF9SR0JBLCAxLCAxLCAwLCBHTF9SR0JBLCBHTF9GTE9BVCQxLCBudWxsKVxuXG4gICAgdmFyIGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIsIGZibylcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChHTF9GUkFNRUJVRkZFUiwgR0xfQ09MT1JfQVRUQUNITUVOVDAsIEdMX1RFWFRVUkVfMkQsIHJlYWRGbG9hdFRleHR1cmUsIDApXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCwgbnVsbClcblxuICAgIGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKEdMX0ZSQU1FQlVGRkVSKSAhPT0gR0xfRlJBTUVCVUZGRVJfQ09NUExFVEUpIHJlYWRGbG9hdCA9IGZhbHNlXG5cbiAgICBlbHNlIHtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIDEsIDEpXG4gICAgICBnbC5jbGVhckNvbG9yKDEuMCwgMC4wLCAwLjAsIDEuMClcbiAgICAgIGdsLmNsZWFyKEdMX0NPTE9SX0JVRkZFUl9CSVQkMSlcbiAgICAgIHZhciBwaXhlbHMgPSBwb29sLmFsbG9jVHlwZShHTF9GTE9BVCQxLCA0KVxuICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBHTF9SR0JBLCBHTF9GTE9BVCQxLCBwaXhlbHMpXG5cbiAgICAgIGlmIChnbC5nZXRFcnJvcigpKSByZWFkRmxvYXQgPSBmYWxzZVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZibylcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShyZWFkRmxvYXRUZXh0dXJlKVxuXG4gICAgICAgIHJlYWRGbG9hdCA9IHBpeGVsc1swXSA9PT0gMS4wXG4gICAgICB9XG5cbiAgICAgIHBvb2wuZnJlZVR5cGUocGl4ZWxzKVxuICAgIH1cbiAgfVxuXG4gIC8vIGRldGVjdCBub24gcG93ZXIgb2YgdHdvIGN1YmUgdGV4dHVyZXMgc3VwcG9ydCAoSUUgZG9lc24ndCBzdXBwb3J0KVxuICB2YXIgaXNJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmICgvTVNJRS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvVHJpZGVudFxcLy8udGVzdChuYXZpZ2F0b3IuYXBwVmVyc2lvbikgfHwgL0VkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG5cbiAgdmFyIG5wb3RUZXh0dXJlQ3ViZSA9IHRydWVcblxuICBpZiAoIWlzSUUpIHtcbiAgICB2YXIgY3ViZVRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICB2YXIgZGF0YSA9IHBvb2wuYWxsb2NUeXBlKEdMX1VOU0lHTkVEX0JZVEUkMSwgMzYpXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMClcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQLCBjdWJlVGV4dHVyZSlcbiAgICBnbC50ZXhJbWFnZTJEKEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgMCwgR0xfUkdCQSwgMywgMywgMCwgR0xfUkdCQSwgR0xfVU5TSUdORURfQllURSQxLCBkYXRhKVxuICAgIHBvb2wuZnJlZVR5cGUoZGF0YSlcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQLCBudWxsKVxuICAgIGdsLmRlbGV0ZVRleHR1cmUoY3ViZVRleHR1cmUpXG4gICAgbnBvdFRleHR1cmVDdWJlID0gIWdsLmdldEVycm9yKClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gZHJhd2luZyBidWZmZXIgYml0IGRlcHRoXG4gICAgY29sb3JCaXRzOiBbXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfUkVEX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0dSRUVOX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0JMVUVfQklUUyksXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxQSEFfQklUUylcbiAgICBdLFxuICAgIGRlcHRoQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX0RFUFRIX0JJVFMpLFxuICAgIHN0ZW5jaWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1RFTkNJTF9CSVRTKSxcbiAgICBzdWJwaXhlbEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9TVUJQSVhFTF9CSVRTKSxcblxuICAgIC8vIHN1cHBvcnRlZCBleHRlbnNpb25zXG4gICAgZXh0ZW5zaW9uczogT2JqZWN0LmtleXMoZXh0ZW5zaW9ucykuZmlsdGVyKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgIHJldHVybiAhIWV4dGVuc2lvbnNbZXh0XVxuICAgIH0pLFxuXG4gICAgLy8gbWF4IGFuaXNvIHNhbXBsZXNcbiAgICBtYXhBbmlzb3Ryb3BpYzogbWF4QW5pc290cm9waWMsXG5cbiAgICAvLyBtYXggZHJhdyBidWZmZXJzXG4gICAgbWF4RHJhd2J1ZmZlcnM6IG1heERyYXdidWZmZXJzLFxuICAgIG1heENvbG9yQXR0YWNobWVudHM6IG1heENvbG9yQXR0YWNobWVudHMsXG5cbiAgICAvLyBwb2ludCBhbmQgbGluZSBzaXplIHJhbmdlc1xuICAgIHBvaW50U2l6ZURpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9BTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UpLFxuICAgIGxpbmVXaWR0aERpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UpLFxuICAgIG1heFZpZXdwb3J0RGltczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WSUVXUE9SVF9ESU1TKSxcbiAgICBtYXhDb21iaW5lZFRleHR1cmVVbml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKSxcbiAgICBtYXhDdWJlTWFwU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLFxuICAgIG1heFJlbmRlcmJ1ZmZlclNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfUkVOREVSQlVGRkVSX1NJWkUpLFxuICAgIG1heFRleHR1cmVVbml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSxcbiAgICBtYXhUZXh0dXJlU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9URVhUVVJFX1NJWkUpLFxuICAgIG1heEF0dHJpYnV0ZXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkVSVEVYX0FUVFJJQlMpLFxuICAgIG1heFZlcnRleFVuaWZvcm1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMpLFxuICAgIG1heFZlcnRleFRleHR1cmVVbml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4VmFyeWluZ1ZlY3RvcnM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkFSWUlOR19WRUNUT1JTKSxcbiAgICBtYXhGcmFnbWVudFVuaWZvcm1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyksXG5cbiAgICAvLyB2ZW5kb3IgaW5mb1xuICAgIGdsc2w6IGdsLmdldFBhcmFtZXRlcihHTF9TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04pLFxuICAgIHJlbmRlcmVyOiBnbC5nZXRQYXJhbWV0ZXIoR0xfUkVOREVSRVIpLFxuICAgIHZlbmRvcjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1ZFTkRPUiksXG4gICAgdmVyc2lvbjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1ZFUlNJT04pLFxuXG4gICAgLy8gcXVpcmtzXG4gICAgcmVhZEZsb2F0OiByZWFkRmxvYXQsXG4gICAgbnBvdFRleHR1cmVDdWJlOiBucG90VGV4dHVyZUN1YmVcbiAgfVxufVxuXG5mdW5jdGlvbiBpc05EQXJyYXlMaWtlIChvYmopIHtcbiAgcmV0dXJuIChcbiAgICAhIW9iaiAmJlxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgQXJyYXkuaXNBcnJheShvYmouc2hhcGUpICYmXG4gICAgQXJyYXkuaXNBcnJheShvYmouc3RyaWRlKSAmJlxuICAgIHR5cGVvZiBvYmoub2Zmc2V0ID09PSAnbnVtYmVyJyAmJlxuICAgIG9iai5zaGFwZS5sZW5ndGggPT09IG9iai5zdHJpZGUubGVuZ3RoICYmXG4gICAgKEFycmF5LmlzQXJyYXkob2JqLmRhdGEpIHx8XG4gICAgICBpc1R5cGVkQXJyYXkob2JqLmRhdGEpKSlcbn1cblxudmFyIHZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldIH0pXG59XG5cbnZhciBmbGF0dGVuVXRpbHMgPSB7XG4gIHNoYXBlOiBhcnJheVNoYXBlJDEsXG4gIGZsYXR0ZW46IGZsYXR0ZW5BcnJheVxufTtcblxuZnVuY3Rpb24gZmxhdHRlbjFEIChhcnJheSwgbngsIG91dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcbiAgICBvdXRbaV0gPSBhcnJheVtpXVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4yRCAoYXJyYXksIG54LCBueSwgb3V0KSB7XG4gIHZhciBwdHIgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbng7ICsraSkge1xuICAgIHZhciByb3cgPSBhcnJheVtpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnk7ICsraikge1xuICAgICAgb3V0W3B0cisrXSA9IHJvd1tqXVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuM0QgKGFycmF5LCBueCwgbnksIG56LCBvdXQsIHB0cl8pIHtcbiAgdmFyIHB0ciA9IHB0cl9cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBueDsgKytpKSB7XG4gICAgdmFyIHJvdyA9IGFycmF5W2ldXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBueTsgKytqKSB7XG4gICAgICB2YXIgY29sID0gcm93W2pdXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG56OyArK2spIHtcbiAgICAgICAgb3V0W3B0cisrXSA9IGNvbFtrXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuUmVjIChhcnJheSwgc2hhcGUsIGxldmVsLCBvdXQsIHB0cikge1xuICB2YXIgc3RyaWRlID0gMVxuICBmb3IgKHZhciBpID0gbGV2ZWwgKyAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBzdHJpZGUgKj0gc2hhcGVbaV1cbiAgfVxuICB2YXIgbiA9IHNoYXBlW2xldmVsXVxuICBpZiAoc2hhcGUubGVuZ3RoIC0gbGV2ZWwgPT09IDQpIHtcbiAgICB2YXIgbnggPSBzaGFwZVtsZXZlbCArIDFdXG4gICAgdmFyIG55ID0gc2hhcGVbbGV2ZWwgKyAyXVxuICAgIHZhciBueiA9IHNoYXBlW2xldmVsICsgM11cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmbGF0dGVuM0QoYXJyYXlbaV0sIG54LCBueSwgbnosIG91dCwgcHRyKVxuICAgICAgcHRyICs9IHN0cmlkZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmbGF0dGVuUmVjKGFycmF5W2ldLCBzaGFwZSwgbGV2ZWwgKyAxLCBvdXQsIHB0cilcbiAgICAgIHB0ciArPSBzdHJpZGVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5IChhcnJheSwgc2hhcGUsIHR5cGUsIG91dF8pIHtcbiAgdmFyIHN6ID0gMVxuICBpZiAoc2hhcGUubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3ogPSAwXG4gIH1cbiAgdmFyIG91dCA9IG91dF8gfHwgcG9vbC5hbGxvY1R5cGUodHlwZSwgc3opXG4gIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgYnJlYWtcbiAgICBjYXNlIDE6XG4gICAgICBmbGF0dGVuMUQoYXJyYXksIHNoYXBlWzBdLCBvdXQpXG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIGZsYXR0ZW4yRChhcnJheSwgc2hhcGVbMF0sIHNoYXBlWzFdLCBvdXQpXG4gICAgICBicmVha1xuICAgIGNhc2UgMzpcbiAgICAgIGZsYXR0ZW4zRChhcnJheSwgc2hhcGVbMF0sIHNoYXBlWzFdLCBzaGFwZVsyXSwgb3V0LCAwKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgZmxhdHRlblJlYyhhcnJheSwgc2hhcGUsIDAsIG91dCwgMClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGFycmF5U2hhcGUkMSAoYXJyYXlfKSB7XG4gIHZhciBzaGFwZSA9IFtdXG4gIGZvciAodmFyIGFycmF5ID0gYXJyYXlfOyBhcnJheS5sZW5ndGg7IGFycmF5ID0gYXJyYXlbMF0pIHtcbiAgICBzaGFwZS5wdXNoKGFycmF5Lmxlbmd0aClcbiAgfVxuICByZXR1cm4gc2hhcGVcbn1cblxudmFyIGFycmF5VHlwZXMgPSAge1xuXHRcIltvYmplY3QgSW50OEFycmF5XVwiOiA1MTIwLFxuXHRcIltvYmplY3QgSW50MTZBcnJheV1cIjogNTEyMixcblx0XCJbb2JqZWN0IEludDMyQXJyYXldXCI6IDUxMjQsXG5cdFwiW29iamVjdCBVaW50OEFycmF5XVwiOiA1MTIxLFxuXHRcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6IDUxMjEsXG5cdFwiW29iamVjdCBVaW50MTZBcnJheV1cIjogNTEyMyxcblx0XCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOiA1MTI1LFxuXHRcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOiA1MTI2LFxuXHRcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOiA1MTIxLFxuXHRcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI6IDUxMjFcbn07XG5cbnZhciBpbnQ4ID0gNTEyMDtcbnZhciBpbnQxNiA9IDUxMjI7XG52YXIgaW50MzIgPSA1MTI0O1xudmFyIHVpbnQ4ID0gNTEyMTtcbnZhciB1aW50MTYgPSA1MTIzO1xudmFyIHVpbnQzMiA9IDUxMjU7XG52YXIgZmxvYXQgPSA1MTI2O1xudmFyIGZsb2F0MzIgPSA1MTI2O1xudmFyIGdsVHlwZXMgPSB7XG5cdGludDg6IGludDgsXG5cdGludDE2OiBpbnQxNixcblx0aW50MzI6IGludDMyLFxuXHR1aW50ODogdWludDgsXG5cdHVpbnQxNjogdWludDE2LFxuXHR1aW50MzI6IHVpbnQzMixcblx0ZmxvYXQ6IGZsb2F0LFxuXHRmbG9hdDMyOiBmbG9hdDMyXG59O1xuXG52YXIgZHluYW1pYyQxID0gMzUwNDg7XG52YXIgc3RyZWFtID0gMzUwNDA7XG52YXIgdXNhZ2VUeXBlcyA9IHtcblx0ZHluYW1pYzogZHluYW1pYyQxLFxuXHRzdHJlYW06IHN0cmVhbSxcblx0XCJzdGF0aWNcIjogMzUwNDRcbn07XG5cbnZhciBhcnJheUZsYXR0ZW4gPSBmbGF0dGVuVXRpbHMuZmxhdHRlblxudmFyIGFycmF5U2hhcGUgPSBmbGF0dGVuVXRpbHMuc2hhcGVcblxudmFyIEdMX1NUQVRJQ19EUkFXID0gMHg4OEU0XG52YXIgR0xfU1RSRUFNX0RSQVcgPSAweDg4RTBcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUkMyA9IDUxMjFcbnZhciBHTF9GTE9BVCQzID0gNTEyNlxuXG52YXIgRFRZUEVTX1NJWkVTID0gW11cbkRUWVBFU19TSVpFU1s1MTIwXSA9IDEgLy8gaW50OFxuRFRZUEVTX1NJWkVTWzUxMjJdID0gMiAvLyBpbnQxNlxuRFRZUEVTX1NJWkVTWzUxMjRdID0gNCAvLyBpbnQzMlxuRFRZUEVTX1NJWkVTWzUxMjFdID0gMSAvLyB1aW50OFxuRFRZUEVTX1NJWkVTWzUxMjNdID0gMiAvLyB1aW50MTZcbkRUWVBFU19TSVpFU1s1MTI1XSA9IDQgLy8gdWludDMyXG5EVFlQRVNfU0laRVNbNTEyNl0gPSA0IC8vIGZsb2F0MzJcblxuZnVuY3Rpb24gdHlwZWRBcnJheUNvZGUgKGRhdGEpIHtcbiAgcmV0dXJuIGFycmF5VHlwZXNbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpXSB8IDBcbn1cblxuZnVuY3Rpb24gY29weUFycmF5IChvdXQsIGlucCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucC5sZW5ndGg7ICsraSkge1xuICAgIG91dFtpXSA9IGlucFtpXVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zcG9zZSAoXG4gIHJlc3VsdCwgZGF0YSwgc2hhcGVYLCBzaGFwZVksIHN0cmlkZVgsIHN0cmlkZVksIG9mZnNldCkge1xuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlWDsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFwZVk7ICsraikge1xuICAgICAgcmVzdWx0W3B0cisrXSA9IGRhdGFbc3RyaWRlWCAqIGkgKyBzdHJpZGVZICogaiArIG9mZnNldF1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcEJ1ZmZlclN0YXRlIChnbCwgc3RhdHMsIGNvbmZpZywgZGVzdHJveUJ1ZmZlcikge1xuICB2YXIgYnVmZmVyQ291bnQgPSAwXG4gIHZhciBidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xCdWZmZXIgKHR5cGUpIHtcbiAgICB0aGlzLmlkID0gYnVmZmVyQ291bnQrK1xuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy51c2FnZSA9IEdMX1NUQVRJQ19EUkFXXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gMFxuICAgIHRoaXMuZGltZW5zaW9uID0gMVxuICAgIHRoaXMuZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDNcblxuICAgIHRoaXMucGVyc2lzdGVudERhdGEgPSBudWxsXG5cbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHRoaXMuc3RhdHMgPSB7IHNpemU6IDAgfVxuICAgIH1cbiAgfVxuXG4gIFJFR0xCdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIHRoaXMuYnVmZmVyKVxuICB9XG5cbiAgUkVHTEJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0cm95KHRoaXMpXG4gIH1cblxuICB2YXIgc3RyZWFtUG9vbCA9IFtdXG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtICh0eXBlLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHN0cmVhbVBvb2wucG9wKClcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gbmV3IFJFR0xCdWZmZXIodHlwZSlcbiAgICB9XG4gICAgYnVmZmVyLmJpbmQoKVxuICAgIGluaXRCdWZmZXJGcm9tRGF0YShidWZmZXIsIGRhdGEsIEdMX1NUUkVBTV9EUkFXLCAwLCAxLCBmYWxzZSlcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95U3RyZWFtIChzdHJlYW0kJDEpIHtcbiAgICBzdHJlYW1Qb29sLnB1c2goc3RyZWFtJCQxKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5IChidWZmZXIsIGRhdGEsIHVzYWdlKSB7XG4gICAgYnVmZmVyLmJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlci50eXBlLCBkYXRhLCB1c2FnZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRCdWZmZXJGcm9tRGF0YSAoYnVmZmVyLCBkYXRhLCB1c2FnZSwgZHR5cGUsIGRpbWVuc2lvbiwgcGVyc2lzdCkge1xuICAgIHZhciBzaGFwZVxuICAgIGJ1ZmZlci51c2FnZSA9IHVzYWdlXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX0ZMT0FUJDNcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGZsYXREYXRhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgc2hhcGUgPSBhcnJheVNoYXBlKGRhdGEpXG4gICAgICAgICAgdmFyIGRpbSA9IDFcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBkaW0gKj0gc2hhcGVbaV1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbVxuICAgICAgICAgIGZsYXREYXRhID0gYXJyYXlGbGF0dGVuKGRhdGEsIHNoYXBlLCBidWZmZXIuZHR5cGUpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKVxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBmbGF0RGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGZsYXREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICAgICAgdmFyIHR5cGVkRGF0YSA9IHBvb2wuYWxsb2NUeXBlKGJ1ZmZlci5kdHlwZSwgZGF0YS5sZW5ndGgpXG4gICAgICAgICAgY29weUFycmF5KHR5cGVkRGF0YSwgZGF0YSlcbiAgICAgICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCB0eXBlZERhdGEsIHVzYWdlKVxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSB0eXBlZERhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZSh0eXBlZERhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhWzBdKSkge1xuICAgICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkYXRhWzBdLmxlbmd0aFxuICAgICAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IHR5cGVkQXJyYXlDb2RlKGRhdGFbMF0pIHx8IEdMX0ZMT0FUJDNcbiAgICAgICAgICBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBbZGF0YS5sZW5ndGgsIGRhdGFbMF0ubGVuZ3RoXSxcbiAgICAgICAgICAgIGJ1ZmZlci5kdHlwZSlcbiAgICAgICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBmbGF0RGF0YSwgdXNhZ2UpXG4gICAgICAgICAgaWYgKHBlcnNpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IGZsYXREYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVR5cGUoZmxhdERhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYnVmZmVyIGRhdGEnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IHR5cGVkQXJyYXlDb2RlKGRhdGEpXG4gICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBkYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcbiAgICAgIHNoYXBlID0gZGF0YS5zaGFwZVxuICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlXG4gICAgICB2YXIgb2Zmc2V0ID0gZGF0YS5vZmZzZXRcblxuICAgICAgdmFyIHNoYXBlWCA9IDBcbiAgICAgIHZhciBzaGFwZVkgPSAwXG4gICAgICB2YXIgc3RyaWRlWCA9IDBcbiAgICAgIHZhciBzdHJpZGVZID0gMFxuICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzaGFwZVggPSBzaGFwZVswXVxuICAgICAgICBzaGFwZVkgPSAxXG4gICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgc3RyaWRlWSA9IDBcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgIHNoYXBlWSA9IHNoYXBlWzFdXG4gICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBzaGFwZScpXG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IHR5cGVkQXJyYXlDb2RlKGRhdGEuZGF0YSkgfHwgR0xfRkxPQVQkM1xuICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IHNoYXBlWVxuXG4gICAgICB2YXIgdHJhbnNwb3NlRGF0YSA9IHBvb2wuYWxsb2NUeXBlKGJ1ZmZlci5kdHlwZSwgc2hhcGVYICogc2hhcGVZKVxuICAgICAgdHJhbnNwb3NlKHRyYW5zcG9zZURhdGEsXG4gICAgICAgIGRhdGEuZGF0YSxcbiAgICAgICAgc2hhcGVYLCBzaGFwZVksXG4gICAgICAgIHN0cmlkZVgsIHN0cmlkZVksXG4gICAgICAgIG9mZnNldClcbiAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIHRyYW5zcG9zZURhdGEsIHVzYWdlKVxuICAgICAgaWYgKHBlcnNpc3QpIHtcbiAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHJhbnNwb3NlRGF0YVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9vbC5mcmVlVHlwZSh0cmFuc3Bvc2VEYXRhKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDNcbiAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1lbnNpb25cbiAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIGRhdGEsIHVzYWdlKVxuICAgICAgaWYgKHBlcnNpc3QpIHtcbiAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoZGF0YSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYnVmZmVyIGRhdGEnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKGJ1ZmZlcikge1xuICAgIHN0YXRzLmJ1ZmZlckNvdW50LS1cblxuICAgIC8vIHJlbW92ZSBhdHRyaWJ1dGUgbGlua1xuICAgIGRlc3Ryb3lCdWZmZXIoYnVmZmVyKVxuXG4gICAgdmFyIGhhbmRsZSA9IGJ1ZmZlci5idWZmZXJcbiAgICBjaGVjayQxKGhhbmRsZSwgJ2J1ZmZlciBtdXN0IG5vdCBiZSBkZWxldGVkIGFscmVhZHknKVxuICAgIGdsLmRlbGV0ZUJ1ZmZlcihoYW5kbGUpXG4gICAgYnVmZmVyLmJ1ZmZlciA9IG51bGxcbiAgICBkZWxldGUgYnVmZmVyU2V0W2J1ZmZlci5pZF1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAob3B0aW9ucywgdHlwZSwgZGVmZXJJbml0LCBwZXJzaXN0ZW50KSB7XG4gICAgc3RhdHMuYnVmZmVyQ291bnQrK1xuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKHR5cGUpXG4gICAgYnVmZmVyU2V0W2J1ZmZlci5pZF0gPSBidWZmZXJcblxuICAgIGZ1bmN0aW9uIHJlZ2xCdWZmZXIgKG9wdGlvbnMpIHtcbiAgICAgIHZhciB1c2FnZSA9IEdMX1NUQVRJQ19EUkFXXG4gICAgICB2YXIgZGF0YSA9IG51bGxcbiAgICAgIHZhciBieXRlTGVuZ3RoID0gMFxuICAgICAgdmFyIGR0eXBlID0gMFxuICAgICAgdmFyIGRpbWVuc2lvbiA9IDFcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgaXNUeXBlZEFycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgaXNOREFycmF5TGlrZShvcHRpb25zKSB8fFxuICAgICAgICAgIG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBkYXRhID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMgfCAwXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY2hlY2skMS50eXBlKFxuICAgICAgICAgIG9wdGlvbnMsICdvYmplY3QnLFxuICAgICAgICAgICdidWZmZXIgYXJndW1lbnRzIG11c3QgYmUgYW4gb2JqZWN0LCBhIG51bWJlciBvciBhbiBhcnJheScpXG5cbiAgICAgICAgaWYgKCdkYXRhJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgIGRhdGEgPT09IG51bGwgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIGlzVHlwZWRBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgaXNOREFycmF5TGlrZShkYXRhKSxcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGJ1ZmZlcicpXG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd1c2FnZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMudXNhZ2UsIHVzYWdlVHlwZXMsICdpbnZhbGlkIGJ1ZmZlciB1c2FnZScpXG4gICAgICAgICAgdXNhZ2UgPSB1c2FnZVR5cGVzW29wdGlvbnMudXNhZ2VdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLnR5cGUsIGdsVHlwZXMsICdpbnZhbGlkIGJ1ZmZlciB0eXBlJylcbiAgICAgICAgICBkdHlwZSA9IGdsVHlwZXNbb3B0aW9ucy50eXBlXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkaW1lbnNpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucy5kaW1lbnNpb24sICdudW1iZXInLCAnaW52YWxpZCBkaW1lbnNpb24nKVxuICAgICAgICAgIGRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9uIHwgMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdsZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLm5uaShieXRlTGVuZ3RoLCAnYnVmZmVyIGxlbmd0aCBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpXG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHwgMFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlci5iaW5kKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAvLyAjNDc1XG4gICAgICAgIGlmIChieXRlTGVuZ3RoKSBnbC5idWZmZXJEYXRhKGJ1ZmZlci50eXBlLCBieXRlTGVuZ3RoLCB1c2FnZSlcbiAgICAgICAgYnVmZmVyLmR0eXBlID0gZHR5cGUgfHwgR0xfVU5TSUdORURfQllURSQzXG4gICAgICAgIGJ1ZmZlci51c2FnZSA9IHVzYWdlXG4gICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1lbnNpb25cbiAgICAgICAgYnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0QnVmZmVyRnJvbURhdGEoYnVmZmVyLCBkYXRhLCB1c2FnZSwgZHR5cGUsIGRpbWVuc2lvbiwgcGVyc2lzdGVudClcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgIGJ1ZmZlci5zdGF0cy5zaXplID0gYnVmZmVyLmJ5dGVMZW5ndGggKiBEVFlQRVNfU0laRVNbYnVmZmVyLmR0eXBlXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbEJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFN1YkRhdGEgKGRhdGEsIG9mZnNldCkge1xuICAgICAgY2hlY2skMShvZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICdpbnZhbGlkIGJ1ZmZlciBzdWJkYXRhIGNhbGwsIGJ1ZmZlciBpcyB0b28gc21hbGwuICcgKyAnIENhblxcJ3Qgd3JpdGUgZGF0YSBvZiBzaXplICcgKyBkYXRhLmJ5dGVMZW5ndGggKyAnIHN0YXJ0aW5nIGZyb20gb2Zmc2V0ICcgKyBvZmZzZXQgKyAnIHRvIGEgYnVmZmVyIG9mIHNpemUgJyArIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGJ1ZmZlci50eXBlLCBvZmZzZXQsIGRhdGEpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ViZGF0YSAoZGF0YSwgb2Zmc2V0Xykge1xuICAgICAgdmFyIG9mZnNldCA9IChvZmZzZXRfIHx8IDApIHwgMFxuICAgICAgdmFyIHNoYXBlXG4gICAgICBidWZmZXIuYmluZCgpXG4gICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpIHx8IGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBzZXRTdWJEYXRhKGRhdGEsIG9mZnNldClcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IHBvb2wuYWxsb2NUeXBlKGJ1ZmZlci5kdHlwZSwgZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICBjb3B5QXJyYXkoY29udmVydGVkLCBkYXRhKVxuICAgICAgICAgICAgc2V0U3ViRGF0YShjb252ZXJ0ZWQsIG9mZnNldClcbiAgICAgICAgICAgIHBvb2wuZnJlZVR5cGUoY29udmVydGVkKVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSB8fCBpc1R5cGVkQXJyYXkoZGF0YVswXSkpIHtcbiAgICAgICAgICAgIHNoYXBlID0gYXJyYXlTaGFwZShkYXRhKVxuICAgICAgICAgICAgdmFyIGZsYXREYXRhID0gYXJyYXlGbGF0dGVuKGRhdGEsIHNoYXBlLCBidWZmZXIuZHR5cGUpXG4gICAgICAgICAgICBzZXRTdWJEYXRhKGZsYXREYXRhLCBvZmZzZXQpXG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGZsYXREYXRhKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlXG5cbiAgICAgICAgdmFyIHNoYXBlWCA9IDBcbiAgICAgICAgdmFyIHNoYXBlWSA9IDBcbiAgICAgICAgdmFyIHN0cmlkZVggPSAwXG4gICAgICAgIHZhciBzdHJpZGVZID0gMFxuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgICAgICBzaGFwZVkgPSAxXG4gICAgICAgICAgc3RyaWRlWCA9IHN0cmlkZVswXVxuICAgICAgICAgIHN0cmlkZVkgPSAwXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgICAgICBzaGFwZVkgPSBzaGFwZVsxXVxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgICBzdHJpZGVZID0gc3RyaWRlWzFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBzaGFwZScpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpXG4gICAgICAgICAgPyBidWZmZXIuZHR5cGVcbiAgICAgICAgICA6IHR5cGVkQXJyYXlDb2RlKGRhdGEuZGF0YSlcblxuICAgICAgICB2YXIgdHJhbnNwb3NlRGF0YSA9IHBvb2wuYWxsb2NUeXBlKGR0eXBlLCBzaGFwZVggKiBzaGFwZVkpXG4gICAgICAgIHRyYW5zcG9zZSh0cmFuc3Bvc2VEYXRhLFxuICAgICAgICAgIGRhdGEuZGF0YSxcbiAgICAgICAgICBzaGFwZVgsIHNoYXBlWSxcbiAgICAgICAgICBzdHJpZGVYLCBzdHJpZGVZLFxuICAgICAgICAgIGRhdGEub2Zmc2V0KVxuICAgICAgICBzZXRTdWJEYXRhKHRyYW5zcG9zZURhdGEsIG9mZnNldClcbiAgICAgICAgcG9vbC5mcmVlVHlwZSh0cmFuc3Bvc2VEYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBkYXRhIGZvciBidWZmZXIgc3ViZGF0YScpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVnbEJ1ZmZlclxuICAgIH1cblxuICAgIGlmICghZGVmZXJJbml0KSB7XG4gICAgICByZWdsQnVmZmVyKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmVnbEJ1ZmZlci5fcmVnbFR5cGUgPSAnYnVmZmVyJ1xuICAgIHJlZ2xCdWZmZXIuX2J1ZmZlciA9IGJ1ZmZlclxuICAgIHJlZ2xCdWZmZXIuc3ViZGF0YSA9IHN1YmRhdGFcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xCdWZmZXIuc3RhdHMgPSBidWZmZXIuc3RhdHNcbiAgICB9XG4gICAgcmVnbEJ1ZmZlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyBkZXN0cm95KGJ1ZmZlcikgfVxuXG4gICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVCdWZmZXJzICgpIHtcbiAgICB2YWx1ZXMoYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgIGJ1ZmZlci5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudHlwZSwgYnVmZmVyLmJ1ZmZlcilcbiAgICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGJ1ZmZlci50eXBlLCBidWZmZXIucGVyc2lzdGVudERhdGEgfHwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlci51c2FnZSlcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0VG90YWxCdWZmZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvdGFsID0gMFxuICAgICAgLy8gVE9ETzogUmlnaHQgbm93LCB0aGUgc3RyZWFtcyBhcmUgbm90IHBhcnQgb2YgdGhlIHRvdGFsIGNvdW50LlxuICAgICAgT2JqZWN0LmtleXMoYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdG90YWwgKz0gYnVmZmVyU2V0W2tleV0uc3RhdHMuc2l6ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlOiBjcmVhdGVCdWZmZXIsXG5cbiAgICBjcmVhdGVTdHJlYW06IGNyZWF0ZVN0cmVhbSxcbiAgICBkZXN0cm95U3RyZWFtOiBkZXN0cm95U3RyZWFtLFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhidWZmZXJTZXQpLmZvckVhY2goZGVzdHJveSlcbiAgICAgIHN0cmVhbVBvb2wuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG5cbiAgICBnZXRCdWZmZXI6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciAmJiB3cmFwcGVyLl9idWZmZXIgaW5zdGFuY2VvZiBSRUdMQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLl9idWZmZXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSxcblxuICAgIHJlc3RvcmU6IHJlc3RvcmVCdWZmZXJzLFxuXG4gICAgX2luaXRCdWZmZXI6IGluaXRCdWZmZXJGcm9tRGF0YVxuICB9XG59XG5cbnZhciBwb2ludHMgPSAwO1xudmFyIHBvaW50ID0gMDtcbnZhciBsaW5lcyA9IDE7XG52YXIgbGluZSA9IDE7XG52YXIgdHJpYW5nbGVzID0gNDtcbnZhciB0cmlhbmdsZSA9IDQ7XG52YXIgcHJpbVR5cGVzID0ge1xuXHRwb2ludHM6IHBvaW50cyxcblx0cG9pbnQ6IHBvaW50LFxuXHRsaW5lczogbGluZXMsXG5cdGxpbmU6IGxpbmUsXG5cdHRyaWFuZ2xlczogdHJpYW5nbGVzLFxuXHR0cmlhbmdsZTogdHJpYW5nbGUsXG5cdFwibGluZSBsb29wXCI6IDIsXG5cdFwibGluZSBzdHJpcFwiOiAzLFxuXHRcInRyaWFuZ2xlIHN0cmlwXCI6IDUsXG5cdFwidHJpYW5nbGUgZmFuXCI6IDZcbn07XG5cbnZhciBHTF9QT0lOVFMgPSAwXG52YXIgR0xfTElORVMgPSAxXG52YXIgR0xfVFJJQU5HTEVTID0gNFxuXG52YXIgR0xfQllURSQyID0gNTEyMFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNCA9IDUxMjFcbnZhciBHTF9TSE9SVCQyID0gNTEyMlxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDIgPSA1MTIzXG52YXIgR0xfSU5UJDIgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UJDIgPSA1MTI1XG5cbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiA9IDM0OTYzXG5cbnZhciBHTF9TVFJFQU1fRFJBVyQxID0gMHg4OEUwXG52YXIgR0xfU1RBVElDX0RSQVckMSA9IDB4ODhFNFxuXG5mdW5jdGlvbiB3cmFwRWxlbWVudHNTdGF0ZSAoZ2wsIGV4dGVuc2lvbnMsIGJ1ZmZlclN0YXRlLCBzdGF0cykge1xuICB2YXIgZWxlbWVudFNldCA9IHt9XG4gIHZhciBlbGVtZW50Q291bnQgPSAwXG5cbiAgdmFyIGVsZW1lbnRUeXBlcyA9IHtcbiAgICAndWludDgnOiBHTF9VTlNJR05FRF9CWVRFJDQsXG4gICAgJ3VpbnQxNic6IEdMX1VOU0lHTkVEX1NIT1JUJDJcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLm9lc19lbGVtZW50X2luZGV4X3VpbnQpIHtcbiAgICBlbGVtZW50VHlwZXMudWludDMyID0gR0xfVU5TSUdORURfSU5UJDJcbiAgfVxuXG4gIGZ1bmN0aW9uIFJFR0xFbGVtZW50QnVmZmVyIChidWZmZXIpIHtcbiAgICB0aGlzLmlkID0gZWxlbWVudENvdW50KytcbiAgICBlbGVtZW50U2V0W3RoaXMuaWRdID0gdGhpc1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyXG4gICAgdGhpcy5wcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgIHRoaXMudmVydENvdW50ID0gMFxuICAgIHRoaXMudHlwZSA9IDBcbiAgfVxuXG4gIFJFR0xFbGVtZW50QnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYnVmZmVyLmJpbmQoKVxuICB9XG5cbiAgdmFyIGJ1ZmZlclBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRTdHJlYW0gKGRhdGEpIHtcbiAgICB2YXIgcmVzdWx0ID0gYnVmZmVyUG9vbC5wb3AoKVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBuZXcgUkVHTEVsZW1lbnRCdWZmZXIoYnVmZmVyU3RhdGUuY3JlYXRlKFxuICAgICAgICBudWxsLFxuICAgICAgICBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UpLl9idWZmZXIpXG4gICAgfVxuICAgIGluaXRFbGVtZW50cyhyZXN1bHQsIGRhdGEsIEdMX1NUUkVBTV9EUkFXJDEsIC0xLCAtMSwgMCwgMClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95RWxlbWVudFN0cmVhbSAoZWxlbWVudHMpIHtcbiAgICBidWZmZXJQb29sLnB1c2goZWxlbWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0RWxlbWVudHMgKFxuICAgIGVsZW1lbnRzLFxuICAgIGRhdGEsXG4gICAgdXNhZ2UsXG4gICAgcHJpbSxcbiAgICBjb3VudCxcbiAgICBieXRlTGVuZ3RoLFxuICAgIHR5cGUpIHtcbiAgICBlbGVtZW50cy5idWZmZXIuYmluZCgpXG4gICAgdmFyIGR0eXBlXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHZhciBwcmVkaWN0ZWRUeXBlID0gdHlwZVxuICAgICAgaWYgKCF0eXBlICYmIChcbiAgICAgICAgIWlzVHlwZWRBcnJheShkYXRhKSB8fFxuICAgICAgICAgKGlzTkRBcnJheUxpa2UoZGF0YSkgJiYgIWlzVHlwZWRBcnJheShkYXRhLmRhdGEpKSkpIHtcbiAgICAgICAgcHJlZGljdGVkVHlwZSA9IGV4dGVuc2lvbnMub2VzX2VsZW1lbnRfaW5kZXhfdWludFxuICAgICAgICAgID8gR0xfVU5TSUdORURfSU5UJDJcbiAgICAgICAgICA6IEdMX1VOU0lHTkVEX1NIT1JUJDJcbiAgICAgIH1cbiAgICAgIGJ1ZmZlclN0YXRlLl9pbml0QnVmZmVyKFxuICAgICAgICBlbGVtZW50cy5idWZmZXIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHVzYWdlLFxuICAgICAgICBwcmVkaWN0ZWRUeXBlLFxuICAgICAgICAzKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5idWZmZXJEYXRhKEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCBieXRlTGVuZ3RoLCB1c2FnZSlcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgZWxlbWVudHMuYnVmZmVyLnVzYWdlID0gdXNhZ2VcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci5kaW1lbnNpb24gPSAzXG4gICAgICBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbiAgICB9XG5cbiAgICBkdHlwZSA9IHR5cGVcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbWVudHMuYnVmZmVyLmR0eXBlKSB7XG4gICAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQ0OlxuICAgICAgICBjYXNlIEdMX0JZVEUkMjpcbiAgICAgICAgICBkdHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQyOlxuICAgICAgICBjYXNlIEdMX1NIT1JUJDI6XG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9TSE9SVCQyXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0lOVCQyOlxuICAgICAgICBjYXNlIEdMX0lOVCQyOlxuICAgICAgICAgIGR0eXBlID0gR0xfVU5TSUdORURfSU5UJDJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2hlY2skMS5yYWlzZSgndW5zdXBwb3J0ZWQgdHlwZSBmb3IgZWxlbWVudCBhcnJheScpXG4gICAgICB9XG4gICAgICBlbGVtZW50cy5idWZmZXIuZHR5cGUgPSBkdHlwZVxuICAgIH1cbiAgICBlbGVtZW50cy50eXBlID0gZHR5cGVcblxuICAgIC8vIENoZWNrIG9lc19lbGVtZW50X2luZGV4X3VpbnQgZXh0ZW5zaW9uXG4gICAgY2hlY2skMShcbiAgICAgIGR0eXBlICE9PSBHTF9VTlNJR05FRF9JTlQkMiB8fFxuICAgICAgISFleHRlbnNpb25zLm9lc19lbGVtZW50X2luZGV4X3VpbnQsXG4gICAgICAnMzIgYml0IGVsZW1lbnQgYnVmZmVycyBub3Qgc3VwcG9ydGVkLCBlbmFibGUgb2VzX2VsZW1lbnRfaW5kZXhfdWludCBmaXJzdCcpXG5cbiAgICAvLyB0cnkgdG8gZ3Vlc3MgZGVmYXVsdCBwcmltaXRpdmUgdHlwZSBhbmQgYXJndW1lbnRzXG4gICAgdmFyIHZlcnRDb3VudCA9IGNvdW50XG4gICAgaWYgKHZlcnRDb3VudCA8IDApIHtcbiAgICAgIHZlcnRDb3VudCA9IGVsZW1lbnRzLmJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICBpZiAoZHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUJDIpIHtcbiAgICAgICAgdmVydENvdW50ID4+PSAxXG4gICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMikge1xuICAgICAgICB2ZXJ0Q291bnQgPj49IDJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudHMudmVydENvdW50ID0gdmVydENvdW50XG5cbiAgICAvLyB0cnkgdG8gZ3Vlc3MgcHJpbWl0aXZlIHR5cGUgZnJvbSBjZWxsIGRpbWVuc2lvblxuICAgIHZhciBwcmltVHlwZSA9IHByaW1cbiAgICBpZiAocHJpbSA8IDApIHtcbiAgICAgIHByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICB2YXIgZGltZW5zaW9uID0gZWxlbWVudHMuYnVmZmVyLmRpbWVuc2lvblxuICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gMSkgcHJpbVR5cGUgPSBHTF9QT0lOVFNcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDIpIHByaW1UeXBlID0gR0xfTElORVNcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDMpIHByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgfVxuICAgIGVsZW1lbnRzLnByaW1UeXBlID0gcHJpbVR5cGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lFbGVtZW50cyAoZWxlbWVudHMpIHtcbiAgICBzdGF0cy5lbGVtZW50c0NvdW50LS1cblxuICAgIGNoZWNrJDEoZWxlbWVudHMuYnVmZmVyICE9PSBudWxsLCAnbXVzdCBub3QgZG91YmxlIGRlc3Ryb3kgZWxlbWVudHMnKVxuICAgIGRlbGV0ZSBlbGVtZW50U2V0W2VsZW1lbnRzLmlkXVxuICAgIGVsZW1lbnRzLmJ1ZmZlci5kZXN0cm95KClcbiAgICBlbGVtZW50cy5idWZmZXIgPSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50cyAob3B0aW9ucywgcGVyc2lzdGVudCkge1xuICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5jcmVhdGUobnVsbCwgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRydWUpXG4gICAgdmFyIGVsZW1lbnRzID0gbmV3IFJFR0xFbGVtZW50QnVmZmVyKGJ1ZmZlci5fYnVmZmVyKVxuICAgIHN0YXRzLmVsZW1lbnRzQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbEVsZW1lbnRzIChvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgYnVmZmVyKClcbiAgICAgICAgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICAgICAgZWxlbWVudHMudmVydENvdW50ID0gMFxuICAgICAgICBlbGVtZW50cy50eXBlID0gR0xfVU5TSUdORURfQllURSQ0XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBidWZmZXIob3B0aW9ucylcbiAgICAgICAgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICAgICAgZWxlbWVudHMudmVydENvdW50ID0gb3B0aW9ucyB8IDBcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsXG4gICAgICAgIHZhciB1c2FnZSA9IEdMX1NUQVRJQ19EUkFXJDFcbiAgICAgICAgdmFyIHByaW1UeXBlID0gLTFcbiAgICAgICAgdmFyIHZlcnRDb3VudCA9IC0xXG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gMFxuICAgICAgICB2YXIgZHR5cGUgPSAwXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgICBpc1R5cGVkQXJyYXkob3B0aW9ucykgfHxcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2Uob3B0aW9ucykpIHtcbiAgICAgICAgICBkYXRhID0gb3B0aW9uc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJndW1lbnRzIGZvciBlbGVtZW50cycpXG4gICAgICAgICAgaWYgKCdkYXRhJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhXG4gICAgICAgICAgICBjaGVjayQxKFxuICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgaXNUeXBlZEFycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgaXNOREFycmF5TGlrZShkYXRhKSxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgZWxlbWVudCBidWZmZXInKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3VzYWdlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihcbiAgICAgICAgICAgICAgb3B0aW9ucy51c2FnZSxcbiAgICAgICAgICAgICAgdXNhZ2VUeXBlcyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgZWxlbWVudCBidWZmZXIgdXNhZ2UnKVxuICAgICAgICAgICAgdXNhZ2UgPSB1c2FnZVR5cGVzW29wdGlvbnMudXNhZ2VdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgncHJpbWl0aXZlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihcbiAgICAgICAgICAgICAgb3B0aW9ucy5wcmltaXRpdmUsXG4gICAgICAgICAgICAgIHByaW1UeXBlcyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgZWxlbWVudCBidWZmZXIgcHJpbWl0aXZlJylcbiAgICAgICAgICAgIHByaW1UeXBlID0gcHJpbVR5cGVzW29wdGlvbnMucHJpbWl0aXZlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2NvdW50JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjaGVjayQxKFxuICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jb3VudCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5jb3VudCA+PSAwLFxuICAgICAgICAgICAgICAnaW52YWxpZCB2ZXJ0ZXggY291bnQgZm9yIGVsZW1lbnRzJylcbiAgICAgICAgICAgIHZlcnRDb3VudCA9IG9wdGlvbnMuY291bnQgfCAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgZWxlbWVudFR5cGVzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBidWZmZXIgdHlwZScpXG4gICAgICAgICAgICBkdHlwZSA9IGVsZW1lbnRUeXBlc1tvcHRpb25zLnR5cGVdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfCAwXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB2ZXJ0Q291bnRcbiAgICAgICAgICAgIGlmIChkdHlwZSA9PT0gR0xfVU5TSUdORURfU0hPUlQkMiB8fCBkdHlwZSA9PT0gR0xfU0hPUlQkMikge1xuICAgICAgICAgICAgICBieXRlTGVuZ3RoICo9IDJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHR5cGUgPT09IEdMX1VOU0lHTkVEX0lOVCQyIHx8IGR0eXBlID09PSBHTF9JTlQkMikge1xuICAgICAgICAgICAgICBieXRlTGVuZ3RoICo9IDRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEVsZW1lbnRzKFxuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgcHJpbVR5cGUsXG4gICAgICAgICAgdmVydENvdW50LFxuICAgICAgICAgIGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZHR5cGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdsRWxlbWVudHNcbiAgICB9XG5cbiAgICByZWdsRWxlbWVudHMob3B0aW9ucylcblxuICAgIHJlZ2xFbGVtZW50cy5fcmVnbFR5cGUgPSAnZWxlbWVudHMnXG4gICAgcmVnbEVsZW1lbnRzLl9lbGVtZW50cyA9IGVsZW1lbnRzXG4gICAgcmVnbEVsZW1lbnRzLnN1YmRhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICBidWZmZXIuc3ViZGF0YShkYXRhLCBvZmZzZXQpXG4gICAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gICAgfVxuICAgIHJlZ2xFbGVtZW50cy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVzdHJveUVsZW1lbnRzKGVsZW1lbnRzKVxuICAgIH1cblxuICAgIHJldHVybiByZWdsRWxlbWVudHNcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlOiBjcmVhdGVFbGVtZW50cyxcbiAgICBjcmVhdGVTdHJlYW06IGNyZWF0ZUVsZW1lbnRTdHJlYW0sXG4gICAgZGVzdHJveVN0cmVhbTogZGVzdHJveUVsZW1lbnRTdHJlYW0sXG4gICAgZ2V0RWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIGVsZW1lbnRzLl9lbGVtZW50cyBpbnN0YW5jZW9mIFJFR0xFbGVtZW50QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5fZWxlbWVudHNcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFsdWVzKGVsZW1lbnRTZXQpLmZvckVhY2goZGVzdHJveUVsZW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgRkxPQVQgPSBuZXcgRmxvYXQzMkFycmF5KDEpXG52YXIgSU5UID0gbmV3IFVpbnQzMkFycmF5KEZMT0FULmJ1ZmZlcilcblxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDQgPSA1MTIzXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0hhbGZGbG9hdCAoYXJyYXkpIHtcbiAgdmFyIHVzaG9ydHMgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9TSE9SVCQ0LCBhcnJheS5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpc05hTihhcnJheVtpXSkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZmZmZcbiAgICB9IGVsc2UgaWYgKGFycmF5W2ldID09PSBJbmZpbml0eSkge1xuICAgICAgdXNob3J0c1tpXSA9IDB4N2MwMFxuICAgIH0gZWxzZSBpZiAoYXJyYXlbaV0gPT09IC1JbmZpbml0eSkge1xuICAgICAgdXNob3J0c1tpXSA9IDB4ZmMwMFxuICAgIH0gZWxzZSB7XG4gICAgICBGTE9BVFswXSA9IGFycmF5W2ldXG4gICAgICB2YXIgeCA9IElOVFswXVxuXG4gICAgICB2YXIgc2duID0gKHggPj4+IDMxKSA8PCAxNVxuICAgICAgdmFyIGV4cCA9ICgoeCA8PCAxKSA+Pj4gMjQpIC0gMTI3XG4gICAgICB2YXIgZnJhYyA9ICh4ID4+IDEzKSAmICgoMSA8PCAxMCkgLSAxKVxuXG4gICAgICBpZiAoZXhwIDwgLTI0KSB7XG4gICAgICAgIC8vIHJvdW5kIG5vbi1yZXByZXNlbnRhYmxlIGRlbm9ybWFscyB0byAwXG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ25cbiAgICAgIH0gZWxzZSBpZiAoZXhwIDwgLTE0KSB7XG4gICAgICAgIC8vIGhhbmRsZSBkZW5vcm1hbHNcbiAgICAgICAgdmFyIHMgPSAtMTQgLSBleHBcbiAgICAgICAgdXNob3J0c1tpXSA9IHNnbiArICgoZnJhYyArICgxIDw8IDEwKSkgPj4gcylcbiAgICAgIH0gZWxzZSBpZiAoZXhwID4gMTUpIHtcbiAgICAgICAgLy8gcm91bmQgb3ZlcmZsb3cgdG8gKy8tIEluZmluaXR5XG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAweDdjMDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBjb252ZXJ0IGRpcmVjdGx5XG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAoKGV4cCArIDE1KSA8PCAxMCkgKyBmcmFjXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVzaG9ydHNcbn1cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UgKHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgfHwgaXNUeXBlZEFycmF5KHMpXG59XG5cbnZhciBpc1BvdzIkMSA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxufVxuXG52YXIgR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgPSAweDg2QTNcblxudmFyIEdMX1RFWFRVUkVfMkQkMSA9IDB4MERFMVxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVAkMSA9IDB4ODUxM1xudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxID0gMHg4NTE1XG5cbnZhciBHTF9SR0JBJDEgPSAweDE5MDhcbnZhciBHTF9BTFBIQSA9IDB4MTkwNlxudmFyIEdMX1JHQiA9IDB4MTkwN1xudmFyIEdMX0xVTUlOQU5DRSA9IDB4MTkwOVxudmFyIEdMX0xVTUlOQU5DRV9BTFBIQSA9IDB4MTkwQVxuXG52YXIgR0xfUkdCQTQgPSAweDgwNTZcbnZhciBHTF9SR0I1X0ExID0gMHg4MDU3XG52YXIgR0xfUkdCNTY1ID0gMHg4RDYyXG5cbnZhciBHTF9VTlNJR05FRF9TSE9SVF80XzRfNF80JDEgPSAweDgwMzNcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzVfNV8xJDEgPSAweDgwMzRcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSQxID0gMHg4MzYzXG52YXIgR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wkMSA9IDB4ODRGQVxuXG52YXIgR0xfREVQVEhfQ09NUE9ORU5UID0gMHgxOTAyXG52YXIgR0xfREVQVEhfU1RFTkNJTCA9IDB4ODRGOVxuXG52YXIgR0xfU1JHQl9FWFQgPSAweDhDNDBcbnZhciBHTF9TUkdCX0FMUEhBX0VYVCA9IDB4OEM0MlxuXG52YXIgR0xfSEFMRl9GTE9BVF9PRVMkMSA9IDB4OEQ2MVxuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMFxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUID0gMHg4M0YxXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgPSAweDgzRjJcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCA9IDB4ODNGM1xuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMID0gMHg4QzkyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCA9IDB4OEM5M1xudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMID0gMHg4N0VFXG5cbnZhciBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HID0gMHg4QzAwXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyA9IDB4OEMwMVxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HID0gMHg4QzAyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUcgPSAweDhDMDNcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgPSAweDhENjRcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNSA9IDB4MTQwMVxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDMgPSAweDE0MDNcbnZhciBHTF9VTlNJR05FRF9JTlQkMyA9IDB4MTQwNVxudmFyIEdMX0ZMT0FUJDQgPSAweDE0MDZcblxudmFyIEdMX1RFWFRVUkVfV1JBUF9TID0gMHgyODAyXG52YXIgR0xfVEVYVFVSRV9XUkFQX1QgPSAweDI4MDNcblxudmFyIEdMX1JFUEVBVCA9IDB4MjkwMVxudmFyIEdMX0NMQU1QX1RPX0VER0UkMSA9IDB4ODEyRlxudmFyIEdMX01JUlJPUkVEX1JFUEVBVCA9IDB4ODM3MFxuXG52YXIgR0xfVEVYVFVSRV9NQUdfRklMVEVSID0gMHgyODAwXG52YXIgR0xfVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxXG5cbnZhciBHTF9ORUFSRVNUJDEgPSAweDI2MDBcbnZhciBHTF9MSU5FQVIgPSAweDI2MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUJDEgPSAweDI3MDBcbnZhciBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QkMSA9IDB4MjcwMVxudmFyIEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxID0gMHgyNzAyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMSA9IDB4MjcwM1xuXG52YXIgR0xfR0VORVJBVEVfTUlQTUFQX0hJTlQgPSAweDgxOTJcbnZhciBHTF9ET05UX0NBUkUgPSAweDExMDBcbnZhciBHTF9GQVNURVNUID0gMHgxMTAxXG52YXIgR0xfTklDRVNUID0gMHgxMTAyXG5cbnZhciBHTF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRVxuXG52YXIgR0xfVU5QQUNLX0FMSUdOTUVOVCA9IDB4MENGNVxudmFyIEdMX1VOUEFDS19GTElQX1lfV0VCR0wgPSAweDkyNDBcbnZhciBHTF9VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wgPSAweDkyNDFcbnZhciBHTF9VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMID0gMHg5MjQzXG5cbnZhciBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0wgPSAweDkyNDRcblxudmFyIEdMX1RFWFRVUkUwJDEgPSAweDg0QzBcblxudmFyIE1JUE1BUF9GSUxURVJTID0gW1xuICBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUJDEsXG4gIEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxLFxuICBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QkMSxcbiAgR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMVxuXVxuXG52YXIgQ0hBTk5FTFNfRk9STUFUID0gW1xuICAwLFxuICBHTF9MVU1JTkFOQ0UsXG4gIEdMX0xVTUlOQU5DRV9BTFBIQSxcbiAgR0xfUkdCLFxuICBHTF9SR0JBJDFcbl1cblxudmFyIEZPUk1BVF9DSEFOTkVMUyA9IHt9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfTFVNSU5BTkNFXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfQUxQSEFdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9ERVBUSF9DT01QT05FTlRdID0gMVxuRk9STUFUX0NIQU5ORUxTW0dMX0RFUFRIX1NURU5DSUxdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9MVU1JTkFOQ0VfQUxQSEFdID0gMlxuRk9STUFUX0NIQU5ORUxTW0dMX1JHQl0gPVxuRk9STUFUX0NIQU5ORUxTW0dMX1NSR0JfRVhUXSA9IDNcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JBJDFdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9TUkdCX0FMUEhBX0VYVF0gPSA0XG5cbmZ1bmN0aW9uIG9iamVjdE5hbWUgKHN0cikge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIHN0ciArICddJ1xufVxuXG52YXIgQ0FOVkFTX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTENhbnZhc0VsZW1lbnQnKVxudmFyIE9GRlNDUkVFTkNBTlZBU19DTEFTUyA9IG9iamVjdE5hbWUoJ09mZnNjcmVlbkNhbnZhcycpXG52YXIgQ09OVEVYVDJEX0NMQVNTID0gb2JqZWN0TmFtZSgnQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEJylcbnZhciBCSVRNQVBfQ0xBU1MgPSBvYmplY3ROYW1lKCdJbWFnZUJpdG1hcCcpXG52YXIgSU1BR0VfQ0xBU1MgPSBvYmplY3ROYW1lKCdIVE1MSW1hZ2VFbGVtZW50JylcbnZhciBWSURFT19DTEFTUyA9IG9iamVjdE5hbWUoJ0hUTUxWaWRlb0VsZW1lbnQnKVxuXG52YXIgUElYRUxfQ0xBU1NFUyA9IE9iamVjdC5rZXlzKGFycmF5VHlwZXMpLmNvbmNhdChbXG4gIENBTlZBU19DTEFTUyxcbiAgT0ZGU0NSRUVOQ0FOVkFTX0NMQVNTLFxuICBDT05URVhUMkRfQ0xBU1MsXG4gIEJJVE1BUF9DTEFTUyxcbiAgSU1BR0VfQ0xBU1MsXG4gIFZJREVPX0NMQVNTXG5dKVxuXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSB0eXBlLCBzdG9yZVxuLy8gdGhlIHNpemUgaW4gYnl0ZXMuXG52YXIgVFlQRV9TSVpFUyA9IFtdXG5UWVBFX1NJWkVTW0dMX1VOU0lHTkVEX0JZVEUkNV0gPSAxXG5UWVBFX1NJWkVTW0dMX0ZMT0FUJDRdID0gNFxuVFlQRV9TSVpFU1tHTF9IQUxGX0ZMT0FUX09FUyQxXSA9IDJcblxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9TSE9SVCQzXSA9IDJcblRZUEVfU0laRVNbR0xfVU5TSUdORURfSU5UJDNdID0gNFxuXG52YXIgRk9STUFUX1NJWkVTX1NQRUNJQUwgPSBbXVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfUkdCQTRdID0gMlxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfUkdCNV9BMV0gPSAyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9SR0I1NjVdID0gMlxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfREVQVEhfU1RFTkNJTF0gPSA0XG5cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRdID0gMC41XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVF0gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUXSA9IDFcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXSA9IDFcblxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTF0gPSAxXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTF0gPSAxXG5cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUddID0gMC41XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXSA9IDAuMjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUddID0gMC4yNVxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMXSA9IDAuNVxuXG5mdW5jdGlvbiBpc051bWVyaWNBcnJheSAoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhcnIpICYmXG4gICAgKGFyci5sZW5ndGggPT09IDAgfHxcbiAgICB0eXBlb2YgYXJyWzBdID09PSAnbnVtYmVyJykpXG59XG5cbmZ1bmN0aW9uIGlzUmVjdEFycmF5IChhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgd2lkdGggPSBhcnIubGVuZ3RoXG4gIGlmICh3aWR0aCA9PT0gMCB8fCAhaXNBcnJheUxpa2UoYXJyWzBdKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNsYXNzU3RyaW5nICh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeClcbn1cblxuZnVuY3Rpb24gaXNDYW52YXNFbGVtZW50IChvYmplY3QpIHtcbiAgcmV0dXJuIGNsYXNzU3RyaW5nKG9iamVjdCkgPT09IENBTlZBU19DTEFTU1xufVxuXG5mdW5jdGlvbiBpc09mZnNjcmVlbkNhbnZhcyAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBPRkZTQ1JFRU5DQU5WQVNfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0MkQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gQ09OVEVYVDJEX0NMQVNTXG59XG5cbmZ1bmN0aW9uIGlzQml0bWFwIChvYmplY3QpIHtcbiAgcmV0dXJuIGNsYXNzU3RyaW5nKG9iamVjdCkgPT09IEJJVE1BUF9DTEFTU1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBJTUFHRV9DTEFTU1xufVxuXG5mdW5jdGlvbiBpc1ZpZGVvRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBWSURFT19DTEFTU1xufVxuXG5mdW5jdGlvbiBpc1BpeGVsRGF0YSAob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzU3RyaW5nKG9iamVjdClcbiAgaWYgKFBJWEVMX0NMQVNTRVMuaW5kZXhPZihjbGFzc05hbWUpID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAoXG4gICAgaXNOdW1lcmljQXJyYXkob2JqZWN0KSB8fFxuICAgIGlzUmVjdEFycmF5KG9iamVjdCkgfHxcbiAgICBpc05EQXJyYXlMaWtlKG9iamVjdCkpXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlDb2RlJDEgKGRhdGEpIHtcbiAgcmV0dXJuIGFycmF5VHlwZXNbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpXSB8IDBcbn1cblxuZnVuY3Rpb24gY29udmVydERhdGEgKHJlc3VsdCwgZGF0YSkge1xuICB2YXIgbiA9IGRhdGEubGVuZ3RoXG4gIHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiAgICBjYXNlIEdMX1VOU0lHTkVEX0JZVEUkNTpcbiAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUJDM6XG4gICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMzpcbiAgICBjYXNlIEdMX0ZMT0FUJDQ6XG4gICAgICB2YXIgY29udmVydGVkID0gcG9vbC5hbGxvY1R5cGUocmVzdWx0LnR5cGUsIG4pXG4gICAgICBjb252ZXJ0ZWQuc2V0KGRhdGEpXG4gICAgICByZXN1bHQuZGF0YSA9IGNvbnZlcnRlZFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgR0xfSEFMRl9GTE9BVF9PRVMkMTpcbiAgICAgIHJlc3VsdC5kYXRhID0gY29udmVydFRvSGFsZkZsb2F0KGRhdGEpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNoZWNrJDEucmFpc2UoJ3Vuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSwgbXVzdCBzcGVjaWZ5IGEgdHlwZWQgYXJyYXknKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZUNvbnZlcnQgKGltYWdlLCBuKSB7XG4gIHJldHVybiBwb29sLmFsbG9jVHlwZShcbiAgICBpbWFnZS50eXBlID09PSBHTF9IQUxGX0ZMT0FUX09FUyQxXG4gICAgICA/IEdMX0ZMT0FUJDRcbiAgICAgIDogaW1hZ2UudHlwZSwgbilcbn1cblxuZnVuY3Rpb24gcG9zdENvbnZlcnQgKGltYWdlLCBkYXRhKSB7XG4gIGlmIChpbWFnZS50eXBlID09PSBHTF9IQUxGX0ZMT0FUX09FUyQxKSB7XG4gICAgaW1hZ2UuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChkYXRhKVxuICAgIHBvb2wuZnJlZVR5cGUoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICBpbWFnZS5kYXRhID0gZGF0YVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zcG9zZURhdGEgKGltYWdlLCBhcnJheSwgc3RyaWRlWCwgc3RyaWRlWSwgc3RyaWRlQywgb2Zmc2V0KSB7XG4gIHZhciB3ID0gaW1hZ2Uud2lkdGhcbiAgdmFyIGggPSBpbWFnZS5oZWlnaHRcbiAgdmFyIGMgPSBpbWFnZS5jaGFubmVsc1xuICB2YXIgbiA9IHcgKiBoICogY1xuICB2YXIgZGF0YSA9IHByZUNvbnZlcnQoaW1hZ2UsIG4pXG5cbiAgdmFyIHAgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaDsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB3OyArK2opIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYzsgKytrKSB7XG4gICAgICAgIGRhdGFbcCsrXSA9IGFycmF5W3N0cmlkZVggKiBqICsgc3RyaWRlWSAqIGkgKyBzdHJpZGVDICogayArIG9mZnNldF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwb3N0Q29udmVydChpbWFnZSwgZGF0YSlcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVNpemUgKGZvcm1hdCwgdHlwZSwgd2lkdGgsIGhlaWdodCwgaXNNaXBtYXAsIGlzQ3ViZSkge1xuICB2YXIgc1xuICBpZiAodHlwZW9mIEZPUk1BVF9TSVpFU19TUEVDSUFMW2Zvcm1hdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd2UgaGF2ZSBhIHNwZWNpYWwgYXJyYXkgZm9yIGRlYWxpbmcgd2l0aCB3ZWlyZCBjb2xvciBmb3JtYXRzIHN1Y2ggYXMgUkdCNUExXG4gICAgcyA9IEZPUk1BVF9TSVpFU19TUEVDSUFMW2Zvcm1hdF1cbiAgfSBlbHNlIHtcbiAgICBzID0gRk9STUFUX0NIQU5ORUxTW2Zvcm1hdF0gKiBUWVBFX1NJWkVTW3R5cGVdXG4gIH1cblxuICBpZiAoaXNDdWJlKSB7XG4gICAgcyAqPSA2XG4gIH1cblxuICBpZiAoaXNNaXBtYXApIHtcbiAgICAvLyBjb21wdXRlIHRoZSB0b3RhbCBzaXplIG9mIGFsbCB0aGUgbWlwbWFwcy5cbiAgICB2YXIgdG90YWwgPSAwXG5cbiAgICB2YXIgdyA9IHdpZHRoXG4gICAgd2hpbGUgKHcgPj0gMSkge1xuICAgICAgLy8gd2UgY2FuIG9ubHkgdXNlIG1pcG1hcHMgb24gYSBzcXVhcmUgaW1hZ2UsXG4gICAgICAvLyBzbyB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgd2lkdGggYW5kIGlnbm9yZSB0aGUgaGVpZ2h0OlxuICAgICAgdG90YWwgKz0gcyAqIHcgKiB3XG4gICAgICB3IC89IDJcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHMgKiB3aWR0aCAqIGhlaWdodFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVTZXQgKFxuICBnbCwgZXh0ZW5zaW9ucywgbGltaXRzLCByZWdsUG9sbCwgY29udGV4dFN0YXRlLCBzdGF0cywgY29uZmlnKSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSW5pdGlhbGl6ZSBjb25zdGFudHMgYW5kIHBhcmFtZXRlciB0YWJsZXMgaGVyZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBtaXBtYXBIaW50ID0ge1xuICAgIFwiZG9uJ3QgY2FyZVwiOiBHTF9ET05UX0NBUkUsXG4gICAgJ2RvbnQgY2FyZSc6IEdMX0RPTlRfQ0FSRSxcbiAgICAnbmljZSc6IEdMX05JQ0VTVCxcbiAgICAnZmFzdCc6IEdMX0ZBU1RFU1RcbiAgfVxuXG4gIHZhciB3cmFwTW9kZXMgPSB7XG4gICAgJ3JlcGVhdCc6IEdMX1JFUEVBVCxcbiAgICAnY2xhbXAnOiBHTF9DTEFNUF9UT19FREdFJDEsXG4gICAgJ21pcnJvcic6IEdMX01JUlJPUkVEX1JFUEVBVFxuICB9XG5cbiAgdmFyIG1hZ0ZpbHRlcnMgPSB7XG4gICAgJ25lYXJlc3QnOiBHTF9ORUFSRVNUJDEsXG4gICAgJ2xpbmVhcic6IEdMX0xJTkVBUlxuICB9XG5cbiAgdmFyIG1pbkZpbHRlcnMgPSBleHRlbmQoe1xuICAgICdtaXBtYXAnOiBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUiQxLFxuICAgICduZWFyZXN0IG1pcG1hcCBuZWFyZXN0JzogR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxLFxuICAgICdsaW5lYXIgbWlwbWFwIG5lYXJlc3QnOiBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QkMSxcbiAgICAnbmVhcmVzdCBtaXBtYXAgbGluZWFyJzogR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSJDEsXG4gICAgJ2xpbmVhciBtaXBtYXAgbGluZWFyJzogR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMVxuICB9LCBtYWdGaWx0ZXJzKVxuXG4gIHZhciBjb2xvclNwYWNlID0ge1xuICAgICdub25lJzogMCxcbiAgICAnYnJvd3Nlcic6IEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTFxuICB9XG5cbiAgdmFyIHRleHR1cmVUeXBlcyA9IHtcbiAgICAndWludDgnOiBHTF9VTlNJR05FRF9CWVRFJDUsXG4gICAgJ3JnYmE0JzogR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCQxLFxuICAgICdyZ2I1NjUnOiBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSQxLFxuICAgICdyZ2I1IGExJzogR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSQxXG4gIH1cblxuICB2YXIgdGV4dHVyZUZvcm1hdHMgPSB7XG4gICAgJ2FscGhhJzogR0xfQUxQSEEsXG4gICAgJ2x1bWluYW5jZSc6IEdMX0xVTUlOQU5DRSxcbiAgICAnbHVtaW5hbmNlIGFscGhhJzogR0xfTFVNSU5BTkNFX0FMUEhBLFxuICAgICdyZ2InOiBHTF9SR0IsXG4gICAgJ3JnYmEnOiBHTF9SR0JBJDEsXG4gICAgJ3JnYmE0JzogR0xfUkdCQTQsXG4gICAgJ3JnYjUgYTEnOiBHTF9SR0I1X0ExLFxuICAgICdyZ2I1NjUnOiBHTF9SR0I1NjVcbiAgfVxuXG4gIHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSB7fVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XG4gICAgdGV4dHVyZUZvcm1hdHMuc3JnYiA9IEdMX1NSR0JfRVhUXG4gICAgdGV4dHVyZUZvcm1hdHMuc3JnYmEgPSBHTF9TUkdCX0FMUEhBX0VYVFxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICB0ZXh0dXJlVHlwZXMuZmxvYXQzMiA9IHRleHR1cmVUeXBlcy5mbG9hdCA9IEdMX0ZMT0FUJDRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcbiAgICB0ZXh0dXJlVHlwZXNbJ2Zsb2F0MTYnXSA9IHRleHR1cmVUeXBlc1snaGFsZiBmbG9hdCddID0gR0xfSEFMRl9GTE9BVF9PRVMkMVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfZGVwdGhfdGV4dHVyZSkge1xuICAgIGV4dGVuZCh0ZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ2RlcHRoJzogR0xfREVQVEhfQ09NUE9ORU5ULFxuICAgICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMXG4gICAgfSlcblxuICAgIGV4dGVuZCh0ZXh0dXJlVHlwZXMsIHtcbiAgICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQzLFxuICAgICAgJ3VpbnQzMic6IEdMX1VOU0lHTkVEX0lOVCQzLFxuICAgICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCQxXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjKSB7XG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBzM3RjIGR4dDEnOiBHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhULFxuICAgICAgJ3JnYmEgczN0YyBkeHQxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQsXG4gICAgICAncmdiYSBzM3RjIGR4dDMnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgICAgICdyZ2JhIHMzdGMgZHh0NSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMpIHtcbiAgICBleHRlbmQoY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLCB7XG4gICAgICAncmdiIGF0Yyc6IEdMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTCxcbiAgICAgICdyZ2JhIGF0YyBleHBsaWNpdCBhbHBoYSc6IEdMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0wsXG4gICAgICAncmdiYSBhdGMgaW50ZXJwb2xhdGVkIGFscGhhJzogR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xcbiAgICB9KVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjKSB7XG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBwdnJ0YyA0YnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HLFxuICAgICAgJ3JnYiBwdnJ0YyAyYnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HLFxuICAgICAgJ3JnYmEgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcsXG4gICAgICAncmdiYSBwdnJ0YyAyYnBwdjEnOiBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR1xuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSkge1xuICAgIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0c1sncmdiIGV0YzEnXSA9IEdMX0NPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcbiAgfVxuXG4gIC8vIENvcHkgb3ZlciBhbGwgdGV4dHVyZSBmb3JtYXRzXG4gIHZhciBzdXBwb3J0ZWRDb21wcmVzc2VkRm9ybWF0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgIGdsLmdldFBhcmFtZXRlcihHTF9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUykpXG4gIE9iamVjdC5rZXlzKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBmb3JtYXQgPSBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHNbbmFtZV1cbiAgICBpZiAoc3VwcG9ydGVkQ29tcHJlc3NlZEZvcm1hdHMuaW5kZXhPZihmb3JtYXQpID49IDApIHtcbiAgICAgIHRleHR1cmVGb3JtYXRzW25hbWVdID0gZm9ybWF0XG4gICAgfVxuICB9KVxuXG4gIHZhciBzdXBwb3J0ZWRGb3JtYXRzID0gT2JqZWN0LmtleXModGV4dHVyZUZvcm1hdHMpXG4gIGxpbWl0cy50ZXh0dXJlRm9ybWF0cyA9IHN1cHBvcnRlZEZvcm1hdHNcblxuICAvLyBhc3NvY2lhdGUgd2l0aCBldmVyeSBmb3JtYXQgc3RyaW5nIGl0c1xuICAvLyBjb3JyZXNwb25kaW5nIEdMLXZhbHVlLlxuICB2YXIgdGV4dHVyZUZvcm1hdHNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyh0ZXh0dXJlRm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IHRleHR1cmVGb3JtYXRzW2tleV1cbiAgICB0ZXh0dXJlRm9ybWF0c0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgdHlwZSBzdHJpbmcgaXRzXG4gIC8vIGNvcnJlc3BvbmRpbmcgR0wtdmFsdWUuXG4gIHZhciB0ZXh0dXJlVHlwZXNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyh0ZXh0dXJlVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB0ZXh0dXJlVHlwZXNba2V5XVxuICAgIHRleHR1cmVUeXBlc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgdmFyIG1hZ0ZpbHRlcnNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyhtYWdGaWx0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gbWFnRmlsdGVyc1trZXldXG4gICAgbWFnRmlsdGVyc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgdmFyIG1pbkZpbHRlcnNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyhtaW5GaWx0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gbWluRmlsdGVyc1trZXldXG4gICAgbWluRmlsdGVyc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgdmFyIHdyYXBNb2Rlc0ludmVydCA9IFtdXG4gIE9iamVjdC5rZXlzKHdyYXBNb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IHdyYXBNb2Rlc1trZXldXG4gICAgd3JhcE1vZGVzSW52ZXJ0W3ZhbF0gPSBrZXlcbiAgfSlcblxuICAvLyBjb2xvckZvcm1hdHNbXSBnaXZlcyB0aGUgZm9ybWF0IChjaGFubmVscykgYXNzb2NpYXRlZCB0byBhblxuICAvLyBpbnRlcm5hbGZvcm1hdFxuICB2YXIgY29sb3JGb3JtYXRzID0gc3VwcG9ydGVkRm9ybWF0cy5yZWR1Y2UoZnVuY3Rpb24gKGNvbG9yLCBrZXkpIHtcbiAgICB2YXIgZ2xlbnVtID0gdGV4dHVyZUZvcm1hdHNba2V5XVxuICAgIGlmIChnbGVudW0gPT09IEdMX0xVTUlOQU5DRSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0FMUEhBIHx8XG4gICAgICAgIGdsZW51bSA9PT0gR0xfTFVNSU5BTkNFIHx8XG4gICAgICAgIGdsZW51bSA9PT0gR0xfTFVNSU5BTkNFX0FMUEhBIHx8XG4gICAgICAgIGdsZW51bSA9PT0gR0xfREVQVEhfQ09NUE9ORU5UIHx8XG4gICAgICAgIGdsZW51bSA9PT0gR0xfREVQVEhfU1RFTkNJTCB8fFxuICAgICAgICAoZXh0ZW5zaW9ucy5leHRfc3JnYiAmJlxuICAgICAgICAgICAgICAgIChnbGVudW0gPT09IEdMX1NSR0JfRVhUIHx8XG4gICAgICAgICAgICAgICAgIGdsZW51bSA9PT0gR0xfU1JHQl9BTFBIQV9FWFQpKSkge1xuICAgICAgY29sb3JbZ2xlbnVtXSA9IGdsZW51bVxuICAgIH0gZWxzZSBpZiAoZ2xlbnVtID09PSBHTF9SR0I1X0ExIHx8IGtleS5pbmRleE9mKCdyZ2JhJykgPj0gMCkge1xuICAgICAgY29sb3JbZ2xlbnVtXSA9IEdMX1JHQkEkMVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvcltnbGVudW1dID0gR0xfUkdCXG4gICAgfVxuICAgIHJldHVybiBjb2xvclxuICB9LCB7fSlcblxuICBmdW5jdGlvbiBUZXhGbGFncyAoKSB7XG4gICAgLy8gZm9ybWF0IGluZm9cbiAgICB0aGlzLmludGVybmFsZm9ybWF0ID0gR0xfUkdCQSQxXG4gICAgdGhpcy5mb3JtYXQgPSBHTF9SR0JBJDFcbiAgICB0aGlzLnR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDVcbiAgICB0aGlzLmNvbXByZXNzZWQgPSBmYWxzZVxuXG4gICAgLy8gcGl4ZWwgc3RvcmFnZVxuICAgIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlXG4gICAgdGhpcy5mbGlwWSA9IGZhbHNlXG4gICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxXG4gICAgdGhpcy5jb2xvclNwYWNlID0gR0xfQlJPV1NFUl9ERUZBVUxUX1dFQkdMXG5cbiAgICAvLyBzaGFwZSBpbmZvXG4gICAgdGhpcy53aWR0aCA9IDBcbiAgICB0aGlzLmhlaWdodCA9IDBcbiAgICB0aGlzLmNoYW5uZWxzID0gMFxuICB9XG5cbiAgZnVuY3Rpb24gY29weUZsYWdzIChyZXN1bHQsIG90aGVyKSB7XG4gICAgcmVzdWx0LmludGVybmFsZm9ybWF0ID0gb3RoZXIuaW50ZXJuYWxmb3JtYXRcbiAgICByZXN1bHQuZm9ybWF0ID0gb3RoZXIuZm9ybWF0XG4gICAgcmVzdWx0LnR5cGUgPSBvdGhlci50eXBlXG4gICAgcmVzdWx0LmNvbXByZXNzZWQgPSBvdGhlci5jb21wcmVzc2VkXG5cbiAgICByZXN1bHQucHJlbXVsdGlwbHlBbHBoYSA9IG90aGVyLnByZW11bHRpcGx5QWxwaGFcbiAgICByZXN1bHQuZmxpcFkgPSBvdGhlci5mbGlwWVxuICAgIHJlc3VsdC51bnBhY2tBbGlnbm1lbnQgPSBvdGhlci51bnBhY2tBbGlnbm1lbnRcbiAgICByZXN1bHQuY29sb3JTcGFjZSA9IG90aGVyLmNvbG9yU3BhY2VcblxuICAgIHJlc3VsdC53aWR0aCA9IG90aGVyLndpZHRoXG4gICAgcmVzdWx0LmhlaWdodCA9IG90aGVyLmhlaWdodFxuICAgIHJlc3VsdC5jaGFubmVscyA9IG90aGVyLmNoYW5uZWxzXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZsYWdzIChmbGFncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgIW9wdGlvbnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgncHJlbXVsdGlwbHlBbHBoYScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSwgJ2Jvb2xlYW4nLFxuICAgICAgICAnaW52YWxpZCBwcmVtdWx0aXBseUFscGhhJylcbiAgICAgIGZsYWdzLnByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGFcbiAgICB9XG5cbiAgICBpZiAoJ2ZsaXBZJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLnR5cGUob3B0aW9ucy5mbGlwWSwgJ2Jvb2xlYW4nLFxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIGZsaXAnKVxuICAgICAgZmxhZ3MuZmxpcFkgPSBvcHRpb25zLmZsaXBZXG4gICAgfVxuXG4gICAgaWYgKCdhbGlnbm1lbnQnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEub25lT2Yob3B0aW9ucy5hbGlnbm1lbnQsIFsxLCAyLCA0LCA4XSxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSB1bnBhY2sgYWxpZ25tZW50JylcbiAgICAgIGZsYWdzLnVucGFja0FsaWdubWVudCA9IG9wdGlvbnMuYWxpZ25tZW50XG4gICAgfVxuXG4gICAgaWYgKCdjb2xvclNwYWNlJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLmNvbG9yU3BhY2UsIGNvbG9yU3BhY2UsXG4gICAgICAgICdpbnZhbGlkIGNvbG9yU3BhY2UnKVxuICAgICAgZmxhZ3MuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2Vbb3B0aW9ucy5jb2xvclNwYWNlXVxuICAgIH1cblxuICAgIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGVcbiAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCB8fFxuICAgICAgICAhKHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2Zsb2F0MzInKSxcbiAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIE9FU190ZXh0dXJlX2Zsb2F0IGV4dGVuc2lvbiBpbiBvcmRlciB0byB1c2UgZmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMuJylcbiAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IHx8XG4gICAgICAgICEodHlwZSA9PT0gJ2hhbGYgZmxvYXQnIHx8IHR5cGUgPT09ICdmbG9hdDE2JyksXG4gICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0IGV4dGVuc2lvbiBpbiBvcmRlciB0byB1c2UgMTYtYml0IGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMud2ViZ2xfZGVwdGhfdGV4dHVyZSB8fFxuICAgICAgICAhKHR5cGUgPT09ICd1aW50MTYnIHx8IHR5cGUgPT09ICd1aW50MzInIHx8IHR5cGUgPT09ICdkZXB0aCBzdGVuY2lsJyksXG4gICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBXRUJHTF9kZXB0aF90ZXh0dXJlIGV4dGVuc2lvbiBpbiBvcmRlciB0byB1c2UgZGVwdGgvc3RlbmNpbCB0ZXh0dXJlcy4nKVxuICAgICAgY2hlY2skMS5wYXJhbWV0ZXIodHlwZSwgdGV4dHVyZVR5cGVzLFxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnKVxuICAgICAgZmxhZ3MudHlwZSA9IHRleHR1cmVUeXBlc1t0eXBlXVxuICAgIH1cblxuICAgIHZhciB3ID0gZmxhZ3Mud2lkdGhcbiAgICB2YXIgaCA9IGZsYWdzLmhlaWdodFxuICAgIHZhciBjID0gZmxhZ3MuY2hhbm5lbHNcbiAgICB2YXIgaGFzQ2hhbm5lbHMgPSBmYWxzZVxuICAgIGlmICgnc2hhcGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShvcHRpb25zLnNoYXBlKSAmJiBvcHRpb25zLnNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAnc2hhcGUgbXVzdCBiZSBhbiBhcnJheScpXG4gICAgICB3ID0gb3B0aW9ucy5zaGFwZVswXVxuICAgICAgaCA9IG9wdGlvbnMuc2hhcGVbMV1cbiAgICAgIGlmIChvcHRpb25zLnNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjID0gb3B0aW9ucy5zaGFwZVsyXVxuICAgICAgICBjaGVjayQxKGMgPiAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzJylcbiAgICAgICAgaGFzQ2hhbm5lbHMgPSB0cnVlXG4gICAgICB9XG4gICAgICBjaGVjayQxKHcgPj0gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSwgJ2ludmFsaWQgd2lkdGgnKVxuICAgICAgY2hlY2skMShoID49IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIGhlaWdodCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHcgPSBoID0gb3B0aW9ucy5yYWRpdXNcbiAgICAgICAgY2hlY2skMSh3ID49IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIHJhZGl1cycpXG4gICAgICB9XG4gICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHcgPSBvcHRpb25zLndpZHRoXG4gICAgICAgIGNoZWNrJDEodyA+PSAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCB3aWR0aCcpXG4gICAgICB9XG4gICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICBoID0gb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgY2hlY2skMShoID49IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIGhlaWdodCcpXG4gICAgICB9XG4gICAgICBpZiAoJ2NoYW5uZWxzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGMgPSBvcHRpb25zLmNoYW5uZWxzXG4gICAgICAgIGNoZWNrJDEoYyA+IDAgJiYgYyA8PSA0LCAnaW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHMnKVxuICAgICAgICBoYXNDaGFubmVscyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgZmxhZ3Mud2lkdGggPSB3IHwgMFxuICAgIGZsYWdzLmhlaWdodCA9IGggfCAwXG4gICAgZmxhZ3MuY2hhbm5lbHMgPSBjIHwgMFxuXG4gICAgdmFyIGhhc0Zvcm1hdCA9IGZhbHNlXG4gICAgaWYgKCdmb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBmb3JtYXRTdHIgPSBvcHRpb25zLmZvcm1hdFxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcbiAgICAgICAgIShmb3JtYXRTdHIgPT09ICdkZXB0aCcgfHwgZm9ybWF0U3RyID09PSAnZGVwdGggc3RlbmNpbCcpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJylcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKGZvcm1hdFN0ciwgdGV4dHVyZUZvcm1hdHMsXG4gICAgICAgICdpbnZhbGlkIHRleHR1cmUgZm9ybWF0JylcbiAgICAgIHZhciBpbnRlcm5hbGZvcm1hdCA9IGZsYWdzLmludGVybmFsZm9ybWF0ID0gdGV4dHVyZUZvcm1hdHNbZm9ybWF0U3RyXVxuICAgICAgZmxhZ3MuZm9ybWF0ID0gY29sb3JGb3JtYXRzW2ludGVybmFsZm9ybWF0XVxuICAgICAgaWYgKGZvcm1hdFN0ciBpbiB0ZXh0dXJlVHlwZXMpIHtcbiAgICAgICAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgZmxhZ3MudHlwZSA9IHRleHR1cmVUeXBlc1tmb3JtYXRTdHJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXRTdHIgaW4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKSB7XG4gICAgICAgIGZsYWdzLmNvbXByZXNzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBoYXNGb3JtYXQgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gUmVjb25jaWxlIGNoYW5uZWxzIGFuZCBmb3JtYXRcbiAgICBpZiAoIWhhc0NoYW5uZWxzICYmIGhhc0Zvcm1hdCkge1xuICAgICAgZmxhZ3MuY2hhbm5lbHMgPSBGT1JNQVRfQ0hBTk5FTFNbZmxhZ3MuZm9ybWF0XVxuICAgIH0gZWxzZSBpZiAoaGFzQ2hhbm5lbHMgJiYgIWhhc0Zvcm1hdCkge1xuICAgICAgaWYgKGZsYWdzLmNoYW5uZWxzICE9PSBDSEFOTkVMU19GT1JNQVRbZmxhZ3MuZm9ybWF0XSkge1xuICAgICAgICBmbGFncy5mb3JtYXQgPSBmbGFncy5pbnRlcm5hbGZvcm1hdCA9IENIQU5ORUxTX0ZPUk1BVFtmbGFncy5jaGFubmVsc11cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0Zvcm1hdCAmJiBoYXNDaGFubmVscykge1xuICAgICAgY2hlY2skMShcbiAgICAgICAgZmxhZ3MuY2hhbm5lbHMgPT09IEZPUk1BVF9DSEFOTkVMU1tmbGFncy5mb3JtYXRdLFxuICAgICAgICAnbnVtYmVyIG9mIGNoYW5uZWxzIGluY29uc2lzdGVudCB3aXRoIHNwZWNpZmllZCBmb3JtYXQnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZsYWdzIChmbGFncykge1xuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19GTElQX1lfV0VCR0wsIGZsYWdzLmZsaXBZKVxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmxhZ3MucHJlbXVsdGlwbHlBbHBoYSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBmbGFncy5jb2xvclNwYWNlKVxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19BTElHTk1FTlQsIGZsYWdzLnVucGFja0FsaWdubWVudClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGV4IGltYWdlIGRhdGFcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBUZXhJbWFnZSAoKSB7XG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKVxuXG4gICAgdGhpcy54T2Zmc2V0ID0gMFxuICAgIHRoaXMueU9mZnNldCA9IDBcblxuICAgIC8vIGRhdGFcbiAgICB0aGlzLmRhdGEgPSBudWxsXG4gICAgdGhpcy5uZWVkc0ZyZWUgPSBmYWxzZVxuXG4gICAgLy8gaHRtbCBlbGVtZW50XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbFxuXG4gICAgLy8gY29weVRleEltYWdlIGluZm9cbiAgICB0aGlzLm5lZWRzQ29weSA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUltYWdlIChpbWFnZSwgb3B0aW9ucykge1xuICAgIHZhciBkYXRhID0gbnVsbFxuICAgIGlmIChpc1BpeGVsRGF0YShvcHRpb25zKSkge1xuICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgcGl4ZWwgZGF0YSB0eXBlJylcbiAgICAgIHBhcnNlRmxhZ3MoaW1hZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoJ3gnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaW1hZ2UueE9mZnNldCA9IG9wdGlvbnMueCB8IDBcbiAgICAgIH1cbiAgICAgIGlmICgneScgaW4gb3B0aW9ucykge1xuICAgICAgICBpbWFnZS55T2Zmc2V0ID0gb3B0aW9ucy55IHwgMFxuICAgICAgfVxuICAgICAgaWYgKGlzUGl4ZWxEYXRhKG9wdGlvbnMuZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrJDEoXG4gICAgICAhaW1hZ2UuY29tcHJlc3NlZCB8fFxuICAgICAgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgICAnY29tcHJlc3NlZCB0ZXh0dXJlIGRhdGEgbXVzdCBiZSBzdG9yZWQgaW4gYSB1aW50OGFycmF5JylcblxuICAgIGlmIChvcHRpb25zLmNvcHkpIHtcbiAgICAgIGNoZWNrJDEoIWRhdGEsICdjYW4gbm90IHNwZWNpZnkgY29weSBhbmQgZGF0YSBmaWVsZCBmb3IgdGhlIHNhbWUgdGV4dHVyZScpXG4gICAgICB2YXIgdmlld1cgPSBjb250ZXh0U3RhdGUudmlld3BvcnRXaWR0aFxuICAgICAgdmFyIHZpZXdIID0gY29udGV4dFN0YXRlLnZpZXdwb3J0SGVpZ2h0XG4gICAgICBpbWFnZS53aWR0aCA9IGltYWdlLndpZHRoIHx8ICh2aWV3VyAtIGltYWdlLnhPZmZzZXQpXG4gICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgKHZpZXdIIC0gaW1hZ2UueU9mZnNldClcbiAgICAgIGltYWdlLm5lZWRzQ29weSA9IHRydWVcbiAgICAgIGNoZWNrJDEoaW1hZ2UueE9mZnNldCA+PSAwICYmIGltYWdlLnhPZmZzZXQgPCB2aWV3VyAmJlxuICAgICAgICAgICAgaW1hZ2UueU9mZnNldCA+PSAwICYmIGltYWdlLnlPZmZzZXQgPCB2aWV3SCAmJlxuICAgICAgICAgICAgaW1hZ2Uud2lkdGggPiAwICYmIGltYWdlLndpZHRoIDw9IHZpZXdXICYmXG4gICAgICAgICAgICBpbWFnZS5oZWlnaHQgPiAwICYmIGltYWdlLmhlaWdodCA8PSB2aWV3SCxcbiAgICAgICdjb3B5IHRleHR1cmUgcmVhZCBvdXQgb2YgYm91bmRzJylcbiAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICBpbWFnZS53aWR0aCA9IGltYWdlLndpZHRoIHx8IDFcbiAgICAgIGltYWdlLmhlaWdodCA9IGltYWdlLmhlaWdodCB8fCAxXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDRcbiAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBpbWFnZS5jaGFubmVscyB8fCA0XG4gICAgICBpbWFnZS5kYXRhID0gZGF0YVxuICAgICAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpICYmIGltYWdlLnR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNSkge1xuICAgICAgICBpbWFnZS50eXBlID0gdHlwZWRBcnJheUNvZGUkMShkYXRhKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNOdW1lcmljQXJyYXkoZGF0YSkpIHtcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gaW1hZ2UuY2hhbm5lbHMgfHwgNFxuICAgICAgY29udmVydERhdGEoaW1hZ2UsIGRhdGEpXG4gICAgICBpbWFnZS5hbGlnbm1lbnQgPSAxXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChpc05EQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgICB2YXIgYXJyYXkgPSBkYXRhLmRhdGFcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkgJiYgaW1hZ2UudHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ1KSB7XG4gICAgICAgIGltYWdlLnR5cGUgPSB0eXBlZEFycmF5Q29kZSQxKGFycmF5KVxuICAgICAgfVxuICAgICAgdmFyIHNoYXBlID0gZGF0YS5zaGFwZVxuICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlXG4gICAgICB2YXIgc2hhcGVYLCBzaGFwZVksIHNoYXBlQywgc3RyaWRlWCwgc3RyaWRlWSwgc3RyaWRlQ1xuICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBzaGFwZUMgPSBzaGFwZVsyXVxuICAgICAgICBzdHJpZGVDID0gc3RyaWRlWzJdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxKHNoYXBlLmxlbmd0aCA9PT0gMiwgJ2ludmFsaWQgbmRhcnJheSBwaXhlbCBkYXRhLCBtdXN0IGJlIDIgb3IgM0QnKVxuICAgICAgICBzaGFwZUMgPSAxXG4gICAgICAgIHN0cmlkZUMgPSAxXG4gICAgICB9XG4gICAgICBzaGFwZVggPSBzaGFwZVswXVxuICAgICAgc2hhcGVZID0gc2hhcGVbMV1cbiAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgIHN0cmlkZVkgPSBzdHJpZGVbMV1cbiAgICAgIGltYWdlLmFsaWdubWVudCA9IDFcbiAgICAgIGltYWdlLndpZHRoID0gc2hhcGVYXG4gICAgICBpbWFnZS5oZWlnaHQgPSBzaGFwZVlcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gc2hhcGVDXG4gICAgICBpbWFnZS5mb3JtYXQgPSBpbWFnZS5pbnRlcm5hbGZvcm1hdCA9IENIQU5ORUxTX0ZPUk1BVFtzaGFwZUNdXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlXG4gICAgICB0cmFuc3Bvc2VEYXRhKGltYWdlLCBhcnJheSwgc3RyaWRlWCwgc3RyaWRlWSwgc3RyaWRlQywgZGF0YS5vZmZzZXQpXG4gICAgfSBlbHNlIGlmIChpc0NhbnZhc0VsZW1lbnQoZGF0YSkgfHwgaXNPZmZzY3JlZW5DYW52YXMoZGF0YSkgfHwgaXNDb250ZXh0MkQoZGF0YSkpIHtcbiAgICAgIGlmIChpc0NhbnZhc0VsZW1lbnQoZGF0YSkgfHwgaXNPZmZzY3JlZW5DYW52YXMoZGF0YSkpIHtcbiAgICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhLmNhbnZhc1xuICAgICAgfVxuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS5lbGVtZW50LndpZHRoXG4gICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZS5lbGVtZW50LmhlaWdodFxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSA0XG4gICAgfSBlbHNlIGlmIChpc0JpdG1hcChkYXRhKSkge1xuICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGFcbiAgICAgIGltYWdlLndpZHRoID0gZGF0YS53aWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS5oZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNJbWFnZUVsZW1lbnQoZGF0YSkpIHtcbiAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICBpbWFnZS53aWR0aCA9IGRhdGEubmF0dXJhbFdpZHRoXG4gICAgICBpbWFnZS5oZWlnaHQgPSBkYXRhLm5hdHVyYWxIZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNWaWRlb0VsZW1lbnQoZGF0YSkpIHtcbiAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICBpbWFnZS53aWR0aCA9IGRhdGEudmlkZW9XaWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS52aWRlb0hlaWdodFxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSA0XG4gICAgfSBlbHNlIGlmIChpc1JlY3RBcnJheShkYXRhKSkge1xuICAgICAgdmFyIHcgPSBpbWFnZS53aWR0aCB8fCBkYXRhWzBdLmxlbmd0aFxuICAgICAgdmFyIGggPSBpbWFnZS5oZWlnaHQgfHwgZGF0YS5sZW5ndGhcbiAgICAgIHZhciBjID0gaW1hZ2UuY2hhbm5lbHNcbiAgICAgIGlmIChpc0FycmF5TGlrZShkYXRhWzBdWzBdKSkge1xuICAgICAgICBjID0gYyB8fCBkYXRhWzBdWzBdLmxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IGMgfHwgMVxuICAgICAgfVxuICAgICAgdmFyIGFycmF5U2hhcGUgPSBmbGF0dGVuVXRpbHMuc2hhcGUoZGF0YSlcbiAgICAgIHZhciBuID0gMVxuICAgICAgZm9yICh2YXIgZGQgPSAwOyBkZCA8IGFycmF5U2hhcGUubGVuZ3RoOyArK2RkKSB7XG4gICAgICAgIG4gKj0gYXJyYXlTaGFwZVtkZF1cbiAgICAgIH1cbiAgICAgIHZhciBhbGxvY0RhdGEgPSBwcmVDb252ZXJ0KGltYWdlLCBuKVxuICAgICAgZmxhdHRlblV0aWxzLmZsYXR0ZW4oZGF0YSwgYXJyYXlTaGFwZSwgJycsIGFsbG9jRGF0YSlcbiAgICAgIHBvc3RDb252ZXJ0KGltYWdlLCBhbGxvY0RhdGEpXG4gICAgICBpbWFnZS5hbGlnbm1lbnQgPSAxXG4gICAgICBpbWFnZS53aWR0aCA9IHdcbiAgICAgIGltYWdlLmhlaWdodCA9IGhcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gY1xuICAgICAgaW1hZ2UuZm9ybWF0ID0gaW1hZ2UuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbY11cbiAgICAgIGltYWdlLm5lZWRzRnJlZSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfRkxPQVQkNCkge1xuICAgICAgY2hlY2skMShsaW1pdHMuZXh0ZW5zaW9ucy5pbmRleE9mKCdvZXNfdGV4dHVyZV9mbG9hdCcpID49IDAsXG4gICAgICAgICdvZXNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gbm90IGVuYWJsZWQnKVxuICAgIH0gZWxzZSBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMSkge1xuICAgICAgY2hlY2skMShsaW1pdHMuZXh0ZW5zaW9ucy5pbmRleE9mKCdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0JykgPj0gMCxcbiAgICAgICAgJ29lc190ZXh0dXJlX2hhbGZfZmxvYXQgZXh0ZW5zaW9uIG5vdCBlbmFibGVkJylcbiAgICB9XG5cbiAgICAvLyBkbyBjb21wcmVzc2VkIHRleHR1cmUgIHZhbGlkYXRpb24gaGVyZS5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEltYWdlIChpbmZvLCB0YXJnZXQsIG1pcGxldmVsKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBpbmZvLmVsZW1lbnRcbiAgICB2YXIgZGF0YSA9IGluZm8uZGF0YVxuICAgIHZhciBpbnRlcm5hbGZvcm1hdCA9IGluZm8uaW50ZXJuYWxmb3JtYXRcbiAgICB2YXIgZm9ybWF0ID0gaW5mby5mb3JtYXRcbiAgICB2YXIgdHlwZSA9IGluZm8udHlwZVxuICAgIHZhciB3aWR0aCA9IGluZm8ud2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gaW5mby5oZWlnaHRcblxuICAgIHNldEZsYWdzKGluZm8pXG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIG1pcGxldmVsLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgZWxlbWVudClcbiAgICB9IGVsc2UgaWYgKGluZm8uY29tcHJlc3NlZCkge1xuICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgaW50ZXJuYWxmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGRhdGEpXG4gICAgfSBlbHNlIGlmIChpbmZvLm5lZWRzQ29weSkge1xuICAgICAgcmVnbFBvbGwoKVxuICAgICAgZ2wuY29weVRleEltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIGZvcm1hdCwgaW5mby54T2Zmc2V0LCBpbmZvLnlPZmZzZXQsIHdpZHRoLCBoZWlnaHQsIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIGRhdGEgfHwgbnVsbClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdWJJbWFnZSAoaW5mbywgdGFyZ2V0LCB4LCB5LCBtaXBsZXZlbCkge1xuICAgIHZhciBlbGVtZW50ID0gaW5mby5lbGVtZW50XG4gICAgdmFyIGRhdGEgPSBpbmZvLmRhdGFcbiAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBpbmZvLmludGVybmFsZm9ybWF0XG4gICAgdmFyIGZvcm1hdCA9IGluZm8uZm9ybWF0XG4gICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVcbiAgICB2YXIgd2lkdGggPSBpbmZvLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGluZm8uaGVpZ2h0XG5cbiAgICBzZXRGbGFncyhpbmZvKVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgZWxlbWVudClcbiAgICB9IGVsc2UgaWYgKGluZm8uY29tcHJlc3NlZCkge1xuICAgICAgZ2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkYXRhKVxuICAgIH0gZWxzZSBpZiAoaW5mby5uZWVkc0NvcHkpIHtcbiAgICAgIHJlZ2xQb2xsKClcbiAgICAgIGdsLmNvcHlUZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBpbmZvLnhPZmZzZXQsIGluZm8ueU9mZnNldCwgd2lkdGgsIGhlaWdodClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRleEltYWdlIHBvb2xcbiAgdmFyIGltYWdlUG9vbCA9IFtdXG5cbiAgZnVuY3Rpb24gYWxsb2NJbWFnZSAoKSB7XG4gICAgcmV0dXJuIGltYWdlUG9vbC5wb3AoKSB8fCBuZXcgVGV4SW1hZ2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gZnJlZUltYWdlIChpbWFnZSkge1xuICAgIGlmIChpbWFnZS5uZWVkc0ZyZWUpIHtcbiAgICAgIHBvb2wuZnJlZVR5cGUoaW1hZ2UuZGF0YSlcbiAgICB9XG4gICAgVGV4SW1hZ2UuY2FsbChpbWFnZSlcbiAgICBpbWFnZVBvb2wucHVzaChpbWFnZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTWlwIG1hcFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIE1pcE1hcCAoKSB7XG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKVxuXG4gICAgdGhpcy5nZW5NaXBtYXBzID0gZmFsc2VcbiAgICB0aGlzLm1pcG1hcEhpbnQgPSBHTF9ET05UX0NBUkVcbiAgICB0aGlzLm1pcG1hc2sgPSAwXG4gICAgdGhpcy5pbWFnZXMgPSBBcnJheSgxNilcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWlwTWFwRnJvbVNoYXBlIChtaXBtYXAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaW1nID0gbWlwbWFwLmltYWdlc1swXSA9IGFsbG9jSW1hZ2UoKVxuICAgIG1pcG1hcC5taXBtYXNrID0gMVxuICAgIGltZy53aWR0aCA9IG1pcG1hcC53aWR0aCA9IHdpZHRoXG4gICAgaW1nLmhlaWdodCA9IG1pcG1hcC5oZWlnaHQgPSBoZWlnaHRcbiAgICBpbWcuY2hhbm5lbHMgPSBtaXBtYXAuY2hhbm5lbHMgPSA0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pcE1hcEZyb21PYmplY3QgKG1pcG1hcCwgb3B0aW9ucykge1xuICAgIHZhciBpbWdEYXRhID0gbnVsbFxuICAgIGlmIChpc1BpeGVsRGF0YShvcHRpb25zKSkge1xuICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbMF0gPSBhbGxvY0ltYWdlKClcbiAgICAgIGNvcHlGbGFncyhpbWdEYXRhLCBtaXBtYXApXG4gICAgICBwYXJzZUltYWdlKGltZ0RhdGEsIG9wdGlvbnMpXG4gICAgICBtaXBtYXAubWlwbWFzayA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VGbGFncyhtaXBtYXAsIG9wdGlvbnMpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm1pcG1hcCkpIHtcbiAgICAgICAgdmFyIG1pcERhdGEgPSBvcHRpb25zLm1pcG1hcFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pcERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpbWdEYXRhID0gbWlwbWFwLmltYWdlc1tpXSA9IGFsbG9jSW1hZ2UoKVxuICAgICAgICAgIGNvcHlGbGFncyhpbWdEYXRhLCBtaXBtYXApXG4gICAgICAgICAgaW1nRGF0YS53aWR0aCA+Pj0gaVxuICAgICAgICAgIGltZ0RhdGEuaGVpZ2h0ID4+PSBpXG4gICAgICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBtaXBEYXRhW2ldKVxuICAgICAgICAgIG1pcG1hcC5taXBtYXNrIHw9ICgxIDw8IGkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZ0RhdGEgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpXG4gICAgICAgIGNvcHlGbGFncyhpbWdEYXRhLCBtaXBtYXApXG4gICAgICAgIHBhcnNlSW1hZ2UoaW1nRGF0YSwgb3B0aW9ucylcbiAgICAgICAgbWlwbWFwLm1pcG1hc2sgPSAxXG4gICAgICB9XG4gICAgfVxuICAgIGNvcHlGbGFncyhtaXBtYXAsIG1pcG1hcC5pbWFnZXNbMF0pXG5cbiAgICAvLyBGb3IgdGV4dHVyZXMgb2YgdGhlIGNvbXByZXNzZWQgZm9ybWF0IFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gICAgLy8gd2UgbXVzdCBoYXZlIHRoYXRcbiAgICAvL1xuICAgIC8vIFwiV2hlbiBsZXZlbCBlcXVhbHMgemVybyB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgIC8vIFdoZW4gbGV2ZWwgaXMgZ3JlYXRlciB0aGFuIDAgd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIDAsIDEsIDIgb3IgYSBtdWx0aXBsZSBvZiA0LiBcIlxuICAgIC8vXG4gICAgLy8gYnV0IHdlIGRvIG5vdCB5ZXQgc3VwcG9ydCBoYXZpbmcgbXVsdGlwbGUgbWlwbWFwIGxldmVscyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyxcbiAgICAvLyBzbyB3ZSBvbmx5IHRlc3QgZm9yIGxldmVsIHplcm8uXG5cbiAgICBpZiAoXG4gICAgICBtaXBtYXAuY29tcHJlc3NlZCAmJlxuICAgICAgKFxuICAgICAgICBtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgfHxcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCB8fFxuICAgICAgICBtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUIHx8XG4gICAgICAgIG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNoZWNrJDEobWlwbWFwLndpZHRoICUgNCA9PT0gMCAmJiBtaXBtYXAuaGVpZ2h0ICUgNCA9PT0gMCxcbiAgICAgICAgJ2ZvciBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0cywgbWlwbWFwIGxldmVsIDAgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBhcmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRNaXBNYXAgKG1pcG1hcCwgdGFyZ2V0KSB7XG4gICAgdmFyIGltYWdlcyA9IG1pcG1hcC5pbWFnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFpbWFnZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZXRJbWFnZShpbWFnZXNbaV0sIHRhcmdldCwgaSlcbiAgICB9XG4gIH1cblxuICB2YXIgbWlwUG9vbCA9IFtdXG5cbiAgZnVuY3Rpb24gYWxsb2NNaXBNYXAgKCkge1xuICAgIHZhciByZXN1bHQgPSBtaXBQb29sLnBvcCgpIHx8IG5ldyBNaXBNYXAoKVxuICAgIFRleEZsYWdzLmNhbGwocmVzdWx0KVxuICAgIHJlc3VsdC5taXBtYXNrID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgcmVzdWx0LmltYWdlc1tpXSA9IG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gZnJlZU1pcE1hcCAobWlwbWFwKSB7XG4gICAgdmFyIGltYWdlcyA9IG1pcG1hcC5pbWFnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGltYWdlc1tpXSkge1xuICAgICAgICBmcmVlSW1hZ2UoaW1hZ2VzW2ldKVxuICAgICAgfVxuICAgICAgaW1hZ2VzW2ldID0gbnVsbFxuICAgIH1cbiAgICBtaXBQb29sLnB1c2gobWlwbWFwKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUZXggaW5mb1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIFRleEluZm8gKCkge1xuICAgIHRoaXMubWluRmlsdGVyID0gR0xfTkVBUkVTVCQxXG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBHTF9ORUFSRVNUJDFcblxuICAgIHRoaXMud3JhcFMgPSBHTF9DTEFNUF9UT19FREdFJDFcbiAgICB0aGlzLndyYXBUID0gR0xfQ0xBTVBfVE9fRURHRSQxXG5cbiAgICB0aGlzLmFuaXNvdHJvcGljID0gMVxuXG4gICAgdGhpcy5nZW5NaXBtYXBzID0gZmFsc2VcbiAgICB0aGlzLm1pcG1hcEhpbnQgPSBHTF9ET05UX0NBUkVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVGV4SW5mbyAoaW5mbywgb3B0aW9ucykge1xuICAgIGlmICgnbWluJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgbWluRmlsdGVyID0gb3B0aW9ucy5taW5cbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG1pbkZpbHRlciwgbWluRmlsdGVycylcbiAgICAgIGluZm8ubWluRmlsdGVyID0gbWluRmlsdGVyc1ttaW5GaWx0ZXJdXG4gICAgICBpZiAoTUlQTUFQX0ZJTFRFUlMuaW5kZXhPZihpbmZvLm1pbkZpbHRlcikgPj0gMCAmJiAhKCdmYWNlcycgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgaW5mby5nZW5NaXBtYXBzID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnbWFnJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgbWFnRmlsdGVyID0gb3B0aW9ucy5tYWdcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG1hZ0ZpbHRlciwgbWFnRmlsdGVycylcbiAgICAgIGluZm8ubWFnRmlsdGVyID0gbWFnRmlsdGVyc1ttYWdGaWx0ZXJdXG4gICAgfVxuXG4gICAgdmFyIHdyYXBTID0gaW5mby53cmFwU1xuICAgIHZhciB3cmFwVCA9IGluZm8ud3JhcFRcbiAgICBpZiAoJ3dyYXAnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3cmFwID0gb3B0aW9ucy53cmFwXG4gICAgICBpZiAodHlwZW9mIHdyYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXAsIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFMgPSB3cmFwVCA9IHdyYXBNb2Rlc1t3cmFwXVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHdyYXApKSB7XG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXBbMF0sIHdyYXBNb2RlcylcbiAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIod3JhcFsxXSwgd3JhcE1vZGVzKVxuICAgICAgICB3cmFwUyA9IHdyYXBNb2Rlc1t3cmFwWzBdXVxuICAgICAgICB3cmFwVCA9IHdyYXBNb2Rlc1t3cmFwWzFdXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ3dyYXBTJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRXcmFwUyA9IG9wdGlvbnMud3JhcFNcbiAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0V3JhcFMsIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFMgPSB3cmFwTW9kZXNbb3B0V3JhcFNdXG4gICAgICB9XG4gICAgICBpZiAoJ3dyYXBUJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRXcmFwVCA9IG9wdGlvbnMud3JhcFRcbiAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0V3JhcFQsIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFQgPSB3cmFwTW9kZXNbb3B0V3JhcFRdXG4gICAgICB9XG4gICAgfVxuICAgIGluZm8ud3JhcFMgPSB3cmFwU1xuICAgIGluZm8ud3JhcFQgPSB3cmFwVFxuXG4gICAgaWYgKCdhbmlzb3Ryb3BpYycgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIGFuaXNvdHJvcGljID0gb3B0aW9ucy5hbmlzb3Ryb3BpY1xuICAgICAgY2hlY2skMSh0eXBlb2YgYW5pc290cm9waWMgPT09ICdudW1iZXInICYmXG4gICAgICAgICBhbmlzb3Ryb3BpYyA+PSAxICYmIGFuaXNvdHJvcGljIDw9IGxpbWl0cy5tYXhBbmlzb3Ryb3BpYyxcbiAgICAgICdhbmlzbyBzYW1wbGVzIG11c3QgYmUgYmV0d2VlbiAxIGFuZCAnKVxuICAgICAgaW5mby5hbmlzb3Ryb3BpYyA9IG9wdGlvbnMuYW5pc290cm9waWNcbiAgICB9XG5cbiAgICBpZiAoJ21pcG1hcCcgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIGhhc01pcE1hcCA9IGZhbHNlXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBvcHRpb25zLm1pcG1hcCkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMubWlwbWFwLCBtaXBtYXBIaW50LFxuICAgICAgICAgICAgJ2ludmFsaWQgbWlwbWFwIGhpbnQnKVxuICAgICAgICAgIGluZm8ubWlwbWFwSGludCA9IG1pcG1hcEhpbnRbb3B0aW9ucy5taXBtYXBdXG4gICAgICAgICAgaW5mby5nZW5NaXBtYXBzID0gdHJ1ZVxuICAgICAgICAgIGhhc01pcE1hcCA9IHRydWVcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIGhhc01pcE1hcCA9IGluZm8uZ2VuTWlwbWFwcyA9IG9wdGlvbnMubWlwbWFwXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShvcHRpb25zLm1pcG1hcCksICdpbnZhbGlkIG1pcG1hcCB0eXBlJylcbiAgICAgICAgICBpbmZvLmdlbk1pcG1hcHMgPSBmYWxzZVxuICAgICAgICAgIGhhc01pcE1hcCA9IHRydWVcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBtaXBtYXAgdHlwZScpXG4gICAgICB9XG4gICAgICBpZiAoaGFzTWlwTWFwICYmICEoJ21pbicgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgPSBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUJDFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXhJbmZvIChpbmZvLCB0YXJnZXQpIHtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9NSU5fRklMVEVSLCBpbmZvLm1pbkZpbHRlcilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9NQUdfRklMVEVSLCBpbmZvLm1hZ0ZpbHRlcilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgR0xfVEVYVFVSRV9XUkFQX1MsIGluZm8ud3JhcFMpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9ULCBpbmZvLndyYXBUKVxuICAgIGlmIChleHRlbnNpb25zLmV4dF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYykge1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBpbmZvLmFuaXNvdHJvcGljKVxuICAgIH1cbiAgICBpZiAoaW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICBnbC5oaW50KEdMX0dFTkVSQVRFX01JUE1BUF9ISU5ULCBpbmZvLm1pcG1hcEhpbnQpXG4gICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBGdWxsIHRleHR1cmUgb2JqZWN0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIHRleHR1cmVDb3VudCA9IDBcbiAgdmFyIHRleHR1cmVTZXQgPSB7fVxuICB2YXIgbnVtVGV4VW5pdHMgPSBsaW1pdHMubWF4VGV4dHVyZVVuaXRzXG4gIHZhciB0ZXh0dXJlVW5pdHMgPSBBcnJheShudW1UZXhVbml0cykubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9KVxuXG4gIGZ1bmN0aW9uIFJFR0xUZXh0dXJlICh0YXJnZXQpIHtcbiAgICBUZXhGbGFncy5jYWxsKHRoaXMpXG4gICAgdGhpcy5taXBtYXNrID0gMFxuICAgIHRoaXMuaW50ZXJuYWxmb3JtYXQgPSBHTF9SR0JBJDFcblxuICAgIHRoaXMuaWQgPSB0ZXh0dXJlQ291bnQrK1xuXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG5cbiAgICB0aGlzLnVuaXQgPSAtMVxuICAgIHRoaXMuYmluZENvdW50ID0gMFxuXG4gICAgdGhpcy50ZXhJbmZvID0gbmV3IFRleEluZm8oKVxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wQmluZCAodGV4dHVyZSkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSlcbiAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKVxuICB9XG5cbiAgZnVuY3Rpb24gdGVtcFJlc3RvcmUgKCkge1xuICAgIHZhciBwcmV2ID0gdGV4dHVyZVVuaXRzWzBdXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHByZXYudGFyZ2V0LCBwcmV2LnRleHR1cmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMSwgbnVsbClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICh0ZXh0dXJlKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRleHR1cmUudGV4dHVyZVxuICAgIGNoZWNrJDEoaGFuZGxlLCAnbXVzdCBub3QgZG91YmxlIGRlc3Ryb3kgdGV4dHVyZScpXG4gICAgdmFyIHVuaXQgPSB0ZXh0dXJlLnVuaXRcbiAgICB2YXIgdGFyZ2V0ID0gdGV4dHVyZS50YXJnZXRcbiAgICBpZiAodW5pdCA+PSAwKSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyB1bml0KVxuICAgICAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCBudWxsKVxuICAgICAgdGV4dHVyZVVuaXRzW3VuaXRdID0gbnVsbFxuICAgIH1cbiAgICBnbC5kZWxldGVUZXh0dXJlKGhhbmRsZSlcbiAgICB0ZXh0dXJlLnRleHR1cmUgPSBudWxsXG4gICAgdGV4dHVyZS5wYXJhbXMgPSBudWxsXG4gICAgdGV4dHVyZS5waXhlbHMgPSBudWxsXG4gICAgdGV4dHVyZS5yZWZDb3VudCA9IDBcbiAgICBkZWxldGUgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXVxuICAgIHN0YXRzLnRleHR1cmVDb3VudC0tXG4gIH1cblxuICBleHRlbmQoUkVHTFRleHR1cmUucHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRleHR1cmUgPSB0aGlzXG4gICAgICB0ZXh0dXJlLmJpbmRDb3VudCArPSAxXG4gICAgICB2YXIgdW5pdCA9IHRleHR1cmUudW5pdFxuICAgICAgaWYgKHVuaXQgPCAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGV4VW5pdHM7ICsraSkge1xuICAgICAgICAgIHZhciBvdGhlciA9IHRleHR1cmVVbml0c1tpXVxuICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmJpbmRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG90aGVyLnVuaXQgPSAtMVxuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSB0ZXh0dXJlXG4gICAgICAgICAgdW5pdCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID49IG51bVRleFVuaXRzKSB7XG4gICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW5zdWZmaWNpZW50IG51bWJlciBvZiB0ZXh0dXJlIHVuaXRzJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnByb2ZpbGUgJiYgc3RhdHMubWF4VGV4dHVyZVVuaXRzIDwgKHVuaXQgKyAxKSkge1xuICAgICAgICAgIHN0YXRzLm1heFRleHR1cmVVbml0cyA9IHVuaXQgKyAxIC8vICsxLCBzaW5jZSB0aGUgdW5pdHMgYXJlIHplcm8tYmFzZWRcbiAgICAgICAgfVxuICAgICAgICB0ZXh0dXJlLnVuaXQgPSB1bml0XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSArIHVuaXQpXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0ZXh0dXJlLnRleHR1cmUpXG4gICAgICB9XG4gICAgICByZXR1cm4gdW5pdFxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmluZENvdW50IC09IDFcbiAgICB9LFxuXG4gICAgZGVjUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoLS10aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgZGVzdHJveSh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlMkQgKGEsIGIpIHtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBSRUdMVGV4dHVyZShHTF9URVhUVVJFXzJEJDEpXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmVcbiAgICBzdGF0cy50ZXh0dXJlQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbFRleHR1cmUyRCAoYSwgYikge1xuICAgICAgdmFyIHRleEluZm8gPSB0ZXh0dXJlLnRleEluZm9cbiAgICAgIFRleEluZm8uY2FsbCh0ZXhJbmZvKVxuICAgICAgdmFyIG1pcERhdGEgPSBhbGxvY01pcE1hcCgpXG5cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbVNoYXBlKG1pcERhdGEsIGEgfCAwLCBiIHwgMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYSB8IDApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYSkge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsLnRleHR1cmUnKVxuICAgICAgICBwYXJzZVRleEluZm8odGV4SW5mbywgYSlcbiAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KG1pcERhdGEsIGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSB0ZXh0dXJlcyBnZXQgYXNzaWduZWQgYSBkZWZhdWx0IHNoYXBlIG9mIDF4MVxuICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCAxLCAxKVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4SW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICAgIG1pcERhdGEubWlwbWFzayA9IChtaXBEYXRhLndpZHRoIDw8IDEpIC0gMVxuICAgICAgfVxuICAgICAgdGV4dHVyZS5taXBtYXNrID0gbWlwRGF0YS5taXBtYXNrXG5cbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBtaXBEYXRhKVxuXG4gICAgICBjaGVjayQxLnRleHR1cmUyRCh0ZXhJbmZvLCBtaXBEYXRhLCBsaW1pdHMpXG4gICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID0gbWlwRGF0YS5pbnRlcm5hbGZvcm1hdFxuXG4gICAgICByZWdsVGV4dHVyZTJELndpZHRoID0gbWlwRGF0YS53aWR0aFxuICAgICAgcmVnbFRleHR1cmUyRC5oZWlnaHQgPSBtaXBEYXRhLmhlaWdodFxuXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKVxuICAgICAgc2V0TWlwTWFwKG1pcERhdGEsIEdMX1RFWFRVUkVfMkQkMSlcbiAgICAgIHNldFRleEluZm8odGV4SW5mbywgR0xfVEVYVFVSRV8yRCQxKVxuICAgICAgdGVtcFJlc3RvcmUoKVxuXG4gICAgICBmcmVlTWlwTWFwKG1pcERhdGEpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICBtaXBEYXRhLndpZHRoLFxuICAgICAgICAgIG1pcERhdGEuaGVpZ2h0LFxuICAgICAgICAgIHRleEluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICAgICBmYWxzZSlcbiAgICAgIH1cbiAgICAgIHJlZ2xUZXh0dXJlMkQuZm9ybWF0ID0gdGV4dHVyZUZvcm1hdHNJbnZlcnRbdGV4dHVyZS5pbnRlcm5hbGZvcm1hdF1cbiAgICAgIHJlZ2xUZXh0dXJlMkQudHlwZSA9IHRleHR1cmVUeXBlc0ludmVydFt0ZXh0dXJlLnR5cGVdXG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQubWFnID0gbWFnRmlsdGVyc0ludmVydFt0ZXhJbmZvLm1hZ0ZpbHRlcl1cbiAgICAgIHJlZ2xUZXh0dXJlMkQubWluID0gbWluRmlsdGVyc0ludmVydFt0ZXhJbmZvLm1pbkZpbHRlcl1cblxuICAgICAgcmVnbFRleHR1cmUyRC53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXVxuICAgICAgcmVnbFRleHR1cmUyRC53cmFwVCA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBUXVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmltYWdlIChpbWFnZSwgeF8sIHlfLCBsZXZlbF8pIHtcbiAgICAgIGNoZWNrJDEoISFpbWFnZSwgJ211c3Qgc3BlY2lmeSBpbWFnZSBkYXRhJylcblxuICAgICAgdmFyIHggPSB4XyB8IDBcbiAgICAgIHZhciB5ID0geV8gfCAwXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbF8gfCAwXG5cbiAgICAgIHZhciBpbWFnZURhdGEgPSBhbGxvY0ltYWdlKClcbiAgICAgIGNvcHlGbGFncyhpbWFnZURhdGEsIHRleHR1cmUpXG4gICAgICBpbWFnZURhdGEud2lkdGggPSAwXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gMFxuICAgICAgcGFyc2VJbWFnZShpbWFnZURhdGEsIGltYWdlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoIHx8ICgodGV4dHVyZS53aWR0aCA+PiBsZXZlbCkgLSB4KVxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQgfHwgKCh0ZXh0dXJlLmhlaWdodCA+PiBsZXZlbCkgLSB5KVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0ZXh0dXJlLnR5cGUgPT09IGltYWdlRGF0YS50eXBlICYmXG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID09PSBpbWFnZURhdGEuZm9ybWF0ICYmXG4gICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPT09IGltYWdlRGF0YS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgJ2luY29tcGF0aWJsZSBmb3JtYXQgZm9yIHRleHR1cmUuc3ViaW1hZ2UnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHkgPj0gMCAmJlxuICAgICAgICB4ICsgaW1hZ2VEYXRhLndpZHRoIDw9IHRleHR1cmUud2lkdGggJiZcbiAgICAgICAgeSArIGltYWdlRGF0YS5oZWlnaHQgPD0gdGV4dHVyZS5oZWlnaHQsXG4gICAgICAgICd0ZXh0dXJlLnN1YmltYWdlIHdyaXRlIG91dCBvZiBib3VuZHMnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrICYgKDEgPDwgbGV2ZWwpLFxuICAgICAgICAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICBjaGVjayQxKFxuICAgICAgICBpbWFnZURhdGEuZGF0YSB8fCBpbWFnZURhdGEuZWxlbWVudCB8fCBpbWFnZURhdGEubmVlZHNDb3B5LFxuICAgICAgICAnbWlzc2luZyBpbWFnZSBkYXRhJylcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldFN1YkltYWdlKGltYWdlRGF0YSwgR0xfVEVYVFVSRV8yRCQxLCB4LCB5LCBsZXZlbClcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZUltYWdlKGltYWdlRGF0YSlcblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemUgKHdfLCBoXykge1xuICAgICAgdmFyIHcgPSB3XyB8IDBcbiAgICAgIHZhciBoID0gKGhfIHwgMCkgfHwgd1xuICAgICAgaWYgKHcgPT09IHRleHR1cmUud2lkdGggJiYgaCA9PT0gdGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICAgIH1cblxuICAgICAgcmVnbFRleHR1cmUyRC53aWR0aCA9IHRleHR1cmUud2lkdGggPSB3XG4gICAgICByZWdsVGV4dHVyZTJELmhlaWdodCA9IHRleHR1cmUuaGVpZ2h0ID0gaFxuXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgdGV4dHVyZS5taXBtYXNrID4+IGk7ICsraSkge1xuICAgICAgICB2YXIgX3cgPSB3ID4+IGlcbiAgICAgICAgdmFyIF9oID0gaCA+PiBpXG4gICAgICAgIGlmICghX3cgfHwgIV9oKSBicmVha1xuICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgIEdMX1RFWFRVUkVfMkQkMSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIF93LFxuICAgICAgICAgIF9oLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgIG51bGwpXG4gICAgICB9XG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIC8vIGFsc28sIHJlY29tcHV0ZSB0aGUgdGV4dHVyZSBzaXplLlxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgIHRleHR1cmUuc3RhdHMuc2l6ZSA9IGdldFRleHR1cmVTaXplKFxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBmYWxzZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICB9XG5cbiAgICByZWdsVGV4dHVyZTJEKGEsIGIpXG5cbiAgICByZWdsVGV4dHVyZTJELnN1YmltYWdlID0gc3ViaW1hZ2VcbiAgICByZWdsVGV4dHVyZTJELnJlc2l6ZSA9IHJlc2l6ZVxuICAgIHJlZ2xUZXh0dXJlMkQuX3JlZ2xUeXBlID0gJ3RleHR1cmUyZCdcbiAgICByZWdsVGV4dHVyZTJELl90ZXh0dXJlID0gdGV4dHVyZVxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgcmVnbFRleHR1cmUyRC5zdGF0cyA9IHRleHR1cmUuc3RhdHNcbiAgICB9XG4gICAgcmVnbFRleHR1cmUyRC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGV4dHVyZS5kZWNSZWYoKVxuICAgIH1cblxuICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlQ3ViZSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgIHZhciB0ZXh0dXJlID0gbmV3IFJFR0xUZXh0dXJlKEdMX1RFWFRVUkVfQ1VCRV9NQVAkMSlcbiAgICB0ZXh0dXJlU2V0W3RleHR1cmUuaWRdID0gdGV4dHVyZVxuICAgIHN0YXRzLmN1YmVDb3VudCsrXG5cbiAgICB2YXIgZmFjZXMgPSBuZXcgQXJyYXkoNilcblxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlQ3ViZSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgdmFyIGlcbiAgICAgIHZhciB0ZXhJbmZvID0gdGV4dHVyZS50ZXhJbmZvXG4gICAgICBUZXhJbmZvLmNhbGwodGV4SW5mbylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZmFjZXNbaV0gPSBhbGxvY01pcE1hcCgpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYTAgPT09ICdudW1iZXInIHx8ICFhMCkge1xuICAgICAgICB2YXIgcyA9IChhMCB8IDApIHx8IDFcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbVNoYXBlKGZhY2VzW2ldLCBzLCBzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhMCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGExKSB7XG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzBdLCBhMClcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbMV0sIGExKVxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1syXSwgYTIpXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzNdLCBhMylcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbNF0sIGE0KVxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1s1XSwgYTUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VUZXhJbmZvKHRleEluZm8sIGEwKVxuICAgICAgICAgIHBhcnNlRmxhZ3ModGV4dHVyZSwgYTApXG4gICAgICAgICAgaWYgKCdmYWNlcycgaW4gYTApIHtcbiAgICAgICAgICAgIHZhciBmYWNlSW5wdXQgPSBhMC5mYWNlc1xuICAgICAgICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KGZhY2VJbnB1dCkgJiYgZmFjZUlucHV0Lmxlbmd0aCA9PT0gNixcbiAgICAgICAgICAgICAgJ2N1YmUgZmFjZXMgbXVzdCBiZSBhIGxlbmd0aCA2IGFycmF5JylcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgICAgY2hlY2skMSh0eXBlb2YgZmFjZUlucHV0W2ldID09PSAnb2JqZWN0JyAmJiAhIWZhY2VJbnB1dFtpXSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBpbnB1dCBmb3IgY3ViZSBtYXAgZmFjZScpXG4gICAgICAgICAgICAgIGNvcHlGbGFncyhmYWNlc1tpXSwgdGV4dHVyZSlcbiAgICAgICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzW2ldLCBmYWNlSW5wdXRbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzW2ldLCBhMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYXJndW1lbnRzIHRvIGN1YmUgbWFwJylcbiAgICAgIH1cblxuICAgICAgY29weUZsYWdzKHRleHR1cmUsIGZhY2VzWzBdKVxuXG4gICAgICBpZiAoIWxpbWl0cy5ucG90VGV4dHVyZUN1YmUpIHtcbiAgICAgICAgY2hlY2skMShpc1BvdzIkMSh0ZXh0dXJlLndpZHRoKSAmJiBpc1BvdzIkMSh0ZXh0dXJlLmhlaWdodCksICd5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBub24gcG93ZXIgb3IgdHdvIHRleHR1cmUgZGltZW5zaW9ucycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXhJbmZvLmdlbk1pcG1hcHMpIHtcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrID0gKGZhY2VzWzBdLndpZHRoIDw8IDEpIC0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrID0gZmFjZXNbMF0ubWlwbWFza1xuICAgICAgfVxuXG4gICAgICBjaGVjayQxLnRleHR1cmVDdWJlKHRleHR1cmUsIHRleEluZm8sIGZhY2VzLCBsaW1pdHMpXG4gICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID0gZmFjZXNbMF0uaW50ZXJuYWxmb3JtYXRcblxuICAgICAgcmVnbFRleHR1cmVDdWJlLndpZHRoID0gZmFjZXNbMF0ud2lkdGhcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5oZWlnaHQgPSBmYWNlc1swXS5oZWlnaHRcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgc2V0TWlwTWFwKGZhY2VzW2ldLCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSArIGkpXG4gICAgICB9XG4gICAgICBzZXRUZXhJbmZvKHRleEluZm8sIEdMX1RFWFRVUkVfQ1VCRV9NQVAkMSlcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgIHRleHR1cmUuc3RhdHMuc2l6ZSA9IGdldFRleHR1cmVTaXplKFxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0LFxuICAgICAgICAgIHRleEluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICAgICB0cnVlKVxuICAgICAgfVxuXG4gICAgICByZWdsVGV4dHVyZUN1YmUuZm9ybWF0ID0gdGV4dHVyZUZvcm1hdHNJbnZlcnRbdGV4dHVyZS5pbnRlcm5hbGZvcm1hdF1cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS50eXBlID0gdGV4dHVyZVR5cGVzSW52ZXJ0W3RleHR1cmUudHlwZV1cblxuICAgICAgcmVnbFRleHR1cmVDdWJlLm1hZyA9IG1hZ0ZpbHRlcnNJbnZlcnRbdGV4SW5mby5tYWdGaWx0ZXJdXG4gICAgICByZWdsVGV4dHVyZUN1YmUubWluID0gbWluRmlsdGVyc0ludmVydFt0ZXhJbmZvLm1pbkZpbHRlcl1cblxuICAgICAgcmVnbFRleHR1cmVDdWJlLndyYXBTID0gd3JhcE1vZGVzSW52ZXJ0W3RleEluZm8ud3JhcFNdXG4gICAgICByZWdsVGV4dHVyZUN1YmUud3JhcFQgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwVF1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICBmcmVlTWlwTWFwKGZhY2VzW2ldKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ViaW1hZ2UgKGZhY2UsIGltYWdlLCB4XywgeV8sIGxldmVsXykge1xuICAgICAgY2hlY2skMSghIWltYWdlLCAnbXVzdCBzcGVjaWZ5IGltYWdlIGRhdGEnKVxuICAgICAgY2hlY2skMSh0eXBlb2YgZmFjZSA9PT0gJ251bWJlcicgJiYgZmFjZSA9PT0gKGZhY2UgfCAwKSAmJlxuICAgICAgICBmYWNlID49IDAgJiYgZmFjZSA8IDYsICdpbnZhbGlkIGZhY2UnKVxuXG4gICAgICB2YXIgeCA9IHhfIHwgMFxuICAgICAgdmFyIHkgPSB5XyB8IDBcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsXyB8IDBcblxuICAgICAgdmFyIGltYWdlRGF0YSA9IGFsbG9jSW1hZ2UoKVxuICAgICAgY29weUZsYWdzKGltYWdlRGF0YSwgdGV4dHVyZSlcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IDBcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSAwXG4gICAgICBwYXJzZUltYWdlKGltYWdlRGF0YSwgaW1hZ2UpXG4gICAgICBpbWFnZURhdGEud2lkdGggPSBpbWFnZURhdGEud2lkdGggfHwgKCh0ZXh0dXJlLndpZHRoID4+IGxldmVsKSAtIHgpXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCB8fCAoKHRleHR1cmUuaGVpZ2h0ID4+IGxldmVsKSAtIHkpXG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHRleHR1cmUudHlwZSA9PT0gaW1hZ2VEYXRhLnR5cGUgJiZcbiAgICAgICAgdGV4dHVyZS5mb3JtYXQgPT09IGltYWdlRGF0YS5mb3JtYXQgJiZcbiAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9PT0gaW1hZ2VEYXRhLmludGVybmFsZm9ybWF0LFxuICAgICAgICAnaW5jb21wYXRpYmxlIGZvcm1hdCBmb3IgdGV4dHVyZS5zdWJpbWFnZScpXG4gICAgICBjaGVjayQxKFxuICAgICAgICB4ID49IDAgJiYgeSA+PSAwICYmXG4gICAgICAgIHggKyBpbWFnZURhdGEud2lkdGggPD0gdGV4dHVyZS53aWR0aCAmJlxuICAgICAgICB5ICsgaW1hZ2VEYXRhLmhlaWdodCA8PSB0ZXh0dXJlLmhlaWdodCxcbiAgICAgICAgJ3RleHR1cmUuc3ViaW1hZ2Ugd3JpdGUgb3V0IG9mIGJvdW5kcycpXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0ZXh0dXJlLm1pcG1hc2sgJiAoMSA8PCBsZXZlbCksXG4gICAgICAgICdtaXNzaW5nIG1pcG1hcCBkYXRhJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGltYWdlRGF0YS5kYXRhIHx8IGltYWdlRGF0YS5lbGVtZW50IHx8IGltYWdlRGF0YS5uZWVkc0NvcHksXG4gICAgICAgICdtaXNzaW5nIGltYWdlIGRhdGEnKVxuXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKVxuICAgICAgc2V0U3ViSW1hZ2UoaW1hZ2VEYXRhLCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSArIGZhY2UsIHgsIHksIGxldmVsKVxuICAgICAgdGVtcFJlc3RvcmUoKVxuXG4gICAgICBmcmVlSW1hZ2UoaW1hZ2VEYXRhKVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplIChyYWRpdXNfKSB7XG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzXyB8IDBcbiAgICAgIGlmIChyYWRpdXMgPT09IHRleHR1cmUud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCA9IHRleHR1cmUud2lkdGggPSByYWRpdXNcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5oZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA9IHJhZGl1c1xuXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IHRleHR1cmUubWlwbWFzayA+PiBqOyArK2opIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgICAgcmFkaXVzID4+IGosXG4gICAgICAgICAgICByYWRpdXMgPj4gaixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgIHRleHR1cmUuc3RhdHMuc2l6ZSA9IGdldFRleHR1cmVTaXplKFxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZUN1YmVcbiAgICB9XG5cbiAgICByZWdsVGV4dHVyZUN1YmUoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSlcblxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5zdWJpbWFnZSA9IHN1YmltYWdlXG4gICAgcmVnbFRleHR1cmVDdWJlLnJlc2l6ZSA9IHJlc2l6ZVxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5fcmVnbFR5cGUgPSAndGV4dHVyZUN1YmUnXG4gICAgcmVnbFRleHR1cmVDdWJlLl90ZXh0dXJlID0gdGV4dHVyZVxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgcmVnbFRleHR1cmVDdWJlLnN0YXRzID0gdGV4dHVyZS5zdGF0c1xuICAgIH1cbiAgICByZWdsVGV4dHVyZUN1YmUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRleHR1cmUuZGVjUmVmKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiByZWdsIGlzIGRlc3Ryb3llZFxuICBmdW5jdGlvbiBkZXN0cm95VGV4dHVyZXMgKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGV4VW5pdHM7ICsraSkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgaSlcbiAgICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMSwgbnVsbClcbiAgICAgIHRleHR1cmVVbml0c1tpXSA9IG51bGxcbiAgICB9XG4gICAgdmFsdWVzKHRleHR1cmVTZXQpLmZvckVhY2goZGVzdHJveSlcblxuICAgIHN0YXRzLmN1YmVDb3VudCA9IDBcbiAgICBzdGF0cy50ZXh0dXJlQ291bnQgPSAwXG4gIH1cblxuICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICBzdGF0cy5nZXRUb3RhbFRleHR1cmVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvdGFsID0gMFxuICAgICAgT2JqZWN0LmtleXModGV4dHVyZVNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IHRleHR1cmVTZXRba2V5XS5zdGF0cy5zaXplXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRvdGFsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIHZhciB0ZXggPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgIGlmICh0ZXgpIHtcbiAgICAgICAgdGV4LmJpbmRDb3VudCA9IDBcbiAgICAgICAgdGV4LnVuaXQgPSAtMVxuICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVzKHRleHR1cmVTZXQpLmZvckVhY2goZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICAgICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIHRleHR1cmUudGV4dHVyZSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgICBpZiAoKHRleHR1cmUubWlwbWFzayAmICgxIDw8IGkpKSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHR1cmUudGFyZ2V0ID09PSBHTF9URVhUVVJFXzJEJDEpIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKEdMX1RFWFRVUkVfMkQkMSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgICAgdGV4dHVyZS53aWR0aCA+PiBpLFxuICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgPj4gaSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgICAgbnVsbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY7ICsraikge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSArIGosXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgICAgIHRleHR1cmUud2lkdGggPj4gaSxcbiAgICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgPj4gaSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgICAgdGV4dHVyZS50eXBlLFxuICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0VGV4SW5mbyh0ZXh0dXJlLnRleEluZm8sIHRleHR1cmUudGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVGV4dHVyZXMgKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGV4VW5pdHM7ICsraSkge1xuICAgICAgdmFyIHRleCA9IHRleHR1cmVVbml0c1tpXVxuICAgICAgaWYgKHRleCkge1xuICAgICAgICB0ZXguYmluZENvdW50ID0gMFxuICAgICAgICB0ZXgudW5pdCA9IC0xXG4gICAgICAgIHRleHR1cmVVbml0c1tpXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSArIGkpXG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQJDEsIG51bGwpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUyRDogY3JlYXRlVGV4dHVyZTJELFxuICAgIGNyZWF0ZUN1YmU6IGNyZWF0ZVRleHR1cmVDdWJlLFxuICAgIGNsZWFyOiBkZXN0cm95VGV4dHVyZXMsXG4gICAgZ2V0VGV4dHVyZTogZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSxcbiAgICByZXN0b3JlOiByZXN0b3JlVGV4dHVyZXMsXG4gICAgcmVmcmVzaDogcmVmcmVzaFRleHR1cmVzXG4gIH1cbn1cblxudmFyIEdMX1JFTkRFUkJVRkZFUiA9IDB4OEQ0MVxuXG52YXIgR0xfUkdCQTQkMSA9IDB4ODA1NlxudmFyIEdMX1JHQjVfQTEkMSA9IDB4ODA1N1xudmFyIEdMX1JHQjU2NSQxID0gMHg4RDYyXG52YXIgR0xfREVQVEhfQ09NUE9ORU5UMTYgPSAweDgxQTVcbnZhciBHTF9TVEVOQ0lMX0lOREVYOCA9IDB4OEQ0OFxudmFyIEdMX0RFUFRIX1NURU5DSUwkMSA9IDB4ODRGOVxuXG52YXIgR0xfU1JHQjhfQUxQSEE4X0VYVCA9IDB4OEM0M1xuXG52YXIgR0xfUkdCQTMyRl9FWFQgPSAweDg4MTRcblxudmFyIEdMX1JHQkExNkZfRVhUID0gMHg4ODFBXG52YXIgR0xfUkdCMTZGX0VYVCA9IDB4ODgxQlxuXG52YXIgRk9STUFUX1NJWkVTID0gW11cblxuRk9STUFUX1NJWkVTW0dMX1JHQkE0JDFdID0gMlxuRk9STUFUX1NJWkVTW0dMX1JHQjVfQTEkMV0gPSAyXG5GT1JNQVRfU0laRVNbR0xfUkdCNTY1JDFdID0gMlxuXG5GT1JNQVRfU0laRVNbR0xfREVQVEhfQ09NUE9ORU5UMTZdID0gMlxuRk9STUFUX1NJWkVTW0dMX1NURU5DSUxfSU5ERVg4XSA9IDFcbkZPUk1BVF9TSVpFU1tHTF9ERVBUSF9TVEVOQ0lMJDFdID0gNFxuXG5GT1JNQVRfU0laRVNbR0xfU1JHQjhfQUxQSEE4X0VYVF0gPSA0XG5GT1JNQVRfU0laRVNbR0xfUkdCQTMyRl9FWFRdID0gMTZcbkZPUk1BVF9TSVpFU1tHTF9SR0JBMTZGX0VYVF0gPSA4XG5GT1JNQVRfU0laRVNbR0xfUkdCMTZGX0VYVF0gPSA2XG5cbmZ1bmN0aW9uIGdldFJlbmRlcmJ1ZmZlclNpemUgKGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gRk9STUFUX1NJWkVTW2Zvcm1hdF0gKiB3aWR0aCAqIGhlaWdodFxufVxuXG52YXIgd3JhcFJlbmRlcmJ1ZmZlcnMgPSBmdW5jdGlvbiAoZ2wsIGV4dGVuc2lvbnMsIGxpbWl0cywgc3RhdHMsIGNvbmZpZykge1xuICB2YXIgZm9ybWF0VHlwZXMgPSB7XG4gICAgJ3JnYmE0JzogR0xfUkdCQTQkMSxcbiAgICAncmdiNTY1JzogR0xfUkdCNTY1JDEsXG4gICAgJ3JnYjUgYTEnOiBHTF9SR0I1X0ExJDEsXG4gICAgJ2RlcHRoJzogR0xfREVQVEhfQ09NUE9ORU5UMTYsXG4gICAgJ3N0ZW5jaWwnOiBHTF9TVEVOQ0lMX0lOREVYOCxcbiAgICAnZGVwdGggc3RlbmNpbCc6IEdMX0RFUFRIX1NURU5DSUwkMVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3NyZ2IpIHtcbiAgICBmb3JtYXRUeXBlc1snc3JnYmEnXSA9IEdMX1NSR0I4X0FMUEhBOF9FWFRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCkge1xuICAgIGZvcm1hdFR5cGVzWydyZ2JhMTZmJ10gPSBHTF9SR0JBMTZGX0VYVFxuICAgIGZvcm1hdFR5cGVzWydyZ2IxNmYnXSA9IEdMX1JHQjE2Rl9FWFRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCkge1xuICAgIGZvcm1hdFR5cGVzWydyZ2JhMzJmJ10gPSBHTF9SR0JBMzJGX0VYVFxuICB9XG5cbiAgdmFyIGZvcm1hdFR5cGVzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMoZm9ybWF0VHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBmb3JtYXRUeXBlc1trZXldXG4gICAgZm9ybWF0VHlwZXNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciByZW5kZXJidWZmZXJDb3VudCA9IDBcbiAgdmFyIHJlbmRlcmJ1ZmZlclNldCA9IHt9XG5cbiAgZnVuY3Rpb24gUkVHTFJlbmRlcmJ1ZmZlciAocmVuZGVyYnVmZmVyKSB7XG4gICAgdGhpcy5pZCA9IHJlbmRlcmJ1ZmZlckNvdW50KytcbiAgICB0aGlzLnJlZkNvdW50ID0gMVxuXG4gICAgdGhpcy5yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXJcblxuICAgIHRoaXMuZm9ybWF0ID0gR0xfUkdCQTQkMVxuICAgIHRoaXMud2lkdGggPSAwXG4gICAgdGhpcy5oZWlnaHQgPSAwXG5cbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHRoaXMuc3RhdHMgPSB7IHNpemU6IDAgfVxuICAgIH1cbiAgfVxuXG4gIFJFR0xSZW5kZXJidWZmZXIucHJvdG90eXBlLmRlY1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoLS10aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgIGRlc3Ryb3kodGhpcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95IChyYikge1xuICAgIHZhciBoYW5kbGUgPSByYi5yZW5kZXJidWZmZXJcbiAgICBjaGVjayQxKGhhbmRsZSwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IHJlbmRlcmJ1ZmZlcicpXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIG51bGwpXG4gICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGhhbmRsZSlcbiAgICByYi5yZW5kZXJidWZmZXIgPSBudWxsXG4gICAgcmIucmVmQ291bnQgPSAwXG4gICAgZGVsZXRlIHJlbmRlcmJ1ZmZlclNldFtyYi5pZF1cbiAgICBzdGF0cy5yZW5kZXJidWZmZXJDb3VudC0tXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJidWZmZXIgKGEsIGIpIHtcbiAgICB2YXIgcmVuZGVyYnVmZmVyID0gbmV3IFJFR0xSZW5kZXJidWZmZXIoZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCkpXG4gICAgcmVuZGVyYnVmZmVyU2V0W3JlbmRlcmJ1ZmZlci5pZF0gPSByZW5kZXJidWZmZXJcbiAgICBzdGF0cy5yZW5kZXJidWZmZXJDb3VudCsrXG5cbiAgICBmdW5jdGlvbiByZWdsUmVuZGVyYnVmZmVyIChhLCBiKSB7XG4gICAgICB2YXIgdyA9IDBcbiAgICAgIHZhciBoID0gMFxuICAgICAgdmFyIGZvcm1hdCA9IEdMX1JHQkE0JDFcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYVxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2hhcGUnKVxuICAgICAgICAgIHcgPSBzaGFwZVswXSB8IDBcbiAgICAgICAgICBoID0gc2hhcGVbMV0gfCAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHcgPSBoID0gb3B0aW9ucy5yYWRpdXMgfCAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnd2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHcgPSBvcHRpb25zLndpZHRoIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2Zvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMuZm9ybWF0LCBmb3JtYXRUeXBlcyxcbiAgICAgICAgICAgICdpbnZhbGlkIHJlbmRlcmJ1ZmZlciBmb3JtYXQnKVxuICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdFR5cGVzW29wdGlvbnMuZm9ybWF0XVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICB3ID0gYSB8IDBcbiAgICAgICAgaWYgKHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGggPSBiIHwgMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGggPSB3XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWEpIHtcbiAgICAgICAgdyA9IGggPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZW5kZXJidWZmZXIgY29uc3RydWN0b3InKVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBzaGFwZVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdyA+IDAgJiYgaCA+IDAgJiZcbiAgICAgICAgdyA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSAmJiBoIDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplLFxuICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2l6ZScpXG5cbiAgICAgIGlmICh3ID09PSByZW5kZXJidWZmZXIud2lkdGggJiZcbiAgICAgICAgICBoID09PSByZW5kZXJidWZmZXIuaGVpZ2h0ICYmXG4gICAgICAgICAgZm9ybWF0ID09PSByZW5kZXJidWZmZXIuZm9ybWF0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZWdsUmVuZGVyYnVmZmVyLndpZHRoID0gcmVuZGVyYnVmZmVyLndpZHRoID0gd1xuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5oZWlnaHQgPSByZW5kZXJidWZmZXIuaGVpZ2h0ID0gaFxuICAgICAgcmVuZGVyYnVmZmVyLmZvcm1hdCA9IGZvcm1hdFxuXG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyLnJlbmRlcmJ1ZmZlcilcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoR0xfUkVOREVSQlVGRkVSLCBmb3JtYXQsIHcsIGgpXG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGdsLmdldEVycm9yKCkgPT09IDAsXG4gICAgICAgICdpbnZhbGlkIHJlbmRlciBidWZmZXIgZm9ybWF0JylcblxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgIHJlbmRlcmJ1ZmZlci5zdGF0cy5zaXplID0gZ2V0UmVuZGVyYnVmZmVyU2l6ZShyZW5kZXJidWZmZXIuZm9ybWF0LCByZW5kZXJidWZmZXIud2lkdGgsIHJlbmRlcmJ1ZmZlci5oZWlnaHQpXG4gICAgICB9XG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmZvcm1hdCA9IGZvcm1hdFR5cGVzSW52ZXJ0W3JlbmRlcmJ1ZmZlci5mb3JtYXRdXG5cbiAgICAgIHJldHVybiByZWdsUmVuZGVyYnVmZmVyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcbiAgICAgIHZhciB3ID0gd18gfCAwXG4gICAgICB2YXIgaCA9IChoXyB8IDApIHx8IHdcblxuICAgICAgaWYgKHcgPT09IHJlbmRlcmJ1ZmZlci53aWR0aCAmJiBoID09PSByZW5kZXJidWZmZXIuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiByZWdsUmVuZGVyYnVmZmVyXG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHNoYXBlXG4gICAgICBjaGVjayQxKFxuICAgICAgICB3ID4gMCAmJiBoID4gMCAmJlxuICAgICAgICB3IDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplICYmIGggPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUsXG4gICAgICAgICdpbnZhbGlkIHJlbmRlcmJ1ZmZlciBzaXplJylcblxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci53aWR0aCA9IHJlbmRlcmJ1ZmZlci53aWR0aCA9IHdcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuaGVpZ2h0ID0gcmVuZGVyYnVmZmVyLmhlaWdodCA9IGhcblxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyLmZvcm1hdCwgdywgaClcblxuICAgICAgY2hlY2skMShcbiAgICAgICAgZ2wuZ2V0RXJyb3IoKSA9PT0gMCxcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyIGJ1ZmZlciBmb3JtYXQnKVxuXG4gICAgICAvLyBhbHNvLCByZWNvbXB1dGUgc2l6ZS5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICByZW5kZXJidWZmZXIuc3RhdHMuc2l6ZSA9IGdldFJlbmRlcmJ1ZmZlclNpemUoXG4gICAgICAgICAgcmVuZGVyYnVmZmVyLmZvcm1hdCwgcmVuZGVyYnVmZmVyLndpZHRoLCByZW5kZXJidWZmZXIuaGVpZ2h0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgIH1cblxuICAgIHJlZ2xSZW5kZXJidWZmZXIoYSwgYilcblxuICAgIHJlZ2xSZW5kZXJidWZmZXIucmVzaXplID0gcmVzaXplXG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5fcmVnbFR5cGUgPSAncmVuZGVyYnVmZmVyJ1xuICAgIHJlZ2xSZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlciA9IHJlbmRlcmJ1ZmZlclxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5zdGF0cyA9IHJlbmRlcmJ1ZmZlci5zdGF0c1xuICAgIH1cbiAgICByZWdsUmVuZGVyYnVmZmVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZW5kZXJidWZmZXIuZGVjUmVmKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0VG90YWxSZW5kZXJidWZmZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvdGFsID0gMFxuICAgICAgT2JqZWN0LmtleXMocmVuZGVyYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdG90YWwgKz0gcmVuZGVyYnVmZmVyU2V0W2tleV0uc3RhdHMuc2l6ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVSZW5kZXJidWZmZXJzICgpIHtcbiAgICB2YWx1ZXMocmVuZGVyYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChyYikge1xuICAgICAgcmIucmVuZGVyYnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKClcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCByYi5yZW5kZXJidWZmZXIpXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgcmIuZm9ybWF0LCByYi53aWR0aCwgcmIuaGVpZ2h0KVxuICAgIH0pXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIG51bGwpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlUmVuZGVyYnVmZmVyLFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWx1ZXMocmVuZGVyYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG4gICAgfSxcbiAgICByZXN0b3JlOiByZXN0b3JlUmVuZGVyYnVmZmVyc1xuICB9XG59XG5cbi8vIFdlIHN0b3JlIHRoZXNlIGNvbnN0YW50cyBzbyB0aGF0IHRoZSBtaW5pZmllciBjYW4gaW5saW5lIHRoZW1cbnZhciBHTF9GUkFNRUJVRkZFUiQxID0gMHg4RDQwXG52YXIgR0xfUkVOREVSQlVGRkVSJDEgPSAweDhENDFcblxudmFyIEdMX1RFWFRVUkVfMkQkMiA9IDB4MERFMVxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyID0gMHg4NTE1XG5cbnZhciBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQxID0gMHg4Q0UwXG52YXIgR0xfREVQVEhfQVRUQUNITUVOVCA9IDB4OEQwMFxudmFyIEdMX1NURU5DSUxfQVRUQUNITUVOVCA9IDB4OEQyMFxudmFyIEdMX0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA9IDB4ODIxQVxuXG52YXIgR0xfRlJBTUVCVUZGRVJfQ09NUExFVEUkMSA9IDB4OENENVxudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCA9IDB4OENENlxudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UID0gMHg4Q0Q3XG52YXIgR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TID0gMHg4Q0Q5XG52YXIgR0xfRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQgPSAweDhDRERcblxudmFyIEdMX0hBTEZfRkxPQVRfT0VTJDIgPSAweDhENjFcbnZhciBHTF9VTlNJR05FRF9CWVRFJDYgPSAweDE0MDFcbnZhciBHTF9GTE9BVCQ1ID0gMHgxNDA2XG5cbnZhciBHTF9SR0IkMSA9IDB4MTkwN1xudmFyIEdMX1JHQkEkMiA9IDB4MTkwOFxuXG52YXIgR0xfREVQVEhfQ09NUE9ORU5UJDEgPSAweDE5MDJcblxudmFyIGNvbG9yVGV4dHVyZUZvcm1hdEVudW1zID0gW1xuICBHTF9SR0IkMSxcbiAgR0xfUkdCQSQyXG5dXG5cbi8vIGZvciBldmVyeSB0ZXh0dXJlIGZvcm1hdCwgc3RvcmVcbi8vIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbnZhciB0ZXh0dXJlRm9ybWF0Q2hhbm5lbHMgPSBbXVxudGV4dHVyZUZvcm1hdENoYW5uZWxzW0dMX1JHQkEkMl0gPSA0XG50ZXh0dXJlRm9ybWF0Q2hhbm5lbHNbR0xfUkdCJDFdID0gM1xuXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSB0eXBlLCBzdG9yZVxuLy8gdGhlIHNpemUgaW4gYnl0ZXMuXG52YXIgdGV4dHVyZVR5cGVTaXplcyA9IFtdXG50ZXh0dXJlVHlwZVNpemVzW0dMX1VOU0lHTkVEX0JZVEUkNl0gPSAxXG50ZXh0dXJlVHlwZVNpemVzW0dMX0ZMT0FUJDVdID0gNFxudGV4dHVyZVR5cGVTaXplc1tHTF9IQUxGX0ZMT0FUX09FUyQyXSA9IDJcblxudmFyIEdMX1JHQkE0JDIgPSAweDgwNTZcbnZhciBHTF9SR0I1X0ExJDIgPSAweDgwNTdcbnZhciBHTF9SR0I1NjUkMiA9IDB4OEQ2MlxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVDE2JDEgPSAweDgxQTVcbnZhciBHTF9TVEVOQ0lMX0lOREVYOCQxID0gMHg4RDQ4XG52YXIgR0xfREVQVEhfU1RFTkNJTCQyID0gMHg4NEY5XG5cbnZhciBHTF9TUkdCOF9BTFBIQThfRVhUJDEgPSAweDhDNDNcblxudmFyIEdMX1JHQkEzMkZfRVhUJDEgPSAweDg4MTRcblxudmFyIEdMX1JHQkExNkZfRVhUJDEgPSAweDg4MUFcbnZhciBHTF9SR0IxNkZfRVhUJDEgPSAweDg4MUJcblxudmFyIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0RW51bXMgPSBbXG4gIEdMX1JHQkE0JDIsXG4gIEdMX1JHQjVfQTEkMixcbiAgR0xfUkdCNTY1JDIsXG4gIEdMX1NSR0I4X0FMUEhBOF9FWFQkMSxcbiAgR0xfUkdCQTE2Rl9FWFQkMSxcbiAgR0xfUkdCMTZGX0VYVCQxLFxuICBHTF9SR0JBMzJGX0VYVCQxXG5dXG5cbnZhciBzdGF0dXNDb2RlID0ge31cbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfQ09NUExFVEUkMV0gPSAnY29tcGxldGUnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVF0gPSAnaW5jb21wbGV0ZSBhdHRhY2htZW50J1xuc3RhdHVzQ29kZVtHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNdID0gJ2luY29tcGxldGUgZGltZW5zaW9ucydcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRdID0gJ2luY29tcGxldGUsIG1pc3NpbmcgYXR0YWNobWVudCdcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfVU5TVVBQT1JURURdID0gJ3Vuc3VwcG9ydGVkJ1xuXG5mdW5jdGlvbiB3cmFwRkJPU3RhdGUgKFxuICBnbCxcbiAgZXh0ZW5zaW9ucyxcbiAgbGltaXRzLFxuICB0ZXh0dXJlU3RhdGUsXG4gIHJlbmRlcmJ1ZmZlclN0YXRlLFxuICBzdGF0cykge1xuICB2YXIgZnJhbWVidWZmZXJTdGF0ZSA9IHtcbiAgICBjdXI6IG51bGwsXG4gICAgbmV4dDogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2V0RkJPOiBudWxsXG4gIH1cblxuICB2YXIgY29sb3JUZXh0dXJlRm9ybWF0cyA9IFsncmdiYSddXG4gIHZhciBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMgPSBbJ3JnYmE0JywgJ3JnYjU2NScsICdyZ2I1IGExJ11cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfc3JnYikge1xuICAgIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5wdXNoKCdzcmdiYScpXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQpIHtcbiAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMucHVzaCgncmdiYTE2ZicsICdyZ2IxNmYnKVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29sb3JfYnVmZmVyX2Zsb2F0KSB7XG4gICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLnB1c2goJ3JnYmEzMmYnKVxuICB9XG5cbiAgdmFyIGNvbG9yVHlwZXMgPSBbJ3VpbnQ4J11cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCkge1xuICAgIGNvbG9yVHlwZXMucHVzaCgnaGFsZiBmbG9hdCcsICdmbG9hdDE2JylcbiAgfVxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCkge1xuICAgIGNvbG9yVHlwZXMucHVzaCgnZmxvYXQnLCAnZmxvYXQzMicpXG4gIH1cblxuICBmdW5jdGlvbiBGcmFtZWJ1ZmZlckF0dGFjaG1lbnQgKHRhcmdldCwgdGV4dHVyZSwgcmVuZGVyYnVmZmVyKSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlXG4gICAgdGhpcy5yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXJcblxuICAgIHZhciB3ID0gMFxuICAgIHZhciBoID0gMFxuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB3ID0gdGV4dHVyZS53aWR0aFxuICAgICAgaCA9IHRleHR1cmUuaGVpZ2h0XG4gICAgfSBlbHNlIGlmIChyZW5kZXJidWZmZXIpIHtcbiAgICAgIHcgPSByZW5kZXJidWZmZXIud2lkdGhcbiAgICAgIGggPSByZW5kZXJidWZmZXIuaGVpZ2h0XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3XG4gICAgdGhpcy5oZWlnaHQgPSBoXG4gIH1cblxuICBmdW5jdGlvbiBkZWNSZWYgKGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBhdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuZGVjUmVmKClcbiAgICAgIH1cbiAgICAgIGlmIChhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcikge1xuICAgICAgICBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmRlY1JlZigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5jUmVmQW5kQ2hlY2tTaGFwZSAoYXR0YWNobWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlXG4gICAgICB2YXIgdHcgPSBNYXRoLm1heCgxLCB0ZXh0dXJlLndpZHRoKVxuICAgICAgdmFyIHRoID0gTWF0aC5tYXgoMSwgdGV4dHVyZS5oZWlnaHQpXG4gICAgICBjaGVjayQxKHR3ID09PSB3aWR0aCAmJiB0aCA9PT0gaGVpZ2h0LFxuICAgICAgICAnaW5jb25zaXN0ZW50IHdpZHRoL2hlaWdodCBmb3Igc3VwcGxpZWQgdGV4dHVyZScpXG4gICAgICB0ZXh0dXJlLnJlZkNvdW50ICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlbmRlcmJ1ZmZlciA9IGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXJcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHJlbmRlcmJ1ZmZlci53aWR0aCA9PT0gd2lkdGggJiYgcmVuZGVyYnVmZmVyLmhlaWdodCA9PT0gaGVpZ2h0LFxuICAgICAgICAnaW5jb25zaXN0ZW50IHdpZHRoL2hlaWdodCBmb3IgcmVuZGVyYnVmZmVyJylcbiAgICAgIHJlbmRlcmJ1ZmZlci5yZWZDb3VudCArPSAxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoIChsb2NhdGlvbiwgYXR0YWNobWVudCkge1xuICAgIGlmIChhdHRhY2htZW50KSB7XG4gICAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgYXR0YWNobWVudC50YXJnZXQsXG4gICAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLnRleHR1cmUsXG4gICAgICAgICAgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKFxuICAgICAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgR0xfUkVOREVSQlVGRkVSJDEsXG4gICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VBdHRhY2htZW50IChhdHRhY2htZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IEdMX1RFWFRVUkVfMkQkMlxuICAgIHZhciB0ZXh0dXJlID0gbnVsbFxuICAgIHZhciByZW5kZXJidWZmZXIgPSBudWxsXG5cbiAgICB2YXIgZGF0YSA9IGF0dGFjaG1lbnRcbiAgICBpZiAodHlwZW9mIGF0dGFjaG1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhXG4gICAgICBpZiAoJ3RhcmdldCcgaW4gYXR0YWNobWVudCkge1xuICAgICAgICB0YXJnZXQgPSBhdHRhY2htZW50LnRhcmdldCB8IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayQxLnR5cGUoZGF0YSwgJ2Z1bmN0aW9uJywgJ2ludmFsaWQgYXR0YWNobWVudCBkYXRhJylcblxuICAgIHZhciB0eXBlID0gZGF0YS5fcmVnbFR5cGVcbiAgICBpZiAodHlwZSA9PT0gJ3RleHR1cmUyZCcpIHtcbiAgICAgIHRleHR1cmUgPSBkYXRhXG4gICAgICBjaGVjayQxKHRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQyKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RleHR1cmVDdWJlJykge1xuICAgICAgdGV4dHVyZSA9IGRhdGFcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHRhcmdldCA+PSBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiAmJlxuICAgICAgICB0YXJnZXQgPCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiArIDYsXG4gICAgICAgICdpbnZhbGlkIGN1YmUgbWFwIHRhcmdldCcpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVuZGVyYnVmZmVyJykge1xuICAgICAgcmVuZGVyYnVmZmVyID0gZGF0YVxuICAgICAgdGFyZ2V0ID0gR0xfUkVOREVSQlVGRkVSJDFcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCByZWdsIG9iamVjdCBmb3IgYXR0YWNobWVudCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGcmFtZWJ1ZmZlckF0dGFjaG1lbnQodGFyZ2V0LCB0ZXh0dXJlLCByZW5kZXJidWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBhbGxvY0F0dGFjaG1lbnQgKFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBpc1RleHR1cmUsXG4gICAgZm9ybWF0LFxuICAgIHR5cGUpIHtcbiAgICBpZiAoaXNUZXh0dXJlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVTdGF0ZS5jcmVhdGUyRCh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9KVxuICAgICAgdGV4dHVyZS5fdGV4dHVyZS5yZWZDb3VudCA9IDBcbiAgICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KEdMX1RFWFRVUkVfMkQkMiwgdGV4dHVyZSwgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJiID0gcmVuZGVyYnVmZmVyU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgIH0pXG4gICAgICByYi5fcmVuZGVyYnVmZmVyLnJlZkNvdW50ID0gMFxuICAgICAgcmV0dXJuIG5ldyBGcmFtZWJ1ZmZlckF0dGFjaG1lbnQoR0xfUkVOREVSQlVGRkVSJDEsIG51bGwsIHJiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud3JhcEF0dGFjaG1lbnQgKGF0dGFjaG1lbnQpIHtcbiAgICByZXR1cm4gYXR0YWNobWVudCAmJiAoYXR0YWNobWVudC50ZXh0dXJlIHx8IGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplQXR0YWNobWVudCAoYXR0YWNobWVudCwgdywgaCkge1xuICAgIGlmIChhdHRhY2htZW50KSB7XG4gICAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgICAgIGF0dGFjaG1lbnQudGV4dHVyZS5yZXNpemUodywgaClcbiAgICAgIH0gZWxzZSBpZiAoYXR0YWNobWVudC5yZW5kZXJidWZmZXIpIHtcbiAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIucmVzaXplKHcsIGgpXG4gICAgICB9XG4gICAgICBhdHRhY2htZW50LndpZHRoID0gd1xuICAgICAgYXR0YWNobWVudC5oZWlnaHQgPSBoXG4gICAgfVxuICB9XG5cbiAgdmFyIGZyYW1lYnVmZmVyQ291bnQgPSAwXG4gIHZhciBmcmFtZWJ1ZmZlclNldCA9IHt9XG5cbiAgZnVuY3Rpb24gUkVHTEZyYW1lYnVmZmVyICgpIHtcbiAgICB0aGlzLmlkID0gZnJhbWVidWZmZXJDb3VudCsrXG4gICAgZnJhbWVidWZmZXJTZXRbdGhpcy5pZF0gPSB0aGlzXG5cbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKVxuICAgIHRoaXMud2lkdGggPSAwXG4gICAgdGhpcy5oZWlnaHQgPSAwXG5cbiAgICB0aGlzLmNvbG9yQXR0YWNobWVudHMgPSBbXVxuICAgIHRoaXMuZGVwdGhBdHRhY2htZW50ID0gbnVsbFxuICAgIHRoaXMuc3RlbmNpbEF0dGFjaG1lbnQgPSBudWxsXG4gICAgdGhpcy5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gZGVjRkJPUmVmcyAoZnJhbWVidWZmZXIpIHtcbiAgICBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzLmZvckVhY2goZGVjUmVmKVxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5kZXB0aEF0dGFjaG1lbnQpXG4gICAgZGVjUmVmKGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50KVxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAoZnJhbWVidWZmZXIpIHtcbiAgICB2YXIgaGFuZGxlID0gZnJhbWVidWZmZXIuZnJhbWVidWZmZXJcbiAgICBjaGVjayQxKGhhbmRsZSwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IGZyYW1lYnVmZmVyJylcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihoYW5kbGUpXG4gICAgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBudWxsXG4gICAgc3RhdHMuZnJhbWVidWZmZXJDb3VudC0tXG4gICAgZGVsZXRlIGZyYW1lYnVmZmVyU2V0W2ZyYW1lYnVmZmVyLmlkXVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhbWVidWZmZXIgKGZyYW1lYnVmZmVyKSB7XG4gICAgdmFyIGlcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9GUkFNRUJVRkZFUiQxLCBmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlcilcbiAgICB2YXIgY29sb3JBdHRhY2htZW50cyA9IGZyYW1lYnVmZmVyLmNvbG9yQXR0YWNobWVudHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JBdHRhY2htZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgYXR0YWNoKEdMX0NPTE9SX0FUVEFDSE1FTlQwJDEgKyBpLCBjb2xvckF0dGFjaG1lbnRzW2ldKVxuICAgIH1cbiAgICBmb3IgKGkgPSBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgaSA8IGxpbWl0cy5tYXhDb2xvckF0dGFjaG1lbnRzOyArK2kpIHtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQxICsgaSxcbiAgICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAwKVxuICAgIH1cblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgR0xfRlJBTUVCVUZGRVIkMSxcbiAgICAgIEdMX0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCxcbiAgICAgIEdMX1RFWFRVUkVfMkQkMixcbiAgICAgIG51bGwsXG4gICAgICAwKVxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgR0xfRlJBTUVCVUZGRVIkMSxcbiAgICAgIEdMX0RFUFRIX0FUVEFDSE1FTlQsXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXG4gICAgICBudWxsLFxuICAgICAgMClcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9TVEVOQ0lMX0FUVEFDSE1FTlQsXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXG4gICAgICBudWxsLFxuICAgICAgMClcblxuICAgIGF0dGFjaChHTF9ERVBUSF9BVFRBQ0hNRU5ULCBmcmFtZWJ1ZmZlci5kZXB0aEF0dGFjaG1lbnQpXG4gICAgYXR0YWNoKEdMX1NURU5DSUxfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuc3RlbmNpbEF0dGFjaG1lbnQpXG4gICAgYXR0YWNoKEdMX0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudClcblxuICAgIC8vIENoZWNrIHN0YXR1cyBjb2RlXG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoR0xfRlJBTUVCVUZGRVIkMSlcbiAgICBpZiAoIWdsLmlzQ29udGV4dExvc3QoKSAmJiBzdGF0dXMgIT09IEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEpIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoJ2ZyYW1lYnVmZmVyIGNvbmZpZ3VyYXRpb24gbm90IHN1cHBvcnRlZCwgc3RhdHVzID0gJyArXG4gICAgICAgIHN0YXR1c0NvZGVbc3RhdHVzXSlcbiAgICB9XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIkMSwgZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID8gZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmZyYW1lYnVmZmVyIDogbnVsbClcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLmN1ciA9IGZyYW1lYnVmZmVyU3RhdGUubmV4dFxuXG4gICAgLy8gRklYTUU6IENsZWFyIGVycm9yIGNvZGUgaGVyZS4gIFRoaXMgaXMgYSB3b3JrIGFyb3VuZCBmb3IgYSBidWcgaW5cbiAgICAvLyBoZWFkbGVzcy1nbFxuICAgIGdsLmdldEVycm9yKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZCTyAoYTAsIGExKSB7XG4gICAgdmFyIGZyYW1lYnVmZmVyID0gbmV3IFJFR0xGcmFtZWJ1ZmZlcigpXG4gICAgc3RhdHMuZnJhbWVidWZmZXJDb3VudCsrXG5cbiAgICBmdW5jdGlvbiByZWdsRnJhbWVidWZmZXIgKGEsIGIpIHtcbiAgICAgIHZhciBpXG5cbiAgICAgIGNoZWNrJDEoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ICE9PSBmcmFtZWJ1ZmZlcixcbiAgICAgICAgJ2NhbiBub3QgdXBkYXRlIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgd2lkdGggPSAwXG4gICAgICB2YXIgaGVpZ2h0ID0gMFxuXG4gICAgICB2YXIgbmVlZHNEZXB0aCA9IHRydWVcbiAgICAgIHZhciBuZWVkc1N0ZW5jaWwgPSB0cnVlXG5cbiAgICAgIHZhciBjb2xvckJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBjb2xvclRleHR1cmUgPSB0cnVlXG4gICAgICB2YXIgY29sb3JGb3JtYXQgPSAncmdiYSdcbiAgICAgIHZhciBjb2xvclR5cGUgPSAndWludDgnXG4gICAgICB2YXIgY29sb3JDb3VudCA9IDFcblxuICAgICAgdmFyIGRlcHRoQnVmZmVyID0gbnVsbFxuICAgICAgdmFyIHN0ZW5jaWxCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgZGVwdGhTdGVuY2lsQnVmZmVyID0gbnVsbFxuICAgICAgdmFyIGRlcHRoU3RlbmNpbFRleHR1cmUgPSBmYWxzZVxuXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdpZHRoID0gYSB8IDBcbiAgICAgICAgaGVpZ2h0ID0gKGIgfCAwKSB8fCB3aWR0aFxuICAgICAgfSBlbHNlIGlmICghYSkge1xuICAgICAgICB3aWR0aCA9IGhlaWdodCA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShhLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJndW1lbnRzIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgIHZhciBvcHRpb25zID0gYVxuXG4gICAgICAgIGlmICgnc2hhcGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc2hhcGUgPSBvcHRpb25zLnNoYXBlXG4gICAgICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgICAgd2lkdGggPSBzaGFwZVswXVxuICAgICAgICAgIGhlaWdodCA9IHNoYXBlWzFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ID0gb3B0aW9ucy5yYWRpdXNcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLndpZHRoXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnaGVpZ2h0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnY29sb3InIGluIG9wdGlvbnMgfHxcbiAgICAgICAgICAgICdjb2xvcnMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yc1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgY29sb3JCdWZmZXIubGVuZ3RoID09PSAxIHx8IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzLFxuICAgICAgICAgICAgICAnbXVsdGlwbGUgcmVuZGVyIHRhcmdldHMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvckJ1ZmZlcikge1xuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JDb3VudCA9IG9wdGlvbnMuY29sb3JDb3VudCB8IDBcbiAgICAgICAgICAgIGNoZWNrJDEoY29sb3JDb3VudCA+IDAsICdpbnZhbGlkIGNvbG9yIGJ1ZmZlciBjb3VudCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvclRleHR1cmUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9ICEhb3B0aW9ucy5jb2xvclRleHR1cmVcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gJ3JnYmE0J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JUeXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvclR5cGUgPSBvcHRpb25zLmNvbG9yVHlwZVxuICAgICAgICAgICAgaWYgKCFjb2xvclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbG9yVHlwZSA9PT0gJ2hhbGYgZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MTYnKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMShleHRlbnNpb25zLmV4dF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCxcbiAgICAgICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0IHRvIHVzZSAxNi1iaXQgcmVuZGVyIGJ1ZmZlcnMnKVxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gJ3JnYmExNmYnXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3JUeXBlID09PSAnZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCxcbiAgICAgICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0IGluIG9yZGVyIHRvIHVzZSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgcmVuZGVyYnVmZmVycycpXG4gICAgICAgICAgICAgICAgY29sb3JGb3JtYXQgPSAncmdiYTMyZidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hlY2skMShleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0IHx8XG4gICAgICAgICAgICAgICAgIShjb2xvclR5cGUgPT09ICdmbG9hdCcgfHwgY29sb3JUeXBlID09PSAnZmxvYXQzMicpLFxuICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIE9FU190ZXh0dXJlX2Zsb2F0IGluIG9yZGVyIHRvIHVzZSBmbG9hdGluZyBwb2ludCBmcmFtZWJ1ZmZlciBvYmplY3RzJylcbiAgICAgICAgICAgICAgY2hlY2skMShleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQgfHxcbiAgICAgICAgICAgICAgICAhKGNvbG9yVHlwZSA9PT0gJ2hhbGYgZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MTYnKSxcbiAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0IGluIG9yZGVyIHRvIHVzZSAxNi1iaXQgZmxvYXRpbmcgcG9pbnQgZnJhbWVidWZmZXIgb2JqZWN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKGNvbG9yVHlwZSwgY29sb3JUeXBlcywgJ2ludmFsaWQgY29sb3IgdHlwZScpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvckZvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0XG4gICAgICAgICAgICBpZiAoY29sb3JUZXh0dXJlRm9ybWF0cy5pbmRleE9mKGNvbG9yRm9ybWF0KSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLmluZGV4T2YoY29sb3JGb3JtYXQpID49IDApIHtcbiAgICAgICAgICAgICAgY29sb3JUZXh0dXJlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvckZvcm1hdCwgY29sb3JUZXh0dXJlRm9ybWF0cyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIGZvcm1hdCBmb3IgdGV4dHVyZScpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIGZvcm1hdCBmb3IgcmVuZGVyYnVmZmVyJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGhUZXh0dXJlJyBpbiBvcHRpb25zIHx8ICdkZXB0aFN0ZW5jaWxUZXh0dXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgZGVwdGhTdGVuY2lsVGV4dHVyZSA9ICEhKG9wdGlvbnMuZGVwdGhUZXh0dXJlIHx8XG4gICAgICAgICAgICBvcHRpb25zLmRlcHRoU3RlbmNpbFRleHR1cmUpXG4gICAgICAgICAgY2hlY2skMSghZGVwdGhTdGVuY2lsVGV4dHVyZSB8fCBleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUsXG4gICAgICAgICAgICAnd2ViZ2xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBvcHRpb25zLmRlcHRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aFxuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3RlbmNpbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc1N0ZW5jaWwgPSBvcHRpb25zLnN0ZW5jaWxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbFxuICAgICAgICAgICAgbmVlZHNEZXB0aCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aFN0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhTdGVuY2lsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBuZWVkc1N0ZW5jaWwgPSBvcHRpb25zLmRlcHRoU3RlbmNpbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLmRlcHRoU3RlbmNpbFxuICAgICAgICAgICAgbmVlZHNEZXB0aCA9IGZhbHNlXG4gICAgICAgICAgICBuZWVkc1N0ZW5jaWwgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBhdHRhY2htZW50c1xuICAgICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBudWxsXG4gICAgICB2YXIgZGVwdGhBdHRhY2htZW50ID0gbnVsbFxuICAgICAgdmFyIHN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuICAgICAgdmFyIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBudWxsXG5cbiAgICAgIC8vIFNldCB1cCBjb2xvciBhdHRhY2htZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JCdWZmZXIpKSB7XG4gICAgICAgIGNvbG9yQXR0YWNobWVudHMgPSBjb2xvckJ1ZmZlci5tYXAocGFyc2VBdHRhY2htZW50KVxuICAgICAgfSBlbHNlIGlmIChjb2xvckJ1ZmZlcikge1xuICAgICAgICBjb2xvckF0dGFjaG1lbnRzID0gW3BhcnNlQXR0YWNobWVudChjb2xvckJ1ZmZlcildXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvckF0dGFjaG1lbnRzID0gbmV3IEFycmF5KGNvbG9yQ291bnQpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckNvdW50OyArK2kpIHtcbiAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzW2ldID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBjb2xvclRleHR1cmUsXG4gICAgICAgICAgICBjb2xvckZvcm1hdCxcbiAgICAgICAgICAgIGNvbG9yVHlwZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzIHx8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoIDw9IDEsXG4gICAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIG11bHRpcGxlIGNvbG9yIGJ1ZmZlcnMuJylcbiAgICAgIGNoZWNrJDEoY29sb3JBdHRhY2htZW50cy5sZW5ndGggPD0gbGltaXRzLm1heENvbG9yQXR0YWNobWVudHMsXG4gICAgICAgICd0b28gbWFueSBjb2xvciBhdHRhY2htZW50cywgbm90IHN1cHBvcnRlZCcpXG5cbiAgICAgIHdpZHRoID0gd2lkdGggfHwgY29sb3JBdHRhY2htZW50c1swXS53aWR0aFxuICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGNvbG9yQXR0YWNobWVudHNbMF0uaGVpZ2h0XG5cbiAgICAgIGlmIChkZXB0aEJ1ZmZlcikge1xuICAgICAgICBkZXB0aEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQoZGVwdGhCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzRGVwdGggJiYgIW5lZWRzU3RlbmNpbCkge1xuICAgICAgICBkZXB0aEF0dGFjaG1lbnQgPSBhbGxvY0F0dGFjaG1lbnQoXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGRlcHRoU3RlbmNpbFRleHR1cmUsXG4gICAgICAgICAgJ2RlcHRoJyxcbiAgICAgICAgICAndWludDMyJylcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgICAgc3RlbmNpbEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQoc3RlbmNpbEJ1ZmZlcilcbiAgICAgIH0gZWxzZSBpZiAobmVlZHNTdGVuY2lsICYmICFuZWVkc0RlcHRoKSB7XG4gICAgICAgIHN0ZW5jaWxBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnc3RlbmNpbCcsXG4gICAgICAgICAgJ3VpbnQ4JylcbiAgICAgIH1cblxuICAgICAgaWYgKGRlcHRoU3RlbmNpbEJ1ZmZlcikge1xuICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KGRlcHRoU3RlbmNpbEJ1ZmZlcilcbiAgICAgIH0gZWxzZSBpZiAoIWRlcHRoQnVmZmVyICYmICFzdGVuY2lsQnVmZmVyICYmIG5lZWRzU3RlbmNpbCAmJiBuZWVkc0RlcHRoKSB7XG4gICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBhbGxvY0F0dGFjaG1lbnQoXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGRlcHRoU3RlbmNpbFRleHR1cmUsXG4gICAgICAgICAgJ2RlcHRoIHN0ZW5jaWwnLFxuICAgICAgICAgICdkZXB0aCBzdGVuY2lsJylcbiAgICAgIH1cblxuICAgICAgY2hlY2skMShcbiAgICAgICAgKCEhZGVwdGhCdWZmZXIpICsgKCEhc3RlbmNpbEJ1ZmZlcikgKyAoISFkZXB0aFN0ZW5jaWxCdWZmZXIpIDw9IDEsXG4gICAgICAgICdpbnZhbGlkIGZyYW1lYnVmZmVyIGNvbmZpZ3VyYXRpb24sIGNhbiBzcGVjaWZ5IGV4YWN0bHkgb25lIGRlcHRoL3N0ZW5jaWwgYXR0YWNobWVudCcpXG5cbiAgICAgIHZhciBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gbnVsbFxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JBdHRhY2htZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbmNSZWZBbmRDaGVja1NoYXBlKGNvbG9yQXR0YWNobWVudHNbaV0sIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIGNoZWNrJDEoIWNvbG9yQXR0YWNobWVudHNbaV0gfHxcbiAgICAgICAgICAoY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlICYmXG4gICAgICAgICAgICBjb2xvclRleHR1cmVGb3JtYXRFbnVtcy5pbmRleE9mKGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS5mb3JtYXQpID49IDApIHx8XG4gICAgICAgICAgKGNvbG9yQXR0YWNobWVudHNbaV0ucmVuZGVyYnVmZmVyICYmXG4gICAgICAgICAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zLmluZGV4T2YoY29sb3JBdHRhY2htZW50c1tpXS5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQpID49IDApLFxuICAgICAgICAnZnJhbWVidWZmZXIgY29sb3IgYXR0YWNobWVudCAnICsgaSArICcgaXMgaW52YWxpZCcpXG5cbiAgICAgICAgaWYgKGNvbG9yQXR0YWNobWVudHNbaV0gJiYgY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlKSB7XG4gICAgICAgICAgdmFyIGNvbG9yQXR0YWNobWVudFNpemUgPVxuICAgICAgICAgICAgICB0ZXh0dXJlRm9ybWF0Q2hhbm5lbHNbY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdF0gKlxuICAgICAgICAgICAgICB0ZXh0dXJlVHlwZVNpemVzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS50eXBlXVxuXG4gICAgICAgICAgaWYgKGNvbW1vbkNvbG9yQXR0YWNobWVudFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1vbkNvbG9yQXR0YWNobWVudFNpemUgPSBjb2xvckF0dGFjaG1lbnRTaXplXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGNvbG9yIGF0dGFjaG1lbnRzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGJpdHBsYW5lc1xuICAgICAgICAgICAgLy8gKHRoYXQgaXMsIHRoZSBzYW1lIG51bWVyIG9mIGJpdHMgcGVyIHBpeGVsKVxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSB0aGUgR0xFUzIuMCBzdGFuZGFyZC4gU2VlIHRoZSBiZWdpbm5pbmcgb2YgQ2hhcHRlciA0IGluIHRoYXQgZG9jdW1lbnQuXG4gICAgICAgICAgICBjaGVjayQxKGNvbW1vbkNvbG9yQXR0YWNobWVudFNpemUgPT09IGNvbG9yQXR0YWNobWVudFNpemUsXG4gICAgICAgICAgICAgICdhbGwgY29sb3IgYXR0YWNobWVudHMgbXVjaCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRzIHBlciBwaXhlbC4nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShkZXB0aEF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpXG4gICAgICBjaGVjayQxKCFkZXB0aEF0dGFjaG1lbnQgfHxcbiAgICAgICAgKGRlcHRoQXR0YWNobWVudC50ZXh0dXJlICYmXG4gICAgICAgICAgZGVwdGhBdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuZm9ybWF0ID09PSBHTF9ERVBUSF9DT01QT05FTlQkMSkgfHxcbiAgICAgICAgKGRlcHRoQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBkZXB0aEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZm9ybWF0ID09PSBHTF9ERVBUSF9DT01QT05FTlQxNiQxKSxcbiAgICAgICdpbnZhbGlkIGRlcHRoIGF0dGFjaG1lbnQgZm9yIGZyYW1lYnVmZmVyIG9iamVjdCcpXG4gICAgICBpbmNSZWZBbmRDaGVja1NoYXBlKHN0ZW5jaWxBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghc3RlbmNpbEF0dGFjaG1lbnQgfHxcbiAgICAgICAgKHN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlciAmJlxuICAgICAgICAgIHN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfU1RFTkNJTF9JTkRFWDgkMSksXG4gICAgICAnaW52YWxpZCBzdGVuY2lsIGF0dGFjaG1lbnQgZm9yIGZyYW1lYnVmZmVyIG9iamVjdCcpXG4gICAgICBpbmNSZWZBbmRDaGVja1NoYXBlKGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpXG4gICAgICBjaGVjayQxKCFkZXB0aFN0ZW5jaWxBdHRhY2htZW50IHx8XG4gICAgICAgIChkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnRleHR1cmUgJiZcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuZm9ybWF0ID09PSBHTF9ERVBUSF9TVEVOQ0lMJDIpIHx8XG4gICAgICAgIChkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlciAmJlxuICAgICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZm9ybWF0ID09PSBHTF9ERVBUSF9TVEVOQ0lMJDIpLFxuICAgICAgJ2ludmFsaWQgZGVwdGgtc3RlbmNpbCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuXG4gICAgICAvLyBkZWNyZW1lbnQgcmVmZXJlbmNlc1xuICAgICAgZGVjRkJPUmVmcyhmcmFtZWJ1ZmZlcilcblxuICAgICAgZnJhbWVidWZmZXIud2lkdGggPSB3aWR0aFxuICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0ID0gaGVpZ2h0XG5cbiAgICAgIGZyYW1lYnVmZmVyLmNvbG9yQXR0YWNobWVudHMgPSBjb2xvckF0dGFjaG1lbnRzXG4gICAgICBmcmFtZWJ1ZmZlci5kZXB0aEF0dGFjaG1lbnQgPSBkZXB0aEF0dGFjaG1lbnRcbiAgICAgIGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50ID0gc3RlbmNpbEF0dGFjaG1lbnRcbiAgICAgIGZyYW1lYnVmZmVyLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBkZXB0aFN0ZW5jaWxBdHRhY2htZW50XG5cbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5jb2xvciA9IGNvbG9yQXR0YWNobWVudHMubWFwKHVud3JhcEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuZGVwdGggPSB1bndyYXBBdHRhY2htZW50KGRlcHRoQXR0YWNobWVudClcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5zdGVuY2lsID0gdW53cmFwQXR0YWNobWVudChzdGVuY2lsQXR0YWNobWVudClcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWwgPSB1bndyYXBBdHRhY2htZW50KGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpXG5cbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci53aWR0aCA9IGZyYW1lYnVmZmVyLndpZHRoXG4gICAgICByZWdsRnJhbWVidWZmZXIuaGVpZ2h0ID0gZnJhbWVidWZmZXIuaGVpZ2h0XG5cbiAgICAgIHVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKVxuXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcbiAgICAgIGNoZWNrJDEoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ICE9PSBmcmFtZWJ1ZmZlcixcbiAgICAgICAgJ2NhbiBub3QgcmVzaXplIGEgZnJhbWVidWZmZXIgd2hpY2ggaXMgY3VycmVudGx5IGluIHVzZScpXG5cbiAgICAgIHZhciB3ID0gTWF0aC5tYXgod18gfCAwLCAxKVxuICAgICAgdmFyIGggPSBNYXRoLm1heCgoaF8gfCAwKSB8fCB3LCAxKVxuICAgICAgaWYgKHcgPT09IGZyYW1lYnVmZmVyLndpZHRoICYmIGggPT09IGZyYW1lYnVmZmVyLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2l6ZSBhbGwgYnVmZmVyc1xuICAgICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzaXplQXR0YWNobWVudChjb2xvckF0dGFjaG1lbnRzW2ldLCB3LCBoKVxuICAgICAgfVxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5kZXB0aEF0dGFjaG1lbnQsIHcsIGgpXG4gICAgICByZXNpemVBdHRhY2htZW50KGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50LCB3LCBoKVxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50LCB3LCBoKVxuXG4gICAgICBmcmFtZWJ1ZmZlci53aWR0aCA9IHJlZ2xGcmFtZWJ1ZmZlci53aWR0aCA9IHdcbiAgICAgIGZyYW1lYnVmZmVyLmhlaWdodCA9IHJlZ2xGcmFtZWJ1ZmZlci5oZWlnaHQgPSBoXG5cbiAgICAgIHVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKVxuXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXG4gICAgfVxuXG4gICAgcmVnbEZyYW1lYnVmZmVyKGEwLCBhMSlcblxuICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyLCB7XG4gICAgICByZXNpemU6IHJlc2l6ZSxcbiAgICAgIF9yZWdsVHlwZTogJ2ZyYW1lYnVmZmVyJyxcbiAgICAgIF9mcmFtZWJ1ZmZlcjogZnJhbWVidWZmZXIsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlc3Ryb3koZnJhbWVidWZmZXIpXG4gICAgICAgIGRlY0ZCT1JlZnMoZnJhbWVidWZmZXIpXG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgZnJhbWVidWZmZXJTdGF0ZS5zZXRGQk8oe1xuICAgICAgICAgIGZyYW1lYnVmZmVyOiByZWdsRnJhbWVidWZmZXJcbiAgICAgICAgfSwgYmxvY2spXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1YmVGQk8gKG9wdGlvbnMpIHtcbiAgICB2YXIgZmFjZXMgPSBBcnJheSg2KVxuXG4gICAgZnVuY3Rpb24gcmVnbEZyYW1lYnVmZmVyQ3ViZSAoYSkge1xuICAgICAgdmFyIGlcblxuICAgICAgY2hlY2skMShmYWNlcy5pbmRleE9mKGZyYW1lYnVmZmVyU3RhdGUubmV4dCkgPCAwLFxuICAgICAgICAnY2FuIG5vdCB1cGRhdGUgZnJhbWVidWZmZXIgd2hpY2ggaXMgY3VycmVudGx5IGluIHVzZScpXG5cbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIGNvbG9yOiBudWxsXG4gICAgICB9XG5cbiAgICAgIHZhciByYWRpdXMgPSAwXG5cbiAgICAgIHZhciBjb2xvckJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBjb2xvckZvcm1hdCA9ICdyZ2JhJ1xuICAgICAgdmFyIGNvbG9yVHlwZSA9ICd1aW50OCdcbiAgICAgIHZhciBjb2xvckNvdW50ID0gMVxuXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJhZGl1cyA9IGEgfCAwXG4gICAgICB9IGVsc2UgaWYgKCFhKSB7XG4gICAgICAgIHJhZGl1cyA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShhLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJndW1lbnRzIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgIHZhciBvcHRpb25zID0gYVxuXG4gICAgICAgIGlmICgnc2hhcGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc2hhcGUgPSBvcHRpb25zLnNoYXBlXG4gICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc2hhcGUpICYmIHNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIGZyYW1lYnVmZmVyJylcbiAgICAgICAgICBjaGVjayQxKFxuICAgICAgICAgICAgc2hhcGVbMF0gPT09IHNoYXBlWzFdLFxuICAgICAgICAgICAgJ2N1YmUgZnJhbWVidWZmZXIgbXVzdCBiZSBzcXVhcmUnKVxuICAgICAgICAgIHJhZGl1cyA9IHNoYXBlWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBvcHRpb25zLndpZHRoIHwgMFxuICAgICAgICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgY2hlY2skMShvcHRpb25zLmhlaWdodCA9PT0gcmFkaXVzLCAnbXVzdCBiZSBzcXVhcmUnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy5oZWlnaHQgfCAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdjb2xvcicgaW4gb3B0aW9ucyB8fFxuICAgICAgICAgICAgJ2NvbG9ycycgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNvbG9yQnVmZmVyID1cbiAgICAgICAgICAgIG9wdGlvbnMuY29sb3IgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuY29sb3JzXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JCdWZmZXIpKSB7XG4gICAgICAgICAgICBjaGVjayQxKFxuICAgICAgICAgICAgICBjb2xvckJ1ZmZlci5sZW5ndGggPT09IDEgfHwgZXh0ZW5zaW9ucy53ZWJnbF9kcmF3X2J1ZmZlcnMsXG4gICAgICAgICAgICAgICdtdWx0aXBsZSByZW5kZXIgdGFyZ2V0cyBub3Qgc3VwcG9ydGVkJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbG9yQnVmZmVyKSB7XG4gICAgICAgICAgaWYgKCdjb2xvckNvdW50JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvckNvdW50ID0gb3B0aW9ucy5jb2xvckNvdW50IHwgMFxuICAgICAgICAgICAgY2hlY2skMShjb2xvckNvdW50ID4gMCwgJ2ludmFsaWQgY29sb3IgYnVmZmVyIGNvdW50JylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2NvbG9yVHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvclR5cGUsIGNvbG9yVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIHR5cGUnKVxuICAgICAgICAgICAgY29sb3JUeXBlID0gb3B0aW9ucy5jb2xvclR5cGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2NvbG9yRm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvckZvcm1hdCA9IG9wdGlvbnMuY29sb3JGb3JtYXRcbiAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIGZvcm1hdCBmb3IgdGV4dHVyZScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHBhcmFtcy5kZXB0aCA9IG9wdGlvbnMuZGVwdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnc3RlbmNpbCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHBhcmFtcy5zdGVuY2lsID0gb3B0aW9ucy5zdGVuY2lsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlcHRoU3RlbmNpbCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHBhcmFtcy5kZXB0aFN0ZW5jaWwgPSBvcHRpb25zLmRlcHRoU3RlbmNpbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckN1YmVzXG4gICAgICBpZiAoY29sb3JCdWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JCdWZmZXIpKSB7XG4gICAgICAgICAgY29sb3JDdWJlcyA9IFtdXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xvckN1YmVzW2ldID0gY29sb3JCdWZmZXJbaV1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sb3JDdWJlcyA9IFsgY29sb3JCdWZmZXIgXVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvckN1YmVzID0gQXJyYXkoY29sb3JDb3VudClcbiAgICAgICAgdmFyIGN1YmVNYXBQYXJhbXMgPSB7XG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgZm9ybWF0OiBjb2xvckZvcm1hdCxcbiAgICAgICAgICB0eXBlOiBjb2xvclR5cGVcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JDb3VudDsgKytpKSB7XG4gICAgICAgICAgY29sb3JDdWJlc1tpXSA9IHRleHR1cmVTdGF0ZS5jcmVhdGVDdWJlKGN1YmVNYXBQYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgY29sb3IgY3ViZXNcbiAgICAgIHBhcmFtcy5jb2xvciA9IEFycmF5KGNvbG9yQ3ViZXMubGVuZ3RoKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQ3ViZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1YmUgPSBjb2xvckN1YmVzW2ldXG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZW9mIGN1YmUgPT09ICdmdW5jdGlvbicgJiYgY3ViZS5fcmVnbFR5cGUgPT09ICd0ZXh0dXJlQ3ViZScsXG4gICAgICAgICAgJ2ludmFsaWQgY3ViZSBtYXAnKVxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgY3ViZS53aWR0aFxuICAgICAgICBjaGVjayQxKFxuICAgICAgICAgIGN1YmUud2lkdGggPT09IHJhZGl1cyAmJiBjdWJlLmhlaWdodCA9PT0gcmFkaXVzLFxuICAgICAgICAgICdpbnZhbGlkIGN1YmUgbWFwIHNoYXBlJylcbiAgICAgICAgcGFyYW1zLmNvbG9yW2ldID0ge1xuICAgICAgICAgIHRhcmdldDogR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIsXG4gICAgICAgICAgZGF0YTogY29sb3JDdWJlc1tpXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xvckN1YmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgcGFyYW1zLmNvbG9yW2pdLnRhcmdldCA9IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyICsgaVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldXNlIGRlcHRoLXN0ZW5jaWwgYXR0YWNobWVudHMgYWNyb3NzIGFsbCBjdWJlIG1hcHNcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcGFyYW1zLmRlcHRoID0gZmFjZXNbMF0uZGVwdGhcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IGZhY2VzWzBdLnN0ZW5jaWxcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gZmFjZXNbMF0uZGVwdGhTdGVuY2lsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhY2VzW2ldKSB7XG4gICAgICAgICAgKGZhY2VzW2ldKShwYXJhbXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZXNbaV0gPSBjcmVhdGVGQk8ocGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyQ3ViZSwge1xuICAgICAgICB3aWR0aDogcmFkaXVzLFxuICAgICAgICBoZWlnaHQ6IHJhZGl1cyxcbiAgICAgICAgY29sb3I6IGNvbG9yQ3ViZXNcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplIChyYWRpdXNfKSB7XG4gICAgICB2YXIgaVxuICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c18gfCAwXG4gICAgICBjaGVjayQxKHJhZGl1cyA+IDAgJiYgcmFkaXVzIDw9IGxpbWl0cy5tYXhDdWJlTWFwU2l6ZSxcbiAgICAgICAgJ2ludmFsaWQgcmFkaXVzIGZvciBjdWJlIGZibycpXG5cbiAgICAgIGlmIChyYWRpdXMgPT09IHJlZ2xGcmFtZWJ1ZmZlckN1YmUud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlckN1YmVcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9ycyA9IHJlZ2xGcmFtZWJ1ZmZlckN1YmUuY29sb3JcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29sb3JzW2ldLnJlc2l6ZShyYWRpdXMpXG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZmFjZXNbaV0ucmVzaXplKHJhZGl1cylcbiAgICAgIH1cblxuICAgICAgcmVnbEZyYW1lYnVmZmVyQ3ViZS53aWR0aCA9IHJlZ2xGcmFtZWJ1ZmZlckN1YmUuaGVpZ2h0ID0gcmFkaXVzXG5cbiAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXG4gICAgfVxuXG4gICAgcmVnbEZyYW1lYnVmZmVyQ3ViZShvcHRpb25zKVxuXG4gICAgcmV0dXJuIGV4dGVuZChyZWdsRnJhbWVidWZmZXJDdWJlLCB7XG4gICAgICBmYWNlczogZmFjZXMsXG4gICAgICByZXNpemU6IHJlc2l6ZSxcbiAgICAgIF9yZWdsVHlwZTogJ2ZyYW1lYnVmZmVyQ3ViZScsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZhY2VzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICBmLmRlc3Ryb3koKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlRnJhbWVidWZmZXJzICgpIHtcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLmN1ciA9IG51bGxcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLm5leHQgPSBudWxsXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5kaXJ0eSA9IHRydWVcbiAgICB2YWx1ZXMoZnJhbWVidWZmZXJTZXQpLmZvckVhY2goZnVuY3Rpb24gKGZiKSB7XG4gICAgICBmYi5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICAgIHVwZGF0ZUZyYW1lYnVmZmVyKGZiKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZXh0ZW5kKGZyYW1lYnVmZmVyU3RhdGUsIHtcbiAgICBnZXRGcmFtZWJ1ZmZlcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicgJiYgb2JqZWN0Ll9yZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyJykge1xuICAgICAgICB2YXIgZmJvID0gb2JqZWN0Ll9mcmFtZWJ1ZmZlclxuICAgICAgICBpZiAoZmJvIGluc3RhbmNlb2YgUkVHTEZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZib1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGVGQk8sXG4gICAgY3JlYXRlQ3ViZTogY3JlYXRlQ3ViZUZCTyxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFsdWVzKGZyYW1lYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG4gICAgfSxcbiAgICByZXN0b3JlOiByZXN0b3JlRnJhbWVidWZmZXJzXG4gIH0pXG59XG5cbnZhciBHTF9GTE9BVCQ2ID0gNTEyNlxudmFyIEdMX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjJcblxuZnVuY3Rpb24gQXR0cmlidXRlUmVjb3JkICgpIHtcbiAgdGhpcy5zdGF0ZSA9IDBcblxuICB0aGlzLnggPSAwLjBcbiAgdGhpcy55ID0gMC4wXG4gIHRoaXMueiA9IDAuMFxuICB0aGlzLncgPSAwLjBcblxuICB0aGlzLmJ1ZmZlciA9IG51bGxcbiAgdGhpcy5zaXplID0gMFxuICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZVxuICB0aGlzLnR5cGUgPSBHTF9GTE9BVCQ2XG4gIHRoaXMub2Zmc2V0ID0gMFxuICB0aGlzLnN0cmlkZSA9IDBcbiAgdGhpcy5kaXZpc29yID0gMFxufVxuXG5mdW5jdGlvbiB3cmFwQXR0cmlidXRlU3RhdGUgKFxuICBnbCxcbiAgZXh0ZW5zaW9ucyxcbiAgbGltaXRzLFxuICBzdGF0cyxcbiAgYnVmZmVyU3RhdGUpIHtcbiAgdmFyIE5VTV9BVFRSSUJVVEVTID0gbGltaXRzLm1heEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZUJpbmRpbmdzID0gbmV3IEFycmF5KE5VTV9BVFRSSUJVVEVTKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IE5VTV9BVFRSSUJVVEVTOyArK2kpIHtcbiAgICBhdHRyaWJ1dGVCaW5kaW5nc1tpXSA9IG5ldyBBdHRyaWJ1dGVSZWNvcmQoKVxuICB9XG4gIHZhciB2YW9Db3VudCA9IDBcbiAgdmFyIHZhb1NldCA9IHt9XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIFJlY29yZDogQXR0cmlidXRlUmVjb3JkLFxuICAgIHNjb3BlOiB7fSxcbiAgICBzdGF0ZTogYXR0cmlidXRlQmluZGluZ3MsXG4gICAgY3VycmVudFZBTzogbnVsbCxcbiAgICB0YXJnZXRWQU86IG51bGwsXG4gICAgcmVzdG9yZTogZXh0VkFPKCkgPyByZXN0b3JlVkFPIDogZnVuY3Rpb24gKCkge30sXG4gICAgY3JlYXRlVkFPOiBjcmVhdGVWQU8sXG4gICAgZ2V0VkFPOiBnZXRWQU8sXG4gICAgZGVzdHJveUJ1ZmZlcjogZGVzdHJveUJ1ZmZlcixcbiAgICBzZXRWQU86IGV4dFZBTygpID8gc2V0VkFPRVhUIDogc2V0VkFPRW11bGF0ZWQsXG4gICAgY2xlYXI6IGV4dFZBTygpID8gZGVzdHJveVZBT0VYVCA6IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95QnVmZmVyIChidWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZUJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcmVjb3JkID0gYXR0cmlidXRlQmluZGluZ3NbaV1cbiAgICAgIGlmIChyZWNvcmQuYnVmZmVyID09PSBidWZmZXIpIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIHJlY29yZC5idWZmZXIgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0VkFPICgpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5vZXNfdmVydGV4X2FycmF5X29iamVjdFxuICB9XG5cbiAgZnVuY3Rpb24gZXh0SW5zdGFuY2VkICgpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRWQU8gKHZhbykge1xuICAgIGlmICh0eXBlb2YgdmFvID09PSAnZnVuY3Rpb24nICYmIHZhby5fdmFvKSB7XG4gICAgICByZXR1cm4gdmFvLl92YW9cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZBT0VYVCAodmFvKSB7XG4gICAgaWYgKHZhbyA9PT0gc3RhdGUuY3VycmVudFZBTykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBleHQgPSBleHRWQU8oKVxuICAgIGlmICh2YW8pIHtcbiAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModmFvLnZhbylcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKVxuICAgIH1cbiAgICBzdGF0ZS5jdXJyZW50VkFPID0gdmFvXG4gIH1cblxuICBmdW5jdGlvbiBzZXRWQU9FbXVsYXRlZCAodmFvKSB7XG4gICAgaWYgKHZhbyA9PT0gc3RhdGUuY3VycmVudFZBTykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YW8pIHtcbiAgICAgIHZhby5iaW5kQXR0cnMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXh0aSA9IGV4dEluc3RhbmNlZCgpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZUJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXR0cmlidXRlQmluZGluZ3NbaV1cbiAgICAgICAgaWYgKGJpbmRpbmcuYnVmZmVyKSB7XG4gICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGksIGJpbmRpbmcuc2l6ZSwgYmluZGluZy50eXBlLCBiaW5kaW5nLm5vcm1hbGl6ZWQsIGJpbmRpbmcuc3RyaWRlLCBiaW5kaW5nLm9mZmZzZXQpXG4gICAgICAgICAgaWYgKGV4dGkgJiYgYmluZGluZy5kaXZpc29yKSB7XG4gICAgICAgICAgICBleHRpLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShpLCBiaW5kaW5nLmRpdmlzb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjRmKGksIGJpbmRpbmcueCwgYmluZGluZy55LCBiaW5kaW5nLnosIGJpbmRpbmcudylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5jdXJyZW50VkFPID0gdmFvXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95VkFPRVhUICgpIHtcbiAgICB2YWx1ZXModmFvU2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh2YW8pIHtcbiAgICAgIHZhby5kZXN0cm95KClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gUkVHTFZBTyAoKSB7XG4gICAgdGhpcy5pZCA9ICsrdmFvQ291bnRcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXVxuICAgIHZhciBleHRlbnNpb24gPSBleHRWQU8oKVxuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgIHRoaXMudmFvID0gZXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YW8gPSBudWxsXG4gICAgfVxuICAgIHZhb1NldFt0aGlzLmlkXSA9IHRoaXNcbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXVxuICB9XG5cbiAgUkVHTFZBTy5wcm90b3R5cGUuYmluZEF0dHJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRpID0gZXh0SW5zdGFuY2VkKClcbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2ldXG4gICAgICBpZiAoYXR0ci5idWZmZXIpIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihHTF9BUlJBWV9CVUZGRVIkMSwgYXR0ci5idWZmZXIuYnVmZmVyKVxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGksIGF0dHIuc2l6ZSwgYXR0ci50eXBlLCBhdHRyLm5vcm1hbGl6ZWQsIGF0dHIuc3RyaWRlLCBhdHRyLm9mZnNldClcbiAgICAgICAgaWYgKGV4dGkgJiYgYXR0ci5kaXZpc29yKSB7XG4gICAgICAgICAgZXh0aS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaSwgYXR0ci5kaXZpc29yKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNGYoaSwgYXR0ci54LCBhdHRyLnksIGF0dHIueiwgYXR0ci53KVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBqID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBOVU1fQVRUUklCVVRFUzsgKytqKSB7XG4gICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoailcbiAgICB9XG4gIH1cblxuICBSRUdMVkFPLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHQgPSBleHRWQU8oKVxuICAgIGlmIChleHQpIHtcbiAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModGhpcy52YW8pXG4gICAgICB0aGlzLmJpbmRBdHRycygpXG4gICAgICBzdGF0ZS5jdXJyZW50VkFPID0gdGhpc1xuICAgIH1cbiAgfVxuXG4gIFJFR0xWQU8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudmFvKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0VkFPKClcbiAgICAgIGlmICh0aGlzID09PSBzdGF0ZS5jdXJyZW50VkFPKSB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnRWQU8gPSBudWxsXG4gICAgICAgIGV4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVMobnVsbClcbiAgICAgIH1cbiAgICAgIGV4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh0aGlzLnZhbylcbiAgICAgIHRoaXMudmFvID0gbnVsbFxuICAgIH1cbiAgICBpZiAodmFvU2V0W3RoaXMuaWRdKSB7XG4gICAgICBkZWxldGUgdmFvU2V0W3RoaXMuaWRdXG4gICAgICBzdGF0cy52YW9Db3VudCAtPSAxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVZBTyAoKSB7XG4gICAgdmFyIGV4dCA9IGV4dFZBTygpXG4gICAgaWYgKGV4dCkge1xuICAgICAgdmFsdWVzKHZhb1NldCkuZm9yRWFjaChmdW5jdGlvbiAodmFvKSB7XG4gICAgICAgIHZhby5yZWZyZXNoKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVkFPIChfYXR0cikge1xuICAgIHZhciB2YW8gPSBuZXcgUkVHTFZBTygpXG4gICAgc3RhdHMudmFvQ291bnQgKz0gMVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlVkFPIChhdHRyaWJ1dGVzKSB7XG4gICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlcyksICdhcmd1bWVudHMgdG8gdmVydGV4IGFycmF5IGNvbnN0cnVjdG9yIG11c3QgYmUgYW4gYXJyYXknKVxuICAgICAgY2hlY2skMShhdHRyaWJ1dGVzLmxlbmd0aCA8IE5VTV9BVFRSSUJVVEVTLCAndG9vIG1hbnkgYXR0cmlidXRlcycpXG4gICAgICBjaGVjayQxKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCwgJ211c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgYXR0cmlidXRlJylcblxuICAgICAgdmFyIGJ1ZlVwZGF0ZWQgPSB7fVxuICAgICAgdmFyIG5hdHRyaWJ1dGVzID0gdmFvLmF0dHJpYnV0ZXNcbiAgICAgIG5hdHRyaWJ1dGVzLmxlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwZWMgPSBhdHRyaWJ1dGVzW2ldXG4gICAgICAgIHZhciByZWMgPSBuYXR0cmlidXRlc1tpXSA9IG5ldyBBdHRyaWJ1dGVSZWNvcmQoKVxuICAgICAgICB2YXIgZGF0YSA9IHNwZWMuZGF0YSB8fCBzcGVjXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzVHlwZWRBcnJheShkYXRhKSB8fCBpc05EQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgICAgICAgdmFyIGJ1ZlxuICAgICAgICAgIGlmICh2YW8uYnVmZmVyc1tpXSkge1xuICAgICAgICAgICAgYnVmID0gdmFvLmJ1ZmZlcnNbaV1cbiAgICAgICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkgJiYgYnVmLl9idWZmZXIuYnl0ZUxlbmd0aCA+PSBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgYnVmLnN1YmRhdGEoZGF0YSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJ1Zi5kZXN0cm95KClcbiAgICAgICAgICAgICAgdmFvLmJ1ZmZlcnNbaV0gPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFvLmJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgIGJ1ZiA9IHZhby5idWZmZXJzW2ldID0gYnVmZmVyU3RhdGUuY3JlYXRlKHNwZWMsIEdMX0FSUkFZX0JVRkZFUiQxLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihidWYpXG4gICAgICAgICAgcmVjLnNpemUgPSByZWMuYnVmZmVyLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgICByZWMubm9ybWFsaXplZCA9IGZhbHNlXG4gICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgcmVjLm9mZnNldCA9IDBcbiAgICAgICAgICByZWMuc3RyaWRlID0gMFxuICAgICAgICAgIHJlYy5kaXZpc29yID0gMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDFcbiAgICAgICAgICBidWZVcGRhdGVkW2ldID0gMVxuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihzcGVjKSkge1xuICAgICAgICAgIHJlYy5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYylcbiAgICAgICAgICByZWMuc2l6ZSA9IHJlYy5idWZmZXIuZGltZW5zaW9uIHwgMFxuICAgICAgICAgIHJlYy5ub3JtYWxpemVkID0gZmFsc2VcbiAgICAgICAgICByZWMudHlwZSA9IHJlYy5idWZmZXIuZHR5cGVcbiAgICAgICAgICByZWMub2Zmc2V0ID0gMFxuICAgICAgICAgIHJlYy5zdHJpZGUgPSAwXG4gICAgICAgICAgcmVjLmRpdmlzb3IgPSAwXG4gICAgICAgICAgcmVjLnN0YXRlID0gMVxuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihzcGVjLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZWMuYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHNwZWMuYnVmZmVyKVxuICAgICAgICAgIHJlYy5zaXplID0gKCgrc3BlYy5zaXplKSB8fCByZWMuYnVmZmVyLmRpbWVuc2lvbikgfCAwXG4gICAgICAgICAgcmVjLm5vcm1hbGl6ZWQgPSAhIXNwZWMubm9ybWFsaXplZCB8fCBmYWxzZVxuICAgICAgICAgIGlmICgndHlwZScgaW4gc3BlYykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoc3BlYy50eXBlLCBnbFR5cGVzLCAnaW52YWxpZCBidWZmZXIgdHlwZScpXG4gICAgICAgICAgICByZWMudHlwZSA9IGdsVHlwZXNbc3BlYy50eXBlXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWMudHlwZSA9IHJlYy5idWZmZXIuZHR5cGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjLm9mZnNldCA9IChzcGVjLm9mZnNldCB8fCAwKSB8IDBcbiAgICAgICAgICByZWMuc3RyaWRlID0gKHNwZWMuc3RyaWRlIHx8IDApIHwgMFxuICAgICAgICAgIHJlYy5kaXZpc29yID0gKHNwZWMuZGl2aXNvciB8fCAwKSB8IDBcbiAgICAgICAgICByZWMuc3RhdGUgPSAxXG5cbiAgICAgICAgICBjaGVjayQxKHJlYy5zaXplID49IDEgJiYgcmVjLnNpemUgPD0gNCwgJ3NpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDQnKVxuICAgICAgICAgIGNoZWNrJDEocmVjLm9mZnNldCA+PSAwLCAnaW52YWxpZCBvZmZzZXQnKVxuICAgICAgICAgIGNoZWNrJDEocmVjLnN0cmlkZSA+PSAwICYmIHJlYy5zdHJpZGUgPD0gMjU1LCAnc3RyaWRlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUnKVxuICAgICAgICAgIGNoZWNrJDEocmVjLmRpdmlzb3IgPj0gMCwgJ2Rpdmlzb3IgbXVzdCBiZSBwb3NpdGl2ZScpXG4gICAgICAgICAgY2hlY2skMSghcmVjLmRpdmlzb3IgfHwgISFleHRlbnNpb25zLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgZGl2aXNvcicpXG4gICAgICAgIH0gZWxzZSBpZiAoJ3gnIGluIHNwZWMpIHtcbiAgICAgICAgICBjaGVjayQxKGkgPiAwLCAnZmlyc3QgYXR0cmlidXRlIG11c3Qgbm90IGJlIGEgY29uc3RhbnQnKVxuICAgICAgICAgIHJlYy54ID0gK3NwZWMueCB8fCAwXG4gICAgICAgICAgcmVjLnkgPSArc3BlYy55IHx8IDBcbiAgICAgICAgICByZWMueiA9ICtzcGVjLnogfHwgMFxuICAgICAgICAgIHJlYy53ID0gK3NwZWMudyB8fCAwXG4gICAgICAgICAgcmVjLnN0YXRlID0gMlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEoZmFsc2UsICdpbnZhbGlkIGF0dHJpYnV0ZSBzcGVjIGZvciBsb2NhdGlvbiAnICsgaSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZXRpcmUgdW51c2VkIGJ1ZmZlcnNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFvLmJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKCFidWZVcGRhdGVkW2pdICYmIHZhby5idWZmZXJzW2pdKSB7XG4gICAgICAgICAgdmFvLmJ1ZmZlcnNbal0uZGVzdHJveSgpXG4gICAgICAgICAgdmFvLmJ1ZmZlcnNbal0gPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFvLnJlZnJlc2goKVxuICAgICAgcmV0dXJuIHVwZGF0ZVZBT1xuICAgIH1cblxuICAgIHVwZGF0ZVZBTy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YW8uYnVmZmVycy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAodmFvLmJ1ZmZlcnNbal0pIHtcbiAgICAgICAgICB2YW8uYnVmZmVyc1tqXS5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFvLmJ1ZmZlcnMubGVuZ3RoID0gMFxuICAgICAgdmFvLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHVwZGF0ZVZBTy5fdmFvID0gdmFvXG4gICAgdXBkYXRlVkFPLl9yZWdsVHlwZSA9ICd2YW8nXG5cbiAgICByZXR1cm4gdXBkYXRlVkFPKF9hdHRyKVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlXG59XG5cbnZhciBHTF9GUkFHTUVOVF9TSEFERVIgPSAzNTYzMlxudmFyIEdMX1ZFUlRFWF9TSEFERVIgPSAzNTYzM1xuXG52YXIgR0xfQUNUSVZFX1VOSUZPUk1TID0gMHg4Qjg2XG52YXIgR0xfQUNUSVZFX0FUVFJJQlVURVMgPSAweDhCODlcblxuZnVuY3Rpb24gd3JhcFNoYWRlclN0YXRlIChnbCwgc3RyaW5nU3RvcmUsIHN0YXRzLCBjb25maWcpIHtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIGdsc2wgY29tcGlsYXRpb24gYW5kIGxpbmtpbmdcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBmcmFnU2hhZGVycyA9IHt9XG4gIHZhciB2ZXJ0U2hhZGVycyA9IHt9XG5cbiAgZnVuY3Rpb24gQWN0aXZlSW5mbyAobmFtZSwgaWQsIGxvY2F0aW9uLCBpbmZvKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvblxuICAgIHRoaXMuaW5mbyA9IGluZm9cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEFjdGl2ZUluZm8gKGxpc3QsIGluZm8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChsaXN0W2ldLmlkID09PSBpbmZvLmlkKSB7XG4gICAgICAgIGxpc3RbaV0ubG9jYXRpb24gPSBpbmZvLmxvY2F0aW9uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBsaXN0LnB1c2goaW5mbylcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNoYWRlciAodHlwZSwgaWQsIGNvbW1hbmQpIHtcbiAgICB2YXIgY2FjaGUgPSB0eXBlID09PSBHTF9GUkFHTUVOVF9TSEFERVIgPyBmcmFnU2hhZGVycyA6IHZlcnRTaGFkZXJzXG4gICAgdmFyIHNoYWRlciA9IGNhY2hlW2lkXVxuXG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzdHJpbmdTdG9yZS5zdHIoaWQpXG4gICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSlcbiAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSlcbiAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKVxuICAgICAgY2hlY2skMS5zaGFkZXJFcnJvcihnbCwgc2hhZGVyLCBzb3VyY2UsIHR5cGUsIGNvbW1hbmQpXG4gICAgICBjYWNoZVtpZF0gPSBzaGFkZXJcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gcHJvZ3JhbSBsaW5raW5nXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgcHJvZ3JhbUNhY2hlID0ge31cbiAgdmFyIHByb2dyYW1MaXN0ID0gW11cblxuICB2YXIgUFJPR1JBTV9DT1VOVEVSID0gMFxuXG4gIGZ1bmN0aW9uIFJFR0xQcm9ncmFtIChmcmFnSWQsIHZlcnRJZCkge1xuICAgIHRoaXMuaWQgPSBQUk9HUkFNX0NPVU5URVIrK1xuICAgIHRoaXMuZnJhZ0lkID0gZnJhZ0lkXG4gICAgdGhpcy52ZXJ0SWQgPSB2ZXJ0SWRcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsXG4gICAgdGhpcy51bmlmb3JtcyA9IFtdXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW11cbiAgICB0aGlzLnJlZkNvdW50ID0gMVxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICB1bmlmb3Jtc0NvdW50OiAwLFxuICAgICAgICBhdHRyaWJ1dGVzQ291bnQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rUHJvZ3JhbSAoZGVzYywgY29tbWFuZCwgYXR0cmlidXRlTG9jYXRpb25zKSB7XG4gICAgdmFyIGksIGluZm9cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb21waWxlICYgbGlua1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgZnJhZ1NoYWRlciA9IGdldFNoYWRlcihHTF9GUkFHTUVOVF9TSEFERVIsIGRlc2MuZnJhZ0lkKVxuICAgIHZhciB2ZXJ0U2hhZGVyID0gZ2V0U2hhZGVyKEdMX1ZFUlRFWF9TSEFERVIsIGRlc2MudmVydElkKVxuXG4gICAgdmFyIHByb2dyYW0gPSBkZXNjLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKClcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcilcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydFNoYWRlcilcbiAgICBpZiAoYXR0cmlidXRlTG9jYXRpb25zKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlTG9jYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXR0cmlidXRlTG9jYXRpb25zW2ldXG4gICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBiaW5kaW5nWzBdLCBiaW5kaW5nWzFdKVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG4gICAgY2hlY2skMS5saW5rRXJyb3IoXG4gICAgICBnbCxcbiAgICAgIHByb2dyYW0sXG4gICAgICBzdHJpbmdTdG9yZS5zdHIoZGVzYy5mcmFnSWQpLFxuICAgICAgc3RyaW5nU3RvcmUuc3RyKGRlc2MudmVydElkKSxcbiAgICAgIGNvbW1hbmQpXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ3JhYiB1bmlmb3Jtc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgbnVtVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEdMX0FDVElWRV9VTklGT1JNUylcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIGRlc2Muc3RhdHMudW5pZm9ybXNDb3VudCA9IG51bVVuaWZvcm1zXG4gICAgfVxuICAgIHZhciB1bmlmb3JtcyA9IGRlc2MudW5pZm9ybXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVW5pZm9ybXM7ICsraSkge1xuICAgICAgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSlcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGlmIChpbmZvLnNpemUgPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbmZvLnNpemU7ICsraikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWUucmVwbGFjZSgnWzBdJywgJ1snICsgaiArICddJylcbiAgICAgICAgICAgIGluc2VydEFjdGl2ZUluZm8odW5pZm9ybXMsIG5ldyBBY3RpdmVJbmZvKFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBzdHJpbmdTdG9yZS5pZChuYW1lKSxcbiAgICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgICAgICAgICAgICBpbmZvKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QWN0aXZlSW5mbyh1bmlmb3JtcywgbmV3IEFjdGl2ZUluZm8oXG4gICAgICAgICAgICBpbmZvLm5hbWUsXG4gICAgICAgICAgICBzdHJpbmdTdG9yZS5pZChpbmZvLm5hbWUpLFxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSksXG4gICAgICAgICAgICBpbmZvKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBncmFiIGF0dHJpYnV0ZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG51bUF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEdMX0FDVElWRV9BVFRSSUJVVEVTKVxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnQgPSBudW1BdHRyaWJ1dGVzXG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkZXNjLmF0dHJpYnV0ZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQXR0cmlidXRlczsgKytpKSB7XG4gICAgICBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpbnNlcnRBY3RpdmVJbmZvKGF0dHJpYnV0ZXMsIG5ldyBBY3RpdmVJbmZvKFxuICAgICAgICAgIGluZm8ubmFtZSxcbiAgICAgICAgICBzdHJpbmdTdG9yZS5pZChpbmZvLm5hbWUpLFxuICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSksXG4gICAgICAgICAgaW5mbykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0TWF4VW5pZm9ybXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtID0gMFxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50ID4gbSkge1xuICAgICAgICAgIG0gPSBkZXNjLnN0YXRzLnVuaWZvcm1zQ291bnRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBtXG4gICAgfVxuXG4gICAgc3RhdHMuZ2V0TWF4QXR0cmlidXRlc0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG0gPSAwXG4gICAgICBwcm9ncmFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgIGlmIChkZXNjLnN0YXRzLmF0dHJpYnV0ZXNDb3VudCA+IG0pIHtcbiAgICAgICAgICBtID0gZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVNoYWRlcnMgKCkge1xuICAgIGZyYWdTaGFkZXJzID0ge31cbiAgICB2ZXJ0U2hhZGVycyA9IHt9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGlua1Byb2dyYW0ocHJvZ3JhbUxpc3RbaV0sIG51bGwsIHByb2dyYW1MaXN0W2ldLmF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHJldHVybiBbaW5mby5sb2NhdGlvbiwgaW5mby5uYW1lXVxuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlbGV0ZVNoYWRlciA9IGdsLmRlbGV0ZVNoYWRlci5iaW5kKGdsKVxuICAgICAgdmFsdWVzKGZyYWdTaGFkZXJzKS5mb3JFYWNoKGRlbGV0ZVNoYWRlcilcbiAgICAgIGZyYWdTaGFkZXJzID0ge31cbiAgICAgIHZhbHVlcyh2ZXJ0U2hhZGVycykuZm9yRWFjaChkZWxldGVTaGFkZXIpXG4gICAgICB2ZXJ0U2hhZGVycyA9IHt9XG5cbiAgICAgIHByb2dyYW1MaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShkZXNjLnByb2dyYW0pXG4gICAgICB9KVxuICAgICAgcHJvZ3JhbUxpc3QubGVuZ3RoID0gMFxuICAgICAgcHJvZ3JhbUNhY2hlID0ge31cblxuICAgICAgc3RhdHMuc2hhZGVyQ291bnQgPSAwXG4gICAgfSxcblxuICAgIHByb2dyYW06IGZ1bmN0aW9uICh2ZXJ0SWQsIGZyYWdJZCwgY29tbWFuZCwgYXR0cmliTG9jYXRpb25zKSB7XG4gICAgICBjaGVjayQxLmNvbW1hbmQodmVydElkID49IDAsICdtaXNzaW5nIHZlcnRleCBzaGFkZXInLCBjb21tYW5kKVxuICAgICAgY2hlY2skMS5jb21tYW5kKGZyYWdJZCA+PSAwLCAnbWlzc2luZyBmcmFnbWVudCBzaGFkZXInLCBjb21tYW5kKVxuXG4gICAgICB2YXIgY2FjaGUgPSBwcm9ncmFtQ2FjaGVbZnJhZ0lkXVxuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IHByb2dyYW1DYWNoZVtmcmFnSWRdID0ge31cbiAgICAgIH1cbiAgICAgIHZhciBwcmV2UHJvZ3JhbSA9IGNhY2hlW3ZlcnRJZF1cbiAgICAgIGlmIChwcmV2UHJvZ3JhbSkge1xuICAgICAgICBwcmV2UHJvZ3JhbS5yZWZDb3VudCsrXG4gICAgICAgIGlmICghYXR0cmliTG9jYXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZQcm9ncmFtXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwcm9ncmFtID0gbmV3IFJFR0xQcm9ncmFtKGZyYWdJZCwgdmVydElkKVxuICAgICAgc3RhdHMuc2hhZGVyQ291bnQrK1xuICAgICAgbGlua1Byb2dyYW0ocHJvZ3JhbSwgY29tbWFuZCwgYXR0cmliTG9jYXRpb25zKVxuICAgICAgaWYgKCFwcmV2UHJvZ3JhbSkge1xuICAgICAgICBjYWNoZVt2ZXJ0SWRdID0gcHJvZ3JhbVxuICAgICAgfVxuICAgICAgcHJvZ3JhbUxpc3QucHVzaChwcm9ncmFtKVxuICAgICAgcmV0dXJuIGV4dGVuZChwcm9ncmFtLCB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9ncmFtLnJlZkNvdW50LS1cbiAgICAgICAgICBpZiAocHJvZ3JhbS5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0ucHJvZ3JhbSlcbiAgICAgICAgICAgIHZhciBpZHggPSBwcm9ncmFtTGlzdC5pbmRleE9mKHByb2dyYW0pXG4gICAgICAgICAgICBwcm9ncmFtTGlzdC5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgICAgc3RhdHMuc2hhZGVyQ291bnQtLVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBubyBwcm9ncmFtIGlzIGxpbmtlZCB0byB0aGlzIHZlcnQgYW55bW9yZVxuICAgICAgICAgIGlmIChjYWNoZVtwcm9ncmFtLnZlcnRJZF0ucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRTaGFkZXJzW3Byb2dyYW0udmVydElkXSlcbiAgICAgICAgICAgIGRlbGV0ZSB2ZXJ0U2hhZGVyc1twcm9ncmFtLnZlcnRJZF1cbiAgICAgICAgICAgIGRlbGV0ZSBwcm9ncmFtQ2FjaGVbcHJvZ3JhbS5mcmFnSWRdW3Byb2dyYW0udmVydElkXVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBubyBwcm9ncmFtIGlzIGxpbmtlZCB0byB0aGlzIGZyYWcgYW55bW9yZVxuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMocHJvZ3JhbUNhY2hlW3Byb2dyYW0uZnJhZ0lkXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcnNbcHJvZ3JhbS5mcmFnSWRdKVxuICAgICAgICAgICAgZGVsZXRlIGZyYWdTaGFkZXJzW3Byb2dyYW0uZnJhZ0lkXVxuICAgICAgICAgICAgZGVsZXRlIHByb2dyYW1DYWNoZVtwcm9ncmFtLmZyYWdJZF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcblxuICAgIHJlc3RvcmU6IHJlc3RvcmVTaGFkZXJzLFxuXG4gICAgc2hhZGVyOiBnZXRTaGFkZXIsXG5cbiAgICBmcmFnOiAtMSxcbiAgICB2ZXJ0OiAtMVxuICB9XG59XG5cbnZhciBHTF9SR0JBJDMgPSA2NDA4XG52YXIgR0xfVU5TSUdORURfQllURSQ3ID0gNTEyMVxudmFyIEdMX1BBQ0tfQUxJR05NRU5UID0gMHgwRDA1XG52YXIgR0xfRkxPQVQkNyA9IDB4MTQwNiAvLyA1MTI2XG5cbmZ1bmN0aW9uIHdyYXBSZWFkUGl4ZWxzIChcbiAgZ2wsXG4gIGZyYW1lYnVmZmVyU3RhdGUsXG4gIHJlZ2xQb2xsLFxuICBjb250ZXh0LFxuICBnbEF0dHJpYnV0ZXMsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cykge1xuICBmdW5jdGlvbiByZWFkUGl4ZWxzSW1wbCAoaW5wdXQpIHtcbiAgICB2YXIgdHlwZVxuICAgIGlmIChmcmFtZWJ1ZmZlclN0YXRlLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGdsQXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgICd5b3UgbXVzdCBjcmVhdGUgYSB3ZWJnbCBjb250ZXh0IHdpdGggXCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXJcIjp0cnVlIGluIG9yZGVyIHRvIHJlYWQgcGl4ZWxzIGZyb20gdGhlIGRyYXdpbmcgYnVmZmVyJylcbiAgICAgIHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDdcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2skMShcbiAgICAgICAgZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmNvbG9yQXR0YWNobWVudHNbMF0udGV4dHVyZSAhPT0gbnVsbCxcbiAgICAgICAgJ1lvdSBjYW5ub3QgcmVhZCBmcm9tIGEgcmVuZGVyYnVmZmVyJylcbiAgICAgIHR5cGUgPSBmcmFtZWJ1ZmZlclN0YXRlLm5leHQuY29sb3JBdHRhY2htZW50c1swXS50ZXh0dXJlLl90ZXh0dXJlLnR5cGVcblxuICAgICAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICB0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcgfHwgdHlwZSA9PT0gR0xfRkxPQVQkNyxcbiAgICAgICAgICAnUmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgdHlwZXMgXFwndWludDhcXCcgYW5kIFxcJ2Zsb2F0XFwnJylcblxuICAgICAgICBpZiAodHlwZSA9PT0gR0xfRkxPQVQkNykge1xuICAgICAgICAgIGNoZWNrJDEobGltaXRzLnJlYWRGbG9hdCwgJ1JlYWRpbmcgXFwnZmxvYXRcXCcgdmFsdWVzIGlzIG5vdCBwZXJtaXR0ZWQgaW4geW91ciBicm93c2VyLiBGb3IgYSBmYWxsYmFjaywgcGxlYXNlIHNlZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xzbC1yZWFkLWZsb2F0JylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICB0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcsXG4gICAgICAgICAgJ1JlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIHR5cGUgXFwndWludDhcXCcnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB4ID0gMFxuICAgIHZhciB5ID0gMFxuICAgIHZhciB3aWR0aCA9IGNvbnRleHQuZnJhbWVidWZmZXJXaWR0aFxuICAgIHZhciBoZWlnaHQgPSBjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0XG4gICAgdmFyIGRhdGEgPSBudWxsXG5cbiAgICBpZiAoaXNUeXBlZEFycmF5KGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0XG4gICAgfSBlbHNlIGlmIChpbnB1dCkge1xuICAgICAgY2hlY2skMS50eXBlKGlucHV0LCAnb2JqZWN0JywgJ2ludmFsaWQgYXJndW1lbnRzIHRvIHJlZ2wucmVhZCgpJylcbiAgICAgIHggPSBpbnB1dC54IHwgMFxuICAgICAgeSA9IGlucHV0LnkgfCAwXG4gICAgICBjaGVjayQxKFxuICAgICAgICB4ID49IDAgJiYgeCA8IGNvbnRleHQuZnJhbWVidWZmZXJXaWR0aCxcbiAgICAgICAgJ2ludmFsaWQgeCBvZmZzZXQgZm9yIHJlZ2wucmVhZCcpXG4gICAgICBjaGVjayQxKFxuICAgICAgICB5ID49IDAgJiYgeSA8IGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQsXG4gICAgICAgICdpbnZhbGlkIHkgb2Zmc2V0IGZvciByZWdsLnJlYWQnKVxuICAgICAgd2lkdGggPSAoaW5wdXQud2lkdGggfHwgKGNvbnRleHQuZnJhbWVidWZmZXJXaWR0aCAtIHgpKSB8IDBcbiAgICAgIGhlaWdodCA9IChpbnB1dC5oZWlnaHQgfHwgKGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQgLSB5KSkgfCAwXG4gICAgICBkYXRhID0gaW5wdXQuZGF0YSB8fCBudWxsXG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrIGlucHV0LmRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNykge1xuICAgICAgICBjaGVjayQxKFxuICAgICAgICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgICAgICdidWZmZXIgbXVzdCBiZSBcXCdVaW50OEFycmF5XFwnIHdoZW4gcmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgb2YgdHlwZSBcXCd1aW50OFxcJycpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5LFxuICAgICAgICAgICdidWZmZXIgbXVzdCBiZSBcXCdGbG9hdDMyQXJyYXlcXCcgd2hlbiByZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBvZiB0eXBlIFxcJ2Zsb2F0XFwnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayQxKFxuICAgICAgd2lkdGggPiAwICYmIHdpZHRoICsgeCA8PSBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGgsXG4gICAgICAnaW52YWxpZCB3aWR0aCBmb3IgcmVhZCBwaXhlbHMnKVxuICAgIGNoZWNrJDEoXG4gICAgICBoZWlnaHQgPiAwICYmIGhlaWdodCArIHkgPD0gY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodCxcbiAgICAgICdpbnZhbGlkIGhlaWdodCBmb3IgcmVhZCBwaXhlbHMnKVxuXG4gICAgLy8gVXBkYXRlIFdlYkdMIHN0YXRlXG4gICAgcmVnbFBvbGwoKVxuXG4gICAgLy8gQ29tcHV0ZSBzaXplXG4gICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodCAqIDRcblxuICAgIC8vIEFsbG9jYXRlIGRhdGFcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgbmV3IEZsb2F0MzJBcnJheShzaXplKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFR5cGUgY2hlY2tcbiAgICBjaGVjayQxLmlzVHlwZWRBcnJheShkYXRhLCAnZGF0YSBidWZmZXIgZm9yIHJlZ2wucmVhZCgpIG11c3QgYmUgYSB0eXBlZGFycmF5JylcbiAgICBjaGVjayQxKGRhdGEuYnl0ZUxlbmd0aCA+PSBzaXplLCAnZGF0YSBidWZmZXIgZm9yIHJlZ2wucmVhZCgpIHRvbyBzbWFsbCcpXG5cbiAgICAvLyBSdW4gcmVhZCBwaXhlbHNcbiAgICBnbC5waXhlbFN0b3JlaShHTF9QQUNLX0FMSUdOTUVOVCwgNClcbiAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIEdMX1JHQkEkMyxcbiAgICAgIHR5cGUsXG4gICAgICBkYXRhKVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHNGQk8gKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0XG4gICAgZnJhbWVidWZmZXJTdGF0ZS5zZXRGQk8oe1xuICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXJcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXN1bHQgPSByZWFkUGl4ZWxzSW1wbChvcHRpb25zKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFBpeGVscyAob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhKCdmcmFtZWJ1ZmZlcicgaW4gb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiByZWFkUGl4ZWxzSW1wbChvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVhZFBpeGVsc0ZCTyhvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkUGl4ZWxzXG59XG5cbmZ1bmN0aW9uIHNsaWNlICh4KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh4KVxufVxuXG5mdW5jdGlvbiBqb2luICh4KSB7XG4gIHJldHVybiBzbGljZSh4KS5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnZpcm9ubWVudCAoKSB7XG4gIC8vIFVuaXF1ZSB2YXJpYWJsZSBpZCBjb3VudGVyXG4gIHZhciB2YXJDb3VudGVyID0gMFxuXG4gIC8vIExpbmtlZCB2YWx1ZXMgYXJlIHBhc3NlZCBmcm9tIHRoaXMgc2NvcGUgaW50byB0aGUgZ2VuZXJhdGVkIGNvZGUgYmxvY2tcbiAgLy8gQ2FsbGluZyBsaW5rKCkgcGFzc2VzIGEgdmFsdWUgaW50byB0aGUgZ2VuZXJhdGVkIHNjb3BlIGFuZCByZXR1cm5zXG4gIC8vIHRoZSB2YXJpYWJsZSBuYW1lIHdoaWNoIGl0IGlzIGJvdW5kIHRvXG4gIHZhciBsaW5rZWROYW1lcyA9IFtdXG4gIHZhciBsaW5rZWRWYWx1ZXMgPSBbXVxuICBmdW5jdGlvbiBsaW5rICh2YWx1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua2VkVmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobGlua2VkVmFsdWVzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbGlua2VkTmFtZXNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9ICdnJyArICh2YXJDb3VudGVyKyspXG4gICAgbGlua2VkTmFtZXMucHVzaChuYW1lKVxuICAgIGxpbmtlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBjcmVhdGUgYSBjb2RlIGJsb2NrXG4gIGZ1bmN0aW9uIGJsb2NrICgpIHtcbiAgICB2YXIgY29kZSA9IFtdXG4gICAgZnVuY3Rpb24gcHVzaCAoKSB7XG4gICAgICBjb2RlLnB1c2guYXBwbHkoY29kZSwgc2xpY2UoYXJndW1lbnRzKSlcbiAgICB9XG5cbiAgICB2YXIgdmFycyA9IFtdXG4gICAgZnVuY3Rpb24gZGVmICgpIHtcbiAgICAgIHZhciBuYW1lID0gJ3YnICsgKHZhckNvdW50ZXIrKylcbiAgICAgIHZhcnMucHVzaChuYW1lKVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKG5hbWUsICc9JylcbiAgICAgICAgY29kZS5wdXNoLmFwcGx5KGNvZGUsIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIGNvZGUucHVzaCgnOycpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChwdXNoLCB7XG4gICAgICBkZWY6IGRlZixcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAodmFycy5sZW5ndGggPiAwID8gJ3ZhciAnICsgdmFycy5qb2luKCcsJykgKyAnOycgOiAnJyksXG4gICAgICAgICAgam9pbihjb2RlKVxuICAgICAgICBdKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBzY29wZSAoKSB7XG4gICAgdmFyIGVudHJ5ID0gYmxvY2soKVxuICAgIHZhciBleGl0ID0gYmxvY2soKVxuXG4gICAgdmFyIGVudHJ5VG9TdHJpbmcgPSBlbnRyeS50b1N0cmluZ1xuICAgIHZhciBleGl0VG9TdHJpbmcgPSBleGl0LnRvU3RyaW5nXG5cbiAgICBmdW5jdGlvbiBzYXZlIChvYmplY3QsIHByb3ApIHtcbiAgICAgIGV4aXQob2JqZWN0LCBwcm9wLCAnPScsIGVudHJ5LmRlZihvYmplY3QsIHByb3ApLCAnOycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICBlbnRyeS5hcHBseShlbnRyeSwgc2xpY2UoYXJndW1lbnRzKSlcbiAgICB9LCB7XG4gICAgICBkZWY6IGVudHJ5LmRlZixcbiAgICAgIGVudHJ5OiBlbnRyeSxcbiAgICAgIGV4aXQ6IGV4aXQsXG4gICAgICBzYXZlOiBzYXZlLFxuICAgICAgc2V0OiBmdW5jdGlvbiAob2JqZWN0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBzYXZlKG9iamVjdCwgcHJvcClcbiAgICAgICAgZW50cnkob2JqZWN0LCBwcm9wLCAnPScsIHZhbHVlLCAnOycpXG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5VG9TdHJpbmcoKSArIGV4aXRUb1N0cmluZygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbmFsICgpIHtcbiAgICB2YXIgcHJlZCA9IGpvaW4oYXJndW1lbnRzKVxuICAgIHZhciB0aGVuQmxvY2sgPSBzY29wZSgpXG4gICAgdmFyIGVsc2VCbG9jayA9IHNjb3BlKClcblxuICAgIHZhciB0aGVuVG9TdHJpbmcgPSB0aGVuQmxvY2sudG9TdHJpbmdcbiAgICB2YXIgZWxzZVRvU3RyaW5nID0gZWxzZUJsb2NrLnRvU3RyaW5nXG5cbiAgICByZXR1cm4gZXh0ZW5kKHRoZW5CbG9jaywge1xuICAgICAgdGhlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGVuQmxvY2suYXBwbHkodGhlbkJsb2NrLCBzbGljZShhcmd1bWVudHMpKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGVsc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxzZUJsb2NrLmFwcGx5KGVsc2VCbG9jaywgc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxzZUNsYXVzZSA9IGVsc2VUb1N0cmluZygpXG4gICAgICAgIGlmIChlbHNlQ2xhdXNlKSB7XG4gICAgICAgICAgZWxzZUNsYXVzZSA9ICdlbHNleycgKyBlbHNlQ2xhdXNlICsgJ30nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpvaW4oW1xuICAgICAgICAgICdpZignLCBwcmVkLCAnKXsnLFxuICAgICAgICAgIHRoZW5Ub1N0cmluZygpLFxuICAgICAgICAgICd9JywgZWxzZUNsYXVzZVxuICAgICAgICBdKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwcm9jZWR1cmUgbGlzdFxuICB2YXIgZ2xvYmFsQmxvY2sgPSBibG9jaygpXG4gIHZhciBwcm9jZWR1cmVzID0ge31cbiAgZnVuY3Rpb24gcHJvYyAobmFtZSwgY291bnQpIHtcbiAgICB2YXIgYXJncyA9IFtdXG4gICAgZnVuY3Rpb24gYXJnICgpIHtcbiAgICAgIHZhciBuYW1lID0gJ2EnICsgYXJncy5sZW5ndGhcbiAgICAgIGFyZ3MucHVzaChuYW1lKVxuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG5cbiAgICBjb3VudCA9IGNvdW50IHx8IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGFyZygpXG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSBzY29wZSgpXG4gICAgdmFyIGJvZHlUb1N0cmluZyA9IGJvZHkudG9TdHJpbmdcblxuICAgIHZhciByZXN1bHQgPSBwcm9jZWR1cmVzW25hbWVdID0gZXh0ZW5kKGJvZHksIHtcbiAgICAgIGFyZzogYXJnLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpvaW4oW1xuICAgICAgICAgICdmdW5jdGlvbignLCBhcmdzLmpvaW4oKSwgJyl7JyxcbiAgICAgICAgICBib2R5VG9TdHJpbmcoKSxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZSAoKSB7XG4gICAgdmFyIGNvZGUgPSBbJ1widXNlIHN0cmljdFwiOycsXG4gICAgICBnbG9iYWxCbG9jayxcbiAgICAgICdyZXR1cm4geyddXG4gICAgT2JqZWN0LmtleXMocHJvY2VkdXJlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgY29kZS5wdXNoKCdcIicsIG5hbWUsICdcIjonLCBwcm9jZWR1cmVzW25hbWVdLnRvU3RyaW5nKCksICcsJylcbiAgICB9KVxuICAgIGNvZGUucHVzaCgnfScpXG4gICAgdmFyIHNyYyA9IGpvaW4oY29kZSlcbiAgICAgIC5yZXBsYWNlKC87L2csICc7XFxuJylcbiAgICAgIC5yZXBsYWNlKC99L2csICd9XFxuJylcbiAgICAgIC5yZXBsYWNlKC97L2csICd7XFxuJylcbiAgICB2YXIgcHJvYyA9IEZ1bmN0aW9uLmFwcGx5KG51bGwsIGxpbmtlZE5hbWVzLmNvbmNhdChzcmMpKVxuICAgIHJldHVybiBwcm9jLmFwcGx5KG51bGwsIGxpbmtlZFZhbHVlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2xvYmFsOiBnbG9iYWxCbG9jayxcbiAgICBsaW5rOiBsaW5rLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBwcm9jOiBwcm9jLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICBjb25kOiBjb25kaXRpb25hbCxcbiAgICBjb21waWxlOiBjb21waWxlXG4gIH1cbn1cblxuLy8gXCJjdXRlXCIgbmFtZXMgZm9yIHZlY3RvciBjb21wb25lbnRzXG52YXIgQ1VURV9DT01QT05FTlRTID0gJ3h5encnLnNwbGl0KCcnKVxuXG52YXIgR0xfVU5TSUdORURfQllURSQ4ID0gNTEyMVxuXG52YXIgQVRUUklCX1NUQVRFX1BPSU5URVIgPSAxXG52YXIgQVRUUklCX1NUQVRFX0NPTlNUQU5UID0gMlxuXG52YXIgRFlOX0ZVTkMkMSA9IDBcbnZhciBEWU5fUFJPUCQxID0gMVxudmFyIERZTl9DT05URVhUJDEgPSAyXG52YXIgRFlOX1NUQVRFJDEgPSAzXG52YXIgRFlOX1RIVU5LID0gNFxudmFyIERZTl9DT05TVEFOVCQxID0gNVxudmFyIERZTl9BUlJBWSQxID0gNlxuXG52YXIgU19ESVRIRVIgPSAnZGl0aGVyJ1xudmFyIFNfQkxFTkRfRU5BQkxFID0gJ2JsZW5kLmVuYWJsZSdcbnZhciBTX0JMRU5EX0NPTE9SID0gJ2JsZW5kLmNvbG9yJ1xudmFyIFNfQkxFTkRfRVFVQVRJT04gPSAnYmxlbmQuZXF1YXRpb24nXG52YXIgU19CTEVORF9GVU5DID0gJ2JsZW5kLmZ1bmMnXG52YXIgU19ERVBUSF9FTkFCTEUgPSAnZGVwdGguZW5hYmxlJ1xudmFyIFNfREVQVEhfRlVOQyA9ICdkZXB0aC5mdW5jJ1xudmFyIFNfREVQVEhfUkFOR0UgPSAnZGVwdGgucmFuZ2UnXG52YXIgU19ERVBUSF9NQVNLID0gJ2RlcHRoLm1hc2snXG52YXIgU19DT0xPUl9NQVNLID0gJ2NvbG9yTWFzaydcbnZhciBTX0NVTExfRU5BQkxFID0gJ2N1bGwuZW5hYmxlJ1xudmFyIFNfQ1VMTF9GQUNFID0gJ2N1bGwuZmFjZSdcbnZhciBTX0ZST05UX0ZBQ0UgPSAnZnJvbnRGYWNlJ1xudmFyIFNfTElORV9XSURUSCA9ICdsaW5lV2lkdGgnXG52YXIgU19QT0xZR09OX09GRlNFVF9FTkFCTEUgPSAncG9seWdvbk9mZnNldC5lbmFibGUnXG52YXIgU19QT0xZR09OX09GRlNFVF9PRkZTRVQgPSAncG9seWdvbk9mZnNldC5vZmZzZXQnXG52YXIgU19TQU1QTEVfQUxQSEEgPSAnc2FtcGxlLmFscGhhJ1xudmFyIFNfU0FNUExFX0VOQUJMRSA9ICdzYW1wbGUuZW5hYmxlJ1xudmFyIFNfU0FNUExFX0NPVkVSQUdFID0gJ3NhbXBsZS5jb3ZlcmFnZSdcbnZhciBTX1NURU5DSUxfRU5BQkxFID0gJ3N0ZW5jaWwuZW5hYmxlJ1xudmFyIFNfU1RFTkNJTF9NQVNLID0gJ3N0ZW5jaWwubWFzaydcbnZhciBTX1NURU5DSUxfRlVOQyA9ICdzdGVuY2lsLmZ1bmMnXG52YXIgU19TVEVOQ0lMX09QRlJPTlQgPSAnc3RlbmNpbC5vcEZyb250J1xudmFyIFNfU1RFTkNJTF9PUEJBQ0sgPSAnc3RlbmNpbC5vcEJhY2snXG52YXIgU19TQ0lTU09SX0VOQUJMRSA9ICdzY2lzc29yLmVuYWJsZSdcbnZhciBTX1NDSVNTT1JfQk9YID0gJ3NjaXNzb3IuYm94J1xudmFyIFNfVklFV1BPUlQgPSAndmlld3BvcnQnXG5cbnZhciBTX1BST0ZJTEUgPSAncHJvZmlsZSdcblxudmFyIFNfRlJBTUVCVUZGRVIgPSAnZnJhbWVidWZmZXInXG52YXIgU19WRVJUID0gJ3ZlcnQnXG52YXIgU19GUkFHID0gJ2ZyYWcnXG52YXIgU19FTEVNRU5UUyA9ICdlbGVtZW50cydcbnZhciBTX1BSSU1JVElWRSA9ICdwcmltaXRpdmUnXG52YXIgU19DT1VOVCA9ICdjb3VudCdcbnZhciBTX09GRlNFVCA9ICdvZmZzZXQnXG52YXIgU19JTlNUQU5DRVMgPSAnaW5zdGFuY2VzJ1xudmFyIFNfVkFPID0gJ3ZhbydcblxudmFyIFNVRkZJWF9XSURUSCA9ICdXaWR0aCdcbnZhciBTVUZGSVhfSEVJR0hUID0gJ0hlaWdodCdcblxudmFyIFNfRlJBTUVCVUZGRVJfV0lEVEggPSBTX0ZSQU1FQlVGRkVSICsgU1VGRklYX1dJRFRIXG52YXIgU19GUkFNRUJVRkZFUl9IRUlHSFQgPSBTX0ZSQU1FQlVGRkVSICsgU1VGRklYX0hFSUdIVFxudmFyIFNfVklFV1BPUlRfV0lEVEggPSBTX1ZJRVdQT1JUICsgU1VGRklYX1dJRFRIXG52YXIgU19WSUVXUE9SVF9IRUlHSFQgPSBTX1ZJRVdQT1JUICsgU1VGRklYX0hFSUdIVFxudmFyIFNfRFJBV0lOR0JVRkZFUiA9ICdkcmF3aW5nQnVmZmVyJ1xudmFyIFNfRFJBV0lOR0JVRkZFUl9XSURUSCA9IFNfRFJBV0lOR0JVRkZFUiArIFNVRkZJWF9XSURUSFxudmFyIFNfRFJBV0lOR0JVRkZFUl9IRUlHSFQgPSBTX0RSQVdJTkdCVUZGRVIgKyBTVUZGSVhfSEVJR0hUXG5cbnZhciBORVNURURfT1BUSU9OUyA9IFtcbiAgU19CTEVORF9GVU5DLFxuICBTX0JMRU5EX0VRVUFUSU9OLFxuICBTX1NURU5DSUxfRlVOQyxcbiAgU19TVEVOQ0lMX09QRlJPTlQsXG4gIFNfU1RFTkNJTF9PUEJBQ0ssXG4gIFNfU0FNUExFX0NPVkVSQUdFLFxuICBTX1ZJRVdQT1JULFxuICBTX1NDSVNTT1JfQk9YLFxuICBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVFxuXVxuXG52YXIgR0xfQVJSQVlfQlVGRkVSJDIgPSAzNDk2MlxudmFyIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSJDEgPSAzNDk2M1xuXG52YXIgR0xfRlJBR01FTlRfU0hBREVSJDEgPSAzNTYzMlxudmFyIEdMX1ZFUlRFWF9TSEFERVIkMSA9IDM1NjMzXG5cbnZhciBHTF9URVhUVVJFXzJEJDMgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQJDIgPSAweDg1MTNcblxudmFyIEdMX0NVTExfRkFDRSA9IDB4MEI0NFxudmFyIEdMX0JMRU5EID0gMHgwQkUyXG52YXIgR0xfRElUSEVSID0gMHgwQkQwXG52YXIgR0xfU1RFTkNJTF9URVNUID0gMHgwQjkwXG52YXIgR0xfREVQVEhfVEVTVCA9IDB4MEI3MVxudmFyIEdMX1NDSVNTT1JfVEVTVCA9IDB4MEMxMVxudmFyIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwgPSAweDgwMzdcbnZhciBHTF9TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgPSAweDgwOUVcbnZhciBHTF9TQU1QTEVfQ09WRVJBR0UgPSAweDgwQTBcblxudmFyIEdMX0ZMT0FUJDggPSA1MTI2XG52YXIgR0xfRkxPQVRfVkVDMiA9IDM1NjY0XG52YXIgR0xfRkxPQVRfVkVDMyA9IDM1NjY1XG52YXIgR0xfRkxPQVRfVkVDNCA9IDM1NjY2XG52YXIgR0xfSU5UJDMgPSA1MTI0XG52YXIgR0xfSU5UX1ZFQzIgPSAzNTY2N1xudmFyIEdMX0lOVF9WRUMzID0gMzU2NjhcbnZhciBHTF9JTlRfVkVDNCA9IDM1NjY5XG52YXIgR0xfQk9PTCA9IDM1NjcwXG52YXIgR0xfQk9PTF9WRUMyID0gMzU2NzFcbnZhciBHTF9CT09MX1ZFQzMgPSAzNTY3MlxudmFyIEdMX0JPT0xfVkVDNCA9IDM1NjczXG52YXIgR0xfRkxPQVRfTUFUMiA9IDM1Njc0XG52YXIgR0xfRkxPQVRfTUFUMyA9IDM1Njc1XG52YXIgR0xfRkxPQVRfTUFUNCA9IDM1Njc2XG52YXIgR0xfU0FNUExFUl8yRCA9IDM1Njc4XG52YXIgR0xfU0FNUExFUl9DVUJFID0gMzU2ODBcblxudmFyIEdMX1RSSUFOR0xFUyQxID0gNFxuXG52YXIgR0xfRlJPTlQgPSAxMDI4XG52YXIgR0xfQkFDSyA9IDEwMjlcbnZhciBHTF9DVyA9IDB4MDkwMFxudmFyIEdMX0NDVyA9IDB4MDkwMVxudmFyIEdMX01JTl9FWFQgPSAweDgwMDdcbnZhciBHTF9NQVhfRVhUID0gMHg4MDA4XG52YXIgR0xfQUxXQVlTID0gNTE5XG52YXIgR0xfS0VFUCA9IDc2ODBcbnZhciBHTF9aRVJPID0gMFxudmFyIEdMX09ORSA9IDFcbnZhciBHTF9GVU5DX0FERCA9IDB4ODAwNlxudmFyIEdMX0xFU1MgPSA1MTNcblxudmFyIEdMX0ZSQU1FQlVGRkVSJDIgPSAweDhENDBcbnZhciBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQyID0gMHg4Q0UwXG5cbnZhciBibGVuZEZ1bmNzID0ge1xuICAnMCc6IDAsXG4gICcxJzogMSxcbiAgJ3plcm8nOiAwLFxuICAnb25lJzogMSxcbiAgJ3NyYyBjb2xvcic6IDc2OCxcbiAgJ29uZSBtaW51cyBzcmMgY29sb3InOiA3NjksXG4gICdzcmMgYWxwaGEnOiA3NzAsXG4gICdvbmUgbWludXMgc3JjIGFscGhhJzogNzcxLFxuICAnZHN0IGNvbG9yJzogNzc0LFxuICAnb25lIG1pbnVzIGRzdCBjb2xvcic6IDc3NSxcbiAgJ2RzdCBhbHBoYSc6IDc3MixcbiAgJ29uZSBtaW51cyBkc3QgYWxwaGEnOiA3NzMsXG4gICdjb25zdGFudCBjb2xvcic6IDMyNzY5LFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJzogMzI3NzAsXG4gICdjb25zdGFudCBhbHBoYSc6IDMyNzcxLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJzogMzI3NzIsXG4gICdzcmMgYWxwaGEgc2F0dXJhdGUnOiA3NzZcbn1cblxuLy8gVGhlcmUgYXJlIGludmFsaWQgdmFsdWVzIGZvciBzcmNSR0IgYW5kIGRzdFJHQi4gU2VlOlxuLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvMS4wLyM2LjEzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL1dlYkdML2Jsb2IvMGQzMjAxZjVmN2VjM2MwMDYwYmMxZjA0MDc3NDYxNTQxZjE5ODdiOS9jb25mb3JtYW5jZS1zdWl0ZXMvMS4wLjMvY29uZm9ybWFuY2UvbWlzYy93ZWJnbC1zcGVjaWZpYy5odG1sI0w1NlxudmFyIGludmFsaWRCbGVuZENvbWJpbmF0aW9ucyA9IFtcbiAgJ2NvbnN0YW50IGNvbG9yLCBjb25zdGFudCBhbHBoYScsXG4gICdvbmUgbWludXMgY29uc3RhbnQgY29sb3IsIGNvbnN0YW50IGFscGhhJyxcbiAgJ2NvbnN0YW50IGNvbG9yLCBvbmUgbWludXMgY29uc3RhbnQgYWxwaGEnLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yLCBvbmUgbWludXMgY29uc3RhbnQgYWxwaGEnLFxuICAnY29uc3RhbnQgYWxwaGEsIGNvbnN0YW50IGNvbG9yJyxcbiAgJ2NvbnN0YW50IGFscGhhLCBvbmUgbWludXMgY29uc3RhbnQgY29sb3InLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhLCBjb25zdGFudCBjb2xvcicsXG4gICdvbmUgbWludXMgY29uc3RhbnQgYWxwaGEsIG9uZSBtaW51cyBjb25zdGFudCBjb2xvcidcbl1cblxudmFyIGNvbXBhcmVGdW5jcyA9IHtcbiAgJ25ldmVyJzogNTEyLFxuICAnbGVzcyc6IDUxMyxcbiAgJzwnOiA1MTMsXG4gICdlcXVhbCc6IDUxNCxcbiAgJz0nOiA1MTQsXG4gICc9PSc6IDUxNCxcbiAgJz09PSc6IDUxNCxcbiAgJ2xlcXVhbCc6IDUxNSxcbiAgJzw9JzogNTE1LFxuICAnZ3JlYXRlcic6IDUxNixcbiAgJz4nOiA1MTYsXG4gICdub3RlcXVhbCc6IDUxNyxcbiAgJyE9JzogNTE3LFxuICAnIT09JzogNTE3LFxuICAnZ2VxdWFsJzogNTE4LFxuICAnPj0nOiA1MTgsXG4gICdhbHdheXMnOiA1MTlcbn1cblxudmFyIHN0ZW5jaWxPcHMgPSB7XG4gICcwJzogMCxcbiAgJ3plcm8nOiAwLFxuICAna2VlcCc6IDc2ODAsXG4gICdyZXBsYWNlJzogNzY4MSxcbiAgJ2luY3JlbWVudCc6IDc2ODIsXG4gICdkZWNyZW1lbnQnOiA3NjgzLFxuICAnaW5jcmVtZW50IHdyYXAnOiAzNDA1NSxcbiAgJ2RlY3JlbWVudCB3cmFwJzogMzQwNTYsXG4gICdpbnZlcnQnOiA1Mzg2XG59XG5cbnZhciBzaGFkZXJUeXBlID0ge1xuICAnZnJhZyc6IEdMX0ZSQUdNRU5UX1NIQURFUiQxLFxuICAndmVydCc6IEdMX1ZFUlRFWF9TSEFERVIkMVxufVxuXG52YXIgb3JpZW50YXRpb25UeXBlID0ge1xuICAnY3cnOiBHTF9DVyxcbiAgJ2Njdyc6IEdMX0NDV1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlckFyZ3MgKHgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgfHxcbiAgICBpc1R5cGVkQXJyYXkoeCkgfHxcbiAgICBpc05EQXJyYXlMaWtlKHgpXG59XG5cbi8vIE1ha2Ugc3VyZSB2aWV3cG9ydCBpcyBwcm9jZXNzZWQgZmlyc3RcbmZ1bmN0aW9uIHNvcnRTdGF0ZSAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gU19WSUVXUE9SVCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChiID09PSBTX1ZJRVdQT1JUKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gKGEgPCBiKSA/IC0xIDogMVxuICB9KVxufVxuXG5mdW5jdGlvbiBEZWNsYXJhdGlvbiAodGhpc0RlcCwgY29udGV4dERlcCwgcHJvcERlcCwgYXBwZW5kKSB7XG4gIHRoaXMudGhpc0RlcCA9IHRoaXNEZXBcbiAgdGhpcy5jb250ZXh0RGVwID0gY29udGV4dERlcFxuICB0aGlzLnByb3BEZXAgPSBwcm9wRGVwXG4gIHRoaXMuYXBwZW5kID0gYXBwZW5kXG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChkZWNsKSB7XG4gIHJldHVybiBkZWNsICYmICEoZGVjbC50aGlzRGVwIHx8IGRlY2wuY29udGV4dERlcCB8fCBkZWNsLnByb3BEZXApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0RlY2wgKGFwcGVuZCkge1xuICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGFwcGVuZClcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHluYW1pY0RlY2wgKGR5biwgYXBwZW5kKSB7XG4gIHZhciB0eXBlID0gZHluLnR5cGVcbiAgaWYgKHR5cGUgPT09IERZTl9GVU5DJDEpIHtcbiAgICB2YXIgbnVtQXJncyA9IGR5bi5kYXRhLmxlbmd0aFxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICB0cnVlLFxuICAgICAgbnVtQXJncyA+PSAxLFxuICAgICAgbnVtQXJncyA+PSAyLFxuICAgICAgYXBwZW5kKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IERZTl9USFVOSykge1xuICAgIHZhciBkYXRhID0gZHluLmRhdGFcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgZGF0YS50aGlzRGVwLFxuICAgICAgZGF0YS5jb250ZXh0RGVwLFxuICAgICAgZGF0YS5wcm9wRGVwLFxuICAgICAgYXBwZW5kKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IERZTl9DT05TVEFOVCQxKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZSxcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fQVJSQVkkMSkge1xuICAgIHZhciB0aGlzRGVwID0gZmFsc2VcbiAgICB2YXIgY29udGV4dERlcCA9IGZhbHNlXG4gICAgdmFyIHByb3BEZXAgPSBmYWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHluLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWJEeW4gPSBkeW4uZGF0YVtpXVxuICAgICAgaWYgKHN1YkR5bi50eXBlID09PSBEWU5fUFJPUCQxKSB7XG4gICAgICAgIHByb3BEZXAgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHN1YkR5bi50eXBlID09PSBEWU5fQ09OVEVYVCQxKSB7XG4gICAgICAgIGNvbnRleHREZXAgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHN1YkR5bi50eXBlID09PSBEWU5fU1RBVEUkMSkge1xuICAgICAgICB0aGlzRGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX0ZVTkMkMSkge1xuICAgICAgICB0aGlzRGVwID0gdHJ1ZVxuICAgICAgICB2YXIgc3ViQXJncyA9IHN1YkR5bi5kYXRhXG4gICAgICAgIGlmIChzdWJBcmdzID49IDEpIHtcbiAgICAgICAgICBjb250ZXh0RGVwID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJBcmdzID49IDIpIHtcbiAgICAgICAgICBwcm9wRGVwID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN1YkR5bi50eXBlID09PSBEWU5fVEhVTkspIHtcbiAgICAgICAgdGhpc0RlcCA9IHRoaXNEZXAgfHwgc3ViRHluLmRhdGEudGhpc0RlcFxuICAgICAgICBjb250ZXh0RGVwID0gY29udGV4dERlcCB8fCBzdWJEeW4uZGF0YS5jb250ZXh0RGVwXG4gICAgICAgIHByb3BEZXAgPSBwcm9wRGVwIHx8IHN1YkR5bi5kYXRhLnByb3BEZXBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIHRoaXNEZXAsXG4gICAgICBjb250ZXh0RGVwLFxuICAgICAgcHJvcERlcCxcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgdHlwZSA9PT0gRFlOX1NUQVRFJDEsXG4gICAgICB0eXBlID09PSBEWU5fQ09OVEVYVCQxLFxuICAgICAgdHlwZSA9PT0gRFlOX1BST1AkMSxcbiAgICAgIGFwcGVuZClcbiAgfVxufVxuXG52YXIgU0NPUEVfREVDTCA9IG5ldyBEZWNsYXJhdGlvbihmYWxzZSwgZmFsc2UsIGZhbHNlLCBmdW5jdGlvbiAoKSB7fSlcblxuZnVuY3Rpb24gcmVnbENvcmUgKFxuICBnbCxcbiAgc3RyaW5nU3RvcmUsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgYnVmZmVyU3RhdGUsXG4gIGVsZW1lbnRTdGF0ZSxcbiAgdGV4dHVyZVN0YXRlLFxuICBmcmFtZWJ1ZmZlclN0YXRlLFxuICB1bmlmb3JtU3RhdGUsXG4gIGF0dHJpYnV0ZVN0YXRlLFxuICBzaGFkZXJTdGF0ZSxcbiAgZHJhd1N0YXRlLFxuICBjb250ZXh0U3RhdGUsXG4gIHRpbWVyLFxuICBjb25maWcpIHtcbiAgdmFyIEF0dHJpYnV0ZVJlY29yZCA9IGF0dHJpYnV0ZVN0YXRlLlJlY29yZFxuXG4gIHZhciBibGVuZEVxdWF0aW9ucyA9IHtcbiAgICAnYWRkJzogMzI3NzQsXG4gICAgJ3N1YnRyYWN0JzogMzI3NzgsXG4gICAgJ3JldmVyc2Ugc3VidHJhY3QnOiAzMjc3OVxuICB9XG4gIGlmIChleHRlbnNpb25zLmV4dF9ibGVuZF9taW5tYXgpIHtcbiAgICBibGVuZEVxdWF0aW9ucy5taW4gPSBHTF9NSU5fRVhUXG4gICAgYmxlbmRFcXVhdGlvbnMubWF4ID0gR0xfTUFYX0VYVFxuICB9XG5cbiAgdmFyIGV4dEluc3RhbmNpbmcgPSBleHRlbnNpb25zLmFuZ2xlX2luc3RhbmNlZF9hcnJheXNcbiAgdmFyIGV4dERyYXdCdWZmZXJzID0gZXh0ZW5zaW9ucy53ZWJnbF9kcmF3X2J1ZmZlcnNcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFdFQkdMIFNUQVRFXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHtcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBwcm9maWxlOiBjb25maWcucHJvZmlsZVxuICB9XG4gIHZhciBuZXh0U3RhdGUgPSB7fVxuICB2YXIgR0xfU1RBVEVfTkFNRVMgPSBbXVxuICB2YXIgR0xfRkxBR1MgPSB7fVxuICB2YXIgR0xfVkFSSUFCTEVTID0ge31cblxuICBmdW5jdGlvbiBwcm9wTmFtZSAobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoJy4nLCAnXycpXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZUZsYWcgKHNuYW1lLCBjYXAsIGluaXQpIHtcbiAgICB2YXIgbmFtZSA9IHByb3BOYW1lKHNuYW1lKVxuICAgIEdMX1NUQVRFX05BTUVTLnB1c2goc25hbWUpXG4gICAgbmV4dFN0YXRlW25hbWVdID0gY3VycmVudFN0YXRlW25hbWVdID0gISFpbml0XG4gICAgR0xfRkxBR1NbbmFtZV0gPSBjYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRlVmFyaWFibGUgKHNuYW1lLCBmdW5jLCBpbml0KSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZShzbmFtZSlcbiAgICBHTF9TVEFURV9OQU1FUy5wdXNoKHNuYW1lKVxuICAgIGlmIChBcnJheS5pc0FycmF5KGluaXQpKSB7XG4gICAgICBjdXJyZW50U3RhdGVbbmFtZV0gPSBpbml0LnNsaWNlKClcbiAgICAgIG5leHRTdGF0ZVtuYW1lXSA9IGluaXQuc2xpY2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50U3RhdGVbbmFtZV0gPSBuZXh0U3RhdGVbbmFtZV0gPSBpbml0XG4gICAgfVxuICAgIEdMX1ZBUklBQkxFU1tuYW1lXSA9IGZ1bmNcbiAgfVxuXG4gIC8vIERpdGhlcmluZ1xuICBzdGF0ZUZsYWcoU19ESVRIRVIsIEdMX0RJVEhFUilcblxuICAvLyBCbGVuZGluZ1xuICBzdGF0ZUZsYWcoU19CTEVORF9FTkFCTEUsIEdMX0JMRU5EKVxuICBzdGF0ZVZhcmlhYmxlKFNfQkxFTkRfQ09MT1IsICdibGVuZENvbG9yJywgWzAsIDAsIDAsIDBdKVxuICBzdGF0ZVZhcmlhYmxlKFNfQkxFTkRfRVFVQVRJT04sICdibGVuZEVxdWF0aW9uU2VwYXJhdGUnLFxuICAgIFtHTF9GVU5DX0FERCwgR0xfRlVOQ19BRERdKVxuICBzdGF0ZVZhcmlhYmxlKFNfQkxFTkRfRlVOQywgJ2JsZW5kRnVuY1NlcGFyYXRlJyxcbiAgICBbR0xfT05FLCBHTF9aRVJPLCBHTF9PTkUsIEdMX1pFUk9dKVxuXG4gIC8vIERlcHRoXG4gIHN0YXRlRmxhZyhTX0RFUFRIX0VOQUJMRSwgR0xfREVQVEhfVEVTVCwgdHJ1ZSlcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX0ZVTkMsICdkZXB0aEZ1bmMnLCBHTF9MRVNTKVxuICBzdGF0ZVZhcmlhYmxlKFNfREVQVEhfUkFOR0UsICdkZXB0aFJhbmdlJywgWzAsIDFdKVxuICBzdGF0ZVZhcmlhYmxlKFNfREVQVEhfTUFTSywgJ2RlcHRoTWFzaycsIHRydWUpXG5cbiAgLy8gQ29sb3IgbWFza1xuICBzdGF0ZVZhcmlhYmxlKFNfQ09MT1JfTUFTSywgU19DT0xPUl9NQVNLLCBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0pXG5cbiAgLy8gRmFjZSBjdWxsaW5nXG4gIHN0YXRlRmxhZyhTX0NVTExfRU5BQkxFLCBHTF9DVUxMX0ZBQ0UpXG4gIHN0YXRlVmFyaWFibGUoU19DVUxMX0ZBQ0UsICdjdWxsRmFjZScsIEdMX0JBQ0spXG5cbiAgLy8gRnJvbnQgZmFjZSBvcmllbnRhdGlvblxuICBzdGF0ZVZhcmlhYmxlKFNfRlJPTlRfRkFDRSwgU19GUk9OVF9GQUNFLCBHTF9DQ1cpXG5cbiAgLy8gTGluZSB3aWR0aFxuICBzdGF0ZVZhcmlhYmxlKFNfTElORV9XSURUSCwgU19MSU5FX1dJRFRILCAxKVxuXG4gIC8vIFBvbHlnb24gb2Zmc2V0XG4gIHN0YXRlRmxhZyhTX1BPTFlHT05fT0ZGU0VUX0VOQUJMRSwgR0xfUE9MWUdPTl9PRkZTRVRfRklMTClcbiAgc3RhdGVWYXJpYWJsZShTX1BPTFlHT05fT0ZGU0VUX09GRlNFVCwgJ3BvbHlnb25PZmZzZXQnLCBbMCwgMF0pXG5cbiAgLy8gU2FtcGxlIGNvdmVyYWdlXG4gIHN0YXRlRmxhZyhTX1NBTVBMRV9BTFBIQSwgR0xfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKVxuICBzdGF0ZUZsYWcoU19TQU1QTEVfRU5BQkxFLCBHTF9TQU1QTEVfQ09WRVJBR0UpXG4gIHN0YXRlVmFyaWFibGUoU19TQU1QTEVfQ09WRVJBR0UsICdzYW1wbGVDb3ZlcmFnZScsIFsxLCBmYWxzZV0pXG5cbiAgLy8gU3RlbmNpbFxuICBzdGF0ZUZsYWcoU19TVEVOQ0lMX0VOQUJMRSwgR0xfU1RFTkNJTF9URVNUKVxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9NQVNLLCAnc3RlbmNpbE1hc2snLCAtMSlcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfRlVOQywgJ3N0ZW5jaWxGdW5jJywgW0dMX0FMV0FZUywgMCwgLTFdKVxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9PUEZST05ULCAnc3RlbmNpbE9wU2VwYXJhdGUnLFxuICAgIFtHTF9GUk9OVCwgR0xfS0VFUCwgR0xfS0VFUCwgR0xfS0VFUF0pXG4gIHN0YXRlVmFyaWFibGUoU19TVEVOQ0lMX09QQkFDSywgJ3N0ZW5jaWxPcFNlcGFyYXRlJyxcbiAgICBbR0xfQkFDSywgR0xfS0VFUCwgR0xfS0VFUCwgR0xfS0VFUF0pXG5cbiAgLy8gU2Npc3NvclxuICBzdGF0ZUZsYWcoU19TQ0lTU09SX0VOQUJMRSwgR0xfU0NJU1NPUl9URVNUKVxuICBzdGF0ZVZhcmlhYmxlKFNfU0NJU1NPUl9CT1gsICdzY2lzc29yJyxcbiAgICBbMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0XSlcblxuICAvLyBWaWV3cG9ydFxuICBzdGF0ZVZhcmlhYmxlKFNfVklFV1BPUlQsIFNfVklFV1BPUlQsXG4gICAgWzAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodF0pXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFTlZJUk9OTUVOVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBzaGFyZWRTdGF0ZSA9IHtcbiAgICBnbDogZ2wsXG4gICAgY29udGV4dDogY29udGV4dFN0YXRlLFxuICAgIHN0cmluZ3M6IHN0cmluZ1N0b3JlLFxuICAgIG5leHQ6IG5leHRTdGF0ZSxcbiAgICBjdXJyZW50OiBjdXJyZW50U3RhdGUsXG4gICAgZHJhdzogZHJhd1N0YXRlLFxuICAgIGVsZW1lbnRzOiBlbGVtZW50U3RhdGUsXG4gICAgYnVmZmVyOiBidWZmZXJTdGF0ZSxcbiAgICBzaGFkZXI6IHNoYWRlclN0YXRlLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZVN0YXRlLnN0YXRlLFxuICAgIHZhbzogYXR0cmlidXRlU3RhdGUsXG4gICAgdW5pZm9ybXM6IHVuaWZvcm1TdGF0ZSxcbiAgICBmcmFtZWJ1ZmZlcjogZnJhbWVidWZmZXJTdGF0ZSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuXG4gICAgdGltZXI6IHRpbWVyLFxuICAgIGlzQnVmZmVyQXJnczogaXNCdWZmZXJBcmdzXG4gIH1cblxuICB2YXIgc2hhcmVkQ29uc3RhbnRzID0ge1xuICAgIHByaW1UeXBlczogcHJpbVR5cGVzLFxuICAgIGNvbXBhcmVGdW5jczogY29tcGFyZUZ1bmNzLFxuICAgIGJsZW5kRnVuY3M6IGJsZW5kRnVuY3MsXG4gICAgYmxlbmRFcXVhdGlvbnM6IGJsZW5kRXF1YXRpb25zLFxuICAgIHN0ZW5jaWxPcHM6IHN0ZW5jaWxPcHMsXG4gICAgZ2xUeXBlczogZ2xUeXBlcyxcbiAgICBvcmllbnRhdGlvblR5cGU6IG9yaWVudGF0aW9uVHlwZVxuICB9XG5cbiAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgc2hhcmVkU3RhdGUuaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZVxuICB9KVxuXG4gIGlmIChleHREcmF3QnVmZmVycykge1xuICAgIHNoYXJlZENvbnN0YW50cy5iYWNrQnVmZmVyID0gW0dMX0JBQ0tdXG4gICAgc2hhcmVkQ29uc3RhbnRzLmRyYXdCdWZmZXIgPSBsb29wKGxpbWl0cy5tYXhEcmF3YnVmZmVycywgZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMF1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsb29wKGksIGZ1bmN0aW9uIChqKSB7XG4gICAgICAgIHJldHVybiBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQyICsgalxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdmFyIGRyYXdDYWxsQ291bnRlciA9IDBcbiAgZnVuY3Rpb24gY3JlYXRlUkVHTEVudmlyb25tZW50ICgpIHtcbiAgICB2YXIgZW52ID0gY3JlYXRlRW52aXJvbm1lbnQoKVxuICAgIHZhciBsaW5rID0gZW52LmxpbmtcbiAgICB2YXIgZ2xvYmFsID0gZW52Lmdsb2JhbFxuICAgIGVudi5pZCA9IGRyYXdDYWxsQ291bnRlcisrXG5cbiAgICBlbnYuYmF0Y2hJZCA9ICcwJ1xuXG4gICAgLy8gbGluayBzaGFyZWQgc3RhdGVcbiAgICB2YXIgU0hBUkVEID0gbGluayhzaGFyZWRTdGF0ZSlcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZCA9IHtcbiAgICAgIHByb3BzOiAnYTAnXG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHNoYXJlZFN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBzaGFyZWRbcHJvcF0gPSBnbG9iYWwuZGVmKFNIQVJFRCwgJy4nLCBwcm9wKVxuICAgIH0pXG5cbiAgICAvLyBJbmplY3QgcnVudGltZSBhc3NlcnRpb24gc3R1ZmYgZm9yIGRlYnVnIGJ1aWxkc1xuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgZW52LkNIRUNLID0gbGluayhjaGVjayQxKVxuICAgICAgZW52LmNvbW1hbmRTdHIgPSBjaGVjayQxLmd1ZXNzQ29tbWFuZCgpXG4gICAgICBlbnYuY29tbWFuZCA9IGxpbmsoZW52LmNvbW1hbmRTdHIpXG4gICAgICBlbnYuYXNzZXJ0ID0gZnVuY3Rpb24gKGJsb2NrLCBwcmVkLCBtZXNzYWdlKSB7XG4gICAgICAgIGJsb2NrKFxuICAgICAgICAgICdpZighKCcsIHByZWQsICcpKScsXG4gICAgICAgICAgdGhpcy5DSEVDSywgJy5jb21tYW5kUmFpc2UoJywgbGluayhtZXNzYWdlKSwgJywnLCB0aGlzLmNvbW1hbmQsICcpOycpXG4gICAgICB9XG5cbiAgICAgIHNoYXJlZENvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnNcbiAgICB9KVxuXG4gICAgLy8gQ29weSBHTCBzdGF0ZSB2YXJpYWJsZXMgb3ZlclxuICAgIHZhciBuZXh0VmFycyA9IGVudi5uZXh0ID0ge31cbiAgICB2YXIgY3VycmVudFZhcnMgPSBlbnYuY3VycmVudCA9IHt9XG4gICAgT2JqZWN0LmtleXMoR0xfVkFSSUFCTEVTKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFN0YXRlW3ZhcmlhYmxlXSkpIHtcbiAgICAgICAgbmV4dFZhcnNbdmFyaWFibGVdID0gZ2xvYmFsLmRlZihzaGFyZWQubmV4dCwgJy4nLCB2YXJpYWJsZSlcbiAgICAgICAgY3VycmVudFZhcnNbdmFyaWFibGVdID0gZ2xvYmFsLmRlZihzaGFyZWQuY3VycmVudCwgJy4nLCB2YXJpYWJsZSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBzaGFyZWQgY29uc3RhbnRzXG4gICAgdmFyIGNvbnN0YW50cyA9IGVudi5jb25zdGFudHMgPSB7fVxuICAgIE9iamVjdC5rZXlzKHNoYXJlZENvbnN0YW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgY29uc3RhbnRzW25hbWVdID0gZ2xvYmFsLmRlZihKU09OLnN0cmluZ2lmeShzaGFyZWRDb25zdGFudHNbbmFtZV0pKVxuICAgIH0pXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGNhbGxpbmcgYSBibG9ja1xuICAgIGVudi5pbnZva2UgPSBmdW5jdGlvbiAoYmxvY2ssIHgpIHtcbiAgICAgIHN3aXRjaCAoeC50eXBlKSB7XG4gICAgICAgIGNhc2UgRFlOX0ZVTkMkMTpcbiAgICAgICAgICB2YXIgYXJnTGlzdCA9IFtcbiAgICAgICAgICAgICd0aGlzJyxcbiAgICAgICAgICAgIHNoYXJlZC5jb250ZXh0LFxuICAgICAgICAgICAgc2hhcmVkLnByb3BzLFxuICAgICAgICAgICAgZW52LmJhdGNoSWRcbiAgICAgICAgICBdXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihcbiAgICAgICAgICAgIGxpbmsoeC5kYXRhKSwgJy5jYWxsKCcsXG4gICAgICAgICAgICBhcmdMaXN0LnNsaWNlKDAsIE1hdGgubWF4KHguZGF0YS5sZW5ndGggKyAxLCA0KSksXG4gICAgICAgICAgICAnKScpXG4gICAgICAgIGNhc2UgRFlOX1BST1AkMTpcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKHNoYXJlZC5wcm9wcywgeC5kYXRhKVxuICAgICAgICBjYXNlIERZTl9DT05URVhUJDE6XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihzaGFyZWQuY29udGV4dCwgeC5kYXRhKVxuICAgICAgICBjYXNlIERZTl9TVEFURSQxOlxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoJ3RoaXMnLCB4LmRhdGEpXG4gICAgICAgIGNhc2UgRFlOX1RIVU5LOlxuICAgICAgICAgIHguZGF0YS5hcHBlbmQoZW52LCBibG9jaylcbiAgICAgICAgICByZXR1cm4geC5kYXRhLnJlZlxuICAgICAgICBjYXNlIERZTl9DT05TVEFOVCQxOlxuICAgICAgICAgIHJldHVybiB4LmRhdGEudG9TdHJpbmcoKVxuICAgICAgICBjYXNlIERZTl9BUlJBWSQxOlxuICAgICAgICAgIHJldHVybiB4LmRhdGEubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW52Lmludm9rZShibG9jaywgeSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGVudi5hdHRyaWJDYWNoZSA9IHt9XG5cbiAgICB2YXIgc2NvcGVBdHRyaWJzID0ge31cbiAgICBlbnYuc2NvcGVBdHRyaWIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGlkID0gc3RyaW5nU3RvcmUuaWQobmFtZSlcbiAgICAgIGlmIChpZCBpbiBzY29wZUF0dHJpYnMpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlQXR0cmlic1tpZF1cbiAgICAgIH1cbiAgICAgIHZhciBiaW5kaW5nID0gYXR0cmlidXRlU3RhdGUuc2NvcGVbaWRdXG4gICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgYmluZGluZyA9IGF0dHJpYnV0ZVN0YXRlLnNjb3BlW2lkXSA9IG5ldyBBdHRyaWJ1dGVSZWNvcmQoKVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNjb3BlQXR0cmlic1tpZF0gPSBsaW5rKGJpbmRpbmcpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudlxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQQVJTSU5HXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gcGFyc2VQcm9maWxlIChvcHRpb25zKSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgdmFyIHByb2ZpbGVFbmFibGVcbiAgICBpZiAoU19QUk9GSUxFIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZSA9ICEhc3RhdGljT3B0aW9uc1tTX1BST0ZJTEVdXG4gICAgICBwcm9maWxlRW5hYmxlID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH0pXG4gICAgICBwcm9maWxlRW5hYmxlLmVuYWJsZSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChTX1BST0ZJTEUgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tTX1BST0ZJTEVdXG4gICAgICBwcm9maWxlRW5hYmxlID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZmlsZUVuYWJsZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGcmFtZWJ1ZmZlciAob3B0aW9ucywgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgaWYgKFNfRlJBTUVCVUZGRVIgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgdmFyIGZyYW1lYnVmZmVyID0gc3RhdGljT3B0aW9uc1tTX0ZSQU1FQlVGRkVSXVxuICAgICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXJTdGF0ZS5nZXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcbiAgICAgICAgY2hlY2skMS5jb21tYW5kKGZyYW1lYnVmZmVyLCAnaW52YWxpZCBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBibG9jaykge1xuICAgICAgICAgIHZhciBGUkFNRUJVRkZFUiA9IGVudi5saW5rKGZyYW1lYnVmZmVyKVxuICAgICAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICAgICAgYmxvY2suc2V0KFxuICAgICAgICAgICAgc2hhcmVkLmZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgJy5uZXh0JyxcbiAgICAgICAgICAgIEZSQU1FQlVGRkVSKVxuICAgICAgICAgIHZhciBDT05URVhUID0gc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICBibG9jay5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcbiAgICAgICAgICAgIEZSQU1FQlVGRkVSICsgJy53aWR0aCcpXG4gICAgICAgICAgYmxvY2suc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfSEVJR0hULFxuICAgICAgICAgICAgRlJBTUVCVUZGRVIgKyAnLmhlaWdodCcpXG4gICAgICAgICAgcmV0dXJuIEZSQU1FQlVGRkVSXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgICAgc2hhcmVkLmZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgJy5uZXh0JyxcbiAgICAgICAgICAgICdudWxsJylcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0XG4gICAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfV0lEVEgsXG4gICAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX1dJRFRIKVxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICAgIENPTlRFWFQgKyAnLicgKyBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUKVxuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFNfRlJBTUVCVUZGRVIgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tTX0ZSQU1FQlVGRkVSXVxuICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIEZSQU1FQlVGRkVSX0ZVTkMgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICAgIHZhciBGUkFNRUJVRkZFUl9TVEFURSA9IHNoYXJlZC5mcmFtZWJ1ZmZlclxuICAgICAgICB2YXIgRlJBTUVCVUZGRVIgPSBzY29wZS5kZWYoXG4gICAgICAgICAgRlJBTUVCVUZGRVJfU1RBVEUsICcuZ2V0RnJhbWVidWZmZXIoJywgRlJBTUVCVUZGRVJfRlVOQywgJyknKVxuXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAnIScgKyBGUkFNRUJVRkZFUl9GVU5DICsgJ3x8JyArIEZSQU1FQlVGRkVSLFxuICAgICAgICAgICAgJ2ludmFsaWQgZnJhbWVidWZmZXIgb2JqZWN0JylcbiAgICAgICAgfSlcblxuICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgRlJBTUVCVUZGRVJfU1RBVEUsXG4gICAgICAgICAgJy5uZXh0JyxcbiAgICAgICAgICBGUkFNRUJVRkZFUilcbiAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX1dJRFRILFxuICAgICAgICAgIEZSQU1FQlVGRkVSICsgJz8nICsgRlJBTUVCVUZGRVIgKyAnLndpZHRoOicgK1xuICAgICAgICAgIENPTlRFWFQgKyAnLicgKyBTX0RSQVdJTkdCVUZGRVJfV0lEVEgpXG4gICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfSEVJR0hULFxuICAgICAgICAgIEZSQU1FQlVGRkVSICtcbiAgICAgICAgICAnPycgKyBGUkFNRUJVRkZFUiArICcuaGVpZ2h0OicgK1xuICAgICAgICAgIENPTlRFWFQgKyAnLicgKyBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUKVxuICAgICAgICByZXR1cm4gRlJBTUVCVUZGRVJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWaWV3cG9ydFNjaXNzb3IgKG9wdGlvbnMsIGZyYW1lYnVmZmVyLCBlbnYpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZUJveCAocGFyYW0pIHtcbiAgICAgIGlmIChwYXJhbSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBib3ggPSBzdGF0aWNPcHRpb25zW3BhcmFtXVxuICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKGJveCwgJ29iamVjdCcsICdpbnZhbGlkICcgKyBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgdmFyIGlzU3RhdGljID0gdHJ1ZVxuICAgICAgICB2YXIgeCA9IGJveC54IHwgMFxuICAgICAgICB2YXIgeSA9IGJveC55IHwgMFxuICAgICAgICB2YXIgdywgaFxuICAgICAgICBpZiAoJ3dpZHRoJyBpbiBib3gpIHtcbiAgICAgICAgICB3ID0gYm94LndpZHRoIHwgMFxuICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCh3ID49IDAsICdpbnZhbGlkICcgKyBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGlmICgnaGVpZ2h0JyBpbiBib3gpIHtcbiAgICAgICAgICBoID0gYm94LmhlaWdodCB8IDBcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoaCA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzU3RhdGljID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgICAgIWlzU3RhdGljICYmIGZyYW1lYnVmZmVyICYmIGZyYW1lYnVmZmVyLnRoaXNEZXAsXG4gICAgICAgICAgIWlzU3RhdGljICYmIGZyYW1lYnVmZmVyICYmIGZyYW1lYnVmZmVyLmNvbnRleHREZXAsXG4gICAgICAgICAgIWlzU3RhdGljICYmIGZyYW1lYnVmZmVyICYmIGZyYW1lYnVmZmVyLnByb3BEZXAsXG4gICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBDT05URVhUID0gZW52LnNoYXJlZC5jb250ZXh0XG4gICAgICAgICAgICB2YXIgQk9YX1cgPSB3XG4gICAgICAgICAgICBpZiAoISgnd2lkdGgnIGluIGJveCkpIHtcbiAgICAgICAgICAgICAgQk9YX1cgPSBzY29wZS5kZWYoQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX1dJRFRILCAnLScsIHgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQk9YX0ggPSBoXG4gICAgICAgICAgICBpZiAoISgnaGVpZ2h0JyBpbiBib3gpKSB7XG4gICAgICAgICAgICAgIEJPWF9IID0gc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9IRUlHSFQsICctJywgeSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeCwgeSwgQk9YX1csIEJPWF9IXVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5Cb3ggPSBkeW5hbWljT3B0aW9uc1twYXJhbV1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5bkJveCwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgQk9YID0gZW52Lmludm9rZShzY29wZSwgZHluQm94KVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBCT1ggKyAnJiZ0eXBlb2YgJyArIEJPWCArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHBhcmFtKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgIHZhciBCT1hfWCA9IHNjb3BlLmRlZihCT1gsICcueHwwJylcbiAgICAgICAgICB2YXIgQk9YX1kgPSBzY29wZS5kZWYoQk9YLCAnLnl8MCcpXG4gICAgICAgICAgdmFyIEJPWF9XID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgJ1wid2lkdGhcIiBpbiAnLCBCT1gsICc/JywgQk9YLCAnLndpZHRofDA6JyxcbiAgICAgICAgICAgICcoJywgQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX1dJRFRILCAnLScsIEJPWF9YLCAnKScpXG4gICAgICAgICAgdmFyIEJPWF9IID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgJ1wiaGVpZ2h0XCIgaW4gJywgQk9YLCAnPycsIEJPWCwgJy5oZWlnaHR8MDonLFxuICAgICAgICAgICAgJygnLCBDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hULCAnLScsIEJPWF9ZLCAnKScpXG5cbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgIEJPWF9XICsgJz49MCYmJyArXG4gICAgICAgICAgICAgIEJPWF9IICsgJz49MCcsXG4gICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwYXJhbSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIFtCT1hfWCwgQk9YX1ksIEJPWF9XLCBCT1hfSF1cbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgcmVzdWx0LnRoaXNEZXAgPSByZXN1bHQudGhpc0RlcCB8fCBmcmFtZWJ1ZmZlci50aGlzRGVwXG4gICAgICAgICAgcmVzdWx0LmNvbnRleHREZXAgPSByZXN1bHQuY29udGV4dERlcCB8fCBmcmFtZWJ1ZmZlci5jb250ZXh0RGVwXG4gICAgICAgICAgcmVzdWx0LnByb3BEZXAgPSByZXN1bHQucHJvcERlcCB8fCBmcmFtZWJ1ZmZlci5wcm9wRGVwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgIGZyYW1lYnVmZmVyLnRoaXNEZXAsXG4gICAgICAgICAgZnJhbWVidWZmZXIuY29udGV4dERlcCxcbiAgICAgICAgICBmcmFtZWJ1ZmZlci5wcm9wRGVwLFxuICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCksXG4gICAgICAgICAgICAgIHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hUKV1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlld3BvcnQgPSBwYXJzZUJveChTX1ZJRVdQT1JUKVxuXG4gICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICB2YXIgcHJldlZpZXdwb3J0ID0gdmlld3BvcnRcbiAgICAgIHZpZXdwb3J0ID0gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICB2aWV3cG9ydC50aGlzRGVwLFxuICAgICAgICB2aWV3cG9ydC5jb250ZXh0RGVwLFxuICAgICAgICB2aWV3cG9ydC5wcm9wRGVwLFxuICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBWSUVXUE9SVCA9IHByZXZWaWV3cG9ydC5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX1ZJRVdQT1JUX1dJRFRILFxuICAgICAgICAgICAgVklFV1BPUlRbMl0pXG4gICAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfVklFV1BPUlRfSEVJR0hULFxuICAgICAgICAgICAgVklFV1BPUlRbM10pXG4gICAgICAgICAgcmV0dXJuIFZJRVdQT1JUXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHNjaXNzb3JfYm94OiBwYXJzZUJveChTX1NDSVNTT1JfQk9YKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmliTG9jYXRpb25zIChvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBzdGF0aWNQcm9ncmFtID1cbiAgICAgIHR5cGVvZiBzdGF0aWNPcHRpb25zW1NfRlJBR10gPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2Ygc3RhdGljT3B0aW9uc1tTX1ZFUlRdID09PSAnc3RyaW5nJ1xuICAgIGlmIChzdGF0aWNQcm9ncmFtKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcy5keW5hbWljKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB2YXIgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuc3RhdGljXG4gICAgICB2YXIgc0F0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhzdGF0aWNBdHRyaWJ1dGVzKVxuICAgICAgaWYgKHNBdHRyaWJ1dGVzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHN0YXRpY0F0dHJpYnV0ZXNbc0F0dHJpYnV0ZXNbMF1dID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2hlY2skMSh0eXBlb2Ygc3RhdGljQXR0cmlidXRlc1tzQXR0cmlidXRlc1tpXV0gPT09ICdudW1iZXInLCAnbXVzdCBzcGVjaWZ5IGFsbCB2ZXJ0ZXggYXR0cmlidXRlIGxvY2F0aW9ucyB3aGVuIHVzaW5nIHZhb3MnKVxuICAgICAgICAgIGJpbmRpbmdzLnB1c2goW3N0YXRpY0F0dHJpYnV0ZXNbc0F0dHJpYnV0ZXNbaV1dIHwgMCwgc0F0dHJpYnV0ZXNbaV1dKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtIChvcHRpb25zLCBlbnYsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hhZGVyIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBpZCA9IHN0cmluZ1N0b3JlLmlkKHN0YXRpY09wdGlvbnNbbmFtZV0pXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNoYWRlclN0YXRlLnNoYWRlcihzaGFkZXJUeXBlW25hbWVdLCBpZCwgY2hlY2skMS5ndWVzc0NvbW1hbmQoKSlcbiAgICAgICAgfSlcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICB9KVxuICAgICAgICByZXN1bHQuaWQgPSBpZFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW25hbWVdXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIHN0ciA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgICAgICB2YXIgaWQgPSBzY29wZS5kZWYoZW52LnNoYXJlZC5zdHJpbmdzLCAnLmlkKCcsIHN0ciwgJyknKVxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAgIGVudi5zaGFyZWQuc2hhZGVyLCAnLnNoYWRlcignLFxuICAgICAgICAgICAgICBzaGFkZXJUeXBlW25hbWVdLCAnLCcsXG4gICAgICAgICAgICAgIGlkLCAnLCcsXG4gICAgICAgICAgICAgIGVudi5jb21tYW5kLCAnKTsnKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIGlkXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBmcmFnID0gcGFyc2VTaGFkZXIoU19GUkFHKVxuICAgIHZhciB2ZXJ0ID0gcGFyc2VTaGFkZXIoU19WRVJUKVxuXG4gICAgdmFyIHByb2dyYW0gPSBudWxsXG4gICAgdmFyIHByb2dWYXJcbiAgICBpZiAoaXNTdGF0aWMoZnJhZykgJiYgaXNTdGF0aWModmVydCkpIHtcbiAgICAgIHByb2dyYW0gPSBzaGFkZXJTdGF0ZS5wcm9ncmFtKHZlcnQuaWQsIGZyYWcuaWQsIG51bGwsIGF0dHJpYkxvY2F0aW9ucylcbiAgICAgIHByb2dWYXIgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBlbnYubGluayhwcm9ncmFtKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ1ZhciA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgKGZyYWcgJiYgZnJhZy50aGlzRGVwKSB8fCAodmVydCAmJiB2ZXJ0LnRoaXNEZXApLFxuICAgICAgICAoZnJhZyAmJiBmcmFnLmNvbnRleHREZXApIHx8ICh2ZXJ0ICYmIHZlcnQuY29udGV4dERlcCksXG4gICAgICAgIChmcmFnICYmIGZyYWcucHJvcERlcCkgfHwgKHZlcnQgJiYgdmVydC5wcm9wRGVwKSxcbiAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgU0hBREVSX1NUQVRFID0gZW52LnNoYXJlZC5zaGFkZXJcbiAgICAgICAgICB2YXIgZnJhZ0lkXG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIGZyYWdJZCA9IGZyYWcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdJZCA9IHNjb3BlLmRlZihTSEFERVJfU1RBVEUsICcuJywgU19GUkFHKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmVydElkXG4gICAgICAgICAgaWYgKHZlcnQpIHtcbiAgICAgICAgICAgIHZlcnRJZCA9IHZlcnQuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRJZCA9IHNjb3BlLmRlZihTSEFERVJfU1RBVEUsICcuJywgU19WRVJUKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJvZ0RlZiA9IFNIQURFUl9TVEFURSArICcucHJvZ3JhbSgnICsgdmVydElkICsgJywnICsgZnJhZ0lkXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9nRGVmICs9ICcsJyArIGVudi5jb21tYW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHByb2dEZWYgKyAnKScpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICB2ZXJ0OiB2ZXJ0LFxuICAgICAgcHJvZ1ZhcjogcHJvZ1ZhcixcbiAgICAgIHByb2dyYW06IHByb2dyYW1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURyYXcgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRWxlbWVudHMgKCkge1xuICAgICAgaWYgKFNfRUxFTUVOVFMgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBzdGF0aWNPcHRpb25zW1NfRUxFTUVOVFNdXG4gICAgICAgIGlmIChpc0J1ZmZlckFyZ3MoZWxlbWVudHMpKSB7XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50U3RhdGUuZ2V0RWxlbWVudHMoZWxlbWVudFN0YXRlLmNyZWF0ZShlbGVtZW50cywgdHJ1ZSkpXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRTdGF0ZS5nZXRFbGVtZW50cyhlbGVtZW50cylcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoZWxlbWVudHMsICdpbnZhbGlkIGVsZW1lbnRzJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbnYubGluayhlbGVtZW50cylcbiAgICAgICAgICAgIGVudi5FTEVNRU5UUyA9IHJlc3VsdFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbnYuRUxFTUVOVFMgPSBudWxsXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gZWxlbWVudHNcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChTX0VMRU1FTlRTIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tTX0VMRU1FTlRTXVxuICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG5cbiAgICAgICAgICB2YXIgSVNfQlVGRkVSX0FSR1MgPSBzaGFyZWQuaXNCdWZmZXJBcmdzXG4gICAgICAgICAgdmFyIEVMRU1FTlRfU1RBVEUgPSBzaGFyZWQuZWxlbWVudHNcblxuICAgICAgICAgIHZhciBlbGVtZW50RGVmbiA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSBzY29wZS5kZWYoJ251bGwnKVxuICAgICAgICAgIHZhciBlbGVtZW50U3RyZWFtID0gc2NvcGUuZGVmKElTX0JVRkZFUl9BUkdTLCAnKCcsIGVsZW1lbnREZWZuLCAnKScpXG5cbiAgICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKGVsZW1lbnRTdHJlYW0pXG4gICAgICAgICAgICAudGhlbihlbGVtZW50cywgJz0nLCBFTEVNRU5UX1NUQVRFLCAnLmNyZWF0ZVN0cmVhbSgnLCBlbGVtZW50RGVmbiwgJyk7JylcbiAgICAgICAgICAgIC5lbHNlKGVsZW1lbnRzLCAnPScsIEVMRU1FTlRfU1RBVEUsICcuZ2V0RWxlbWVudHMoJywgZWxlbWVudERlZm4sICcpOycpXG5cbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQoaWZ0ZS5lbHNlLFxuICAgICAgICAgICAgICAnIScgKyBlbGVtZW50RGVmbiArICd8fCcgKyBlbGVtZW50cyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgZWxlbWVudHMnKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBzY29wZS5lbnRyeShpZnRlKVxuICAgICAgICAgIHNjb3BlLmV4aXQoXG4gICAgICAgICAgICBlbnYuY29uZChlbGVtZW50U3RyZWFtKVxuICAgICAgICAgICAgICAudGhlbihFTEVNRU5UX1NUQVRFLCAnLmRlc3Ryb3lTdHJlYW0oJywgZWxlbWVudHMsICcpOycpKVxuXG4gICAgICAgICAgZW52LkVMRU1FTlRTID0gZWxlbWVudHNcblxuICAgICAgICAgIHJldHVybiBlbGVtZW50c1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IHBhcnNlRWxlbWVudHMoKVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltaXRpdmUgKCkge1xuICAgICAgaWYgKFNfUFJJTUlUSVZFIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByaW1pdGl2ZSA9IHN0YXRpY09wdGlvbnNbU19QUklNSVRJVkVdXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihwcmltaXRpdmUsIHByaW1UeXBlcywgJ2ludmFsaWQgcHJpbWl0dmUnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICByZXR1cm4gcHJpbVR5cGVzW3ByaW1pdGl2ZV1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoU19QUklNSVRJVkUgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5blByaW1pdGl2ZSA9IGR5bmFtaWNPcHRpb25zW1NfUFJJTUlUSVZFXVxuICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluUHJpbWl0aXZlLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBQUklNX1RZUEVTID0gZW52LmNvbnN0YW50cy5wcmltVHlwZXNcbiAgICAgICAgICB2YXIgcHJpbSA9IGVudi5pbnZva2Uoc2NvcGUsIGR5blByaW1pdGl2ZSlcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgIHByaW0gKyAnIGluICcgKyBQUklNX1RZUEVTLFxuICAgICAgICAgICAgICAnaW52YWxpZCBwcmltaXRpdmUsIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhwcmltVHlwZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihQUklNX1RZUEVTLCAnWycsIHByaW0sICddJylcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGlmIChlbGVtZW50cy52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbnYuRUxFTUVOVFMsICcucHJpbVR5cGUnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gR0xfVFJJQU5HTEVTJDFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgICAgICBlbGVtZW50cy50aGlzRGVwLFxuICAgICAgICAgICAgZWxlbWVudHMuY29udGV4dERlcCxcbiAgICAgICAgICAgIGVsZW1lbnRzLnByb3BEZXAsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBlbnYuRUxFTUVOVFNcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbGVtZW50cywgJz8nLCBlbGVtZW50cywgJy5wcmltVHlwZTonLCBHTF9UUklBTkdMRVMkMSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbSAocGFyYW0sIGlzT2Zmc2V0KSB7XG4gICAgICBpZiAocGFyYW0gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdGF0aWNPcHRpb25zW3BhcmFtXSB8IDBcbiAgICAgICAgY2hlY2skMS5jb21tYW5kKCFpc09mZnNldCB8fCB2YWx1ZSA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgZW52Lk9GRlNFVCA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluVmFsdWUgPSBkeW5hbWljT3B0aW9uc1twYXJhbV1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5blZhbHVlLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5WYWx1ZSlcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGVudi5PRkZTRVQgPSByZXN1bHRcbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgIHJlc3VsdCArICc+PTAnLFxuICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwYXJhbSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNPZmZzZXQgJiYgZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICBlbnYuT0ZGU0VUID0gJzAnXG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIE9GRlNFVCA9IHBhcnNlUGFyYW0oU19PRkZTRVQsIHRydWUpXG5cbiAgICBmdW5jdGlvbiBwYXJzZVZlcnRDb3VudCAoKSB7XG4gICAgICBpZiAoU19DT1VOVCBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHN0YXRpY09wdGlvbnNbU19DT1VOVF0gfCAwXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICB0eXBlb2YgY291bnQgPT09ICdudW1iZXInICYmIGNvdW50ID49IDAsICdpbnZhbGlkIHZlcnRleCBjb3VudCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvdW50XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKFNfQ09VTlQgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5bkNvdW50ID0gZHluYW1pY09wdGlvbnNbU19DT1VOVF1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5bkNvdW50LCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5Db3VudClcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICd0eXBlb2YgJyArIHJlc3VsdCArICc9PT1cIm51bWJlclwiJiYnICtcbiAgICAgICAgICAgICAgcmVzdWx0ICsgJz49MCYmJyArXG4gICAgICAgICAgICAgIHJlc3VsdCArICc9PT0oJyArIHJlc3VsdCArICd8MCknLFxuICAgICAgICAgICAgICAnaW52YWxpZCB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50cykge1xuICAgICAgICBpZiAoaXNTdGF0aWMoZWxlbWVudHMpKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoT0ZGU0VUKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgICAgT0ZGU0VULnRoaXNEZXAsXG4gICAgICAgICAgICAgICAgT0ZGU0VULmNvbnRleHREZXAsXG4gICAgICAgICAgICAgICAgT0ZGU0VULnByb3BEZXAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgICAgIGVudi5FTEVNRU5UUywgJy52ZXJ0Q291bnQtJywgZW52Lk9GRlNFVClcblxuICAgICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICsgJz49MCcsXG4gICAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IG9mZnNldC9lbGVtZW50IGJ1ZmZlciB0b28gc21hbGwnKVxuICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnZlcnRDb3VudCcpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5NSVNTSU5HID0gdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhcmlhYmxlID0gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgZWxlbWVudHMudGhpc0RlcCB8fCBPRkZTRVQudGhpc0RlcCxcbiAgICAgICAgICAgIGVsZW1lbnRzLmNvbnRleHREZXAgfHwgT0ZGU0VULmNvbnRleHREZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5wcm9wRGVwIHx8IE9GRlNFVC5wcm9wRGVwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZW52LkVMRU1FTlRTXG4gICAgICAgICAgICAgIGlmIChlbnYuT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbGVtZW50cywgJz8nLCBlbGVtZW50cywgJy52ZXJ0Q291bnQtJyxcbiAgICAgICAgICAgICAgICAgIGVudi5PRkZTRVQsICc6LTEnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcudmVydENvdW50Oi0xJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5EWU5BTUlDID0gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHZhcmlhYmxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgIHByaW1pdGl2ZTogcGFyc2VQcmltaXRpdmUoKSxcbiAgICAgIGNvdW50OiBwYXJzZVZlcnRDb3VudCgpLFxuICAgICAgaW5zdGFuY2VzOiBwYXJzZVBhcmFtKFNfSU5TVEFOQ0VTLCBmYWxzZSksXG4gICAgICBvZmZzZXQ6IE9GRlNFVFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlR0xTdGF0ZSAob3B0aW9ucywgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgdmFyIFNUQVRFID0ge31cblxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbSA9IHByb3BOYW1lKHByb3ApXG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW0gKHBhcnNlU3RhdGljLCBwYXJzZUR5bmFtaWMpIHtcbiAgICAgICAgaWYgKHByb3AgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlU3RhdGljKHN0YXRpY09wdGlvbnNbcHJvcF0pXG4gICAgICAgICAgU1RBVEVbcGFyYW1dID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbcHJvcF1cbiAgICAgICAgICBTVEFURVtwYXJhbV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEeW5hbWljKGVudiwgc2NvcGUsIGVudi5pbnZva2Uoc2NvcGUsIGR5bikpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBTX0NVTExfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfQkxFTkRfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfRElUSEVSOlxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19ERVBUSF9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19TQ0lTU09SX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX1BPTFlHT05fT0ZGU0VUX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX1NBTVBMRV9BTFBIQTpcbiAgICAgICAgY2FzZSBTX1NBTVBMRV9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19ERVBUSF9NQVNLOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdib29sZWFuJywgcHJvcCwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJib29sZWFuXCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgZmxhZyAnICsgcHJvcCwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfREVQVEhfRlVOQzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIodmFsdWUsIGNvbXBhcmVGdW5jcywgJ2ludmFsaWQgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUZ1bmNzW3ZhbHVlXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgQ09NUEFSRV9GVU5DUyA9IGVudi5jb25zdGFudHMuY29tcGFyZUZ1bmNzXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcgaW4gJyArIENPTVBBUkVfRlVOQ1MsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcCArICcsIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhjb21wYXJlRnVuY3MpKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKENPTVBBUkVfRlVOQ1MsICdbJywgdmFsdWUsICddJylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0RFUFRIX1JBTkdFOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlWzFdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlWzBdIDw9IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICdkZXB0aCByYW5nZSBpcyAyZCBhcnJheScsXG4gICAgICAgICAgICAgICAgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgZW52LnNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIHZhbHVlICsgJykmJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnLmxlbmd0aD09PTImJicgK1xuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnWzBdPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgICAgICAndHlwZW9mICcgKyB2YWx1ZSArICdbMV09PT1cIm51bWJlclwiJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJ1swXTw9JyArIHZhbHVlICsgJ1sxXScsXG4gICAgICAgICAgICAgICAgICAnZGVwdGggcmFuZ2UgbXVzdCBiZSBhIDJkIGFycmF5JylcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICB2YXIgWl9ORUFSID0gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbMF0nKVxuICAgICAgICAgICAgICB2YXIgWl9GQVIgPSBzY29wZS5kZWYoJysnLCB2YWx1ZSwgJ1sxXScpXG4gICAgICAgICAgICAgIHJldHVybiBbWl9ORUFSLCBaX0ZBUl1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0JMRU5EX0ZVTkM6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ29iamVjdCcsICdibGVuZC5mdW5jJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHZhciBzcmNSR0IgPSAoJ3NyY1JHQicgaW4gdmFsdWUgPyB2YWx1ZS5zcmNSR0IgOiB2YWx1ZS5zcmMpXG4gICAgICAgICAgICAgIHZhciBzcmNBbHBoYSA9ICgnc3JjQWxwaGEnIGluIHZhbHVlID8gdmFsdWUuc3JjQWxwaGEgOiB2YWx1ZS5zcmMpXG4gICAgICAgICAgICAgIHZhciBkc3RSR0IgPSAoJ2RzdFJHQicgaW4gdmFsdWUgPyB2YWx1ZS5kc3RSR0IgOiB2YWx1ZS5kc3QpXG4gICAgICAgICAgICAgIHZhciBkc3RBbHBoYSA9ICgnZHN0QWxwaGEnIGluIHZhbHVlID8gdmFsdWUuZHN0QWxwaGEgOiB2YWx1ZS5kc3QpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihzcmNSR0IsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5zcmNSR0InLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHNyY0FscGhhLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuc3JjQWxwaGEnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGRzdFJHQiwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLmRzdFJHQicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoZHN0QWxwaGEsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5kc3RBbHBoYScsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAoaW52YWxpZEJsZW5kQ29tYmluYXRpb25zLmluZGV4T2Yoc3JjUkdCICsgJywgJyArIGRzdFJHQikgPT09IC0xKSxcbiAgICAgICAgICAgICAgICAndW5hbGxvd2VkIGJsZW5kaW5nIGNvbWJpbmF0aW9uIChzcmNSR0IsIGRzdFJHQikgPSAoJyArIHNyY1JHQiArICcsICcgKyBkc3RSR0IgKyAnKScsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNSR0JdLFxuICAgICAgICAgICAgICAgIGJsZW5kRnVuY3NbZHN0UkdCXSxcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW3NyY0FscGhhXSxcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW2RzdEFscGhhXVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBCTEVORF9GVU5DUyA9IGVudi5jb25zdGFudHMuYmxlbmRGdW5jc1xuXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBibGVuZCBmdW5jLCBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVhZCAocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICAgICAgICdcIicsIHByZWZpeCwgc3VmZml4LCAnXCIgaW4gJywgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAnPycsIHZhbHVlLCAnLicsIHByZWZpeCwgc3VmZml4LFxuICAgICAgICAgICAgICAgICAgJzonLCB2YWx1ZSwgJy4nLCBwcmVmaXgpXG5cbiAgICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKyAnIGluICcgKyBCTEVORF9GVU5DUyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLicgKyBwcmVmaXggKyBzdWZmaXggKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoYmxlbmRGdW5jcykpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc3JjUkdCID0gcmVhZCgnc3JjJywgJ1JHQicpXG4gICAgICAgICAgICAgIHZhciBkc3RSR0IgPSByZWFkKCdkc3QnLCAnUkdCJylcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgSU5WQUxJRF9CTEVORF9DT01CSU5BVElPTlMgPSBlbnYuY29uc3RhbnRzLmludmFsaWRCbGVuZENvbWJpbmF0aW9uc1xuXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfQkxFTkRfQ09NQklOQVRJT05TICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICcuaW5kZXhPZignICsgc3JjUkdCICsgJytcIiwgXCIrJyArIGRzdFJHQiArICcpID09PSAtMSAnLFxuICAgICAgICAgICAgICAgICAgJ3VuYWxsb3dlZCBibGVuZGluZyBjb21iaW5hdGlvbiBmb3IgKHNyY1JHQiwgZHN0UkdCKSdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIFNSQ19SR0IgPSBzY29wZS5kZWYoQkxFTkRfRlVOQ1MsICdbJywgc3JjUkdCLCAnXScpXG4gICAgICAgICAgICAgIHZhciBTUkNfQUxQSEEgPSBzY29wZS5kZWYoQkxFTkRfRlVOQ1MsICdbJywgcmVhZCgnc3JjJywgJ0FscGhhJyksICddJylcbiAgICAgICAgICAgICAgdmFyIERTVF9SR0IgPSBzY29wZS5kZWYoQkxFTkRfRlVOQ1MsICdbJywgZHN0UkdCLCAnXScpXG4gICAgICAgICAgICAgIHZhciBEU1RfQUxQSEEgPSBzY29wZS5kZWYoQkxFTkRfRlVOQ1MsICdbJywgcmVhZCgnZHN0JywgJ0FscGhhJyksICddJylcblxuICAgICAgICAgICAgICByZXR1cm4gW1NSQ19SR0IsIERTVF9SR0IsIFNSQ19BTFBIQSwgRFNUX0FMUEhBXVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfQkxFTkRfRVFVQVRJT046XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIodmFsdWUsIGJsZW5kRXF1YXRpb25zLCAnaW52YWxpZCAnICsgcHJvcCwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKFxuICAgICAgICAgICAgICAgICAgdmFsdWUucmdiLCBibGVuZEVxdWF0aW9ucywgcHJvcCArICcucmdiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKFxuICAgICAgICAgICAgICAgICAgdmFsdWUuYWxwaGEsIGJsZW5kRXF1YXRpb25zLCBwcm9wICsgJy5hbHBoYScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZS5yZ2JdLFxuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUuYWxwaGFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFJhaXNlKCdpbnZhbGlkIGJsZW5kLmVxdWF0aW9uJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIEJMRU5EX0VRVUFUSU9OUyA9IGVudi5jb25zdGFudHMuYmxlbmRFcXVhdGlvbnNcblxuICAgICAgICAgICAgICB2YXIgUkdCID0gc2NvcGUuZGVmKClcbiAgICAgICAgICAgICAgdmFyIEFMUEhBID0gc2NvcGUuZGVmKClcblxuICAgICAgICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKCd0eXBlb2YgJywgdmFsdWUsICc9PT1cInN0cmluZ1wiJylcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja1Byb3AgKGJsb2NrLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgZW52LmFzc2VydChibG9jayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnIGluICcgKyBCTEVORF9FUVVBVElPTlMsXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBuYW1lICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGJsZW5kRXF1YXRpb25zKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tQcm9wKGlmdGUudGhlbiwgcHJvcCwgdmFsdWUpXG5cbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KGlmdGUuZWxzZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wKVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLmVsc2UsIHByb3AgKyAnLnJnYicsIHZhbHVlICsgJy5yZ2InKVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLmVsc2UsIHByb3AgKyAnLmFscGhhJywgdmFsdWUgKyAnLmFscGhhJylcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBpZnRlLnRoZW4oXG4gICAgICAgICAgICAgICAgUkdCLCAnPScsIEFMUEhBLCAnPScsIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YWx1ZSwgJ107JylcbiAgICAgICAgICAgICAgaWZ0ZS5lbHNlKFxuICAgICAgICAgICAgICAgIFJHQiwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICcucmdiXTsnLFxuICAgICAgICAgICAgICAgIEFMUEhBLCAnPScsIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YWx1ZSwgJy5hbHBoYV07JylcblxuICAgICAgICAgICAgICBzY29wZShpZnRlKVxuXG4gICAgICAgICAgICAgIHJldHVybiBbUkdCLCBBTFBIQV1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0JMRU5EX0NPTE9SOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgJ2JsZW5kLmNvbG9yIG11c3QgYmUgYSA0ZCBhcnJheScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiArdmFsdWVbaV1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT00JyxcbiAgICAgICAgICAgICAgICAgICdibGVuZC5jb2xvciBtdXN0IGJlIGEgNGQgYXJyYXknKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoJysnLCB2YWx1ZSwgJ1snLCBpLCAnXScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX01BU0s6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ251bWJlcicsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHwgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJudW1iZXJcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBzdGVuY2lsLm1hc2snKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHZhbHVlLCAnfDAnKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9GVU5DOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHZhciBjbXAgPSB2YWx1ZS5jbXAgfHwgJ2tlZXAnXG4gICAgICAgICAgICAgIHZhciByZWYgPSB2YWx1ZS5yZWYgfHwgMFxuICAgICAgICAgICAgICB2YXIgbWFzayA9ICdtYXNrJyBpbiB2YWx1ZSA/IHZhbHVlLm1hc2sgOiAtMVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoY21wLCBjb21wYXJlRnVuY3MsIHByb3AgKyAnLmNtcCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHJlZiwgJ251bWJlcicsIHByb3AgKyAnLnJlZicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKG1hc2ssICdudW1iZXInLCBwcm9wICsgJy5tYXNrJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgY29tcGFyZUZ1bmNzW2NtcF0sXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIG1hc2tcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgQ09NUEFSRV9GVU5DUyA9IGVudi5jb25zdGFudHMuY29tcGFyZUZ1bmNzXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFzc2VydCAoKSB7XG4gICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJycpLFxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCBzdGVuY2lsLmZ1bmMnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnQodmFsdWUgKyAnJiZ0eXBlb2YgJywgdmFsdWUsICc9PT1cIm9iamVjdFwiJylcbiAgICAgICAgICAgICAgICBhc3NlcnQoJyEoXCJjbXBcIiBpbiAnLCB2YWx1ZSwgJyl8fCgnLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsICcuY21wIGluICcsIENPTVBBUkVfRlVOQ1MsICcpJylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgdmFyIGNtcCA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICAgICAnXCJjbXBcIiBpbiAnLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAnPycsIENPTVBBUkVfRlVOQ1MsICdbJywgdmFsdWUsICcuY21wXScsXG4gICAgICAgICAgICAgICAgJzonLCBHTF9LRUVQKVxuICAgICAgICAgICAgICB2YXIgcmVmID0gc2NvcGUuZGVmKHZhbHVlLCAnLnJlZnwwJylcbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1wibWFza1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICc/JywgdmFsdWUsICcubWFza3wwOi0xJylcbiAgICAgICAgICAgICAgcmV0dXJuIFtjbXAsIHJlZiwgbWFza11cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1NURU5DSUxfT1BGUk9OVDpcbiAgICAgICAgY2FzZSBTX1NURU5DSUxfT1BCQUNLOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHZhciBmYWlsID0gdmFsdWUuZmFpbCB8fCAna2VlcCdcbiAgICAgICAgICAgICAgdmFyIHpmYWlsID0gdmFsdWUuemZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgICAgIHZhciB6cGFzcyA9IHZhbHVlLnpwYXNzIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoZmFpbCwgc3RlbmNpbE9wcywgcHJvcCArICcuZmFpbCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoemZhaWwsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLnpmYWlsJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcih6cGFzcywgc3RlbmNpbE9wcywgcHJvcCArICcuenBhc3MnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwcm9wID09PSBTX1NURU5DSUxfT1BCQUNLID8gR0xfQkFDSyA6IEdMX0ZST05ULFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbZmFpbF0sXG4gICAgICAgICAgICAgICAgc3RlbmNpbE9wc1t6ZmFpbF0sXG4gICAgICAgICAgICAgICAgc3RlbmNpbE9wc1t6cGFzc11cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgU1RFTkNJTF9PUFMgPSBlbnYuY29uc3RhbnRzLnN0ZW5jaWxPcHNcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3ApXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVhZCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgJyEoXCInICsgbmFtZSArICdcIiBpbiAnICsgdmFsdWUgKyAnKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICcoJyArIHZhbHVlICsgJy4nICsgbmFtZSArICcgaW4gJyArIFNURU5DSUxfT1BTICsgJyknLFxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcCArICcuJyArIG5hbWUgKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoc3RlbmNpbE9wcykpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgICAnXCInLCBuYW1lLCAnXCIgaW4gJywgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAnPycsIFNURU5DSUxfT1BTLCAnWycsIHZhbHVlLCAnLicsIG5hbWUsICddOicsXG4gICAgICAgICAgICAgICAgICBHTF9LRUVQKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwcm9wID09PSBTX1NURU5DSUxfT1BCQUNLID8gR0xfQkFDSyA6IEdMX0ZST05ULFxuICAgICAgICAgICAgICAgIHJlYWQoJ2ZhaWwnKSxcbiAgICAgICAgICAgICAgICByZWFkKCd6ZmFpbCcpLFxuICAgICAgICAgICAgICAgIHJlYWQoJ3pwYXNzJylcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfUE9MWUdPTl9PRkZTRVRfT0ZGU0VUOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHZhciBmYWN0b3IgPSB2YWx1ZS5mYWN0b3IgfCAwXG4gICAgICAgICAgICAgIHZhciB1bml0cyA9IHZhbHVlLnVuaXRzIHwgMFxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKGZhY3RvciwgJ251bWJlcicsIHBhcmFtICsgJy5mYWN0b3InLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh1bml0cywgJ251bWJlcicsIHBhcmFtICsgJy51bml0cycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW2ZhY3RvciwgdW5pdHNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcClcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICB2YXIgRkFDVE9SID0gc2NvcGUuZGVmKHZhbHVlLCAnLmZhY3RvcnwwJylcbiAgICAgICAgICAgICAgdmFyIFVOSVRTID0gc2NvcGUuZGVmKHZhbHVlLCAnLnVuaXRzfDAnKVxuXG4gICAgICAgICAgICAgIHJldHVybiBbRkFDVE9SLCBVTklUU11cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0NVTExfRkFDRTpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgZmFjZSA9IDBcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgICAgICAgZmFjZSA9IEdMX0ZST05UXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdiYWNrJykge1xuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9CQUNLXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEhZmFjZSwgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gZmFjZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJmcm9udFwifHwnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiYmFja1wiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGN1bGwuZmFjZScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUsICc9PT1cImZyb250XCI/JywgR0xfRlJPTlQsICc6JywgR0xfQkFDSylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0xJTkVfV0lEVEg6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA+PSBsaW1pdHMubGluZVdpZHRoRGltc1swXSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlIDw9IGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLFxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGxpbmUgd2lkdGgsIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIgYmV0d2VlbiAnICtcbiAgICAgICAgICAgICAgICBsaW1pdHMubGluZVdpZHRoRGltc1swXSArICcgYW5kICcgKyBsaW1pdHMubGluZVdpZHRoRGltc1sxXSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc+PScgKyBsaW1pdHMubGluZVdpZHRoRGltc1swXSArICcmJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPD0nICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMV0sXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBsaW5lIHdpZHRoJylcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0ZST05UX0ZBQ0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBvcmllbnRhdGlvblR5cGUsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uVHlwZVt2YWx1ZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiY3dcInx8JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImNjd1wiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGZyb250RmFjZSwgbXVzdCBiZSBvbmUgb2YgY3csY2N3JylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZih2YWx1ZSArICc9PT1cImN3XCI/JyArIEdMX0NXICsgJzonICsgR0xfQ0NXKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfQ09MT1JfTUFTSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgICAgICAgICAnY29sb3IubWFzayBtdXN0IGJlIGxlbmd0aCA0IGFycmF5JywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICEhdiB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgZW52LnNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIHZhbHVlICsgJykmJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnLmxlbmd0aD09PTQnLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgY29sb3IubWFzaycpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBsb29wKDQsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICchIScgKyB2YWx1ZSArICdbJyArIGkgKyAnXSdcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1NBTVBMRV9DT1ZFUkFHRTpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSwgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgc2FtcGxlVmFsdWUgPSAndmFsdWUnIGluIHZhbHVlID8gdmFsdWUudmFsdWUgOiAxXG4gICAgICAgICAgICAgIHZhciBzYW1wbGVJbnZlcnQgPSAhIXZhbHVlLmludmVydFxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNhbXBsZVZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlID49IDAgJiYgc2FtcGxlVmFsdWUgPD0gMSxcbiAgICAgICAgICAgICAgICAnc2FtcGxlLmNvdmVyYWdlLnZhbHVlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlVmFsdWUsIHNhbXBsZUludmVydF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIHNhbXBsZS5jb3ZlcmFnZScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHZhciBWQUxVRSA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICAgICAnXCJ2YWx1ZVwiIGluICcsIHZhbHVlLCAnPysnLCB2YWx1ZSwgJy52YWx1ZToxJylcbiAgICAgICAgICAgICAgdmFyIElOVkVSVCA9IHNjb3BlLmRlZignISEnLCB2YWx1ZSwgJy5pbnZlcnQnKVxuICAgICAgICAgICAgICByZXR1cm4gW1ZBTFVFLCBJTlZFUlRdXG4gICAgICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gU1RBVEVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVW5pZm9ybXMgKHVuaWZvcm1zLCBlbnYpIHtcbiAgICB2YXIgc3RhdGljVW5pZm9ybXMgPSB1bmlmb3Jtcy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY1VuaWZvcm1zID0gdW5pZm9ybXMuZHluYW1pY1xuXG4gICAgdmFyIFVOSUZPUk1TID0ge31cblxuICAgIE9iamVjdC5rZXlzKHN0YXRpY1VuaWZvcm1zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0aWNVbmlmb3Jtc1tuYW1lXVxuICAgICAgdmFyIHJlc3VsdFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciByZWdsVHlwZSA9IHZhbHVlLl9yZWdsVHlwZVxuICAgICAgICBpZiAocmVnbFR5cGUgPT09ICd0ZXh0dXJlMmQnIHx8XG4gICAgICAgICAgICByZWdsVHlwZSA9PT0gJ3RleHR1cmVDdWJlJykge1xuICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAocmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicgfHxcbiAgICAgICAgICAgICAgICAgICByZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyQ3ViZScpIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodmFsdWUuY29sb3IubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICdtaXNzaW5nIGNvbG9yIGF0dGFjaG1lbnQgZm9yIGZyYW1lYnVmZmVyIHNlbnQgdG8gdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgICAgICByZXR1cm4gZW52LmxpbmsodmFsdWUuY29sb3JbMF0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBkYXRhIGZvciB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCInLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgICAgdmFyIElURU0gPSBlbnYuZ2xvYmFsLmRlZignWycsXG4gICAgICAgICAgICBsb29wKHZhbHVlLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVtpXSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWVbaV0gPT09ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2ldXG4gICAgICAgICAgICB9KSwgJ10nKVxuICAgICAgICAgIHJldHVybiBJVEVNXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBvciBtaXNzaW5nIGRhdGEgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWVcbiAgICAgIFVOSUZPUk1TW25hbWVdID0gcmVzdWx0XG4gICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGR5bmFtaWNVbmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY1VuaWZvcm1zW2tleV1cbiAgICAgIFVOSUZPUk1TW2tleV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gVU5JRk9STVNcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyAoYXR0cmlidXRlcywgZW52KSB7XG4gICAgdmFyIHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnN0YXRpY1xuICAgIHZhciBkeW5hbWljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuZHluYW1pY1xuXG4gICAgdmFyIGF0dHJpYnV0ZURlZnMgPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoc3RhdGljQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0aWNBdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cbiAgICAgIHZhciBpZCA9IHN0cmluZ1N0b3JlLmlkKGF0dHJpYnV0ZSlcblxuICAgICAgdmFyIHJlY29yZCA9IG5ldyBBdHRyaWJ1dGVSZWNvcmQoKVxuICAgICAgaWYgKGlzQnVmZmVyQXJncyh2YWx1ZSkpIHtcbiAgICAgICAgcmVjb3JkLnN0YXRlID0gQVRUUklCX1NUQVRFX1BPSU5URVJcbiAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihcbiAgICAgICAgICBidWZmZXJTdGF0ZS5jcmVhdGUodmFsdWUsIEdMX0FSUkFZX0JVRkZFUiQyLCBmYWxzZSwgdHJ1ZSkpXG4gICAgICAgIHJlY29yZC50eXBlID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcih2YWx1ZSlcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgICAgIHJlY29yZC50eXBlID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLFxuICAgICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgYXR0cmlidXRlICcgKyBhdHRyaWJ1dGUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIGlmICgnY29uc3RhbnQnIGluIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RhbnQgPSB2YWx1ZS5jb25zdGFudFxuICAgICAgICAgICAgcmVjb3JkLmJ1ZmZlciA9ICdudWxsJ1xuICAgICAgICAgICAgcmVjb3JkLnN0YXRlID0gQVRUUklCX1NUQVRFX0NPTlNUQU5UXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0YW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICByZWNvcmQueCA9IGNvbnN0YW50XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UoY29uc3RhbnQpICYmXG4gICAgICAgICAgICAgICAgY29uc3RhbnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGNvbnN0YW50Lmxlbmd0aCA8PSA0LFxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbnN0YW50IGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIENVVEVfQ09NUE9ORU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjb25zdGFudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlY29yZFtjXSA9IGNvbnN0YW50W2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNCdWZmZXJBcmdzKHZhbHVlLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKFxuICAgICAgICAgICAgICAgIGJ1ZmZlclN0YXRlLmNyZWF0ZSh2YWx1ZS5idWZmZXIsIEdMX0FSUkFZX0JVRkZFUiQyLCBmYWxzZSwgdHJ1ZSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIodmFsdWUuYnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEhYnVmZmVyLCAnbWlzc2luZyBidWZmZXIgZm9yIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHZhbHVlLm9mZnNldCB8IDBcbiAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChvZmZzZXQgPj0gMCxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgb2Zmc2V0IGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB2YWx1ZS5zdHJpZGUgfCAwXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoc3RyaWRlID49IDAgJiYgc3RyaWRlIDwgMjU2LFxuICAgICAgICAgICAgICAnaW52YWxpZCBzdHJpZGUgZm9yIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCIsIG11c3QgYmUgaW50ZWdlciBiZXR3ZWVlbiBbMCwgMjU1XScsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHZhbHVlLnNpemUgfCAwXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoISgnc2l6ZScgaW4gdmFsdWUpIHx8IChzaXplID4gMCAmJiBzaXplIDw9IDQpLFxuICAgICAgICAgICAgICAnaW52YWxpZCBzaXplIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBtdXN0IGJlIDEsMiwzLDQnLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSAhIXZhbHVlLm5vcm1hbGl6ZWRcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSAwXG4gICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlLCBnbFR5cGVzLFxuICAgICAgICAgICAgICAgICdpbnZhbGlkIHR5cGUgZm9yIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgdHlwZSA9IGdsVHlwZXNbdmFsdWUudHlwZV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSB2YWx1ZS5kaXZpc29yIHwgMFxuICAgICAgICAgICAgaWYgKCdkaXZpc29yJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoZGl2aXNvciA9PT0gMCB8fCBleHRJbnN0YW5jaW5nLFxuICAgICAgICAgICAgICAgICdjYW5ub3Qgc3BlY2lmeSBkaXZpc29yIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBpbnN0YW5jaW5nIG5vdCBzdXBwb3J0ZWQnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPj0gMCxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBkaXZpc29yIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGVudi5jb21tYW5kU3RyXG5cbiAgICAgICAgICAgICAgdmFyIFZBTElEX0tFWVMgPSBbXG4gICAgICAgICAgICAgICAgJ2J1ZmZlcicsXG4gICAgICAgICAgICAgICAgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgJ2Rpdmlzb3InLFxuICAgICAgICAgICAgICAgICdub3JtYWxpemVkJyxcbiAgICAgICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAgICAgJ3NpemUnLFxuICAgICAgICAgICAgICAgICdzdHJpZGUnXG4gICAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIFZBTElEX0tFWVMuaW5kZXhPZihwcm9wKSA+PSAwLFxuICAgICAgICAgICAgICAgICAgJ3Vua25vd24gcGFyYW1ldGVyIFwiJyArIHByb3AgKyAnXCIgZm9yIGF0dHJpYnV0ZSBwb2ludGVyIFwiJyArIGF0dHJpYnV0ZSArICdcIiAodmFsaWQgcGFyYW1ldGVycyBhcmUgJyArIFZBTElEX0tFWVMgKyAnKScsXG4gICAgICAgICAgICAgICAgICBjb21tYW5kKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgICAgICAgcmVjb3JkLnN0YXRlID0gQVRUUklCX1NUQVRFX1BPSU5URVJcbiAgICAgICAgICAgIHJlY29yZC5zaXplID0gc2l6ZVxuICAgICAgICAgICAgcmVjb3JkLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkXG4gICAgICAgICAgICByZWNvcmQudHlwZSA9IHR5cGUgfHwgYnVmZmVyLmR0eXBlXG4gICAgICAgICAgICByZWNvcmQub2Zmc2V0ID0gb2Zmc2V0XG4gICAgICAgICAgICByZWNvcmQuc3RyaWRlID0gc3RyaWRlXG4gICAgICAgICAgICByZWNvcmQuZGl2aXNvciA9IGRpdmlzb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlRGVmc1thdHRyaWJ1dGVdID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBlbnYuYXR0cmliQ2FjaGVcbiAgICAgICAgaWYgKGlkIGluIGNhY2hlKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlW2lkXVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgaXNTdHJlYW06IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMocmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHJlY29yZFtrZXldXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChyZWNvcmQuYnVmZmVyKSB7XG4gICAgICAgICAgcmVzdWx0LmJ1ZmZlciA9IGVudi5saW5rKHJlY29yZC5idWZmZXIpXG4gICAgICAgICAgcmVzdWx0LnR5cGUgPSByZXN1bHQudHlwZSB8fCAocmVzdWx0LmJ1ZmZlciArICcuZHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2lkXSA9IHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY0F0dHJpYnV0ZXNbYXR0cmlidXRlXVxuXG4gICAgICBmdW5jdGlvbiBhcHBlbmRBdHRyaWJ1dGVDb2RlIChlbnYsIGJsb2NrKSB7XG4gICAgICAgIHZhciBWQUxVRSA9IGVudi5pbnZva2UoYmxvY2ssIGR5bilcblxuICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50c1xuXG4gICAgICAgIHZhciBJU19CVUZGRVJfQVJHUyA9IHNoYXJlZC5pc0J1ZmZlckFyZ3NcbiAgICAgICAgdmFyIEJVRkZFUl9TVEFURSA9IHNoYXJlZC5idWZmZXJcblxuICAgICAgICAvLyBQZXJmb3JtIHZhbGlkYXRpb24gb24gYXR0cmlidXRlXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXG4gICAgICAgICAgICBWQUxVRSArICcmJih0eXBlb2YgJyArIFZBTFVFICsgJz09PVwib2JqZWN0XCJ8fHR5cGVvZiAnICtcbiAgICAgICAgICAgIFZBTFVFICsgJz09PVwiZnVuY3Rpb25cIikmJignICtcbiAgICAgICAgICAgIElTX0JVRkZFUl9BUkdTICsgJygnICsgVkFMVUUgKyAnKXx8JyArXG4gICAgICAgICAgICBCVUZGRVJfU1RBVEUgKyAnLmdldEJ1ZmZlcignICsgVkFMVUUgKyAnKXx8JyArXG4gICAgICAgICAgICBCVUZGRVJfU1RBVEUgKyAnLmdldEJ1ZmZlcignICsgVkFMVUUgKyAnLmJ1ZmZlcil8fCcgK1xuICAgICAgICAgICAgSVNfQlVGRkVSX0FSR1MgKyAnKCcgKyBWQUxVRSArICcuYnVmZmVyKXx8JyArXG4gICAgICAgICAgICAnKFwiY29uc3RhbnRcIiBpbiAnICsgVkFMVUUgK1xuICAgICAgICAgICAgJyYmKHR5cGVvZiAnICsgVkFMVUUgKyAnLmNvbnN0YW50PT09XCJudW1iZXJcInx8JyArXG4gICAgICAgICAgICBzaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyBWQUxVRSArICcuY29uc3RhbnQpKSkpJyxcbiAgICAgICAgICAgICdpbnZhbGlkIGR5bmFtaWMgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gYWxsb2NhdGUgbmFtZXMgZm9yIHJlc3VsdFxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzU3RyZWFtOiBibG9jay5kZWYoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRSZWNvcmQgPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgICAgZGVmYXVsdFJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRSZWNvcmQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gYmxvY2suZGVmKCcnICsgZGVmYXVsdFJlY29yZFtrZXldKVxuICAgICAgICB9KVxuXG4gICAgICAgIHZhciBCVUZGRVIgPSByZXN1bHQuYnVmZmVyXG4gICAgICAgIHZhciBUWVBFID0gcmVzdWx0LnR5cGVcbiAgICAgICAgYmxvY2soXG4gICAgICAgICAgJ2lmKCcsIElTX0JVRkZFUl9BUkdTLCAnKCcsIFZBTFVFLCAnKSl7JyxcbiAgICAgICAgICByZXN1bHQuaXNTdHJlYW0sICc9dHJ1ZTsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsIFZBTFVFLCAnKTsnLFxuICAgICAgICAgIFRZUEUsICc9JywgQlVGRkVSLCAnLmR0eXBlOycsXG4gICAgICAgICAgJ31lbHNleycsXG4gICAgICAgICAgQlVGRkVSLCAnPScsIEJVRkZFUl9TVEFURSwgJy5nZXRCdWZmZXIoJywgVkFMVUUsICcpOycsXG4gICAgICAgICAgJ2lmKCcsIEJVRkZFUiwgJyl7JyxcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxuICAgICAgICAgICd9ZWxzZSBpZihcImNvbnN0YW50XCIgaW4gJywgVkFMVUUsICcpeycsXG4gICAgICAgICAgcmVzdWx0LnN0YXRlLCAnPScsIEFUVFJJQl9TVEFURV9DT05TVEFOVCwgJzsnLFxuICAgICAgICAgICdpZih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudCA9PT0gXCJudW1iZXJcIil7JyxcbiAgICAgICAgICByZXN1bHRbQ1VURV9DT01QT05FTlRTWzBdXSwgJz0nLCBWQUxVRSwgJy5jb25zdGFudDsnLFxuICAgICAgICAgIENVVEVfQ09NUE9ORU5UUy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbbl1cbiAgICAgICAgICB9KS5qb2luKCc9JyksICc9MDsnLFxuICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgIENVVEVfQ09NUE9ORU5UUy5tYXAoZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSArICc9JyArIFZBTFVFICsgJy5jb25zdGFudC5sZW5ndGg+JyArIGkgK1xuICAgICAgICAgICAgICAnPycgKyBWQUxVRSArICcuY29uc3RhbnRbJyArIGkgKyAnXTowOydcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgICAnfX1lbHNleycsXG4gICAgICAgICAgJ2lmKCcsIElTX0JVRkZFUl9BUkdTLCAnKCcsIFZBTFVFLCAnLmJ1ZmZlcikpeycsXG4gICAgICAgICAgQlVGRkVSLCAnPScsIEJVRkZFUl9TVEFURSwgJy5jcmVhdGVTdHJlYW0oJywgR0xfQVJSQVlfQlVGRkVSJDIsICcsJywgVkFMVUUsICcuYnVmZmVyKTsnLFxuICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuZ2V0QnVmZmVyKCcsIFZBTFVFLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICAnfScsXG4gICAgICAgICAgVFlQRSwgJz1cInR5cGVcIiBpbiAnLCBWQUxVRSwgJz8nLFxuICAgICAgICAgIGNvbnN0YW50cy5nbFR5cGVzLCAnWycsIFZBTFVFLCAnLnR5cGVdOicsIEJVRkZFUiwgJy5kdHlwZTsnLFxuICAgICAgICAgIHJlc3VsdC5ub3JtYWxpemVkLCAnPSEhJywgVkFMVUUsICcubm9ybWFsaXplZDsnKVxuICAgICAgICBmdW5jdGlvbiBlbWl0UmVhZFJlY29yZCAobmFtZSkge1xuICAgICAgICAgIGJsb2NrKHJlc3VsdFtuYW1lXSwgJz0nLCBWQUxVRSwgJy4nLCBuYW1lLCAnfDA7JylcbiAgICAgICAgfVxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnc2l6ZScpXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdvZmZzZXQnKVxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnc3RyaWRlJylcbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ2Rpdmlzb3InKVxuXG4gICAgICAgIGJsb2NrKCd9fScpXG5cbiAgICAgICAgYmxvY2suZXhpdChcbiAgICAgICAgICAnaWYoJywgcmVzdWx0LmlzU3RyZWFtLCAnKXsnLFxuICAgICAgICAgIEJVRkZFUl9TVEFURSwgJy5kZXN0cm95U3RyZWFtKCcsIEJVRkZFUiwgJyk7JyxcbiAgICAgICAgICAnfScpXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGVEZWZzW2F0dHJpYnV0ZV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGFwcGVuZEF0dHJpYnV0ZUNvZGUpXG4gICAgfSlcblxuICAgIHJldHVybiBhdHRyaWJ1dGVEZWZzXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVZBTyAob3B0aW9ucywgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuICAgIGlmIChTX1ZBTyBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICB2YXIgdmFvID0gc3RhdGljT3B0aW9uc1tTX1ZBT11cbiAgICAgIGlmICh2YW8gIT09IG51bGwgJiYgYXR0cmlidXRlU3RhdGUuZ2V0VkFPKHZhbykgPT09IG51bGwpIHtcbiAgICAgICAgdmFvID0gYXR0cmlidXRlU3RhdGUuY3JlYXRlVkFPKHZhbylcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgcmV0dXJuIGVudi5saW5rKGF0dHJpYnV0ZVN0YXRlLmdldFZBTyh2YW8pKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKFNfVkFPIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19WQU9dXG4gICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICB2YXIgdmFvUmVmID0gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVudi5zaGFyZWQudmFvICsgJy5nZXRWQU8oJyArIHZhb1JlZiArICcpJylcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNvbnRleHQgKGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGljQ29udGV4dCA9IGNvbnRleHQuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNDb250ZXh0ID0gY29udGV4dC5keW5hbWljXG4gICAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhzdGF0aWNDb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0aWNDb250ZXh0W25hbWVdXG4gICAgICByZXN1bHRbbmFtZV0gPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuICcnICsgdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZW52LmxpbmsodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGR5bmFtaWNDb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY0NvbnRleHRbbmFtZV1cbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzIChvcHRpb25zLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgS0VZX05BTUVTID0gW1xuICAgICAgICBTX0ZSQU1FQlVGRkVSLFxuICAgICAgICBTX1ZFUlQsXG4gICAgICAgIFNfRlJBRyxcbiAgICAgICAgU19FTEVNRU5UUyxcbiAgICAgICAgU19QUklNSVRJVkUsXG4gICAgICAgIFNfT0ZGU0VULFxuICAgICAgICBTX0NPVU5ULFxuICAgICAgICBTX0lOU1RBTkNFUyxcbiAgICAgICAgU19QUk9GSUxFLFxuICAgICAgICBTX1ZBT1xuICAgICAgXS5jb25jYXQoR0xfU1RBVEVfTkFNRVMpXG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrS2V5cyAoZGljdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICBLRVlfTkFNRVMuaW5kZXhPZihrZXkpID49IDAsXG4gICAgICAgICAgICAndW5rbm93biBwYXJhbWV0ZXIgXCInICsga2V5ICsgJ1wiJyxcbiAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjaGVja0tleXMoc3RhdGljT3B0aW9ucylcbiAgICAgIGNoZWNrS2V5cyhkeW5hbWljT3B0aW9ucylcbiAgICB9KVxuXG4gICAgdmFyIGF0dHJpYkxvY2F0aW9ucyA9IHBhcnNlQXR0cmliTG9jYXRpb25zKG9wdGlvbnMsIGF0dHJpYnV0ZXMpXG5cbiAgICB2YXIgZnJhbWVidWZmZXIgPSBwYXJzZUZyYW1lYnVmZmVyKG9wdGlvbnMsIGVudilcbiAgICB2YXIgdmlld3BvcnRBbmRTY2lzc29yID0gcGFyc2VWaWV3cG9ydFNjaXNzb3Iob3B0aW9ucywgZnJhbWVidWZmZXIsIGVudilcbiAgICB2YXIgZHJhdyA9IHBhcnNlRHJhdyhvcHRpb25zLCBlbnYpXG4gICAgdmFyIHN0YXRlID0gcGFyc2VHTFN0YXRlKG9wdGlvbnMsIGVudilcbiAgICB2YXIgc2hhZGVyID0gcGFyc2VQcm9ncmFtKG9wdGlvbnMsIGVudiwgYXR0cmliTG9jYXRpb25zKVxuXG4gICAgZnVuY3Rpb24gY29weUJveCAobmFtZSkge1xuICAgICAgdmFyIGRlZm4gPSB2aWV3cG9ydEFuZFNjaXNzb3JbbmFtZV1cbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIHN0YXRlW25hbWVdID0gZGVmblxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5Qm94KFNfVklFV1BPUlQpXG4gICAgY29weUJveChwcm9wTmFtZShTX1NDSVNTT1JfQk9YKSlcblxuICAgIHZhciBkaXJ0eSA9IE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGggPiAwXG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyLFxuICAgICAgZHJhdzogZHJhdyxcbiAgICAgIHNoYWRlcjogc2hhZGVyLFxuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgc2NvcGVWQU86IG51bGwsXG4gICAgICBkcmF3VkFPOiBudWxsLFxuICAgICAgdXNlVkFPOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb2ZpbGUgPSBwYXJzZVByb2ZpbGUob3B0aW9ucywgZW52KVxuICAgIHJlc3VsdC51bmlmb3JtcyA9IHBhcnNlVW5pZm9ybXModW5pZm9ybXMsIGVudilcbiAgICByZXN1bHQuZHJhd1ZBTyA9IHJlc3VsdC5zY29wZVZBTyA9IHBhcnNlVkFPKG9wdGlvbnMsIGVudilcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGNoZWNrIGlmIHdlIGNhbiBzdGF0aWNhbGx5IGFsbG9jYXRlIGEgdmVydGV4IGFycmF5IG9iamVjdCBmb3IgdGhpcyBwcm9ncmFtXG4gICAgaWYgKCFyZXN1bHQuZHJhd1ZBTyAmJiBzaGFkZXIucHJvZ3JhbSAmJiAhYXR0cmliTG9jYXRpb25zICYmIGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5cykge1xuICAgICAgdmFyIHVzZVZBTyA9IHRydWVcbiAgICAgIHZhciBzdGF0aWNCaW5kaW5ncyA9IHNoYWRlci5wcm9ncmFtLmF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXR0cmlidXRlcy5zdGF0aWNbYXR0cl1cbiAgICAgICAgdXNlVkFPID0gdXNlVkFPICYmICEhYmluZGluZ1xuICAgICAgICByZXR1cm4gYmluZGluZ1xuICAgICAgfSlcbiAgICAgIGlmICh1c2VWQU8gJiYgc3RhdGljQmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdmFvID0gYXR0cmlidXRlU3RhdGUuZ2V0VkFPKGF0dHJpYnV0ZVN0YXRlLmNyZWF0ZVZBTyhzdGF0aWNCaW5kaW5ncykpXG4gICAgICAgIHJlc3VsdC5kcmF3VkFPID0gbmV3IERlY2xhcmF0aW9uKG51bGwsIG51bGwsIG51bGwsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbylcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0LnVzZVZBTyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgcmVzdWx0LnVzZVZBTyA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZW52KVxuICAgIH1cbiAgICByZXN1bHQuY29udGV4dCA9IHBhcnNlQ29udGV4dChjb250ZXh0LCBlbnYpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBDT01NT04gVVBEQVRFIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXRDb250ZXh0IChlbnYsIHNjb3BlLCBjb250ZXh0KSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0XG5cbiAgICB2YXIgY29udGV4dEVudGVyID0gZW52LnNjb3BlKClcblxuICAgIE9iamVjdC5rZXlzKGNvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHNjb3BlLnNhdmUoQ09OVEVYVCwgJy4nICsgbmFtZSlcbiAgICAgIHZhciBkZWZuID0gY29udGV4dFtuYW1lXVxuICAgICAgdmFyIHZhbHVlID0gZGVmbi5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb250ZXh0RW50ZXIoQ09OVEVYVCwgJy4nLCBuYW1lLCAnPVsnLCB2YWx1ZS5qb2luKCksICddOycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0RW50ZXIoQ09OVEVYVCwgJy4nLCBuYW1lLCAnPScsIHZhbHVlLCAnOycpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHNjb3BlKGNvbnRleHRFbnRlcilcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09NTU9OIERSQVdJTkcgRlVOQ1RJT05TXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW1pdFBvbGxGcmFtZWJ1ZmZlciAoZW52LCBzY29wZSwgZnJhbWVidWZmZXIsIHNraXBDaGVjaykge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG5cbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICB2YXIgRlJBTUVCVUZGRVJfU1RBVEUgPSBzaGFyZWQuZnJhbWVidWZmZXJcbiAgICB2YXIgRVhUX0RSQVdfQlVGRkVSU1xuICAgIGlmIChleHREcmF3QnVmZmVycykge1xuICAgICAgRVhUX0RSQVdfQlVGRkVSUyA9IHNjb3BlLmRlZihzaGFyZWQuZXh0ZW5zaW9ucywgJy53ZWJnbF9kcmF3X2J1ZmZlcnMnKVxuICAgIH1cblxuICAgIHZhciBjb25zdGFudHMgPSBlbnYuY29uc3RhbnRzXG5cbiAgICB2YXIgRFJBV19CVUZGRVJTID0gY29uc3RhbnRzLmRyYXdCdWZmZXJcbiAgICB2YXIgQkFDS19CVUZGRVIgPSBjb25zdGFudHMuYmFja0J1ZmZlclxuXG4gICAgdmFyIE5FWFRcbiAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgIE5FWFQgPSBmcmFtZWJ1ZmZlci5hcHBlbmQoZW52LCBzY29wZSlcbiAgICB9IGVsc2Uge1xuICAgICAgTkVYVCA9IHNjb3BlLmRlZihGUkFNRUJVRkZFUl9TVEFURSwgJy5uZXh0JylcbiAgICB9XG5cbiAgICBpZiAoIXNraXBDaGVjaykge1xuICAgICAgc2NvcGUoJ2lmKCcsIE5FWFQsICchPT0nLCBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXIpeycpXG4gICAgfVxuICAgIHNjb3BlKFxuICAgICAgJ2lmKCcsIE5FWFQsICcpeycsXG4gICAgICBHTCwgJy5iaW5kRnJhbWVidWZmZXIoJywgR0xfRlJBTUVCVUZGRVIkMiwgJywnLCBORVhULCAnLmZyYW1lYnVmZmVyKTsnKVxuICAgIGlmIChleHREcmF3QnVmZmVycykge1xuICAgICAgc2NvcGUoRVhUX0RSQVdfQlVGRkVSUywgJy5kcmF3QnVmZmVyc1dFQkdMKCcsXG4gICAgICAgIERSQVdfQlVGRkVSUywgJ1snLCBORVhULCAnLmNvbG9yQXR0YWNobWVudHMubGVuZ3RoXSk7JylcbiAgICB9XG4gICAgc2NvcGUoJ31lbHNleycsXG4gICAgICBHTCwgJy5iaW5kRnJhbWVidWZmZXIoJywgR0xfRlJBTUVCVUZGRVIkMiwgJyxudWxsKTsnKVxuICAgIGlmIChleHREcmF3QnVmZmVycykge1xuICAgICAgc2NvcGUoRVhUX0RSQVdfQlVGRkVSUywgJy5kcmF3QnVmZmVyc1dFQkdMKCcsIEJBQ0tfQlVGRkVSLCAnKTsnKVxuICAgIH1cbiAgICBzY29wZShcbiAgICAgICd9JyxcbiAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLCAnLmN1cj0nLCBORVhULCAnOycpXG4gICAgaWYgKCFza2lwQ2hlY2spIHtcbiAgICAgIHNjb3BlKCd9JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0UG9sbFN0YXRlIChlbnYsIHNjb3BlLCBhcmdzKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcblxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuXG4gICAgdmFyIENVUlJFTlRfVkFSUyA9IGVudi5jdXJyZW50XG4gICAgdmFyIE5FWFRfVkFSUyA9IGVudi5uZXh0XG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuICAgIHZhciBORVhUX1NUQVRFID0gc2hhcmVkLm5leHRcblxuICAgIHZhciBibG9jayA9IGVudi5jb25kKENVUlJFTlRfU1RBVEUsICcuZGlydHknKVxuXG4gICAgR0xfU1RBVEVfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgdmFyIHBhcmFtID0gcHJvcE5hbWUocHJvcClcbiAgICAgIGlmIChwYXJhbSBpbiBhcmdzLnN0YXRlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgTkVYVCwgQ1VSUkVOVFxuICAgICAgaWYgKHBhcmFtIGluIE5FWFRfVkFSUykge1xuICAgICAgICBORVhUID0gTkVYVF9WQVJTW3BhcmFtXVxuICAgICAgICBDVVJSRU5UID0gQ1VSUkVOVF9WQVJTW3BhcmFtXVxuICAgICAgICB2YXIgcGFydHMgPSBsb29wKGN1cnJlbnRTdGF0ZVtwYXJhbV0ubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoTkVYVCwgJ1snLCBpLCAnXScpXG4gICAgICAgIH0pXG4gICAgICAgIGJsb2NrKGVudi5jb25kKHBhcnRzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIHJldHVybiBwICsgJyE9PScgKyBDVVJSRU5UICsgJ1snICsgaSArICddJ1xuICAgICAgICB9KS5qb2luKCd8fCcpKVxuICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgR0wsICcuJywgR0xfVkFSSUFCTEVTW3BhcmFtXSwgJygnLCBwYXJ0cywgJyk7JyxcbiAgICAgICAgICAgIHBhcnRzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ1VSUkVOVCArICdbJyArIGkgKyAnXT0nICsgcFxuICAgICAgICAgICAgfSkuam9pbignOycpLCAnOycpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTkVYVCA9IGJsb2NrLmRlZihORVhUX1NUQVRFLCAnLicsIHBhcmFtKVxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKE5FWFQsICchPT0nLCBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtKVxuICAgICAgICBibG9jayhpZnRlKVxuICAgICAgICBpZiAocGFyYW0gaW4gR0xfRkxBR1MpIHtcbiAgICAgICAgICBpZnRlKFxuICAgICAgICAgICAgZW52LmNvbmQoTkVYVClcbiAgICAgICAgICAgICAgLnRoZW4oR0wsICcuZW5hYmxlKCcsIEdMX0ZMQUdTW3BhcmFtXSwgJyk7JylcbiAgICAgICAgICAgICAgLmVsc2UoR0wsICcuZGlzYWJsZSgnLCBHTF9GTEFHU1twYXJhbV0sICcpOycpLFxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCBORVhULCAnOycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZ0ZShcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgTkVYVCwgJyk7JyxcbiAgICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgTkVYVCwgJzsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBibG9jayhDVVJSRU5UX1NUQVRFLCAnLmRpcnR5PWZhbHNlOycpXG4gICAgfVxuICAgIHNjb3BlKGJsb2NrKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFNldE9wdGlvbnMgKGVudiwgc2NvcGUsIG9wdGlvbnMsIGZpbHRlcikge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENVUlJFTlRfVkFSUyA9IGVudi5jdXJyZW50XG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuICAgIHNvcnRTdGF0ZShPYmplY3Qua2V5cyhvcHRpb25zKSkuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBkZWZuID0gb3B0aW9uc1twYXJhbV1cbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlcihkZWZuKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciB2YXJpYWJsZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoR0xfRkxBR1NbcGFyYW1dKSB7XG4gICAgICAgIHZhciBmbGFnID0gR0xfRkxBR1NbcGFyYW1dXG4gICAgICAgIGlmIChpc1N0YXRpYyhkZWZuKSkge1xuICAgICAgICAgIGlmICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgc2NvcGUoR0wsICcuZW5hYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLmRpc2FibGUoJywgZmxhZywgJyk7JylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcGUoZW52LmNvbmQodmFyaWFibGUpXG4gICAgICAgICAgICAudGhlbihHTCwgJy5lbmFibGUoJywgZmxhZywgJyk7JylcbiAgICAgICAgICAgIC5lbHNlKEdMLCAnLmRpc2FibGUoJywgZmxhZywgJyk7JykpXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZSh2YXJpYWJsZSkpIHtcbiAgICAgICAgdmFyIENVUlJFTlQgPSBDVVJSRU5UX1ZBUlNbcGFyYW1dXG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgdmFyaWFibGUsICcpOycsXG4gICAgICAgICAgdmFyaWFibGUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1VSUkVOVCArICdbJyArIGkgKyAnXT0nICsgdlxuICAgICAgICAgIH0pLmpvaW4oJzsnKSwgJzsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgR0wsICcuJywgR0xfVkFSSUFCTEVTW3BhcmFtXSwgJygnLCB2YXJpYWJsZSwgJyk7JyxcbiAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtLCAnPScsIHZhcmlhYmxlLCAnOycpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbnMgKGVudiwgc2NvcGUpIHtcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgZW52Lmluc3RhbmNpbmcgPSBzY29wZS5kZWYoXG4gICAgICAgIGVudi5zaGFyZWQuZXh0ZW5zaW9ucywgJy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0UHJvZmlsZSAoZW52LCBzY29wZSwgYXJncywgdXNlU2NvcGUsIGluY3JlbWVudENvdW50ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBTVEFUUyA9IGVudi5zdGF0c1xuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgVElNRVIgPSBzaGFyZWQudGltZXJcbiAgICB2YXIgcHJvZmlsZUFyZyA9IGFyZ3MucHJvZmlsZVxuXG4gICAgZnVuY3Rpb24gcGVyZkNvdW50ZXIgKCkge1xuICAgICAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICdEYXRlLm5vdygpJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdwZXJmb3JtYW5jZS5ub3coKSdcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQ1BVX1NUQVJULCBRVUVSWV9DT1VOVEVSXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVTdGFydCAoYmxvY2spIHtcbiAgICAgIENQVV9TVEFSVCA9IHNjb3BlLmRlZigpXG4gICAgICBibG9jayhDUFVfU1RBUlQsICc9JywgcGVyZkNvdW50ZXIoKSwgJzsnKVxuICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnRDb3VudGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBibG9jayhTVEFUUywgJy5jb3VudCs9JywgaW5jcmVtZW50Q291bnRlciwgJzsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrKzsnKVxuICAgICAgfVxuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGlmICh1c2VTY29wZSkge1xuICAgICAgICAgIFFVRVJZX0NPVU5URVIgPSBzY29wZS5kZWYoKVxuICAgICAgICAgIGJsb2NrKFFVRVJZX0NPVU5URVIsICc9JywgVElNRVIsICcuZ2V0TnVtUGVuZGluZ1F1ZXJpZXMoKTsnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLmJlZ2luUXVlcnkoJywgU1RBVFMsICcpOycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0UHJvZmlsZUVuZCAoYmxvY2spIHtcbiAgICAgIGJsb2NrKFNUQVRTLCAnLmNwdVRpbWUrPScsIHBlcmZDb3VudGVyKCksICctJywgQ1BVX1NUQVJULCAnOycpXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgaWYgKHVzZVNjb3BlKSB7XG4gICAgICAgICAgYmxvY2soVElNRVIsICcucHVzaFNjb3BlU3RhdHMoJyxcbiAgICAgICAgICAgIFFVRVJZX0NPVU5URVIsICcsJyxcbiAgICAgICAgICAgIFRJTUVSLCAnLmdldE51bVBlbmRpbmdRdWVyaWVzKCksJyxcbiAgICAgICAgICAgIFNUQVRTLCAnKTsnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLmVuZFF1ZXJ5KCk7JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjb3BlUHJvZmlsZSAodmFsdWUpIHtcbiAgICAgIHZhciBwcmV2ID0gc2NvcGUuZGVmKENVUlJFTlRfU1RBVEUsICcucHJvZmlsZScpXG4gICAgICBzY29wZShDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGU9JywgdmFsdWUsICc7JylcbiAgICAgIHNjb3BlLmV4aXQoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlPScsIHByZXYsICc7JylcbiAgICB9XG5cbiAgICB2YXIgVVNFX1BST0ZJTEVcbiAgICBpZiAocHJvZmlsZUFyZykge1xuICAgICAgaWYgKGlzU3RhdGljKHByb2ZpbGVBcmcpKSB7XG4gICAgICAgIGlmIChwcm9maWxlQXJnLmVuYWJsZSkge1xuICAgICAgICAgIGVtaXRQcm9maWxlU3RhcnQoc2NvcGUpXG4gICAgICAgICAgZW1pdFByb2ZpbGVFbmQoc2NvcGUuZXhpdClcbiAgICAgICAgICBzY29wZVByb2ZpbGUoJ3RydWUnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlUHJvZmlsZSgnZmFsc2UnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgVVNFX1BST0ZJTEUgPSBwcm9maWxlQXJnLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgc2NvcGVQcm9maWxlKFVTRV9QUk9GSUxFKVxuICAgIH0gZWxzZSB7XG4gICAgICBVU0VfUFJPRklMRSA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKVxuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGVudi5ibG9jaygpXG4gICAgZW1pdFByb2ZpbGVTdGFydChzdGFydClcbiAgICBzY29wZSgnaWYoJywgVVNFX1BST0ZJTEUsICcpeycsIHN0YXJ0LCAnfScpXG4gICAgdmFyIGVuZCA9IGVudi5ibG9jaygpXG4gICAgZW1pdFByb2ZpbGVFbmQoZW5kKVxuICAgIHNjb3BlLmV4aXQoJ2lmKCcsIFVTRV9QUk9GSUxFLCAnKXsnLCBlbmQsICd9JylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRBdHRyaWJ1dGVzIChlbnYsIHNjb3BlLCBhcmdzLCBhdHRyaWJ1dGVzLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgZnVuY3Rpb24gdHlwZUxlbmd0aCAoeCkge1xuICAgICAgc3dpdGNoICh4KSB7XG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMjpcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgcmV0dXJuIDJcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMzOlxuICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMzpcbiAgICAgICAgICByZXR1cm4gM1xuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzQ6XG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgICAgIHJldHVybiA0XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0QmluZEF0dHJpYnV0ZSAoQVRUUklCVVRFLCBzaXplLCByZWNvcmQpIHtcbiAgICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuXG4gICAgICB2YXIgTE9DQVRJT04gPSBzY29wZS5kZWYoQVRUUklCVVRFLCAnLmxvY2F0aW9uJylcbiAgICAgIHZhciBCSU5ESU5HID0gc2NvcGUuZGVmKHNoYXJlZC5hdHRyaWJ1dGVzLCAnWycsIExPQ0FUSU9OLCAnXScpXG5cbiAgICAgIHZhciBTVEFURSA9IHJlY29yZC5zdGF0ZVxuICAgICAgdmFyIEJVRkZFUiA9IHJlY29yZC5idWZmZXJcbiAgICAgIHZhciBDT05TVF9DT01QT05FTlRTID0gW1xuICAgICAgICByZWNvcmQueCxcbiAgICAgICAgcmVjb3JkLnksXG4gICAgICAgIHJlY29yZC56LFxuICAgICAgICByZWNvcmQud1xuICAgICAgXVxuXG4gICAgICB2YXIgQ09NTU9OX0tFWVMgPSBbXG4gICAgICAgICdidWZmZXInLFxuICAgICAgICAnbm9ybWFsaXplZCcsXG4gICAgICAgICdvZmZzZXQnLFxuICAgICAgICAnc3RyaWRlJ1xuICAgICAgXVxuXG4gICAgICBmdW5jdGlvbiBlbWl0QnVmZmVyICgpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCEnLCBCSU5ESU5HLCAnLmJ1ZmZlcil7JyxcbiAgICAgICAgICBHTCwgJy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgnLCBMT0NBVElPTiwgJyk7fScpXG5cbiAgICAgICAgdmFyIFRZUEUgPSByZWNvcmQudHlwZVxuICAgICAgICB2YXIgU0laRVxuICAgICAgICBpZiAoIXJlY29yZC5zaXplKSB7XG4gICAgICAgICAgU0laRSA9IHNpemVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBTSVpFID0gc2NvcGUuZGVmKHJlY29yZC5zaXplLCAnfHwnLCBzaXplKVxuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUoJ2lmKCcsXG4gICAgICAgICAgQklORElORywgJy50eXBlIT09JywgVFlQRSwgJ3x8JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnNpemUhPT0nLCBTSVpFLCAnfHwnLFxuICAgICAgICAgIENPTU1PTl9LRVlTLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGtleSArICchPT0nICsgcmVjb3JkW2tleV1cbiAgICAgICAgICB9KS5qb2luKCd8fCcpLFxuICAgICAgICAgICcpeycsXG4gICAgICAgICAgR0wsICcuYmluZEJ1ZmZlcignLCBHTF9BUlJBWV9CVUZGRVIkMiwgJywnLCBCVUZGRVIsICcuYnVmZmVyKTsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYlBvaW50ZXIoJywgW1xuICAgICAgICAgICAgTE9DQVRJT04sXG4gICAgICAgICAgICBTSVpFLFxuICAgICAgICAgICAgVFlQRSxcbiAgICAgICAgICAgIHJlY29yZC5ub3JtYWxpemVkLFxuICAgICAgICAgICAgcmVjb3JkLnN0cmlkZSxcbiAgICAgICAgICAgIHJlY29yZC5vZmZzZXRcbiAgICAgICAgICBdLCAnKTsnLFxuICAgICAgICAgIEJJTkRJTkcsICcudHlwZT0nLCBUWVBFLCAnOycsXG4gICAgICAgICAgQklORElORywgJy5zaXplPScsIFNJWkUsICc7JyxcbiAgICAgICAgICBDT01NT05fS0VZUy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBrZXkgKyAnPScgKyByZWNvcmRba2V5XSArICc7J1xuICAgICAgICAgIH0pLmpvaW4oJycpLFxuICAgICAgICAgICd9JylcblxuICAgICAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgICAgIHZhciBESVZJU09SID0gcmVjb3JkLmRpdmlzb3JcbiAgICAgICAgICBzY29wZShcbiAgICAgICAgICAgICdpZignLCBCSU5ESU5HLCAnLmRpdmlzb3IhPT0nLCBESVZJU09SLCAnKXsnLFxuICAgICAgICAgICAgZW52Lmluc3RhbmNpbmcsICcudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCcsIFtMT0NBVElPTiwgRElWSVNPUl0sICcpOycsXG4gICAgICAgICAgICBCSU5ESU5HLCAnLmRpdmlzb3I9JywgRElWSVNPUiwgJzt9JylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbWl0Q29uc3RhbnQgKCkge1xuICAgICAgICBzY29wZShcbiAgICAgICAgICAnaWYoJywgQklORElORywgJy5idWZmZXIpeycsXG4gICAgICAgICAgR0wsICcuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIExPQ0FUSU9OLCAnKTsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuYnVmZmVyPW51bGw7JyxcbiAgICAgICAgICAnfWlmKCcsIENVVEVfQ09NUE9ORU5UUy5tYXAoZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBCSU5ESU5HICsgJy4nICsgYyArICchPT0nICsgQ09OU1RfQ09NUE9ORU5UU1tpXVxuICAgICAgICAgIH0pLmpvaW4oJ3x8JyksICcpeycsXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliNGYoJywgTE9DQVRJT04sICcsJywgQ09OU1RfQ09NUE9ORU5UUywgJyk7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnPScgKyBDT05TVF9DT01QT05FTlRTW2ldICsgJzsnXG4gICAgICAgICAgfSkuam9pbignJyksXG4gICAgICAgICAgJ30nKVxuICAgICAgfVxuXG4gICAgICBpZiAoU1RBVEUgPT09IEFUVFJJQl9TVEFURV9QT0lOVEVSKSB7XG4gICAgICAgIGVtaXRCdWZmZXIoKVxuICAgICAgfSBlbHNlIGlmIChTVEFURSA9PT0gQVRUUklCX1NUQVRFX0NPTlNUQU5UKSB7XG4gICAgICAgIGVtaXRDb25zdGFudCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZSgnaWYoJywgU1RBVEUsICc9PT0nLCBBVFRSSUJfU1RBVEVfUE9JTlRFUiwgJyl7JylcbiAgICAgICAgZW1pdEJ1ZmZlcigpXG4gICAgICAgIHNjb3BlKCd9ZWxzZXsnKVxuICAgICAgICBlbWl0Q29uc3RhbnQoKVxuICAgICAgICBzY29wZSgnfScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWVcbiAgICAgIHZhciBhcmcgPSBhcmdzLmF0dHJpYnV0ZXNbbmFtZV1cbiAgICAgIHZhciByZWNvcmRcbiAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIoYXJnKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJlY29yZCA9IGFyZy5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmlsdGVyKFNDT1BFX0RFQ0wpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlQXR0cmliID0gZW52LnNjb3BlQXR0cmliKG5hbWUpXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICBzY29wZUF0dHJpYiArICcuc3RhdGUnLFxuICAgICAgICAgICAgJ21pc3NpbmcgYXR0cmlidXRlICcgKyBuYW1lKVxuICAgICAgICB9KVxuICAgICAgICByZWNvcmQgPSB7fVxuICAgICAgICBPYmplY3Qua2V5cyhuZXcgQXR0cmlidXRlUmVjb3JkKCkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJlY29yZFtrZXldID0gc2NvcGUuZGVmKHNjb3BlQXR0cmliLCAnLicsIGtleSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVtaXRCaW5kQXR0cmlidXRlKFxuICAgICAgICBlbnYubGluayhhdHRyaWJ1dGUpLCB0eXBlTGVuZ3RoKGF0dHJpYnV0ZS5pbmZvLnR5cGUpLCByZWNvcmQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRVbmlmb3JtcyAoZW52LCBzY29wZSwgYXJncywgdW5pZm9ybXMsIGZpbHRlcikge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsXG5cbiAgICB2YXIgaW5maXhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW2ldXG4gICAgICB2YXIgbmFtZSA9IHVuaWZvcm0ubmFtZVxuICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtLmluZm8udHlwZVxuICAgICAgdmFyIGFyZyA9IGFyZ3MudW5pZm9ybXNbbmFtZV1cbiAgICAgIHZhciBVTklGT1JNID0gZW52LmxpbmsodW5pZm9ybSlcbiAgICAgIHZhciBMT0NBVElPTiA9IFVOSUZPUk0gKyAnLmxvY2F0aW9uJ1xuXG4gICAgICB2YXIgVkFMVUVcbiAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIoYXJnKSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RhdGljKGFyZykpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWVcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgJ21pc3NpbmcgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgaWYgKHR5cGUgPT09IEdMX1NBTVBMRVJfMkQgfHwgdHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoKHR5cGUgPT09IEdMX1NBTVBMRVJfMkQgJiZcbiAgICAgICAgICAgICAgICAodmFsdWUuX3JlZ2xUeXBlID09PSAndGV4dHVyZTJkJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9yZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyJykpIHx8XG4gICAgICAgICAgICAgICh0eXBlID09PSBHTF9TQU1QTEVSX0NVQkUgJiZcbiAgICAgICAgICAgICAgICAodmFsdWUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXJDdWJlJykpKSxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSBmb3IgdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICB2YXIgVEVYX1ZBTFVFID0gZW52LmxpbmsodmFsdWUuX3RleHR1cmUgfHwgdmFsdWUuY29sb3JbMF0uX3RleHR1cmUpXG4gICAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtMWkoJywgTE9DQVRJT04sICcsJywgVEVYX1ZBTFVFICsgJy5iaW5kKCkpOycpXG4gICAgICAgICAgICBzY29wZS5leGl0KFRFWF9WQUxVRSwgJy51bmJpbmQoKTsnKVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlID09PSBHTF9GTE9BVF9NQVQyIHx8XG4gICAgICAgICAgICB0eXBlID09PSBHTF9GTE9BVF9NQVQzIHx8XG4gICAgICAgICAgICB0eXBlID09PSBHTF9GTE9BVF9NQVQ0KSB7XG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGlzQXJyYXlMaWtlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBtYXRyaXggZm9yIHVuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDIgJiYgdmFsdWUubGVuZ3RoID09PSA0KSB8fFxuICAgICAgICAgICAgICAgICh0eXBlID09PSBHTF9GTE9BVF9NQVQzICYmIHZhbHVlLmxlbmd0aCA9PT0gOSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfRkxPQVRfTUFUNCAmJiB2YWx1ZS5sZW5ndGggPT09IDE2KSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBsZW5ndGggZm9yIG1hdHJpeCB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB2YXIgTUFUX1ZBTFVFID0gZW52Lmdsb2JhbC5kZWYoJ25ldyBGbG9hdDMyQXJyYXkoWycgK1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWx1ZSkgKyAnXSknKVxuICAgICAgICAgICAgdmFyIGRpbSA9IDJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBHTF9GTE9BVF9NQVQzKSB7XG4gICAgICAgICAgICAgIGRpbSA9IDNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gR0xfRkxPQVRfTUFUNCkge1xuICAgICAgICAgICAgICBkaW0gPSA0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZShcbiAgICAgICAgICAgICAgR0wsICcudW5pZm9ybU1hdHJpeCcsIGRpbSwgJ2Z2KCcsXG4gICAgICAgICAgICAgIExPQ0FUSU9OLCAnLGZhbHNlLCcsIE1BVF9WQUxVRSwgJyk7JylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgR0xfRkxPQVQkODpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzFmJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMjpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzJmJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAzLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNmJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzRmJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTDpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnYm9vbGVhbicsICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcxaSdcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0lOVCQzOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdudW1iZXInLCAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMWknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcyaSdcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMyOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICczaSdcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDMsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0aSdcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0nLCBpbmZpeCwgJygnLCBMT0NBVElPTiwgJywnLFxuICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWx1ZSkgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgJyk7JylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBWQUxVRSA9IGFyZy5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIoU0NPUEVfREVDTCkpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIFZBTFVFID0gc2NvcGUuZGVmKHNoYXJlZC51bmlmb3JtcywgJ1snLCBzdHJpbmdTdG9yZS5pZChuYW1lKSwgJ10nKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gR0xfU0FNUExFUl8yRCkge1xuICAgICAgICBjaGVjayQxKCFBcnJheS5pc0FycmF5KFZBTFVFKSwgJ211c3Qgc3BlY2lmeSBhIHNjYWxhciBwcm9wIGZvciB0ZXh0dXJlcycpXG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyYmJywgVkFMVUUsICcuX3JlZ2xUeXBlPT09XCJmcmFtZWJ1ZmZlclwiKXsnLFxuICAgICAgICAgIFZBTFVFLCAnPScsIFZBTFVFLCAnLmNvbG9yWzBdOycsXG4gICAgICAgICAgJ30nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9TQU1QTEVSX0NVQkUpIHtcbiAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IHNwZWNpZnkgYSBzY2FsYXIgcHJvcCBmb3IgY3ViZSBtYXBzJylcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcsIFZBTFVFLCAnJiYnLCBWQUxVRSwgJy5fcmVnbFR5cGU9PT1cImZyYW1lYnVmZmVyQ3ViZVwiKXsnLFxuICAgICAgICAgIFZBTFVFLCAnPScsIFZBTFVFLCAnLmNvbG9yWzBdOycsXG4gICAgICAgICAgJ30nKVxuICAgICAgfVxuXG4gICAgICAvLyBwZXJmb3JtIHR5cGUgdmFsaWRhdGlvblxuICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGVtaXRDaGVjayAocHJlZCwgbWVzc2FnZSkge1xuICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsIHByZWQsXG4gICAgICAgICAgICAnYmFkIGRhdGEgb3IgbWlzc2luZyBmb3IgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiLiAgJyArIG1lc3NhZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1R5cGUgKHR5cGUpIHtcbiAgICAgICAgICBjaGVjayQxKCFBcnJheS5pc0FycmF5KFZBTFVFKSwgJ211c3Qgbm90IHNwZWNpZnkgYW4gYXJyYXkgdHlwZSBmb3IgdW5pZm9ybScpXG4gICAgICAgICAgZW1pdENoZWNrKFxuICAgICAgICAgICAgJ3R5cGVvZiAnICsgVkFMVUUgKyAnPT09XCInICsgdHlwZSArICdcIicsXG4gICAgICAgICAgICAnaW52YWxpZCB0eXBlLCBleHBlY3RlZCAnICsgdHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVmVjdG9yIChuLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoVkFMVUUpKSB7XG4gICAgICAgICAgICBjaGVjayQxKFZBTFVFLmxlbmd0aCA9PT0gbiwgJ211c3QgaGF2ZSBsZW5ndGggJyArIG4pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICAgc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgVkFMVUUgKyAnKSYmJyArIFZBTFVFICsgJy5sZW5ndGg9PT0nICsgbixcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVjdG9yLCBzaG91bGQgaGF2ZSBsZW5ndGggJyArIG4sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVGV4dHVyZSAodGFyZ2V0KSB7XG4gICAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IG5vdCBzcGVjaWZ5IGEgdmFsdWUgdHlwZScpXG4gICAgICAgICAgZW1pdENoZWNrKFxuICAgICAgICAgICAgJ3R5cGVvZiAnICsgVkFMVUUgKyAnPT09XCJmdW5jdGlvblwiJiYnICtcbiAgICAgICAgICAgIFZBTFVFICsgJy5fcmVnbFR5cGU9PT1cInRleHR1cmUnICtcbiAgICAgICAgICAgICh0YXJnZXQgPT09IEdMX1RFWFRVUkVfMkQkMyA/ICcyZCcgOiAnQ3ViZScpICsgJ1wiJyxcbiAgICAgICAgICAgICdpbnZhbGlkIHRleHR1cmUgdHlwZScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDIsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfSU5UX1ZFQzQ6XG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVCQ4OlxuICAgICAgICAgICAgY2hlY2tUeXBlKCdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDQsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0JPT0w6XG4gICAgICAgICAgICBjaGVja1R5cGUoJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMjpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDIsICdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigzLCAnYm9vbGVhbicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDI6XG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoOSwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUNDpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDE2LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9TQU1QTEVSXzJEOlxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9TQU1QTEVSX0NVQkU6XG4gICAgICAgICAgICBjaGVja1RleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCQyKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdmFyIHVucm9sbCA9IDFcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEdMX1NBTVBMRVJfMkQ6XG4gICAgICAgIGNhc2UgR0xfU0FNUExFUl9DVUJFOlxuICAgICAgICAgIHZhciBURVggPSBzY29wZS5kZWYoVkFMVUUsICcuX3RleHR1cmUnKVxuICAgICAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0xaSgnLCBMT0NBVElPTiwgJywnLCBURVgsICcuYmluZCgpKTsnKVxuICAgICAgICAgIHNjb3BlLmV4aXQoVEVYLCAnLnVuYmluZCgpOycpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIEdMX0lOVCQzOlxuICAgICAgICBjYXNlIEdMX0JPT0w6XG4gICAgICAgICAgaW5maXggPSAnMWknXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0lOVF9WRUMyOlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMjpcbiAgICAgICAgICBpbmZpeCA9ICcyaSdcbiAgICAgICAgICB1bnJvbGwgPSAyXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMzpcbiAgICAgICAgICBpbmZpeCA9ICczaSdcbiAgICAgICAgICB1bnJvbGwgPSAzXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICBpbmZpeCA9ICc0aSdcbiAgICAgICAgICB1bnJvbGwgPSA0XG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XG4gICAgICAgICAgaW5maXggPSAnMWYnXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgICAgaW5maXggPSAnMmYnXG4gICAgICAgICAgdW5yb2xsID0gMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMzOlxuICAgICAgICAgIGluZml4ID0gJzNmJ1xuICAgICAgICAgIHVucm9sbCA9IDNcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcbiAgICAgICAgICBpbmZpeCA9ICc0ZidcbiAgICAgICAgICB1bnJvbGwgPSA0XG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDI6XG4gICAgICAgICAgaW5maXggPSAnTWF0cml4MmZ2J1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQzOlxuICAgICAgICAgIGluZml4ID0gJ01hdHJpeDNmdidcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUNDpcbiAgICAgICAgICBpbmZpeCA9ICdNYXRyaXg0ZnYnXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgc2NvcGUoR0wsICcudW5pZm9ybScsIGluZml4LCAnKCcsIExPQ0FUSU9OLCAnLCcpXG4gICAgICBpZiAoaW5maXguY2hhckF0KDApID09PSAnTScpIHtcbiAgICAgICAgdmFyIG1hdFNpemUgPSBNYXRoLnBvdyh0eXBlIC0gR0xfRkxPQVRfTUFUMiArIDIsIDIpXG4gICAgICAgIHZhciBTVE9SQUdFID0gZW52Lmdsb2JhbC5kZWYoJ25ldyBGbG9hdDMyQXJyYXkoJywgbWF0U2l6ZSwgJyknKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShWQUxVRSkpIHtcbiAgICAgICAgICBzY29wZShcbiAgICAgICAgICAgICdmYWxzZSwoJyxcbiAgICAgICAgICAgIGxvb3AobWF0U2l6ZSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNUT1JBR0UgKyAnWycgKyBpICsgJ109JyArIFZBTFVFW2ldXG4gICAgICAgICAgICB9KSwgJywnLCBTVE9SQUdFLCAnKScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnZmFsc2UsKEFycmF5LmlzQXJyYXkoJywgVkFMVUUsICcpfHwnLCBWQUxVRSwgJyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk/JywgVkFMVUUsICc6KCcsXG4gICAgICAgICAgICBsb29wKG1hdFNpemUsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVE9SQUdFICsgJ1snICsgaSArICddPScgKyBWQUxVRSArICdbJyArIGkgKyAnXSdcbiAgICAgICAgICAgIH0pLCAnLCcsIFNUT1JBR0UsICcpJylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bnJvbGwgPiAxKSB7XG4gICAgICAgIHNjb3BlKGxvb3AodW5yb2xsLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KFZBTFVFKSA/IFZBTFVFW2ldIDogVkFMVUUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgIH0pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICd1bmlmb3JtIHZhbHVlIG11c3Qgbm90IGJlIGFuIGFycmF5JylcbiAgICAgICAgc2NvcGUoVkFMVUUpXG4gICAgICB9XG4gICAgICBzY29wZSgnKTsnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXREcmF3IChlbnYsIG91dGVyLCBpbm5lciwgYXJncykge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsXG4gICAgdmFyIERSQVdfU1RBVEUgPSBzaGFyZWQuZHJhd1xuXG4gICAgdmFyIGRyYXdPcHRpb25zID0gYXJncy5kcmF3XG5cbiAgICBmdW5jdGlvbiBlbWl0RWxlbWVudHMgKCkge1xuICAgICAgdmFyIGRlZm4gPSBkcmF3T3B0aW9ucy5lbGVtZW50c1xuICAgICAgdmFyIEVMRU1FTlRTXG4gICAgICB2YXIgc2NvcGUgPSBvdXRlclxuICAgICAgaWYgKGRlZm4pIHtcbiAgICAgICAgaWYgKChkZWZuLmNvbnRleHREZXAgJiYgYXJncy5jb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwKSB7XG4gICAgICAgICAgc2NvcGUgPSBpbm5lclxuICAgICAgICB9XG4gICAgICAgIEVMRU1FTlRTID0gZGVmbi5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEVMRU1FTlRTID0gc2NvcGUuZGVmKERSQVdfU1RBVEUsICcuJywgU19FTEVNRU5UUylcbiAgICAgIH1cbiAgICAgIGlmIChFTEVNRU5UUykge1xuICAgICAgICBzY29wZShcbiAgICAgICAgICAnaWYoJyArIEVMRU1FTlRTICsgJyknICtcbiAgICAgICAgICBHTCArICcuYmluZEJ1ZmZlcignICsgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIkMSArICcsJyArIEVMRU1FTlRTICsgJy5idWZmZXIuYnVmZmVyKTsnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEVMRU1FTlRTXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdENvdW50ICgpIHtcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuY291bnRcbiAgICAgIHZhciBDT1VOVFxuICAgICAgdmFyIHNjb3BlID0gb3V0ZXJcbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIGlmICgoZGVmbi5jb250ZXh0RGVwICYmIGFyZ3MuY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcCkge1xuICAgICAgICAgIHNjb3BlID0gaW5uZXJcbiAgICAgICAgfVxuICAgICAgICBDT1VOVCA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkZWZuLk1JU1NJTkcpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQob3V0ZXIsICdmYWxzZScsICdtaXNzaW5nIHZlcnRleCBjb3VudCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZuLkRZTkFNSUMpIHtcbiAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsIENPVU5UICsgJz49MCcsICdtaXNzaW5nIHZlcnRleCBjb3VudCcpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ09VTlQgPSBzY29wZS5kZWYoRFJBV19TVEFURSwgJy4nLCBTX0NPVU5UKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBDT1VOVCArICc+PTAnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIENPVU5UXG4gICAgfVxuXG4gICAgdmFyIEVMRU1FTlRTID0gZW1pdEVsZW1lbnRzKClcbiAgICBmdW5jdGlvbiBlbWl0VmFsdWUgKG5hbWUpIHtcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnNbbmFtZV1cbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIGlmICgoZGVmbi5jb250ZXh0RGVwICYmIGFyZ3MuY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcCkge1xuICAgICAgICAgIHJldHVybiBkZWZuLmFwcGVuZChlbnYsIGlubmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZuLmFwcGVuZChlbnYsIG91dGVyKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3V0ZXIuZGVmKERSQVdfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUFJJTUlUSVZFID0gZW1pdFZhbHVlKFNfUFJJTUlUSVZFKVxuICAgIHZhciBPRkZTRVQgPSBlbWl0VmFsdWUoU19PRkZTRVQpXG5cbiAgICB2YXIgQ09VTlQgPSBlbWl0Q291bnQoKVxuICAgIGlmICh0eXBlb2YgQ09VTlQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoQ09VTlQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVyKCdpZignLCBDT1VOVCwgJyl7JylcbiAgICAgIGlubmVyLmV4aXQoJ30nKVxuICAgIH1cblxuICAgIHZhciBJTlNUQU5DRVMsIEVYVF9JTlNUQU5DSU5HXG4gICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgIElOU1RBTkNFUyA9IGVtaXRWYWx1ZShTX0lOU1RBTkNFUylcbiAgICAgIEVYVF9JTlNUQU5DSU5HID0gZW52Lmluc3RhbmNpbmdcbiAgICB9XG5cbiAgICB2YXIgRUxFTUVOVF9UWVBFID0gRUxFTUVOVFMgKyAnLnR5cGUnXG5cbiAgICB2YXIgZWxlbWVudHNTdGF0aWMgPSBkcmF3T3B0aW9ucy5lbGVtZW50cyAmJiBpc1N0YXRpYyhkcmF3T3B0aW9ucy5lbGVtZW50cylcblxuICAgIGZ1bmN0aW9uIGVtaXRJbnN0YW5jaW5nICgpIHtcbiAgICAgIGZ1bmN0aW9uIGRyYXdFbGVtZW50cyAoKSB7XG4gICAgICAgIGlubmVyKEVYVF9JTlNUQU5DSU5HLCAnLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCcsIFtcbiAgICAgICAgICBQUklNSVRJVkUsXG4gICAgICAgICAgQ09VTlQsXG4gICAgICAgICAgRUxFTUVOVF9UWVBFLFxuICAgICAgICAgIE9GRlNFVCArICc8PCgoJyArIEVMRU1FTlRfVFlQRSArICctJyArIEdMX1VOU0lHTkVEX0JZVEUkOCArICcpPj4xKScsXG4gICAgICAgICAgSU5TVEFOQ0VTXG4gICAgICAgIF0sICcpOycpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYXdBcnJheXMgKCkge1xuICAgICAgICBpbm5lcihFWFRfSU5TVEFOQ0lORywgJy5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoJyxcbiAgICAgICAgICBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5ULCBJTlNUQU5DRVNdLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBpZiAoRUxFTUVOVFMpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50c1N0YXRpYykge1xuICAgICAgICAgIGlubmVyKCdpZignLCBFTEVNRU5UUywgJyl7JylcbiAgICAgICAgICBkcmF3RWxlbWVudHMoKVxuICAgICAgICAgIGlubmVyKCd9ZWxzZXsnKVxuICAgICAgICAgIGRyYXdBcnJheXMoKVxuICAgICAgICAgIGlubmVyKCd9JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmF3RWxlbWVudHMoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmF3QXJyYXlzKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0UmVndWxhciAoKSB7XG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMgKCkge1xuICAgICAgICBpbm5lcihHTCArICcuZHJhd0VsZW1lbnRzKCcgKyBbXG4gICAgICAgICAgUFJJTUlUSVZFLFxuICAgICAgICAgIENPVU5ULFxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcbiAgICAgICAgICBPRkZTRVQgKyAnPDwoKCcgKyBFTEVNRU5UX1RZUEUgKyAnLScgKyBHTF9VTlNJR05FRF9CWVRFJDggKyAnKT4+MSknXG4gICAgICAgIF0gKyAnKTsnKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3QXJyYXlzICgpIHtcbiAgICAgICAgaW5uZXIoR0wgKyAnLmRyYXdBcnJheXMoJyArIFtQUklNSVRJVkUsIE9GRlNFVCwgQ09VTlRdICsgJyk7JylcbiAgICAgIH1cblxuICAgICAgaWYgKEVMRU1FTlRTKSB7XG4gICAgICAgIGlmICghZWxlbWVudHNTdGF0aWMpIHtcbiAgICAgICAgICBpbm5lcignaWYoJywgRUxFTUVOVFMsICcpeycpXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgICBpbm5lcignfWVsc2V7JylcbiAgICAgICAgICBkcmF3QXJyYXlzKClcbiAgICAgICAgICBpbm5lcignfScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dEluc3RhbmNpbmcgJiYgKHR5cGVvZiBJTlNUQU5DRVMgIT09ICdudW1iZXInIHx8IElOU1RBTkNFUyA+PSAwKSkge1xuICAgICAgaWYgKHR5cGVvZiBJTlNUQU5DRVMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlubmVyKCdpZignLCBJTlNUQU5DRVMsICc+MCl7JylcbiAgICAgICAgZW1pdEluc3RhbmNpbmcoKVxuICAgICAgICBpbm5lcignfWVsc2UgaWYoJywgSU5TVEFOQ0VTLCAnPDApeycpXG4gICAgICAgIGVtaXRSZWd1bGFyKClcbiAgICAgICAgaW5uZXIoJ30nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdEluc3RhbmNpbmcoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0UmVndWxhcigpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQm9keSAoZW1pdEJvZHksIHBhcmVudEVudiwgYXJncywgcHJvZ3JhbSwgY291bnQpIHtcbiAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KClcbiAgICB2YXIgc2NvcGUgPSBlbnYucHJvYygnYm9keScsIGNvdW50KVxuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgZW52LmNvbW1hbmRTdHIgPSBwYXJlbnRFbnYuY29tbWFuZFN0clxuICAgICAgZW52LmNvbW1hbmQgPSBlbnYubGluayhwYXJlbnRFbnYuY29tbWFuZFN0cilcbiAgICB9KVxuICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICBlbnYuaW5zdGFuY2luZyA9IHNjb3BlLmRlZihcbiAgICAgICAgZW52LnNoYXJlZC5leHRlbnNpb25zLCAnLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMnKVxuICAgIH1cbiAgICBlbWl0Qm9keShlbnYsIHNjb3BlLCBhcmdzLCBwcm9ncmFtKVxuICAgIHJldHVybiBlbnYuY29tcGlsZSgpLmJvZHlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRFJBVyBQUk9DXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW1pdERyYXdCb2R5IChlbnYsIGRyYXcsIGFyZ3MsIHByb2dyYW0pIHtcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgZHJhdylcbiAgICBpZiAoYXJncy51c2VWQU8pIHtcbiAgICAgIGlmIChhcmdzLmRyYXdWQU8pIHtcbiAgICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgYXJncy5kcmF3VkFPLmFwcGVuZChlbnYsIGRyYXcpLCAnKTsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgZW52LnNoYXJlZC52YW8sICcudGFyZ2V0VkFPKTsnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3KGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgZW1pdEF0dHJpYnV0ZXMoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgfVxuICAgIGVtaXRVbmlmb3JtcyhlbnYsIGRyYXcsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgICBlbWl0RHJhdyhlbnYsIGRyYXcsIGRyYXcsIGFyZ3MpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0RHJhd1Byb2MgKGVudiwgYXJncykge1xuICAgIHZhciBkcmF3ID0gZW52LnByb2MoJ2RyYXcnLCAxKVxuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGRyYXcpXG5cbiAgICBlbWl0Q29udGV4dChlbnYsIGRyYXcsIGFyZ3MuY29udGV4dClcbiAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgZHJhdywgYXJncy5mcmFtZWJ1ZmZlcilcblxuICAgIGVtaXRQb2xsU3RhdGUoZW52LCBkcmF3LCBhcmdzKVxuICAgIGVtaXRTZXRPcHRpb25zKGVudiwgZHJhdywgYXJncy5zdGF0ZSlcblxuICAgIGVtaXRQcm9maWxlKGVudiwgZHJhdywgYXJncywgZmFsc2UsIHRydWUpXG5cbiAgICB2YXIgcHJvZ3JhbSA9IGFyZ3Muc2hhZGVyLnByb2dWYXIuYXBwZW5kKGVudiwgZHJhdylcbiAgICBkcmF3KGVudi5zaGFyZWQuZ2wsICcudXNlUHJvZ3JhbSgnLCBwcm9ncmFtLCAnLnByb2dyYW0pOycpXG5cbiAgICBpZiAoYXJncy5zaGFkZXIucHJvZ3JhbSkge1xuICAgICAgZW1pdERyYXdCb2R5KGVudiwgZHJhdywgYXJncywgYXJncy5zaGFkZXIucHJvZ3JhbSlcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8obnVsbCk7JylcbiAgICAgIHZhciBkcmF3Q2FjaGUgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgICAgdmFyIFBST0dfSUQgPSBkcmF3LmRlZihwcm9ncmFtLCAnLmlkJylcbiAgICAgIHZhciBDQUNIRURfUFJPQyA9IGRyYXcuZGVmKGRyYXdDYWNoZSwgJ1snLCBQUk9HX0lELCAnXScpXG4gICAgICBkcmF3KFxuICAgICAgICBlbnYuY29uZChDQUNIRURfUFJPQylcbiAgICAgICAgICAudGhlbihDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTApOycpXG4gICAgICAgICAgLmVsc2UoXG4gICAgICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgICAgIGVudi5saW5rKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb2R5KGVtaXREcmF3Qm9keSwgZW52LCBhcmdzLCBwcm9ncmFtLCAxKVxuICAgICAgICAgICAgfSksICcoJywgcHJvZ3JhbSwgJyk7JyxcbiAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCk7JykpXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGRyYXcoZW52LnNoYXJlZC5jdXJyZW50LCAnLmRpcnR5PXRydWU7JylcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEJBVENIIFBST0NcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIGVtaXRCYXRjaER5bmFtaWNTaGFkZXJCb2R5IChlbnYsIHNjb3BlLCBhcmdzLCBwcm9ncmFtKSB7XG4gICAgZW52LmJhdGNoSWQgPSAnYTEnXG5cbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpXG5cbiAgICBmdW5jdGlvbiBhbGwgKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBlbWl0QXR0cmlidXRlcyhlbnYsIHNjb3BlLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGFsbClcbiAgICBlbWl0VW5pZm9ybXMoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbS51bmlmb3JtcywgYWxsKVxuICAgIGVtaXREcmF3KGVudiwgc2NvcGUsIHNjb3BlLCBhcmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEJhdGNoQm9keSAoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSkge1xuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBzY29wZSlcblxuICAgIHZhciBjb250ZXh0RHluYW1pYyA9IGFyZ3MuY29udGV4dERlcFxuXG4gICAgdmFyIEJBVENIX0lEID0gc2NvcGUuZGVmKClcbiAgICB2YXIgUFJPUF9MSVNUID0gJ2EwJ1xuICAgIHZhciBOVU1fUFJPUFMgPSAnYTEnXG4gICAgdmFyIFBST1BTID0gc2NvcGUuZGVmKClcbiAgICBlbnYuc2hhcmVkLnByb3BzID0gUFJPUFNcbiAgICBlbnYuYmF0Y2hJZCA9IEJBVENIX0lEXG5cbiAgICB2YXIgb3V0ZXIgPSBlbnYuc2NvcGUoKVxuICAgIHZhciBpbm5lciA9IGVudi5zY29wZSgpXG5cbiAgICBzY29wZShcbiAgICAgIG91dGVyLmVudHJ5LFxuICAgICAgJ2ZvcignLCBCQVRDSF9JRCwgJz0wOycsIEJBVENIX0lELCAnPCcsIE5VTV9QUk9QUywgJzsrKycsIEJBVENIX0lELCAnKXsnLFxuICAgICAgUFJPUFMsICc9JywgUFJPUF9MSVNULCAnWycsIEJBVENIX0lELCAnXTsnLFxuICAgICAgaW5uZXIsXG4gICAgICAnfScsXG4gICAgICBvdXRlci5leGl0KVxuXG4gICAgZnVuY3Rpb24gaXNJbm5lckRlZm4gKGRlZm4pIHtcbiAgICAgIHJldHVybiAoKGRlZm4uY29udGV4dERlcCAmJiBjb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT3V0ZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gIWlzSW5uZXJEZWZuKGRlZm4pXG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubmVlZHNDb250ZXh0KSB7XG4gICAgICBlbWl0Q29udGV4dChlbnYsIGlubmVyLCBhcmdzLmNvbnRleHQpXG4gICAgfVxuICAgIGlmIChhcmdzLm5lZWRzRnJhbWVidWZmZXIpIHtcbiAgICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCBpbm5lciwgYXJncy5mcmFtZWJ1ZmZlcilcbiAgICB9XG4gICAgZW1pdFNldE9wdGlvbnMoZW52LCBpbm5lciwgYXJncy5zdGF0ZSwgaXNJbm5lckRlZm4pXG5cbiAgICBpZiAoYXJncy5wcm9maWxlICYmIGlzSW5uZXJEZWZuKGFyZ3MucHJvZmlsZSkpIHtcbiAgICAgIGVtaXRQcm9maWxlKGVudiwgaW5uZXIsIGFyZ3MsIGZhbHNlLCB0cnVlKVxuICAgIH1cblxuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgdmFyIHByb2dDYWNoZSA9IGVudi5nbG9iYWwuZGVmKCd7fScpXG4gICAgICB2YXIgUFJPR1JBTSA9IGFyZ3Muc2hhZGVyLnByb2dWYXIuYXBwZW5kKGVudiwgaW5uZXIpXG4gICAgICB2YXIgUFJPR19JRCA9IGlubmVyLmRlZihQUk9HUkFNLCAnLmlkJylcbiAgICAgIHZhciBDQUNIRURfUFJPQyA9IGlubmVyLmRlZihwcm9nQ2FjaGUsICdbJywgUFJPR19JRCwgJ10nKVxuICAgICAgaW5uZXIoXG4gICAgICAgIGVudi5zaGFyZWQuZ2wsICcudXNlUHJvZ3JhbSgnLCBQUk9HUkFNLCAnLnByb2dyYW0pOycsXG4gICAgICAgICdpZighJywgQ0FDSEVEX1BST0MsICcpeycsXG4gICAgICAgIENBQ0hFRF9QUk9DLCAnPScsIHByb2dDYWNoZSwgJ1snLCBQUk9HX0lELCAnXT0nLFxuICAgICAgICBlbnYubGluayhmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVCb2R5KFxuICAgICAgICAgICAgZW1pdEJhdGNoRHluYW1pY1NoYWRlckJvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMilcbiAgICAgICAgfSksICcoJywgUFJPR1JBTSwgJyk7fScsXG4gICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMFsnLCBCQVRDSF9JRCwgJ10sJywgQkFUQ0hfSUQsICcpOycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmdzLnVzZVZBTykge1xuICAgICAgICBpZiAoYXJncy5kcmF3VkFPKSB7XG4gICAgICAgICAgaWYgKGlzSW5uZXJEZWZuKGFyZ3MuZHJhd1ZBTykpIHtcbiAgICAgICAgICAgIC8vIHZhbyBpcyBhIHByb3BcbiAgICAgICAgICAgIGlubmVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTygnLCBhcmdzLmRyYXdWQU8uYXBwZW5kKGVudiwgaW5uZXIpLCAnKTsnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2YW8gaXMgaW52YXJpYW50XG4gICAgICAgICAgICBvdXRlcihlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgYXJncy5kcmF3VkFPLmFwcGVuZChlbnYsIG91dGVyKSwgJyk7JylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHZhbyBiaW5kaW5nXG4gICAgICAgICAgb3V0ZXIoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ZXIoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKG51bGwpOycpXG4gICAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0uYXR0cmlidXRlcywgaXNPdXRlckRlZm4pXG4gICAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgaW5uZXIsIGFyZ3MsIHByb2dyYW0uYXR0cmlidXRlcywgaXNJbm5lckRlZm4pXG4gICAgICB9XG4gICAgICBlbWl0VW5pZm9ybXMoZW52LCBvdXRlciwgYXJncywgcHJvZ3JhbS51bmlmb3JtcywgaXNPdXRlckRlZm4pXG4gICAgICBlbWl0VW5pZm9ybXMoZW52LCBpbm5lciwgYXJncywgcHJvZ3JhbS51bmlmb3JtcywgaXNJbm5lckRlZm4pXG4gICAgICBlbWl0RHJhdyhlbnYsIG91dGVyLCBpbm5lciwgYXJncylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QmF0Y2hQcm9jIChlbnYsIGFyZ3MpIHtcbiAgICB2YXIgYmF0Y2ggPSBlbnYucHJvYygnYmF0Y2gnLCAyKVxuICAgIGVudi5iYXRjaElkID0gJzAnXG5cbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgYmF0Y2gpXG5cbiAgICAvLyBDaGVjayBpZiBhbnkgY29udGV4dCB2YXJpYWJsZXMgZGVwZW5kIG9uIHByb3BzXG4gICAgdmFyIGNvbnRleHREeW5hbWljID0gZmFsc2VcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gdHJ1ZVxuICAgIE9iamVjdC5rZXlzKGFyZ3MuY29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgY29udGV4dER5bmFtaWMgPSBjb250ZXh0RHluYW1pYyB8fCBhcmdzLmNvbnRleHRbbmFtZV0ucHJvcERlcFxuICAgIH0pXG4gICAgaWYgKCFjb250ZXh0RHluYW1pYykge1xuICAgICAgZW1pdENvbnRleHQoZW52LCBiYXRjaCwgYXJncy5jb250ZXh0KVxuICAgICAgbmVlZHNDb250ZXh0ID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBmcmFtZWJ1ZmZlciBzdGF0ZSBhZmZlY3RzIGZyYW1lYnVmZmVyV2lkdGgvaGVpZ2h0IGNvbnRleHQgdmFyc1xuICAgIHZhciBmcmFtZWJ1ZmZlciA9IGFyZ3MuZnJhbWVidWZmZXJcbiAgICB2YXIgbmVlZHNGcmFtZWJ1ZmZlciA9IGZhbHNlXG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBpZiAoZnJhbWVidWZmZXIucHJvcERlcCkge1xuICAgICAgICBjb250ZXh0RHluYW1pYyA9IG5lZWRzRnJhbWVidWZmZXIgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGZyYW1lYnVmZmVyLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHtcbiAgICAgICAgbmVlZHNGcmFtZWJ1ZmZlciA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICghbmVlZHNGcmFtZWJ1ZmZlcikge1xuICAgICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgYmF0Y2gsIGZyYW1lYnVmZmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgYmF0Y2gsIG51bGwpXG4gICAgfVxuXG4gICAgLy8gdmlld3BvcnQgaXMgd2VpcmQgYmVjYXVzZSBpdCBjYW4gYWZmZWN0IGNvbnRleHQgdmFyc1xuICAgIGlmIChhcmdzLnN0YXRlLnZpZXdwb3J0ICYmIGFyZ3Muc3RhdGUudmlld3BvcnQucHJvcERlcCkge1xuICAgICAgY29udGV4dER5bmFtaWMgPSB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbm5lckRlZm4gKGRlZm4pIHtcbiAgICAgIHJldHVybiAoZGVmbi5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXBcbiAgICB9XG5cbiAgICAvLyBzZXQgd2ViZ2wgb3B0aW9uc1xuICAgIGVtaXRQb2xsU3RhdGUoZW52LCBiYXRjaCwgYXJncylcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGJhdGNoLCBhcmdzLnN0YXRlLCBmdW5jdGlvbiAoZGVmbikge1xuICAgICAgcmV0dXJuICFpc0lubmVyRGVmbihkZWZuKVxuICAgIH0pXG5cbiAgICBpZiAoIWFyZ3MucHJvZmlsZSB8fCAhaXNJbm5lckRlZm4oYXJncy5wcm9maWxlKSkge1xuICAgICAgZW1pdFByb2ZpbGUoZW52LCBiYXRjaCwgYXJncywgZmFsc2UsICdhMScpXG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGVzZSB2YWx1ZXMgdG8gYXJncyBzbyB0aGF0IHRoZSBiYXRjaCBib2R5IHJvdXRpbmUgY2FuIHVzZSB0aGVtXG4gICAgYXJncy5jb250ZXh0RGVwID0gY29udGV4dER5bmFtaWNcbiAgICBhcmdzLm5lZWRzQ29udGV4dCA9IG5lZWRzQ29udGV4dFxuICAgIGFyZ3MubmVlZHNGcmFtZWJ1ZmZlciA9IG5lZWRzRnJhbWVidWZmZXJcblxuICAgIC8vIGRldGVybWluZSBpZiBzaGFkZXIgaXMgZHluYW1pY1xuICAgIHZhciBwcm9nRGVmbiA9IGFyZ3Muc2hhZGVyLnByb2dWYXJcbiAgICBpZiAoKHByb2dEZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IHByb2dEZWZuLnByb3BEZXApIHtcbiAgICAgIGVtaXRCYXRjaEJvZHkoXG4gICAgICAgIGVudixcbiAgICAgICAgYmF0Y2gsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBQUk9HUkFNID0gcHJvZ0RlZm4uYXBwZW5kKGVudiwgYmF0Y2gpXG4gICAgICBiYXRjaChlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgUFJPR1JBTSwgJy5wcm9ncmFtKTsnKVxuICAgICAgaWYgKGFyZ3Muc2hhZGVyLnByb2dyYW0pIHtcbiAgICAgICAgZW1pdEJhdGNoQm9keShcbiAgICAgICAgICBlbnYsXG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBhcmdzLnNoYWRlci5wcm9ncmFtKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2goZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKG51bGwpOycpXG4gICAgICAgIHZhciBiYXRjaENhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9JylcbiAgICAgICAgdmFyIFBST0dfSUQgPSBiYXRjaC5kZWYoUFJPR1JBTSwgJy5pZCcpXG4gICAgICAgIHZhciBDQUNIRURfUFJPQyA9IGJhdGNoLmRlZihiYXRjaENhY2hlLCAnWycsIFBST0dfSUQsICddJylcbiAgICAgICAgYmF0Y2goXG4gICAgICAgICAgZW52LmNvbmQoQ0FDSEVEX1BST0MpXG4gICAgICAgICAgICAudGhlbihDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTAsYTEpOycpXG4gICAgICAgICAgICAuZWxzZShcbiAgICAgICAgICAgICAgQ0FDSEVEX1BST0MsICc9JywgYmF0Y2hDYWNoZSwgJ1snLCBQUk9HX0lELCAnXT0nLFxuICAgICAgICAgICAgICBlbnYubGluayhmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb2R5KGVtaXRCYXRjaEJvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMilcbiAgICAgICAgICAgICAgfSksICcoJywgUFJPR1JBTSwgJyk7JyxcbiAgICAgICAgICAgICAgQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwLGExKTsnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgYmF0Y2goZW52LnNoYXJlZC5jdXJyZW50LCAnLmRpcnR5PXRydWU7JylcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNDT1BFIENPTU1BTkRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBlbWl0U2NvcGVQcm9jIChlbnYsIGFyZ3MpIHtcbiAgICB2YXIgc2NvcGUgPSBlbnYucHJvYygnc2NvcGUnLCAzKVxuICAgIGVudi5iYXRjaElkID0gJ2EyJ1xuXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICB2YXIgQ1VSUkVOVF9TVEFURSA9IHNoYXJlZC5jdXJyZW50XG5cbiAgICBlbWl0Q29udGV4dChlbnYsIHNjb3BlLCBhcmdzLmNvbnRleHQpXG5cbiAgICBpZiAoYXJncy5mcmFtZWJ1ZmZlcikge1xuICAgICAgYXJncy5mcmFtZWJ1ZmZlci5hcHBlbmQoZW52LCBzY29wZSlcbiAgICB9XG5cbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBkZWZuID0gYXJncy5zdGF0ZVtuYW1lXVxuICAgICAgdmFyIHZhbHVlID0gZGVmbi5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgIHNjb3BlLnNldChlbnYubmV4dFtuYW1lXSwgJ1snICsgaSArICddJywgdilcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlLnNldChzaGFyZWQubmV4dCwgJy4nICsgbmFtZSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGVtaXRQcm9maWxlKGVudiwgc2NvcGUsIGFyZ3MsIHRydWUsIHRydWUpXG5cbiAgICA7W1NfRUxFTUVOVFMsIFNfT0ZGU0VULCBTX0NPVU5ULCBTX0lOU1RBTkNFUywgU19QUklNSVRJVkVdLmZvckVhY2goXG4gICAgICBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIHZhciB2YXJpYWJsZSA9IGFyZ3MuZHJhd1tvcHRdXG4gICAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLmRyYXcsICcuJyArIG9wdCwgJycgKyB2YXJpYWJsZS5hcHBlbmQoZW52LCBzY29wZSkpXG4gICAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMoYXJncy51bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAob3B0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzLnVuaWZvcm1zW29wdF0uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSAnWycgKyB2YWx1ZS5qb2luKCkgKyAnXSdcbiAgICAgIH1cbiAgICAgIHNjb3BlLnNldChcbiAgICAgICAgc2hhcmVkLnVuaWZvcm1zLFxuICAgICAgICAnWycgKyBzdHJpbmdTdG9yZS5pZChvcHQpICsgJ10nLFxuICAgICAgICB2YWx1ZSlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMoYXJncy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gYXJncy5hdHRyaWJ1dGVzW25hbWVdLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgdmFyIHNjb3BlQXR0cmliID0gZW52LnNjb3BlQXR0cmliKG5hbWUpXG4gICAgICBPYmplY3Qua2V5cyhuZXcgQXR0cmlidXRlUmVjb3JkKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgc2NvcGUuc2V0KHNjb3BlQXR0cmliLCAnLicgKyBwcm9wLCByZWNvcmRbcHJvcF0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpZiAoYXJncy5zY29wZVZBTykge1xuICAgICAgc2NvcGUuc2V0KHNoYXJlZC52YW8sICcudGFyZ2V0VkFPJywgYXJncy5zY29wZVZBTy5hcHBlbmQoZW52LCBzY29wZSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZVNoYWRlciAobmFtZSkge1xuICAgICAgdmFyIHNoYWRlciA9IGFyZ3Muc2hhZGVyW25hbWVdXG4gICAgICBpZiAoc2hhZGVyKSB7XG4gICAgICAgIHNjb3BlLnNldChzaGFyZWQuc2hhZGVyLCAnLicgKyBuYW1lLCBzaGFkZXIuYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgICAgfVxuICAgIH1cbiAgICBzYXZlU2hhZGVyKFNfVkVSVClcbiAgICBzYXZlU2hhZGVyKFNfRlJBRylcblxuICAgIGlmIChPYmplY3Qua2V5cyhhcmdzLnN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICBzY29wZShDVVJSRU5UX1NUQVRFLCAnLmRpcnR5PXRydWU7JylcbiAgICAgIHNjb3BlLmV4aXQoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuXG4gICAgc2NvcGUoJ2ExKCcsIGVudi5zaGFyZWQuY29udGV4dCwgJyxhMCwnLCBlbnYuYmF0Y2hJZCwgJyk7JylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRHluYW1pY09iamVjdCAob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8IGlzQXJyYXlMaWtlKG9iamVjdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKG9iamVjdFtwcm9wc1tpXV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gc3BsYXRPYmplY3QgKGVudiwgb3B0aW9ucywgbmFtZSkge1xuICAgIHZhciBvYmplY3QgPSBvcHRpb25zLnN0YXRpY1tuYW1lXVxuICAgIGlmICghb2JqZWN0IHx8ICFpc0R5bmFtaWNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGdsb2JhbHMgPSBlbnYuZ2xvYmFsXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG4gICAgdmFyIHRoaXNEZXAgPSBmYWxzZVxuICAgIHZhciBjb250ZXh0RGVwID0gZmFsc2VcbiAgICB2YXIgcHJvcERlcCA9IGZhbHNlXG4gICAgdmFyIG9iamVjdFJlZiA9IGVudi5nbG9iYWwuZGVmKCd7fScpXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldXG4gICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldID0gZHluYW1pYy51bmJveCh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwcyA9IGNyZWF0ZUR5bmFtaWNEZWNsKHZhbHVlLCBudWxsKVxuICAgICAgICB0aGlzRGVwID0gdGhpc0RlcCB8fCBkZXBzLnRoaXNEZXBcbiAgICAgICAgcHJvcERlcCA9IHByb3BEZXAgfHwgZGVwcy5wcm9wRGVwXG4gICAgICAgIGNvbnRleHREZXAgPSBjb250ZXh0RGVwIHx8IGRlcHMuY29udGV4dERlcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFscyhvYmplY3RSZWYsICcuJywga2V5LCAnPScpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGdsb2JhbHModmFsdWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBnbG9iYWxzKCdcIicsIHZhbHVlLCAnXCInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGdsb2JhbHMoJ1snLCB2YWx1ZS5qb2luKCksICddJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGdsb2JhbHMoZW52LmxpbmsodmFsdWUpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxzKCc7JylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kQmxvY2sgKGVudiwgYmxvY2spIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldXG4gICAgICAgIGlmICghZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IGVudi5pbnZva2UoYmxvY2ssIHZhbHVlKVxuICAgICAgICBibG9jayhvYmplY3RSZWYsICcuJywga2V5LCAnPScsIHJlZiwgJzsnKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBvcHRpb25zLmR5bmFtaWNbbmFtZV0gPSBuZXcgZHluYW1pYy5EeW5hbWljVmFyaWFibGUoRFlOX1RIVU5LLCB7XG4gICAgICB0aGlzRGVwOiB0aGlzRGVwLFxuICAgICAgY29udGV4dERlcDogY29udGV4dERlcCxcbiAgICAgIHByb3BEZXA6IHByb3BEZXAsXG4gICAgICByZWY6IG9iamVjdFJlZixcbiAgICAgIGFwcGVuZDogYXBwZW5kQmxvY2tcbiAgICB9KVxuICAgIGRlbGV0ZSBvcHRpb25zLnN0YXRpY1tuYW1lXVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBNQUlOIERSQVcgQ09NTUFORFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGNvbXBpbGVDb21tYW5kIChvcHRpb25zLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgc3RhdHMpIHtcbiAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KClcblxuICAgIC8vIGxpbmsgc3RhdHMsIHNvIHRoYXQgd2UgY2FuIGVhc2lseSBhY2Nlc3MgaXQgaW4gdGhlIHByb2dyYW0uXG4gICAgZW52LnN0YXRzID0gZW52Lmxpbmsoc3RhdHMpXG5cbiAgICAvLyBzcGxhdCBvcHRpb25zIGFuZCBhdHRyaWJ1dGVzIHRvIGFsbG93IGZvciBkeW5hbWljIG5lc3RlZCBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcy5zdGF0aWMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3BsYXRPYmplY3QoZW52LCBhdHRyaWJ1dGVzLCBrZXkpXG4gICAgfSlcbiAgICBORVNURURfT1BUSU9OUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzcGxhdE9iamVjdChlbnYsIG9wdGlvbnMsIG5hbWUpXG4gICAgfSlcblxuICAgIHZhciBhcmdzID0gcGFyc2VBcmd1bWVudHMob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIGVudilcblxuICAgIGVtaXREcmF3UHJvYyhlbnYsIGFyZ3MpXG4gICAgZW1pdFNjb3BlUHJvYyhlbnYsIGFyZ3MpXG4gICAgZW1pdEJhdGNoUHJvYyhlbnYsIGFyZ3MpXG5cbiAgICByZXR1cm4gZXh0ZW5kKGVudi5jb21waWxlKCksIHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJncy5zaGFkZXIucHJvZ3JhbS5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQT0xMIC8gUkVGUkVTSFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHJldHVybiB7XG4gICAgbmV4dDogbmV4dFN0YXRlLFxuICAgIGN1cnJlbnQ6IGN1cnJlbnRTdGF0ZSxcbiAgICBwcm9jczogKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbnYgPSBjcmVhdGVSRUdMRW52aXJvbm1lbnQoKVxuICAgICAgdmFyIHBvbGwgPSBlbnYucHJvYygncG9sbCcpXG4gICAgICB2YXIgcmVmcmVzaCA9IGVudi5wcm9jKCdyZWZyZXNoJylcbiAgICAgIHZhciBjb21tb24gPSBlbnYuYmxvY2soKVxuICAgICAgcG9sbChjb21tb24pXG4gICAgICByZWZyZXNoKGNvbW1vbilcblxuICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuICAgICAgdmFyIE5FWFRfU1RBVEUgPSBzaGFyZWQubmV4dFxuICAgICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuXG4gICAgICBjb21tb24oQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT1mYWxzZTsnKVxuXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgcG9sbClcbiAgICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCByZWZyZXNoLCBudWxsLCB0cnVlKVxuXG4gICAgICAvLyBSZWZyZXNoIHVwZGF0ZXMgYWxsIGF0dHJpYnV0ZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICB2YXIgSU5TVEFOQ0lOR1xuICAgICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgICAgSU5TVEFOQ0lORyA9IGVudi5saW5rKGV4dEluc3RhbmNpbmcpXG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB2ZXJ0ZXggYXJyYXkgYmluZGluZ3NcbiAgICAgIGlmIChleHRlbnNpb25zLm9lc192ZXJ0ZXhfYXJyYXlfb2JqZWN0KSB7XG4gICAgICAgIHJlZnJlc2goZW52LmxpbmsoZXh0ZW5zaW9ucy5vZXNfdmVydGV4X2FycmF5X29iamVjdCksICcuYmluZFZlcnRleEFycmF5T0VTKG51bGwpOycpXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0cy5tYXhBdHRyaWJ1dGVzOyArK2kpIHtcbiAgICAgICAgdmFyIEJJTkRJTkcgPSByZWZyZXNoLmRlZihzaGFyZWQuYXR0cmlidXRlcywgJ1snLCBpLCAnXScpXG4gICAgICAgIHZhciBpZnRlID0gZW52LmNvbmQoQklORElORywgJy5idWZmZXInKVxuICAgICAgICBpZnRlLnRoZW4oXG4gICAgICAgICAgR0wsICcuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoJywgaSwgJyk7JyxcbiAgICAgICAgICBHTCwgJy5iaW5kQnVmZmVyKCcsXG4gICAgICAgICAgR0xfQVJSQVlfQlVGRkVSJDIsICcsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLmJ1ZmZlci5idWZmZXIpOycsXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliUG9pbnRlcignLFxuICAgICAgICAgIGksICcsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnNpemUsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnR5cGUsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLm5vcm1hbGl6ZWQsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnN0cmlkZSwnLFxuICAgICAgICAgIEJJTkRJTkcsICcub2Zmc2V0KTsnXG4gICAgICAgICkuZWxzZShcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoJywgaSwgJyk7JyxcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWI0ZignLFxuICAgICAgICAgIGksICcsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLngsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnksJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnosJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLncpOycsXG4gICAgICAgICAgQklORElORywgJy5idWZmZXI9bnVsbDsnKVxuICAgICAgICByZWZyZXNoKGlmdGUpXG4gICAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICAgICAgcmVmcmVzaChcbiAgICAgICAgICAgIElOU1RBTkNJTkcsICcudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCcsXG4gICAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgICBCSU5ESU5HLCAnLmRpdmlzb3IpOycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlZnJlc2goXG4gICAgICAgIGVudi5zaGFyZWQudmFvLCAnLmN1cnJlbnRWQU89bnVsbDsnLFxuICAgICAgICBlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgZW52LnNoYXJlZC52YW8sICcudGFyZ2V0VkFPKTsnKVxuXG4gICAgICBPYmplY3Qua2V5cyhHTF9GTEFHUykuZm9yRWFjaChmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICB2YXIgY2FwID0gR0xfRkxBR1NbZmxhZ11cbiAgICAgICAgdmFyIE5FWFQgPSBjb21tb24uZGVmKE5FWFRfU1RBVEUsICcuJywgZmxhZylcbiAgICAgICAgdmFyIGJsb2NrID0gZW52LmJsb2NrKClcbiAgICAgICAgYmxvY2soJ2lmKCcsIE5FWFQsICcpeycsXG4gICAgICAgICAgR0wsICcuZW5hYmxlKCcsIGNhcCwgJyl9ZWxzZXsnLFxuICAgICAgICAgIEdMLCAnLmRpc2FibGUoJywgY2FwLCAnKX0nLFxuICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgZmxhZywgJz0nLCBORVhULCAnOycpXG4gICAgICAgIHJlZnJlc2goYmxvY2spXG4gICAgICAgIHBvbGwoXG4gICAgICAgICAgJ2lmKCcsIE5FWFQsICchPT0nLCBDVVJSRU5UX1NUQVRFLCAnLicsIGZsYWcsICcpeycsXG4gICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgJ30nKVxuICAgICAgfSlcblxuICAgICAgT2JqZWN0LmtleXMoR0xfVkFSSUFCTEVTKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gR0xfVkFSSUFCTEVTW25hbWVdXG4gICAgICAgIHZhciBpbml0ID0gY3VycmVudFN0YXRlW25hbWVdXG4gICAgICAgIHZhciBORVhULCBDVVJSRU5UXG4gICAgICAgIHZhciBibG9jayA9IGVudi5ibG9jaygpXG4gICAgICAgIGJsb2NrKEdMLCAnLicsIGZ1bmMsICcoJylcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGluaXQpKSB7XG4gICAgICAgICAgdmFyIG4gPSBpbml0Lmxlbmd0aFxuICAgICAgICAgIE5FWFQgPSBlbnYuZ2xvYmFsLmRlZihORVhUX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgQ1VSUkVOVCA9IGVudi5nbG9iYWwuZGVmKENVUlJFTlRfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgICAgICBibG9jayhcbiAgICAgICAgICAgIGxvb3AobiwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5FWFQgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICB9KSwgJyk7JyxcbiAgICAgICAgICAgIGxvb3AobiwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIE5FWFQgKyAnWycgKyBpICsgJ107J1xuICAgICAgICAgICAgfSkuam9pbignJykpXG4gICAgICAgICAgcG9sbChcbiAgICAgICAgICAgICdpZignLCBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBORVhUICsgJ1snICsgaSArICddIT09JyArIENVUlJFTlQgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICB9KS5qb2luKCd8fCcpLCAnKXsnLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAnfScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTkVYVCA9IGNvbW1vbi5kZWYoTkVYVF9TVEFURSwgJy4nLCBuYW1lKVxuICAgICAgICAgIENVUlJFTlQgPSBjb21tb24uZGVmKENVUlJFTlRfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgICAgICBibG9jayhcbiAgICAgICAgICAgIE5FWFQsICcpOycsXG4gICAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUsICc9JywgTkVYVCwgJzsnKVxuICAgICAgICAgIHBvbGwoXG4gICAgICAgICAgICAnaWYoJywgTkVYVCwgJyE9PScsIENVUlJFTlQsICcpeycsXG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgICd9JylcbiAgICAgICAgfVxuICAgICAgICByZWZyZXNoKGJsb2NrKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGVudi5jb21waWxlKClcbiAgICB9KSgpLFxuICAgIGNvbXBpbGU6IGNvbXBpbGVDb21tYW5kXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhdHMgKCkge1xuICByZXR1cm4ge1xuICAgIHZhb0NvdW50OiAwLFxuICAgIGJ1ZmZlckNvdW50OiAwLFxuICAgIGVsZW1lbnRzQ291bnQ6IDAsXG4gICAgZnJhbWVidWZmZXJDb3VudDogMCxcbiAgICBzaGFkZXJDb3VudDogMCxcbiAgICB0ZXh0dXJlQ291bnQ6IDAsXG4gICAgY3ViZUNvdW50OiAwLFxuICAgIHJlbmRlcmJ1ZmZlckNvdW50OiAwLFxuICAgIG1heFRleHR1cmVVbml0czogMFxuICB9XG59XG5cbnZhciBHTF9RVUVSWV9SRVNVTFRfRVhUID0gMHg4ODY2XG52YXIgR0xfUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQgPSAweDg4NjdcbnZhciBHTF9USU1FX0VMQVBTRURfRVhUID0gMHg4OEJGXG5cbnZhciBjcmVhdGVUaW1lciA9IGZ1bmN0aW9uIChnbCwgZXh0ZW5zaW9ucykge1xuICBpZiAoIWV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIFFVRVJZIFBPT0wgQkVHSU5cbiAgdmFyIHF1ZXJ5UG9vbCA9IFtdXG4gIGZ1bmN0aW9uIGFsbG9jUXVlcnkgKCkge1xuICAgIHJldHVybiBxdWVyeVBvb2wucG9wKCkgfHwgZXh0ZW5zaW9ucy5leHRfZGlzam9pbnRfdGltZXJfcXVlcnkuY3JlYXRlUXVlcnlFWFQoKVxuICB9XG4gIGZ1bmN0aW9uIGZyZWVRdWVyeSAocXVlcnkpIHtcbiAgICBxdWVyeVBvb2wucHVzaChxdWVyeSlcbiAgfVxuICAvLyBRVUVSWSBQT09MIEVORFxuXG4gIHZhciBwZW5kaW5nUXVlcmllcyA9IFtdXG4gIGZ1bmN0aW9uIGJlZ2luUXVlcnkgKHN0YXRzKSB7XG4gICAgdmFyIHF1ZXJ5ID0gYWxsb2NRdWVyeSgpXG4gICAgZXh0ZW5zaW9ucy5leHRfZGlzam9pbnRfdGltZXJfcXVlcnkuYmVnaW5RdWVyeUVYVChHTF9USU1FX0VMQVBTRURfRVhULCBxdWVyeSlcbiAgICBwZW5kaW5nUXVlcmllcy5wdXNoKHF1ZXJ5KVxuICAgIHB1c2hTY29wZVN0YXRzKHBlbmRpbmdRdWVyaWVzLmxlbmd0aCAtIDEsIHBlbmRpbmdRdWVyaWVzLmxlbmd0aCwgc3RhdHMpXG4gIH1cblxuICBmdW5jdGlvbiBlbmRRdWVyeSAoKSB7XG4gICAgZXh0ZW5zaW9ucy5leHRfZGlzam9pbnRfdGltZXJfcXVlcnkuZW5kUXVlcnlFWFQoR0xfVElNRV9FTEFQU0VEX0VYVClcbiAgfVxuXG4gIC8vXG4gIC8vIFBlbmRpbmcgc3RhdHMgcG9vbC5cbiAgLy9cbiAgZnVuY3Rpb24gUGVuZGluZ1N0YXRzICgpIHtcbiAgICB0aGlzLnN0YXJ0UXVlcnlJbmRleCA9IC0xXG4gICAgdGhpcy5lbmRRdWVyeUluZGV4ID0gLTFcbiAgICB0aGlzLnN1bSA9IDBcbiAgICB0aGlzLnN0YXRzID0gbnVsbFxuICB9XG4gIHZhciBwZW5kaW5nU3RhdHNQb29sID0gW11cbiAgZnVuY3Rpb24gYWxsb2NQZW5kaW5nU3RhdHMgKCkge1xuICAgIHJldHVybiBwZW5kaW5nU3RhdHNQb29sLnBvcCgpIHx8IG5ldyBQZW5kaW5nU3RhdHMoKVxuICB9XG4gIGZ1bmN0aW9uIGZyZWVQZW5kaW5nU3RhdHMgKHBlbmRpbmdTdGF0cykge1xuICAgIHBlbmRpbmdTdGF0c1Bvb2wucHVzaChwZW5kaW5nU3RhdHMpXG4gIH1cbiAgLy8gUGVuZGluZyBzdGF0cyBwb29sIGVuZFxuXG4gIHZhciBwZW5kaW5nU3RhdHMgPSBbXVxuICBmdW5jdGlvbiBwdXNoU2NvcGVTdGF0cyAoc3RhcnQsIGVuZCwgc3RhdHMpIHtcbiAgICB2YXIgcHMgPSBhbGxvY1BlbmRpbmdTdGF0cygpXG4gICAgcHMuc3RhcnRRdWVyeUluZGV4ID0gc3RhcnRcbiAgICBwcy5lbmRRdWVyeUluZGV4ID0gZW5kXG4gICAgcHMuc3VtID0gMFxuICAgIHBzLnN0YXRzID0gc3RhdHNcbiAgICBwZW5kaW5nU3RhdHMucHVzaChwcylcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBjYWxsIHRoaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZnJhbWUsXG4gIC8vIGluIG9yZGVyIHRvIHVwZGF0ZSBncHVUaW1lXG4gIHZhciB0aW1lU3VtID0gW11cbiAgdmFyIHF1ZXJ5UHRyID0gW11cbiAgZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICB2YXIgcHRyLCBpXG5cbiAgICB2YXIgbiA9IHBlbmRpbmdRdWVyaWVzLmxlbmd0aFxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBSZXNlcnZlIHNwYWNlXG4gICAgcXVlcnlQdHIubGVuZ3RoID0gTWF0aC5tYXgocXVlcnlQdHIubGVuZ3RoLCBuICsgMSlcbiAgICB0aW1lU3VtLmxlbmd0aCA9IE1hdGgubWF4KHRpbWVTdW0ubGVuZ3RoLCBuICsgMSlcbiAgICB0aW1lU3VtWzBdID0gMFxuICAgIHF1ZXJ5UHRyWzBdID0gMFxuXG4gICAgLy8gVXBkYXRlIGFsbCBwZW5kaW5nIHRpbWVyIHF1ZXJpZXNcbiAgICB2YXIgcXVlcnlUaW1lID0gMFxuICAgIHB0ciA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBxdWVyeSA9IHBlbmRpbmdRdWVyaWVzW2ldXG4gICAgICBpZiAoZXh0ZW5zaW9ucy5leHRfZGlzam9pbnRfdGltZXJfcXVlcnkuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKSkge1xuICAgICAgICBxdWVyeVRpbWUgKz0gZXh0ZW5zaW9ucy5leHRfZGlzam9pbnRfdGltZXJfcXVlcnkuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIEdMX1FVRVJZX1JFU1VMVF9FWFQpXG4gICAgICAgIGZyZWVRdWVyeShxdWVyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdRdWVyaWVzW3B0cisrXSA9IHF1ZXJ5XG4gICAgICB9XG4gICAgICB0aW1lU3VtW2kgKyAxXSA9IHF1ZXJ5VGltZVxuICAgICAgcXVlcnlQdHJbaSArIDFdID0gcHRyXG4gICAgfVxuICAgIHBlbmRpbmdRdWVyaWVzLmxlbmd0aCA9IHB0clxuXG4gICAgLy8gVXBkYXRlIGFsbCBwZW5kaW5nIHN0YXQgcXVlcmllc1xuICAgIHB0ciA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ1N0YXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3RhdHMgPSBwZW5kaW5nU3RhdHNbaV1cbiAgICAgIHZhciBzdGFydCA9IHN0YXRzLnN0YXJ0UXVlcnlJbmRleFxuICAgICAgdmFyIGVuZCA9IHN0YXRzLmVuZFF1ZXJ5SW5kZXhcbiAgICAgIHN0YXRzLnN1bSArPSB0aW1lU3VtW2VuZF0gLSB0aW1lU3VtW3N0YXJ0XVxuICAgICAgdmFyIHN0YXJ0UHRyID0gcXVlcnlQdHJbc3RhcnRdXG4gICAgICB2YXIgZW5kUHRyID0gcXVlcnlQdHJbZW5kXVxuICAgICAgaWYgKGVuZFB0ciA9PT0gc3RhcnRQdHIpIHtcbiAgICAgICAgc3RhdHMuc3RhdHMuZ3B1VGltZSArPSBzdGF0cy5zdW0gLyAxZTZcbiAgICAgICAgZnJlZVBlbmRpbmdTdGF0cyhzdGF0cylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRzLnN0YXJ0UXVlcnlJbmRleCA9IHN0YXJ0UHRyXG4gICAgICAgIHN0YXRzLmVuZFF1ZXJ5SW5kZXggPSBlbmRQdHJcbiAgICAgICAgcGVuZGluZ1N0YXRzW3B0cisrXSA9IHN0YXRzXG4gICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdTdGF0cy5sZW5ndGggPSBwdHJcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVnaW5RdWVyeTogYmVnaW5RdWVyeSxcbiAgICBlbmRRdWVyeTogZW5kUXVlcnksXG4gICAgcHVzaFNjb3BlU3RhdHM6IHB1c2hTY29wZVN0YXRzLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIGdldE51bVBlbmRpbmdRdWVyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVuZGluZ1F1ZXJpZXMubGVuZ3RoXG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgcXVlcnlQb29sLnB1c2guYXBwbHkocXVlcnlQb29sLCBwZW5kaW5nUXVlcmllcylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlQb29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmRlbGV0ZVF1ZXJ5RVhUKHF1ZXJ5UG9vbFtpXSlcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdRdWVyaWVzLmxlbmd0aCA9IDBcbiAgICAgIHF1ZXJ5UG9vbC5sZW5ndGggPSAwXG4gICAgfSxcbiAgICByZXN0b3JlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSAwXG4gICAgICBxdWVyeVBvb2wubGVuZ3RoID0gMFxuICAgIH1cbiAgfVxufVxuXG52YXIgR0xfQ09MT1JfQlVGRkVSX0JJVCA9IDE2Mzg0XG52YXIgR0xfREVQVEhfQlVGRkVSX0JJVCA9IDI1NlxudmFyIEdMX1NURU5DSUxfQlVGRkVSX0JJVCA9IDEwMjRcblxudmFyIEdMX0FSUkFZX0JVRkZFUiA9IDM0OTYyXG5cbnZhciBDT05URVhUX0xPU1RfRVZFTlQgPSAnd2ViZ2xjb250ZXh0bG9zdCdcbnZhciBDT05URVhUX1JFU1RPUkVEX0VWRU5UID0gJ3dlYmdsY29udGV4dHJlc3RvcmVkJ1xuXG52YXIgRFlOX1BST1AgPSAxXG52YXIgRFlOX0NPTlRFWFQgPSAyXG52YXIgRFlOX1NUQVRFID0gM1xuXG5mdW5jdGlvbiBmaW5kIChoYXlzdGFjaywgbmVlZGxlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaGF5c3RhY2tbaV0gPT09IG5lZWRsZSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIHdyYXBSRUdMIChhcmdzKSB7XG4gIHZhciBjb25maWcgPSBwYXJzZUFyZ3MoYXJncylcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIGdsID0gY29uZmlnLmdsXG4gIHZhciBnbEF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpXG4gIHZhciBjb250ZXh0TG9zdCA9IGdsLmlzQ29udGV4dExvc3QoKVxuXG4gIHZhciBleHRlbnNpb25TdGF0ZSA9IGNyZWF0ZUV4dGVuc2lvbkNhY2hlKGdsLCBjb25maWcpXG4gIGlmICghZXh0ZW5zaW9uU3RhdGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIHN0cmluZ1N0b3JlID0gY3JlYXRlU3RyaW5nU3RvcmUoKVxuICB2YXIgc3RhdHMkJDEgPSBzdGF0cygpXG4gIHZhciBleHRlbnNpb25zID0gZXh0ZW5zaW9uU3RhdGUuZXh0ZW5zaW9uc1xuICB2YXIgdGltZXIgPSBjcmVhdGVUaW1lcihnbCwgZXh0ZW5zaW9ucylcblxuICB2YXIgU1RBUlRfVElNRSA9IGNsb2NrKClcbiAgdmFyIFdJRFRIID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoXG4gIHZhciBIRUlHSFQgPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0XG5cbiAgdmFyIGNvbnRleHRTdGF0ZSA9IHtcbiAgICB0aWNrOiAwLFxuICAgIHRpbWU6IDAsXG4gICAgdmlld3BvcnRXaWR0aDogV0lEVEgsXG4gICAgdmlld3BvcnRIZWlnaHQ6IEhFSUdIVCxcbiAgICBmcmFtZWJ1ZmZlcldpZHRoOiBXSURUSCxcbiAgICBmcmFtZWJ1ZmZlckhlaWdodDogSEVJR0hULFxuICAgIGRyYXdpbmdCdWZmZXJXaWR0aDogV0lEVEgsXG4gICAgZHJhd2luZ0J1ZmZlckhlaWdodDogSEVJR0hULFxuICAgIHBpeGVsUmF0aW86IGNvbmZpZy5waXhlbFJhdGlvXG4gIH1cbiAgdmFyIHVuaWZvcm1TdGF0ZSA9IHt9XG4gIHZhciBkcmF3U3RhdGUgPSB7XG4gICAgZWxlbWVudHM6IG51bGwsXG4gICAgcHJpbWl0aXZlOiA0LCAvLyBHTF9UUklBTkdMRVNcbiAgICBjb3VudDogLTEsXG4gICAgb2Zmc2V0OiAwLFxuICAgIGluc3RhbmNlczogLTFcbiAgfVxuXG4gIHZhciBsaW1pdHMgPSB3cmFwTGltaXRzKGdsLCBleHRlbnNpb25zKVxuICB2YXIgYnVmZmVyU3RhdGUgPSB3cmFwQnVmZmVyU3RhdGUoXG4gICAgZ2wsXG4gICAgc3RhdHMkJDEsXG4gICAgY29uZmlnLFxuICAgIGRlc3Ryb3lCdWZmZXIpXG4gIHZhciBhdHRyaWJ1dGVTdGF0ZSA9IHdyYXBBdHRyaWJ1dGVTdGF0ZShcbiAgICBnbCxcbiAgICBleHRlbnNpb25zLFxuICAgIGxpbWl0cyxcbiAgICBzdGF0cyQkMSxcbiAgICBidWZmZXJTdGF0ZSlcbiAgZnVuY3Rpb24gZGVzdHJveUJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZVN0YXRlLmRlc3Ryb3lCdWZmZXIoYnVmZmVyKVxuICB9XG4gIHZhciBlbGVtZW50U3RhdGUgPSB3cmFwRWxlbWVudHNTdGF0ZShnbCwgZXh0ZW5zaW9ucywgYnVmZmVyU3RhdGUsIHN0YXRzJCQxKVxuICB2YXIgc2hhZGVyU3RhdGUgPSB3cmFwU2hhZGVyU3RhdGUoZ2wsIHN0cmluZ1N0b3JlLCBzdGF0cyQkMSwgY29uZmlnKVxuICB2YXIgdGV4dHVyZVN0YXRlID0gY3JlYXRlVGV4dHVyZVNldChcbiAgICBnbCxcbiAgICBleHRlbnNpb25zLFxuICAgIGxpbWl0cyxcbiAgICBmdW5jdGlvbiAoKSB7IGNvcmUucHJvY3MucG9sbCgpIH0sXG4gICAgY29udGV4dFN0YXRlLFxuICAgIHN0YXRzJCQxLFxuICAgIGNvbmZpZylcbiAgdmFyIHJlbmRlcmJ1ZmZlclN0YXRlID0gd3JhcFJlbmRlcmJ1ZmZlcnMoZ2wsIGV4dGVuc2lvbnMsIGxpbWl0cywgc3RhdHMkJDEsIGNvbmZpZylcbiAgdmFyIGZyYW1lYnVmZmVyU3RhdGUgPSB3cmFwRkJPU3RhdGUoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgdGV4dHVyZVN0YXRlLFxuICAgIHJlbmRlcmJ1ZmZlclN0YXRlLFxuICAgIHN0YXRzJCQxKVxuICB2YXIgY29yZSA9IHJlZ2xDb3JlKFxuICAgIGdsLFxuICAgIHN0cmluZ1N0b3JlLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgbGltaXRzLFxuICAgIGJ1ZmZlclN0YXRlLFxuICAgIGVsZW1lbnRTdGF0ZSxcbiAgICB0ZXh0dXJlU3RhdGUsXG4gICAgZnJhbWVidWZmZXJTdGF0ZSxcbiAgICB1bmlmb3JtU3RhdGUsXG4gICAgYXR0cmlidXRlU3RhdGUsXG4gICAgc2hhZGVyU3RhdGUsXG4gICAgZHJhd1N0YXRlLFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICB0aW1lcixcbiAgICBjb25maWcpXG4gIHZhciByZWFkUGl4ZWxzID0gd3JhcFJlYWRQaXhlbHMoXG4gICAgZ2wsXG4gICAgZnJhbWVidWZmZXJTdGF0ZSxcbiAgICBjb3JlLnByb2NzLnBvbGwsXG4gICAgY29udGV4dFN0YXRlLFxuICAgIGdsQXR0cmlidXRlcywgZXh0ZW5zaW9ucywgbGltaXRzKVxuXG4gIHZhciBuZXh0U3RhdGUgPSBjb3JlLm5leHRcbiAgdmFyIGNhbnZhcyA9IGdsLmNhbnZhc1xuXG4gIHZhciByYWZDYWxsYmFja3MgPSBbXVxuICB2YXIgbG9zc0NhbGxiYWNrcyA9IFtdXG4gIHZhciByZXN0b3JlQ2FsbGJhY2tzID0gW11cbiAgdmFyIGRlc3Ryb3lDYWxsYmFja3MgPSBbY29uZmlnLm9uRGVzdHJveV1cblxuICB2YXIgYWN0aXZlUkFGID0gbnVsbFxuICBmdW5jdGlvbiBoYW5kbGVSQUYgKCkge1xuICAgIGlmIChyYWZDYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgdGltZXIudXBkYXRlKClcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVJBRiA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHNjaGVkdWxlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgYWN0aXZlUkFGID0gcmFmLm5leHQoaGFuZGxlUkFGKVxuXG4gICAgLy8gcG9sbCBmb3IgY2hhbmdlc1xuICAgIHBvbGwoKVxuXG4gICAgLy8gZmlyZSBhIGNhbGxiYWNrIGZvciBhbGwgcGVuZGluZyByYWZzXG4gICAgZm9yICh2YXIgaSA9IHJhZkNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGNiID0gcmFmQ2FsbGJhY2tzW2ldXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IoY29udGV4dFN0YXRlLCBudWxsLCAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZsdXNoIGFsbCBwZW5kaW5nIHdlYmdsIGNhbGxzXG4gICAgZ2wuZmx1c2goKVxuXG4gICAgLy8gcG9sbCBHUFUgdGltZXJzICphZnRlciogZ2wuZmx1c2ggc28gd2UgZG9uJ3QgZGVsYXkgY29tbWFuZCBkaXNwYXRjaFxuICAgIGlmICh0aW1lcikge1xuICAgICAgdGltZXIudXBkYXRlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFJBRiAoKSB7XG4gICAgaWYgKCFhY3RpdmVSQUYgJiYgcmFmQ2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wUkFGICgpIHtcbiAgICBpZiAoYWN0aXZlUkFGKSB7XG4gICAgICByYWYuY2FuY2VsKGhhbmRsZVJBRilcbiAgICAgIGFjdGl2ZVJBRiA9IG51bGxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TG9zcyAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAvLyBzZXQgY29udGV4dCBsb3N0IGZsYWdcbiAgICBjb250ZXh0TG9zdCA9IHRydWVcblxuICAgIC8vIHBhdXNlIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lXG4gICAgc3RvcFJBRigpXG5cbiAgICAvLyBsb3NlIGNvbnRleHRcbiAgICBsb3NzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRSZXN0b3JlZCAoZXZlbnQpIHtcbiAgICAvLyBjbGVhciBlcnJvciBjb2RlXG4gICAgZ2wuZ2V0RXJyb3IoKVxuXG4gICAgLy8gY2xlYXIgY29udGV4dCBsb3N0IGZsYWdcbiAgICBjb250ZXh0TG9zdCA9IGZhbHNlXG5cbiAgICAvLyByZWZyZXNoIHN0YXRlXG4gICAgZXh0ZW5zaW9uU3RhdGUucmVzdG9yZSgpXG4gICAgc2hhZGVyU3RhdGUucmVzdG9yZSgpXG4gICAgYnVmZmVyU3RhdGUucmVzdG9yZSgpXG4gICAgdGV4dHVyZVN0YXRlLnJlc3RvcmUoKVxuICAgIHJlbmRlcmJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIGZyYW1lYnVmZmVyU3RhdGUucmVzdG9yZSgpXG4gICAgYXR0cmlidXRlU3RhdGUucmVzdG9yZSgpXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci5yZXN0b3JlKClcbiAgICB9XG5cbiAgICAvLyByZWZyZXNoIHN0YXRlXG4gICAgY29yZS5wcm9jcy5yZWZyZXNoKClcblxuICAgIC8vIHJlc3RhcnQgUkFGXG4gICAgc3RhcnRSQUYoKVxuXG4gICAgLy8gcmVzdG9yZSBjb250ZXh0XG4gICAgcmVzdG9yZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBpZiAoY2FudmFzKSB7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9MT1NUX0VWRU5ULCBoYW5kbGVDb250ZXh0TG9zcywgZmFsc2UpXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCwgaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICAgIHJhZkNhbGxiYWNrcy5sZW5ndGggPSAwXG4gICAgc3RvcFJBRigpXG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05URVhUX0xPU1RfRVZFTlQsIGhhbmRsZUNvbnRleHRMb3NzKVxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCwgaGFuZGxlQ29udGV4dFJlc3RvcmVkKVxuICAgIH1cblxuICAgIHNoYWRlclN0YXRlLmNsZWFyKClcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLmNsZWFyKClcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgdGV4dHVyZVN0YXRlLmNsZWFyKClcbiAgICBlbGVtZW50U3RhdGUuY2xlYXIoKVxuICAgIGJ1ZmZlclN0YXRlLmNsZWFyKClcbiAgICBhdHRyaWJ1dGVTdGF0ZS5jbGVhcigpXG5cbiAgICBpZiAodGltZXIpIHtcbiAgICAgIHRpbWVyLmNsZWFyKClcbiAgICB9XG5cbiAgICBkZXN0cm95Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVQcm9jZWR1cmUgKG9wdGlvbnMpIHtcbiAgICBjaGVjayQxKCEhb3B0aW9ucywgJ2ludmFsaWQgYXJncyB0byByZWdsKHsuLi59KScpXG4gICAgY2hlY2skMS50eXBlKG9wdGlvbnMsICdvYmplY3QnLCAnaW52YWxpZCBhcmdzIHRvIHJlZ2woey4uLn0pJylcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRPcHRpb25zIChvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZXh0ZW5kKHt9LCBvcHRpb25zKVxuICAgICAgZGVsZXRlIHJlc3VsdC51bmlmb3Jtc1xuICAgICAgZGVsZXRlIHJlc3VsdC5hdHRyaWJ1dGVzXG4gICAgICBkZWxldGUgcmVzdWx0LmNvbnRleHRcbiAgICAgIGRlbGV0ZSByZXN1bHQudmFvXG5cbiAgICAgIGlmICgnc3RlbmNpbCcgaW4gcmVzdWx0ICYmIHJlc3VsdC5zdGVuY2lsLm9wKSB7XG4gICAgICAgIHJlc3VsdC5zdGVuY2lsLm9wQmFjayA9IHJlc3VsdC5zdGVuY2lsLm9wRnJvbnQgPSByZXN1bHQuc3RlbmNpbC5vcFxuICAgICAgICBkZWxldGUgcmVzdWx0LnN0ZW5jaWwub3BcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVyZ2UgKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gcmVzdWx0W25hbWVdXG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtuYW1lXVxuICAgICAgICAgIE9iamVjdC5rZXlzKGNoaWxkKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZSArICcuJyArIHByb3BdID0gY2hpbGRbcHJvcF1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXJnZSgnYmxlbmQnKVxuICAgICAgbWVyZ2UoJ2RlcHRoJylcbiAgICAgIG1lcmdlKCdjdWxsJylcbiAgICAgIG1lcmdlKCdzdGVuY2lsJylcbiAgICAgIG1lcmdlKCdwb2x5Z29uT2Zmc2V0JylcbiAgICAgIG1lcmdlKCdzY2lzc29yJylcbiAgICAgIG1lcmdlKCdzYW1wbGUnKVxuXG4gICAgICBpZiAoJ3ZhbycgaW4gb3B0aW9ucykge1xuICAgICAgICByZXN1bHQudmFvID0gb3B0aW9ucy52YW9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlcGFyYXRlRHluYW1pYyAob2JqZWN0LCB1c2VBcnJheXMpIHtcbiAgICAgIHZhciBzdGF0aWNJdGVtcyA9IHt9XG4gICAgICB2YXIgZHluYW1pY0l0ZW1zID0ge31cbiAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtvcHRpb25dXG4gICAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyh2YWx1ZSkpIHtcbiAgICAgICAgICBkeW5hbWljSXRlbXNbb3B0aW9uXSA9IGR5bmFtaWMudW5ib3godmFsdWUsIG9wdGlvbilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh1c2VBcnJheXMgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWVbaV0pKSB7XG4gICAgICAgICAgICAgIGR5bmFtaWNJdGVtc1tvcHRpb25dID0gZHluYW1pYy51bmJveCh2YWx1ZSwgb3B0aW9uKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljSXRlbXNbb3B0aW9uXSA9IHZhbHVlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZHluYW1pY0l0ZW1zLFxuICAgICAgICBzdGF0aWM6IHN0YXRpY0l0ZW1zXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJlYXQgY29udGV4dCB2YXJpYWJsZXMgc2VwYXJhdGUgZnJvbSBvdGhlciBkeW5hbWljIHZhcmlhYmxlc1xuICAgIHZhciBjb250ZXh0ID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMuY29udGV4dCB8fCB7fSwgdHJ1ZSlcbiAgICB2YXIgdW5pZm9ybXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy51bmlmb3JtcyB8fCB7fSwgdHJ1ZSlcbiAgICB2YXIgYXR0cmlidXRlcyA9IHNlcGFyYXRlRHluYW1pYyhvcHRpb25zLmF0dHJpYnV0ZXMgfHwge30sIGZhbHNlKVxuICAgIHZhciBvcHRzID0gc2VwYXJhdGVEeW5hbWljKGZsYXR0ZW5OZXN0ZWRPcHRpb25zKG9wdGlvbnMpLCBmYWxzZSlcblxuICAgIHZhciBzdGF0cyQkMSA9IHtcbiAgICAgIGdwdVRpbWU6IDAuMCxcbiAgICAgIGNwdVRpbWU6IDAuMCxcbiAgICAgIGNvdW50OiAwXG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gY29yZS5jb21waWxlKG9wdHMsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zLCBjb250ZXh0LCBzdGF0cyQkMSlcblxuICAgIHZhciBkcmF3ID0gY29tcGlsZWQuZHJhd1xuICAgIHZhciBiYXRjaCA9IGNvbXBpbGVkLmJhdGNoXG4gICAgdmFyIHNjb3BlID0gY29tcGlsZWQuc2NvcGVcblxuICAgIC8vIEZJWE1FOiB3ZSBzaG91bGQgbW9kaWZ5IGNvZGUgZ2VuZXJhdGlvbiBmb3IgYmF0Y2ggY29tbWFuZHMgc28gdGhpc1xuICAgIC8vIGlzbid0IG5lY2Vzc2FyeVxuICAgIHZhciBFTVBUWV9BUlJBWSA9IFtdXG4gICAgZnVuY3Rpb24gcmVzZXJ2ZSAoY291bnQpIHtcbiAgICAgIHdoaWxlIChFTVBUWV9BUlJBWS5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBFTVBUWV9BUlJBWS5wdXNoKG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm4gRU1QVFlfQVJSQVlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSRUdMQ29tbWFuZCAoYXJncywgYm9keSkge1xuICAgICAgdmFyIGlcbiAgICAgIGlmIChjb250ZXh0TG9zdCkge1xuICAgICAgICBjaGVjayQxLnJhaXNlKCdjb250ZXh0IGxvc3QnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5jYWxsKHRoaXMsIG51bGwsIGFyZ3MsIDApXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnczsgKytpKSB7XG4gICAgICAgICAgICBzY29wZS5jYWxsKHRoaXMsIG51bGwsIGJvZHksIGkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBhcmdzW2ldLCBib2R5LCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2NvcGUuY2FsbCh0aGlzLCBhcmdzLCBib2R5LCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoYXJncyA+IDApIHtcbiAgICAgICAgICByZXR1cm4gYmF0Y2guY2FsbCh0aGlzLCByZXNlcnZlKGFyZ3MgfCAwKSwgYXJncyB8IDApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYmF0Y2guY2FsbCh0aGlzLCBhcmdzLCBhcmdzLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRyYXcuY2FsbCh0aGlzLCBhcmdzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoUkVHTENvbW1hbmQsIHtcbiAgICAgIHN0YXRzOiBzdGF0cyQkMSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcGlsZWQuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHZhciBzZXRGQk8gPSBmcmFtZWJ1ZmZlclN0YXRlLnNldEZCTyA9IGNvbXBpbGVQcm9jZWR1cmUoe1xuICAgIGZyYW1lYnVmZmVyOiBkeW5hbWljLmRlZmluZS5jYWxsKG51bGwsIERZTl9QUk9QLCAnZnJhbWVidWZmZXInKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNsZWFySW1wbCAoXywgb3B0aW9ucykge1xuICAgIHZhciBjbGVhckZsYWdzID0gMFxuICAgIGNvcmUucHJvY3MucG9sbCgpXG5cbiAgICB2YXIgYyA9IG9wdGlvbnMuY29sb3JcbiAgICBpZiAoYykge1xuICAgICAgZ2wuY2xlYXJDb2xvcigrY1swXSB8fCAwLCArY1sxXSB8fCAwLCArY1syXSB8fCAwLCArY1szXSB8fCAwKVxuICAgICAgY2xlYXJGbGFncyB8PSBHTF9DT0xPUl9CVUZGRVJfQklUXG4gICAgfVxuICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsLmNsZWFyRGVwdGgoK29wdGlvbnMuZGVwdGgpXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX0RFUFRIX0JVRkZFUl9CSVRcbiAgICB9XG4gICAgaWYgKCdzdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICBnbC5jbGVhclN0ZW5jaWwob3B0aW9ucy5zdGVuY2lsIHwgMClcbiAgICAgIGNsZWFyRmxhZ3MgfD0gR0xfU1RFTkNJTF9CVUZGRVJfQklUXG4gICAgfVxuXG4gICAgY2hlY2skMSghIWNsZWFyRmxhZ3MsICdjYWxsZWQgcmVnbC5jbGVhciB3aXRoIG5vIGJ1ZmZlciBzcGVjaWZpZWQnKVxuICAgIGdsLmNsZWFyKGNsZWFyRmxhZ3MpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhciAob3B0aW9ucykge1xuICAgIGNoZWNrJDEoXG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyxcbiAgICAgICdyZWdsLmNsZWFyKCkgdGFrZXMgYW4gb2JqZWN0IGFzIGlucHV0JylcbiAgICBpZiAoJ2ZyYW1lYnVmZmVyJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5mcmFtZWJ1ZmZlciAmJlxuICAgICAgICAgIG9wdGlvbnMuZnJhbWVidWZmZXJfcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgc2V0RkJPKGV4dGVuZCh7XG4gICAgICAgICAgICBmcmFtZWJ1ZmZlcjogb3B0aW9ucy5mcmFtZWJ1ZmZlci5mYWNlc1tpXVxuICAgICAgICAgIH0sIG9wdGlvbnMpLCBjbGVhckltcGwpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEZCTyhvcHRpb25zLCBjbGVhckltcGwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFySW1wbChudWxsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZyYW1lIChjYikge1xuICAgIGNoZWNrJDEudHlwZShjYiwgJ2Z1bmN0aW9uJywgJ3JlZ2wuZnJhbWUoKSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIHJhZkNhbGxiYWNrcy5wdXNoKGNiKVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsICgpIHtcbiAgICAgIC8vIEZJWE1FOiAgc2hvdWxkIHdlIGNoZWNrIHNvbWV0aGluZyBvdGhlciB0aGFuIGVxdWFscyBjYiBoZXJlP1xuICAgICAgLy8gd2hhdCBpZiBhIHVzZXIgY2FsbHMgZnJhbWUgdHdpY2Ugd2l0aCB0aGUgc2FtZSBjYWxsYmFjay4uLlxuICAgICAgLy9cbiAgICAgIHZhciBpID0gZmluZChyYWZDYWxsYmFja3MsIGNiKVxuICAgICAgY2hlY2skMShpID49IDAsICdjYW5ub3QgY2FuY2VsIGEgZnJhbWUgdHdpY2UnKVxuICAgICAgZnVuY3Rpb24gcGVuZGluZ0NhbmNlbCAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmQocmFmQ2FsbGJhY2tzLCBwZW5kaW5nQ2FuY2VsKVxuICAgICAgICByYWZDYWxsYmFja3NbaW5kZXhdID0gcmFmQ2FsbGJhY2tzW3JhZkNhbGxiYWNrcy5sZW5ndGggLSAxXVxuICAgICAgICByYWZDYWxsYmFja3MubGVuZ3RoIC09IDFcbiAgICAgICAgaWYgKHJhZkNhbGxiYWNrcy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIHN0b3BSQUYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByYWZDYWxsYmFja3NbaV0gPSBwZW5kaW5nQ2FuY2VsXG4gICAgfVxuXG4gICAgc3RhcnRSQUYoKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgfVxuICB9XG5cbiAgLy8gcG9sbCB2aWV3cG9ydFxuICBmdW5jdGlvbiBwb2xsVmlld3BvcnQgKCkge1xuICAgIHZhciB2aWV3cG9ydCA9IG5leHRTdGF0ZS52aWV3cG9ydFxuICAgIHZhciBzY2lzc29yQm94ID0gbmV4dFN0YXRlLnNjaXNzb3JfYm94XG4gICAgdmlld3BvcnRbMF0gPSB2aWV3cG9ydFsxXSA9IHNjaXNzb3JCb3hbMF0gPSBzY2lzc29yQm94WzFdID0gMFxuICAgIGNvbnRleHRTdGF0ZS52aWV3cG9ydFdpZHRoID1cbiAgICAgIGNvbnRleHRTdGF0ZS5mcmFtZWJ1ZmZlcldpZHRoID1cbiAgICAgIGNvbnRleHRTdGF0ZS5kcmF3aW5nQnVmZmVyV2lkdGggPVxuICAgICAgdmlld3BvcnRbMl0gPVxuICAgICAgc2Npc3NvckJveFsyXSA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aFxuICAgIGNvbnRleHRTdGF0ZS52aWV3cG9ydEhlaWdodCA9XG4gICAgICBjb250ZXh0U3RhdGUuZnJhbWVidWZmZXJIZWlnaHQgPVxuICAgICAgY29udGV4dFN0YXRlLmRyYXdpbmdCdWZmZXJIZWlnaHQgPVxuICAgICAgdmlld3BvcnRbM10gPVxuICAgICAgc2Npc3NvckJveFszXSA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbGwgKCkge1xuICAgIGNvbnRleHRTdGF0ZS50aWNrICs9IDFcbiAgICBjb250ZXh0U3RhdGUudGltZSA9IG5vdygpXG4gICAgcG9sbFZpZXdwb3J0KClcbiAgICBjb3JlLnByb2NzLnBvbGwoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaCAoKSB7XG4gICAgdGV4dHVyZVN0YXRlLnJlZnJlc2goKVxuICAgIHBvbGxWaWV3cG9ydCgpXG4gICAgY29yZS5wcm9jcy5yZWZyZXNoKClcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm93ICgpIHtcbiAgICByZXR1cm4gKGNsb2NrKCkgLSBTVEFSVF9USU1FKSAvIDEwMDAuMFxuICB9XG5cbiAgcmVmcmVzaCgpXG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXIgKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGNoZWNrJDEudHlwZShjYWxsYmFjaywgJ2Z1bmN0aW9uJywgJ2xpc3RlbmVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpXG5cbiAgICB2YXIgY2FsbGJhY2tzXG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICByZXR1cm4gZnJhbWUoY2FsbGJhY2spXG4gICAgICBjYXNlICdsb3N0JzpcbiAgICAgICAgY2FsbGJhY2tzID0gbG9zc0NhbGxiYWNrc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVzdG9yZSc6XG4gICAgICAgIGNhbGxiYWNrcyA9IHJlc3RvcmVDYWxsYmFja3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICBjYWxsYmFja3MgPSBkZXN0cm95Q2FsbGJhY2tzXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGV2ZW50LCBtdXN0IGJlIG9uZSBvZiBmcmFtZSxsb3N0LHJlc3RvcmUsZGVzdHJveScpXG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFja3NbaV0gPSBjYWxsYmFja3NbY2FsbGJhY2tzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICBjYWxsYmFja3MucG9wKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZWdsID0gZXh0ZW5kKGNvbXBpbGVQcm9jZWR1cmUsIHtcbiAgICAvLyBDbGVhciBjdXJyZW50IEZCT1xuICAgIGNsZWFyOiBjbGVhcixcblxuICAgIC8vIFNob3J0IGN1dHMgZm9yIGR5bmFtaWMgdmFyaWFibGVzXG4gICAgcHJvcDogZHluYW1pYy5kZWZpbmUuYmluZChudWxsLCBEWU5fUFJPUCksXG4gICAgY29udGV4dDogZHluYW1pYy5kZWZpbmUuYmluZChudWxsLCBEWU5fQ09OVEVYVCksXG4gICAgdGhpczogZHluYW1pYy5kZWZpbmUuYmluZChudWxsLCBEWU5fU1RBVEUpLFxuXG4gICAgLy8gZXhlY3V0ZXMgYW4gZW1wdHkgZHJhdyBjb21tYW5kXG4gICAgZHJhdzogY29tcGlsZVByb2NlZHVyZSh7fSksXG5cbiAgICAvLyBSZXNvdXJjZXNcbiAgICBidWZmZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYnVmZmVyU3RhdGUuY3JlYXRlKG9wdGlvbnMsIEdMX0FSUkFZX0JVRkZFUiwgZmFsc2UsIGZhbHNlKVxuICAgIH0sXG4gICAgZWxlbWVudHM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFN0YXRlLmNyZWF0ZShvcHRpb25zLCBmYWxzZSlcbiAgICB9LFxuICAgIHRleHR1cmU6IHRleHR1cmVTdGF0ZS5jcmVhdGUyRCxcbiAgICBjdWJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZSxcbiAgICByZW5kZXJidWZmZXI6IHJlbmRlcmJ1ZmZlclN0YXRlLmNyZWF0ZSxcbiAgICBmcmFtZWJ1ZmZlcjogZnJhbWVidWZmZXJTdGF0ZS5jcmVhdGUsXG4gICAgZnJhbWVidWZmZXJDdWJlOiBmcmFtZWJ1ZmZlclN0YXRlLmNyZWF0ZUN1YmUsXG4gICAgdmFvOiBhdHRyaWJ1dGVTdGF0ZS5jcmVhdGVWQU8sXG5cbiAgICAvLyBFeHBvc2UgY29udGV4dCBhdHRyaWJ1dGVzXG4gICAgYXR0cmlidXRlczogZ2xBdHRyaWJ1dGVzLFxuXG4gICAgLy8gRnJhbWUgcmVuZGVyaW5nXG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIG9uOiBhZGRMaXN0ZW5lcixcblxuICAgIC8vIFN5c3RlbSBsaW1pdHNcbiAgICBsaW1pdHM6IGxpbWl0cyxcbiAgICBoYXNFeHRlbnNpb246IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZihuYW1lLnRvTG93ZXJDYXNlKCkpID49IDBcbiAgICB9LFxuXG4gICAgLy8gUmVhZCBwaXhlbHNcbiAgICByZWFkOiByZWFkUGl4ZWxzLFxuXG4gICAgLy8gRGVzdHJveSByZWdsIGFuZCBhbGwgYXNzb2NpYXRlZCByZXNvdXJjZXNcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuXG4gICAgLy8gRGlyZWN0IEdMIHN0YXRlIG1hbmlwdWxhdGlvblxuICAgIF9nbDogZ2wsXG4gICAgX3JlZnJlc2g6IHJlZnJlc2gsXG5cbiAgICBwb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKClcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICB0aW1lci51cGRhdGUoKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDdXJyZW50IHRpbWVcbiAgICBub3c6IG5vdyxcblxuICAgIC8vIHJlZ2wgU3RhdGlzdGljcyBJbmZvcm1hdGlvblxuICAgIHN0YXRzOiBzdGF0cyQkMVxuICB9KVxuXG4gIGNvbmZpZy5vbkRvbmUobnVsbCwgcmVnbClcblxuICByZXR1cm4gcmVnbFxufVxuXG5yZXR1cm4gd3JhcFJFR0w7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdsLmpzLm1hcFxuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBnbG9iYWwucGVyZm9ybWFuY2UgJiZcbiAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA/IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgfSA6IERhdGUubm93IHx8IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlXG4gIH1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3REaWZmID0gcmVxdWlyZShcInJvYnVzdC1zdWJ0cmFjdFwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxuXG52YXIgTlVNX0VYUEFORCA9IDZcblxuZnVuY3Rpb24gb3JpZW50YXRpb24obikge1xuICB2YXIgZm4gPVxuICAgIG4gPT09IDMgPyBpblNwaGVyZTMgOlxuICAgIG4gPT09IDQgPyBpblNwaGVyZTQgOlxuICAgIG4gPT09IDUgPyBpblNwaGVyZTUgOiBpblNwaGVyZTY7XG5cbiAgcmV0dXJuIGZuKHJvYnVzdFN1bSwgcm9idXN0RGlmZiwgdHdvUHJvZHVjdCwgcm9idXN0U2NhbGUpXG59XG5cbmZ1bmN0aW9uIGluU3BoZXJlMCgpIHsgcmV0dXJuIDAgfVxuZnVuY3Rpb24gaW5TcGhlcmUxKCkgeyByZXR1cm4gMCB9XG5mdW5jdGlvbiBpblNwaGVyZTIoKSB7IHJldHVybiAwIH1cblxuZnVuY3Rpb24gaW5TcGhlcmUzKHN1bSwgZGlmZiwgcHJvZCwgc2NhbGUpIHtcbiAgZnVuY3Rpb24gZXhhY3RJblNwaGVyZTMobTAsIG0xLCBtMikge1xuICAgIHZhciB3MCA9IHByb2QobTBbMF0sIG0wWzBdKVxuICAgIHZhciB3MG0xID0gc2NhbGUodzAsIG0xWzBdKVxuICAgIHZhciB3MG0yID0gc2NhbGUodzAsIG0yWzBdKVxuICAgIHZhciB3MSA9IHByb2QobTFbMF0sIG0xWzBdKVxuICAgIHZhciB3MW0wID0gc2NhbGUodzEsIG0wWzBdKVxuICAgIHZhciB3MW0yID0gc2NhbGUodzEsIG0yWzBdKVxuICAgIHZhciB3MiA9IHByb2QobTJbMF0sIG0yWzBdKVxuICAgIHZhciB3Mm0wID0gc2NhbGUodzIsIG0wWzBdKVxuICAgIHZhciB3Mm0xID0gc2NhbGUodzIsIG0xWzBdKVxuICAgIHZhciBwID0gc3VtKGRpZmYodzJtMSwgdzFtMiksIGRpZmYodzFtMCwgdzBtMSkpXG4gICAgdmFyIG4gPSBkaWZmKHcybTAsIHcwbTIpXG4gICAgdmFyIGQgPSBkaWZmKHAsIG4pXG4gICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXVxuICB9XG4gIHJldHVybiBleGFjdEluU3BoZXJlM1xufVxuXG5mdW5jdGlvbiBpblNwaGVyZTQoc3VtLCBkaWZmLCBwcm9kLCBzY2FsZSkge1xuICBmdW5jdGlvbiBleGFjdEluU3BoZXJlNChtMCwgbTEsIG0yLCBtMykge1xuICAgIHZhciB3MCA9IHN1bShwcm9kKG0wWzBdLCBtMFswXSksIHByb2QobTBbMV0sIG0wWzFdKSlcbiAgICB2YXIgdzBtMSA9IHNjYWxlKHcwLCBtMVswXSlcbiAgICB2YXIgdzBtMiA9IHNjYWxlKHcwLCBtMlswXSlcbiAgICB2YXIgdzBtMyA9IHNjYWxlKHcwLCBtM1swXSlcbiAgICB2YXIgdzEgPSBzdW0ocHJvZChtMVswXSwgbTFbMF0pLCBwcm9kKG0xWzFdLCBtMVsxXSkpXG4gICAgdmFyIHcxbTAgPSBzY2FsZSh3MSwgbTBbMF0pXG4gICAgdmFyIHcxbTIgPSBzY2FsZSh3MSwgbTJbMF0pXG4gICAgdmFyIHcxbTMgPSBzY2FsZSh3MSwgbTNbMF0pXG4gICAgdmFyIHcyID0gc3VtKHByb2QobTJbMF0sIG0yWzBdKSwgcHJvZChtMlsxXSwgbTJbMV0pKVxuICAgIHZhciB3Mm0wID0gc2NhbGUodzIsIG0wWzBdKVxuICAgIHZhciB3Mm0xID0gc2NhbGUodzIsIG0xWzBdKVxuICAgIHZhciB3Mm0zID0gc2NhbGUodzIsIG0zWzBdKVxuICAgIHZhciB3MyA9IHN1bShwcm9kKG0zWzBdLCBtM1swXSksIHByb2QobTNbMV0sIG0zWzFdKSlcbiAgICB2YXIgdzNtMCA9IHNjYWxlKHczLCBtMFswXSlcbiAgICB2YXIgdzNtMSA9IHNjYWxlKHczLCBtMVswXSlcbiAgICB2YXIgdzNtMiA9IHNjYWxlKHczLCBtMlswXSlcbiAgICB2YXIgcCA9IHN1bShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSlcbiAgICB2YXIgbiA9IHN1bShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSlcbiAgICB2YXIgZCA9IGRpZmYocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cbiAgcmV0dXJuIGV4YWN0SW5TcGhlcmU0XG59XG5cblxuZnVuY3Rpb24gaW5TcGhlcmU1KHN1bSwgZGlmZiwgcHJvZCwgc2NhbGUpIHtcbiAgZnVuY3Rpb24gZXhhY3RJblNwaGVyZTUobTAsIG0xLCBtMiwgbTMsIG00KSB7XG4gICAgdmFyIHcwID0gc3VtKHByb2QobTBbMF0sIG0wWzBdKSwgc3VtKHByb2QobTBbMV0sIG0wWzFdKSwgcHJvZChtMFsyXSwgbTBbMl0pKSlcbiAgICB2YXIgdzBtMSA9IHNjYWxlKHcwLCBtMVswXSlcbiAgICB2YXIgdzBtMiA9IHNjYWxlKHcwLCBtMlswXSlcbiAgICB2YXIgdzBtMyA9IHNjYWxlKHcwLCBtM1swXSlcbiAgICB2YXIgdzBtNCA9IHNjYWxlKHcwLCBtNFswXSlcbiAgICB2YXIgdzEgPSBzdW0ocHJvZChtMVswXSwgbTFbMF0pLCBzdW0ocHJvZChtMVsxXSwgbTFbMV0pLCBwcm9kKG0xWzJdLCBtMVsyXSkpKVxuICAgIHZhciB3MW0wID0gc2NhbGUodzEsIG0wWzBdKVxuICAgIHZhciB3MW0yID0gc2NhbGUodzEsIG0yWzBdKVxuICAgIHZhciB3MW0zID0gc2NhbGUodzEsIG0zWzBdKVxuICAgIHZhciB3MW00ID0gc2NhbGUodzEsIG00WzBdKVxuICAgIHZhciB3MiA9IHN1bShwcm9kKG0yWzBdLCBtMlswXSksIHN1bShwcm9kKG0yWzFdLCBtMlsxXSksIHByb2QobTJbMl0sIG0yWzJdKSkpXG4gICAgdmFyIHcybTAgPSBzY2FsZSh3MiwgbTBbMF0pXG4gICAgdmFyIHcybTEgPSBzY2FsZSh3MiwgbTFbMF0pXG4gICAgdmFyIHcybTMgPSBzY2FsZSh3MiwgbTNbMF0pXG4gICAgdmFyIHcybTQgPSBzY2FsZSh3MiwgbTRbMF0pXG4gICAgdmFyIHczID0gc3VtKHByb2QobTNbMF0sIG0zWzBdKSwgc3VtKHByb2QobTNbMV0sIG0zWzFdKSwgcHJvZChtM1syXSwgbTNbMl0pKSlcbiAgICB2YXIgdzNtMCA9IHNjYWxlKHczLCBtMFswXSlcbiAgICB2YXIgdzNtMSA9IHNjYWxlKHczLCBtMVswXSlcbiAgICB2YXIgdzNtMiA9IHNjYWxlKHczLCBtMlswXSlcbiAgICB2YXIgdzNtNCA9IHNjYWxlKHczLCBtNFswXSlcbiAgICB2YXIgdzQgPSBzdW0ocHJvZChtNFswXSwgbTRbMF0pLCBzdW0ocHJvZChtNFsxXSwgbTRbMV0pLCBwcm9kKG00WzJdLCBtNFsyXSkpKVxuICAgIHZhciB3NG0wID0gc2NhbGUodzQsIG0wWzBdKVxuICAgIHZhciB3NG0xID0gc2NhbGUodzQsIG0xWzBdKVxuICAgIHZhciB3NG0yID0gc2NhbGUodzQsIG0yWzBdKVxuICAgIHZhciB3NG0zID0gc2NhbGUodzQsIG0zWzBdKVxuICAgIHZhciBwID0gc3VtKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG00WzFdKSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgbTNbMl0pKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIC1tNFsyXSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTFbMl0pKSkpLCBzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTNbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCAtbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIG0wWzJdKSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCAtbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW0zWzJdKSkpKSlcbiAgICB2YXIgbiA9IHN1bShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTRbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG00WzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW00WzJdKSkpKVxuICAgIHZhciBkID0gZGlmZihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxuXG4gICAgcmV0dXJuIGV4YWN0SW5TcGhlcmU1XG59XG5cbmZ1bmN0aW9uIGluU3BoZXJlNihzdW0sIGRpZmYsIHByb2QsIHNjYWxlKSB7XG4gIGZ1bmN0aW9uIGV4YWN0SW5TcGhlcmU2KG0wLCBtMSwgbTIsIG0zLCBtNCwgbTUpIHtcbiAgICB2YXIgdzAgPSBzdW0oc3VtKHByb2QobTBbMF0sIG0wWzBdKSwgcHJvZChtMFsxXSwgbTBbMV0pKSwgc3VtKHByb2QobTBbMl0sIG0wWzJdKSwgcHJvZChtMFszXSwgbTBbM10pKSlcbiAgICB2YXIgdzBtMSA9IHNjYWxlKHcwLCBtMVswXSlcbiAgICB2YXIgdzBtMiA9IHNjYWxlKHcwLCBtMlswXSlcbiAgICB2YXIgdzBtMyA9IHNjYWxlKHcwLCBtM1swXSlcbiAgICB2YXIgdzBtNCA9IHNjYWxlKHcwLCBtNFswXSlcbiAgICB2YXIgdzBtNSA9IHNjYWxlKHcwLCBtNVswXSlcbiAgICB2YXIgdzEgPSBzdW0oc3VtKHByb2QobTFbMF0sIG0xWzBdKSwgcHJvZChtMVsxXSwgbTFbMV0pKSwgc3VtKHByb2QobTFbMl0sIG0xWzJdKSwgcHJvZChtMVszXSwgbTFbM10pKSlcbiAgICB2YXIgdzFtMCA9IHNjYWxlKHcxLCBtMFswXSlcbiAgICB2YXIgdzFtMiA9IHNjYWxlKHcxLCBtMlswXSlcbiAgICB2YXIgdzFtMyA9IHNjYWxlKHcxLCBtM1swXSlcbiAgICB2YXIgdzFtNCA9IHNjYWxlKHcxLCBtNFswXSlcbiAgICB2YXIgdzFtNSA9IHNjYWxlKHcxLCBtNVswXSlcbiAgICB2YXIgdzIgPSBzdW0oc3VtKHByb2QobTJbMF0sIG0yWzBdKSwgcHJvZChtMlsxXSwgbTJbMV0pKSwgc3VtKHByb2QobTJbMl0sIG0yWzJdKSwgcHJvZChtMlszXSwgbTJbM10pKSlcbiAgICB2YXIgdzJtMCA9IHNjYWxlKHcyLCBtMFswXSlcbiAgICB2YXIgdzJtMSA9IHNjYWxlKHcyLCBtMVswXSlcbiAgICB2YXIgdzJtMyA9IHNjYWxlKHcyLCBtM1swXSlcbiAgICB2YXIgdzJtNCA9IHNjYWxlKHcyLCBtNFswXSlcbiAgICB2YXIgdzJtNSA9IHNjYWxlKHcyLCBtNVswXSlcbiAgICB2YXIgdzMgPSBzdW0oc3VtKHByb2QobTNbMF0sIG0zWzBdKSwgcHJvZChtM1sxXSwgbTNbMV0pKSwgc3VtKHByb2QobTNbMl0sIG0zWzJdKSwgcHJvZChtM1szXSwgbTNbM10pKSlcbiAgICB2YXIgdzNtMCA9IHNjYWxlKHczLCBtMFswXSlcbiAgICB2YXIgdzNtMSA9IHNjYWxlKHczLCBtMVswXSlcbiAgICB2YXIgdzNtMiA9IHNjYWxlKHczLCBtMlswXSlcbiAgICB2YXIgdzNtNCA9IHNjYWxlKHczLCBtNFswXSlcbiAgICB2YXIgdzNtNSA9IHNjYWxlKHczLCBtNVswXSlcbiAgICB2YXIgdzQgPSBzdW0oc3VtKHByb2QobTRbMF0sIG00WzBdKSwgcHJvZChtNFsxXSwgbTRbMV0pKSwgc3VtKHByb2QobTRbMl0sIG00WzJdKSwgcHJvZChtNFszXSwgbTRbM10pKSlcbiAgICB2YXIgdzRtMCA9IHNjYWxlKHc0LCBtMFswXSlcbiAgICB2YXIgdzRtMSA9IHNjYWxlKHc0LCBtMVswXSlcbiAgICB2YXIgdzRtMiA9IHNjYWxlKHc0LCBtMlswXSlcbiAgICB2YXIgdzRtMyA9IHNjYWxlKHc0LCBtM1swXSlcbiAgICB2YXIgdzRtNSA9IHNjYWxlKHc0LCBtNVswXSlcbiAgICB2YXIgdzUgPSBzdW0oc3VtKHByb2QobTVbMF0sIG01WzBdKSwgcHJvZChtNVsxXSwgbTVbMV0pKSwgc3VtKHByb2QobTVbMl0sIG01WzJdKSwgcHJvZChtNVszXSwgbTVbM10pKSlcbiAgICB2YXIgdzVtMCA9IHNjYWxlKHc1LCBtMFswXSlcbiAgICB2YXIgdzVtMSA9IHNjYWxlKHc1LCBtMVswXSlcbiAgICB2YXIgdzVtMiA9IHNjYWxlKHc1LCBtMlswXSlcbiAgICB2YXIgdzVtMyA9IHNjYWxlKHc1LCBtM1swXSlcbiAgICB2YXIgdzVtNCA9IHNjYWxlKHc1LCBtNFswXSlcbiAgICB2YXIgcCA9IHN1bShzdW0oc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0zWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG01WzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtNVsxXSkpKSwgLW0zWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG00WzFdKSkpLCAtbTVbMl0pKSksIG0xWzNdKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0zWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgLW0zWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCAtbTVbMl0pKSksIC1tMlszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCAtbTVbMl0pKSksIG0zWzNdKSkpLCBzdW0oc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCAtbTVbMl0pKSksIC1tNFszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG00WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCAtbTRbMl0pKSksIG01WzNdKSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0zWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCBtNVsxXSkpKSwgLW0zWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTVbMl0pKSksIC1tMVszXSkpKSksIHN1bShzdW0oc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCBtNVsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG00WzFdKSkpLCAtbTVbMl0pKSksIG0zWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNVsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIC1tNVsyXSkpKSwgLW00WzNdKSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtNVszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCAtbTVbMl0pKSksIG0wWzNdKSkpLCBzdW0oc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCAtbTVbMl0pKSksIC1tMVszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCAtbTVbMl0pKSksIG0yWzNdKSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW01WzJdKSkpLCAtbTNbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW0zWzJdKSkpLCBtNVszXSkpKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtMFszXSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTJbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtM1szXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCAtbTRbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtNVszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIG0xWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTBbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTFbM10pKSkpLCBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtMlszXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTVbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTVbMl0pKSksIC1tNFszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNFsyXSkpKSwgbTVbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtMFszXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCAtbTFbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtMlszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNFsyXSkpKSwgLW0zWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tM1syXSkpKSwgbTRbM10pKSkpKVxuICAgIHZhciBkID0gZGlmZihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxuICByZXR1cm4gZXhhY3RJblNwaGVyZTZcbn1cblxudmFyIENBQ0hFRCA9IFtcbiAgaW5TcGhlcmUwLFxuICBpblNwaGVyZTEsXG4gIGluU3BoZXJlMlxuXVxuXG5mdW5jdGlvbiBzbG93SW5TcGhlcmUoYXJncykge1xuICB2YXIgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF1cbiAgaWYoIXByb2MpIHtcbiAgICBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXSA9IG9yaWVudGF0aW9uKGFyZ3MubGVuZ3RoKVxuICB9XG4gIHJldHVybiBwcm9jLmFwcGx5KHVuZGVmaW5lZCwgYXJncylcbn1cblxuZnVuY3Rpb24gcHJvYyhzbG93LCBvMCwgbzEsIG8yLCBvMywgbzQsIG81LCBvNikge1xuICBmdW5jdGlvbiB0ZXN0SW5TcGhlcmUoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG8yKGEwLCBhMSlcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG8zKGEwLCBhMSwgYTIpXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBvNChhMCwgYTEsIGEyLCBhMylcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIG81KGEwLCBhMSwgYTIsIGEzLCBhNClcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIG82KGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpXG4gICAgfVxuXG4gICAgdmFyIHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICByZXR1cm4gc2xvdyhzKVxuICB9XG4gIHJldHVybiB0ZXN0SW5TcGhlcmVcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVJblNwaGVyZVRlc3QoKSB7XG4gIHdoaWxlKENBQ0hFRC5sZW5ndGggPD0gTlVNX0VYUEFORCkge1xuICAgIENBQ0hFRC5wdXNoKG9yaWVudGF0aW9uKENBQ0hFRC5sZW5ndGgpKVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jLmFwcGx5KHVuZGVmaW5lZCwgW3Nsb3dJblNwaGVyZV0uY29uY2F0KENBQ0hFRCkpXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBtb2R1bGUuZXhwb3J0c1tpXSA9IENBQ0hFRFtpXVxuICB9XG59XG5cbmdlbmVyYXRlSW5TcGhlcmVUZXN0KCkiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG52YXIgcm9idXN0U2NhbGUgPSByZXF1aXJlKFwicm9idXN0LXNjYWxlXCIpXG52YXIgcm9idXN0U3VidHJhY3QgPSByZXF1aXJlKFwicm9idXN0LXN1YnRyYWN0XCIpXG5cbnZhciBOVU1fRVhQQU5EID0gNVxuXG52YXIgRVBTSUxPTiAgICAgPSAxLjExMDIyMzAyNDYyNTE1NjVlLTE2XG52YXIgRVJSQk9VTkQzICAgPSAoMy4wICsgMTYuMCAqIEVQU0lMT04pICogRVBTSUxPTlxudmFyIEVSUkJPVU5ENCAgID0gKDcuMCArIDU2LjAgKiBFUFNJTE9OKSAqIEVQU0lMT05cblxuZnVuY3Rpb24gb3JpZW50YXRpb25fMyhzdW0sIHByb2QsIHNjYWxlLCBzdWIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9yaWVudGF0aW9uM0V4YWN0KG0wLCBtMSwgbTIpIHtcbiAgICB2YXIgcCA9IHN1bShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSkpXG4gICAgdmFyIG4gPSBzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKVxuICAgIHZhciBkID0gc3ViKHAsIG4pXG4gICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXVxuICB9XG59XG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uXzQoc3VtLCBwcm9kLCBzY2FsZSwgc3ViKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmllbnRhdGlvbjRFeGFjdChtMCwgbTEsIG0yLCBtMykge1xuICAgIHZhciBwID0gc3VtKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtM1syXSkpKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0zWzJdKSkpKVxuICAgIHZhciBuID0gc3VtKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCBtM1syXSkpKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0yWzJdKSkpKVxuICAgIHZhciBkID0gc3ViKHAsIG4pXG4gICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXVxuICB9XG59XG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uXzUoc3VtLCBwcm9kLCBzY2FsZSwgc3ViKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmllbnRhdGlvbjVFeGFjdChtMCwgbTEsIG0yLCBtMywgbTQpIHtcbiAgICB2YXIgcCA9IHN1bShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTJbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0yWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMlswXSkpLCBtNFsyXSkpKSwgbTFbM10pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0zWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtM1swXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0zWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG00WzJdKSkpLCAtbTJbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0yWzBdKSksIG0xWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMVswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTRbMl0pKSksIG0zWzNdKSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG0zWzJdKSkpLCAtbTRbM10pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0zWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtM1swXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0zWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG00WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgLW0xWzNdKSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTRbMl0pKSksIG0zWzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtM1syXSkpKSwgLW00WzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG0zWzJdKSkpLCBtMFszXSkpKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCBtM1syXSkpKSwgLW0xWzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtM1syXSkpKSwgbTJbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTJbMl0pKSksIC1tM1szXSkpKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTNbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0zWzBdKSksIG0yWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCAtbTNbMl0pLCBzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTRbMl0pKSksIG0wWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0zWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtM1swXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTBbMF0pKSwgLW0zWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIG00WzJdKSkpLCAtbTJbM10pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTJbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgbTNbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIC1tNFszXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0yWzBdKSksIG0xWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMVswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTRbMl0pKSksIG0wWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTBbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSksIG00WzJdKSkpLCAtbTFbM10pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgbTJbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTJbMl0pKSksIC1tNFszXSkpKSlcbiAgICB2YXIgZCA9IHN1YihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbihuKSB7XG4gIHZhciBmbiA9XG4gICAgbiA9PT0gMyA/IG9yaWVudGF0aW9uXzMgOlxuICAgIG4gPT09IDQgPyBvcmllbnRhdGlvbl80IDogb3JpZW50YXRpb25fNVxuXG4gIHJldHVybiBmbihyb2J1c3RTdW0sIHR3b1Byb2R1Y3QsIHJvYnVzdFNjYWxlLCByb2J1c3RTdWJ0cmFjdClcbn1cblxudmFyIG9yaWVudGF0aW9uM0V4YWN0ID0gb3JpZW50YXRpb24oMylcbnZhciBvcmllbnRhdGlvbjRFeGFjdCA9IG9yaWVudGF0aW9uKDQpXG5cbnZhciBDQUNIRUQgPSBbXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMCgpIHsgcmV0dXJuIDAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24xKCkgeyByZXR1cm4gMCB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjIoYSwgYikge1xuICAgIHJldHVybiBiWzBdIC0gYVswXVxuICB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjMoYSwgYiwgYykge1xuICAgIHZhciBsID0gKGFbMV0gLSBjWzFdKSAqIChiWzBdIC0gY1swXSlcbiAgICB2YXIgciA9IChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGNbMV0pXG4gICAgdmFyIGRldCA9IGwgLSByXG4gICAgdmFyIHNcbiAgICBpZihsID4gMCkge1xuICAgICAgaWYociA8PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBsICsgclxuICAgICAgfVxuICAgIH0gZWxzZSBpZihsIDwgMCkge1xuICAgICAgaWYociA+PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSAtKGwgKyByKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGV0XG4gICAgfVxuICAgIHZhciB0b2wgPSBFUlJCT1VORDMgKiBzXG4gICAgaWYoZGV0ID49IHRvbCB8fCBkZXQgPD0gLXRvbCkge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICByZXR1cm4gb3JpZW50YXRpb24zRXhhY3QoYSwgYiwgYylcbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb240KGEsYixjLGQpIHtcbiAgICB2YXIgYWR4ID0gYVswXSAtIGRbMF1cbiAgICB2YXIgYmR4ID0gYlswXSAtIGRbMF1cbiAgICB2YXIgY2R4ID0gY1swXSAtIGRbMF1cbiAgICB2YXIgYWR5ID0gYVsxXSAtIGRbMV1cbiAgICB2YXIgYmR5ID0gYlsxXSAtIGRbMV1cbiAgICB2YXIgY2R5ID0gY1sxXSAtIGRbMV1cbiAgICB2YXIgYWR6ID0gYVsyXSAtIGRbMl1cbiAgICB2YXIgYmR6ID0gYlsyXSAtIGRbMl1cbiAgICB2YXIgY2R6ID0gY1syXSAtIGRbMl1cbiAgICB2YXIgYmR4Y2R5ID0gYmR4ICogY2R5XG4gICAgdmFyIGNkeGJkeSA9IGNkeCAqIGJkeVxuICAgIHZhciBjZHhhZHkgPSBjZHggKiBhZHlcbiAgICB2YXIgYWR4Y2R5ID0gYWR4ICogY2R5XG4gICAgdmFyIGFkeGJkeSA9IGFkeCAqIGJkeVxuICAgIHZhciBiZHhhZHkgPSBiZHggKiBhZHlcbiAgICB2YXIgZGV0ID0gYWR6ICogKGJkeGNkeSAtIGNkeGJkeSlcbiAgICAgICAgICAgICsgYmR6ICogKGNkeGFkeSAtIGFkeGNkeSlcbiAgICAgICAgICAgICsgY2R6ICogKGFkeGJkeSAtIGJkeGFkeSlcbiAgICB2YXIgcGVybWFuZW50ID0gKE1hdGguYWJzKGJkeGNkeSkgKyBNYXRoLmFicyhjZHhiZHkpKSAqIE1hdGguYWJzKGFkeilcbiAgICAgICAgICAgICAgICAgICsgKE1hdGguYWJzKGNkeGFkeSkgKyBNYXRoLmFicyhhZHhjZHkpKSAqIE1hdGguYWJzKGJkeilcbiAgICAgICAgICAgICAgICAgICsgKE1hdGguYWJzKGFkeGJkeSkgKyBNYXRoLmFicyhiZHhhZHkpKSAqIE1hdGguYWJzKGNkeilcbiAgICB2YXIgdG9sID0gRVJSQk9VTkQ0ICogcGVybWFuZW50XG4gICAgaWYgKChkZXQgPiB0b2wpIHx8ICgtZGV0ID4gdG9sKSkge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICByZXR1cm4gb3JpZW50YXRpb240RXhhY3QoYSxiLGMsZClcbiAgfVxuXVxuXG5mdW5jdGlvbiBzbG93T3JpZW50KGFyZ3MpIHtcbiAgdmFyIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdXG4gIGlmKCFwcm9jKSB7XG4gICAgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF0gPSBvcmllbnRhdGlvbihhcmdzLmxlbmd0aClcbiAgfVxuICByZXR1cm4gcHJvYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIHByb2MgKHNsb3csIG8wLCBvMSwgbzIsIG8zLCBvNCwgbzUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE9yaWVudGF0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG8yKGEwLCBhMSlcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG8zKGEwLCBhMSwgYTIpXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBvNChhMCwgYTEsIGEyLCBhMylcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIG81KGEwLCBhMSwgYTIsIGEzLCBhNClcbiAgICB9XG5cbiAgICB2YXIgcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHJldHVybiBzbG93KHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVPcmllbnRhdGlvblByb2MoKSB7XG4gIHdoaWxlKENBQ0hFRC5sZW5ndGggPD0gTlVNX0VYUEFORCkge1xuICAgIENBQ0hFRC5wdXNoKG9yaWVudGF0aW9uKENBQ0hFRC5sZW5ndGgpKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93T3JpZW50XS5jb25jYXQoQ0FDSEVEKSlcbiAgZm9yKHZhciBpPTA7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIG1vZHVsZS5leHBvcnRzW2ldID0gQ0FDSEVEW2ldXG4gIH1cbn1cblxuZ2VuZXJhdGVPcmllbnRhdGlvblByb2MoKSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciByb2J1c3RTdW0gPSByZXF1aXJlKFwicm9idXN0LXN1bVwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJvYnVzdFByb2R1Y3RcblxuZnVuY3Rpb24gcm9idXN0UHJvZHVjdChhLCBiKSB7XG4gIGlmKGEubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJvYnVzdFNjYWxlKGIsIGFbMF0pXG4gIH1cbiAgaWYoYi5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcm9idXN0U2NhbGUoYSwgYlswXSlcbiAgfVxuICBpZihhLmxlbmd0aCA9PT0gMCB8fCBiLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbMF1cbiAgfVxuICB2YXIgciA9IFswXVxuICBpZihhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgZm9yKHZhciBpPTA7IGk8YS5sZW5ndGg7ICsraSkge1xuICAgICAgciA9IHJvYnVzdFN1bShyLCByb2J1c3RTY2FsZShiLCBhW2ldKSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBpPTA7IGk8Yi5sZW5ndGg7ICsraSkge1xuICAgICAgciA9IHJvYnVzdFN1bShyLCByb2J1c3RTY2FsZShhLCBiW2ldKSlcbiAgICB9ICAgIFxuICB9XG4gIHJldHVybiByXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKFwidHdvLXByb2R1Y3RcIilcbnZhciB0d29TdW0gPSByZXF1aXJlKFwidHdvLXN1bVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjYWxlTGluZWFyRXhwYW5zaW9uXG5cbmZ1bmN0aW9uIHNjYWxlTGluZWFyRXhwYW5zaW9uKGUsIHNjYWxlKSB7XG4gIHZhciBuID0gZS5sZW5ndGhcbiAgaWYobiA9PT0gMSkge1xuICAgIHZhciB0cyA9IHR3b1Byb2R1Y3QoZVswXSwgc2NhbGUpXG4gICAgaWYodHNbMF0pIHtcbiAgICAgIHJldHVybiB0c1xuICAgIH1cbiAgICByZXR1cm4gWyB0c1sxXSBdXG4gIH1cbiAgdmFyIGcgPSBuZXcgQXJyYXkoMiAqIG4pXG4gIHZhciBxID0gWzAuMSwgMC4xXVxuICB2YXIgdCA9IFswLjEsIDAuMV1cbiAgdmFyIGNvdW50ID0gMFxuICB0d29Qcm9kdWN0KGVbMF0sIHNjYWxlLCBxKVxuICBpZihxWzBdKSB7XG4gICAgZ1tjb3VudCsrXSA9IHFbMF1cbiAgfVxuICBmb3IodmFyIGk9MTsgaTxuOyArK2kpIHtcbiAgICB0d29Qcm9kdWN0KGVbaV0sIHNjYWxlLCB0KVxuICAgIHZhciBwcSA9IHFbMV1cbiAgICB0d29TdW0ocHEsIHRbMF0sIHEpXG4gICAgaWYocVswXSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHFbMF1cbiAgICB9XG4gICAgdmFyIGEgPSB0WzFdXG4gICAgdmFyIGIgPSBxWzFdXG4gICAgdmFyIHggPSBhICsgYlxuICAgIHZhciBidiA9IHggLSBhXG4gICAgdmFyIHkgPSBiIC0gYnZcbiAgICBxWzFdID0geFxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICB9XG4gIGlmKHFbMV0pIHtcbiAgICBnW2NvdW50KytdID0gcVsxXVxuICB9XG4gIGlmKGNvdW50ID09PSAwKSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlZ21lbnRzSW50ZXJzZWN0XG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpWzNdXG5cbmZ1bmN0aW9uIGNoZWNrQ29sbGluZWFyKGEwLCBhMSwgYjAsIGIxKSB7XG5cbiAgZm9yKHZhciBkPTA7IGQ8MjsgKytkKSB7XG4gICAgdmFyIHgwID0gYTBbZF1cbiAgICB2YXIgeTAgPSBhMVtkXVxuICAgIHZhciBsMCA9IE1hdGgubWluKHgwLCB5MClcbiAgICB2YXIgaDAgPSBNYXRoLm1heCh4MCwgeTApICAgIFxuXG4gICAgdmFyIHgxID0gYjBbZF1cbiAgICB2YXIgeTEgPSBiMVtkXVxuICAgIHZhciBsMSA9IE1hdGgubWluKHgxLCB5MSlcbiAgICB2YXIgaDEgPSBNYXRoLm1heCh4MSwgeTEpICAgIFxuXG4gICAgaWYoaDEgPCBsMCB8fCBoMCA8IGwxKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzZWdtZW50c0ludGVyc2VjdChhMCwgYTEsIGIwLCBiMSkge1xuICB2YXIgeDAgPSBvcmllbnQoYTAsIGIwLCBiMSlcbiAgdmFyIHkwID0gb3JpZW50KGExLCBiMCwgYjEpXG4gIGlmKCh4MCA+IDAgJiYgeTAgPiAwKSB8fCAoeDAgPCAwICYmIHkwIDwgMCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciB4MSA9IG9yaWVudChiMCwgYTAsIGExKVxuICB2YXIgeTEgPSBvcmllbnQoYjEsIGEwLCBhMSlcbiAgaWYoKHgxID4gMCAmJiB5MSA+IDApIHx8ICh4MSA8IDAgJiYgeTEgPCAwKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy9DaGVjayBmb3IgZGVnZW5lcmF0ZSBjb2xsaW5lYXIgY2FzZVxuICBpZih4MCA9PT0gMCAmJiB5MCA9PT0gMCAmJiB4MSA9PT0gMCAmJiB5MSA9PT0gMCkge1xuICAgIHJldHVybiBjaGVja0NvbGxpbmVhcihhMCwgYTEsIGIwLCBiMSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByb2J1c3RTdWJ0cmFjdFxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gcm9idXN0U3VidHJhY3QoZSwgZikge1xuICB2YXIgbmUgPSBlLmxlbmd0aHwwXG4gIHZhciBuZiA9IGYubGVuZ3RofDBcbiAgaWYobmUgPT09IDEgJiYgbmYgPT09IDEpIHtcbiAgICByZXR1cm4gc2NhbGFyU2NhbGFyKGVbMF0sIC1mWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSAtZltmcHRyXVxuICB2YXIgZmEgPSBhYnMoZmkpXG4gIHZhciBhLCBiXG4gIGlmKGVhIDwgZmEpIHtcbiAgICBiID0gZWlcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgZWEgPSBhYnMoZWkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGIgPSBmaVxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSAtZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIGlmKChlcHRyIDwgbmUgJiYgZWEgPCBmYSkgfHwgKGZwdHIgPj0gbmYpKSB7XG4gICAgYSA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSAtZltmcHRyXVxuICAgICAgICBmYSA9IGFicyhmaSlcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICB9XG4gIHdoaWxlKGVwdHIgPCBuZSkge1xuICAgIGEgPSBlaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgIH1cbiAgfVxuICB3aGlsZShmcHRyIDwgbmYpIHtcbiAgICBhID0gZmlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfSBcbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSAtZltmcHRyXVxuICAgIH1cbiAgfVxuICBpZihxMCkge1xuICAgIGdbY291bnQrK10gPSBxMFxuICB9XG4gIGlmKHExKSB7XG4gICAgZ1tjb3VudCsrXSA9IHExXG4gIH1cbiAgaWYoIWNvdW50KSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMCAgXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gbGluZWFyRXhwYW5zaW9uU3VtXG5cbi8vRWFzeSBjYXNlOiBBZGQgdHdvIHNjYWxhcnNcbmZ1bmN0aW9uIHNjYWxhclNjYWxhcihhLCBiKSB7XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIGF2ID0geCAtIGJ2XG4gIHZhciBiciA9IGIgLSBidlxuICB2YXIgYXIgPSBhIC0gYXZcbiAgdmFyIHkgPSBhciArIGJyXG4gIGlmKHkpIHtcbiAgICByZXR1cm4gW3ksIHhdXG4gIH1cbiAgcmV0dXJuIFt4XVxufVxuXG5mdW5jdGlvbiBsaW5lYXJFeHBhbnNpb25TdW0oZSwgZikge1xuICB2YXIgbmUgPSBlLmxlbmd0aHwwXG4gIHZhciBuZiA9IGYubGVuZ3RofDBcbiAgaWYobmUgPT09IDEgJiYgbmYgPT09IDEpIHtcbiAgICByZXR1cm4gc2NhbGFyU2NhbGFyKGVbMF0sIGZbMF0pXG4gIH1cbiAgdmFyIG4gPSBuZSArIG5mXG4gIHZhciBnID0gbmV3IEFycmF5KG4pXG4gIHZhciBjb3VudCA9IDBcbiAgdmFyIGVwdHIgPSAwXG4gIHZhciBmcHRyID0gMFxuICB2YXIgYWJzID0gTWF0aC5hYnNcbiAgdmFyIGVpID0gZVtlcHRyXVxuICB2YXIgZWEgPSBhYnMoZWkpXG4gIHZhciBmaSA9IGZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIGlmKChlcHRyIDwgbmUgJiYgZWEgPCBmYSkgfHwgKGZwdHIgPj0gbmYpKSB7XG4gICAgYSA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIHkgPSBiIC0gYnZcbiAgdmFyIHEwID0geVxuICB2YXIgcTEgPSB4XG4gIHZhciBfeCwgX2J2LCBfYXYsIF9iciwgX2FyXG4gIHdoaWxlKGVwdHIgPCBuZSAmJiBmcHRyIDwgbmYpIHtcbiAgICBpZihlYSA8IGZhKSB7XG4gICAgICBhID0gZWlcbiAgICAgIGVwdHIgKz0gMVxuICAgICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgICBlYSA9IGFicyhlaSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGZpXG4gICAgICBmcHRyICs9IDFcbiAgICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgICBmaSA9IGZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgIH1cbiAgfVxuICBpZihxMCkge1xuICAgIGdbY291bnQrK10gPSBxMFxuICB9XG4gIGlmKHExKSB7XG4gICAgZ1tjb3VudCsrXSA9IHExXG4gIH1cbiAgaWYoIWNvdW50KSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMCAgXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2lnbnVtKHgpIHtcbiAgaWYoeCA8IDApIHsgcmV0dXJuIC0xIH1cbiAgaWYoeCA+IDApIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMC4wXG59IiwiXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pb25GaW5kO1xuXG5mdW5jdGlvbiBVbmlvbkZpbmQoY291bnQpIHtcbiAgdGhpcy5yb290cyA9IG5ldyBBcnJheShjb3VudCk7XG4gIHRoaXMucmFua3MgPSBuZXcgQXJyYXkoY291bnQpO1xuICBcbiAgZm9yKHZhciBpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHRoaXMucm9vdHNbaV0gPSBpO1xuICAgIHRoaXMucmFua3NbaV0gPSAwO1xuICB9XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJvb3RzLmxlbmd0aDtcbn1cblxuVW5pb25GaW5kLnByb3RvdHlwZS5tYWtlU2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gdGhpcy5yb290cy5sZW5ndGg7XG4gIHRoaXMucm9vdHMucHVzaChuKTtcbiAgdGhpcy5yYW5rcy5wdXNoKDApO1xuICByZXR1cm4gbjtcbn1cblxuVW5pb25GaW5kLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcm9vdHMgPSB0aGlzLnJvb3RzO1xuICB3aGlsZShyb290c1t4XSAhPT0geCkge1xuICAgIHZhciB5ID0gcm9vdHNbeF07XG4gICAgcm9vdHNbeF0gPSByb290c1t5XTtcbiAgICB4ID0geTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuVW5pb25GaW5kLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgeHIgPSB0aGlzLmZpbmQoeClcbiAgICAsIHlyID0gdGhpcy5maW5kKHkpO1xuICBpZih4ciA9PT0geXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJhbmtzID0gdGhpcy5yYW5rc1xuICAgICwgcm9vdHMgPSB0aGlzLnJvb3RzXG4gICAgLCB4ZCAgICA9IHJhbmtzW3hyXVxuICAgICwgeWQgICAgPSByYW5rc1t5cl07XG4gIGlmKHhkIDwgeWQpIHtcbiAgICByb290c1t4cl0gPSB5cjtcbiAgfSBlbHNlIGlmKHlkIDwgeGQpIHtcbiAgICByb290c1t5cl0gPSB4cjtcbiAgfSBlbHNlIHtcbiAgICByb290c1t5cl0gPSB4cjtcbiAgICArK3JhbmtzW3hyXTtcbiAgfVxufVxuXG4iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxudmFyIGJpdHMgICAgICA9IHJlcXVpcmUoXCJiaXQtdHdpZGRsZVwiKVxuICAsIFVuaW9uRmluZCA9IHJlcXVpcmUoXCJ1bmlvbi1maW5kXCIpXG5cbi8vUmV0dXJucyB0aGUgZGltZW5zaW9uIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBkaW1lbnNpb24oY2VsbHMpIHtcbiAgdmFyIGQgPSAwXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBkID0gbWF4KGQsIGNlbGxzW2ldLmxlbmd0aClcbiAgfVxuICByZXR1cm4gZC0xXG59XG5leHBvcnRzLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuXG4vL0NvdW50cyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIGZhY2VzXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKGNlbGxzKSB7XG4gIHZhciB2YyA9IC0xXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsIGpsPWMubGVuZ3RoOyBqPGpsOyArK2opIHtcbiAgICAgIHZjID0gbWF4KHZjLCBjW2pdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmMrMVxufVxuZXhwb3J0cy5jb3VudFZlcnRpY2VzID0gY291bnRWZXJ0aWNlc1xuXG4vL1JldHVybnMgYSBkZWVwIGNvcHkgb2YgY2VsbHNcbmZ1bmN0aW9uIGNsb25lQ2VsbHMoY2VsbHMpIHtcbiAgdmFyIG5jZWxscyA9IG5ldyBBcnJheShjZWxscy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIG5jZWxsc1tpXSA9IGNlbGxzW2ldLnNsaWNlKDApXG4gIH1cbiAgcmV0dXJuIG5jZWxsc1xufVxuZXhwb3J0cy5jbG9uZUNlbGxzID0gY2xvbmVDZWxsc1xuXG4vL1JhbmtzIGEgcGFpciBvZiBjZWxscyB1cCB0byBwZXJtdXRhdGlvblxuZnVuY3Rpb24gY29tcGFyZUNlbGxzKGEsIGIpIHtcbiAgdmFyIG4gPSBhLmxlbmd0aFxuICAgICwgdCA9IGEubGVuZ3RoIC0gYi5sZW5ndGhcbiAgICAsIG1pbiA9IE1hdGgubWluXG4gIGlmKHQpIHtcbiAgICByZXR1cm4gdFxuICB9XG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHZhciBkID0gYVswXSthWzFdLWJbMF0tYlsxXVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihhWzBdLGFbMV0pIC0gbWluKGJbMF0sYlsxXSlcbiAgICBjYXNlIDM6XG4gICAgICB2YXIgbDEgPSBhWzBdK2FbMV1cbiAgICAgICAgLCBtMSA9IGJbMF0rYlsxXVxuICAgICAgZCA9IGwxK2FbMl0gLSAobTErYlsyXSlcbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHZhciBsMCA9IG1pbihhWzBdLCBhWzFdKVxuICAgICAgICAsIG0wID0gbWluKGJbMF0sIGJbMV0pXG4gICAgICAgICwgZCAgPSBtaW4obDAsIGFbMl0pIC0gbWluKG0wLCBiWzJdKVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihsMCthWzJdLCBsMSkgLSBtaW4obTArYlsyXSwgbTEpXG4gICAgXG4gICAgLy9UT0RPOiBNYXliZSBvcHRpbWl6ZSBuPTQgYXMgd2VsbD9cbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGFzID0gYS5zbGljZSgwKVxuICAgICAgYXMuc29ydCgpXG4gICAgICB2YXIgYnMgPSBiLnNsaWNlKDApXG4gICAgICBicy5zb3J0KClcbiAgICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgICB0ID0gYXNbaV0gLSBic1tpXVxuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgfVxufVxuZXhwb3J0cy5jb21wYXJlQ2VsbHMgPSBjb21wYXJlQ2VsbHNcblxuZnVuY3Rpb24gY29tcGFyZVppcHBlZChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlQ2VsbHMoYVswXSwgYlswXSlcbn1cblxuLy9QdXRzIGEgY2VsbCBjb21wbGV4IGludG8gbm9ybWFsIG9yZGVyIGZvciB0aGUgcHVycG9zZXMgb2YgZmluZENlbGwgcXVlcmllc1xuZnVuY3Rpb24gbm9ybWFsaXplKGNlbGxzLCBhdHRyKSB7XG4gIGlmKGF0dHIpIHtcbiAgICB2YXIgbGVuID0gY2VsbHMubGVuZ3RoXG4gICAgdmFyIHppcHBlZCA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgIHppcHBlZFtpXSA9IFtjZWxsc1tpXSwgYXR0cltpXV1cbiAgICB9XG4gICAgemlwcGVkLnNvcnQoY29tcGFyZVppcHBlZClcbiAgICBmb3IodmFyIGk9MDsgaTxsZW47ICsraSkge1xuICAgICAgY2VsbHNbaV0gPSB6aXBwZWRbaV1bMF1cbiAgICAgIGF0dHJbaV0gPSB6aXBwZWRbaV1bMV1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzXG4gIH0gZWxzZSB7XG4gICAgY2VsbHMuc29ydChjb21wYXJlQ2VsbHMpXG4gICAgcmV0dXJuIGNlbGxzXG4gIH1cbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplXG5cbi8vUmVtb3ZlcyBhbGwgZHVwbGljYXRlIGNlbGxzIGluIHRoZSBjb21wbGV4XG5mdW5jdGlvbiB1bmlxdWUoY2VsbHMpIHtcbiAgaWYoY2VsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGNlbGxzLmxlbmd0aFxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIHZhciBhID0gY2VsbHNbaV1cbiAgICBpZihjb21wYXJlQ2VsbHMoYSwgY2VsbHNbaS0xXSkpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY2VsbHNbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBjZWxscy5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGNlbGxzXG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcblxuLy9GaW5kcyBhIGNlbGwgaW4gYSBub3JtYWxpemVkIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gZmluZENlbGwoY2VsbHMsIGMpIHtcbiAgdmFyIGxvID0gMFxuICAgICwgaGkgPSBjZWxscy5sZW5ndGgtMVxuICAgICwgciAgPSAtMVxuICB3aGlsZSAobG8gPD0gaGkpIHtcbiAgICB2YXIgbWlkID0gKGxvICsgaGkpID4+IDFcbiAgICAgICwgcyAgID0gY29tcGFyZUNlbGxzKGNlbGxzW21pZF0sIGMpXG4gICAgaWYocyA8PSAwKSB7XG4gICAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBtaWRcbiAgICAgIH1cbiAgICAgIGxvID0gbWlkICsgMVxuICAgIH0gZWxzZSBpZihzID4gMCkge1xuICAgICAgaGkgPSBtaWQgLSAxXG4gICAgfVxuICB9XG4gIHJldHVybiByXG59XG5leHBvcnRzLmZpbmRDZWxsID0gZmluZENlbGw7XG5cbi8vQnVpbGRzIGFuIGluZGV4IGZvciBhbiBuLWNlbGwuICBUaGlzIGlzIG1vcmUgZ2VuZXJhbCB0aGFuIGR1YWwsIGJ1dCBsZXNzIGVmZmljaWVudFxuZnVuY3Rpb24gaW5jaWRlbmNlKGZyb21fY2VsbHMsIHRvX2NlbGxzKSB7XG4gIHZhciBpbmRleCA9IG5ldyBBcnJheShmcm9tX2NlbGxzLmxlbmd0aClcbiAgZm9yKHZhciBpPTAsIGlsPWluZGV4Lmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgaW5kZXhbaV0gPSBbXVxuICB9XG4gIHZhciBiID0gW11cbiAgZm9yKHZhciBpPTAsIG49dG9fY2VsbHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBjID0gdG9fY2VsbHNbaV1cbiAgICB2YXIgY2wgPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaz0xLCBrbj0oMTw8Y2wpOyBrPGtuOyArK2spIHtcbiAgICAgIGIubGVuZ3RoID0gYml0cy5wb3BDb3VudChrKVxuICAgICAgdmFyIGwgPSAwXG4gICAgICBmb3IodmFyIGo9MDsgajxjbDsgKytqKSB7XG4gICAgICAgIGlmKGsgJiAoMTw8aikpIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2pdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpZHg9ZmluZENlbGwoZnJvbV9jZWxscywgYilcbiAgICAgIGlmKGlkeCA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaW5kZXhbaWR4KytdLnB1c2goaSlcbiAgICAgICAgaWYoaWR4ID49IGZyb21fY2VsbHMubGVuZ3RoIHx8IGNvbXBhcmVDZWxscyhmcm9tX2NlbGxzW2lkeF0sIGIpICE9PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cbmV4cG9ydHMuaW5jaWRlbmNlID0gaW5jaWRlbmNlXG5cbi8vQ29tcHV0ZXMgdGhlIGR1YWwgb2YgdGhlIG1lc2guICBUaGlzIGlzIGJhc2ljYWxseSBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBidWlsZEluZGV4IGZvciB0aGUgc2l0dWF0aW9uIHdoZXJlIGZyb21fY2VsbHMgaXMganVzdCB0aGUgbGlzdCBvZiB2ZXJ0aWNlc1xuZnVuY3Rpb24gZHVhbChjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKCF2ZXJ0ZXhfY291bnQpIHtcbiAgICByZXR1cm4gaW5jaWRlbmNlKHVuaXF1ZShza2VsZXRvbihjZWxscywgMCkpLCBjZWxscywgMClcbiAgfVxuICB2YXIgcmVzID0gbmV3IEFycmF5KHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8dmVydGV4X2NvdW50OyArK2kpIHtcbiAgICByZXNbaV0gPSBbXVxuICB9XG4gIGZvcih2YXIgaT0wLCBsZW49Y2VsbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLCBjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICByZXNbY1tqXV0ucHVzaChpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5leHBvcnRzLmR1YWwgPSBkdWFsXG5cbi8vRW51bWVyYXRlcyBhbGwgY2VsbHMgaW4gdGhlIGNvbXBsZXhcbmZ1bmN0aW9uIGV4cGxvZGUoY2VsbHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICAgICwgY2wgPSBjLmxlbmd0aHwwXG4gICAgZm9yKHZhciBqPTEsIGpsPSgxPDxjbCk7IGo8amw7ICsraikge1xuICAgICAgdmFyIGIgPSBbXVxuICAgICAgZm9yKHZhciBrPTA7IGs8Y2w7ICsraykge1xuICAgICAgICBpZigoaiA+Pj4gaykgJiAxKSB7XG4gICAgICAgICAgYi5wdXNoKGNba10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzdWx0KVxufVxuZXhwb3J0cy5leHBsb2RlID0gZXhwbG9kZVxuXG4vL0VudW1lcmF0ZXMgYWxsIG9mIHRoZSBuLWNlbGxzIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBza2VsZXRvbihjZWxscywgbikge1xuICBpZihuIDwgMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBbXVxuICAgICwgazAgICAgID0gKDE8PChuKzEpKS0xXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaz1rMDsgazwoMTw8Yy5sZW5ndGgpOyBrPWJpdHMubmV4dENvbWJpbmF0aW9uKGspKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShuKzEpXG4gICAgICAgICwgbCA9IDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYoayAmICgxPDxqKSkge1xuICAgICAgICAgIGJbbCsrXSA9IGNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShyZXN1bHQpXG59XG5leHBvcnRzLnNrZWxldG9uID0gc2tlbGV0b247XG5cbi8vQ29tcHV0ZXMgdGhlIGJvdW5kYXJ5IG9mIGFsbCBjZWxscywgZG9lcyBub3QgcmVtb3ZlIGR1cGxpY2F0ZXNcbmZ1bmN0aW9uIGJvdW5kYXJ5KGNlbGxzKSB7XG4gIHZhciByZXMgPSBbXVxuICBmb3IodmFyIGk9MCxpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCxjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShjLmxlbmd0aC0xKVxuICAgICAgZm9yKHZhciBrPTAsIGw9MDsgazxjbDsgKytrKSB7XG4gICAgICAgIGlmKGsgIT09IGopIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2tdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzKVxufVxuZXhwb3J0cy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGRlbnNlIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19kZW5zZShjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIHZhciBsYWJlbHMgPSBuZXcgVW5pb25GaW5kKHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKGNbal0sIGNba10pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjb21wb25lbnRzID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgPSBsYWJlbHMucmFua3NcbiAgZm9yKHZhciBpPTA7IGk8Y29tcG9uZW50X2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbXBvbmVudF9sYWJlbHNbaV0gPSAtMVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGwgPSBsYWJlbHMuZmluZChjZWxsc1tpXVswXSlcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIHNwYXJzZSBncmFwaFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19zcGFyc2UoY2VsbHMpIHtcbiAgdmFyIHZlcnRpY2VzICA9IHVuaXF1ZShub3JtYWxpemUoc2tlbGV0b24oY2VsbHMsIDApKSlcbiAgICAsIGxhYmVscyAgICA9IG5ldyBVbmlvbkZpbmQodmVydGljZXMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgdmogPSBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nbal1dKVxuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKHZqLCBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nba11dKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbXBvbmVudHMgICAgICAgID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgID0gbGFiZWxzLnJhbmtzXG4gIGZvcih2YXIgaT0wOyBpPGNvbXBvbmVudF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb21wb25lbnRfbGFiZWxzW2ldID0gLTFcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsID0gbGFiZWxzLmZpbmQoZmluZENlbGwodmVydGljZXMsIFtjZWxsc1tpXVswXV0pKTtcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50cyhjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKHZlcnRleF9jb3VudCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRDb21wb25lbnRzX2RlbnNlKGNlbGxzLCB2ZXJ0ZXhfY291bnQpXG4gIH1cbiAgcmV0dXJuIGNvbm5lY3RlZENvbXBvbmVudHNfc3BhcnNlKGNlbGxzKVxufVxuZXhwb3J0cy5jb25uZWN0ZWRDb21wb25lbnRzID0gY29ubmVjdGVkQ29tcG9uZW50c1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeVBvbHlnb25cblxudmFyIG9yaWVudCA9IHJlcXVpcmUoXCJyb2J1c3Qtb3JpZW50YXRpb25cIilcbnZhciBzYyA9IHJlcXVpcmUoXCJzaW1wbGljaWFsLWNvbXBsZXhcIilcblxuZnVuY3Rpb24gZXJyb3JXZWlnaHQoYmFzZSwgYSwgYikge1xuICB2YXIgYXJlYSA9IE1hdGguYWJzKG9yaWVudChiYXNlLCBhLCBiKSlcbiAgdmFyIHBlcmltID0gTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0gLSBiWzBdLCAyKSArIE1hdGgucG93KGFbMV0tYlsxXSwgMikpXG4gIHJldHVybiBhcmVhIC8gcGVyaW1cbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlQb2x5Z29uKGNlbGxzLCBwb3NpdGlvbnMsIG1pbkFyZWEpIHtcblxuICB2YXIgbiA9IHBvc2l0aW9ucy5sZW5ndGhcbiAgdmFyIG5jID0gY2VsbHMubGVuZ3RoXG4gIHZhciBpbnYgPSBuZXcgQXJyYXkobilcbiAgdmFyIG91dHYgPSBuZXcgQXJyYXkobilcbiAgdmFyIHdlaWdodHMgPSBuZXcgQXJyYXkobilcbiAgdmFyIGRlYWQgPSBuZXcgQXJyYXkobilcbiAgXG4gIC8vSW5pdGlhbGl6ZSB0YWJsZXNcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaW52W2ldID0gb3V0dltpXSA9IC0xXG4gICAgd2VpZ2h0c1tpXSA9IEluZmluaXR5XG4gICAgZGVhZFtpXSA9IGZhbHNlXG4gIH1cblxuICAvL0NvbXB1dGUgbmVpZ2hib3JzXG4gIGZvcih2YXIgaT0wOyBpPG5jOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgaWYoYy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgYSBncmFwaFwiKVxuICAgIH1cbiAgICB2YXIgcyA9IGNbMV1cbiAgICB2YXIgdCA9IGNbMF1cbiAgICBpZihvdXR2W3RdICE9PSAtMSkge1xuICAgICAgb3V0dlt0XSA9IC0yXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHZbdF0gPSBzXG4gICAgfVxuICAgIGlmKGludltzXSAhPT0gLTEpIHtcbiAgICAgIGludltzXSA9IC0yXG4gICAgfSBlbHNlIHtcbiAgICAgIGludltzXSA9IHRcbiAgICB9XG4gIH1cblxuICAvL1VwZGF0ZXMgdGhlIHdlaWdodCBmb3IgdmVydGV4IGlcbiAgZnVuY3Rpb24gY29tcHV0ZVdlaWdodChpKSB7XG4gICAgaWYoZGVhZFtpXSkge1xuICAgICAgcmV0dXJuIEluZmluaXR5XG4gICAgfVxuICAgIC8vVE9ETzogQ2hlY2sgdGhhdCB0aGUgbGluZSBzZWdtZW50IGRvZXNuJ3QgY3Jvc3Mgb25jZSBzaW1wbGlmaWVkXG4gICAgdmFyIHMgPSBpbnZbaV1cbiAgICB2YXIgdCA9IG91dHZbaV1cbiAgICBpZigoczwwKSB8fCAodDwwKSkge1xuICAgICAgcmV0dXJuIEluZmluaXR5XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlcnJvcldlaWdodChwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tzXSwgcG9zaXRpb25zW3RdKVxuICAgIH1cbiAgfVxuXG4gIC8vU3dhcHMgdHdvIG5vZGVzIG9uIHRoZSBoZWFwIChpLGopIGFyZSB0aGUgaW5kZXggb2YgdGhlIG5vZGVzXG4gIGZ1bmN0aW9uIGhlYXBTd2FwKGksaikge1xuICAgIHZhciBhID0gaGVhcFtpXVxuICAgIHZhciBiID0gaGVhcFtqXVxuICAgIGhlYXBbaV0gPSBiXG4gICAgaGVhcFtqXSA9IGFcbiAgICBpbmRleFthXSA9IGpcbiAgICBpbmRleFtiXSA9IGlcbiAgfVxuXG4gIC8vUmV0dXJucyB0aGUgd2VpZ2h0IG9mIG5vZGUgaSBvbiB0aGUgaGVhcFxuICBmdW5jdGlvbiBoZWFwV2VpZ2h0KGkpIHtcbiAgICByZXR1cm4gd2VpZ2h0c1toZWFwW2ldXVxuICB9XG5cbiAgZnVuY3Rpb24gaGVhcFBhcmVudChpKSB7XG4gICAgaWYoaSAmIDEpIHtcbiAgICAgIHJldHVybiAoaSAtIDEpID4+IDFcbiAgICB9XG4gICAgcmV0dXJuIChpID4+IDEpIC0gMVxuICB9XG5cbiAgLy9CdWJibGUgZWxlbWVudCBpIGRvd24gdGhlIGhlYXBcbiAgZnVuY3Rpb24gaGVhcERvd24oaSkge1xuICAgIHZhciB3ID0gaGVhcFdlaWdodChpKVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHZhciB0dyA9IHdcbiAgICAgIHZhciBsZWZ0ICA9IDIqaSArIDFcbiAgICAgIHZhciByaWdodCA9IDIqKGkgKyAxKVxuICAgICAgdmFyIG5leHQgPSBpXG4gICAgICBpZihsZWZ0IDwgaGVhcENvdW50KSB7XG4gICAgICAgIHZhciBsdyA9IGhlYXBXZWlnaHQobGVmdClcbiAgICAgICAgaWYobHcgPCB0dykge1xuICAgICAgICAgIG5leHQgPSBsZWZ0XG4gICAgICAgICAgdHcgPSBsd1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihyaWdodCA8IGhlYXBDb3VudCkge1xuICAgICAgICB2YXIgcncgPSBoZWFwV2VpZ2h0KHJpZ2h0KVxuICAgICAgICBpZihydyA8IHR3KSB7XG4gICAgICAgICAgbmV4dCA9IHJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG5leHQgPT09IGkpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICAgIGhlYXBTd2FwKGksIG5leHQpXG4gICAgICBpID0gbmV4dCAgICAgIFxuICAgIH1cbiAgfVxuXG4gIC8vQnViYmxlcyBlbGVtZW50IGkgdXAgdGhlIGhlYXBcbiAgZnVuY3Rpb24gaGVhcFVwKGkpIHtcbiAgICB2YXIgdyA9IGhlYXBXZWlnaHQoaSlcbiAgICB3aGlsZShpID4gMCkge1xuICAgICAgdmFyIHBhcmVudCA9IGhlYXBQYXJlbnQoaSlcbiAgICAgIGlmKHBhcmVudCA+PSAwKSB7XG4gICAgICAgIHZhciBwdyA9IGhlYXBXZWlnaHQocGFyZW50KVxuICAgICAgICBpZih3IDwgcHcpIHtcbiAgICAgICAgICBoZWFwU3dhcChpLCBwYXJlbnQpXG4gICAgICAgICAgaSA9IHBhcmVudFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgLy9Qb3AgbWluaW11bSBlbGVtZW50XG4gIGZ1bmN0aW9uIGhlYXBQb3AoKSB7XG4gICAgaWYoaGVhcENvdW50ID4gMCkge1xuICAgICAgdmFyIGhlYWQgPSBoZWFwWzBdXG4gICAgICBoZWFwU3dhcCgwLCBoZWFwQ291bnQtMSlcbiAgICAgIGhlYXBDb3VudCAtPSAxXG4gICAgICBoZWFwRG93bigwKVxuICAgICAgcmV0dXJuIGhlYWRcbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvL1VwZGF0ZSBoZWFwIGl0ZW0gaVxuICBmdW5jdGlvbiBoZWFwVXBkYXRlKGksIHcpIHtcbiAgICB2YXIgYSA9IGhlYXBbaV1cbiAgICBpZih3ZWlnaHRzW2FdID09PSB3KSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgICB3ZWlnaHRzW2FdID0gLUluZmluaXR5XG4gICAgaGVhcFVwKGkpXG4gICAgaGVhcFBvcCgpXG4gICAgd2VpZ2h0c1thXSA9IHdcbiAgICBoZWFwQ291bnQgKz0gMVxuICAgIHJldHVybiBoZWFwVXAoaGVhcENvdW50LTEpXG4gIH1cblxuICAvL0tpbGxzIGEgdmVydGV4IChhc3N1bWUgdmVydGV4IGFscmVhZHkgcmVtb3ZlZCBmcm9tIGhlYXApXG4gIGZ1bmN0aW9uIGtpbGwoaSkge1xuICAgIGlmKGRlYWRbaV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvL0tpbGwgdmVydGV4XG4gICAgZGVhZFtpXSA9IHRydWVcbiAgICAvL0ZpeHVwIHRvcG9sb2d5XG4gICAgdmFyIHMgPSBpbnZbaV1cbiAgICB2YXIgdCA9IG91dHZbaV1cbiAgICBpZihpbnZbdF0gPj0gMCkge1xuICAgICAgaW52W3RdID0gc1xuICAgIH1cbiAgICBpZihvdXR2W3NdID49IDApIHtcbiAgICAgIG91dHZbc10gPSB0XG4gICAgfVxuXG4gICAgLy9VcGRhdGUgd2VpZ2h0cyBvbiBzIGFuZCB0XG4gICAgaWYoaW5kZXhbc10gPj0gMCkge1xuICAgICAgaGVhcFVwZGF0ZShpbmRleFtzXSwgY29tcHV0ZVdlaWdodChzKSlcbiAgICB9XG4gICAgaWYoaW5kZXhbdF0gPj0gMCkge1xuICAgICAgaGVhcFVwZGF0ZShpbmRleFt0XSwgY29tcHV0ZVdlaWdodCh0KSlcbiAgICB9XG4gIH1cblxuICAvL0luaXRpYWxpemUgd2VpZ2h0cyBhbmQgaGVhcFxuICB2YXIgaGVhcCA9IFtdXG4gIHZhciBpbmRleCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgdyA9IHdlaWdodHNbaV0gPSBjb21wdXRlV2VpZ2h0KGkpXG4gICAgaWYodyA8IEluZmluaXR5KSB7XG4gICAgICBpbmRleFtpXSA9IGhlYXAubGVuZ3RoXG4gICAgICBoZWFwLnB1c2goaSlcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhbaV0gPSAtMVxuICAgIH1cbiAgfVxuICB2YXIgaGVhcENvdW50ID0gaGVhcC5sZW5ndGhcbiAgZm9yKHZhciBpPWhlYXBDb3VudD4+MTsgaT49MDsgLS1pKSB7XG4gICAgaGVhcERvd24oaSlcbiAgfVxuICBcbiAgLy9LaWxsIHZlcnRpY2VzXG4gIHdoaWxlKHRydWUpIHtcbiAgICB2YXIgaG1pbiA9IGhlYXBQb3AoKVxuICAgIGlmKChobWluIDwgMCkgfHwgKHdlaWdodHNbaG1pbl0gPiBtaW5BcmVhKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAga2lsbChobWluKVxuICB9XG5cbiAgLy9CdWlsZCBjb2xsYXBzZWQgdmVydGV4IHRhYmxlXG4gIHZhciBucG9zaXRpb25zID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoIWRlYWRbaV0pIHtcbiAgICAgIGluZGV4W2ldID0gbnBvc2l0aW9ucy5sZW5ndGhcbiAgICAgIG5wb3NpdGlvbnMucHVzaChwb3NpdGlvbnNbaV0uc2xpY2UoKSlcbiAgICB9XG4gIH1cbiAgdmFyIG52ID0gbnBvc2l0aW9ucy5sZW5ndGhcblxuICBmdW5jdGlvbiB0b3J0b2lzZUhhcmUoc2VxLCBzdGFydCkge1xuICAgIGlmKHNlcVtzdGFydF0gPCAwKSB7XG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG4gICAgdmFyIHQgPSBzdGFydFxuICAgIHZhciBoID0gc3RhcnRcbiAgICBkbyB7XG4gICAgICAvL1dhbGsgdHdvIHN0ZXBzIHdpdGggaFxuICAgICAgdmFyIG5oID0gc2VxW2hdXG4gICAgICBpZighZGVhZFtoXSB8fCBuaCA8IDAgfHwgbmggPT09IGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGggPSBuaFxuICAgICAgbmggPSBzZXFbaF1cbiAgICAgIGlmKCFkZWFkW2hdIHx8IG5oIDwgMCB8fCBuaCA9PT0gaCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaCA9IG5oXG5cbiAgICAgIC8vV2FsayBvbmUgc3RlcCB3aXRoIHRcbiAgICAgIHQgPSBzZXFbdF1cbiAgICB9IHdoaWxlKHQgIT09IGgpXG4gICAgLy9Db21wcmVzcyBjeWNsZXNcbiAgICBmb3IodmFyIHY9c3RhcnQ7IHYhPT1oOyB2ID0gc2VxW3ZdKSB7XG4gICAgICBzZXFbdl0gPSBoXG4gICAgfVxuICAgIHJldHVybiBoXG4gIH1cblxuICB2YXIgbmNlbGxzID0gW11cbiAgY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgdmFyIHRpbiA9IHRvcnRvaXNlSGFyZShpbnYsIGNbMF0pXG4gICAgdmFyIHRvdXQgPSB0b3J0b2lzZUhhcmUob3V0diwgY1sxXSlcbiAgICBpZih0aW4gPj0gMCAmJiB0b3V0ID49IDAgJiYgdGluICE9PSB0b3V0KSB7XG4gICAgICB2YXIgY2luID0gaW5kZXhbdGluXVxuICAgICAgdmFyIGNvdXQgPSBpbmRleFt0b3V0XVxuICAgICAgaWYoY2luICE9PSBjb3V0KSB7XG4gICAgICAgIG5jZWxscy5wdXNoKFsgY2luLCBjb3V0IF0pXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC8vTm9ybWFsaXplIHJlc3VsdFxuICBzYy51bmlxdWUoc2Mubm9ybWFsaXplKG5jZWxscykpXG5cbiAgLy9SZXR1cm4gZmluYWwgbGlzdCBvZiBjZWxsc1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uczogbnBvc2l0aW9ucyxcbiAgICBlZGdlczogbmNlbGxzXG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IG9yZGVyU2VnbWVudHNcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoXCJyb2J1c3Qtb3JpZW50YXRpb25cIilcblxuZnVuY3Rpb24gaG9yaXpvbnRhbE9yZGVyKGEsIGIpIHtcbiAgdmFyIGJsLCBiclxuICBpZihiWzBdWzBdIDwgYlsxXVswXSkge1xuICAgIGJsID0gYlswXVxuICAgIGJyID0gYlsxXVxuICB9IGVsc2UgaWYoYlswXVswXSA+IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMV1cbiAgICBiciA9IGJbMF1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYWxvID0gTWF0aC5taW4oYVswXVsxXSwgYVsxXVsxXSlcbiAgICB2YXIgYWhpID0gTWF0aC5tYXgoYVswXVsxXSwgYVsxXVsxXSlcbiAgICB2YXIgYmxvID0gTWF0aC5taW4oYlswXVsxXSwgYlsxXVsxXSlcbiAgICB2YXIgYmhpID0gTWF0aC5tYXgoYlswXVsxXSwgYlsxXVsxXSlcbiAgICBpZihhaGkgPCBibG8pIHtcbiAgICAgIHJldHVybiBhaGkgLSBibG9cbiAgICB9XG4gICAgaWYoYWxvID4gYmhpKSB7XG4gICAgICByZXR1cm4gYWxvIC0gYmhpXG4gICAgfVxuICAgIHJldHVybiBhaGkgLSBiaGlcbiAgfVxuICB2YXIgYWwsIGFyXG4gIGlmKGFbMF1bMV0gPCBhWzFdWzFdKSB7XG4gICAgYWwgPSBhWzBdXG4gICAgYXIgPSBhWzFdXG4gIH0gZWxzZSB7XG4gICAgYWwgPSBhWzFdXG4gICAgYXIgPSBhWzBdXG4gIH1cbiAgdmFyIGQgPSBvcmllbnQoYnIsIGJsLCBhbClcbiAgaWYoZCkge1xuICAgIHJldHVybiBkXG4gIH1cbiAgZCA9IG9yaWVudChiciwgYmwsIGFyKVxuICBpZihkKSB7XG4gICAgcmV0dXJuIGRcbiAgfVxuICByZXR1cm4gYXIgLSBiclxufVxuXG5mdW5jdGlvbiBvcmRlclNlZ21lbnRzKGIsIGEpIHtcbiAgdmFyIGFsLCBhclxuICBpZihhWzBdWzBdIDwgYVsxXVswXSkge1xuICAgIGFsID0gYVswXVxuICAgIGFyID0gYVsxXVxuICB9IGVsc2UgaWYoYVswXVswXSA+IGFbMV1bMF0pIHtcbiAgICBhbCA9IGFbMV1cbiAgICBhciA9IGFbMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaG9yaXpvbnRhbE9yZGVyKGEsIGIpXG4gIH1cbiAgdmFyIGJsLCBiclxuICBpZihiWzBdWzBdIDwgYlsxXVswXSkge1xuICAgIGJsID0gYlswXVxuICAgIGJyID0gYlsxXVxuICB9IGVsc2UgaWYoYlswXVswXSA+IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMV1cbiAgICBiciA9IGJbMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLWhvcml6b250YWxPcmRlcihiLCBhKVxuICB9XG4gIHZhciBkMSA9IG9yaWVudChhbCwgYXIsIGJyKVxuICB2YXIgZDIgPSBvcmllbnQoYWwsIGFyLCBibClcbiAgaWYoZDEgPCAwKSB7XG4gICAgaWYoZDIgPD0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDEgPiAwKSB7XG4gICAgaWYoZDIgPj0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDIpIHtcbiAgICByZXR1cm4gZDJcbiAgfVxuICBkMSA9IG9yaWVudChiciwgYmwsIGFyKVxuICBkMiA9IG9yaWVudChiciwgYmwsIGFsKVxuICBpZihkMSA8IDApIHtcbiAgICBpZihkMiA8PSAwKSB7XG4gICAgICByZXR1cm4gZDFcbiAgICB9XG4gIH0gZWxzZSBpZihkMSA+IDApIHtcbiAgICBpZihkMiA+PSAwKSB7XG4gICAgICByZXR1cm4gZDFcbiAgICB9XG4gIH0gZWxzZSBpZihkMikge1xuICAgIHJldHVybiBkMlxuICB9XG4gIHJldHVybiBhclswXSAtIGJyWzBdXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTbGFiRGVjb21wb3NpdGlvblxuXG52YXIgYm91bmRzID0gcmVxdWlyZShcImJpbmFyeS1zZWFyY2gtYm91bmRzXCIpXG52YXIgY3JlYXRlUkJUcmVlID0gcmVxdWlyZShcImZ1bmN0aW9uYWwtcmVkLWJsYWNrLXRyZWVcIilcbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgb3JkZXJTZWdtZW50cyA9IHJlcXVpcmUoXCIuL2xpYi9vcmRlci1zZWdtZW50c1wiKVxuXG5mdW5jdGlvbiBTbGFiRGVjb21wb3NpdGlvbihzbGFicywgY29vcmRpbmF0ZXMsIGhvcml6b250YWwpIHtcbiAgdGhpcy5zbGFicyA9IHNsYWJzXG4gIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlc1xuICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsXG59XG5cbnZhciBwcm90byA9IFNsYWJEZWNvbXBvc2l0aW9uLnByb3RvdHlwZVxuXG5mdW5jdGlvbiBjb21wYXJlSG9yaXpvbnRhbChlLCB5KSB7XG4gIHJldHVybiBlLnkgLSB5XG59XG5cbmZ1bmN0aW9uIHNlYXJjaEJ1Y2tldChyb290LCBwKSB7XG4gIHZhciBsYXN0Tm9kZSA9IG51bGxcbiAgd2hpbGUocm9vdCkge1xuICAgIHZhciBzZWcgPSByb290LmtleVxuICAgIHZhciBsLCByXG4gICAgaWYoc2VnWzBdWzBdIDwgc2VnWzFdWzBdKSB7XG4gICAgICBsID0gc2VnWzBdXG4gICAgICByID0gc2VnWzFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBzZWdbMV1cbiAgICAgIHIgPSBzZWdbMF1cbiAgICB9XG4gICAgdmFyIG8gPSBvcmllbnQobCwgciwgcClcbiAgICBpZihvIDwgMCkge1xuICAgICAgcm9vdCA9IHJvb3QubGVmdFxuICAgIH0gZWxzZSBpZihvID4gMCkge1xuICAgICAgaWYocFswXSAhPT0gc2VnWzFdWzBdKSB7XG4gICAgICAgIGxhc3ROb2RlID0gcm9vdFxuICAgICAgICByb290ID0gcm9vdC5yaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbCA9IHNlYXJjaEJ1Y2tldChyb290LnJpZ2h0LCBwKVxuICAgICAgICBpZih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IHJvb3QubGVmdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihwWzBdICE9PSBzZWdbMV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHJvb3RcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWFyY2hCdWNrZXQocm9vdC5yaWdodCwgcClcbiAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhc3ROb2RlXG59XG5cbnByb3RvLmNhc3RVcCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGJ1Y2tldCA9IGJvdW5kcy5sZSh0aGlzLmNvb3JkaW5hdGVzLCBwWzBdKVxuICBpZihidWNrZXQgPCAwKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgdmFyIHJvb3QgPSB0aGlzLnNsYWJzW2J1Y2tldF1cbiAgdmFyIGhpdE5vZGUgPSBzZWFyY2hCdWNrZXQodGhpcy5zbGFic1tidWNrZXRdLCBwKVxuICB2YXIgbGFzdEhpdCA9IC0xXG4gIGlmKGhpdE5vZGUpIHtcbiAgICBsYXN0SGl0ID0gaGl0Tm9kZS52YWx1ZVxuICB9XG4gIC8vRWRnZSBjYXNlOiBuZWVkIHRvIGhhbmRsZSBob3Jpem9udGFsIHNlZ21lbnRzIChzdWNrcylcbiAgaWYodGhpcy5jb29yZGluYXRlc1tidWNrZXRdID09PSBwWzBdKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gbnVsbFxuICAgIGlmKGhpdE5vZGUpIHtcbiAgICAgIGxhc3RTZWdtZW50ID0gaGl0Tm9kZS5rZXlcbiAgICB9XG4gICAgaWYoYnVja2V0ID4gMCkge1xuICAgICAgdmFyIG90aGVySGl0Tm9kZSA9IHNlYXJjaEJ1Y2tldCh0aGlzLnNsYWJzW2J1Y2tldC0xXSwgcClcbiAgICAgIGlmKG90aGVySGl0Tm9kZSkge1xuICAgICAgICBpZihsYXN0U2VnbWVudCkge1xuICAgICAgICAgIGlmKG9yZGVyU2VnbWVudHMob3RoZXJIaXROb2RlLmtleSwgbGFzdFNlZ21lbnQpID4gMCkge1xuICAgICAgICAgICAgbGFzdFNlZ21lbnQgPSBvdGhlckhpdE5vZGUua2V5XG4gICAgICAgICAgICBsYXN0SGl0ID0gb3RoZXJIaXROb2RlLnZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RIaXQgPSBvdGhlckhpdE5vZGUudmFsdWVcbiAgICAgICAgICBsYXN0U2VnbWVudCA9IG90aGVySGl0Tm9kZS5rZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaG9yaXogPSB0aGlzLmhvcml6b250YWxbYnVja2V0XVxuICAgIGlmKGhvcml6Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBoYnVja2V0ID0gYm91bmRzLmdlKGhvcml6LCBwWzFdLCBjb21wYXJlSG9yaXpvbnRhbClcbiAgICAgIGlmKGhidWNrZXQgPCBob3Jpei5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGUgPSBob3JpeltoYnVja2V0XVxuICAgICAgICBpZihwWzFdID09PSBlLnkpIHtcbiAgICAgICAgICBpZihlLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUoaGJ1Y2tldCA8IGhvcml6Lmxlbmd0aC0xICYmIGhvcml6W2hidWNrZXQrMV0ueSA9PT0gcFsxXSkge1xuICAgICAgICAgICAgICBoYnVja2V0ID0gaGJ1Y2tldCsxXG4gICAgICAgICAgICAgIGUgPSBob3JpeltoYnVja2V0XVxuICAgICAgICAgICAgICBpZihlLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmluZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGUueSA9PT0gcFsxXSAmJiAhZS5zdGFydCkge1xuICAgICAgICAgICAgICBoYnVja2V0ID0gaGJ1Y2tldCsxXG4gICAgICAgICAgICAgIGlmKGhidWNrZXQgPj0gaG9yaXoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RIaXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlID0gaG9yaXpbaGJ1Y2tldF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9DaGVjayBpZiBlIGlzIGFib3ZlL2JlbG93IGxhc3Qgc2VnbWVudFxuICAgICAgICBpZihlLnN0YXJ0KSB7XG4gICAgICAgICAgaWYobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBvID0gb3JpZW50KGxhc3RTZWdtZW50WzBdLCBsYXN0U2VnbWVudFsxXSwgW3BbMF0sIGUueV0pXG4gICAgICAgICAgICBpZihsYXN0U2VnbWVudFswXVswXSA+IGxhc3RTZWdtZW50WzFdWzBdKSB7XG4gICAgICAgICAgICAgIG8gPSAtb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgICAgICAgbGFzdEhpdCA9IGUuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdEhpdCA9IGUuaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihlLnkgIT09IHBbMV0pIHtcbiAgICAgICAgICBsYXN0SGl0ID0gZS5pbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXN0SGl0XG59XG5cbmZ1bmN0aW9uIEludGVydmFsU2VnbWVudCh5LCBpbmRleCwgc3RhcnQsIGNsb3NlZCkge1xuICB0aGlzLnkgPSB5XG4gIHRoaXMuaW5kZXggPSBpbmRleFxuICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgdGhpcy5jbG9zZWQgPSBjbG9zZWRcbn1cblxuZnVuY3Rpb24gRXZlbnQoeCwgc2VnbWVudCwgY3JlYXRlLCBpbmRleCkge1xuICB0aGlzLnggPSB4XG4gIHRoaXMuc2VnbWVudCA9IHNlZ21lbnRcbiAgdGhpcy5jcmVhdGUgPSBjcmVhdGVcbiAgdGhpcy5pbmRleCA9IGluZGV4XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU2xhYkRlY29tcG9zaXRpb24oc2VnbWVudHMpIHtcbiAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoXG4gIHZhciBudW1FdmVudHMgPSAyICogbnVtU2VnbWVudHNcbiAgdmFyIGV2ZW50cyA9IG5ldyBBcnJheShudW1FdmVudHMpXG4gIGZvcih2YXIgaT0wOyBpPG51bVNlZ21lbnRzOyArK2kpIHtcbiAgICB2YXIgcyA9IHNlZ21lbnRzW2ldXG4gICAgdmFyIGYgPSBzWzBdWzBdIDwgc1sxXVswXVxuICAgIGV2ZW50c1syKmldID0gbmV3IEV2ZW50KHNbMF1bMF0sIHMsIGYsIGkpXG4gICAgZXZlbnRzWzIqaSsxXSA9IG5ldyBFdmVudChzWzFdWzBdLCBzLCAhZiwgaSlcbiAgfVxuICBldmVudHMuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgZCA9IGEueCAtIGIueFxuICAgIGlmKGQpIHtcbiAgICAgIHJldHVybiBkXG4gICAgfVxuICAgIGQgPSBhLmNyZWF0ZSAtIGIuY3JlYXRlXG4gICAgaWYoZCkge1xuICAgICAgcmV0dXJuIGRcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKGEuc2VnbWVudFswXVsxXSwgYS5zZWdtZW50WzFdWzFdKSAtIE1hdGgubWluKGIuc2VnbWVudFswXVsxXSwgYi5zZWdtZW50WzFdWzFdKVxuICB9KVxuICB2YXIgdHJlZSA9IGNyZWF0ZVJCVHJlZShvcmRlclNlZ21lbnRzKVxuICB2YXIgc2xhYnMgPSBbXVxuICB2YXIgbGluZXMgPSBbXVxuICB2YXIgaG9yaXpvbnRhbCA9IFtdXG4gIHZhciBsYXN0WCA9IC1JbmZpbml0eVxuICBmb3IodmFyIGk9MDsgaTxudW1FdmVudHM7ICkge1xuICAgIHZhciB4ID0gZXZlbnRzW2ldLnhcbiAgICB2YXIgaG9yaXogPSBbXVxuICAgIHdoaWxlKGkgPCBudW1FdmVudHMpIHtcbiAgICAgIHZhciBlID0gZXZlbnRzW2ldXG4gICAgICBpZihlLnggIT09IHgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGkgKz0gMVxuICAgICAgaWYoZS5zZWdtZW50WzBdWzBdID09PSBlLnggJiYgZS5zZWdtZW50WzFdWzBdID09PSBlLngpIHtcbiAgICAgICAgaWYoZS5jcmVhdGUpIHtcbiAgICAgICAgICBpZihlLnNlZ21lbnRbMF1bMV0gPCBlLnNlZ21lbnRbMV1bMV0pIHtcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMF1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHRydWUpKVxuICAgICAgICAgICAgaG9yaXoucHVzaChuZXcgSW50ZXJ2YWxTZWdtZW50KFxuICAgICAgICAgICAgICAgIGUuc2VnbWVudFsxXVsxXSxcbiAgICAgICAgICAgICAgICBlLmluZGV4LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhbHNlKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9yaXoucHVzaChuZXcgSW50ZXJ2YWxTZWdtZW50KFxuICAgICAgICAgICAgICAgIGUuc2VnbWVudFsxXVsxXSxcbiAgICAgICAgICAgICAgICBlLmluZGV4LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgZmFsc2UpKVxuICAgICAgICAgICAgaG9yaXoucHVzaChuZXcgSW50ZXJ2YWxTZWdtZW50KFxuICAgICAgICAgICAgICAgIGUuc2VnbWVudFswXVsxXSxcbiAgICAgICAgICAgICAgICBlLmluZGV4LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHRydWUpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZS5jcmVhdGUpIHtcbiAgICAgICAgICB0cmVlID0gdHJlZS5pbnNlcnQoZS5zZWdtZW50LCBlLmluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyZWUgPSB0cmVlLnJlbW92ZShlLnNlZ21lbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2xhYnMucHVzaCh0cmVlLnJvb3QpXG4gICAgbGluZXMucHVzaCh4KVxuICAgIGhvcml6b250YWwucHVzaChob3JpeilcbiAgfVxuICByZXR1cm4gbmV3IFNsYWJEZWNvbXBvc2l0aW9uKHNsYWJzLCBsaW5lcywgaG9yaXpvbnRhbClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cmZhY2VOZXRzXG5cbnZhciBnZW5lcmF0ZUNvbnRvdXJFeHRyYWN0b3IgPSByZXF1aXJlKFwibmRhcnJheS1leHRyYWN0LWNvbnRvdXJcIilcbnZhciB0cmlhbmd1bGF0ZUN1YmUgPSByZXF1aXJlKFwidHJpYW5ndWxhdGUtaHlwZXJjdWJlXCIpXG52YXIgemVyb0Nyb3NzaW5ncyA9IHJlcXVpcmUoXCJ6ZXJvLWNyb3NzaW5nc1wiKVxuXG5mdW5jdGlvbiBidWlsZFN1cmZhY2VOZXRzKG9yZGVyLCBkdHlwZSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnO1wiXVxuICB2YXIgZnVuY05hbWUgPSBcInN1cmZhY2VOZXRzXCIgKyBvcmRlci5qb2luKFwiX1wiKSArIFwiZFwiICsgZHR5cGVcblxuICAvL0NvbnRvdXIgZXh0cmFjdGlvbiBmdW5jdGlvblxuICBjb2RlLnB1c2goXG4gICAgXCJ2YXIgY29udG91cj1nZW5Db250b3VyKHtcIixcbiAgICAgIFwib3JkZXI6W1wiLCBvcmRlci5qb2luKCksIFwiXSxcIixcbiAgICAgIFwic2NhbGFyQXJndW1lbnRzOiAzLFwiLFxuICAgICAgXCJwaGFzZTpmdW5jdGlvbiBwaGFzZUZ1bmMocCxhLGIsYykgeyByZXR1cm4gKHAgPiBjKXwwIH0sXCIpXG4gIGlmKGR0eXBlID09PSBcImdlbmVyaWNcIikge1xuICAgIGNvZGUucHVzaChcImdldHRlcnM6WzBdLFwiKVxuICB9XG5cbiAgLy9HZW5lcmF0ZSB2ZXJ0ZXggZnVuY3Rpb25cbiAgdmFyIGN1YmVBcmdzID0gW11cbiAgdmFyIGV4dHJhQXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY3ViZUFyZ3MucHVzaChcImRcIiArIGkpXG4gICAgZXh0cmFBcmdzLnB1c2goXCJkXCIgKyBpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICBjdWJlQXJncy5wdXNoKFwidlwiICsgaSlcbiAgICBleHRyYUFyZ3MucHVzaChcInZcIiArIGkpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8KDE8PGRpbWVuc2lvbik7ICsraSkge1xuICAgIGN1YmVBcmdzLnB1c2goXCJwXCIgKyBpKVxuICAgIGV4dHJhQXJncy5wdXNoKFwicFwiICsgaSlcbiAgfVxuICBjdWJlQXJncy5wdXNoKFwiYVwiLCBcImJcIiwgXCJjXCIpXG4gIGV4dHJhQXJncy5wdXNoKFwiYVwiLCBcImNcIilcbiAgY29kZS5wdXNoKFwidmVydGV4OmZ1bmN0aW9uIHZlcnRleEZ1bmMoXCIsIGN1YmVBcmdzLmpvaW4oKSwgXCIpe1wiKVxuICAvL01hc2sgYXJncyB0b2dldGhlclxuICB2YXIgbWFza1N0ciA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICBtYXNrU3RyLnB1c2goXCIocFwiICsgaSArIFwiPDxcIiArIGkgKyBcIilcIilcbiAgfVxuICAvL0dlbmVyYXRlIHZhcmlhYmxlcyBhbmQgZ2lnYW50byBzd2l0Y2ggc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInZhciBtPShcIiwgbWFza1N0ci5qb2luKFwiK1wiKSwgXCIpfDA7aWYobT09PTB8fG09PT1cIiwgKDE8PCgxPDxkaW1lbnNpb24pKS0xLCBcIil7cmV0dXJufVwiKVxuICB2YXIgZXh0cmFGdW5jcyA9IFtdXG4gIHZhciBjdXJyZW50RnVuYyA9IFtdXG4gIGlmKDE8PCgxPDxkaW1lbnNpb24pIDw9IDEyOCkge1xuICAgIGNvZGUucHVzaChcInN3aXRjaChtKXtcIilcbiAgICBjdXJyZW50RnVuYyA9IGNvZGVcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJzd2l0Y2gobT4+Pjcpe1wiKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPDE8PCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICBpZigxPDwoMTw8ZGltZW5zaW9uKSA+IDEyOCkge1xuICAgICAgaWYoKGklMTI4KT09PTApIHtcbiAgICAgICAgaWYoZXh0cmFGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudEZ1bmMucHVzaChcIn19XCIpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVmTmFtZSA9IFwidkV4dHJhXCIgKyBleHRyYUZ1bmNzLmxlbmd0aFxuICAgICAgICBjb2RlLnB1c2goXCJjYXNlIFwiLCAoaT4+PjcpLCBcIjpcIiwgZWZOYW1lLCBcIihtJjB4N2YsXCIsIGV4dHJhQXJncy5qb2luKCksIFwiKTticmVhaztcIilcbiAgICAgICAgY3VycmVudEZ1bmMgPSBbXG4gICAgICAgICAgXCJmdW5jdGlvbiBcIiwgZWZOYW1lLCBcIihtLFwiLCBleHRyYUFyZ3Muam9pbigpLCBcIil7c3dpdGNoKG0pe1wiXG4gICAgICAgIF1cbiAgICAgICAgZXh0cmFGdW5jcy5wdXNoKGN1cnJlbnRGdW5jKVxuICAgICAgfSAgXG4gICAgfVxuICAgIGN1cnJlbnRGdW5jLnB1c2goXCJjYXNlIFwiLCAoaSYweDdmKSwgXCI6XCIpXG4gICAgdmFyIGNyb3NzaW5ncyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgdmFyIGRlbm9tcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgdmFyIGNyb3NzaW5nQ291bnQgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIHZhciBiaWFzID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICB2YXIgdG90YWxDcm9zc2luZ3MgPSAwXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGNyb3NzaW5nc1tqXSA9IFtdXG4gICAgICBkZW5vbXNbal0gPSBbXVxuICAgICAgY3Jvc3NpbmdDb3VudFtqXSA9IDBcbiAgICAgIGJpYXNbal0gPSAwXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICAgIGZvcih2YXIgaz0wOyBrPGRpbWVuc2lvbjsgKytrKSB7XG4gICAgICAgIHZhciB1ID0gaiBeICgxPDxrKVxuICAgICAgICBpZih1ID4gaikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYoIShpJigxPDx1KSkgIT09ICEoaSYoMTw8aikpKSB7XG4gICAgICAgICAgdmFyIHNpZ24gPSAxXG4gICAgICAgICAgaWYoaSYoMTw8dSkpIHtcbiAgICAgICAgICAgIGRlbm9tc1trXS5wdXNoKFwidlwiICsgdSArIFwiLXZcIiArIGopXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbm9tc1trXS5wdXNoKFwidlwiICsgaiArIFwiLXZcIiArIHUpXG4gICAgICAgICAgICBzaWduID0gLXNpZ25cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoc2lnbiA8IDApIHtcbiAgICAgICAgICAgIGNyb3NzaW5nc1trXS5wdXNoKFwiLXZcIiArIGogKyBcIi12XCIgKyB1KVxuICAgICAgICAgICAgY3Jvc3NpbmdDb3VudFtrXSArPSAyXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyb3NzaW5nc1trXS5wdXNoKFwidlwiICsgaiArIFwiK3ZcIiArIHUpXG4gICAgICAgICAgICBjcm9zc2luZ0NvdW50W2tdIC09IDIgICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxDcm9zc2luZ3MgKz0gMVxuICAgICAgICAgIGZvcih2YXIgbD0wOyBsPGRpbWVuc2lvbjsgKytsKSB7XG4gICAgICAgICAgICBpZihsID09PSBrKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih1JigxPDxsKSkge1xuICAgICAgICAgICAgICBiaWFzW2xdICs9IDFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJpYXNbbF0gLT0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmVydGV4U3RyID0gW11cbiAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgaWYoY3Jvc3NpbmdzW2tdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2ZXJ0ZXhTdHIucHVzaChcImRcIiArIGsgKyBcIi0wLjVcIilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjU3RyID0gXCJcIlxuICAgICAgICBpZihjcm9zc2luZ0NvdW50W2tdIDwgMCkge1xuICAgICAgICAgIGNTdHIgPSBjcm9zc2luZ0NvdW50W2tdICsgXCIqY1wiXG4gICAgICAgIH0gZWxzZSBpZihjcm9zc2luZ0NvdW50W2tdID4gMCkge1xuICAgICAgICAgIGNTdHIgPSBcIitcIiArIGNyb3NzaW5nQ291bnRba10gKyBcIipjXCJcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2VpZ2h0ID0gMC41ICogKGNyb3NzaW5nc1trXS5sZW5ndGggLyB0b3RhbENyb3NzaW5ncylcbiAgICAgICAgdmFyIHNoaWZ0ID0gMC41ICsgMC41ICogKGJpYXNba10gLyB0b3RhbENyb3NzaW5ncylcbiAgICAgICAgdmVydGV4U3RyLnB1c2goXCJkXCIgKyBrICsgXCItXCIgKyBzaGlmdCArIFwiLVwiICsgd2VpZ2h0ICsgXCIqKFwiICsgY3Jvc3NpbmdzW2tdLmpvaW4oXCIrXCIpICsgY1N0ciArIFwiKS8oXCIgKyBkZW5vbXNba10uam9pbihcIitcIikgKyBcIilcIilcbiAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJlbnRGdW5jLnB1c2goXCJhLnB1c2goW1wiLCB2ZXJ0ZXhTdHIuam9pbigpLCBcIl0pO1wiLFxuICAgICAgXCJicmVhaztcIilcbiAgfVxuICBjb2RlLnB1c2goXCJ9fSxcIilcbiAgaWYoZXh0cmFGdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgY3VycmVudEZ1bmMucHVzaChcIn19XCIpXG4gIH1cblxuICAvL0NyZWF0ZSBmYWNlIGZ1bmN0aW9uXG4gIHZhciBmYWNlQXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPCgxPDwoZGltZW5zaW9uLTEpKTsgKytpKSB7XG4gICAgZmFjZUFyZ3MucHVzaChcInZcIiArIGkpXG4gIH1cbiAgZmFjZUFyZ3MucHVzaChcImMwXCIsIFwiYzFcIiwgXCJwMFwiLCBcInAxXCIsIFwiYVwiLCBcImJcIiwgXCJjXCIpXG4gIGNvZGUucHVzaChcImNlbGw6ZnVuY3Rpb24gY2VsbEZ1bmMoXCIsIGZhY2VBcmdzLmpvaW4oKSwgXCIpe1wiKVxuXG4gIHZhciBmYWNldHMgPSB0cmlhbmd1bGF0ZUN1YmUoZGltZW5zaW9uLTEpXG4gIGNvZGUucHVzaChcImlmKHAwKXtiLnB1c2goXCIsXG4gICAgZmFjZXRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gXCJbXCIgKyBmLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBcInZcIiArIHZcbiAgICAgIH0pICsgXCJdXCJcbiAgICB9KS5qb2luKCksIFwiKX1lbHNle2IucHVzaChcIixcbiAgICBmYWNldHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciBlID0gZi5zbGljZSgpXG4gICAgICBlLnJldmVyc2UoKVxuICAgICAgcmV0dXJuIFwiW1wiICsgZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gXCJ2XCIgKyB2XG4gICAgICB9KSArIFwiXVwiXG4gICAgfSkuam9pbigpLFxuICAgIFwiKX19fSk7ZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihhcnJheSxsZXZlbCl7dmFyIHZlcnRzPVtdLGNlbGxzPVtdO2NvbnRvdXIoYXJyYXksdmVydHMsY2VsbHMsbGV2ZWwpO3JldHVybiB7cG9zaXRpb25zOnZlcnRzLGNlbGxzOmNlbGxzfTt9IHJldHVybiBcIiwgZnVuY05hbWUsIFwiO1wiKVxuXG4gIGZvcih2YXIgaT0wOyBpPGV4dHJhRnVuY3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goZXh0cmFGdW5jc1tpXS5qb2luKFwiXCIpKVxuICB9XG5cbiAgLy9Db21waWxlIGFuZCBsaW5rXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKFwiZ2VuQ29udG91clwiLCBjb2RlLmpvaW4oXCJcIikpXG4gIHJldHVybiBwcm9jKGdlbmVyYXRlQ29udG91ckV4dHJhY3Rvcilcbn1cblxuLy8xRCBjYXNlOiBOZWVkIHRvIGhhbmRsZSBzcGVjaWFsbHlcbmZ1bmN0aW9uIG1lc2gxRChhcnJheSwgbGV2ZWwpIHtcbiAgdmFyIHpjID0gemVyb0Nyb3NzaW5ncyhhcnJheSwgbGV2ZWwpXG4gIHZhciBuID0gemMubGVuZ3RoXG4gIHZhciBucG9zID0gbmV3IEFycmF5KG4pXG4gIHZhciBuY2VsID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIG5wb3NbaV0gPSBbIHpjW2ldIF1cbiAgICBuY2VsW2ldID0gWyBpIF1cbiAgfVxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uczogbnBvcyxcbiAgICBjZWxsczogbmNlbFxuICB9XG59XG5cbnZhciBDQUNIRSA9IHt9XG5cbmZ1bmN0aW9uIHN1cmZhY2VOZXRzKGFycmF5LGxldmVsKSB7XG4gIGlmKGFycmF5LmRpbWVuc2lvbiA8PSAwKSB7XG4gICAgcmV0dXJuIHsgcG9zaXRpb25zOiBbXSwgY2VsbHM6IFtdIH1cbiAgfSBlbHNlIGlmKGFycmF5LmRpbWVuc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBtZXNoMUQoYXJyYXksIGxldmVsKVxuICB9XG4gIHZhciB0eXBlc2lnID0gYXJyYXkub3JkZXIuam9pbigpICsgXCItXCIgKyBhcnJheS5kdHlwZVxuICB2YXIgcHJvYyA9IENBQ0hFW3R5cGVzaWddXG4gIHZhciBsZXZlbCA9ICgrbGV2ZWwpIHx8IDAuMFxuICBpZighcHJvYykge1xuICAgIHByb2MgPSBDQUNIRVt0eXBlc2lnXSA9IGJ1aWxkU3VyZmFjZU5ldHMoYXJyYXkub3JkZXIsIGFycmF5LmR0eXBlKVxuICB9XG4gIHJldHVybiBwcm9jKGFycmF5LGxldmVsKVxufSIsImV4cG9ydCBjb25zdCBSRVZJU0lPTiA9ICcxNTYnO1xuXG5leHBvcnQgY29uc3QgTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIsIFJPVEFURTogMCwgRE9MTFk6IDEsIFBBTjogMiB9O1xuZXhwb3J0IGNvbnN0IFRPVUNIID0geyBST1RBVEU6IDAsIFBBTjogMSwgRE9MTFlfUEFOOiAyLCBET0xMWV9ST1RBVEU6IDMgfTtcbmV4cG9ydCBjb25zdCBDdWxsRmFjZU5vbmUgPSAwO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlQmFjayA9IDE7XG5leHBvcnQgY29uc3QgQ3VsbEZhY2VGcm9udCA9IDI7XG5leHBvcnQgY29uc3QgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuZXhwb3J0IGNvbnN0IEJhc2ljU2hhZG93TWFwID0gMDtcbmV4cG9ydCBjb25zdCBQQ0ZTaGFkb3dNYXAgPSAxO1xuZXhwb3J0IGNvbnN0IFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xuZXhwb3J0IGNvbnN0IFZTTVNoYWRvd01hcCA9IDM7XG5leHBvcnQgY29uc3QgRnJvbnRTaWRlID0gMDtcbmV4cG9ydCBjb25zdCBCYWNrU2lkZSA9IDE7XG5leHBvcnQgY29uc3QgRG91YmxlU2lkZSA9IDI7XG5leHBvcnQgY29uc3QgVHdvUGFzc0RvdWJsZVNpZGUgPSAyOyAvLyByMTQ5XG5leHBvcnQgY29uc3QgTm9CbGVuZGluZyA9IDA7XG5leHBvcnQgY29uc3QgTm9ybWFsQmxlbmRpbmcgPSAxO1xuZXhwb3J0IGNvbnN0IEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuZXhwb3J0IGNvbnN0IFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuZXhwb3J0IGNvbnN0IE11bHRpcGx5QmxlbmRpbmcgPSA0O1xuZXhwb3J0IGNvbnN0IEN1c3RvbUJsZW5kaW5nID0gNTtcbmV4cG9ydCBjb25zdCBBZGRFcXVhdGlvbiA9IDEwMDtcbmV4cG9ydCBjb25zdCBTdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuZXhwb3J0IGNvbnN0IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuZXhwb3J0IGNvbnN0IE1pbkVxdWF0aW9uID0gMTAzO1xuZXhwb3J0IGNvbnN0IE1heEVxdWF0aW9uID0gMTA0O1xuZXhwb3J0IGNvbnN0IFplcm9GYWN0b3IgPSAyMDA7XG5leHBvcnQgY29uc3QgT25lRmFjdG9yID0gMjAxO1xuZXhwb3J0IGNvbnN0IFNyY0NvbG9yRmFjdG9yID0gMjAyO1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5leHBvcnQgY29uc3QgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5leHBvcnQgY29uc3QgT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcbmV4cG9ydCBjb25zdCBEc3RBbHBoYUZhY3RvciA9IDIwNjtcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuZXhwb3J0IGNvbnN0IERzdENvbG9yRmFjdG9yID0gMjA4O1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5leHBvcnQgY29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcbmV4cG9ydCBjb25zdCBOZXZlckRlcHRoID0gMDtcbmV4cG9ydCBjb25zdCBBbHdheXNEZXB0aCA9IDE7XG5leHBvcnQgY29uc3QgTGVzc0RlcHRoID0gMjtcbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxEZXB0aCA9IDM7XG5leHBvcnQgY29uc3QgRXF1YWxEZXB0aCA9IDQ7XG5leHBvcnQgY29uc3QgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJEZXB0aCA9IDY7XG5leHBvcnQgY29uc3QgTm90RXF1YWxEZXB0aCA9IDc7XG5leHBvcnQgY29uc3QgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuZXhwb3J0IGNvbnN0IE1peE9wZXJhdGlvbiA9IDE7XG5leHBvcnQgY29uc3QgQWRkT3BlcmF0aW9uID0gMjtcbmV4cG9ydCBjb25zdCBOb1RvbmVNYXBwaW5nID0gMDtcbmV4cG9ydCBjb25zdCBMaW5lYXJUb25lTWFwcGluZyA9IDE7XG5leHBvcnQgY29uc3QgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG5leHBvcnQgY29uc3QgQ2luZW9uVG9uZU1hcHBpbmcgPSAzO1xuZXhwb3J0IGNvbnN0IEFDRVNGaWxtaWNUb25lTWFwcGluZyA9IDQ7XG5leHBvcnQgY29uc3QgQ3VzdG9tVG9uZU1hcHBpbmcgPSA1O1xuXG5leHBvcnQgY29uc3QgVVZNYXBwaW5nID0gMzAwO1xuZXhwb3J0IGNvbnN0IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcbmV4cG9ydCBjb25zdCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5leHBvcnQgY29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5leHBvcnQgY29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5leHBvcnQgY29uc3QgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDY7XG5leHBvcnQgY29uc3QgUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuZXhwb3J0IGNvbnN0IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5leHBvcnQgY29uc3QgTGluZWFyRmlsdGVyID0gMTAwNjtcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IGNvbnN0IExpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5leHBvcnQgY29uc3QgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5leHBvcnQgY29uc3QgQnl0ZVR5cGUgPSAxMDEwO1xuZXhwb3J0IGNvbnN0IFNob3J0VHlwZSA9IDEwMTE7XG5leHBvcnQgY29uc3QgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuZXhwb3J0IGNvbnN0IEludFR5cGUgPSAxMDEzO1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG5leHBvcnQgY29uc3QgRmxvYXRUeXBlID0gMTAxNTtcbmV4cG9ydCBjb25zdCBIYWxmRmxvYXRUeXBlID0gMTAxNjtcbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG5leHBvcnQgY29uc3QgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcbmV4cG9ydCBjb25zdCBBbHBoYUZvcm1hdCA9IDEwMjE7XG5leHBvcnQgY29uc3QgUkdCQUZvcm1hdCA9IDEwMjM7XG5leHBvcnQgY29uc3QgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcbmV4cG9ydCBjb25zdCBMdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjU7XG5leHBvcnQgY29uc3QgRGVwdGhGb3JtYXQgPSAxMDI2O1xuZXhwb3J0IGNvbnN0IERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XG5leHBvcnQgY29uc3QgUmVkRm9ybWF0ID0gMTAyODtcbmV4cG9ydCBjb25zdCBSZWRJbnRlZ2VyRm9ybWF0ID0gMTAyOTtcbmV4cG9ydCBjb25zdCBSR0Zvcm1hdCA9IDEwMzA7XG5leHBvcnQgY29uc3QgUkdJbnRlZ2VyRm9ybWF0ID0gMTAzMTtcbmV4cG9ydCBjb25zdCBSR0JBSW50ZWdlckZvcm1hdCA9IDEwMzM7XG5cbmV4cG9ydCBjb25zdCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc2O1xuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc3O1xuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDMzNzc5O1xuZXhwb3J0IGNvbnN0IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDA7XG5leHBvcnQgY29uc3QgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MTtcbmV4cG9ydCBjb25zdCBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0MjtcbmV4cG9ydCBjb25zdCBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MztcbmV4cG9ydCBjb25zdCBSR0JfRVRDMV9Gb3JtYXQgPSAzNjE5NjtcbmV4cG9ydCBjb25zdCBSR0JfRVRDMl9Gb3JtYXQgPSAzNzQ5MjtcbmV4cG9ydCBjb25zdCBSR0JBX0VUQzJfRUFDX0Zvcm1hdCA9IDM3NDk2O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzV4NF9Gb3JtYXQgPSAzNzgwOTtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNXg1X0Zvcm1hdCA9IDM3ODEwO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgPSAzNzgxMjtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg1X0Zvcm1hdCA9IDM3ODEzO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4OF9Gb3JtYXQgPSAzNzgxNTtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSAzNzgxNjtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgPSAzNzgxODtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4MTBfRm9ybWF0ID0gMzc4MTk7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgPSAzNzgyMTtcbmV4cG9ydCBjb25zdCBSR0JBX0JQVENfRm9ybWF0ID0gMzY0OTI7XG5leHBvcnQgY29uc3QgUkdCX0JQVENfU0lHTkVEX0Zvcm1hdCA9IDM2NDk0O1xuZXhwb3J0IGNvbnN0IFJHQl9CUFRDX1VOU0lHTkVEX0Zvcm1hdCA9IDM2NDk1O1xuZXhwb3J0IGNvbnN0IFJFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4MztcbmV4cG9ydCBjb25zdCBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCA9IDM2Mjg0O1xuZXhwb3J0IGNvbnN0IFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NTtcbmV4cG9ydCBjb25zdCBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCA9IDM2Mjg2O1xuZXhwb3J0IGNvbnN0IExvb3BPbmNlID0gMjIwMDtcbmV4cG9ydCBjb25zdCBMb29wUmVwZWF0ID0gMjIwMTtcbmV4cG9ydCBjb25zdCBMb29wUGluZ1BvbmcgPSAyMjAyO1xuZXhwb3J0IGNvbnN0IEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuZXhwb3J0IGNvbnN0IEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG5leHBvcnQgY29uc3QgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5leHBvcnQgY29uc3QgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcbmV4cG9ydCBjb25zdCBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcbmV4cG9ydCBjb25zdCBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAwO1xuZXhwb3J0IGNvbnN0IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMTtcbmV4cG9ydCBjb25zdCBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbmV4cG9ydCBjb25zdCBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgTGluZWFyU1JHQkNvbG9yU3BhY2Ugb3IgTm9Db2xvclNwYWNlIGluIHRocmVlLmpzIHIxNTIrLiAqL1xuZXhwb3J0IGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgU1JHQkNvbG9yU3BhY2UgaW4gdGhyZWUuanMgcjE1MisuICovXG5leHBvcnQgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbmV4cG9ydCBjb25zdCBCYXNpY0RlcHRoUGFja2luZyA9IDMyMDA7XG5leHBvcnQgY29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5leHBvcnQgY29uc3QgVGFuZ2VudFNwYWNlTm9ybWFsTWFwID0gMDtcbmV4cG9ydCBjb25zdCBPYmplY3RTcGFjZU5vcm1hbE1hcCA9IDE7XG5cbi8vIENvbG9yIHNwYWNlIHN0cmluZyBpZGVudGlmaWVycywgbWF0Y2hpbmcgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0IGFuZCBXZWJHUFUgbmFtZXMgd2hlcmUgYXZhaWxhYmxlLlxuZXhwb3J0IGNvbnN0IE5vQ29sb3JTcGFjZSA9ICcnO1xuZXhwb3J0IGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuZXhwb3J0IGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbmV4cG9ydCBjb25zdCBEaXNwbGF5UDNDb2xvclNwYWNlID0gJ2Rpc3BsYXktcDMnO1xuZXhwb3J0IGNvbnN0IExpbmVhckRpc3BsYXlQM0NvbG9yU3BhY2UgPSAnZGlzcGxheS1wMy1saW5lYXInO1xuXG5leHBvcnQgY29uc3QgWmVyb1N0ZW5jaWxPcCA9IDA7XG5leHBvcnQgY29uc3QgS2VlcFN0ZW5jaWxPcCA9IDc2ODA7XG5leHBvcnQgY29uc3QgUmVwbGFjZVN0ZW5jaWxPcCA9IDc2ODE7XG5leHBvcnQgY29uc3QgSW5jcmVtZW50U3RlbmNpbE9wID0gNzY4MjtcbmV4cG9ydCBjb25zdCBEZWNyZW1lbnRTdGVuY2lsT3AgPSA3NjgzO1xuZXhwb3J0IGNvbnN0IEluY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NTtcbmV4cG9ydCBjb25zdCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTY7XG5leHBvcnQgY29uc3QgSW52ZXJ0U3RlbmNpbE9wID0gNTM4NjtcblxuZXhwb3J0IGNvbnN0IE5ldmVyU3RlbmNpbEZ1bmMgPSA1MTI7XG5leHBvcnQgY29uc3QgTGVzc1N0ZW5jaWxGdW5jID0gNTEzO1xuZXhwb3J0IGNvbnN0IEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XG5leHBvcnQgY29uc3QgTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSA1MTU7XG5leHBvcnQgY29uc3QgR3JlYXRlclN0ZW5jaWxGdW5jID0gNTE2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XG5leHBvcnQgY29uc3QgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMgPSA1MTg7XG5leHBvcnQgY29uc3QgQWx3YXlzU3RlbmNpbEZ1bmMgPSA1MTk7XG5cbmV4cG9ydCBjb25zdCBOZXZlckNvbXBhcmUgPSA1MTI7XG5leHBvcnQgY29uc3QgTGVzc0NvbXBhcmUgPSA1MTM7XG5leHBvcnQgY29uc3QgRXF1YWxDb21wYXJlID0gNTE0O1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbENvbXBhcmUgPSA1MTU7XG5leHBvcnQgY29uc3QgR3JlYXRlckNvbXBhcmUgPSA1MTY7XG5leHBvcnQgY29uc3QgTm90RXF1YWxDb21wYXJlID0gNTE3O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbENvbXBhcmUgPSA1MTg7XG5leHBvcnQgY29uc3QgQWx3YXlzQ29tcGFyZSA9IDUxOTtcblxuZXhwb3J0IGNvbnN0IFN0YXRpY0RyYXdVc2FnZSA9IDM1MDQ0O1xuZXhwb3J0IGNvbnN0IER5bmFtaWNEcmF3VXNhZ2UgPSAzNTA0ODtcbmV4cG9ydCBjb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmV4cG9ydCBjb25zdCBTdGF0aWNSZWFkVXNhZ2UgPSAzNTA0NTtcbmV4cG9ydCBjb25zdCBEeW5hbWljUmVhZFVzYWdlID0gMzUwNDk7XG5leHBvcnQgY29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5leHBvcnQgY29uc3QgU3RhdGljQ29weVVzYWdlID0gMzUwNDY7XG5leHBvcnQgY29uc3QgRHluYW1pY0NvcHlVc2FnZSA9IDM1MDUwO1xuZXhwb3J0IGNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuXG5leHBvcnQgY29uc3QgR0xTTDEgPSAnMTAwJztcbmV4cG9ydCBjb25zdCBHTFNMMyA9ICczMDAgZXMnO1xuXG5leHBvcnQgY29uc3QgX1NSR0JBRm9ybWF0ID0gMTAzNTsgLy8gZmFsbGJhY2sgZm9yIFdlYkdMIDFcblxuZXhwb3J0IGNvbnN0IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSA9IDIwMDA7XG5leHBvcnQgY29uc3QgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSA9IDIwMDE7XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgZGVub3JtYWxpemUsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IFN0YXRpY0RyYXdVc2FnZSwgRmxvYXRUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGZyb21IYWxmRmxvYXQsIHRvSGFsZkZsb2F0IH0gZnJvbSAnLi4vZXh0cmFzL0RhdGFVdGlscy5qcyc7XG5cbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmVjdG9yMiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcblxuY2xhc3MgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkID0gZmFsc2UgKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXHRcdHRoaXMuZ3B1VHlwZSA9IEZsb2F0VHlwZTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH1cblxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuXHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcblxuXHRcdHRoaXMudXNhZ2UgPSBzb3VyY2UudXNhZ2U7XG5cdFx0dGhpcy5ncHVUeXBlID0gc291cmNlLmdwdVR5cGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUF0KCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5QXJyYXkoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0aWYgKCB0aGlzLml0ZW1TaXplID09PSAyICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRfdmVjdG9yMi5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cdFx0XHRcdF92ZWN0b3IyLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFkoIGksIF92ZWN0b3IyLngsIF92ZWN0b3IyLnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5pdGVtU2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cdFx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXgzKCBtICk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci5hcHBseU1hdHJpeDQoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbSApO1xuXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci50cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXQoIHZhbHVlLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Ly8gTWF0Y2hpbmcgQnVmZmVyQXR0cmlidXRlIGNvbnN0cnVjdG9yLCBkbyBub3Qgbm9ybWFsaXplIHRoZSBhcnJheS5cblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXgsIGNvbXBvbmVudCApIHtcblxuXHRcdGxldCB2YWx1ZSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIGNvbXBvbmVudCBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB2YWx1ZSA9IGRlbm9ybWFsaXplKCB2YWx1ZSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB2YWx1ZSA9IG5vcm1hbGl6ZSggdmFsdWUsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIGNvbXBvbmVudCBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gZGVub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB4O1xuXG5cdH1cblxuXHRzZXRYKCBpbmRleCwgeCApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFkoIGluZGV4ICkge1xuXG5cdFx0bGV0IHkgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHk7XG5cblx0fVxuXG5cdHNldFkoIGluZGV4LCB5ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFooIGluZGV4ICkge1xuXG5cdFx0bGV0IHogPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHo7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFcoIGluZGV4ICkge1xuXG5cdFx0bGV0IHcgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBkZW5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHc7XG5cblx0fVxuXG5cdHNldFcoIGluZGV4LCB3ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG9uVXBsb2FkKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5LCB0aGlzLml0ZW1TaXplICkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRhcnJheTogQXJyYXkuZnJvbSggdGhpcy5hcnJheSApLFxuXHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIHRoaXMudXNhZ2UgIT09IFN0YXRpY0RyYXdVc2FnZSApIGRhdGEudXNhZ2UgPSB0aGlzLnVzYWdlO1xuXHRcdGlmICggdGhpcy51cGRhdGVSYW5nZS5vZmZzZXQgIT09IDAgfHwgdGhpcy51cGRhdGVSYW5nZS5jb3VudCAhPT0gLSAxICkgZGF0YS51cGRhdGVSYW5nZSA9IHRoaXMudXBkYXRlUmFuZ2U7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn1cblxuLy9cblxuY2xhc3MgSW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdHRoaXMuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Z2V0WCggaW5kZXggKSB7XG5cblx0XHRsZXQgeCA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHg7XG5cblx0fVxuXG5cdHNldFgoIGluZGV4LCB4ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WSggaW5kZXggKSB7XG5cblx0XHRsZXQgeSA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHo7XG5cblx0fVxuXG5cdHNldFooIGluZGV4LCB6ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFcoIGluZGV4ICkge1xuXG5cdFx0bGV0IHcgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4gdztcblxuXHR9XG5cblx0c2V0VyggaW5kZXgsIHcgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFkoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWiggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0gdG9IYWxmRmxvYXQoIHggKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHRvSGFsZkZsb2F0KCB3ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5jbGFzcyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuLy9cblxuZXhwb3J0IHtcblx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSxcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0RmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDMyQnVmZmVyQXR0cmlidXRlLFxuXHRJbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDE2QnVmZmVyQXR0cmlidXRlLFxuXHRJbnQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLFxuXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50OEJ1ZmZlckF0dHJpYnV0ZSxcblx0QnVmZmVyQXR0cmlidXRlXG59O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBVaW50MTZCdWZmZXJBdHRyaWJ1dGUsIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi9PYmplY3QzRC5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IGFycmF5TmVlZHNVaW50MzIgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmxldCBfaWQgPSAwO1xuXG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfb2JqID0gLypAX19QVVJFX18qLyBuZXcgT2JqZWN0M0QoKTtcbmNvbnN0IF9vZmZzZXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX2JveE1vcnBoVGFyZ2V0cyA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNsYXNzIEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZmFsc2U7XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHRnZXRJbmRleCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmluZGV4O1xuXG5cdH1cblxuXHRzZXRJbmRleCggaW5kZXggKSB7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGluZGV4ICkgKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgKCBhcnJheU5lZWRzVWludDMyKCBpbmRleCApID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGV4LCAxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0QXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdH1cblxuXHRzZXRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRlbGV0ZUF0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRoYXNBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gIT09IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0YWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCA9IDAgKSB7XG5cblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Y2xlYXJHcm91cHMoKSB7XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdH1cblxuXHRzZXREcmF3UmFuZ2UoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cG9zaXRpb24uYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdFx0bm9ybWFsLmFwcGx5Tm9ybWFsTWF0cml4KCBub3JtYWxNYXRyaXggKTtcblxuXHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnQgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcblxuXHRcdGlmICggdGFuZ2VudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0YW5nZW50LnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICk7XG5cblx0XHRcdHRhbmdlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdF9tMS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZVgoIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdF9tMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuXHRcdF9tMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuXHRcdF9tMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXG5cdFx0X20xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuXHRcdF9tMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsb29rQXQoIHZlY3RvciApIHtcblxuXHRcdF9vYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuXHRcdF9vYmoudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX29iai5tYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZW50ZXIoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIF9vZmZzZXQgKS5uZWdhdGUoKTtcblxuXHRcdHRoaXMudHJhbnNsYXRlKCBfb2Zmc2V0LngsIF9vZmZzZXQueSwgX29mZnNldC56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0cG9zaXRpb24ucHVzaCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXQoXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5IClcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRfYm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5taW4sIF9ib3gubWluICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCB0aGlzLmJvdW5kaW5nQm94Lm1heCwgX2JveC5tYXggKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfYm94Lm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblxuXHRcdH1cblxuXHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4gQWx0ZXJuYXRpdmVseSBzZXQgXCJtZXNoLmZydXN0dW1DdWxsZWRcIiB0byBcImZhbHNlXCIuJywgdGhpcyApO1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldCggbmV3IFZlY3RvcjMoKSwgSW5maW5pdHkgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwb3NpdGlvbiApIHtcblxuXHRcdFx0Ly8gZmlyc3QsIGZpbmQgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlXG5cblx0XHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG5cdFx0XHRfYm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdF9ib3hNb3JwaFRhcmdldHMuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCBfYm94Lm1pbiwgX2JveE1vcnBoVGFyZ2V0cy5taW4gKTtcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIF9ib3gubWF4LCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF9ib3hNb3JwaFRhcmdldHMubWF4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9ib3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0Ly8gc2Vjb25kLCB0cnkgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxuXHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggX3ZlY3RvciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG1vcnBoQXR0cmlidXRlLmNvdW50OyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGogKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfb2Zmc2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBqICk7XG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkKCBfb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggX3ZlY3RvciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG5cdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZVRhbmdlbnRzKCkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdC8vIChwZXIgdmVydGV4IHRhbmdlbnRzKVxuXG5cdFx0aWYgKCBpbmRleCA9PT0gbnVsbCB8fFxuXHRcdFx0IGF0dHJpYnV0ZXMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0IGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLnV2ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1diknICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHRjb25zdCBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cdFx0Y29uc3QgdXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcblxuXHRcdGNvbnN0IG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG5cdFx0aWYgKCB0aGlzLmhhc0F0dHJpYnV0ZSggJ3RhbmdlbnQnICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3RhbmdlbnQnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA0ICogblZlcnRpY2VzICksIDQgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGFuZ2VudHMgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3RhbmdlbnQnICkuYXJyYXk7XG5cblx0XHRjb25zdCB0YW4xID0gW10sIHRhbjIgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSArKyApIHtcblxuXHRcdFx0dGFuMVsgaSBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHRhbjJbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2QSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR2QiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR2QyA9IG5ldyBWZWN0b3IzKCksXG5cblx0XHRcdHV2QSA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHR1dkIgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZDID0gbmV3IFZlY3RvcjIoKSxcblxuXHRcdFx0c2RpciA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHR0ZGlyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBhLCBiLCBjICkge1xuXG5cdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXHRcdFx0dkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cblx0XHRcdHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcblx0XHRcdHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcblx0XHRcdHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcblxuXHRcdFx0dkIuc3ViKCB2QSApO1xuXHRcdFx0dkMuc3ViKCB2QSApO1xuXG5cdFx0XHR1dkIuc3ViKCB1dkEgKTtcblx0XHRcdHV2Qy5zdWIoIHV2QSApO1xuXG5cdFx0XHRjb25zdCByID0gMS4wIC8gKCB1dkIueCAqIHV2Qy55IC0gdXZDLnggKiB1dkIueSApO1xuXG5cdFx0XHQvLyBzaWxlbnRseSBpZ25vcmUgZGVnZW5lcmF0ZSB1diB0cmlhbmdsZXMgaGF2aW5nIGNvaW5jaWRlbnQgb3IgY29saW5lYXIgdmVydGljZXNcblxuXHRcdFx0aWYgKCAhIGlzRmluaXRlKCByICkgKSByZXR1cm47XG5cblx0XHRcdHNkaXIuY29weSggdkIgKS5tdWx0aXBseVNjYWxhciggdXZDLnkgKS5hZGRTY2FsZWRWZWN0b3IoIHZDLCAtIHV2Qi55ICkubXVsdGlwbHlTY2FsYXIoIHIgKTtcblx0XHRcdHRkaXIuY29weSggdkMgKS5tdWx0aXBseVNjYWxhciggdXZCLnggKS5hZGRTY2FsZWRWZWN0b3IoIHZCLCAtIHV2Qy54ICkubXVsdGlwbHlTY2FsYXIoIHIgKTtcblxuXHRcdFx0dGFuMVsgYSBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xuXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBjIF0uYWRkKCB0ZGlyICk7XG5cblx0XHR9XG5cblx0XHRsZXQgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdGdyb3VwcyA9IFsge1xuXHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0Y291bnQ6IGluZGljZXMubGVuZ3RoXG5cdFx0XHR9IF07XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0Y29uc3QgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0Zm9yICggbGV0IGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcblxuXHRcdFx0XHRoYW5kbGVUcmlhbmdsZShcblx0XHRcdFx0XHRpbmRpY2VzWyBqICsgMCBdLFxuXHRcdFx0XHRcdGluZGljZXNbIGogKyAxIF0sXG5cdFx0XHRcdFx0aW5kaWNlc1sgaiArIDIgXVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCB0bXAgPSBuZXcgVmVjdG9yMygpLCB0bXAyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBuID0gbmV3IFZlY3RvcjMoKSwgbjIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVmVydGV4KCB2ICkge1xuXG5cdFx0XHRuLmZyb21BcnJheSggbm9ybWFscywgdiAqIDMgKTtcblx0XHRcdG4yLmNvcHkoIG4gKTtcblxuXHRcdFx0Y29uc3QgdCA9IHRhbjFbIHYgXTtcblxuXHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuXHRcdFx0dG1wLmNvcHkoIHQgKTtcblx0XHRcdHRtcC5zdWIoIG4ubXVsdGlwbHlTY2FsYXIoIG4uZG90KCB0ICkgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHR0bXAyLmNyb3NzVmVjdG9ycyggbjIsIHQgKTtcblx0XHRcdGNvbnN0IHRlc3QgPSB0bXAyLmRvdCggdGFuMlsgdiBdICk7XG5cdFx0XHRjb25zdCB3ID0gKCB0ZXN0IDwgMC4wICkgPyAtIDEuMCA6IDEuMDtcblxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0IF0gPSB0bXAueDtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDEgXSA9IHRtcC55O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMiBdID0gdG1wLno7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAzIF0gPSB3O1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMCBdICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kaWNlc1sgaiArIDEgXSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGljZXNbIGogKyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb21wdXRlVmVydGV4Tm9ybWFscygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRpZiAoIHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxldCBub3JtYWxBdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblxuXHRcdFx0aWYgKCBub3JtYWxBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIDMgKSwgMyApO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub3JtYWxBdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGksIDAsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcEEgPSBuZXcgVmVjdG9yMygpLCBwQiA9IG5ldyBWZWN0b3IzKCksIHBDID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IG5BID0gbmV3IFZlY3RvcjMoKSwgbkIgPSBuZXcgVmVjdG9yMygpLCBuQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaW5kZXhlZCBlbGVtZW50c1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBpbmRleC5jb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2QSA9IGluZGV4LmdldFgoIGkgKyAwICk7XG5cdFx0XHRcdFx0Y29uc3QgdkIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IHZDID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHRcdHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QSApO1xuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QiApO1xuXHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QyApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRuQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZBICk7XG5cdFx0XHRcdFx0bkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QiApO1xuXHRcdFx0XHRcdG5DLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkMgKTtcblxuXHRcdFx0XHRcdG5BLmFkZCggY2IgKTtcblx0XHRcdFx0XHRuQi5hZGQoIGNiICk7XG5cdFx0XHRcdFx0bkMuYWRkKCBjYiApO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkEsIG5BLngsIG5BLnksIG5BLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QiwgbkIueCwgbkIueSwgbkIueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZDLCBuQy54LCBuQy55LCBuQy56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDAgKTtcblx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDIgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDAsIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMSwgY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAyLCBjYi54LCBjYi55LCBjYi56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdFx0XHRub3JtYWxBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRub3JtYWxpemVOb3JtYWxzKCkge1xuXG5cdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIGkgKTtcblxuXHRcdFx0X3ZlY3Rvci5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFscy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dG9Ob25JbmRleGVkKCkge1xuXG5cdFx0ZnVuY3Rpb24gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXG5cdFx0XHRjb25zdCBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcblxuXHRcdFx0bGV0IGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGF0dHJpYnV0ZS5kYXRhLnN0cmlkZSArIGF0dHJpYnV0ZS5vZmZzZXQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBhdHRyaWJ1dGVzXG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICk7XG5cblx0XHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgbW9ycGhBcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZVsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRcdG1vcnBoQXJyYXkucHVzaCggbmV3QXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkyLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gbW9ycGhBcnJheTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5Mi5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRnZW9tZXRyeTIuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5MjtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdC8vIGZvciBzaW1wbGljaXR5IHRoZSBjb2RlIGFzc3VtZXMgYXR0cmlidXRlcyBhcmUgbm90IHNoYXJlZCBhY3Jvc3MgZ2VvbWV0cmllcywgc2VlICMxNTgxMVxuXG5cdFx0ZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xuXHRcdFx0XHR0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5IClcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdGxldCBoYXNNb3JwaEF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSB0aGlzLm1vcnBoQXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhdHRyaWJ1dGVBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVsgaSBdO1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS50b0pTT04oIGRhdGEuZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1vcnBoQXR0cmlidXRlc1sga2V5IF0gPSBhcnJheTtcblxuXHRcdFx0XHRoYXNNb3JwaEF0dHJpYnV0ZXMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc01vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLm1vcnBoQXR0cmlidXRlcyA9IG1vcnBoQXR0cmlidXRlcztcblx0XHRcdGRhdGEuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0Ly8gcmVzZXRcblxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8vIHVzZWQgZm9yIHN0b3JpbmcgY2xvbmVkLCBzaGFyZWQgZGF0YVxuXG5cdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0Ly8gbmFtZVxuXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHQvLyBpbmRleFxuXG5cdFx0Y29uc3QgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSggZGF0YSApICk7XG5cblx0XHR9XG5cblx0XHQvLyBhdHRyaWJ1dGVzXG5cblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSggZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHNvdXJjZS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdC8vIGdyb3Vwc1xuXG5cdFx0Y29uc3QgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBib3hcblxuXHRcdGNvbnN0IGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xuXG5cdFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHQvLyBib3VuZGluZyBzcGhlcmVcblxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHQvLyBkcmF3IHJhbmdlXG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHNvdXJjZS5kcmF3UmFuZ2Uuc3RhcnQ7XG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBzb3VyY2UuZHJhd1JhbmdlLmNvdW50O1xuXG5cdFx0Ly8gdXNlciBkYXRhXG5cblx0XHR0aGlzLnVzZXJEYXRhID0gc291cmNlLnVzZXJEYXRhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnkgfTtcbiIsIi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRhZGRFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcblxuXHRcdH1cblxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRoYXNFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRyZXR1cm4gbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDE7XG5cblx0fVxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cblx0XHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRkaXNwYXRjaEV2ZW50KCBldmVudCApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdC8vIE1ha2UgYSBjb3B5LCBpbiBjYXNlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCB3aGlsZSBpdGVyYXRpbmcuXG5cdFx0XHRjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoIDAgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBFdmVudERpc3BhdGNoZXIgfTtcbiIsImNsYXNzIExheWVycyB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAxIHwgMDtcblxuXHR9XG5cblx0c2V0KCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrID0gKCAxIDw8IGNoYW5uZWwgfCAwICkgPj4+IDA7XG5cblx0fVxuXG5cdGVuYWJsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRlbmFibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAweGZmZmZmZmZmIHwgMDtcblxuXHR9XG5cblx0dG9nZ2xlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0fVxuXG5cdGRpc2FibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcblxuXHR9XG5cblx0ZGlzYWJsZUFsbCgpIHtcblxuXHRcdHRoaXMubWFzayA9IDA7XG5cblx0fVxuXG5cdHRlc3QoIGxheWVycyApIHtcblxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XG5cblx0fVxuXG5cdGlzRW5hYmxlZCggY2hhbm5lbCApIHtcblxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmICggMSA8PCBjaGFubmVsIHwgMCApICkgIT09IDA7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgTGF5ZXJzIH07XG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG5sZXQgX29iamVjdDNESWQgPSAwO1xuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcTEgPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfdGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfc2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcblxuY29uc3QgX3hBeGlzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuY29uc3QgX3lBeGlzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuY29uc3QgX3pBeGlzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMCwgMSApO1xuXG5jb25zdCBfYWRkZWRFdmVudCA9IHsgdHlwZTogJ2FkZGVkJyB9O1xuY29uc3QgX3JlbW92ZWRFdmVudCA9IHsgdHlwZTogJ3JlbW92ZWQnIH07XG5cbmNsYXNzIE9iamVjdDNEIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzT2JqZWN0M0QgPSB0cnVlO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfb2JqZWN0M0RJZCArKyB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5ERUZBVUxUX1VQLmNsb25lKCk7XG5cblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0XHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cblx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRyb3RhdGlvbi5fb25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0XHRxdWF0ZXJuaW9uLl9vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdFx0fSxcblx0XHRcdHF1YXRlcm5pb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHR9LFxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH1cblxuXHRvbkJlZm9yZVJlbmRlciggLyogcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKi8gKSB7fVxuXG5cdG9uQWZ0ZXJSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdHRoaXMubWF0cml4LnByZW11bHRpcGx5KCBtYXRyaXggKTtcblxuXHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggcSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0fVxuXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cblx0fVxuXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeCggbSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cblx0fVxuXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuXHR9XG5cblx0cm90YXRlT25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3ExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIF9xMSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZU9uV29ybGRBeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiB3b3JsZCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0Ly8gbWV0aG9kIGFzc3VtZXMgbm8gcm90YXRlZCBwYXJlbnRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3hBeGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRyb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3lBeGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRyb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3pBeGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHR0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRfdjEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmFkZCggX3YxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlWCggZGlzdGFuY2UgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIF94QXhpcywgZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlWSggZGlzdGFuY2UgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIF95QXhpcywgZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIF96QXhpcywgZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0bG9jYWxUb1dvcmxkKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHR9XG5cblx0d29ybGRUb0xvY2FsKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIF9tMS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCkgKTtcblxuXHR9XG5cblx0bG9va0F0KCB4LCB5LCB6ICkge1xuXG5cdFx0Ly8gVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBwYXJlbnQocylcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdF90YXJnZXQuY29weSggeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X3RhcmdldC5zZXQoIHgsIHksIHogKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF9wb3NpdGlvbiwgX3RhcmdldCwgdGhpcy51cCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X20xLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRfbTEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEuaW52ZXJ0KCkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0YWRkKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW5cXCd0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLicsIG9iamVjdCApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdGhpcztcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCBfYWRkZWRFdmVudCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC4nLCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyZW1vdmUoIG9iamVjdCApIHtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCBfcmVtb3ZlZEV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlRnJvbVBhcmVudCgpIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHBhcmVudC5yZW1vdmUoIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGVhcigpIHtcblxuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggLi4uIHRoaXMuY2hpbGRyZW4gKTtcblxuXHR9XG5cblx0YXR0YWNoKCBvYmplY3QgKSB7XG5cblx0XHQvLyBhZGRzIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMsIHdoaWxlIG1haW50YWluaW5nIHRoZSBvYmplY3QncyB3b3JsZCB0cmFuc2Zvcm1cblxuXHRcdC8vIE5vdGU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2NlbmUgZ3JhcGhzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBub2RlcyhzKVxuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9tMS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cblx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdG9iamVjdC5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRcdF9tMS5tdWx0aXBseSggb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0b2JqZWN0LmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCB0cnVlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlJZCggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdH1cblxuXHRnZXRPYmplY3RCeU5hbWUoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGdldE9iamVjdHNCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApIHtcblxuXHRcdGxldCByZXN1bHQgPSBbXTtcblxuXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJlc3VsdC5wdXNoKCB0aGlzICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkUmVzdWx0ID0gdGhpcy5jaGlsZHJlblsgaSBdLmdldE9iamVjdHNCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGNoaWxkUmVzdWx0Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdCggY2hpbGRSZXN1bHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0Z2V0V29ybGRQb3NpdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdGdldFdvcmxkUXVhdGVybmlvbiggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIHRhcmdldCwgX3NjYWxlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRXb3JsZFNjYWxlKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIF9wb3NpdGlvbiwgX3F1YXRlcm5pb24sIHRhcmdldCApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGREaXJlY3Rpb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRjb25zdCBlID0gdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztcblxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCBlWyA4IF0sIGVbIDkgXSwgZVsgMTAgXSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRyYXljYXN0KCAvKiByYXljYXN0ZXIsIGludGVyc2VjdHMgKi8gKSB7fVxuXG5cdHRyYXZlcnNlKCBjYWxsYmFjayApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlTWF0cml4KCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWyBpIF07XG5cblx0XHRcdGlmICggY2hpbGQubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNoaWxkLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApIHtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCB1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHRpZiAoIHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y2hpbGQudXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCB0cnVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvSlNPTiggbWV0YSApIHtcblxuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xuXG5cdFx0Y29uc3Qgb3V0cHV0ID0ge307XG5cblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0Z2VvbWV0cmllczoge30sXG5cdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0aW1hZ2VzOiB7fSxcblx0XHRcdFx0c2hhcGVzOiB7fSxcblx0XHRcdFx0c2tlbGV0b25zOiB7fSxcblx0XHRcdFx0YW5pbWF0aW9uczoge30sXG5cdFx0XHRcdG5vZGVzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG5cdFx0Y29uc3Qgb2JqZWN0ID0ge307XG5cblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMucmVuZGVyT3JkZXIgIT09IDAgKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdG9iamVjdC5sYXllcnMgPSB0aGlzLmxheWVycy5tYXNrO1xuXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG5cdFx0b2JqZWN0LnVwID0gdGhpcy51cC50b0FycmF5KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gZmFsc2UgKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0Ly8gb2JqZWN0IHNwZWNpZmljIHByb3BlcnRpZXNcblxuXHRcdGlmICggdGhpcy5pc0luc3RhbmNlZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC50eXBlID0gJ0luc3RhbmNlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcblx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCk7XG5cdFx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gdGhpcy5pbnN0YW5jZUNvbG9yLnRvSlNPTigpO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZSggbGlicmFyeSwgZWxlbWVudCApIHtcblxuXHRcdFx0aWYgKCBsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbWVudC51dWlkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzU2NlbmUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlICYmIHRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IHRoaXMuZW52aXJvbm1lbnQudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cyApIHtcblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKCBtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkgKTtcblxuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztcblxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBpIF07XG5cblx0XHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC5iaW5kTW9kZSA9IHRoaXMuYmluZE1vZGU7XG5cdFx0XHRvYmplY3QuYmluZE1hdHJpeCA9IHRoaXMuYmluZE1hdHJpeC50b0FycmF5KCk7XG5cblx0XHRcdGlmICggdGhpcy5za2VsZXRvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5za2VsZXRvbnMsIHRoaXMuc2tlbGV0b24gKTtcblxuXHRcdFx0XHRvYmplY3Quc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRjb25zdCB1dWlkcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHV1aWRzLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbIGkgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5hbmltYXRpb25zLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG9iamVjdC5hbmltYXRpb25zID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zWyBpIF07XG5cblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMucHVzaCggc2VyaWFsaXplKCBtZXRhLmFuaW1hdGlvbnMsIGFuaW1hdGlvbiApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5zaGFwZXMgKTtcblx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2tlbGV0b25zICk7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5hbmltYXRpb25zICk7XG5cdFx0XHRjb25zdCBub2RlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubm9kZXMgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cdFx0XHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcblx0XHRcdGlmICggc2tlbGV0b25zLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2tlbGV0b25zID0gc2tlbGV0b25zO1xuXHRcdFx0aWYgKCBhbmltYXRpb25zLmxlbmd0aCA+IDAgKSBvdXRwdXQuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQubm9kZXMgPSBub2RlcztcblxuXHRcdH1cblxuXHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcblx0XHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXG5cdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlID0gdHJ1ZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHNvdXJjZS5yb3RhdGlvbi5vcmRlcjtcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcblx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZTtcblxuXHRcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBzb3VyY2UuYW5pbWF0aW9ucy5zbGljZSgpO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbk9iamVjdDNELkRFRkFVTFRfVVAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSA9IHRydWU7XG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSA9IHRydWU7XG5cbmV4cG9ydCB7IE9iamVjdDNEIH07XG4iLCJpbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuLy8gRmFzdCBIYWxmIEZsb2F0IENvbnZlcnNpb25zLCBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbmNvbnN0IF90YWJsZXMgPSAvKkBfX1BVUkVfXyovIF9nZW5lcmF0ZVRhYmxlcygpO1xuXG5mdW5jdGlvbiBfZ2VuZXJhdGVUYWJsZXMoKSB7XG5cblx0Ly8gZmxvYXQzMiB0byBmbG9hdDE2IGhlbHBlcnNcblxuXHRjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoIDQgKTtcblx0Y29uc3QgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cdGNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdGNvbnN0IGJhc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNTEyICk7XG5cdGNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IDI1NjsgKysgaSApIHtcblxuXHRcdGNvbnN0IGUgPSBpIC0gMTI3O1xuXG5cdFx0Ly8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuXG5cdFx0aWYgKCBlIDwgLSAyNyApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDAwMDA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMjQ7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDI0O1xuXG5cdFx0XHQvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcblxuXHRcdH0gZWxzZSBpZiAoIGUgPCAtIDE0ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4MDQwMCA+PiAoIC0gZSAtIDE0ICk7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAweDA0MDAgPj4gKCAtIGUgLSAxNCApICkgfCAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAtIGUgLSAxO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAtIGUgLSAxO1xuXG5cdFx0XHQvLyBub3JtYWwgbnVtYmVyXG5cblx0XHR9IGVsc2UgaWYgKCBlIDw9IDE1ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9ICggZSArIDE1ICkgPDwgMTA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAoIGUgKyAxNSApIDw8IDEwICkgfCAweDgwMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAxMztcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMTM7XG5cblx0XHRcdC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSBpZiAoIGUgPCAxMjggKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDdjMDA7XG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHhmYzAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBmbG9hdDE2IHRvIGZsb2F0MzIgaGVscGVyc1xuXG5cdGNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDIwNDggKTtcblx0Y29uc3QgZXhwb25lbnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNjQgKTtcblx0Y29uc3Qgb2Zmc2V0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgMTAyNDsgKysgaSApIHtcblxuXHRcdGxldCBtID0gaSA8PCAxMzsgLy8gemVybyBwYWQgbWFudGlzc2EgYml0c1xuXHRcdGxldCBlID0gMDsgLy8gemVybyBleHBvbmVudFxuXG5cdFx0Ly8gbm9ybWFsaXplZFxuXHRcdHdoaWxlICggKCBtICYgMHgwMDgwMDAwMCApID09PSAwICkge1xuXG5cdFx0XHRtIDw8PSAxO1xuXHRcdFx0ZSAtPSAweDAwODAwMDAwOyAvLyBkZWNyZW1lbnQgZXhwb25lbnRcblxuXHRcdH1cblxuXHRcdG0gJj0gfiAweDAwODAwMDAwOyAvLyBjbGVhciBsZWFkaW5nIDEgYml0XG5cdFx0ZSArPSAweDM4ODAwMDAwOyAvLyBhZGp1c3QgYmlhc1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gbSB8IGU7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTAyNDsgaSA8IDIwNDg7ICsrIGkgKSB7XG5cblx0XHRtYW50aXNzYVRhYmxlWyBpIF0gPSAweDM4MDAwMDAwICsgKCAoIGkgLSAxMDI0ICkgPDwgMTMgKTtcblxuXHR9XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgMzE7ICsrIGkgKSB7XG5cblx0XHRleHBvbmVudFRhYmxlWyBpIF0gPSBpIDw8IDIzO1xuXG5cdH1cblxuXHRleHBvbmVudFRhYmxlWyAzMSBdID0gMHg0NzgwMDAwMDtcblx0ZXhwb25lbnRUYWJsZVsgMzIgXSA9IDB4ODAwMDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAzMzsgaSA8IDYzOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gMHg4MDAwMDAwMCArICggKCBpIC0gMzIgKSA8PCAyMyApO1xuXG5cdH1cblxuXHRleHBvbmVudFRhYmxlWyA2MyBdID0gMHhjNzgwMDAwMDtcblxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCA2NDsgKysgaSApIHtcblxuXHRcdGlmICggaSAhPT0gMzIgKSB7XG5cblx0XHRcdG9mZnNldFRhYmxlWyBpIF0gPSAxMDI0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGZsb2F0VmlldzogZmxvYXRWaWV3LFxuXHRcdHVpbnQzMlZpZXc6IHVpbnQzMlZpZXcsXG5cdFx0YmFzZVRhYmxlOiBiYXNlVGFibGUsXG5cdFx0c2hpZnRUYWJsZTogc2hpZnRUYWJsZSxcblx0XHRtYW50aXNzYVRhYmxlOiBtYW50aXNzYVRhYmxlLFxuXHRcdGV4cG9uZW50VGFibGU6IGV4cG9uZW50VGFibGUsXG5cdFx0b2Zmc2V0VGFibGU6IG9mZnNldFRhYmxlXG5cdH07XG5cbn1cblxuLy8gZmxvYXQzMiB0byBmbG9hdDE2XG5cbmZ1bmN0aW9uIHRvSGFsZkZsb2F0KCB2YWwgKSB7XG5cblx0aWYgKCBNYXRoLmFicyggdmFsICkgPiA2NTUwNCApIGNvbnNvbGUud2FybiggJ1RIUkVFLkRhdGFVdGlscy50b0hhbGZGbG9hdCgpOiBWYWx1ZSBvdXQgb2YgcmFuZ2UuJyApO1xuXG5cdHZhbCA9IGNsYW1wKCB2YWwsIC0gNjU1MDQsIDY1NTA0ICk7XG5cblx0X3RhYmxlcy5mbG9hdFZpZXdbIDAgXSA9IHZhbDtcblx0Y29uc3QgZiA9IF90YWJsZXMudWludDMyVmlld1sgMCBdO1xuXHRjb25zdCBlID0gKCBmID4+IDIzICkgJiAweDFmZjtcblx0cmV0dXJuIF90YWJsZXMuYmFzZVRhYmxlWyBlIF0gKyAoICggZiAmIDB4MDA3ZmZmZmYgKSA+PiBfdGFibGVzLnNoaWZ0VGFibGVbIGUgXSApO1xuXG59XG5cbi8vIGZsb2F0MTYgdG8gZmxvYXQzMlxuXG5mdW5jdGlvbiBmcm9tSGFsZkZsb2F0KCB2YWwgKSB7XG5cblx0Y29uc3QgbSA9IHZhbCA+PiAxMDtcblx0X3RhYmxlcy51aW50MzJWaWV3WyAwIF0gPSBfdGFibGVzLm1hbnRpc3NhVGFibGVbIF90YWJsZXMub2Zmc2V0VGFibGVbIG0gXSArICggdmFsICYgMHgzZmYgKSBdICsgX3RhYmxlcy5leHBvbmVudFRhYmxlWyBtIF07XG5cdHJldHVybiBfdGFibGVzLmZsb2F0Vmlld1sgMCBdO1xuXG59XG5cbmNvbnN0IERhdGFVdGlscyA9IHtcblx0dG9IYWxmRmxvYXQ6IHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0OiBmcm9tSGFsZkZsb2F0LFxufTtcblxuZXhwb3J0IHtcblx0dG9IYWxmRmxvYXQsXG5cdGZyb21IYWxmRmxvYXQsXG5cdERhdGFVdGlsc1xufTtcbiIsIi8qKlxuICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4yLjQpXG4gKi9cblxuY29uc3QgRWFyY3V0ID0ge1xuXG5cdHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiAoIGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gPSAyICkge1xuXG5cdFx0Y29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG5cdFx0Y29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWyAwIF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblx0XHRsZXQgb3V0ZXJOb2RlID0gbGlua2VkTGlzdCggZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSApO1xuXHRcdGNvbnN0IHRyaWFuZ2xlcyA9IFtdO1xuXG5cdFx0aWYgKCAhIG91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYgKSByZXR1cm4gdHJpYW5nbGVzO1xuXG5cdFx0bGV0IG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cblx0XHRpZiAoIGhhc0hvbGVzICkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApO1xuXG5cdFx0Ly8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG5cdFx0aWYgKCBkYXRhLmxlbmd0aCA+IDgwICogZGltICkge1xuXG5cdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcblx0XHRcdG1pblkgPSBtYXhZID0gZGF0YVsgMSBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSApIHtcblxuXHRcdFx0XHR4ID0gZGF0YVsgaSBdO1xuXHRcdFx0XHR5ID0gZGF0YVsgaSArIDEgXTtcblx0XHRcdFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xuXHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcblx0XHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG5cdFx0XHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xuXHRcdFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuXG5cdFx0fVxuXG5cdFx0ZWFyY3V0TGlua2VkKCBvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwICk7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVzO1xuXG5cdH1cblxufTtcblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSApIHtcblxuXHRsZXQgaSwgbGFzdDtcblxuXHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcblxuXHRcdGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0gKSBsYXN0ID0gaW5zZXJ0Tm9kZSggaSwgZGF0YVsgaSBdLCBkYXRhWyBpICsgMSBdLCBsYXN0ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xuXG5cdH1cblxuXHRpZiAoIGxhc3QgJiYgZXF1YWxzKCBsYXN0LCBsYXN0Lm5leHQgKSApIHtcblxuXHRcdHJlbW92ZU5vZGUoIGxhc3QgKTtcblx0XHRsYXN0ID0gbGFzdC5uZXh0O1xuXG5cdH1cblxuXHRyZXR1cm4gbGFzdDtcblxufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKCBzdGFydCwgZW5kICkge1xuXG5cdGlmICggISBzdGFydCApIHJldHVybiBzdGFydDtcblx0aWYgKCAhIGVuZCApIGVuZCA9IHN0YXJ0O1xuXG5cdGxldCBwID0gc3RhcnQsXG5cdFx0YWdhaW47XG5cdGRvIHtcblxuXHRcdGFnYWluID0gZmFsc2U7XG5cblx0XHRpZiAoICEgcC5zdGVpbmVyICYmICggZXF1YWxzKCBwLCBwLm5leHQgKSB8fCBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID09PSAwICkgKSB7XG5cblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcblx0XHRcdHAgPSBlbmQgPSBwLnByZXY7XG5cdFx0XHRpZiAoIHAgPT09IHAubmV4dCApIGJyZWFrO1xuXHRcdFx0YWdhaW4gPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cCA9IHAubmV4dDtcblxuXHRcdH1cblxuXHR9IHdoaWxlICggYWdhaW4gfHwgcCAhPT0gZW5kICk7XG5cblx0cmV0dXJuIGVuZDtcblxufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyApIHtcblxuXHRpZiAoICEgZWFyICkgcmV0dXJuO1xuXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXG5cdGxldCBzdG9wID0gZWFyLFxuXHRcdHByZXYsIG5leHQ7XG5cblx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG5cdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xuXG5cdFx0cHJldiA9IGVhci5wcmV2O1xuXHRcdG5leHQgPSBlYXIubmV4dDtcblxuXHRcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcblxuXHRcdFx0Ly8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwcmV2LmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggZWFyLmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggbmV4dC5pIC8gZGltIHwgMCApO1xuXG5cdFx0XHRyZW1vdmVOb2RlKCBlYXIgKTtcblxuXHRcdFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuXHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xuXHRcdFx0c3RvcCA9IG5leHQubmV4dDtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHRlYXIgPSBuZXh0O1xuXG5cdFx0Ly8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcblx0XHRpZiAoIGVhciA9PT0gc3RvcCApIHtcblxuXHRcdFx0Ly8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cblx0XHRcdGlmICggISBwYXNzICkge1xuXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEgKTtcblxuXHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXNzID09PSAxICkge1xuXG5cdFx0XHRcdGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIGZpbHRlclBvaW50cyggZWFyICksIHRyaWFuZ2xlcywgZGltICk7XG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMiApO1xuXG5cdFx0XHRcdC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG5cblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XG5cblx0XHRcdFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhciggZWFyICkge1xuXG5cdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRiID0gZWFyLFxuXHRcdGMgPSBlYXIubmV4dDtcblxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG5cdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cdGNvbnN0IGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cblx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcblx0Y29uc3QgeDAgPSBheCA8IGJ4ID8gKCBheCA8IGN4ID8gYXggOiBjeCApIDogKCBieCA8IGN4ID8gYnggOiBjeCApLFxuXHRcdHkwID0gYXkgPCBieSA/ICggYXkgPCBjeSA/IGF5IDogY3kgKSA6ICggYnkgPCBjeSA/IGJ5IDogY3kgKSxcblx0XHR4MSA9IGF4ID4gYnggPyAoIGF4ID4gY3ggPyBheCA6IGN4ICkgOiAoIGJ4ID4gY3ggPyBieCA6IGN4ICksXG5cdFx0eTEgPSBheSA+IGJ5ID8gKCBheSA+IGN5ID8gYXkgOiBjeSApIDogKCBieSA+IGN5ID8gYnkgOiBjeSApO1xuXG5cdGxldCBwID0gYy5uZXh0O1xuXHR3aGlsZSAoIHAgIT09IGEgKSB7XG5cblx0XHRpZiAoIHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmXG5cdFx0XHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHRjb25zdCBhID0gZWFyLnByZXYsXG5cdFx0YiA9IGVhcixcblx0XHRjID0gZWFyLm5leHQ7XG5cblx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuXHRjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG5cdGNvbnN0IHgwID0gYXggPCBieCA/ICggYXggPCBjeCA/IGF4IDogY3ggKSA6ICggYnggPCBjeCA/IGJ4IDogY3ggKSxcblx0XHR5MCA9IGF5IDwgYnkgPyAoIGF5IDwgY3kgPyBheSA6IGN5ICkgOiAoIGJ5IDwgY3kgPyBieSA6IGN5ICksXG5cdFx0eDEgPSBheCA+IGJ4ID8gKCBheCA+IGN4ID8gYXggOiBjeCApIDogKCBieCA+IGN4ID8gYnggOiBjeCApLFxuXHRcdHkxID0gYXkgPiBieSA/ICggYXkgPiBjeSA/IGF5IDogY3kgKSA6ICggYnkgPiBjeSA/IGJ5IDogY3kgKTtcblxuXHQvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuXHRjb25zdCBtaW5aID0gek9yZGVyKCB4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUgKSxcblx0XHRtYXhaID0gek9yZGVyKCB4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRsZXQgcCA9IGVhci5wcmV2Wixcblx0XHRuID0gZWFyLm5leHRaO1xuXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuXHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4WiApIHtcblxuXHRcdGlmICggcC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5wcmV2WjtcblxuXHRcdGlmICggbi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSApICYmIGFyZWEoIG4ucHJldiwgbiwgbi5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRuID0gbi5uZXh0WjtcblxuXHR9XG5cblx0Ly8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcblx0d2hpbGUgKCBwICYmIHAueiA+PSBtaW5aICkge1xuXG5cdFx0aWYgKCBwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdHAgPSBwLnByZXZaO1xuXG5cdH1cblxuXHQvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuXHR3aGlsZSAoIG4gJiYgbi56IDw9IG1heFogKSB7XG5cblx0XHRpZiAoIG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkgKSAmJiBhcmVhKCBuLnByZXYsIG4sIG4ubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0biA9IG4ubmV4dFo7XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XG5cblx0bGV0IHAgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0Y29uc3QgYSA9IHAucHJldixcblx0XHRcdGIgPSBwLm5leHQubmV4dDtcblxuXHRcdGlmICggISBlcXVhbHMoIGEsIGIgKSAmJiBpbnRlcnNlY3RzKCBhLCBwLCBwLm5leHQsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICkge1xuXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggYS5pIC8gZGltIHwgMCApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goIHAuaSAvIGRpbSB8IDAgKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gfCAwICk7XG5cblx0XHRcdC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcblx0XHRcdHJlbW92ZU5vZGUoIHAubmV4dCApO1xuXG5cdFx0XHRwID0gc3RhcnQgPSBiO1xuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRyZXR1cm4gZmlsdGVyUG9pbnRzKCBwICk7XG5cbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KCBzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cblx0bGV0IGEgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0bGV0IGIgPSBhLm5leHQubmV4dDtcblx0XHR3aGlsZSAoIGIgIT09IGEucHJldiApIHtcblxuXHRcdFx0aWYgKCBhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSApIHtcblxuXHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG5cdFx0XHRcdGxldCBjID0gc3BsaXRQb2x5Z29uKCBhLCBiICk7XG5cblx0XHRcdFx0Ly8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblx0XHRcdFx0YSA9IGZpbHRlclBvaW50cyggYSwgYS5uZXh0ICk7XG5cdFx0XHRcdGMgPSBmaWx0ZXJQb2ludHMoIGMsIGMubmV4dCApO1xuXG5cdFx0XHRcdC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDAgKTtcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0YiA9IGIubmV4dDtcblxuXHRcdH1cblxuXHRcdGEgPSBhLm5leHQ7XG5cblx0fSB3aGlsZSAoIGEgIT09IHN0YXJ0ICk7XG5cbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApIHtcblxuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKysgKSB7XG5cblx0XHRzdGFydCA9IGhvbGVJbmRpY2VzWyBpIF0gKiBkaW07XG5cdFx0ZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1sgaSArIDEgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdGxpc3QgPSBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlICk7XG5cdFx0aWYgKCBsaXN0ID09PSBsaXN0Lm5leHQgKSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuXHRcdHF1ZXVlLnB1c2goIGdldExlZnRtb3N0KCBsaXN0ICkgKTtcblxuXHR9XG5cblx0cXVldWUuc29ydCggY29tcGFyZVggKTtcblxuXHQvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuXHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUoIHF1ZXVlWyBpIF0sIG91dGVyTm9kZSApO1xuXG5cdH1cblxuXHRyZXR1cm4gb3V0ZXJOb2RlO1xuXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKCBhLCBiICkge1xuXG5cdHJldHVybiBhLnggLSBiLng7XG5cbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoIGhvbGUsIG91dGVyTm9kZSApIHtcblxuXHRjb25zdCBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICk7XG5cdGlmICggISBicmlkZ2UgKSB7XG5cblx0XHRyZXR1cm4gb3V0ZXJOb2RlO1xuXG5cdH1cblxuXHRjb25zdCBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKCBicmlkZ2UsIGhvbGUgKTtcblxuXHQvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblx0ZmlsdGVyUG9pbnRzKCBicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQgKTtcblx0cmV0dXJuIGZpbHRlclBvaW50cyggYnJpZGdlLCBicmlkZ2UubmV4dCApO1xuXG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XG5cblx0bGV0IHAgPSBvdXRlck5vZGUsXG5cdFx0cXggPSAtIEluZmluaXR5LFxuXHRcdG07XG5cblx0Y29uc3QgaHggPSBob2xlLngsIGh5ID0gaG9sZS55O1xuXG5cdC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcblx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuXHRkbyB7XG5cblx0XHRpZiAoIGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55ICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcC54ICsgKCBoeSAtIHAueSApICogKCBwLm5leHQueCAtIHAueCApIC8gKCBwLm5leHQueSAtIHAueSApO1xuXHRcdFx0aWYgKCB4IDw9IGh4ICYmIHggPiBxeCApIHtcblxuXHRcdFx0XHRxeCA9IHg7XG5cdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG5cdFx0XHRcdGlmICggeCA9PT0gaHggKSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gb3V0ZXJOb2RlICk7XG5cblx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcblxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG5cdC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG5cdGNvbnN0IHN0b3AgPSBtLFxuXHRcdG14ID0gbS54LFxuXHRcdG15ID0gbS55O1xuXHRsZXQgdGFuTWluID0gSW5maW5pdHksIHRhbjtcblxuXHRwID0gbTtcblxuXHRkbyB7XG5cblx0XHRpZiAoIGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuXHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XG5cblx0XHRcdHRhbiA9IE1hdGguYWJzKCBoeSAtIHAueSApIC8gKCBoeCAtIHAueCApOyAvLyB0YW5nZW50aWFsXG5cblx0XHRcdGlmICggbG9jYWxseUluc2lkZSggcCwgaG9sZSApICYmICggdGFuIDwgdGFuTWluIHx8ICggdGFuID09PSB0YW5NaW4gJiYgKCBwLnggPiBtLnggfHwgKCBwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvciggbSwgcCApICkgKSApICkgKSB7XG5cblx0XHRcdFx0bSA9IHA7XG5cdFx0XHRcdHRhbk1pbiA9IHRhbjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RvcCApO1xuXG5cdHJldHVybiBtO1xuXG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IoIG0sIHAgKSB7XG5cblx0cmV0dXJuIGFyZWEoIG0ucHJldiwgbSwgcC5wcmV2ICkgPCAwICYmIGFyZWEoIHAubmV4dCwgbSwgbS5uZXh0ICkgPCAwO1xuXG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoIHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdGxldCBwID0gc3RhcnQ7XG5cdGRvIHtcblxuXHRcdGlmICggcC56ID09PSAwICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXHRcdHAucHJldlogPSBwLnByZXY7XG5cdFx0cC5uZXh0WiA9IHAubmV4dDtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xuXG5cdHAucHJldloubmV4dFogPSBudWxsO1xuXHRwLnByZXZaID0gbnVsbDtcblxuXHRzb3J0TGlua2VkKCBwICk7XG5cbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKCBsaXN0ICkge1xuXG5cdGxldCBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcblx0XHRpblNpemUgPSAxO1xuXG5cdGRvIHtcblxuXHRcdHAgPSBsaXN0O1xuXHRcdGxpc3QgPSBudWxsO1xuXHRcdHRhaWwgPSBudWxsO1xuXHRcdG51bU1lcmdlcyA9IDA7XG5cblx0XHR3aGlsZSAoIHAgKSB7XG5cblx0XHRcdG51bU1lcmdlcyArKztcblx0XHRcdHEgPSBwO1xuXHRcdFx0cFNpemUgPSAwO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpblNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0cFNpemUgKys7XG5cdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRpZiAoICEgcSApIGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHFTaXplID0gaW5TaXplO1xuXG5cdFx0XHR3aGlsZSAoIHBTaXplID4gMCB8fCAoIHFTaXplID4gMCAmJiBxICkgKSB7XG5cblx0XHRcdFx0aWYgKCBwU2l6ZSAhPT0gMCAmJiAoIHFTaXplID09PSAwIHx8ICEgcSB8fCBwLnogPD0gcS56ICkgKSB7XG5cblx0XHRcdFx0XHRlID0gcDtcblx0XHRcdFx0XHRwID0gcC5uZXh0Wjtcblx0XHRcdFx0XHRwU2l6ZSAtLTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZSA9IHE7XG5cdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0cVNpemUgLS07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xuXHRcdFx0XHRlbHNlIGxpc3QgPSBlO1xuXG5cdFx0XHRcdGUucHJldlogPSB0YWlsO1xuXHRcdFx0XHR0YWlsID0gZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcTtcblxuXHRcdH1cblxuXHRcdHRhaWwubmV4dFogPSBudWxsO1xuXHRcdGluU2l6ZSAqPSAyO1xuXG5cdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XG5cblx0cmV0dXJuIGxpc3Q7XG5cbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoIHgsIHksIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuXHR4ID0gKCB4IC0gbWluWCApICogaW52U2l6ZSB8IDA7XG5cdHkgPSAoIHkgLSBtaW5ZICkgKiBpbnZTaXplIHwgMDtcblxuXHR4ID0gKCB4IHwgKCB4IDw8IDggKSApICYgMHgwMEZGMDBGRjtcblx0eCA9ICggeCB8ICggeCA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XG5cdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xuXHR4ID0gKCB4IHwgKCB4IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcblxuXHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcblx0eSA9ICggeSB8ICggeSA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XG5cdHkgPSAoIHkgfCAoIHkgPDwgMiApICkgJiAweDMzMzMzMzMzO1xuXHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcblxuXHRyZXR1cm4geCB8ICggeSA8PCAxICk7XG5cbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3QoIHN0YXJ0ICkge1xuXG5cdGxldCBwID0gc3RhcnQsXG5cdFx0bGVmdG1vc3QgPSBzdGFydDtcblx0ZG8ge1xuXG5cdFx0aWYgKCBwLnggPCBsZWZ0bW9zdC54IHx8ICggcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkgKSApIGxlZnRtb3N0ID0gcDtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xuXG5cdHJldHVybiBsZWZ0bW9zdDtcblxufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSApIHtcblxuXHRyZXR1cm4gKCBjeCAtIHB4ICkgKiAoIGF5IC0gcHkgKSA+PSAoIGF4IC0gcHggKSAqICggY3kgLSBweSApICYmXG4gICAgICAgICAgICggYXggLSBweCApICogKCBieSAtIHB5ICkgPj0gKCBieCAtIHB4ICkgKiAoIGF5IC0gcHkgKSAmJlxuICAgICAgICAgICAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApID49ICggY3ggLSBweCApICogKCBieSAtIHB5ICk7XG5cbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKCBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICYmIG1pZGRsZUluc2lkZSggYSwgYiApICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKCBhcmVhKCBhLnByZXYsIGEsIGIucHJldiApIHx8IGFyZWEoIGEsIGIucHJldiwgYiApICkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoIGEsIGIgKSAmJiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApID4gMCAmJiBhcmVhKCBiLnByZXYsIGIsIGIubmV4dCApID4gMCApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2VcblxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKCBwLCBxLCByICkge1xuXG5cdHJldHVybiAoIHEueSAtIHAueSApICogKCByLnggLSBxLnggKSAtICggcS54IC0gcC54ICkgKiAoIHIueSAtIHEueSApO1xuXG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcblxuXHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xuXG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMoIHAxLCBxMSwgcDIsIHEyICkge1xuXG5cdGNvbnN0IG8xID0gc2lnbiggYXJlYSggcDEsIHExLCBwMiApICk7XG5cdGNvbnN0IG8yID0gc2lnbiggYXJlYSggcDEsIHExLCBxMiApICk7XG5cdGNvbnN0IG8zID0gc2lnbiggYXJlYSggcDIsIHEyLCBwMSApICk7XG5cdGNvbnN0IG80ID0gc2lnbiggYXJlYSggcDIsIHEyLCBxMSApICk7XG5cblx0aWYgKCBvMSAhPT0gbzIgJiYgbzMgIT09IG80ICkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG5cdGlmICggbzEgPT09IDAgJiYgb25TZWdtZW50KCBwMSwgcDIsIHExICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcblx0aWYgKCBvMiA9PT0gMCAmJiBvblNlZ21lbnQoIHAxLCBxMiwgcTEgKSApIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuXHRpZiAoIG8zID09PSAwICYmIG9uU2VnbWVudCggcDIsIHAxLCBxMiApICkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG5cdGlmICggbzQgPT09IDAgJiYgb25TZWdtZW50KCBwMiwgcTEsIHEyICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudCggcCwgcSwgciApIHtcblxuXHRyZXR1cm4gcS54IDw9IE1hdGgubWF4KCBwLngsIHIueCApICYmIHEueCA+PSBNYXRoLm1pbiggcC54LCByLnggKSAmJiBxLnkgPD0gTWF0aC5tYXgoIHAueSwgci55ICkgJiYgcS55ID49IE1hdGgubWluKCBwLnksIHIueSApO1xuXG59XG5cbmZ1bmN0aW9uIHNpZ24oIG51bSApIHtcblxuXHRyZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLSAxIDogMDtcblxufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSB7XG5cblx0bGV0IHAgPSBhO1xuXHRkbyB7XG5cblx0XHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuXHRcdFx0aW50ZXJzZWN0cyggcCwgcC5uZXh0LCBhLCBiICkgKSByZXR1cm4gdHJ1ZTtcblx0XHRwID0gcC5uZXh0O1xuXG5cdH0gd2hpbGUgKCBwICE9PSBhICk7XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZSggYSwgYiApIHtcblxuXHRyZXR1cm4gYXJlYSggYS5wcmV2LCBhLCBhLm5leHQgKSA8IDAgP1xuXHRcdGFyZWEoIGEsIGIsIGEubmV4dCApID49IDAgJiYgYXJlYSggYSwgYS5wcmV2LCBiICkgPj0gMCA6XG5cdFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcblxufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZSggYSwgYiApIHtcblxuXHRsZXQgcCA9IGEsXG5cdFx0aW5zaWRlID0gZmFsc2U7XG5cdGNvbnN0IHB4ID0gKCBhLnggKyBiLnggKSAvIDIsXG5cdFx0cHkgPSAoIGEueSArIGIueSApIC8gMjtcblx0ZG8ge1xuXG5cdFx0aWYgKCAoICggcC55ID4gcHkgKSAhPT0gKCBwLm5leHQueSA+IHB5ICkgKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG5cdFx0XHQoIHB4IDwgKCBwLm5leHQueCAtIHAueCApICogKCBweSAtIHAueSApIC8gKCBwLm5leHQueSAtIHAueSApICsgcC54ICkgKVxuXHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xuXG5cdHJldHVybiBpbnNpZGU7XG5cbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oIGEsIGIgKSB7XG5cblx0Y29uc3QgYTIgPSBuZXcgTm9kZSggYS5pLCBhLngsIGEueSApLFxuXHRcdGIyID0gbmV3IE5vZGUoIGIuaSwgYi54LCBiLnkgKSxcblx0XHRhbiA9IGEubmV4dCxcblx0XHRicCA9IGIucHJldjtcblxuXHRhLm5leHQgPSBiO1xuXHRiLnByZXYgPSBhO1xuXG5cdGEyLm5leHQgPSBhbjtcblx0YW4ucHJldiA9IGEyO1xuXG5cdGIyLm5leHQgPSBhMjtcblx0YTIucHJldiA9IGIyO1xuXG5cdGJwLm5leHQgPSBiMjtcblx0YjIucHJldiA9IGJwO1xuXG5cdHJldHVybiBiMjtcblxufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZSggaSwgeCwgeSwgbGFzdCApIHtcblxuXHRjb25zdCBwID0gbmV3IE5vZGUoIGksIHgsIHkgKTtcblxuXHRpZiAoICEgbGFzdCApIHtcblxuXHRcdHAucHJldiA9IHA7XG5cdFx0cC5uZXh0ID0gcDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xuXHRcdHAucHJldiA9IGxhc3Q7XG5cdFx0bGFzdC5uZXh0LnByZXYgPSBwO1xuXHRcdGxhc3QubmV4dCA9IHA7XG5cblx0fVxuXG5cdHJldHVybiBwO1xuXG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUoIHAgKSB7XG5cblx0cC5uZXh0LnByZXYgPSBwLnByZXY7XG5cdHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG5cdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuXHRpZiAoIHAubmV4dFogKSBwLm5leHRaLnByZXZaID0gcC5wcmV2WjtcblxufVxuXG5mdW5jdGlvbiBOb2RlKCBpLCB4LCB5ICkge1xuXG5cdC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuXHR0aGlzLmkgPSBpO1xuXG5cdC8vIHZlcnRleCBjb29yZGluYXRlc1xuXHR0aGlzLnggPSB4O1xuXHR0aGlzLnkgPSB5O1xuXG5cdC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuXHR0aGlzLnByZXYgPSBudWxsO1xuXHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdC8vIHotb3JkZXIgY3VydmUgdmFsdWVcblx0dGhpcy56ID0gMDtcblxuXHQvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG5cdHRoaXMucHJldlogPSBudWxsO1xuXHR0aGlzLm5leHRaID0gbnVsbDtcblxuXHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuXHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcblxufVxuXG5mdW5jdGlvbiBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSB7XG5cblx0bGV0IHN1bSA9IDA7XG5cdGZvciAoIGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltICkge1xuXG5cdFx0c3VtICs9ICggZGF0YVsgaiBdIC0gZGF0YVsgaSBdICkgKiAoIGRhdGFbIGkgKyAxIF0gKyBkYXRhWyBqICsgMSBdICk7XG5cdFx0aiA9IGk7XG5cblx0fVxuXG5cdHJldHVybiBzdW07XG5cbn1cblxuZXhwb3J0IHsgRWFyY3V0IH07XG4iLCJpbXBvcnQgeyBFYXJjdXQgfSBmcm9tICcuL0VhcmN1dC5qcyc7XG5cbmNsYXNzIFNoYXBlVXRpbHMge1xuXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblxuXHRzdGF0aWMgYXJlYSggY29udG91ciApIHtcblxuXHRcdGNvbnN0IG4gPSBjb250b3VyLmxlbmd0aDtcblx0XHRsZXQgYSA9IDAuMDtcblxuXHRcdGZvciAoIGxldCBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYSAqIDAuNTtcblxuXHR9XG5cblx0c3RhdGljIGlzQ2xvY2tXaXNlKCBwdHMgKSB7XG5cblx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XG5cblx0fVxuXG5cdHN0YXRpYyB0cmlhbmd1bGF0ZVNoYXBlKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107IC8vIGZsYXQgYXJyYXkgb2YgdmVydGljZXMgbGlrZSBbIHgwLHkwLCB4MSx5MSwgeDIseTIsIC4uLiBdXG5cdFx0Y29uc3QgaG9sZUluZGljZXMgPSBbXTsgLy8gYXJyYXkgb2YgaG9sZSBpbmRpY2VzXG5cdFx0Y29uc3QgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cblxuXHRcdHJlbW92ZUR1cEVuZFB0cyggY29udG91ciApO1xuXHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICk7XG5cblx0XHQvL1xuXG5cdFx0bGV0IGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGhvbGVJbmRpY2VzLnB1c2goIGhvbGVJbmRleCApO1xuXHRcdFx0aG9sZUluZGV4ICs9IGhvbGVzWyBpIF0ubGVuZ3RoO1xuXHRcdFx0YWRkQ29udG91ciggdmVydGljZXMsIGhvbGVzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCB0cmlhbmdsZXMgPSBFYXJjdXQudHJpYW5ndWxhdGUoIHZlcnRpY2VzLCBob2xlSW5kaWNlcyApO1xuXG5cdFx0Ly9cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0ZmFjZXMucHVzaCggdHJpYW5nbGVzLnNsaWNlKCBpLCBpICsgMyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFjZXM7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cEVuZFB0cyggcG9pbnRzICkge1xuXG5cdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xuXG5cdGlmICggbCA+IDIgJiYgcG9pbnRzWyBsIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcblxuXHRcdHBvaW50cy5wb3AoKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gYWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueCApO1xuXHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS55ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNoYXBlVXRpbHMgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi8uLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XG5cbi8qKlxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3QuXG4gKlxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0IClcbiAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKlxuICogLS0gM0QgY3VydmVzIC0tXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cbiAqXG4gKiovXG5cbmNsYXNzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblxuXHR9XG5cblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG5cdC8vXHQtIHQgWzAgLi4gMV1cblxuXHRnZXRQb2ludCggLyogdCwgb3B0aW9uYWxUYXJnZXQgKi8gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG5cdC8vIC0gdSBbMCAuLiAxXVxuXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblx0Z2V0UG9pbnRzKCBkaXZpc2lvbnMgPSA1ICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cblx0fVxuXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblx0Z2V0TGVuZ3RocyggZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgKSB7XG5cblx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXG5cdFx0XHQoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PT0gZGl2aXNpb25zICsgMSApICYmXG5cdFx0XHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGNvbnN0IGNhY2hlID0gW107XG5cdFx0bGV0IGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRmb3IgKCBsZXQgcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xuXHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XG5cdFx0XHRsYXN0ID0gY3VycmVudDtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdH1cblxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXHRnZXRVdG9UbWFwcGluZyggdSwgZGlzdGFuY2UgKSB7XG5cblx0XHRjb25zdCBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuXHRcdGxldCB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0XHR9XG5cblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG5cdFx0bGV0IGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG5cdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuXHRcdFx0XHRsb3cgPSBpICsgMTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBET05FXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGkgPSBoaWdoO1xuXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGkgLyAoIGlsIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdGNvbnN0IGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcblx0XHRjb25zdCBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cblx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cblx0XHRjb25zdCB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xuXG5cdFx0cmV0dXJuIHQ7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblx0Z2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zdCBkZWx0YSA9IDAuMDAwMTtcblx0XHRsZXQgdDEgPSB0IC0gZGVsdGE7XG5cdFx0bGV0IHQyID0gdCArIGRlbHRhO1xuXG5cdFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG5cdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHRjb25zdCBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHRcdGNvbnN0IHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgKCAoIHB0MS5pc1ZlY3RvcjIgKSA/IG5ldyBWZWN0b3IyKCkgOiBuZXcgVmVjdG9yMygpICk7XG5cblx0XHR0YW5nZW50LmNvcHkoIHB0MiApLnN1YiggcHQxICkubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGFuZ2VudDtcblxuXHR9XG5cblx0Z2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29tcHV0ZUZyZW5ldEZyYW1lcyggc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCB0YW5nZW50cyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCBiaW5vcm1hbHMgPSBbXTtcblxuXHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXG5cdFx0XHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUsIG5ldyBWZWN0b3IzKCkgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRjb25zdCB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHRjb25zdCB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHRjb25zdCB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eDtcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gbWluICkge1xuXG5cdFx0XHRtaW4gPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gbWluICkge1xuXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHR9XG5cblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cblx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cblx0XHRpZiAoIGNsb3NlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bGV0IHRoZXRhID0gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIHNlZ21lbnRzIF0gKSwgLSAxLCAxICkgKTtcblx0XHRcdHRoZXRhIC89IHNlZ21lbnRzO1xuXG5cdFx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIHNlZ21lbnRzIF0gKSApID4gMCApIHtcblxuXHRcdFx0XHR0aGV0YSA9IC0gdGhldGE7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xuXHRcdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGFuZ2VudHM6IHRhbmdlbnRzLFxuXHRcdFx0bm9ybWFsczogbm9ybWFscyxcblx0XHRcdGJpbm9ybWFsczogYmlub3JtYWxzXG5cdFx0fTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gc291cmNlLmFyY0xlbmd0aERpdmlzaW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnQ3VydmUnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdDdXJ2ZS50b0pTT04nXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGRhdGEuYXJjTGVuZ3RoRGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBqc29uLmFyY0xlbmd0aERpdmlzaW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEN1cnZlIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4vQ3VydmUuanMnO1xuaW1wb3J0ICogYXMgQ3VydmVzIGZyb20gJy4uL2N1cnZlcy9DdXJ2ZXMuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jbGFzcyBDdXJ2ZVBhdGggZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cblx0fVxuXG5cdGFkZCggY3VydmUgKSB7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdH1cblxuXHRjbG9zZVBhdGgoKSB7XG5cblx0XHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcblx0XHRjb25zdCBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xuXHRcdGNvbnN0IGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyAnTGluZUN1cnZlJyBdKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuXHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG5cdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuXHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG5cdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdGxldCBpID0gMDtcblxuXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGNvbnN0IHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblxuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblxuXHR9XG5cblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcblx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5cdGdldExlbmd0aCgpIHtcblxuXHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxuXHR9XG5cblx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cblx0fVxuXG5cdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5cdGdldEN1cnZlTGVuZ3RocygpIHtcblxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHRjb25zdCBsZW5ndGhzID0gW107XG5cdFx0bGV0IHN1bXMgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cblx0XHRyZXR1cm4gbGVuZ3RocztcblxuXHR9XG5cblx0Z2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgPSA0MCApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDEyICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gW107XG5cdFx0bGV0IGxhc3Q7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcblx0XHRcdGNvbnN0IHJlc29sdXRpb24gPSBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSA/IGRpdmlzaW9ucyAqIDJcblx0XHRcdFx0OiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApID8gMVxuXHRcdFx0XHRcdDogY3VydmUuaXNTcGxpbmVDdXJ2ZSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcblx0XHRcdFx0XHRcdDogZGl2aXNpb25zO1xuXG5cdFx0XHRjb25zdCBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IHB0c1sgaiBdO1xuXG5cdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xuXHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSBzb3VyY2UuY3VydmVzWyBpIF07XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0gc291cmNlLmF1dG9DbG9zZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdGRhdGEuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0ganNvbi5jdXJ2ZXNbIGkgXTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBDdXJ2ZVBhdGggfTtcbiIsIi8qKlxuICogQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuICovXG5cbmZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdGNvbnN0IHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XG5cdGNvbnN0IHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cdGNvbnN0IHQyID0gdCAqIHQ7XG5cdGNvbnN0IHQzID0gdCAqIHQyO1xuXHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxufVxuXG4vL1xuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcCApIHtcblxuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiBrICogayAqIHA7XG5cbn1cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAgKSB7XG5cblx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMiggdCwgcCApIHtcblxuXHRyZXR1cm4gdCAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllciggdCwgcDAsIHAxLCBwMiApIHtcblxuXHRyZXR1cm4gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAwICkgKyBRdWFkcmF0aWNCZXppZXJQMSggdCwgcDEgKSArXG5cdFx0UXVhZHJhdGljQmV6aWVyUDIoIHQsIHAyICk7XG5cbn1cblxuLy9cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMCggdCwgcCApIHtcblxuXHRjb25zdCBrID0gMSAtIHQ7XG5cdHJldHVybiBrICogayAqIGsgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDEoIHQsIHAgKSB7XG5cblx0Y29uc3QgayA9IDEgLSB0O1xuXHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMiggdCwgcCApIHtcblxuXHRyZXR1cm4gMyAqICggMSAtIHQgKSAqIHQgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAzKCB0LCBwICkge1xuXG5cdHJldHVybiB0ICogdCAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRyZXR1cm4gQ3ViaWNCZXppZXJQMCggdCwgcDAgKSArIEN1YmljQmV6aWVyUDEoIHQsIHAxICkgKyBDdWJpY0JlemllclAyKCB0LCBwMiApICtcblx0XHRDdWJpY0JlemllclAzKCB0LCBwMyApO1xuXG59XG5cbmV4cG9ydCB7IENhdG11bGxSb20sIFF1YWRyYXRpY0JlemllciwgQ3ViaWNCZXppZXIgfTtcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgQ3VydmVQYXRoIH0gZnJvbSAnLi9DdXJ2ZVBhdGguanMnO1xuaW1wb3J0IHsgRWxsaXBzZUN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0VsbGlwc2VDdXJ2ZS5qcyc7XG5pbXBvcnQgeyBTcGxpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qcyc7XG5pbXBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanMnO1xuaW1wb3J0IHsgTGluZUN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0xpbmVDdXJ2ZS5qcyc7XG5cbmNsYXNzIFBhdGggZXh0ZW5kcyBDdXJ2ZVBhdGgge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BhdGgnO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubW92ZVRvKCBwb2ludHNbIDAgXS54LCBwb2ludHNbIDAgXS55ICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5saW5lVG8oIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtb3ZlVG8oIHgsIHkgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsaW5lVG8oIHgsIHkgKSB7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUoIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cXVhZHJhdGljQ3VydmVUbyggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUoXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxuXHRcdCk7XG5cblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRiZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgQ3ViaWNCZXppZXJDdXJ2ZShcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYVgsIGFZIClcblx0XHQpO1xuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3BsaW5lVGhydSggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XG5cblx0XHRjb25zdCBucHRzID0gWyB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpIF0uY29uY2F0KCBwdHMgKTtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFyYyggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0Y29uc3QgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuXHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuXHRcdHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuXHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFic2FyYyggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlbGxpcHNlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRjb25zdCB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFic2VsbGlwc2UoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuXG5cdFx0aWYgKCB0aGlzLmN1cnZlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHQvLyBpZiBhIHByZXZpb3VzIGN1cnZlIGlzIHByZXNlbnQsIGF0dGVtcHQgdG8gam9pblxuXHRcdFx0Y29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAwICk7XG5cblx0XHRcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcblxuXHRcdFx0XHR0aGlzLmxpbmVUbyggZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdGNvbnN0IGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggbGFzdFBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBzb3VyY2UuY3VycmVudFBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuZnJvbUFycmF5KCBqc29uLmN1cnJlbnRQb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgUGF0aCB9O1xuIiwiaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4vUGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG5jbGFzcyBTaGFwZSBleHRlbmRzIFBhdGgge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgKSB7XG5cblx0XHRzdXBlciggcG9pbnRzICk7XG5cblx0XHR0aGlzLnV1aWQgPSBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xuXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdH1cblxuXHRnZXRQb2ludHNIb2xlcyggZGl2aXNpb25zICkge1xuXG5cdFx0Y29uc3QgaG9sZXNQdHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhvbGVzUHRzO1xuXG5cdH1cblxuXHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuXHRleHRyYWN0UG9pbnRzKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxuXHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0XHR9O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XG5cblx0XHRcdHRoaXMuaG9sZXMucHVzaCggaG9sZS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEuaG9sZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaG9sZSA9IHRoaXMuaG9sZXNbIGkgXTtcblx0XHRcdGRhdGEuaG9sZXMucHVzaCggaG9sZS50b0pTT04oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhvbGUgPSBqc29uLmhvbGVzWyBpIF07XG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIG5ldyBQYXRoKCkuZnJvbUpTT04oIGhvbGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgU2hhcGUgfTtcbiIsImltcG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4vRWxsaXBzZUN1cnZlLmpzJztcblxuY2xhc3MgQXJjQ3VydmUgZXh0ZW5kcyBFbGxpcHNlQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRzdXBlciggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHR0aGlzLmlzQXJjQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQXJjQ3VydmUgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcblxuLyoqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cblxuLypcbkJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cbiAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXG4gLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cblxuVGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxuYnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG53aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXG4qL1xuXG5mdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG5cblx0bGV0IGMwID0gMCwgYzEgPSAwLCBjMiA9IDAsIGMzID0gMDtcblxuXHQvKlxuXHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG5cdCAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xuXHQgKiBzdWNoIHRoYXRcblx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuXHQgKiAgYW5kXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cblx0ICovXG5cdGZ1bmN0aW9uIGluaXQoIHgwLCB4MSwgdDAsIHQxICkge1xuXG5cdFx0YzAgPSB4MDtcblx0XHRjMSA9IHQwO1xuXHRcdGMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcblx0XHRjMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRpbml0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCB4MCwgeDEsIHgyLCB4MywgdGVuc2lvbiApIHtcblxuXHRcdFx0aW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG5cdFx0fSxcblxuXHRcdGluaXROb251bmlmb3JtQ2F0bXVsbFJvbTogZnVuY3Rpb24gKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcblxuXHRcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuXHRcdFx0bGV0IHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcblx0XHRcdGxldCB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XG5cblx0XHRcdC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuXHRcdFx0dDEgKj0gZHQxO1xuXHRcdFx0dDIgKj0gZHQxO1xuXG5cdFx0XHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xuXG5cdFx0fSxcblxuXHRcdGNhbGM6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0Y29uc3QgdDIgPSB0ICogdDtcblx0XHRcdGNvbnN0IHQzID0gdDIgKiB0O1xuXHRcdFx0cmV0dXJuIGMwICsgYzEgKiB0ICsgYzIgKiB0MiArIGMzICogdDM7XG5cblx0XHR9XG5cblx0fTtcblxufVxuXG4vL1xuXG5jb25zdCB0bXAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBweCA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmljUG9seSgpO1xuY29uc3QgcHkgPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJpY1BvbHkoKTtcbmNvbnN0IHB6ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XG5cbmNsYXNzIENhdG11bGxSb21DdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHBvaW50cyA9IFtdLCBjbG9zZWQgPSBmYWxzZSwgY3VydmVUeXBlID0gJ2NlbnRyaXBldGFsJywgdGVuc2lvbiA9IDAuNSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzQ2F0bXVsbFJvbUN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2F0bXVsbFJvbUN1cnZlMyc7XG5cblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcblx0XHR0aGlzLmNsb3NlZCA9IGNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IGN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSB0ZW5zaW9uO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0Y29uc3QgcCA9ICggbCAtICggdGhpcy5jbG9zZWQgPyAwIDogMSApICkgKiB0O1xuXHRcdGxldCBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcblx0XHRsZXQgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcblxuXHRcdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBsICkgKyAxICkgKiBsO1xuXG5cdFx0fSBlbHNlIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcblxuXHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcblx0XHRcdHdlaWdodCA9IDE7XG5cblx0XHR9XG5cblx0XHRsZXQgcDAsIHAzOyAvLyA0IHBvaW50cyAocDEgJiBwMiBkZWZpbmVkIGJlbG93KVxuXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XG5cblx0XHRcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcblx0XHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XG5cdFx0XHRwMCA9IHRtcDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHAxID0gcG9pbnRzWyBpbnRQb2ludCAlIGwgXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcblxuXHRcdFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDEgXSApO1xuXHRcdFx0cDMgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgKSB7XG5cblx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG5cdFx0XHRjb25zdCBwb3cgPSB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcblx0XHRcdGxldCBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xuXHRcdFx0bGV0IGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XG5cdFx0XHRsZXQgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcblxuXHRcdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcblx0XHRcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcblx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcblx0XHRcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcblxuXHRcdFx0cHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcblx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuXHRcdFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRoaXMudGVuc2lvbiApO1xuXHRcdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRoaXMudGVuc2lvbiApO1xuXHRcdFx0cHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRoaXMudGVuc2lvbiApO1xuXG5cdFx0fVxuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRweS5jYWxjKCB3ZWlnaHQgKSxcblx0XHRcdHB6LmNhbGMoIHdlaWdodCApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcblxuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZWQgPSBzb3VyY2UuY2xvc2VkO1xuXHRcdHRoaXMuY3VydmVUeXBlID0gc291cmNlLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBzb3VyY2UudGVuc2lvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRkYXRhLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXHRcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XG5cdFx0ZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9pbnQgKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZWQgPSBqc29uLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IGpzb24uY3VydmVUeXBlO1xuXHRcdHRoaXMudGVuc2lvbiA9IGpzb24udGVuc2lvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDYXRtdWxsUm9tQ3VydmUzIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBDdWJpY0JlemllckN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2MCA9IG5ldyBWZWN0b3IyKCksIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpLCB2MyA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRcdHBvaW50LnNldChcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblx0XHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblx0XHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBDdWJpY0JlemllciB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIEN1YmljQmV6aWVyQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2MCA9IG5ldyBWZWN0b3IzKCksIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpLCB2MyA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XG5cblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2Mjtcblx0XHR0aGlzLnYzID0gdjM7XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55LCB2My55ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueiwgdjEueiwgdjIueiwgdjMueiApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblx0XHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblx0XHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUzIH07XG4iLCJleHBvcnQgeyBBcmNDdXJ2ZSB9IGZyb20gJy4vQXJjQ3VydmUuanMnO1xuZXhwb3J0IHsgQ2F0bXVsbFJvbUN1cnZlMyB9IGZyb20gJy4vQ2F0bXVsbFJvbUN1cnZlMy5qcyc7XG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi9DdWJpY0JlemllckN1cnZlLmpzJztcbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUzIH0gZnJvbSAnLi9DdWJpY0JlemllckN1cnZlMy5qcyc7XG5leHBvcnQgeyBFbGxpcHNlQ3VydmUgfSBmcm9tICcuL0VsbGlwc2VDdXJ2ZS5qcyc7XG5leHBvcnQgeyBMaW5lQ3VydmUgfSBmcm9tICcuL0xpbmVDdXJ2ZS5qcyc7XG5leHBvcnQgeyBMaW5lQ3VydmUzIH0gZnJvbSAnLi9MaW5lQ3VydmUzLmpzJztcbmV4cG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlIH0gZnJvbSAnLi9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qcyc7XG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgfSBmcm9tICcuL1F1YWRyYXRpY0JlemllckN1cnZlMy5qcyc7XG5leHBvcnQgeyBTcGxpbmVDdXJ2ZSB9IGZyb20gJy4vU3BsaW5lQ3VydmUuanMnO1xuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBFbGxpcHNlQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFYID0gMCwgYVkgPSAwLCB4UmFkaXVzID0gMSwgeVJhZGl1cyA9IDEsIGFTdGFydEFuZ2xlID0gMCwgYUVuZEFuZ2xlID0gTWF0aC5QSSAqIDIsIGFDbG9ja3dpc2UgPSBmYWxzZSwgYVJvdGF0aW9uID0gMCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdFbGxpcHNlQ3VydmUnO1xuXG5cdFx0dGhpcy5hWCA9IGFYO1xuXHRcdHRoaXMuYVkgPSBhWTtcblxuXHRcdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cblx0XHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0XHRsZXQgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRjb25zdCBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xuXG5cdFx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG5cdFx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdGlmICggc2FtZVBvaW50cyApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cyApIHtcblxuXHRcdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblx0XHRsZXQgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRsZXQgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cblx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XG5cdFx0XHRjb25zdCB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcblxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEuYVggPSB0aGlzLmFYO1xuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXG5cdFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcblxuXHRcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XG5cblx0XHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XG5cblx0XHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuYVggPSBqc29uLmFYO1xuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XG5cblx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEVsbGlwc2VDdXJ2ZSB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuXG5jbGFzcyBMaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XG5cblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaW5lQ3VydmUgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcblxuY2xhc3MgTGluZUN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0xpbmVDdXJ2ZTMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZTMnO1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9XG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0aWYgKCB0ID09PSAxICkge1xuXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICkuc3ViKCB0aGlzLnYxICk7XG5cdFx0XHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHJldHVybiBvcHRpb25hbFRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IExpbmVDdXJ2ZTMgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXG5cdFx0KTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9O1xuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcbmltcG9ydCB7IFF1YWRyYXRpY0JlemllciB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIFF1YWRyYXRpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcblxuXHRcdHBvaW50LnNldChcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55ICksXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUzIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgQ2F0bXVsbFJvbSB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbmNsYXNzIFNwbGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblxuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGNvbnN0IHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0Y29uc3Qgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0Y29uc3QgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0Y29uc3QgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BsaW5lQ3VydmUgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIEJveEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSwgd2lkdGhTZWdtZW50cyA9IDEsIGhlaWdodFNlZ21lbnRzID0gMSwgZGVwdGhTZWdtZW50cyA9IDEgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0ZGVwdGg6IGRlcHRoLFxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Ly8gc2VnbWVudHNcblxuXHRcdHdpZHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICk7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApO1xuXHRcdGRlcHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCBkZXB0aFNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgbnVtYmVyT2ZWZXJ0aWNlcyA9IDA7XG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXG5cdFx0Ly8gYnVpbGQgZWFjaCBzaWRlIG9mIHRoZSBib3ggZ2VvbWV0cnlcblxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDAgKTsgLy8gcHhcblx0XHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAxICk7IC8vIG54XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDIgKTsgLy8gcHlcblx0XHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMgKTsgLy8gbnlcblx0XHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNCApOyAvLyBwelxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSApOyAvLyBuelxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHRjb25zdCBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdFx0Y29uc3Qgc2VnbWVudEhlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xuXG5cdFx0XHRjb25zdCB3aWR0aEhhbGYgPSB3aWR0aCAvIDI7XG5cdFx0XHRjb25zdCBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdGNvbnN0IGRlcHRoSGFsZiA9IGRlcHRoIC8gMjtcblxuXHRcdFx0Y29uc3QgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHRcdFx0Y29uc3QgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdFx0XHRsZXQgdmVydGV4Q291bnRlciA9IDA7XG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHkgPSBpeSAqIHNlZ21lbnRIZWlnaHQgLSBoZWlnaHRIYWxmO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHggPSBpeCAqIHNlZ21lbnRXaWR0aCAtIHdpZHRoSGFsZjtcblxuXHRcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG5cblx0XHRcdFx0XHR2ZWN0b3JbIHUgXSA9IHggKiB1ZGlyO1xuXHRcdFx0XHRcdHZlY3RvclsgdiBdID0geSAqIHZkaXI7XG5cdFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aEhhbGY7XG5cblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcblxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcblxuXHRcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG5cblx0XHRcdFx0XHR2ZWN0b3JbIHUgXSA9IDA7XG5cdFx0XHRcdFx0dmVjdG9yWyB2IF0gPSAwO1xuXHRcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcblxuXHRcdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gbm9ybWFsIGJ1ZmZlclxuXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHQvLyB1dnNcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XG5cdFx0XHRcdFx0dXZzLnB1c2goIDEgLSAoIGl5IC8gZ3JpZFkgKSApO1xuXG5cdFx0XHRcdFx0Ly8gY291bnRlcnNcblxuXHRcdFx0XHRcdHZlcnRleENvdW50ZXIgKz0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHQvLyAxLiB5b3UgbmVlZCB0aHJlZSBpbmRpY2VzIHRvIGRyYXcgYSBzaW5nbGUgZmFjZVxuXHRcdFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcblx0XHRcdC8vIDMuIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgc2l4ICgyKjMpIGluZGljZXMgcGVyIHNlZ21lbnRcblxuXHRcdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHRcdC8vIGluY3JlYXNlIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBCb3hHZW9tZXRyeSggZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQsIGRhdGEuZGVwdGgsIGRhdGEud2lkdGhTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5kZXB0aFNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJveEdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vZXh0cmFzL2NvcmUvUGF0aC5qcyc7XG5pbXBvcnQgeyBMYXRoZUdlb21ldHJ5IH0gZnJvbSAnLi9MYXRoZUdlb21ldHJ5LmpzJztcblxuY2xhc3MgQ2Fwc3VsZUdlb21ldHJ5IGV4dGVuZHMgTGF0aGVHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGxlbmd0aCA9IDEsIGNhcFNlZ21lbnRzID0gNCwgcmFkaWFsU2VnbWVudHMgPSA4ICkge1xuXG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIC0gbGVuZ3RoIC8gMiwgcmFkaXVzLCBNYXRoLlBJICogMS41LCAwICk7XG5cdFx0cGF0aC5hYnNhcmMoIDAsIGxlbmd0aCAvIDIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDAuNSApO1xuXG5cdFx0c3VwZXIoIHBhdGguZ2V0UG9pbnRzKCBjYXBTZWdtZW50cyApLCByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhcHN1bGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGxlbmd0aDogbGVuZ3RoLFxuXHRcdFx0Y2FwU2VnbWVudHM6IGNhcFNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ2Fwc3VsZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5sZW5ndGgsIGRhdGEuY2FwU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ2Fwc3VsZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbmNsYXNzIENpcmNsZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBzZWdtZW50cyA9IDMyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGNlbnRlciBwb2ludFxuXG5cdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXHRcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xuXG5cdFx0Zm9yICggbGV0IHMgPSAwLCBpID0gMzsgcyA8PSBzZWdtZW50czsgcyArKywgaSArPSAzICkge1xuXG5cdFx0XHRjb25zdCBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG5cdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0Ly8gdXZzXG5cblx0XHRcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXHRcdFx0dXYueSA9ICggdmVydGljZXNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IENpcmNsZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5zZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQ2lyY2xlR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEN5bGluZGVyR2VvbWV0cnkgfSBmcm9tICcuL0N5bGluZGVyR2VvbWV0cnkuanMnO1xuXG5jbGFzcyBDb25lR2VvbWV0cnkgZXh0ZW5kcyBDeWxpbmRlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlciggMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDb25lR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDb25lR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY2xhc3MgQ3lsaW5kZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzVG9wID0gMSwgcmFkaXVzQm90dG9tID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcblx0XHRjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG5cdFx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xuXHRcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXG5cdFx0XHRjb25zdCBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4Um93ID0gW107XG5cblx0XHRcdFx0Y29uc3QgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0XHRjb25zdCByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblx0XHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFsLnNldCggc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xuXG5cdFx0XHRcdFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcblxuXHRcdFx0XHRcdGluZGV4Um93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG5cblx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG5cblx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggXTtcblx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCArIDEgXTtcblx0XHRcdFx0XHRjb25zdCBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGdyb3VwIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XG5cblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XG5cblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gKCB0b3AgPT09IHRydWUgKSA/IHJhZGl1c1RvcCA6IHJhZGl1c0JvdHRvbTtcblx0XHRcdGNvbnN0IHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcblxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XG5cblx0XHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xuXG5cdFx0XHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XG5cdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSAoIGNvc1RoZXRhICogMC41ICkgKyAwLjU7XG5cdFx0XHRcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XG5cdFx0XHRcdGNvbnN0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XG5cblx0XHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIHRvcFxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgYyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBmYWNlIGJvdHRvbVxuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICsgMSwgaSwgYyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIHRvcCA9PT0gdHJ1ZSA/IDEgOiAyICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KCBkYXRhLnJhZGl1c1RvcCwgZGF0YS5yYWRpdXNCb3R0b20sIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQ3lsaW5kZXJHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xuXG5jbGFzcyBEb2RlY2FoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cdFx0Y29uc3QgciA9IDEgLyB0O1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cblx0XHRcdC8vICjCsTEsIMKxMSwgwrExKVxuXHRcdFx0LSAxLCAtIDEsIC0gMSxcdC0gMSwgLSAxLCAxLFxuXHRcdFx0LSAxLCAxLCAtIDEsIC0gMSwgMSwgMSxcblx0XHRcdDEsIC0gMSwgLSAxLCAxLCAtIDEsIDEsXG5cdFx0XHQxLCAxLCAtIDEsIDEsIDEsIDEsXG5cblx0XHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0XHQwLCAtIHIsIC0gdCwgMCwgLSByLCB0LFxuXHRcdFx0MCwgciwgLSB0LCAwLCByLCB0LFxuXG5cdFx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxuXHRcdFx0LSByLCAtIHQsIDAsIC0gciwgdCwgMCxcblx0XHRcdHIsIC0gdCwgMCwgciwgdCwgMCxcblxuXHRcdFx0Ly8gKMKxz4YsIDAsIMKxMS/Philcblx0XHRcdC0gdCwgMCwgLSByLCB0LCAwLCAtIHIsXG5cdFx0XHQtIHQsIDAsIHIsIHQsIDAsIHJcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDMsIDExLCA3LCBcdDMsIDcsIDE1LCBcdDMsIDE1LCAxMyxcblx0XHRcdDcsIDE5LCAxNywgXHQ3LCAxNywgNiwgXHQ3LCA2LCAxNSxcblx0XHRcdDE3LCA0LCA4LCBcdDE3LCA4LCAxMCwgXHQxNywgMTAsIDYsXG5cdFx0XHQ4LCAwLCAxNiwgXHQ4LCAxNiwgMiwgXHQ4LCAyLCAxMCxcblx0XHRcdDAsIDEyLCAxLCBcdDAsIDEsIDE4LCBcdDAsIDE4LCAxNixcblx0XHRcdDYsIDEwLCAyLCBcdDYsIDIsIDEzLCBcdDYsIDEzLCAxNSxcblx0XHRcdDIsIDE2LCAxOCwgXHQyLCAxOCwgMywgXHQyLCAzLCAxMyxcblx0XHRcdDE4LCAxLCA5LCBcdDE4LCA5LCAxMSwgXHQxOCwgMTEsIDMsXG5cdFx0XHQ0LCAxNCwgMTIsIFx0NCwgMTIsIDAsIFx0NCwgMCwgOCxcblx0XHRcdDExLCA5LCA1LCBcdDExLCA1LCAxOSwgXHQxMSwgMTksIDcsXG5cdFx0XHQxOSwgNSwgMTQsIFx0MTksIDE0LCA0LCBcdDE5LCA0LCAxNyxcblx0XHRcdDEsIDEyLCAxNCwgXHQxLCAxNCwgNSwgXHQxLCA1LCA5XG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBEb2RlY2FoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRG9kZWNhaGVkcm9uR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi4vbWF0aC9UcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFRyaWFuZ2xlKCk7XG5cbmNsYXNzIEVkZ2VzR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbnVsbCwgdGhyZXNob2xkQW5nbGUgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdFZGdlc0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcblx0XHRcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxuXHRcdH07XG5cblx0XHRpZiAoIGdlb21ldHJ5ICE9PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBwcmVjaXNpb25Qb2ludHMgPSA0O1xuXHRcdFx0Y29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblx0XHRcdGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBNYXRoVXRpbHMuREVHMlJBRCAqIHRocmVzaG9sZEFuZ2xlICk7XG5cblx0XHRcdGNvbnN0IGluZGV4QXR0ciA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRcdGNvbnN0IGluZGV4Q291bnQgPSBpbmRleEF0dHIgPyBpbmRleEF0dHIuY291bnQgOiBwb3NpdGlvbkF0dHIuY291bnQ7XG5cblx0XHRcdGNvbnN0IGluZGV4QXJyID0gWyAwLCAwLCAwIF07XG5cdFx0XHRjb25zdCB2ZXJ0S2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHRcdFx0Y29uc3QgaGFzaGVzID0gbmV3IEFycmF5KCAzICk7XG5cblx0XHRcdGNvbnN0IGVkZ2VEYXRhID0ge307XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGlmICggaW5kZXhBdHRyICkge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGluZGV4QXR0ci5nZXRYKCBpICk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGluZGV4QXR0ci5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpbmRleEF0dHIuZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDAgXSA9IGk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGkgKyAxO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAyIF0gPSBpICsgMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSBfdHJpYW5nbGU7XG5cdFx0XHRcdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMCBdICk7XG5cdFx0XHRcdGIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMSBdICk7XG5cdFx0XHRcdGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMiBdICk7XG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoIF9ub3JtYWwgKTtcblxuXHRcdFx0XHQvLyBjcmVhdGUgaGFzaGVzIGZvciB0aGUgZWRnZSBmcm9tIHRoZSB2ZXJ0aWNlc1xuXHRcdFx0XHRoYXNoZXNbIDAgXSA9IGAkeyBNYXRoLnJvdW5kKCBhLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYS56ICogcHJlY2lzaW9uICkgfWA7XG5cdFx0XHRcdGhhc2hlc1sgMSBdID0gYCR7IE1hdGgucm91bmQoIGIueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYi55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBiLnogKiBwcmVjaXNpb24gKSB9YDtcblx0XHRcdFx0aGFzaGVzWyAyIF0gPSBgJHsgTWF0aC5yb3VuZCggYy54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGMueiAqIHByZWNpc2lvbiApIH1gO1xuXG5cdFx0XHRcdC8vIHNraXAgZGVnZW5lcmF0ZSB0cmlhbmdsZXNcblx0XHRcdFx0aWYgKCBoYXNoZXNbIDAgXSA9PT0gaGFzaGVzWyAxIF0gfHwgaGFzaGVzWyAxIF0gPT09IGhhc2hlc1sgMiBdIHx8IGhhc2hlc1sgMiBdID09PSBoYXNoZXNbIDAgXSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgZXZlcnkgZWRnZVxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBmaXJzdCBhbmQgbmV4dCB2ZXJ0ZXggbWFraW5nIHVwIHRoZSBlZGdlXG5cdFx0XHRcdFx0Y29uc3Qgak5leHQgPSAoIGogKyAxICkgJSAzO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gwID0gaGFzaGVzWyBqIF07XG5cdFx0XHRcdFx0Y29uc3QgdmVjSGFzaDEgPSBoYXNoZXNbIGpOZXh0IF07XG5cdFx0XHRcdFx0Y29uc3QgdjAgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqIF0gXTtcblx0XHRcdFx0XHRjb25zdCB2MSA9IF90cmlhbmdsZVsgdmVydEtleXNbIGpOZXh0IF0gXTtcblxuXHRcdFx0XHRcdGNvbnN0IGhhc2ggPSBgJHsgdmVjSGFzaDAgfV8keyB2ZWNIYXNoMSB9YDtcblx0XHRcdFx0XHRjb25zdCByZXZlcnNlSGFzaCA9IGAkeyB2ZWNIYXNoMSB9XyR7IHZlY0hhc2gwIH1gO1xuXG5cdFx0XHRcdFx0aWYgKCByZXZlcnNlSGFzaCBpbiBlZGdlRGF0YSAmJiBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0XHRcdGlmICggX25vcm1hbC5kb3QoIGVkZ2VEYXRhWyByZXZlcnNlSGFzaCBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MC54LCB2MC55LCB2MC56ICk7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSA9IG51bGw7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhICggaGFzaCBpbiBlZGdlRGF0YSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBlZGdlIGhlcmUgdGhlbiBza2lwIGFkZGluZyBhIG5ldyBvbmVcblx0XHRcdFx0XHRcdGVkZ2VEYXRhWyBoYXNoIF0gPSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kZXgwOiBpbmRleEFyclsgaiBdLFxuXHRcdFx0XHRcdFx0XHRpbmRleDE6IGluZGV4QXJyWyBqTmV4dCBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWw6IF9ub3JtYWwuY2xvbmUoKSxcblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGVkZ2VEYXRhICkge1xuXG5cdFx0XHRcdGlmICggZWRnZURhdGFbIGtleSBdICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgeyBpbmRleDAsIGluZGV4MSB9ID0gZWRnZURhdGFbIGtleSBdO1xuXHRcdFx0XHRcdF92MC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MCApO1xuXHRcdFx0XHRcdF92MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MSApO1xuXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YwLngsIF92MC55LCBfdjAueiApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIF92MS54LCBfdjEueSwgX3YxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgRWRnZXNHZW9tZXRyeSB9O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gKiAgZGVwdGg6IDxmbG9hdD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIChpbmNsdWRpbmcgYmV2ZWxPZmZzZXQpIGlzIGJldmVsXG4gKiAgYmV2ZWxPZmZzZXQ6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGRvZXMgYmV2ZWwgc3RhcnRcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXG4gKlxuICogIFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICovXG5cbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0ICogYXMgQ3VydmVzIGZyb20gJy4uL2V4dHJhcy9jdXJ2ZXMvQ3VydmVzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL2V4dHJhcy9jb3JlL1NoYXBlLmpzJztcbmltcG9ydCB7IFNoYXBlVXRpbHMgfSBmcm9tICcuLi9leHRyYXMvU2hhcGVVdGlscy5qcyc7XG5cbmNsYXNzIEV4dHJ1ZGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3Rvciggc2hhcGVzID0gbmV3IFNoYXBlKCBbIG5ldyBWZWN0b3IyKCAwLjUsIDAuNSApLCBuZXcgVmVjdG9yMiggLSAwLjUsIDAuNSApLCBuZXcgVmVjdG9yMiggLSAwLjUsIC0gMC41ICksIG5ldyBWZWN0b3IyKCAwLjUsIC0gMC41ICkgXSApLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcblx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdFx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgdmVydGljZXNBcnJheSA9IFtdO1xuXHRcdGNvbnN0IHV2QXJyYXkgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXHRcdFx0YWRkU2hhcGUoIHNoYXBlICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlc0FycmF5LCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QXJyYXksIDIgKSApO1xuXG5cdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdFx0Ly8gZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XG5cblx0XHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gW107XG5cblx0XHRcdC8vIG9wdGlvbnNcblxuXHRcdFx0Y29uc3QgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cdFx0XHRjb25zdCBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXHRcdFx0Y29uc3QgZGVwdGggPSBvcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoIDogMTtcblxuXHRcdFx0bGV0IGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7XG5cdFx0XHRsZXQgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogMC4yO1xuXHRcdFx0bGV0IGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMC4xO1xuXHRcdFx0bGV0IGJldmVsT2Zmc2V0ID0gb3B0aW9ucy5iZXZlbE9mZnNldCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbE9mZnNldCA6IDA7XG5cdFx0XHRsZXQgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuXHRcdFx0Y29uc3QgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXG5cdFx0XHRjb25zdCB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBXb3JsZFVWR2VuZXJhdG9yO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRsZXQgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXHRcdFx0bGV0IHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcblxuXHRcdFx0aWYgKCBleHRydWRlUGF0aCApIHtcblxuXHRcdFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xuXG5cdFx0XHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cblx0XHRcdFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXG5cdFx0XHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cblx0XHRcdFx0c3BsaW5lVHViZSA9IGV4dHJ1ZGVQYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHN0ZXBzLCBmYWxzZSApO1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0XHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuXHRcdFx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0XHRiZXZlbFNlZ21lbnRzID0gMDtcblx0XHRcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xuXHRcdFx0XHRiZXZlbFNpemUgPSAwO1xuXHRcdFx0XHRiZXZlbE9mZnNldCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cblx0XHRcdGNvbnN0IHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG5cdFx0XHRsZXQgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcblx0XHRcdGNvbnN0IGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cblx0XHRcdGNvbnN0IHJldmVyc2UgPSAhIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cblx0XHRcdGlmICggcmV2ZXJzZSApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdFx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cblx0XHRcdC8qIFZlcnRpY2VzICovXG5cblx0XHRcdGNvbnN0IGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuXHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIHNjYWxlUHQyKCBwdCwgdmVjLCBzaXplICkge1xuXG5cdFx0XHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3QnICk7XG5cblx0XHRcdFx0cmV0dXJuIHB0LmNsb25lKCkuYWRkU2NhbGVkVmVjdG9yKCB2ZWMsIHNpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2bGVuID0gdmVydGljZXMubGVuZ3RoLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cblx0XHRcdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG5cdFx0XHRmdW5jdGlvbiBnZXRCZXZlbFZlYyggaW5QdCwgaW5QcmV2LCBpbk5leHQgKSB7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuXHRcdFx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG5cdFx0XHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuXHRcdFx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuXG5cdFx0XHRcdGxldCB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5OyAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XG5cblx0XHRcdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuXHRcdFx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0XHRcdGNvbnN0IHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXG5cdFx0XHRcdFx0dl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcblx0XHRcdFx0Y29uc3Qgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcblx0XHRcdFx0XHR2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXG5cdFx0XHRcdGNvbnN0IHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblxuXHRcdFx0XHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG5cdFx0XHRcdGNvbnN0IGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHQvLyBub3QgY29sbGluZWFyXG5cblx0XHRcdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcblxuXHRcdFx0XHRcdGNvbnN0IHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuXHRcdFx0XHRcdGNvbnN0IHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XG5cblx0XHRcdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cblx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuXHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cblx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuXHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cblx0XHRcdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHRcdFx0Y29uc3Qgc2YgPSAoICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cblx0XHRcdFx0XHRcdFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggKSAvXG5cdFx0XHRcdFx0XHQoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cblx0XHRcdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuXHRcdFx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHRcdFx0Ly8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xuXHRcdFx0XHRcdGNvbnN0IHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xuXHRcdFx0XHRcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cblx0XHRcdFx0XHRsZXQgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cblx0XHRcdFx0XHRpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZfcHJldl94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3g7XG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Y29uc3QgY29udG91ck1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG5cdFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHRcdFx0Y29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBob2xlc01vdmVtZW50cyA9IFtdO1xuXHRcdFx0bGV0IG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG5cdFx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcblx0XHRcdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG5cdFx0XHRmb3IgKCBsZXQgYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG5cdFx0XHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXG5cdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0Y29uc3QgeiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKSArIGJldmVsT2Zmc2V0O1xuXG5cdFx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICsgYmV2ZWxPZmZzZXQ7XG5cblx0XHRcdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cblx0XHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0XHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXHRcdFx0Zm9yICggbGV0IHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBkZXB0aCAvIHN0ZXBzICogcyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG5cdFx0XHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cblx0XHRcdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblx0XHRcdGZvciAoIGxldCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcblxuXHRcdFx0XHRjb25zdCB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcblx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBkZXB0aCArIHogKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0LyogRmFjZXMgKi9cblxuXHRcdFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXHRcdFx0YnVpbGRMaWRGYWNlcygpO1xuXG5cdFx0XHQvLyBTaWRlcyBmYWNlc1xuXG5cdFx0XHRidWlsZFNpZGVGYWNlcygpO1xuXG5cblx0XHRcdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblxuXHRcdFx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0XHRcdGxldCBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxuXHRcdFx0XHRcdGxldCBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcblx0XHRcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0XHQvLyBUb3AgZmFjZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBUb3AgZmFjZXNcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRsZXQgbGF5ZXJvZmZzZXQgPSAwO1xuXHRcdFx0XHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XG5cdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdFx0XHRzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xuXG5cdFx0XHRcdFx0Ly8sIHRydWVcblx0XHRcdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMSApO1xuXG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuXHRcdFx0XHRsZXQgaSA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggLS0gaSA+PSAwICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaiA9IGk7XG5cdFx0XHRcdFx0bGV0IGsgPSBpIC0gMTtcblx0XHRcdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcblxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHMgPSAwLCBzbCA9ICggc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMiApOyBzIDwgc2w7IHMgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNsZW4xID0gdmxlbiAqIHM7XG5cdFx0XHRcdFx0XHRjb25zdCBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuXHRcdFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXG5cdFx0XHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblxuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB4ICk7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHkgKTtcblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeiApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0YWRkVmVydGV4KCBhICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcblxuXHRcdFx0XHRjb25zdCBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdGNvbnN0IHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XG5cblx0XHRcdFx0YWRkVVYoIHV2c1sgMCBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCApIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBiICk7XG5cdFx0XHRcdGFkZFZlcnRleCggZCApO1xuXG5cdFx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBkICk7XG5cblxuXHRcdFx0XHRjb25zdCBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdGNvbnN0IHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDYsIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcblxuXHRcdFx0XHRhZGRVViggdXZzWyAwIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xuXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAyIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBpbmRleCApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAwIF0gKTtcblx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMSBdICk7XG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDIgXSApO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gYWRkVVYoIHZlY3RvcjIgKSB7XG5cblx0XHRcdFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnggKTtcblx0XHRcdFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMucGFyYW1ldGVycy5vcHRpb25zO1xuXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICk7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBqIF0gXTtcblxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXG5cdFx0aWYgKCBleHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBuZXcgQ3VydmVzWyBleHRydWRlUGF0aC50eXBlIF0oKS5mcm9tSlNPTiggZXh0cnVkZVBhdGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5vcHRpb25zICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IFdvcmxkVVZHZW5lcmF0b3IgPSB7XG5cblx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cblx0XHRjb25zdCBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xuXHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XG5cdFx0Y29uc3QgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XG5cdFx0Y29uc3QgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcblx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRuZXcgVmVjdG9yMiggYV94LCBhX3kgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIGJfeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgY195IClcblx0XHRdO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xuXG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcblx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcblx0XHRjb25zdCBhX3ogPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDIgXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xuXHRcdGNvbnN0IGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGJfeiA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMiBdO1xuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XG5cdFx0Y29uc3QgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XG5cdFx0Y29uc3QgY196ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAyIF07XG5cdFx0Y29uc3QgZF94ID0gdmVydGljZXNbIGluZGV4RCAqIDMgXTtcblx0XHRjb25zdCBkX3kgPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDEgXTtcblx0XHRjb25zdCBkX3ogPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDIgXTtcblxuXHRcdGlmICggTWF0aC5hYnMoIGFfeSAtIGJfeSApIDwgTWF0aC5hYnMoIGFfeCAtIGJfeCApICkge1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV94LCAxIC0gYV96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIDEgLSBiX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgMSAtIGNfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF94LCAxIC0gZF96IClcblx0XHRcdF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV95LCAxIC0gYV96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3ksIDEgLSBiX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF95LCAxIC0gZF96IClcblx0XHRcdF07XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5mdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgb3B0aW9ucywgZGF0YSApIHtcblxuXHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdH1cblxuXHRkYXRhLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgb3B0aW9ucyApO1xuXG5cdGlmICggb3B0aW9ucy5leHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkgZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aC50b0pTT04oKTtcblxuXHRyZXR1cm4gZGF0YTtcblxufVxuXG5cbmV4cG9ydCB7IEV4dHJ1ZGVHZW9tZXRyeSB9O1xuIiwiZXhwb3J0ICogZnJvbSAnLi9Cb3hHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NhcHN1bGVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NpcmNsZUdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQ29uZUdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQ3lsaW5kZXJHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0RvZGVjYWhlZHJvbkdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vRWRnZXNHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0V4dHJ1ZGVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0ljb3NhaGVkcm9uR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9MYXRoZUdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vT2N0YWhlZHJvbkdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vUGxhbmVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1JpbmdHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1NoYXBlR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9TcGhlcmVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1RldHJhaGVkcm9uR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Ub3J1c0dlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vVG9ydXNLbm90R2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9UdWJlR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9XaXJlZnJhbWVHZW9tZXRyeS5qcyc7XG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XG5cbmNsYXNzIEljb3NhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQtIDEsIHQsIDAsIFx0MSwgdCwgMCwgXHQtIDEsIC0gdCwgMCwgXHQxLCAtIHQsIDAsXG5cdFx0XHQwLCAtIDEsIHQsIFx0MCwgMSwgdCxcdDAsIC0gMSwgLSB0LCBcdDAsIDEsIC0gdCxcblx0XHRcdHQsIDAsIC0gMSwgXHR0LCAwLCAxLCBcdC0gdCwgMCwgLSAxLCBcdC0gdCwgMCwgMVxuXHRcdF07XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW1xuXHRcdFx0MCwgMTEsIDUsIFx0MCwgNSwgMSwgXHQwLCAxLCA3LCBcdDAsIDcsIDEwLCBcdDAsIDEwLCAxMSxcblx0XHRcdDEsIDUsIDksIFx0NSwgMTEsIDQsXHQxMSwgMTAsIDIsXHQxMCwgNywgNixcdDcsIDEsIDgsXG5cdFx0XHQzLCA5LCA0LCBcdDMsIDQsIDIsXHQzLCAyLCA2LFx0MywgNiwgOCxcdDMsIDgsIDksXG5cdFx0XHQ0LCA5LCA1LCBcdDIsIDQsIDExLFx0NiwgMiwgMTAsXHQ4LCA2LCA3LFx0OSwgOCwgMVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBJY29zYWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuXG5jbGFzcyBMYXRoZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbIG5ldyBWZWN0b3IyKCAwLCAtIDAuNSApLCBuZXcgVmVjdG9yMiggMC41LCAwICksIG5ldyBWZWN0b3IyKCAwLCAwLjUgKSBdLCBzZWdtZW50cyA9IDEyLCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHBvaW50czogcG9pbnRzLFxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcblx0XHR9O1xuXG5cdFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKCBzZWdtZW50cyApO1xuXG5cdFx0Ly8gY2xhbXAgcGhpTGVuZ3RoIHNvIGl0J3MgaW4gcmFuZ2Ugb2YgWyAwLCAyUEkgXVxuXG5cdFx0cGhpTGVuZ3RoID0gTWF0aFV0aWxzLmNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbml0Tm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY3VyTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwcmV2Tm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgZHggPSAwO1xuXHRcdGxldCBkeSA9IDA7XG5cblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0c3dpdGNoICggaiApIHtcblxuXHRcdFx0XHRjYXNlIDA6XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICggcG9pbnRzLmxlbmd0aCAtIDEgKTpcdC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGxhc3QgVmVydGV4IG9uIHBhdGhcblxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIHByZXZOb3JtYWwueCwgcHJldk5vcm1hbC55LCBwcmV2Tm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XHRcdFx0Ly8gZGVmYXVsdCBoYW5kbGluZyBmb3IgYWxsIHZlcnRpY2VzIGluIGJldHdlZW5cblxuXHRcdFx0XHRcdGR4ID0gcG9pbnRzWyBqICsgMSBdLnggLSBwb2ludHNbIGogXS54O1xuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBkeSAqIDEuMDtcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcblxuXHRcdFx0XHRcdGN1ck5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ICs9IHByZXZOb3JtYWwueDtcblx0XHRcdFx0XHRub3JtYWwueSArPSBwcmV2Tm9ybWFsLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xuXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KCBjdXJOb3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIHV2cyBhbmQgbm9ybWFsc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCBwaGkgKTtcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCBwaGkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XG5cdFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y29uc3QgeCA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIHNpbjtcblx0XHRcdFx0Y29uc3QgeSA9IGluaXROb3JtYWxzWyAzICogaiArIDEgXTtcblx0XHRcdFx0Y29uc3QgeiA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIGNvcztcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRjb25zdCBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XG5cdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRoZUdlb21ldHJ5KCBkYXRhLnBvaW50cywgZGF0YS5zZWdtZW50cywgZGF0YS5waGlTdGFydCwgZGF0YS5waGlMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBMYXRoZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XG5cbmNsYXNzIE9jdGFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDAsIDAsIFx0LSAxLCAwLCAwLFx0MCwgMSwgMCxcblx0XHRcdDAsIC0gMSwgMCwgXHQwLCAwLCAxLFx0MCwgMCwgLSAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQwLCAyLCA0LFx0MCwgNCwgMyxcdDAsIDMsIDUsXG5cdFx0XHQwLCA1LCAyLFx0MSwgMiwgNSxcdDEsIDUsIDMsXG5cdFx0XHQxLCAzLCA0LFx0MSwgNCwgMlxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE9jdGFoZWRyb25HZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5cbmNsYXNzIFBsYW5lR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgd2lkdGhTZWdtZW50cyA9IDEsIGhlaWdodFNlZ21lbnRzID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcblx0XHR9O1xuXG5cdFx0Y29uc3Qgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcblx0XHRjb25zdCBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cblx0XHRjb25zdCBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKTtcblx0XHRjb25zdCBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XG5cblx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0Y29uc3QgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdFx0Y29uc3Qgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0Y29uc3Qgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAtIHksIDAgKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xuXHRcdFx0XHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0Y29uc3QgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0Y29uc3QgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRjb25zdCBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFBsYW5lR2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBQb2x5aGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHZlcnRpY2VzID0gW10sIGluZGljZXMgPSBbXSwgcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcyxcblx0XHRcdGluZGljZXM6IGluZGljZXMsXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHRcdC8vIGRlZmF1bHQgYnVmZmVyIGRhdGFcblxuXHRcdGNvbnN0IHZlcnRleEJ1ZmZlciA9IFtdO1xuXHRcdGNvbnN0IHV2QnVmZmVyID0gW107XG5cblx0XHQvLyB0aGUgc3ViZGl2aXNpb24gY3JlYXRlcyB0aGUgdmVydGV4IGJ1ZmZlciBkYXRhXG5cblx0XHRzdWJkaXZpZGUoIGRldGFpbCApO1xuXG5cdFx0Ly8gYWxsIHZlcnRpY2VzIHNob3VsZCBsaWUgb24gYSBjb25jZXB0dWFsIHNwaGVyZSB3aXRoIGEgZ2l2ZW4gcmFkaXVzXG5cblx0XHRhcHBseVJhZGl1cyggcmFkaXVzICk7XG5cblx0XHQvLyBmaW5hbGx5LCBjcmVhdGUgdGhlIHV2IGRhdGFcblxuXHRcdGdlbmVyYXRlVVZzKCk7XG5cblx0XHQvLyBidWlsZCBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlci5zbGljZSgpLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QnVmZmVyLCAyICkgKTtcblxuXHRcdGlmICggZGV0YWlsID09PSAwICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7IC8vIHNtb290aCBub3JtYWxzXG5cblx0XHR9XG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBzdWJkaXZpZGUoIGRldGFpbCApIHtcblxuXHRcdFx0Y29uc3QgYSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGZhY2VzIGFuZCBhcHBseSBhIHN1YmRpdmlzaW9uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdC8vIGdldCB0aGUgdmVydGljZXMgb2YgdGhlIGZhY2VcblxuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMCBdLCBhICk7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAxIF0sIGIgKTtcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDIgXSwgYyApO1xuXG5cdFx0XHRcdC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cblxuXHRcdFx0XHRzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICkge1xuXG5cdFx0XHRjb25zdCBjb2xzID0gZGV0YWlsICsgMTtcblxuXHRcdFx0Ly8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cblxuXHRcdFx0Y29uc3QgdiA9IFtdO1xuXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvblxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gY29sczsgaSArKyApIHtcblxuXHRcdFx0XHR2WyBpIF0gPSBbXTtcblxuXHRcdFx0XHRjb25zdCBhaiA9IGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xuXHRcdFx0XHRjb25zdCBiaiA9IGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xuXG5cdFx0XHRcdGNvbnN0IHJvd3MgPSBjb2xzIC0gaTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcblxuXHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xuXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IGFqO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb2xzOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XG5cblx0XHRcdFx0XHRpZiAoIGogJSAyID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrIF0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayArIDEgXSApO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhcHBseVJhZGl1cyggcmFkaXVzICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBidWZmZXIgYW5kIGFwcGx5IHRoZSByYWRpdXMgdG8gZWFjaCB2ZXJ0ZXhcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcblx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF07XG5cblx0XHRcdFx0dmVydGV4Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcblxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDIgXSA9IHZlcnRleC56O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcblx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF07XG5cblx0XHRcdFx0Y29uc3QgdSA9IGF6aW11dGgoIHZlcnRleCApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdGNvbnN0IHYgPSBpbmNsaW5hdGlvbiggdmVydGV4ICkgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHR1dkJ1ZmZlci5wdXNoKCB1LCAxIC0gdiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvcnJlY3RVVnMoKTtcblxuXHRcdFx0Y29ycmVjdFNlYW0oKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xuXG5cdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtLCBzZWUgIzMyNjlcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdXZCdWZmZXIubGVuZ3RoOyBpICs9IDYgKSB7XG5cblx0XHRcdFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXG5cblx0XHRcdFx0Y29uc3QgeDAgPSB1dkJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0Y29uc3QgeDEgPSB1dkJ1ZmZlclsgaSArIDIgXTtcblx0XHRcdFx0Y29uc3QgeDIgPSB1dkJ1ZmZlclsgaSArIDQgXTtcblxuXHRcdFx0XHRjb25zdCBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xuXHRcdFx0XHRjb25zdCBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xuXG5cdFx0XHRcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuXHRcdFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAwIF0gKz0gMTtcblx0XHRcdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAyIF0gKz0gMTtcblx0XHRcdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZCdWZmZXJbIGkgKyA0IF0gKz0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHB1c2hWZXJ0ZXgoIHZlcnRleCApIHtcblxuXHRcdFx0dmVydGV4QnVmZmVyLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFZlcnRleEJ5SW5kZXgoIGluZGV4LCB2ZXJ0ZXggKSB7XG5cblx0XHRcdGNvbnN0IHN0cmlkZSA9IGluZGV4ICogMztcblxuXHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMCBdO1xuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMSBdO1xuXHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMiBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcblxuXHRcdFx0Y29uc3QgYSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRjb25zdCBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGNvbnN0IHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRjb25zdCB1dkIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdXZDID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gOSwgaiArPSA2ICkge1xuXG5cdFx0XHRcdGEuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0sIHZlcnRleEJ1ZmZlclsgaSArIDEgXSwgdmVydGV4QnVmZmVyWyBpICsgMiBdICk7XG5cdFx0XHRcdGIuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAzIF0sIHZlcnRleEJ1ZmZlclsgaSArIDQgXSwgdmVydGV4QnVmZmVyWyBpICsgNSBdICk7XG5cdFx0XHRcdGMuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyA2IF0sIHZlcnRleEJ1ZmZlclsgaSArIDcgXSwgdmVydGV4QnVmZmVyWyBpICsgOCBdICk7XG5cblx0XHRcdFx0dXZBLnNldCggdXZCdWZmZXJbIGogKyAwIF0sIHV2QnVmZmVyWyBqICsgMSBdICk7XG5cdFx0XHRcdHV2Qi5zZXQoIHV2QnVmZmVyWyBqICsgMiBdLCB1dkJ1ZmZlclsgaiArIDMgXSApO1xuXHRcdFx0XHR1dkMuc2V0KCB1dkJ1ZmZlclsgaiArIDQgXSwgdXZCdWZmZXJbIGogKyA1IF0gKTtcblxuXHRcdFx0XHRjZW50cm9pZC5jb3B5KCBhICkuYWRkKCBiICkuYWRkKCBjICkuZGl2aWRlU2NhbGFyKCAzICk7XG5cblx0XHRcdFx0Y29uc3QgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QSwgaiArIDAsIGEsIGF6aSApO1xuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QiwgaiArIDIsIGIsIGF6aSApO1xuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QywgaiArIDQsIGMsIGF6aSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCBzdHJpZGUsIHZlY3RvciwgYXppbXV0aCApIHtcblxuXHRcdFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB7XG5cblx0XHRcdFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gdXYueCAtIDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkge1xuXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG5cdFx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG5cdFx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIC0gdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBQb2x5aGVkcm9uR2VvbWV0cnkoIGRhdGEudmVydGljZXMsIGRhdGEuaW5kaWNlcywgZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlscyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY2xhc3MgUmluZ0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBpbm5lclJhZGl1cyA9IDAuNSwgb3V0ZXJSYWRpdXMgPSAxLCB0aGV0YVNlZ21lbnRzID0gMzIsIHBoaVNlZ21lbnRzID0gMSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR0aGV0YVNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKTtcblx0XHRwaGlTZWdtZW50cyA9IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gc29tZSBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRsZXQgcmFkaXVzID0gaW5uZXJSYWRpdXM7XG5cdFx0Y29uc3QgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdGhldGFTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcblx0XHRcdFx0dXYueSA9ICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG5cblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmNyZWFzZSB0aGUgcmFkaXVzIGZvciBuZXh0IHJvdyBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuXHRcdH1cblxuXHRcdC8vIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcblxuXHRcdFx0XHRjb25zdCBhID0gc2VnbWVudDtcblx0XHRcdFx0Y29uc3QgYiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcblx0XHRcdFx0Y29uc3QgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblx0XHRcdFx0Y29uc3QgZCA9IHNlZ21lbnQgKyAxO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFJpbmdHZW9tZXRyeSggZGF0YS5pbm5lclJhZGl1cywgZGF0YS5vdXRlclJhZGl1cywgZGF0YS50aGV0YVNlZ21lbnRzLCBkYXRhLnBoaVNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBSaW5nR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5pbXBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi4vZXh0cmFzL1NoYXBlVXRpbHMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbmNsYXNzIFNoYXBlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMCwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgLSAwLjUgKSBdICksIGN1cnZlU2VnbWVudHMgPSAxMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcblx0XHRcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcblx0XHR9O1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXHRcdGxldCBncm91cENvdW50ID0gMDtcblxuXHRcdC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcInNoYXBlc1wiIHBhcmFtZXRlclxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGFkZFNoYXBlKCBzaGFwZXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XG5cblx0XHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSApOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblx0XHRcdFx0Z3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xuXG5cdFx0XHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZVZlcnRpY2VzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVIb2xlICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzaGFwZUhvbGVzWyBpIF0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xuXG5cdFx0XHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoIHNoYXBlSG9sZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IHNoYXBlVmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIDAgKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cdFx0XHRcdHV2cy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnkgKTsgLy8gd29ybGQgdXZzXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0Y29uc3QgYiA9IGZhY2VbIDEgXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBjID0gZmFjZVsgMiBdICsgaW5kZXhPZmZzZXQ7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhLCBzaGFwZXMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeVNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGogXSBdO1xuXG5cdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5jdXJ2ZVNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBkYXRhICkge1xuXG5cdGRhdGEuc2hhcGVzID0gW107XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XG5cblx0fVxuXG5cdHJldHVybiBkYXRhO1xuXG59XG5cbmV4cG9ydCB7IFNoYXBlR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIFNwaGVyZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB3aWR0aFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMTYsIHBoaVN0YXJ0ID0gMCwgcGhpTGVuZ3RoID0gTWF0aC5QSSAqIDIsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSApO1xuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgKTtcblxuXHRcdGNvbnN0IHRoZXRhRW5kID0gTWF0aC5taW4oIHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aCwgTWF0aC5QSSApO1xuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBncmlkID0gW107XG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzUm93ID0gW107XG5cblx0XHRcdGNvbnN0IHYgPSBpeSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIHRoZSBwb2xlc1xuXG5cdFx0XHRsZXQgdU9mZnNldCA9IDA7XG5cblx0XHRcdGlmICggaXkgPT09IDAgJiYgdGhldGFTdGFydCA9PT0gMCApIHtcblxuXHRcdFx0XHR1T2Zmc2V0ID0gMC41IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0fSBlbHNlIGlmICggaXkgPT09IGhlaWdodFNlZ21lbnRzICYmIHRoZXRhRW5kID09PSBNYXRoLlBJICkge1xuXG5cdFx0XHRcdHVPZmZzZXQgPSAtIDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdSA9IGl4IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCB2ZXJ0ZXggKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggdSArIHVPZmZzZXQsIDEgLSB2ICk7XG5cblx0XHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKysgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhID0gZ3JpZFsgaXkgXVsgaXggKyAxIF07XG5cdFx0XHRcdGNvbnN0IGIgPSBncmlkWyBpeSBdWyBpeCBdO1xuXHRcdFx0XHRjb25zdCBjID0gZ3JpZFsgaXkgKyAxIF1bIGl4IF07XG5cdFx0XHRcdGNvbnN0IGQgPSBncmlkWyBpeSArIDEgXVsgaXggKyAxIF07XG5cblx0XHRcdFx0aWYgKCBpeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpZiAoIGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgU3BoZXJlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BoZXJlR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFBvbHloZWRyb25HZW9tZXRyeSB9IGZyb20gJy4vUG9seWhlZHJvbkdlb21ldHJ5LmpzJztcblxuY2xhc3MgVGV0cmFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDEsIDEsIFx0LSAxLCAtIDEsIDEsIFx0LSAxLCAxLCAtIDEsIFx0MSwgLSAxLCAtIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDIsIDEsIDAsIFx0MCwgMywgMixcdDEsIDMsIDAsXHQyLCAzLCAxXG5cdFx0XTtcblxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRldHJhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBUZXRyYWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBUb3J1c0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB0dWJlID0gMC40LCByYWRpYWxTZWdtZW50cyA9IDEyLCB0dWJ1bGFyU2VnbWVudHMgPSA0OCwgYXJjID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR0dWJlOiB0dWJlLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRhcmM6IGFyY1xuXHRcdH07XG5cblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICk7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgY2VudGVyICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0XHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0Y29uc3QgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuXHRcdFx0XHRjb25zdCBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcblx0XHRcdFx0Y29uc3QgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdFx0Y29uc3QgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEuYXJjICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRvcnVzR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIFRvcnVzS25vdEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCB0dWJlID0gMC40LCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaWFsU2VnbWVudHMgPSA4LCBwID0gMiwgcSA9IDMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0cDogcCxcblx0XHRcdHE6IHFcblx0XHR9O1xuXG5cdFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICk7XG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgUDEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IFAyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGNvbnN0IEIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IFQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKysgaSApIHtcblxuXHRcdFx0Ly8gdGhlIHJhZGlhbiBcInVcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlIG9mIHRoZSBjdXJyZW50IHR1YnVsYXIgc2VnbWVudFxuXG5cdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIHAgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXG5cdFx0XHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcImNvb3JkaW5hdGUgc3BhY2VcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXG5cblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBQMSApO1xuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1ICsgMC4wMSwgcCwgcSwgcmFkaXVzLCBQMiApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuXHRcdFx0VC5zdWJWZWN0b3JzKCBQMiwgUDEgKTtcblx0XHRcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0XHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xuXHRcdFx0Ti5jcm9zc1ZlY3RvcnMoIEIsIFQgKTtcblxuXHRcdFx0Ly8gbm9ybWFsaXplIEIsIE4uIFQgY2FuIGJlIGlnbm9yZWQsIHdlIGRvbid0IHVzZSBpdFxuXG5cdFx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdFx0Ti5ub3JtYWxpemUoKTtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArKyBqICkge1xuXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxuXHRcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdGNvbnN0IGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTtcblx0XHRcdFx0Y29uc3QgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG5cdFx0XHRcdC8vIGZpcnN0IHdlIG9yaWVudCB0aGUgZXh0cnVzaW9uIHdpdGggb3VyIGJhc2lzIHZlY3RvcnMsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxuXG5cdFx0XHRcdHZlcnRleC54ID0gUDEueCArICggY3ggKiBOLnggKyBjeSAqIEIueCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoIGN4ICogTi55ICsgY3kgKiBCLnkgKTtcblx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKCBjeCAqIE4ueiArIGN5ICogQi56ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBQMSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHRjb25zdCBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXG5cblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24gKSB7XG5cblx0XHRcdGNvbnN0IGN1ID0gTWF0aC5jb3MoIHUgKTtcblx0XHRcdGNvbnN0IHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHRcdGNvbnN0IHF1T3ZlclAgPSBxIC8gcCAqIHU7XG5cdFx0XHRjb25zdCBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XG5cblx0XHRcdHBvc2l0aW9uLnggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG5cdFx0XHRwb3NpdGlvbi55ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuXHRcdFx0cG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUb3J1c0tub3RHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEucCwgZGF0YS5xICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRvcnVzS25vdEdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCAqIGFzIEN1cnZlcyBmcm9tICcuLi9leHRyYXMvY3VydmVzL0N1cnZlcy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBUdWJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHBhdGggPSBuZXcgQ3VydmVzWyAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJyBdKCBuZXcgVmVjdG9yMyggLSAxLCAtIDEsIDAgKSwgbmV3IFZlY3RvcjMoIC0gMSwgMSwgMCApLCBuZXcgVmVjdG9yMyggMSwgMSwgMCApICksIHR1YnVsYXJTZWdtZW50cyA9IDY0LCByYWRpdXMgPSAxLCByYWRpYWxTZWdtZW50cyA9IDgsIGNsb3NlZCA9IGZhbHNlICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZFxuXHRcdH07XG5cblx0XHRjb25zdCBmcmFtZXMgPSBwYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHR1YnVsYXJTZWdtZW50cywgY2xvc2VkICk7XG5cblx0XHQvLyBleHBvc2UgaW50ZXJuYWxzXG5cblx0XHR0aGlzLnRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzO1xuXHRcdHRoaXMubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xuXHRcdHRoaXMuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0bGV0IFAgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyXG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHQvLyBjcmVhdGUgYnVmZmVyIGRhdGFcblxuXHRcdGdlbmVyYXRlQnVmZmVyRGF0YSgpO1xuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlU2VnbWVudCggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBub3QgY2xvc2VkLCBnZW5lcmF0ZSB0aGUgbGFzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHNcblx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgZHVwbGljYXRlIHRoZSBmaXJzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHMgKHV2cyB3aWxsIGRpZmZlcilcblxuXHRcdFx0Z2VuZXJhdGVTZWdtZW50KCAoIGNsb3NlZCA9PT0gZmFsc2UgKSA/IHR1YnVsYXJTZWdtZW50cyA6IDAgKTtcblxuXHRcdFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cblx0XHRcdC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xuXG5cdFx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0XHQvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xuXG5cdFx0XHRnZW5lcmF0ZUluZGljZXMoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudCggaSApIHtcblxuXHRcdFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuXG5cdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XG5cblx0XHRcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0XHRjb25zdCBOID0gZnJhbWVzLm5vcm1hbHNbIGkgXTtcblx0XHRcdGNvbnN0IEIgPSBmcmFtZXMuYmlub3JtYWxzWyBpIF07XG5cblx0XHRcdC8vIGdlbmVyYXRlIG5vcm1hbHMgYW5kIHZlcnRpY2VzIGZvciB0aGUgY3VycmVudCBzZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4oIHYgKTtcblx0XHRcdFx0Y29uc3QgY29zID0gLSBNYXRoLmNvcyggdiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbC54ID0gKCBjb3MgKiBOLnggKyBzaW4gKiBCLnggKTtcblx0XHRcdFx0bm9ybWFsLnkgPSAoIGNvcyAqIE4ueSArIHNpbiAqIEIueSApO1xuXHRcdFx0XHRub3JtYWwueiA9ICggY29zICogTi56ICsgc2luICogQi56ICk7XG5cdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAueSArIHJhZGl1cyAqIG5vcm1hbC55O1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IFAueiArIHJhZGl1cyAqIG5vcm1hbC56O1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcblx0XHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRcdHV2LnggPSBpIC8gdHVidWxhclNlZ21lbnRzO1xuXHRcdFx0XHRcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEucGF0aCA9IHRoaXMucGFyYW1ldGVycy5wYXRoLnRvSlNPTigpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdC8vIFRoaXMgb25seSB3b3JrcyBmb3IgYnVpbHQtaW4gY3VydmVzIChlLmcuIENhdG11bGxSb21DdXJ2ZTMpLlxuXHRcdC8vIFVzZXIgZGVmaW5lZCBjdXJ2ZXMgb3IgaW5zdGFuY2VzIG9mIEN1cnZlUGF0aCB3aWxsIG5vdCBiZSBkZXNlcmlhbGl6ZWQuXG5cdFx0cmV0dXJuIG5ldyBUdWJlR2VvbWV0cnkoXG5cdFx0XHRuZXcgQ3VydmVzWyBkYXRhLnBhdGgudHlwZSBdKCkuZnJvbUpTT04oIGRhdGEucGF0aCApLFxuXHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRkYXRhLmNsb3NlZFxuXHRcdCk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgVHViZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBXaXJlZnJhbWVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBudWxsICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnlcblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gYnVmZmVyXG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBlZGdlcyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBlbmQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIGluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0bGV0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRncm91cHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmNvdW50LCBtYXRlcmlhbEluZGV4OiAwIH0gXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWRnZXMgd2l0aG91dCBkdXBsaWNhdGVzXG5cblx0XHRcdFx0Zm9yICggbGV0IG8gPSAwLCBvbCA9IGdyb3Vwcy5sZW5ndGg7IG8gPCBvbDsgKysgbyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBvIF07XG5cblx0XHRcdFx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBDb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBncm91cFN0YXJ0LCBsID0gKCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCApOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MSA9IGluZGljZXMuZ2V0WCggaSArIGogKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgyID0gaW5kaWNlcy5nZXRYKCBpICsgKCBqICsgMSApICUgMyApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcblx0XHRcdFx0XHRcdFx0ZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzVW5pcXVlRWRnZSggc3RhcnQsIGVuZCwgZWRnZXMgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnogKTtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBlbmQueCwgZW5kLnksIGVuZC56ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9ICggcG9zaXRpb24uY291bnQgLyAzICk7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdGhyZWUgZWRnZXMgcGVyIHRyaWFuZ2xlLCBhbiBlZGdlIGlzIHJlcHJlc2VudGVkIGFzIChpbmRleDEsIGluZGV4Milcblx0XHRcdFx0XHRcdC8vIGUuZy4gdGhlIGZpcnN0IHRyaWFuZ2xlIGhhcyB0aGUgZm9sbG93aW5nIGVkZ2VzOiAoMCwxKSwoMSwyKSwoMiwwKVxuXG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSAzICogaSArIGo7XG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAzICogaSArICggKCBqICsgMSApICUgMyApO1xuXG5cdFx0XHRcdFx0XHRzdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgxICk7XG5cdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGlzVW5pcXVlRWRnZSggc3RhcnQsIGVuZCwgZWRnZXMgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBzdGFydC54LCBzdGFydC55LCBzdGFydC56ICk7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIGVuZC54LCBlbmQueSwgZW5kLnogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkge1xuXG5cdGNvbnN0IGhhc2gxID0gYCR7c3RhcnQueH0sJHtzdGFydC55fSwke3N0YXJ0Lnp9LSR7ZW5kLnh9LCR7ZW5kLnl9LCR7ZW5kLnp9YDtcblx0Y29uc3QgaGFzaDIgPSBgJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen0tJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen1gOyAvLyBjb2luY2lkZW50IGVkZ2VcblxuXHRpZiAoIGVkZ2VzLmhhcyggaGFzaDEgKSA9PT0gdHJ1ZSB8fCBlZGdlcy5oYXMoIGhhc2gyICkgPT09IHRydWUgKSB7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdGVkZ2VzLmFkZCggaGFzaDEgKTtcblx0XHRlZGdlcy5hZGQoIGhhc2gyICk7XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgV2lyZWZyYW1lR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBCb3gzIHtcblxuXHRjb25zdHJ1Y3RvciggbWluID0gbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKSwgbWF4ID0gbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSApIHtcblxuXHRcdHRoaXMuaXNCb3gzID0gdHJ1ZTtcblxuXHRcdHRoaXMubWluID0gbWluO1xuXHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdH1cblxuXHRzZXQoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yLmZyb21BcnJheSggYXJyYXksIGkgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuXHRcdGNvbnN0IGhhbGZTaXplID0gX3ZlY3Rvci5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tT2JqZWN0KCBvYmplY3QsIHByZWNpc2UgPSBmYWxzZSApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdCggb2JqZWN0LCBwcmVjaXNlICk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VFbXB0eSgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpc0VtcHR5KCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcblxuXHR9XG5cblx0Z2V0Q2VudGVyKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwLCAwICkgOiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdH1cblxuXHRnZXRTaXplKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwLCAwICkgOiB0YXJnZXQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0fVxuXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVZlY3RvciggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHQvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXG5cdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgZmFsc2UgKTtcblxuXHRcdGlmICggb2JqZWN0LmJvdW5kaW5nQm94ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94LmNvcHkoIG9iamVjdC5ib3VuZGluZ0JveCApO1xuXHRcdFx0X2JveC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR0aGlzLnVuaW9uKCBfYm94ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggcHJlY2lzZSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaSApLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfYm94LmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHRcdFx0X2JveC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0dGhpcy51bmlvbiggX2JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBwcmVjaXNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XG5cdFx0XHRwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0Y29udGFpbnNCb3goIGJveCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcblx0XHRcdHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuXG5cdH1cblxuXHRnZXRQYXJhbWV0ZXIoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcblx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuXHRcdCk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0Ym94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuXHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgX3ZlY3RvciApO1xuXG5cdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXG5cdFx0cmV0dXJuIF92ZWN0b3IuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNQbGFuZSggcGxhbmUgKSB7XG5cblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXG5cdFx0Ly8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cblx0XHRsZXQgbWluLCBtYXg7XG5cblx0XHRpZiAoIHBsYW5lLm5vcm1hbC54ID4gMCApIHtcblxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuXHRcdFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuXHRcdFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueSA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHBsYW5lLm5vcm1hbC56ID4gMCApIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblxuXHRcdH1cblxuXHRcdHJldHVybiAoIG1pbiA8PSAtIHBsYW5lLmNvbnN0YW50ICYmIG1heCA+PSAtIHBsYW5lLmNvbnN0YW50ICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcblx0XHR0aGlzLmdldENlbnRlciggX2NlbnRlciApO1xuXHRcdF9leHRlbnRzLnN1YlZlY3RvcnMoIHRoaXMubWF4LCBfY2VudGVyICk7XG5cblx0XHQvLyB0cmFuc2xhdGUgdHJpYW5nbGUgdG8gYWFiYiBvcmlnaW5cblx0XHRfdjAuc3ViVmVjdG9ycyggdHJpYW5nbGUuYSwgX2NlbnRlciApO1xuXHRcdF92MS5zdWJWZWN0b3JzKCB0cmlhbmdsZS5iLCBfY2VudGVyICk7XG5cdFx0X3YyLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmMsIF9jZW50ZXIgKTtcblxuXHRcdC8vIGNvbXB1dGUgZWRnZSB2ZWN0b3JzIGZvciB0cmlhbmdsZVxuXHRcdF9mMC5zdWJWZWN0b3JzKCBfdjEsIF92MCApO1xuXHRcdF9mMS5zdWJWZWN0b3JzKCBfdjIsIF92MSApO1xuXHRcdF9mMi5zdWJWZWN0b3JzKCBfdjAsIF92MiApO1xuXG5cdFx0Ly8gdGVzdCBhZ2FpbnN0IGF4ZXMgdGhhdCBhcmUgZ2l2ZW4gYnkgY3Jvc3MgcHJvZHVjdCBjb21iaW5hdGlvbnMgb2YgdGhlIGVkZ2VzIG9mIHRoZSB0cmlhbmdsZSBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBhYWJiXG5cdFx0Ly8gbWFrZSBhbiBheGlzIHRlc3Rpbmcgb2YgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgYWFiYiBhZ2FpbnN0IGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlID0gOSBheGlzIG9mIHNlcGFyYXRpb25cblx0XHQvLyBheGlzX2lqID0gdV9pIHggZl9qICh1MCwgdTEsIHUyID0gZmFjZSBub3JtYWxzIG9mIGFhYmIgPSB4LHkseiBheGVzIHZlY3RvcnMgc2luY2UgYWFiYiBpcyBheGlzIGFsaWduZWQpXG5cdFx0bGV0IGF4ZXMgPSBbXG5cdFx0XHQwLCAtIF9mMC56LCBfZjAueSwgMCwgLSBfZjEueiwgX2YxLnksIDAsIC0gX2YyLnosIF9mMi55LFxuXHRcdFx0X2YwLnosIDAsIC0gX2YwLngsIF9mMS56LCAwLCAtIF9mMS54LCBfZjIueiwgMCwgLSBfZjIueCxcblx0XHRcdC0gX2YwLnksIF9mMC54LCAwLCAtIF9mMS55LCBfZjEueCwgMCwgLSBfZjIueSwgX2YyLngsIDBcblx0XHRdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyB0ZXN0IDMgZmFjZSBub3JtYWxzIGZyb20gdGhlIGFhYmJcblx0XHRheGVzID0gWyAxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxIF07XG5cdFx0aWYgKCAhIHNhdEZvckF4ZXMoIGF4ZXMsIF92MCwgX3YxLCBfdjIsIF9leHRlbnRzICkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIGZpbmFsbHkgdGVzdGluZyB0aGUgZmFjZSBub3JtYWwgb2YgdGhlIHRyaWFuZ2xlXG5cdFx0Ly8gdXNlIGFscmVhZHkgZXhpc3RpbmcgdHJpYW5nbGUgZWRnZSB2ZWN0b3JzIGhlcmVcblx0XHRfdHJpYW5nbGVOb3JtYWwuY3Jvc3NWZWN0b3JzKCBfZjAsIF9mMSApO1xuXHRcdGF4ZXMgPSBbIF90cmlhbmdsZU5vcm1hbC54LCBfdHJpYW5nbGVOb3JtYWwueSwgX3RyaWFuZ2xlTm9ybWFsLnogXTtcblxuXHRcdHJldHVybiBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApO1xuXG5cdH1cblxuXHRjbGFtcFBvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiB0aGlzLmNsYW1wUG9pbnQoIHBvaW50LCBfdmVjdG9yICkuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdTcGhlcmUoIHRhcmdldCApIHtcblxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCB0YXJnZXQuY2VudGVyICk7XG5cblx0XHRcdHRhcmdldC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIF92ZWN0b3IgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGludGVyc2VjdCggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dW5pb24oIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcblx0XHRfcG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXG5cdFx0X3BvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxuXHRcdF9wb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcblx0XHRfcG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXG5cdFx0X3BvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxuXHRcdF9wb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcblx0XHRfcG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXG5cdFx0X3BvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMVxuXG5cdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBfcG9pbnRzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9wb2ludHMgPSBbXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpXG5dO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuXG4vLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5jb25zdCBfdjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbi8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5jb25zdCBfZjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9jZW50ZXIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF90ZXN0QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gc2F0Rm9yQXhlcyggYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cyApIHtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzICkge1xuXG5cdFx0X3Rlc3RBeGlzLmZyb21BcnJheSggYXhlcywgaSApO1xuXHRcdC8vIHByb2plY3QgdGhlIGFhYmIgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCBfdGVzdEF4aXMueCApICsgZXh0ZW50cy55ICogTWF0aC5hYnMoIF90ZXN0QXhpcy55ICkgKyBleHRlbnRzLnogKiBNYXRoLmFicyggX3Rlc3RBeGlzLnogKTtcblx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcblx0XHRjb25zdCBwMCA9IHYwLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Y29uc3QgcDEgPSB2MS5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAyID0gdjIuZG90KCBfdGVzdEF4aXMgKTtcblx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcblxuXHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZXhwb3J0IHsgQm94MyB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9NYXRyaXg0LmpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jb25zdCBfbWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNsYXNzIEV1bGVyIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSBFdWxlci5ERUZBVUxUX09SREVSICkge1xuXG5cdFx0dGhpcy5pc0V1bGVyID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0fVxuXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCBvcmRlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHR9XG5cblx0c2V0IG9yZGVyKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHosIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG5cdH1cblxuXHRjb3B5KCBldWxlciApIHtcblxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSwgb3JkZXIgPSB0aGlzLl9vcmRlciwgdXBkYXRlID0gdHJ1ZSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0Y29uc3QgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcblx0XHRjb25zdCBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdGNvbnN0IG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRcdGNhc2UgJ1hZWic6XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWFonOlxuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWlhZJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pZWCc6XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWlgnOlxuXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWFpZJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0XHRpZiAoIHVwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUXVhdGVybmlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdF9tYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdH1cblxuXHRzZXRGcm9tVmVjdG9yMyggdiwgb3JkZXIgPSB0aGlzLl9vcmRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgKTtcblxuXHR9XG5cblx0cmVvcmRlciggbmV3T3JkZXIgKSB7XG5cblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cblx0XHRfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiwgbmV3T3JkZXIgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcblxuXHR9XG5cbn1cblxuRXVsZXIuREVGQVVMVF9PUkRFUiA9ICdYWVonO1xuXG5leHBvcnQgeyBFdWxlciB9O1xuIiwiY29uc3QgX2x1dCA9IFsgJzAwJywgJzAxJywgJzAyJywgJzAzJywgJzA0JywgJzA1JywgJzA2JywgJzA3JywgJzA4JywgJzA5JywgJzBhJywgJzBiJywgJzBjJywgJzBkJywgJzBlJywgJzBmJywgJzEwJywgJzExJywgJzEyJywgJzEzJywgJzE0JywgJzE1JywgJzE2JywgJzE3JywgJzE4JywgJzE5JywgJzFhJywgJzFiJywgJzFjJywgJzFkJywgJzFlJywgJzFmJywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI0JywgJzI1JywgJzI2JywgJzI3JywgJzI4JywgJzI5JywgJzJhJywgJzJiJywgJzJjJywgJzJkJywgJzJlJywgJzJmJywgJzMwJywgJzMxJywgJzMyJywgJzMzJywgJzM0JywgJzM1JywgJzM2JywgJzM3JywgJzM4JywgJzM5JywgJzNhJywgJzNiJywgJzNjJywgJzNkJywgJzNlJywgJzNmJywgJzQwJywgJzQxJywgJzQyJywgJzQzJywgJzQ0JywgJzQ1JywgJzQ2JywgJzQ3JywgJzQ4JywgJzQ5JywgJzRhJywgJzRiJywgJzRjJywgJzRkJywgJzRlJywgJzRmJywgJzUwJywgJzUxJywgJzUyJywgJzUzJywgJzU0JywgJzU1JywgJzU2JywgJzU3JywgJzU4JywgJzU5JywgJzVhJywgJzViJywgJzVjJywgJzVkJywgJzVlJywgJzVmJywgJzYwJywgJzYxJywgJzYyJywgJzYzJywgJzY0JywgJzY1JywgJzY2JywgJzY3JywgJzY4JywgJzY5JywgJzZhJywgJzZiJywgJzZjJywgJzZkJywgJzZlJywgJzZmJywgJzcwJywgJzcxJywgJzcyJywgJzczJywgJzc0JywgJzc1JywgJzc2JywgJzc3JywgJzc4JywgJzc5JywgJzdhJywgJzdiJywgJzdjJywgJzdkJywgJzdlJywgJzdmJywgJzgwJywgJzgxJywgJzgyJywgJzgzJywgJzg0JywgJzg1JywgJzg2JywgJzg3JywgJzg4JywgJzg5JywgJzhhJywgJzhiJywgJzhjJywgJzhkJywgJzhlJywgJzhmJywgJzkwJywgJzkxJywgJzkyJywgJzkzJywgJzk0JywgJzk1JywgJzk2JywgJzk3JywgJzk4JywgJzk5JywgJzlhJywgJzliJywgJzljJywgJzlkJywgJzllJywgJzlmJywgJ2EwJywgJ2ExJywgJ2EyJywgJ2EzJywgJ2E0JywgJ2E1JywgJ2E2JywgJ2E3JywgJ2E4JywgJ2E5JywgJ2FhJywgJ2FiJywgJ2FjJywgJ2FkJywgJ2FlJywgJ2FmJywgJ2IwJywgJ2IxJywgJ2IyJywgJ2IzJywgJ2I0JywgJ2I1JywgJ2I2JywgJ2I3JywgJ2I4JywgJ2I5JywgJ2JhJywgJ2JiJywgJ2JjJywgJ2JkJywgJ2JlJywgJ2JmJywgJ2MwJywgJ2MxJywgJ2MyJywgJ2MzJywgJ2M0JywgJ2M1JywgJ2M2JywgJ2M3JywgJ2M4JywgJ2M5JywgJ2NhJywgJ2NiJywgJ2NjJywgJ2NkJywgJ2NlJywgJ2NmJywgJ2QwJywgJ2QxJywgJ2QyJywgJ2QzJywgJ2Q0JywgJ2Q1JywgJ2Q2JywgJ2Q3JywgJ2Q4JywgJ2Q5JywgJ2RhJywgJ2RiJywgJ2RjJywgJ2RkJywgJ2RlJywgJ2RmJywgJ2UwJywgJ2UxJywgJ2UyJywgJ2UzJywgJ2U0JywgJ2U1JywgJ2U2JywgJ2U3JywgJ2U4JywgJ2U5JywgJ2VhJywgJ2ViJywgJ2VjJywgJ2VkJywgJ2VlJywgJ2VmJywgJ2YwJywgJ2YxJywgJ2YyJywgJ2YzJywgJ2Y0JywgJ2Y1JywgJ2Y2JywgJ2Y3JywgJ2Y4JywgJ2Y5JywgJ2ZhJywgJ2ZiJywgJ2ZjJywgJ2ZkJywgJ2ZlJywgJ2ZmJyBdO1xuXG5sZXQgX3NlZWQgPSAxMjM0NTY3O1xuXG5cbmNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG5cdGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCB1dWlkID0gX2x1dFsgZDAgJiAweGZmIF0gKyBfbHV0WyBkMCA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRfbHV0WyBkMSAmIDB4ZmYgXSArIF9sdXRbIGQxID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMSA+PiAxNiAmIDB4MGYgfCAweDQwIF0gKyBfbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRfbHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBfbHV0WyBkMiA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDIgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXG5cdFx0XHRfbHV0WyBkMyAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xuXG5cdC8vIC50b0xvd2VyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cblx0cmV0dXJuIHV1aWQudG9Mb3dlckNhc2UoKTtcblxufVxuXG5mdW5jdGlvbiBjbGFtcCggdmFsdWUsIG1pbiwgbWF4ICkge1xuXG5cdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cbn1cblxuLy8gY29tcHV0ZSBldWNsaWRlYW4gbW9kdWxvIG9mIG0gJSBuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5mdW5jdGlvbiBldWNsaWRlYW5Nb2R1bG8oIG4sIG0gKSB7XG5cblx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxufVxuXG4vLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5mdW5jdGlvbiBtYXBMaW5lYXIoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG59XG5cbi8vIGh0dHBzOi8vd3d3LmdhbWVkZXYubmV0L3R1dG9yaWFscy9wcm9ncmFtbWluZy9nZW5lcmFsLWFuZC1nYW1lcGxheS1wcm9ncmFtbWluZy9pbnZlcnNlLWxlcnAtYS1zdXBlci11c2VmdWwteWV0LW9mdGVuLW92ZXJsb29rZWQtZnVuY3Rpb24tcjUyMzAvXG5mdW5jdGlvbiBpbnZlcnNlTGVycCggeCwgeSwgdmFsdWUgKSB7XG5cblx0aWYgKCB4ICE9PSB5ICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgLSB4ICkgLyAoIHkgLSB4ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxuZnVuY3Rpb24gbGVycCggeCwgeSwgdCApIHtcblxuXHRyZXR1cm4gKCAxIC0gdCApICogeCArIHQgKiB5O1xuXG59XG5cbi8vIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xuZnVuY3Rpb24gZGFtcCggeCwgeSwgbGFtYmRhLCBkdCApIHtcblxuXHRyZXR1cm4gbGVycCggeCwgeSwgMSAtIE1hdGguZXhwKCAtIGxhbWJkYSAqIGR0ICkgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdmNzam55ejd4NFxuZnVuY3Rpb24gcGluZ3BvbmcoIHgsIGxlbmd0aCA9IDEgKSB7XG5cblx0cmV0dXJuIGxlbmd0aCAtIE1hdGguYWJzKCBldWNsaWRlYW5Nb2R1bG8oIHgsIGxlbmd0aCAqIDIgKSAtIGxlbmd0aCApO1xuXG59XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuZnVuY3Rpb24gc21vb3Roc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG59XG5cbmZ1bmN0aW9uIHNtb290aGVyc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG59XG5cbi8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcbmZ1bmN0aW9uIHJhbmRJbnQoIGxvdywgaGlnaCApIHtcblxuXHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG59XG5cbi8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXQoIGxvdywgaGlnaCApIHtcblxuXHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG59XG5cbi8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcbmZ1bmN0aW9uIHJhbmRGbG9hdFNwcmVhZCggcmFuZ2UgKSB7XG5cblx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cbn1cblxuLy8gRGV0ZXJtaW5pc3RpYyBwc2V1ZG8tcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbIDAsIDEgXVxuZnVuY3Rpb24gc2VlZGVkUmFuZG9tKCBzICkge1xuXG5cdGlmICggcyAhPT0gdW5kZWZpbmVkICkgX3NlZWQgPSBzO1xuXG5cdC8vIE11bGJlcnJ5MzIgZ2VuZXJhdG9yXG5cblx0bGV0IHQgPSBfc2VlZCArPSAweDZEMkI3OUY1O1xuXG5cdHQgPSBNYXRoLmltdWwoIHQgXiB0ID4+PiAxNSwgdCB8IDEgKTtcblxuXHR0IF49IHQgKyBNYXRoLmltdWwoIHQgXiB0ID4+PiA3LCB0IHwgNjEgKTtcblxuXHRyZXR1cm4gKCAoIHQgXiB0ID4+PiAxNCApID4+PiAwICkgLyA0Mjk0OTY3Mjk2O1xuXG59XG5cbmZ1bmN0aW9uIGRlZ1RvUmFkKCBkZWdyZWVzICkge1xuXG5cdHJldHVybiBkZWdyZWVzICogREVHMlJBRDtcblxufVxuXG5mdW5jdGlvbiByYWRUb0RlZyggcmFkaWFucyApIHtcblxuXHRyZXR1cm4gcmFkaWFucyAqIFJBRDJERUc7XG5cbn1cblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxufVxuXG5mdW5jdGlvbiBjZWlsUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmNlaWwoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG59XG5cbmZ1bmN0aW9uIGZsb29yUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmZsb29yKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCBxLCBhLCBiLCBjLCBvcmRlciApIHtcblxuXHQvLyBJbnRyaW5zaWMgUHJvcGVyIEV1bGVyIEFuZ2xlcyAtIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcl9hbmdsZXNcblxuXHQvLyByb3RhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGF4ZXMgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBieSAnb3JkZXInXG5cdC8vIHJvdGF0aW9uIGJ5IGFuZ2xlICdhJyBpcyBhcHBsaWVkIGZpcnN0LCB0aGVuIGJ5IGFuZ2xlICdiJywgdGhlbiBieSBhbmdsZSAnYydcblx0Ly8gYW5nbGVzIGFyZSBpbiByYWRpYW5zXG5cblx0Y29uc3QgY29zID0gTWF0aC5jb3M7XG5cdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdGNvbnN0IGMyID0gY29zKCBiIC8gMiApO1xuXHRjb25zdCBzMiA9IHNpbiggYiAvIDIgKTtcblxuXHRjb25zdCBjMTMgPSBjb3MoICggYSArIGMgKSAvIDIgKTtcblx0Y29uc3QgczEzID0gc2luKCAoIGEgKyBjICkgLyAyICk7XG5cblx0Y29uc3QgYzFfMyA9IGNvcyggKCBhIC0gYyApIC8gMiApO1xuXHRjb25zdCBzMV8zID0gc2luKCAoIGEgLSBjICkgLyAyICk7XG5cblx0Y29uc3QgYzNfMSA9IGNvcyggKCBjIC0gYSApIC8gMiApO1xuXHRjb25zdCBzM18xID0gc2luKCAoIGMgLSBhICkgLyAyICk7XG5cblx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRjYXNlICdYWVgnOlxuXHRcdFx0cS5zZXQoIGMyICogczEzLCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWVpZJzpcblx0XHRcdHEuc2V0KCBzMiAqIHMxXzMsIGMyICogczEzLCBzMiAqIGMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1pYWic6XG5cdFx0XHRxLnNldCggczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogczEzLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdYWlgnOlxuXHRcdFx0cS5zZXQoIGMyICogczEzLCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWVhZJzpcblx0XHRcdHEuc2V0KCBzMiAqIGMzXzEsIGMyICogczEzLCBzMiAqIHMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1pZWic6XG5cdFx0XHRxLnNldCggczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogczEzLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBkZW5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZSAvIDQyOTQ5NjcyOTUuMDtcblxuXHRcdGNhc2UgVWludDE2QXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZSAvIDY1NTM1LjA7XG5cblx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZSAvIDI1NS4wO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHZhbHVlIC8gMjE0NzQ4MzY0Ny4wLCAtIDEuMCApO1xuXG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHZhbHVlIC8gMzI3NjcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHZhbHVlIC8gMTI3LjAsIC0gMS4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKCB2YWx1ZSwgYXJyYXkgKSB7XG5cblx0c3dpdGNoICggYXJyYXkuY29uc3RydWN0b3IgKSB7XG5cblx0XHRjYXNlIEZsb2F0MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0Y2FzZSBVaW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNDI5NDk2NzI5NS4wICk7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiA2NTUzNS4wICk7XG5cblx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDI1NS4wICk7XG5cblx0XHRjYXNlIEludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDIxNDc0ODM2NDcuMCApO1xuXG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAzMjc2Ny4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMTI3LjAgKTtcblxuXHRcdGRlZmF1bHQ6XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcG9uZW50IHR5cGUuJyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBNYXRoVXRpbHMgPSB7XG5cdERFRzJSQUQ6IERFRzJSQUQsXG5cdFJBRDJERUc6IFJBRDJERUcsXG5cdGdlbmVyYXRlVVVJRDogZ2VuZXJhdGVVVUlELFxuXHRjbGFtcDogY2xhbXAsXG5cdGV1Y2xpZGVhbk1vZHVsbzogZXVjbGlkZWFuTW9kdWxvLFxuXHRtYXBMaW5lYXI6IG1hcExpbmVhcixcblx0aW52ZXJzZUxlcnA6IGludmVyc2VMZXJwLFxuXHRsZXJwOiBsZXJwLFxuXHRkYW1wOiBkYW1wLFxuXHRwaW5ncG9uZzogcGluZ3BvbmcsXG5cdHNtb290aHN0ZXA6IHNtb290aHN0ZXAsXG5cdHNtb290aGVyc3RlcDogc21vb3RoZXJzdGVwLFxuXHRyYW5kSW50OiByYW5kSW50LFxuXHRyYW5kRmxvYXQ6IHJhbmRGbG9hdCxcblx0cmFuZEZsb2F0U3ByZWFkOiByYW5kRmxvYXRTcHJlYWQsXG5cdHNlZWRlZFJhbmRvbTogc2VlZGVkUmFuZG9tLFxuXHRkZWdUb1JhZDogZGVnVG9SYWQsXG5cdHJhZFRvRGVnOiByYWRUb0RlZyxcblx0aXNQb3dlck9mVHdvOiBpc1Bvd2VyT2ZUd28sXG5cdGNlaWxQb3dlck9mVHdvOiBjZWlsUG93ZXJPZlR3byxcblx0Zmxvb3JQb3dlck9mVHdvOiBmbG9vclBvd2VyT2ZUd28sXG5cdHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6IHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIsXG5cdG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuXHRkZW5vcm1hbGl6ZTogZGVub3JtYWxpemVcbn07XG5cbmV4cG9ydCB7XG5cdERFRzJSQUQsXG5cdFJBRDJERUcsXG5cdGdlbmVyYXRlVVVJRCxcblx0Y2xhbXAsXG5cdGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyLFxuXHRpbnZlcnNlTGVycCxcblx0bGVycCxcblx0ZGFtcCxcblx0cGluZ3BvbmcsXG5cdHNtb290aHN0ZXAsXG5cdHNtb290aGVyc3RlcCxcblx0cmFuZEludCxcblx0cmFuZEZsb2F0LFxuXHRyYW5kRmxvYXRTcHJlYWQsXG5cdHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQsXG5cdHJhZFRvRGVnLFxuXHRpc1Bvd2VyT2ZUd28sXG5cdGNlaWxQb3dlck9mVHdvLFxuXHRmbG9vclBvd2VyT2ZUd28sXG5cdHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIsXG5cdG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemUsXG5cdE1hdGhVdGlsc1xufTtcbiIsImNsYXNzIE1hdHJpeDMge1xuXG5cdGNvbnN0cnVjdG9yKCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xuXG5cdFx0TWF0cml4My5wcm90b3R5cGUuaXNNYXRyaXgzID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0XTtcblxuXHRcdGlmICggbjExICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc2V0KCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XG5cdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcblx0XHR0ZVsgNiBdID0gbjEzOyB0ZVsgNyBdID0gbjIzOyB0ZVsgOCBdID0gbjMzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlkZW50aXR5KCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07XG5cdFx0dGVbIDMgXSA9IG1lWyAzIF07IHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTtcblx0XHR0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07IHRlWyA4IF0gPSBtZVsgOCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDEgKTtcblx0XHR6QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdG1lWyAwIF0sIG1lWyA0IF0sIG1lWyA4IF0sXG5cdFx0XHRtZVsgMSBdLCBtZVsgNSBdLCBtZVsgOSBdLFxuXHRcdFx0bWVbIDIgXSwgbWVbIDYgXSwgbWVbIDEwIF1cblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseU1hdHJpY2VzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyAzIF0sIGIxMyA9IGJlWyA2IF07XG5cdFx0Y29uc3QgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNSBdLCBiMzMgPSBiZVsgOCBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcblx0XHR0ZVsgMyBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xuXHRcdHRlWyA2IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xuXHRcdHRlWyA0IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzI7XG5cdFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG5cdFx0dGVbIDUgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcblx0XHR0ZVsgOCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGV0ZXJtaW5hbnQoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuXHRcdFx0ZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sXG5cdFx0XHRuMTIgPSB0ZVsgMyBdLCBuMjIgPSB0ZVsgNCBdLCBuMzIgPSB0ZVsgNSBdLFxuXHRcdFx0bjEzID0gdGVbIDYgXSwgbjIzID0gdGVbIDcgXSwgbjMzID0gdGVbIDggXSxcblxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxuXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRsZXQgdG1wO1xuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xuXHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Tm9ybWFsTWF0cml4KCBtYXRyaXg0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQoIG1hdHJpeDQgKS5pbnZlcnQoKS50cmFuc3Bvc2UoKTtcblxuXHR9XG5cblx0dHJhbnNwb3NlSW50b0FycmF5KCByICkge1xuXG5cdFx0Y29uc3QgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRVdlRyYW5zZm9ybSggdHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCByb3RhdGlvbiApO1xuXG5cdFx0dGhpcy5zZXQoXG5cdFx0XHRzeCAqIGMsIHN4ICogcywgLSBzeCAqICggYyAqIGN4ICsgcyAqIGN5ICkgKyBjeCArIHR4LFxuXHRcdFx0LSBzeSAqIHMsIHN5ICogYywgLSBzeSAqICggLSBzICogY3ggKyBjICogY3kgKSArIGN5ICsgdHksXG5cdFx0XHQwLCAwLCAxXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvL1xuXG5cdHNjYWxlKCBzeCwgc3kgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVNjYWxlKCBzeCwgc3kgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZSggdGhldGEgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVJvdGF0aW9uKCAtIHRoZXRhICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIHR4LCB0eSApIHtcblxuXHRcdHRoaXMucHJlbXVsdGlwbHkoIF9tMy5tYWtlVHJhbnNsYXRpb24oIHR4LCB0eSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gZm9yIDJEIFRyYW5zZm9ybXNcblxuXHRtYWtlVHJhbnNsYXRpb24oIHgsIHkgKSB7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IyICkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCB4LngsXG5cdFx0XHRcdDAsIDEsIHgueSxcblx0XHRcdFx0MCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeCxcblx0XHRcdFx0MCwgMSwgeSxcblx0XHRcdFx0MCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbiggdGhldGEgKSB7XG5cblx0XHQvLyBjb3VudGVyY2xvY2t3aXNlXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCxcblx0XHRcdHMsIGMsIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VTY2FsZSggeCwgeSApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLFxuXHRcdFx0MCwgeSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF9tMyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKTtcblxuZXhwb3J0IHsgTWF0cml4MyB9O1xuIiwiaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtLCBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBNYXRyaXg0IHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG5cdGNvcHkoIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTsgdGVbIDMgXSA9IG1lWyAzIF07XG5cdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07IHRlWyAxMyBdID0gbWVbIDEzIF07IHRlWyAxNCBdID0gbWVbIDE0IF07IHRlWyAxNSBdID0gbWVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weVBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLCAwLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSwgMCxcblx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF0sIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXh0cmFjdFJvdGF0aW9uKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc2NhbGVZID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc2NhbGVaID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xuXHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0Y29uc3QgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuXHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0Y29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG5cdFx0XHR0ZVsgMSBdID0gZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcblx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fVxuXG5cdGxvb2tBdCggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0X3ouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcblxuXHRcdGlmICggX3oubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXG5cblx0XHRcdF96LnogPSAxO1xuXG5cdFx0fVxuXG5cdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0X3guY3Jvc3NWZWN0b3JzKCB1cCwgX3ogKTtcblxuXHRcdGlmICggX3gubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcblxuXHRcdFx0XHRfei54ICs9IDAuMDAwMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfei56ICs9IDAuMDAwMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHR9XG5cblx0XHRfeC5ub3JtYWxpemUoKTtcblx0XHRfeS5jcm9zc1ZlY3RvcnMoIF96LCBfeCApO1xuXG5cdFx0dGVbIDAgXSA9IF94Lng7IHRlWyA0IF0gPSBfeS54OyB0ZVsgOCBdID0gX3oueDtcblx0XHR0ZVsgMSBdID0gX3gueTsgdGVbIDUgXSA9IF95Lnk7IHRlWyA5IF0gPSBfei55O1xuXHRcdHRlWyAyIF0gPSBfeC56OyB0ZVsgNiBdID0gX3kuejsgdGVbIDEwIF0gPSBfei56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0Y29uc3QgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdGNvbnN0IGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdGNvbnN0IGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHRjb25zdCBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cblx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuXHRcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG5cdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0Y29uc3QgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0Y29uc3QgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0bjQxICogKFxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG5cdFx0XHQpICtcblx0XHRcdG40MiAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDMgKiAoXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQ0ICogKFxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG5cdFx0XHQpXG5cblx0XHQpO1xuXG5cdH1cblxuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRQb3NpdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRlWyAxMiBdID0geC54O1xuXHRcdFx0dGVbIDEzIF0gPSB4Lnk7XG5cdFx0XHR0ZVsgMTQgXSA9IHguejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRlWyAxMiBdID0geDtcblx0XHRcdHRlWyAxMyBdID0geTtcblx0XHRcdHRlWyAxNCBdID0gejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sIG40MSA9IHRlWyAzIF0sXG5cdFx0XHRuMTIgPSB0ZVsgNCBdLCBuMjIgPSB0ZVsgNSBdLCBuMzIgPSB0ZVsgNiBdLCBuNDIgPSB0ZVsgNyBdLFxuXHRcdFx0bjEzID0gdGVbIDggXSwgbjIzID0gdGVbIDkgXSwgbjMzID0gdGVbIDEwIF0sIG40MyA9IHRlWyAxMSBdLFxuXHRcdFx0bjE0ID0gdGVbIDEyIF0sIG4yNCA9IHRlWyAxMyBdLCBuMzQgPSB0ZVsgMTQgXSwgbjQ0ID0gdGVbIDE1IF0sXG5cblx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblxuXHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblxuXHRcdGlmICggZGV0ID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG5cdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XG5cdFx0dGVbIDUgXSA9ICggbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcblx0XHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggdiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9XG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCAwLCB4LnksXG5cdFx0XHRcdDAsIDAsIDEsIHgueixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblgoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIGMsIC0gcywgMCxcblx0XHRcdDAsIHMsIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblkoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblooIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgYywgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2hlYXIoIHh5LCB4eiwgeXgsIHl6LCB6eCwgenkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgeXgsIHp4LCAwLFxuXHRcdFx0eHksIDEsIHp5LCAwLFxuXHRcdFx0eHosIHl6LCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHRjb25zdCB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHRjb25zdCB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0Y29uc3Qgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XG5cblx0XHR0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xuXHRcdHRlWyAxIF0gPSAoIHh5ICsgd3ogKSAqIHN4O1xuXHRcdHRlWyAyIF0gPSAoIHh6IC0gd3kgKSAqIHN4O1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9ICggeHkgLSB3eiApICogc3k7XG5cdFx0dGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcblx0XHR0ZVsgNiBdID0gKCB5eiArIHd4ICkgKiBzeTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSAoIHh6ICsgd3kgKSAqIHN6O1xuXHRcdHRlWyA5IF0gPSAoIHl6IC0gd3ggKSAqIHN6O1xuXHRcdHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gcG9zaXRpb24ueDtcblx0XHR0ZVsgMTMgXSA9IHBvc2l0aW9uLnk7XG5cdFx0dGVbIDE0IF0gPSBwb3NpdGlvbi56O1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGxldCBzeCA9IF92MS5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IF92MS5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IF92MS5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xLmNvcHkoIHRoaXMgKTtcblxuXHRcdGNvbnN0IGludlNYID0gMSAvIHN4O1xuXHRcdGNvbnN0IGludlNZID0gMSAvIHN5O1xuXHRcdGNvbnN0IGludlNaID0gMSAvIHN6O1xuXG5cdFx0X20xLmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRfbTEuZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdF9tMS5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdHNjYWxlLnggPSBzeDtcblx0XHRzY2FsZS55ID0gc3k7XG5cdFx0c2NhbGUueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIsIGNvb3JkaW5hdGVTeXN0ZW0gPSBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG5cdFx0Y29uc3QgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGxldCBjLCBkO1xuXG5cdFx0aWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gKSB7XG5cblx0XHRcdGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0XHRkID0gKCAtIDIgKiBmYXIgKiBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XG5cblx0XHRcdGMgPSAtIGZhciAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSBmYXIgKiBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICcgKyBjb29yZGluYXRlU3lzdGVtICk7XG5cblx0XHR9XG5cblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7IFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjsgXHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYzsgXHR0ZVsgMTQgXSA9IGQ7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHcgPSAxLjAgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdGNvbnN0IHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdGNvbnN0IHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcblx0XHRjb25zdCB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XG5cblx0XHRsZXQgeiwgekludjtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHR6ID0gKCBmYXIgKyBuZWFyICkgKiBwO1xuXHRcdFx0ekludiA9IC0gMiAqIHA7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHR6ID0gbmVhciAqIHA7XG5cdFx0XHR6SW52ID0gLSAxICogcDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLk1hdHJpeDQubWFrZU9ydGhvZ3JhcGhpYygpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHRcdHRlWyA4IF0gPSAwOyBcdFx0dGVbIDEyIF0gPSAtIHg7XG5cdFx0dGVbIDEgXSA9IDA7IFx0XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDsgXHRcdHRlWyAxMyBdID0gLSB5O1xuXHRcdHRlWyAyIF0gPSAwOyBcdFx0dGVbIDYgXSA9IDA7XHRcdHRlWyAxMCBdID0gekludjtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdHRlWyAzIF0gPSAwOyBcdFx0dGVbIDcgXSA9IDA7XHRcdHRlWyAxMSBdID0gMDtcdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59XG5cbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF96ZXJvID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xuY29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcbmNvbnN0IF94ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3kgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZXhwb3J0IHsgTWF0cml4NCB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgUXVhdGVybmlvbiB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxICkge1xuXG5cdFx0dGhpcy5pc1F1YXRlcm5pb24gPSB0cnVlO1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0fVxuXG5cdHN0YXRpYyBzbGVycEZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0bGV0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcblxuXHRcdGNvbnN0IHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcblx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGlmICggdCA9PT0gMCApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHoxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xuXG5cdFx0XHRsZXQgcyA9IDEgLSB0O1xuXHRcdFx0Y29uc3QgY29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcblxuXHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xuXHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcblx0XHRcdGlmICggcyA9PT0gMSAtIHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcblxuXHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHR5MCAqPSBmO1xuXHRcdFx0XHR6MCAqPSBmO1xuXHRcdFx0XHR3MCAqPSBmO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cblx0fVxuXG5cdHN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdCggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEgKSB7XG5cblx0XHRjb25zdCB4MCA9IHNyYzBbIHNyY09mZnNldDAgXTtcblx0XHRjb25zdCB5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF07XG5cdFx0Y29uc3QgejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdO1xuXHRcdGNvbnN0IHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcblxuXHRcdGNvbnN0IHgxID0gc3JjMVsgc3JjT2Zmc2V0MSBdO1xuXHRcdGNvbnN0IHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXTtcblx0XHRjb25zdCB6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF07XG5cdFx0Y29uc3QgdzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwICogdzEgKyB3MCAqIHgxICsgeTAgKiB6MSAtIHowICogeTE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MCAqIHcxICsgdzAgKiB5MSArIHowICogeDEgLSB4MCAqIHoxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejAgKiB3MSArIHcwICogejEgKyB4MCAqIHkxIC0geTAgKiB4MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwICogdzEgLSB4MCAqIHgxIC0geTAgKiB5MSAtIHowICogejE7XG5cblx0XHRyZXR1cm4gZHN0O1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgdygpIHtcblxuXHRcdHJldHVybiB0aGlzLl93O1xuXG5cdH1cblxuXHRzZXQgdyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl93ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdH1cblxuXHRjb3B5KCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tRXVsZXIoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRcdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdFx0Y29uc3QgYzEgPSBjb3MoIHggLyAyICk7XG5cdFx0Y29uc3QgYzIgPSBjb3MoIHkgLyAyICk7XG5cdFx0Y29uc3QgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHRjb25zdCBzMSA9IHNpbiggeCAvIDIgKTtcblx0XHRjb25zdCBzMiA9IHNpbiggeSAvIDIgKTtcblx0XHRjb25zdCBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0Y29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG5cblx0XHRpZiAoIHRyYWNlID4gMCApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuXHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHRsZXQgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG5cdFx0aWYgKCByIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdC8vIHZGcm9tIGFuZCB2VG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuXG5cdFx0XHRyID0gMDtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gLSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl95ID0gdkZyb20ueDtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gLSB2RnJvbS56O1xuXHRcdFx0XHR0aGlzLl96ID0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApOyAvLyBpbmxpbmVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmN5IG9uIFZlY3RvcjNcblxuXHRcdFx0dGhpcy5feCA9IHZGcm9tLnkgKiB2VG8ueiAtIHZGcm9tLnogKiB2VG8ueTtcblx0XHRcdHRoaXMuX3kgPSB2RnJvbS56ICogdlRvLnggLSB2RnJvbS54ICogdlRvLno7XG5cdFx0XHR0aGlzLl96ID0gdkZyb20ueCAqIHZUby55IC0gdkZyb20ueSAqIHZUby54O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YW5nbGVUbyggcSApIHtcblxuXHRcdHJldHVybiAyICogTWF0aC5hY29zKCBNYXRoLmFicyggTWF0aFV0aWxzLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XG5cblx0fVxuXG5cdHJvdGF0ZVRvd2FyZHMoIHEsIHN0ZXAgKSB7XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYW5nbGVUbyggcSApO1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gMCApIHJldHVybiB0aGlzO1xuXG5cdFx0Y29uc3QgdCA9IE1hdGgubWluKCAxLCBzdGVwIC8gYW5nbGUgKTtcblxuXHRcdHRoaXMuc2xlcnAoIHEsIHQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG5cblx0fVxuXG5cdGNvbmp1Z2F0ZSgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fVxuXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdGxldCBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdGNvbnN0IHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0Y29uc3QgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnAoIHFiLCB0ICkge1xuXG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuXHRcdGxldCBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XG5cdFx0XHR0aGlzLl95ID0gLSBxYi5feTtcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xuXG5cdFx0aWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAxIC0gdDtcblx0XHRcdHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XG5cdFx0XHR0aGlzLl95ID0gcyAqIHkgKyB0ICogdGhpcy5feTtcblx0XHRcdHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggc3FyU2luSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcblx0XHRjb25zdCByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH1cblxuXHRyYW5kb20oKSB7XG5cblx0XHQvLyBEZXJpdmVkIGZyb20gaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuXHRcdC8vIE5vdGUsIHRoaXMgc291cmNlIHVzZXMgdywgeCwgeSwgeiBvcmRlcmluZyxcblx0XHQvLyBzbyB3ZSBzd2FwIHRoZSBvcmRlciBiZWxvdy5cblxuXHRcdGNvbnN0IHUxID0gTWF0aC5yYW5kb20oKTtcblx0XHRjb25zdCBzcXJ0MXUxID0gTWF0aC5zcXJ0KCAxIC0gdTEgKTtcblx0XHRjb25zdCBzcXJ0dTEgPSBNYXRoLnNxcnQoIHUxICk7XG5cblx0XHRjb25zdCB1MiA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblxuXHRcdGNvbnN0IHUzID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KFxuXHRcdFx0c3FydDF1MSAqIE1hdGguY29zKCB1MiApLFxuXHRcdFx0c3FydHUxICogTWF0aC5zaW4oIHUzICksXG5cdFx0XHRzcXJ0dTEgKiBNYXRoLmNvcyggdTMgKSxcblx0XHRcdHNxcnQxdTEgKiBNYXRoLnNpbiggdTIgKSxcblx0XHQpO1xuXG5cdH1cblxuXHRlcXVhbHMoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy5feCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMuX3kgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLl96ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cdFx0dGhpcy5fdyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdHJldHVybiB0aGlzLnRvQXJyYXkoKTtcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLl94O1xuXHRcdHlpZWxkIHRoaXMuX3k7XG5cdFx0eWllbGQgdGhpcy5fejtcblx0XHR5aWVsZCB0aGlzLl93O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBRdWF0ZXJuaW9uIH07XG4iLCJpbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi9Cb3gzLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBTcGhlcmUge1xuXG5cdGNvbnN0cnVjdG9yKCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpLCByYWRpdXMgPSAtIDEgKSB7XG5cblx0XHR0aGlzLmNlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHR9XG5cblx0c2V0KCBjZW50ZXIsIHJhZGl1cyApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cblx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfYm94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHR9XG5cblx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggc3BoZXJlICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpc0VtcHR5KCkge1xuXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPCAwICk7XG5cblx0fVxuXG5cdG1ha2VFbXB0eSgpIHtcblxuXHRcdHRoaXMuY2VudGVyLnNldCggMCwgMCwgMCApO1xuXHRcdHRoaXMucmFkaXVzID0gLSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRjb25zdCByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLmNlbnRlciApICkgPD0gdGhpcy5yYWRpdXM7XG5cblx0fVxuXG5cdGNsYW1wUG9pbnQoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHR0YXJnZXQuY29weSggcG9pbnQgKTtcblxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHR0YXJnZXQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldEJvdW5kaW5nQm94KCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHQvLyBFbXB0eSBzcGhlcmUgcHJvZHVjZXMgZW1wdHkgYm91bmRpbmcgYm94XG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG5cdFx0dGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlQb2ludCggcG9pbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHR0aGlzLmNlbnRlci5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHR0aGlzLnJhZGl1cyA9IDA7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0X3YxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLmNlbnRlciApO1xuXG5cdFx0Y29uc3QgbGVuZ3RoU3EgPSBfdjEubGVuZ3RoU3EoKTtcblxuXHRcdGlmICggbGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoIGxlbmd0aFNxICk7XG5cblx0XHRcdGNvbnN0IGRlbHRhID0gKCBsZW5ndGggLSB0aGlzLnJhZGl1cyApICogMC41O1xuXG5cdFx0XHR0aGlzLmNlbnRlci5hZGRTY2FsZWRWZWN0b3IoIF92MSwgZGVsdGEgLyBsZW5ndGggKTtcblxuXHRcdFx0dGhpcy5yYWRpdXMgKz0gZGVsdGE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dW5pb24oIHNwaGVyZSApIHtcblxuXHRcdGlmICggc3BoZXJlLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHNwaGVyZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jZW50ZXIuZXF1YWxzKCBzcGhlcmUuY2VudGVyICkgPT09IHRydWUgKSB7XG5cblx0XHRcdCB0aGlzLnJhZGl1cyA9IE1hdGgubWF4KCB0aGlzLnJhZGl1cywgc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X3YyLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMuY2VudGVyICkuc2V0TGVuZ3RoKCBzcGhlcmUucmFkaXVzICk7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3YxLmNvcHkoIHNwaGVyZS5jZW50ZXIgKS5hZGQoIF92MiApICk7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3YxLmNvcHkoIHNwaGVyZS5jZW50ZXIgKS5zdWIoIF92MiApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgU3BoZXJlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfdmFiID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhYyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YmMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmFwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZicCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92Y3AgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmxldCB3YXJuZWRHZXRVViA9IGZhbHNlO1xuXG5jbGFzcyBUcmlhbmdsZSB7XG5cblx0Y29uc3RydWN0b3IoIGEgPSBuZXcgVmVjdG9yMygpLCBiID0gbmV3IFZlY3RvcjMoKSwgYyA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHR0aGlzLmEgPSBhO1xuXHRcdHRoaXMuYiA9IGI7XG5cdFx0dGhpcy5jID0gYztcblxuXHR9XG5cblx0c3RhdGljIGdldE5vcm1hbCggYSwgYiwgYywgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0LnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRfdjAuc3ViVmVjdG9ycyggYSwgYiApO1xuXHRcdHRhcmdldC5jcm9zcyggX3YwICk7XG5cblx0XHRjb25zdCB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xuXHRcdGlmICggdGFyZ2V0TGVuZ3RoU3EgPiAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCB0YXJnZXRMZW5ndGhTcSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggMCwgMCwgMCApO1xuXG5cdH1cblxuXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXHRzdGF0aWMgZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgdGFyZ2V0ICkge1xuXG5cdFx0X3YwLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdF92Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG5cdFx0Y29uc3QgZG90MDAgPSBfdjAuZG90KCBfdjAgKTtcblx0XHRjb25zdCBkb3QwMSA9IF92MC5kb3QoIF92MSApO1xuXHRcdGNvbnN0IGRvdDAyID0gX3YwLmRvdCggX3YyICk7XG5cdFx0Y29uc3QgZG90MTEgPSBfdjEuZG90KCBfdjEgKTtcblx0XHRjb25zdCBkb3QxMiA9IF92MS5kb3QoIF92MiApO1xuXG5cdFx0Y29uc3QgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cblx0XHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcblx0XHRpZiAoIGRlbm9tID09PSAwICkge1xuXG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cblx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCAtIDIsIC0gMSwgLSAxICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHRjb25zdCB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG5cdFx0Y29uc3QgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG5cdFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XG5cblx0fVxuXG5cdHN0YXRpYyBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgX3YzICk7XG5cblx0XHRyZXR1cm4gKCBfdjMueCA+PSAwICkgJiYgKCBfdjMueSA+PSAwICkgJiYgKCAoIF92My54ICsgX3YzLnkgKSA8PSAxICk7XG5cblx0fVxuXG5cdHN0YXRpYyBnZXRVViggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMsIHRhcmdldCApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNTFcblxuXHRcdGlmICggd2FybmVkR2V0VVYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UcmlhbmdsZS5nZXRVVigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbigpLicgKTtcblxuXHRcdFx0d2FybmVkR2V0VVYgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRzdGF0aWMgZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHYxLCB2MiwgdjMsIHRhcmdldCApIHtcblxuXHRcdHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgcDEsIHAyLCBwMywgX3YzICk7XG5cblx0XHR0YXJnZXQuc2V0U2NhbGFyKCAwICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjEsIF92My54ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjIsIF92My55ICk7XG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjMsIF92My56ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRzdGF0aWMgaXNGcm9udEZhY2luZyggYSwgYiwgYywgZGlyZWN0aW9uICkge1xuXG5cdFx0X3YwLnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggYSwgYiApO1xuXG5cdFx0Ly8gc3RyaWN0bHkgZnJvbnQgZmFjaW5nXG5cdFx0cmV0dXJuICggX3YwLmNyb3NzKCBfdjEgKS5kb3QoIGRpcmVjdGlvbiApIDwgMCApID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdH1cblxuXHRzZXQoIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmEuY29weSggYSApO1xuXHRcdHRoaXMuYi5jb3B5KCBiICk7XG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlcyggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuXHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcblx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUF0dHJpYnV0ZUFuZEluZGljZXMoIGF0dHJpYnV0ZSwgaTAsIGkxLCBpMiApIHtcblxuXHRcdHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkwICk7XG5cdFx0dGhpcy5iLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTEgKTtcblx0XHR0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCB0cmlhbmdsZSApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcblx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEFyZWEoKSB7XG5cblx0XHRfdjAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuXHRcdHJldHVybiBfdjAuY3Jvc3MoIF92MSApLmxlbmd0aCgpICogMC41O1xuXG5cdH1cblxuXHRnZXRNaWRwb2ludCggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0fVxuXG5cdGdldE5vcm1hbCggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFBsYW5lKCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH1cblxuXHRnZXRCYXJ5Y29vcmQoIHBvaW50LCB0YXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0QmFyeWNvb3JkKCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGdldFVWKCBwb2ludCwgdXYxLCB1djIsIHV2MywgdGFyZ2V0ICkgeyAvLyBAZGVwcmVjYXRlZCwgcjE1MVxuXG5cdFx0aWYgKCB3YXJuZWRHZXRVViA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlRyaWFuZ2xlLmdldFVWKCkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5UcmlhbmdsZS5nZXRJbnRlcnBvbGF0aW9uKCkuJyApO1xuXG5cdFx0XHR3YXJuZWRHZXRVViA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHV2MSwgdXYyLCB1djMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB2MSwgdjIsIHYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0aXNGcm9udEZhY2luZyggZGlyZWN0aW9uICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmlzRnJvbnRGYWNpbmcoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIGRpcmVjdGlvbiApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jO1xuXHRcdGxldCB2LCB3O1xuXG5cdFx0Ly8gYWxnb3JpdGhtIHRoYW5rcyB0byBSZWFsLVRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiBieSBDaHJpc3RlciBFcmljc29uLFxuXHRcdC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcblx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cblx0XHQvLyBiYXNpY2FsbHksIHdlJ3JlIGRpc3Rpbmd1aXNoaW5nIHdoaWNoIG9mIHRoZSB2b3Jvbm9pIHJlZ2lvbnMgb2YgdGhlIHRyaWFuZ2xlXG5cdFx0Ly8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxuXG5cdFx0X3ZhYi5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0X3ZhYy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X3ZhcC5zdWJWZWN0b3JzKCBwLCBhICk7XG5cdFx0Y29uc3QgZDEgPSBfdmFiLmRvdCggX3ZhcCApO1xuXHRcdGNvbnN0IGQyID0gX3ZhYy5kb3QoIF92YXAgKTtcblx0XHRpZiAoIGQxIDw9IDAgJiYgZDIgPD0gMCApIHtcblxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKTtcblxuXHRcdH1cblxuXHRcdF92YnAuc3ViVmVjdG9ycyggcCwgYiApO1xuXHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoIF92YnAgKTtcblx0XHRjb25zdCBkNCA9IF92YWMuZG90KCBfdmJwICk7XG5cdFx0aWYgKCBkMyA+PSAwICYmIGQ0IDw9IGQzICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEI7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMSwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmMgPSBkMSAqIGQ0IC0gZDMgKiBkMjtcblx0XHRpZiAoIHZjIDw9IDAgJiYgZDEgPj0gMCAmJiBkMyA8PSAwICkge1xuXG5cdFx0XHR2ID0gZDEgLyAoIGQxIC0gZDMgKTtcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEFCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdiwgdiwgMClcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYiwgdiApO1xuXG5cdFx0fVxuXG5cdFx0X3ZjcC5zdWJWZWN0b3JzKCBwLCBjICk7XG5cdFx0Y29uc3QgZDUgPSBfdmFiLmRvdCggX3ZjcCApO1xuXHRcdGNvbnN0IGQ2ID0gX3ZhYy5kb3QoIF92Y3AgKTtcblx0XHRpZiAoIGQ2ID49IDAgJiYgZDUgPD0gZDYgKSB7XG5cblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBjICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YiA9IGQ1ICogZDIgLSBkMSAqIGQ2O1xuXHRcdGlmICggdmIgPD0gMCAmJiBkMiA+PSAwICYmIGQ2IDw9IDAgKSB7XG5cblx0XHRcdHcgPSBkMiAvICggZDIgLSBkNiApO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUM7IGJhcnljZW50cmljIGNvb3JkcyAoMS13LCAwLCB3KVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXHRcdGlmICggdmEgPD0gMCAmJiAoIGQ0IC0gZDMgKSA+PSAwICYmICggZDUgLSBkNiApID49IDAgKSB7XG5cblx0XHRcdF92YmMuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdFx0dyA9ICggZDQgLSBkMyApIC8gKCAoIGQ0IC0gZDMgKSArICggZDUgLSBkNiApICk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKS5hZGRTY2FsZWRWZWN0b3IoIF92YmMsIHcgKTsgLy8gZWRnZSByZWdpb24gb2YgQkNcblxuXHRcdH1cblxuXHRcdC8vIGZhY2UgcmVnaW9uXG5cdFx0Y29uc3QgZGVub20gPSAxIC8gKCB2YSArIHZiICsgdmMgKTtcblx0XHQvLyB1ID0gdmEgKiBkZW5vbVxuXHRcdHYgPSB2YiAqIGRlbm9tO1xuXHRcdHcgPSB2YyAqIGRlbm9tO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFiLCB2ICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XG5cblx0fVxuXG5cdGVxdWFscyggdHJpYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRyaWFuZ2xlIH07XG4iLCJpbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jbGFzcyBWZWN0b3IyIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwICkge1xuXG5cdFx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHR9XG5cblx0Z2V0IHdpZHRoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueDtcblxuXHR9XG5cblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMueCA9IHZhbHVlO1xuXG5cdH1cblxuXHRnZXQgaGVpZ2h0KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueTtcblxuXHR9XG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuXHR9XG5cblx0c2V0KCB4LCB5ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGQoIHYgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1pbiggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1heCggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgudHJ1bmMoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgudHJ1bmMoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG5lZ2F0ZSgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cblx0fVxuXG5cdGNyb3NzKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcblxuXHR9XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHR9XG5cblx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0YW5nbGUoKSB7XG5cblx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXG5cdFx0Y29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKCAtIHRoaXMueSwgLSB0aGlzLnggKSArIE1hdGguUEk7XG5cblx0XHRyZXR1cm4gYW5nbGU7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvU3F1YXJlZCggdiApIHtcblxuXHRcdGNvbnN0IGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApO1xuXG5cdH1cblxuXHRzZXRMZW5ndGgoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHR9XG5cblx0bGVycCggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdGF0ZUFyb3VuZCggY2VudGVyLCBhbmdsZSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggYW5nbGUgKSwgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuXHRcdGNvbnN0IHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcblxuXHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy54O1xuXHRcdHlpZWxkIHRoaXMueTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgVmVjdG9yMiB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuXG5jbGFzcyBWZWN0b3IzIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCApIHtcblxuXHRcdFZlY3RvcjMucHJvdG90eXBlLmlzVmVjdG9yMyA9IHRydWU7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6ICkge1xuXG5cdFx0aWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gdGhpcy56OyAvLyBzcHJpdGUuc2NhbGUuc2V0KHgseSlcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WiggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fVxuXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGQoIHYgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cdFx0dGhpcy56IC09IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5VmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuXHR9XG5cblx0YXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHRjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcblx0XHRjb25zdCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHRjb25zdCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHRjb25zdCBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdCggY2FtZXJhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdH1cblxuXHR1bnByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHR9XG5cblx0dHJhbnNmb3JtRGlyZWN0aW9uKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRkaXZpZGUoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdG1pbiggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1heCggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcExlbmd0aCggbWluLCBtYXggKSB7XG5cblx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0fVxuXG5cdGZsb29yKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VpbCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnRydW5jKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnRydW5jKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnRydW5jKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH1cblxuXHQvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHR9XG5cblx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjcm9zcyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdGhpcywgdiApO1xuXG5cdH1cblxuXHRjcm9zc1ZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdGNvbnN0IGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwcm9qZWN0T25WZWN0b3IoIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHYubGVuZ3RoU3EoKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IHNjYWxhciA9IHYuZG90KCB0aGlzICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHYgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0fVxuXG5cdHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdF92ZWN0b3IuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciApO1xuXG5cdH1cblxuXHRyZWZsZWN0KCBub3JtYWwgKSB7XG5cblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdH1cblxuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIE1hdGhVdGlscy5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWwoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9XG5cblx0c2V0RnJvbVNwaGVyaWNhbENvb3JkcyggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0Y29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHBoaSApICogcmFkaXVzO1xuXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jb3MoIHBoaSApICogcmFkaXVzO1xuXHRcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DeWxpbmRyaWNhbCggYyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggYy5yYWRpdXMsIGMudGhldGEsIGMueSApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIHJhZGl1cywgdGhldGEsIHkgKSB7XG5cblx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlKCBtICkge1xuXG5cdFx0Y29uc3Qgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXgzQ29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZSApIHtcblxuXHRcdHRoaXMueCA9IGUuX3g7XG5cdFx0dGhpcy55ID0gZS5feTtcblx0XHR0aGlzLnogPSBlLl96O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Db2xvciggYyApIHtcblxuXHRcdHRoaXMueCA9IGMucjtcblx0XHR0aGlzLnkgPSBjLmc7XG5cdFx0dGhpcy56ID0gYy5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tRGlyZWN0aW9uKCkge1xuXG5cdFx0Ly8gRGVyaXZlZCBmcm9tIGh0dHBzOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NwaGVyZVBvaW50UGlja2luZy5odG1sXG5cblx0XHRjb25zdCB1ID0gKCBNYXRoLnJhbmRvbSgpIC0gMC41ICkgKiAyO1xuXHRcdGNvbnN0IHQgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgZiA9IE1hdGguc3FydCggMSAtIHUgKiogMiApO1xuXG5cdFx0dGhpcy54ID0gZiAqIE1hdGguY29zKCB0ICk7XG5cdFx0dGhpcy55ID0gZiAqIE1hdGguc2luKCB0ICk7XG5cdFx0dGhpcy56ID0gdTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cdFx0eWllbGQgdGhpcy56O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmV4cG9ydCB7IFZlY3RvcjMgfTtcbiIsImZ1bmN0aW9uIGFycmF5TWluKCBhcnJheSApIHtcblxuXHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiBJbmZpbml0eTtcblxuXHRsZXQgbWluID0gYXJyYXlbIDAgXTtcblxuXHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xuXG5cdFx0aWYgKCBhcnJheVsgaSBdIDwgbWluICkgbWluID0gYXJyYXlbIGkgXTtcblxuXHR9XG5cblx0cmV0dXJuIG1pbjtcblxufVxuXG5mdW5jdGlvbiBhcnJheU1heCggYXJyYXkgKSB7XG5cblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gLSBJbmZpbml0eTtcblxuXHRsZXQgbWF4ID0gYXJyYXlbIDAgXTtcblxuXHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xuXG5cdFx0aWYgKCBhcnJheVsgaSBdID4gbWF4ICkgbWF4ID0gYXJyYXlbIGkgXTtcblxuXHR9XG5cblx0cmV0dXJuIG1heDtcblxufVxuXG5mdW5jdGlvbiBhcnJheU5lZWRzVWludDMyKCBhcnJheSApIHtcblxuXHQvLyBhc3N1bWVzIGxhcmdlciB2YWx1ZXMgdXN1YWxseSBvbiBsYXN0XG5cblx0Zm9yICggbGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IC0tIGkgKSB7XG5cblx0XHRpZiAoIGFycmF5WyBpIF0gPj0gNjU1MzUgKSByZXR1cm4gdHJ1ZTsgLy8gYWNjb3VudCBmb3IgUFJJTUlUSVZFX1JFU1RBUlRfRklYRURfSU5ERVgsICMyNDU2NVxuXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuY29uc3QgVFlQRURfQVJSQVlTID0ge1xuXHRJbnQ4QXJyYXk6IEludDhBcnJheSxcblx0VWludDhBcnJheTogVWludDhBcnJheSxcblx0VWludDhDbGFtcGVkQXJyYXk6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHRJbnQxNkFycmF5OiBJbnQxNkFycmF5LFxuXHRVaW50MTZBcnJheTogVWludDE2QXJyYXksXG5cdEludDMyQXJyYXk6IEludDMyQXJyYXksXG5cdFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcblx0RmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXG5cdEZsb2F0NjRBcnJheTogRmxvYXQ2NEFycmF5XG59O1xuXG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5KCB0eXBlLCBidWZmZXIgKSB7XG5cblx0cmV0dXJuIG5ldyBUWVBFRF9BUlJBWVNbIHR5cGUgXSggYnVmZmVyICk7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKCBuYW1lICkge1xuXG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgbmFtZSApO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSB7XG5cblx0Y29uc3QgY2FudmFzID0gY3JlYXRlRWxlbWVudE5TKCAnY2FudmFzJyApO1xuXHRjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdHJldHVybiBjYW52YXM7XG5cbn1cblxuY29uc3QgX2NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKCBtZXNzYWdlICkge1xuXG5cdGlmICggbWVzc2FnZSBpbiBfY2FjaGUgKSByZXR1cm47XG5cblx0X2NhY2hlWyBtZXNzYWdlIF0gPSB0cnVlO1xuXG5cdGNvbnNvbGUud2FybiggbWVzc2FnZSApO1xuXG59XG5cbmV4cG9ydCB7IGFycmF5TWluLCBhcnJheU1heCwgYXJyYXlOZWVkc1VpbnQzMiwgZ2V0VHlwZWRBcnJheSwgY3JlYXRlRWxlbWVudE5TLCBjcmVhdGVDYW52YXNFbGVtZW50LCB3YXJuT25jZSB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSB0cmlhbmd1bGF0ZUN1YmVcblxudmFyIHBlcm0gPSByZXF1aXJlKFwicGVybXV0YXRpb24tcmFua1wiKVxudmFyIHNnbiA9IHJlcXVpcmUoXCJwZXJtdXRhdGlvbi1wYXJpdHlcIilcbnZhciBnYW1tYSA9IHJlcXVpcmUoXCJnYW1tYVwiKVxuXG5mdW5jdGlvbiB0cmlhbmd1bGF0ZUN1YmUoZGltZW5zaW9uKSB7XG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICByZXR1cm4gWyBdXG4gIH1cbiAgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgcmV0dXJuIFsgWzBdIF1cbiAgfVxuICB2YXIgZGZhY3RvcmlhbCA9IE1hdGgucm91bmQoZ2FtbWEoZGltZW5zaW9uKzEpKXwwXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxkZmFjdG9yaWFsOyArK2kpIHtcbiAgICB2YXIgcCA9IHBlcm0udW5yYW5rKGRpbWVuc2lvbiwgaSlcbiAgICB2YXIgY2VsbCA9IFsgMCBdXG4gICAgdmFyIHYgPSAwXG4gICAgZm9yKHZhciBqPTA7IGo8cC5sZW5ndGg7ICsraikge1xuICAgICAgdiArPSAoMTw8cFtqXSlcbiAgICAgIGNlbGwucHVzaCh2KVxuICAgIH1cbiAgICBpZihzZ24ocCkgPCAxKSB7XG4gICAgICBjZWxsWzBdID0gdlxuICAgICAgY2VsbFtkaW1lbnNpb25dID0gMFxuICAgIH1cbiAgICByZXN1bHQucHVzaChjZWxsKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHR3b1Byb2R1Y3RcblxudmFyIFNQTElUVEVSID0gKyhNYXRoLnBvdygyLCAyNykgKyAxLjApXG5cbmZ1bmN0aW9uIHR3b1Byb2R1Y3QoYSwgYiwgcmVzdWx0KSB7XG4gIHZhciB4ID0gYSAqIGJcblxuICB2YXIgYyA9IFNQTElUVEVSICogYVxuICB2YXIgYWJpZyA9IGMgLSBhXG4gIHZhciBhaGkgPSBjIC0gYWJpZ1xuICB2YXIgYWxvID0gYSAtIGFoaVxuXG4gIHZhciBkID0gU1BMSVRURVIgKiBiXG4gIHZhciBiYmlnID0gZCAtIGJcbiAgdmFyIGJoaSA9IGQgLSBiYmlnXG4gIHZhciBibG8gPSBiIC0gYmhpXG5cbiAgdmFyIGVycjEgPSB4IC0gKGFoaSAqIGJoaSlcbiAgdmFyIGVycjIgPSBlcnIxIC0gKGFsbyAqIGJoaSlcbiAgdmFyIGVycjMgPSBlcnIyIC0gKGFoaSAqIGJsbylcblxuICB2YXIgeSA9IGFsbyAqIGJsbyAtIGVycjNcblxuICBpZihyZXN1bHQpIHtcbiAgICByZXN1bHRbMF0gPSB5XG4gICAgcmVzdWx0WzFdID0geFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHJldHVybiBbIHksIHggXVxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFR3b1N1bVxuXG5mdW5jdGlvbiBmYXN0VHdvU3VtKGEsIGIsIHJlc3VsdCkge1xuXHR2YXIgeCA9IGEgKyBiXG5cdHZhciBidiA9IHggLSBhXG5cdHZhciBhdiA9IHggLSBidlxuXHR2YXIgYnIgPSBiIC0gYnZcblx0dmFyIGFyID0gYSAtIGF2XG5cdGlmKHJlc3VsdCkge1xuXHRcdHJlc3VsdFswXSA9IGFyICsgYnJcblx0XHRyZXN1bHRbMV0gPSB4XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cdHJldHVybiBbYXIrYnIsIHhdXG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCSUdVSU5UNjQgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJJR0lOVDY0ICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgICAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgaGFzQmlnVWludDY0ID0gKHR5cGVvZiBCaWdVaW50NjRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgaGFzQmlnSW50NjQgPSAodHlwZW9mIEJpZ0ludDY0QXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQklHVUlOVDY0KSB7XG4gIFBPT0wuQklHVUlOVDY0ID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CSUdJTlQ2NCkge1xuICBQT09MLkJJR0lOVDY0ID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlQmlnVWludDY0ID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlQmlnSW50NjQgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYmlnaW50NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jQmlnSW50NjQobilcbiAgICAgIGNhc2UgJ2JpZ3VpbnQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NCaWdVaW50NjQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NCaWdVaW50NjQobikge1xuICBpZihoYXNCaWdVaW50NjQpIHtcbiAgICByZXR1cm4gbmV3IEJpZ1VpbnQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jQmlnVWludDY0ID0gbWFsbG9jQmlnVWludDY0XG5cbmZ1bmN0aW9uIG1hbGxvY0JpZ0ludDY0KG4pIHtcbiAgaWYgKGhhc0JpZ0ludDY0KSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jQmlnSW50NjQgPSBtYWxsb2NCaWdJbnQ2NFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkJJR1VJTlQ2NFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5CSUdJTlQ2NFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uRmluZDtcblxuZnVuY3Rpb24gVW5pb25GaW5kKGNvdW50KSB7XG4gIHRoaXMucm9vdHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICB0aGlzLnJhbmtzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgXG4gIGZvcih2YXIgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICB0aGlzLnJvb3RzW2ldID0gaTtcbiAgICB0aGlzLnJhbmtzW2ldID0gMDtcbiAgfVxufVxuXG52YXIgcHJvdG8gPSBVbmlvbkZpbmQucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJsZW5ndGhcIiwge1xuICBcImdldFwiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yb290cy5sZW5ndGhcbiAgfVxufSlcblxucHJvdG8ubWFrZVNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IHRoaXMucm9vdHMubGVuZ3RoO1xuICB0aGlzLnJvb3RzLnB1c2gobik7XG4gIHRoaXMucmFua3MucHVzaCgwKTtcbiAgcmV0dXJuIG47XG59XG5cbnByb3RvLmZpbmQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB4MCA9IHhcbiAgdmFyIHJvb3RzID0gdGhpcy5yb290cztcbiAgd2hpbGUocm9vdHNbeF0gIT09IHgpIHtcbiAgICB4ID0gcm9vdHNbeF1cbiAgfVxuICB3aGlsZShyb290c1t4MF0gIT09IHgpIHtcbiAgICB2YXIgeSA9IHJvb3RzW3gwXVxuICAgIHJvb3RzW3gwXSA9IHhcbiAgICB4MCA9IHlcbiAgfVxuICByZXR1cm4geDtcbn1cblxucHJvdG8ubGluayA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHhyID0gdGhpcy5maW5kKHgpXG4gICAgLCB5ciA9IHRoaXMuZmluZCh5KTtcbiAgaWYoeHIgPT09IHlyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByYW5rcyA9IHRoaXMucmFua3NcbiAgICAsIHJvb3RzID0gdGhpcy5yb290c1xuICAgICwgeGQgICAgPSByYW5rc1t4cl1cbiAgICAsIHlkICAgID0gcmFua3NbeXJdO1xuICBpZih4ZCA8IHlkKSB7XG4gICAgcm9vdHNbeHJdID0geXI7XG4gIH0gZWxzZSBpZih5ZCA8IHhkKSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gICAgKytyYW5rc1t4cl07XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRleHRcblxudmFyIHZlY3Rvcml6ZVRleHQgPSByZXF1aXJlKFwiLi9saWIvdnRleHRcIilcbnZhciBkZWZhdWx0Q2FudmFzID0gbnVsbFxudmFyIGRlZmF1bHRDb250ZXh0ID0gbnVsbFxuXG5pZih0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRlZmF1bHRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBkZWZhdWx0Q2FudmFzLndpZHRoID0gODE5MlxuICBkZWZhdWx0Q2FudmFzLmhlaWdodCA9IDEwMjRcbiAgZGVmYXVsdENvbnRleHQgPSBkZWZhdWx0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0KHN0ciwgb3B0aW9ucykge1xuICBpZigodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHx8IChvcHRpb25zID09PSBudWxsKSkge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIHJldHVybiB2ZWN0b3JpemVUZXh0KFxuICAgIHN0cixcbiAgICBvcHRpb25zLmNhbnZhcyB8fCBkZWZhdWx0Q2FudmFzLFxuICAgIG9wdGlvbnMuY29udGV4dCB8fCBkZWZhdWx0Q29udGV4dCxcbiAgICBvcHRpb25zKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB2ZWN0b3JpemVUZXh0XG5tb2R1bGUuZXhwb3J0cy5wcm9jZXNzUGl4ZWxzID0gcHJvY2Vzc1BpeGVsc1xuXG52YXIgc3VyZmFjZU5ldHMgPSByZXF1aXJlKCdzdXJmYWNlLW5ldHMnKVxudmFyIG5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5JylcbnZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJ3NpbXBsaWZ5LXBsYW5hci1ncmFwaCcpXG52YXIgY2xlYW5QU0xHID0gcmVxdWlyZSgnY2xlYW4tcHNsZycpXG52YXIgY2R0MmQgPSByZXF1aXJlKCdjZHQyZCcpXG52YXIgdG9Qb2x5Z29uQ3JhcHB5ID0gcmVxdWlyZSgncGxhbmFyLWdyYXBoLXRvLXBvbHlsaW5lJylcblxudmFyIFRBR19ib2xkID0gXCJiXCJcbnZhciBDSFJfYm9sZCA9ICdifCdcblxudmFyIFRBR19pdGFsaWMgPSBcImlcIlxudmFyIENIUl9pdGFsaWMgPSAnaXwnXG5cbnZhciBUQUdfc3VwZXIgPSBcInN1cFwiXG52YXIgQ0hSX3N1cGVyMCA9ICcrJ1xudmFyIENIUl9zdXBlciA9ICcrMSdcblxudmFyIFRBR19zdWIgPSBcInN1YlwiXG52YXIgQ0hSX3N1YjAgPSAnLSdcbnZhciBDSFJfc3ViID0gJy0xJ1xuXG5mdW5jdGlvbiBwYXJzZVRhZyh0YWcsIFRBR19DSFIsIHN0ciwgbWFwKSB7XG5cbiAgdmFyIG9wblRhZyA9ICBcIjxcIiAgKyB0YWcgKyBcIj5cIlxuICB2YXIgY2xzVGFnID0gIFwiPC9cIiArIHRhZyArIFwiPlwiXG5cbiAgdmFyIG5PUE4gPSBvcG5UYWcubGVuZ3RoXG4gIHZhciBuQ0xTID0gY2xzVGFnLmxlbmd0aFxuXG4gIHZhciBpc1JlY3Vyc2l2ZSA9IChUQUdfQ0hSWzBdID09PSBDSFJfc3VwZXIwKSB8fFxuICAgICAgICAgICAgICAgICAgICAoVEFHX0NIUlswXSA9PT0gQ0hSX3N1YjApO1xuXG4gIHZhciBhID0gMFxuICB2YXIgYiA9IC1uQ0xTXG4gIHdoaWxlIChhID4gLTEpIHtcbiAgICBhID0gc3RyLmluZGV4T2Yob3BuVGFnLCBhKVxuICAgIGlmKGEgPT09IC0xKSBicmVha1xuXG4gICAgYiA9IHN0ci5pbmRleE9mKGNsc1RhZywgYSArIG5PUE4pXG4gICAgaWYoYiA9PT0gLTEpIGJyZWFrXG5cbiAgICBpZihiIDw9IGEpIGJyZWFrXG5cbiAgICBmb3IodmFyIGkgPSBhOyBpIDwgYiArIG5DTFM7ICsraSl7XG4gICAgICBpZigoaSA8IGEgKyBuT1BOKSB8fCAoaSA+PSBiKSkge1xuICAgICAgICBtYXBbaV0gPSBudWxsXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgaSkgKyBcIiBcIiArIHN0ci5zdWJzdHIoaSArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihtYXBbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcG9zID0gbWFwW2ldLmluZGV4T2YoVEFHX0NIUlswXSlcbiAgICAgICAgICBpZihwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBtYXBbaV0gKz0gVEFHX0NIUlxuICAgICAgICAgIH0gZWxzZSB7IC8vIGkuZS4gdG8gaGFuZGxlIG11bHRpcGxlIHN1Yi9zdXBlci1zY3JpcHRzXG4gICAgICAgICAgICBpZihpc1JlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAvLyBpLmUgdG8gaW5jcmVhc2UgdGhlIHN1Yi9zdXAgbnVtYmVyXG4gICAgICAgICAgICAgIG1hcFtpXSA9IG1hcFtpXS5zdWJzdHIoMCwgcG9zICsgMSkgKyAoMSArIHBhcnNlSW50KG1hcFtpXVtwb3MgKyAxXSkpICsgbWFwW2ldLnN1YnN0cihwb3MgKyAyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGEgKyBuT1BOXG4gICAgdmFyIHJlbWFpbmluZ1N0ciA9IHN0ci5zdWJzdHIoc3RhcnQsIGIgLSBzdGFydClcblxuICAgIHZhciBjID0gcmVtYWluaW5nU3RyLmluZGV4T2Yob3BuVGFnKVxuICAgIGlmKGMgIT09IC0xKSBhID0gY1xuICAgIGVsc2UgYSA9IGIgKyBuQ0xTXG4gIH1cblxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvc2l0aW9ucyhwb3NpdGlvbnMsIG9wdGlvbnMsIHNpemUpIHtcbiAgdmFyIGFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ24gfHwgXCJzdGFydFwiXG4gIHZhciBiYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lIHx8IFwiYWxwaGFiZXRpY1wiXG5cbiAgdmFyIGxvID0gWzE8PDMwLCAxPDwzMF1cbiAgdmFyIGhpID0gWzAsMF1cbiAgdmFyIG4gPSBwb3NpdGlvbnMubGVuZ3RoXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBwID0gcG9zaXRpb25zW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8MjsgKytqKSB7XG4gICAgICBsb1tqXSA9IE1hdGgubWluKGxvW2pdLCBwW2pdKXwwXG4gICAgICBoaVtqXSA9IE1hdGgubWF4KGhpW2pdLCBwW2pdKXwwXG4gICAgfVxuICB9XG5cbiAgdmFyIHhTaGlmdCA9IDBcbiAgc3dpdGNoKGFsaWduKSB7XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgeFNoaWZ0ID0gLTAuNSAqIChsb1swXSArIGhpWzBdKVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICB4U2hpZnQgPSAtaGlbMF1cbiAgICBicmVha1xuXG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHhTaGlmdCA9IC1sb1swXVxuICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVjdG9yaXplLXRleHQ6IFVucmVjb2duaXplZCB0ZXh0QWxpZ246ICdcIiArIGFsaWduICsgXCInXCIpXG4gIH1cblxuICB2YXIgeVNoaWZ0ID0gMFxuICBzd2l0Y2goYmFzZWxpbmUpIHtcbiAgICBjYXNlIFwiaGFuZ2luZ1wiOlxuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIHlTaGlmdCA9IC1sb1sxXVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICB5U2hpZnQgPSAtMC41ICogKGxvWzFdICsgaGlbMV0pXG4gICAgYnJlYWtcblxuICAgIGNhc2UgXCJhbHBoYWJldGljXCI6XG4gICAgY2FzZSBcImlkZW9ncmFwaGljXCI6XG4gICAgICB5U2hpZnQgPSAtMyAqIHNpemVcbiAgICBicmVha1xuXG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgeVNoaWZ0ID0gLWhpWzFdXG4gICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZWN0b3JpemUtdGV4dDogVW5yZWNvZ2luaXplZCB0ZXh0QmFzZWxpbmU6ICdcIiArIGJhc2VsaW5lICsgXCInXCIpXG4gIH1cblxuICB2YXIgc2NhbGUgPSAxLjAgLyBzaXplXG4gIGlmKFwibGluZUhlaWdodFwiIGluIG9wdGlvbnMpIHtcbiAgICBzY2FsZSAqPSArb3B0aW9ucy5saW5lSGVpZ2h0XG4gIH0gZWxzZSBpZihcIndpZHRoXCIgaW4gb3B0aW9ucykge1xuICAgIHNjYWxlID0gb3B0aW9ucy53aWR0aCAvIChoaVswXSAtIGxvWzBdKVxuICB9IGVsc2UgaWYoXCJoZWlnaHRcIiBpbiBvcHRpb25zKSB7XG4gICAgc2NhbGUgPSBvcHRpb25zLmhlaWdodCAvIChoaVsxXSAtIGxvWzFdKVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBbIHNjYWxlICogKHBbMF0gKyB4U2hpZnQpLCBzY2FsZSAqIChwWzFdICsgeVNoaWZ0KSBdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldFBpeGVscyhjYW52YXMsIGNvbnRleHQsIHJhd1N0cmluZywgZm9udFNpemUsIGxpbmVTcGFjaW5nLCBzdHlsZXRhZ3MpIHtcblxuICByYXdTdHJpbmcgPSByYXdTdHJpbmcucmVwbGFjZSgvXFxuL2csICcnKSAvLyBkb24ndCBhY2NlcHQgXFxuIGluIHRoZSBpbnB1dFxuXG4gIGlmKHN0eWxldGFncy5icmVha2xpbmVzID09PSB0cnVlKSB7XG4gICAgcmF3U3RyaW5nID0gcmF3U3RyaW5nLnJlcGxhY2UoL1xcPGJyXFw+L2csICdcXG4nKSAvLyByZXBsYWNlIDxicj4gdGFncyB3aXRoIFxcbiBpbiB0aGUgc3RyaW5nXG4gIH0gZWxzZSB7XG4gICAgcmF3U3RyaW5nID0gcmF3U3RyaW5nLnJlcGxhY2UoL1xcPGJyXFw+L2csICcgJykgLy8gZG9uJ3QgYWNjZXB0IDxicj4gdGFncyBpbiB0aGUgaW5wdXQgYW5kIHJlcGxhY2Ugd2l0aCBzcGFjZSBpbiB0aGlzIGNhc2VcbiAgfVxuXG4gIHZhciBhY3RpdmVTdHlsZSA9IFwiXCJcbiAgdmFyIG1hcCA9IFtdXG4gIGZvcihqID0gMDsgaiA8IHJhd1N0cmluZy5sZW5ndGg7ICsraikge1xuICAgIG1hcFtqXSA9IGFjdGl2ZVN0eWxlXG4gIH1cblxuICBpZihzdHlsZXRhZ3MuYm9sZHMgPT09IHRydWUpIG1hcCA9IHBhcnNlVGFnKFRBR19ib2xkLCBDSFJfYm9sZCwgcmF3U3RyaW5nLCBtYXApXG4gIGlmKHN0eWxldGFncy5pdGFsaWNzID09PSB0cnVlKSBtYXAgPSBwYXJzZVRhZyhUQUdfaXRhbGljLCBDSFJfaXRhbGljLCByYXdTdHJpbmcsIG1hcClcbiAgaWYoc3R5bGV0YWdzLnN1cGVyc2NyaXB0cyA9PT0gdHJ1ZSkgbWFwID0gcGFyc2VUYWcoVEFHX3N1cGVyLCBDSFJfc3VwZXIsIHJhd1N0cmluZywgbWFwKVxuICBpZihzdHlsZXRhZ3Muc3Vic2NyaXB0cyA9PT0gdHJ1ZSkgbWFwID0gcGFyc2VUYWcoVEFHX3N1YiwgQ0hSX3N1YiwgcmF3U3RyaW5nLCBtYXApXG5cbiAgdmFyIGFsbFN0eWxlcyA9IFtdXG4gIHZhciBwbGFpblRleHQgPSBcIlwiXG4gIGZvcihqID0gMDsgaiA8IHJhd1N0cmluZy5sZW5ndGg7ICsraikge1xuICAgIGlmKG1hcFtqXSAhPT0gbnVsbCkge1xuICAgICAgcGxhaW5UZXh0ICs9IHJhd1N0cmluZ1tqXVxuICAgICAgYWxsU3R5bGVzLnB1c2gobWFwW2pdKVxuICAgIH1cbiAgfVxuXG4gIHZhciBhbGxUZXh0cyA9IHBsYWluVGV4dC5zcGxpdCgnXFxuJylcblxuICB2YXIgbnVtYmVyT2ZMaW5lcyA9IGFsbFRleHRzLmxlbmd0aFxuICB2YXIgbGluZUhlaWdodCA9IE1hdGgucm91bmQobGluZVNwYWNpbmcgKiBmb250U2l6ZSlcbiAgdmFyIG9mZnNldFggPSBmb250U2l6ZVxuICB2YXIgb2Zmc2V0WSA9IGZvbnRTaXplICogMlxuICB2YXIgbWF4V2lkdGggPSAwXG4gIHZhciBtaW5IZWlnaHQgPSBudW1iZXJPZkxpbmVzICogbGluZUhlaWdodCArIG9mZnNldFlcblxuICBpZihjYW52YXMuaGVpZ2h0IDwgbWluSGVpZ2h0KSB7XG4gICAgY2FudmFzLmhlaWdodCA9IG1pbkhlaWdodFxuICB9XG5cbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiMwMDBcIlxuICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZlwiXG4gIHZhciBpLCBqLCB4UG9zLCB5UG9zLCB6UG9zXG4gIHZhciBuRG9uZSA9IDBcblxuICB2YXIgYnVmZmVyID0gXCJcIlxuICBmdW5jdGlvbiB3cml0ZUJ1ZmZlcigpIHtcbiAgICBpZihidWZmZXIgIT09IFwiXCIpIHtcbiAgICAgIHZhciBkZWx0YSA9IGNvbnRleHQubWVhc3VyZVRleHQoYnVmZmVyKS53aWR0aFxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KGJ1ZmZlciwgb2Zmc2V0WCArIHhQb3MsIG9mZnNldFkgKyB5UG9zKVxuICAgICAgeFBvcyArPSBkZWx0YVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRleHRGb250U2l6ZSgpIHtcbiAgICByZXR1cm4gXCJcIiArIE1hdGgucm91bmQoelBvcykgKyBcInB4IFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlU3R5bGUob2xkU3R5bGUsIG5ld1N0eWxlKSB7XG4gICAgdmFyIGN0eEZvbnQgPSBcIlwiICsgY29udGV4dC5mb250O1xuXG4gICAgaWYoc3R5bGV0YWdzLnN1YnNjcmlwdHMgPT09IHRydWUpIHtcbiAgICAgIHZhciBvbGRJbmRleF9TdWIgPSBvbGRTdHlsZS5pbmRleE9mKENIUl9zdWIwKTtcbiAgICAgIHZhciBuZXdJbmRleF9TdWIgPSBuZXdTdHlsZS5pbmRleE9mKENIUl9zdWIwKTtcblxuICAgICAgdmFyIG9sZFN1YiA9IChvbGRJbmRleF9TdWIgPiAtMSkgPyBwYXJzZUludChvbGRTdHlsZVsxICsgb2xkSW5kZXhfU3ViXSkgOiAwO1xuICAgICAgdmFyIG5ld1N1YiA9IChuZXdJbmRleF9TdWIgPiAtMSkgPyBwYXJzZUludChuZXdTdHlsZVsxICsgbmV3SW5kZXhfU3ViXSkgOiAwO1xuXG4gICAgICBpZihvbGRTdWIgIT09IG5ld1N1Yikge1xuICAgICAgICBjdHhGb250ID0gY3R4Rm9udC5yZXBsYWNlKGdldFRleHRGb250U2l6ZSgpLCBcIj9weCBcIilcbiAgICAgICAgelBvcyAqPSBNYXRoLnBvdygwLjc1LCAobmV3U3ViIC0gb2xkU3ViKSlcbiAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShcIj9weCBcIiwgZ2V0VGV4dEZvbnRTaXplKCkpXG4gICAgICB9XG4gICAgICB5UG9zICs9IDAuMjUgKiBsaW5lSGVpZ2h0ICogKG5ld1N1YiAtIG9sZFN1Yik7XG4gICAgfVxuXG4gICAgaWYoc3R5bGV0YWdzLnN1cGVyc2NyaXB0cyA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIG9sZEluZGV4X1N1cGVyID0gb2xkU3R5bGUuaW5kZXhPZihDSFJfc3VwZXIwKTtcbiAgICAgIHZhciBuZXdJbmRleF9TdXBlciA9IG5ld1N0eWxlLmluZGV4T2YoQ0hSX3N1cGVyMCk7XG5cbiAgICAgIHZhciBvbGRTdXBlciA9IChvbGRJbmRleF9TdXBlciA+IC0xKSA/IHBhcnNlSW50KG9sZFN0eWxlWzEgKyBvbGRJbmRleF9TdXBlcl0pIDogMDtcbiAgICAgIHZhciBuZXdTdXBlciA9IChuZXdJbmRleF9TdXBlciA+IC0xKSA/IHBhcnNlSW50KG5ld1N0eWxlWzEgKyBuZXdJbmRleF9TdXBlcl0pIDogMDtcblxuICAgICAgaWYob2xkU3VwZXIgIT09IG5ld1N1cGVyKSB7XG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoZ2V0VGV4dEZvbnRTaXplKCksIFwiP3B4IFwiKVxuICAgICAgICB6UG9zICo9IE1hdGgucG93KDAuNzUsIChuZXdTdXBlciAtIG9sZFN1cGVyKSlcbiAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShcIj9weCBcIiwgZ2V0VGV4dEZvbnRTaXplKCkpXG4gICAgICB9XG4gICAgICB5UG9zIC09IDAuMjUgKiBsaW5lSGVpZ2h0ICogKG5ld1N1cGVyIC0gb2xkU3VwZXIpO1xuICAgIH1cblxuICAgIGlmKHN0eWxldGFncy5ib2xkcyA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHdhc0JvbGQgPSAob2xkU3R5bGUuaW5kZXhPZihDSFJfYm9sZCkgPiAtMSlcbiAgICAgIHZhciBpc19Cb2xkID0gKG5ld1N0eWxlLmluZGV4T2YoQ0hSX2JvbGQpID4gLTEpXG5cbiAgICAgIGlmKCF3YXNCb2xkICYmIGlzX0JvbGQpIHtcbiAgICAgICAgaWYod2FzSXRhbGljKSB7XG4gICAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShcIml0YWxpYyBcIiwgXCJpdGFsaWMgYm9sZCBcIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhGb250ID0gXCJib2xkIFwiICsgY3R4Rm9udFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih3YXNCb2xkICYmICFpc19Cb2xkKSB7XG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCJib2xkIFwiLCAnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHlsZXRhZ3MuaXRhbGljcyA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHdhc0l0YWxpYyA9IChvbGRTdHlsZS5pbmRleE9mKENIUl9pdGFsaWMpID4gLTEpXG4gICAgICB2YXIgaXNfSXRhbGljID0gKG5ld1N0eWxlLmluZGV4T2YoQ0hSX2l0YWxpYykgPiAtMSlcblxuICAgICAgaWYoIXdhc0l0YWxpYyAmJiBpc19JdGFsaWMpIHtcbiAgICAgICAgY3R4Rm9udCA9IFwiaXRhbGljIFwiICsgY3R4Rm9udFxuICAgICAgfVxuICAgICAgaWYod2FzSXRhbGljICYmICFpc19JdGFsaWMpIHtcbiAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShcIml0YWxpYyBcIiwgJycpXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQuZm9udCA9IGN0eEZvbnRcbiAgfVxuXG4gIGZvcihpID0gMDsgaSA8IG51bWJlck9mTGluZXM7ICsraSkge1xuICAgIHZhciB0eHQgPSBhbGxUZXh0c1tpXSArICdcXG4nXG4gICAgeFBvcyA9IDBcbiAgICB5UG9zID0gaSAqIGxpbmVIZWlnaHRcbiAgICB6UG9zID0gZm9udFNpemVcblxuICAgIGJ1ZmZlciA9IFwiXCJcbiAgICBcbiAgICBmb3IoaiA9IDA7IGogPCB0eHQubGVuZ3RoOyArK2opIHtcbiAgICAgIHZhciBzdHlsZSA9IChqICsgbkRvbmUgPCBhbGxTdHlsZXMubGVuZ3RoKSA/IGFsbFN0eWxlc1tqICsgbkRvbmVdIDogYWxsU3R5bGVzW2FsbFN0eWxlcy5sZW5ndGggLSAxXVxuICAgICAgaWYoYWN0aXZlU3R5bGUgPT09IHN0eWxlKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0eHRbal1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQnVmZmVyKClcbiAgICAgICAgYnVmZmVyID0gdHh0W2pdXG5cbiAgICAgICAgaWYoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoYW5nZVN0eWxlKGFjdGl2ZVN0eWxlLCBzdHlsZSlcbiAgICAgICAgICBhY3RpdmVTdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVCdWZmZXIoKVxuXG4gICAgbkRvbmUgKz0gdHh0Lmxlbmd0aFxuXG4gICAgdmFyIHdpZHRoID0gTWF0aC5yb3VuZCh4UG9zICsgMiAqIG9mZnNldFgpIHwgMFxuICAgIGlmKG1heFdpZHRoIDwgd2lkdGgpIG1heFdpZHRoID0gd2lkdGhcbiAgfVxuXG4gIC8vQ3V0IHBpeGVscyBmcm9tIGltYWdlXG4gIHZhciB4Q3V0ID0gbWF4V2lkdGhcbiAgdmFyIHlDdXQgPSBvZmZzZXRZICsgbGluZUhlaWdodCAqIG51bWJlck9mTGluZXNcbiAgdmFyIHBpeGVscyA9IG5kYXJyYXkoY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgeEN1dCwgeUN1dCkuZGF0YSwgW3lDdXQsIHhDdXQsIDRdKVxuICByZXR1cm4gcGl4ZWxzLnBpY2soLTEsIC0xLCAwKS50cmFuc3Bvc2UoMSwgMClcbn1cblxuZnVuY3Rpb24gZ2V0Q29udG91cihwaXhlbHMsIGRvU2ltcGxpZnkpIHtcbiAgdmFyIGNvbnRvdXIgPSBzdXJmYWNlTmV0cyhwaXhlbHMsIDEyOClcbiAgaWYoZG9TaW1wbGlmeSkge1xuICAgIHJldHVybiBzaW1wbGlmeShjb250b3VyLmNlbGxzLCBjb250b3VyLnBvc2l0aW9ucywgMC4yNSlcbiAgfVxuICByZXR1cm4ge1xuICAgIGVkZ2VzOiBjb250b3VyLmNlbGxzLFxuICAgIHBvc2l0aW9uczogY29udG91ci5wb3NpdGlvbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUGl4ZWxzSW1wbChwaXhlbHMsIG9wdGlvbnMsIHNpemUsIHNpbXBsaWZ5KSB7XG4gIC8vRXh0cmFjdCBjb250b3VyXG4gIHZhciBjb250b3VyID0gZ2V0Q29udG91cihwaXhlbHMsIHNpbXBsaWZ5KVxuXG4gIC8vQXBwbHkgd2FycCB0byBwb3NpdGlvbnNcbiAgdmFyIHBvc2l0aW9ucyA9IHRyYW5zZm9ybVBvc2l0aW9ucyhjb250b3VyLnBvc2l0aW9ucywgb3B0aW9ucywgc2l6ZSlcbiAgdmFyIGVkZ2VzICAgICA9IGNvbnRvdXIuZWRnZXNcbiAgdmFyIGZsaXAgPSBcImNjd1wiID09PSBvcHRpb25zLm9yaWVudGF0aW9uXG5cbiAgLy9DbGVhbiB1cCB0aGUgUFNMRywgcmVzb2x2ZSBzZWxmIGludGVyc2VjdGlvbnMsIGV0Yy5cbiAgY2xlYW5QU0xHKHBvc2l0aW9ucywgZWRnZXMpXG5cbiAgLy9JZiB0cmlhbmd1bGF0ZSBmbGFnIHBhc3NlZCwgdHJpYW5ndWxhdGUgdGhlIHJlc3VsdFxuICBpZihvcHRpb25zLnBvbHlnb25zIHx8IG9wdGlvbnMucG9seWdvbiB8fCBvcHRpb25zLnBvbHlsaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRvUG9seWdvbkNyYXBweShlZGdlcywgcG9zaXRpb25zKVxuICAgIHZhciBucmVzdWx0ID0gbmV3IEFycmF5KHJlc3VsdC5sZW5ndGgpXG4gICAgZm9yKHZhciBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbG9vcHMgPSByZXN1bHRbaV1cbiAgICAgIHZhciBubG9vcHMgPSBuZXcgQXJyYXkobG9vcHMubGVuZ3RoKVxuICAgICAgZm9yKHZhciBqPTA7IGo8bG9vcHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGxvb3AgPSBsb29wc1tqXVxuICAgICAgICB2YXIgbmxvb3AgPSBuZXcgQXJyYXkobG9vcC5sZW5ndGgpXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPGxvb3AubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICBubG9vcFtrXSA9IHBvc2l0aW9uc1tsb29wW2tdXS5zbGljZSgpXG4gICAgICAgIH1cbiAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgIG5sb29wLnJldmVyc2UoKVxuICAgICAgICB9XG4gICAgICAgIG5sb29wc1tqXSA9IG5sb29wXG4gICAgICB9XG4gICAgICBucmVzdWx0W2ldID0gbmxvb3BzXG4gICAgfVxuICAgIHJldHVybiBucmVzdWx0XG4gIH0gZWxzZSBpZihvcHRpb25zLnRyaWFuZ2xlcyB8fCBvcHRpb25zLnRyaWFuZ3VsYXRlIHx8IG9wdGlvbnMudHJpYW5nbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2VsbHM6IGNkdDJkKHBvc2l0aW9ucywgZWRnZXMsIHtcbiAgICAgICAgZGVsYXVuYXk6IGZhbHNlLFxuICAgICAgICBleHRlcmlvcjogZmFsc2UsXG4gICAgICAgIGludGVyaW9yOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBlZGdlczogICAgIGVkZ2VzLFxuICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1BpeGVscyhwaXhlbHMsIG9wdGlvbnMsIHNpemUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzc1BpeGVsc0ltcGwocGl4ZWxzLCBvcHRpb25zLCBzaXplLCB0cnVlKVxuICB9IGNhdGNoKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3NQaXhlbHNJbXBsKHBpeGVscywgb3B0aW9ucywgc2l6ZSwgZmFsc2UpXG4gIH0gY2F0Y2goZSkge31cbiAgaWYob3B0aW9ucy5wb2x5Z29ucyB8fCBvcHRpb25zLnBvbHlsaW5lIHx8IG9wdGlvbnMucG9seWdvbikge1xuICAgIHJldHVybiBbXVxuICB9XG4gIGlmKG9wdGlvbnMudHJpYW5nbGVzIHx8IG9wdGlvbnMudHJpYW5ndWxhdGUgfHwgb3B0aW9ucy50cmlhbmdsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjZWxsczogW10sXG4gICAgICBwb3NpdGlvbnM6IFtdXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZWRnZXM6IFtdLFxuICAgIHBvc2l0aW9uczogW11cbiAgfVxufVxuXG5mdW5jdGlvbiB2ZWN0b3JpemVUZXh0KHN0ciwgY2FudmFzLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBzaXplID0gNjRcbiAgdmFyIGxpbmVTcGFjaW5nID0gMS4yNVxuICB2YXIgc3R5bGV0YWdzID0ge1xuICAgIGJyZWFrbGluZXM6IGZhbHNlLFxuICAgIGJvbGRzOiBmYWxzZSxcbiAgICBpdGFsaWNzOiBmYWxzZSxcbiAgICBzdWJzY3JpcHRzOiBmYWxzZSxcbiAgICBzdXBlcnNjcmlwdHM6IGZhbHNlXG4gIH1cblxuICBpZihvcHRpb25zKSB7XG5cbiAgICBpZihvcHRpb25zLnNpemUgJiZcbiAgICAgICBvcHRpb25zLnNpemUgPiAwKSBzaXplID1cbiAgICAgICBvcHRpb25zLnNpemVcblxuICAgIGlmKG9wdGlvbnMubGluZVNwYWNpbmcgJiZcbiAgICAgICBvcHRpb25zLmxpbmVTcGFjaW5nID4gMCkgbGluZVNwYWNpbmcgPVxuICAgICAgIG9wdGlvbnMubGluZVNwYWNpbmdcblxuICAgIGlmKG9wdGlvbnMuc3R5bGV0YWdzICYmXG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3MuYnJlYWtsaW5lcykgc3R5bGV0YWdzLmJyZWFrbGluZXMgPVxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJyZWFrbGluZXMgPyB0cnVlIDogZmFsc2VcblxuICAgIGlmKG9wdGlvbnMuc3R5bGV0YWdzICYmXG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3MuYm9sZHMpIHN0eWxldGFncy5ib2xkcyA9XG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3MuYm9sZHMgPyB0cnVlIDogZmFsc2VcblxuICAgIGlmKG9wdGlvbnMuc3R5bGV0YWdzICYmXG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3MuaXRhbGljcykgc3R5bGV0YWdzLml0YWxpY3MgPVxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLml0YWxpY3MgPyB0cnVlIDogZmFsc2VcblxuICAgIGlmKG9wdGlvbnMuc3R5bGV0YWdzICYmXG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3Muc3Vic2NyaXB0cykgc3R5bGV0YWdzLnN1YnNjcmlwdHMgPVxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLnN1YnNjcmlwdHMgPyB0cnVlIDogZmFsc2VcblxuICAgIGlmKG9wdGlvbnMuc3R5bGV0YWdzICYmXG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3Muc3VwZXJzY3JpcHRzKSBzdHlsZXRhZ3Muc3VwZXJzY3JpcHRzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5zdXBlcnNjcmlwdHMgPyB0cnVlIDogZmFsc2VcbiAgfVxuXG4gIGNvbnRleHQuZm9udCA9IFtcbiAgICBvcHRpb25zLmZvbnRTdHlsZSxcbiAgICBvcHRpb25zLmZvbnRWYXJpYW50LFxuICAgIG9wdGlvbnMuZm9udFdlaWdodCxcbiAgICBzaXplICsgXCJweFwiLFxuICAgIG9wdGlvbnMuZm9udFxuICBdLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGR9KS5qb2luKFwiIFwiKVxuICBjb250ZXh0LnRleHRBbGlnbiA9IFwic3RhcnRcIlxuICBjb250ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiXG4gIGNvbnRleHQuZGlyZWN0aW9uID0gXCJsdHJcIlxuXG4gIHZhciBwaXhlbHMgPSBnZXRQaXhlbHMoY2FudmFzLCBjb250ZXh0LCBzdHIsIHNpemUsIGxpbmVTcGFjaW5nLCBzdHlsZXRhZ3MpXG5cbiAgcmV0dXJuIHByb2Nlc3NQaXhlbHMocGl4ZWxzLCBvcHRpb25zLCBzaXplKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdjd2lzZS1jb21waWxlcicpKHtcbiAgICBhcmdzOiBbJ2FycmF5Jywge1xuICAgICAgICBvZmZzZXQ6IFsxXSxcbiAgICAgICAgYXJyYXk6IDBcbiAgICB9LCAnc2NhbGFyJywgJ3NjYWxhcicsICdpbmRleCddLFxuICAgIHByZToge1xuICAgICAgICBcImJvZHlcIjogXCJ7fVwiLFxuICAgICAgICBcImFyZ3NcIjogW10sXG4gICAgICAgIFwidGhpc1ZhcnNcIjogW10sXG4gICAgICAgIFwibG9jYWxWYXJzXCI6IFtdXG4gICAgfSxcbiAgICBwb3N0OiB7XG4gICAgICAgIFwiYm9keVwiOiBcInt9XCIsXG4gICAgICAgIFwiYXJnc1wiOiBbXSxcbiAgICAgICAgXCJ0aGlzVmFyc1wiOiBbXSxcbiAgICAgICAgXCJsb2NhbFZhcnNcIjogW11cbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgICAgXCJib2R5XCI6IFwie1xcbiAgICAgICAgdmFyIF9pbmxpbmVfMV9kYSA9IF9pbmxpbmVfMV9hcmcwXyAtIF9pbmxpbmVfMV9hcmczX1xcbiAgICAgICAgdmFyIF9pbmxpbmVfMV9kYiA9IF9pbmxpbmVfMV9hcmcxXyAtIF9pbmxpbmVfMV9hcmczX1xcbiAgICAgICAgaWYoKF9pbmxpbmVfMV9kYSA+PSAwKSAhPT0gKF9pbmxpbmVfMV9kYiA+PSAwKSkge1xcbiAgICAgICAgICBfaW5saW5lXzFfYXJnMl8ucHVzaChfaW5saW5lXzFfYXJnNF9bMF0gKyAwLjUgKyAwLjUgKiAoX2lubGluZV8xX2RhICsgX2lubGluZV8xX2RiKSAvIChfaW5saW5lXzFfZGEgLSBfaW5saW5lXzFfZGIpKVxcbiAgICAgICAgfVxcbiAgICAgIH1cIixcbiAgICAgICAgXCJhcmdzXCI6IFt7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJfaW5saW5lXzFfYXJnMF9cIixcbiAgICAgICAgICAgIFwibHZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJydmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY291bnRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJfaW5saW5lXzFfYXJnMV9cIixcbiAgICAgICAgICAgIFwibHZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJydmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY291bnRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJfaW5saW5lXzFfYXJnMl9cIixcbiAgICAgICAgICAgIFwibHZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJydmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY291bnRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJfaW5saW5lXzFfYXJnM19cIixcbiAgICAgICAgICAgIFwibHZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJydmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY291bnRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJfaW5saW5lXzFfYXJnNF9cIixcbiAgICAgICAgICAgIFwibHZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJydmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY291bnRcIjogMVxuICAgICAgICB9XSxcbiAgICAgICAgXCJ0aGlzVmFyc1wiOiBbXSxcbiAgICAgICAgXCJsb2NhbFZhcnNcIjogW1wiX2lubGluZV8xX2RhXCIsIFwiX2lubGluZV8xX2RiXCJdXG4gICAgfSxcbiAgICBmdW5jTmFtZTogJ3plcm9Dcm9zc2luZ3MnXG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kWmVyb0Nyb3NzaW5nc1xuXG52YXIgY29yZSA9IHJlcXVpcmUoXCIuL2xpYi96Yy1jb3JlXCIpXG5cbmZ1bmN0aW9uIGZpbmRaZXJvQ3Jvc3NpbmdzKGFycmF5LCBsZXZlbCkge1xuICB2YXIgY3Jvc3MgPSBbXVxuICBsZXZlbCA9ICtsZXZlbCB8fCAwLjBcbiAgY29yZShhcnJheS5oaShhcnJheS5zaGFwZVswXS0xKSwgY3Jvc3MsIGxldmVsKVxuICByZXR1cm4gY3Jvc3Ncbn0iLCIvLyBoYW5kbGVzIGNvZGUgZXZhbHVhdGlvbiBhbmQgYXR0YWNoaW5nIHJlbGV2YW50IG9iamVjdHMgdG8gZ2xvYmFsIGFuZCBldmFsdWF0aW9uIGNvbnRleHRzXG5cbmltcG9ydCBTYW5kYm94IGZyb20gJy4vbGliL3NhbmRib3guanMnXG5pbXBvcnQgQXJyYXlVdGlscyBmcm9tICcuL2xpYi9hcnJheS11dGlscy5qcydcblxuY2xhc3MgRXZhbFNhbmRib3gge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG1ha2VHbG9iYWwsIHVzZXJQcm9wcyA9IFtdKSB7XG4gICAgdGhpcy5tYWtlR2xvYmFsID0gbWFrZUdsb2JhbFxuICAgIHRoaXMuc2FuZGJveCA9IFNhbmRib3gocGFyZW50KVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG4gICAgdmFyIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhwYXJlbnQpXG4gICAgcHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4gdGhpcy5hZGQocHJvcGVydHkpKVxuICAgIHRoaXMudXNlclByb3BzID0gdXNlclByb3BzXG4gIH1cblxuICBhZGQobmFtZSkge1xuICAgIGlmKHRoaXMubWFrZUdsb2JhbCkgd2luZG93W25hbWVdID0gdGhpcy5wYXJlbnRbbmFtZV1cbiAgICAvLyB0aGlzLnNhbmRib3guYWRkVG9Db250ZXh0KG5hbWUsIGBwYXJlbnQuJHtuYW1lfWApXG4gIH1cblxuLy8gc2V0cyBvbiB3aW5kb3cgYXMgd2VsbCBhcyBzeW50aCBvYmplY3QgaWYgZ2xvYmFsIChub3QgbmVlZGVkIGZvciBvYmplY3RzLCB3aGljaCBjYW4gYmUgc2V0IGRpcmVjdGx5KVxuXG4gIHNldChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBpZih0aGlzLm1ha2VHbG9iYWwpIHtcbiAgICAgIHdpbmRvd1twcm9wZXJ0eV0gPSB2YWx1ZVxuICAgIH1cbiAgICB0aGlzLnBhcmVudFtwcm9wZXJ0eV0gPSB2YWx1ZVxuICB9XG5cbiAgdGljaygpIHtcbiAgICBpZih0aGlzLm1ha2VHbG9iYWwpIHtcbiAgICAgIHRoaXMudXNlclByb3BzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHRoaXMucGFyZW50W3Byb3BlcnR5XSA9IHdpbmRvd1twcm9wZXJ0eV1cbiAgICAgIH0pXG4gICAgICAvLyAgdGhpcy5wYXJlbnQuc3BlZWQgPSB3aW5kb3cuc3BlZWRcbiAgICB9IGVsc2Uge1xuXG4gICAgfVxuICB9XG5cbiAgZXZhbChjb2RlKSB7XG4gICAgdGhpcy5zYW5kYm94LmV2YWwoY29kZSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmFsU2FuZGJveFxuIiwiaW1wb3J0IGFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG5pbXBvcnQge2dldExvb2t1cH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblxuLy8gW1dJUF0gaG93IHRvIHRyZWF0IGRpZmZlcmVudCBkaW1lbnNpb25zICg/KVxuY29uc3QgREVGQVVMVF9DT05WRVJTSU9OUyA9IHtcbiAgZmxvYXQ6IHtcbiAgICAndmVjNCc6IHsgbmFtZTogJ3N1bScsIGFyZ3M6IFtbMSwgMSwgMSwgMV1dIH0sXG4gICAgJ3ZlYzInOiB7IG5hbWU6ICdzdW0nLCBhcmdzOiBbWzEsIDFdXSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsbEFycmF5V2l0aERlZmF1bHRzKGFyciwgbGVuKSB7XG4gIC8vIGZpbGwgdGhlIGFycmF5IHdpdGggZGVmYXVsdCB2YWx1ZXMgaWYgaXQncyB0b28gc2hvcnRcbiAgd2hpbGUgKGFyci5sZW5ndGggPCBsZW4pIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMykgeyAvLyBwdXNoIGEgMSBhcyB0aGUgZGVmYXVsdCBmb3IgLmEgaW4gdmVjNFxuICAgICAgYXJyLnB1c2goMS4wKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnIucHVzaCgwLjApXG4gICAgfVxuICB9XG4gIHJldHVybiBhcnIuc2xpY2UoMCwgbGVuKVxufVxuXG5jb25zdCBlbnN1cmVfZGVjaW1hbF9kb3QgPSAodmFsKSA9PiB7XG4gIHZhbCA9IHZhbC50b1N0cmluZygpXG4gIGlmICh2YWwuaW5kZXhPZignLicpIDwgMCkge1xuICAgIHZhbCArPSAnLidcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRBcmd1bWVudHModHJhbnNmb3JtLCBzdGFydEluZGV4LCBzeW50aENvbnRleHQpIHtcbiAgY29uc3QgZGVmYXVsdEFyZ3MgPSB0cmFuc2Zvcm0udHJhbnNmb3JtLmlucHV0c1xuICBjb25zdCB1c2VyQXJncyA9IHRyYW5zZm9ybS51c2VyQXJnc1xuICBjb25zdCB7IGdlbmVyYXRvcnMgfSA9IHRyYW5zZm9ybS5zeW50aFxuICBjb25zdCB7IHNyYyB9ID0gZ2VuZXJhdG9ycyAvLyBkZXBlbmRzIG9uIHN5bnRoIGhhdmluZyBzcmMoKSBmdW5jdGlvblxuICByZXR1cm4gZGVmYXVsdEFyZ3MubWFwKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB0eXBlZEFyZyA9IHtcbiAgICAgIHZhbHVlOiBpbnB1dC5kZWZhdWx0LFxuICAgICAgdHlwZTogaW5wdXQudHlwZSwgLy9cbiAgICAgIGlzVW5pZm9ybTogZmFsc2UsXG4gICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgdmVjTGVuOiAwXG4gICAgICAvLyAgZ2VuZXJhdGVHbHNsOiBudWxsIC8vIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBnbHNsXG4gICAgfVxuXG4gICAgaWYgKHR5cGVkQXJnLnR5cGUgPT09ICdmbG9hdCcpIHR5cGVkQXJnLnZhbHVlID0gZW5zdXJlX2RlY2ltYWxfZG90KGlucHV0LmRlZmF1bHQpXG4gICAgaWYgKGlucHV0LnR5cGUuc3RhcnRzV2l0aCgndmVjJykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR5cGVkQXJnLnZlY0xlbiA9IE51bWJlci5wYXJzZUludChpbnB1dC50eXBlLnN1YnN0cigzKSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEVycm9yIGRldGVybWluaW5nIGxlbmd0aCBvZiB2ZWN0b3IgaW5wdXQgdHlwZSAke2lucHV0LnR5cGV9ICgke2lucHV0Lm5hbWV9KWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdXNlciBoYXMgaW5wdXQgc29tZXRoaW5nIGZvciB0aGlzIGFyZ3VtZW50XG4gICAgaWYgKHVzZXJBcmdzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB0eXBlZEFyZy52YWx1ZSA9IHVzZXJBcmdzW2luZGV4XTtcbiAgICAgIGlmICh0eXBlb2YgdHlwZWRBcmcudmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdHlwZWRBcmcudmFsdWUubmFtZSAhPT0gJ3JlZ2xUZXh0dXJlMkQnICYmIHR5cGVkQXJnLnZhbHVlLm5hbWUgIT09ICdyZWdsRnJhbWVidWZmZXInKSB7XG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0eXBlZEFyZy52YWx1ZSwgaW5wdXQpO1xuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHR5cGVkQXJnLnZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IGdldEFycmF5VmFsdWUodHlwZWRBcmcudmFsdWUsIGlucHV0LCB0eXBlZEFyZy52ZWNMZW4pXG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IHRydWVcbiAgICAgICAgLy8gfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZWRBcmcudmFsdWUgJiYgdHlwZWRBcmcudmFsdWUudHJhbnNmb3Jtcykge1xuICAgICAgICBjb25zdCBmaW5hbF90cmFuc2Zvcm0gPSB0eXBlZEFyZy52YWx1ZS50cmFuc2Zvcm1zW3R5cGVkQXJnLnZhbHVlLnRyYW5zZm9ybXMubGVuZ3RoIC0gMV1cblxuICAgICAgICBpZiAoZmluYWxfdHJhbnNmb3JtLnRyYW5zZm9ybS5nbHNsX3JldHVybl90eXBlICE9PSBpbnB1dC50eXBlKSB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdHMgPSBERUZBVUxUX0NPTlZFUlNJT05TW2lucHV0LnR5cGVdXG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRfZGVmID0gZGVmYXVsdHNbZmluYWxfdHJhbnNmb3JtLnRyYW5zZm9ybS5nbHNsX3JldHVybl90eXBlXVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0X2RlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBhcmdzIH0gPSBkZWZhdWx0X2RlZlxuICAgICAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IHR5cGVkQXJnLnZhbHVlW25hbWVdKC4uLmFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAodHlwZWRBcmcudHlwZSA9PT0gJ2Zsb2F0JyAmJiB0eXBlb2YgdHlwZWRBcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0gZW5zdXJlX2RlY2ltYWxfZG90KHR5cGVkQXJnLnZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlZEFyZy50eXBlLnN0YXJ0c1dpdGgoJ3ZlYycpICYmIHR5cGVvZiB0eXBlZEFyZy52YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZWRBcmcudmFsdWUuZ2V0VGV4dHVyZSkge1xuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSBmYWxzZVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlZEFyZy52YWx1ZSkgfHwgdHlwZWRBcmcudmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgdHlwZWRBcmcudmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgLy8gdG9kbzogYWNjZXB0IHNtYWxsZXIgYXJyYXlzP1xuICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gYCR7dHlwZWRBcmcudHlwZX0oJHt0eXBlZEFyZy52YWx1ZS5tYXAoZW5zdXJlX2RlY2ltYWxfZG90KS5qb2luKCcsICcpfSlgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHR5cGVkQXJnLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHR5cGVkQXJnLnR5cGUuc3Vic3RyKC0xKSk7XG4gICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkobGVuZ3RoKS5maWxsKHR5cGVkQXJnLnZhbHVlKTtcbiAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IGAke3R5cGVkQXJnLnR5cGV9KCR7YXJyLm1hcChlbnN1cmVfZGVjaW1hbF9kb3QpLmpvaW4oJywgJyl9KWBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnB1dC50eXBlID09PSAnc2FtcGxlcjJEJykge1xuICAgICAgICAvLyB0eXBlZEFyZy50ZXggPSB0eXBlZEFyZy52YWx1ZVxuICAgICAgICB2YXIgeCA9IHR5cGVkQXJnLnZhbHVlXG4gICAgICAgIHR5cGVkQXJnLnZhbHVlID0geC5nZXRUZXh0dXJlID8gKCkgPT4gKHguZ2V0VGV4dHVyZSgpKSA6IHhcbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhIHRleHR1cmUgcmVmZXJlbmNlLCB3aGVuIGZ1bmN0aW9uIGFza3MgZm9yIHZlYzQsIGNvbnZlcnQgdG8gdmVjNFxuICAgICAgICBpZiAodHlwZWRBcmcudmFsdWUuZ2V0VGV4dHVyZSB8fCB0eXBlZEFyZy52YWx1ZS5uYW1lID09PSAncmVnbFRleHR1cmUyRCcpIHtcbiAgICAgICAgICB2YXIgeDEgPSB0eXBlZEFyZy52YWx1ZVxuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAndmVjNCcpIHtcbiAgICAgICAgICAgIHR5cGVkQXJnLnZhbHVlID0gc3JjKHgxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSBnZXRMb29rdXBbaW5wdXQudHlwZV07XG4gICAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IHNyYyh4MSlbZ2V0dGVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdHAgdW5pZm9ybSBhcnJheSBpZiBpcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwYXNzIGluIGEgZGlmZmVyZW50IHZhbHVlIG9uIGVhY2ggcmVuZGVyIGZyYW1lLFxuICAgICAgLy8gb3IgYSB0ZXh0dXJlLyBleHRlcm5hbCBzb3VyY2VcblxuICAgICAgaWYgKGlucHV0LmlzVW5pZm9ybSkgdHlwZWRBcmcuaXNVbmlmb3JtID0gaW5wdXQuaXNVbmlmb3JtO1xuICAgICAgaWYgKHR5cGVkQXJnLmlzVW5pZm9ybSkge1xuICAgICAgICB0eXBlZEFyZy5uYW1lICs9IHN0YXJ0SW5kZXhcbiAgICAgICAgLy8gIHNoYWRlclBhcmFtcy51bmlmb3Jtcy5wdXNoKHR5cGVkQXJnKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZWRBcmdcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25WYWx1ZSh2YWx1ZSwgaW5wdXQpIHtcbiAgLy8gaWYgKHR5cGVkQXJnLnZlY0xlbiA+IDApIHsgLy8gZXhwZWN0ZWQgaW5wdXQgaXMgYSB2ZWN0b3IsIG5vdCBhIHNjYWxhclxuICAvLyAgICB0eXBlZEFyZy52YWx1ZSA9IChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4gKGZpbGxBcnJheVdpdGhEZWZhdWx0cyh1c2VyQXJnc1tpbmRleF0ocHJvcHMpLCB0eXBlZEFyZy52ZWNMZW4pKVxuICAvLyB9IGVsc2Uge1xuICByZXR1cm4gKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlKHByb3BzKVxuICAgICAgaWYodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSBudW1iZXInLCB2YWx1ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dC5kZWZhdWx0XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKCdFUlJPUicsIGUpXG4gICAgICByZXR1cm4gaW5wdXQuZGVmYXVsdFxuICAgIH1cbiAgfVxuICAvLyAgfVxufVxuXG5mdW5jdGlvbiBnZXRBcnJheVZhbHVlKHZhbHVlLCBpbnB1dCwgdmVjTGVuID0gMCkge1xuICAvLyAgIGlmICh0eXBlZEFyZy52ZWNMZW4gPiAwKSB7IC8vIGV4cGVjdGVkIGlucHV0IGlzIGEgdmVjdG9yLCBub3QgYSBzY2FsYXJcbiAgLy8gICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IHRydWVcbiAgLy8gICAgIHR5cGVkQXJnLnZhbHVlID0gZmlsbEFycmF5V2l0aERlZmF1bHRzKHR5cGVkQXJnLnZhbHVlLCB0eXBlZEFyZy52ZWNMZW4pXG4gIC8vICB9IGVsc2Uge1xuICAvLyAgY29uc29sZS5sb2coXCJpcyBBcnJheVwiKVxuICAvLyBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IGFyZSBub3QgYSBudW1iZXJcbiAgLy8gY29uc3QgZmlsdGVyZWRBcnJheSA9IHVzZXJBcmdzW2luZGV4XS5maWx0ZXIoKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gIC8vIHR5cGVkQXJnLnZhbHVlID0gKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKSA9PiBhcnJheVV0aWxzLmdldFZhbHVlKGZpbHRlcmVkQXJyYXkpKHByb3BzKVxuICBpZiAodmVjTGVuKSB7XG4gICAgcmV0dXJuIChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkodmVjTGVuKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx2ZWNMZW47IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gdmFsdWVbaV07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGlucHV0LmRlZmF1bHQgPyBpbnB1dC5kZWZhdWx0LmNvbnN0cnVjdG9yID09PSBBcnJheSA/IGlucHV0LmRlZmF1bHRbaV0gOiBpbnB1dC5kZWZhdWx0IDogMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gZ2V0RnVuY3Rpb25WYWx1ZSh2LCB7ZGVmYXVsdDogZGVmYXVsdFZhbHVlfSkoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSBhcnJheVV0aWxzLmdldFZhbHVlKHYpKHByb3BzKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKSA9PiBhcnJheVV0aWxzLmdldFZhbHVlKHZhbHVlKShwcm9wcylcbiAgfVxufSIsImltcG9ydCBmb3JtYXRBcmd1bWVudHMgZnJvbSAnLi9mb3JtYXQtYXJndW1lbnRzLmpzJ1xuaW1wb3J0IHt0eXBlTG9va3VwLCBnZXRMb29rdXAsIGdldFR5cGVMb29rdXAsIGNhc3RUeXBlfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXG4vLyBjb252ZXJ0cyBhIHRyZWUgb2YgamF2YXNjcmlwdCBmdW5jdGlvbnMgdG8gYSBzaGFkZXJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gZ2VuZXJhdGVQYXJhbXMoY3JlYXRlUGFyYW1zKCksIHNvdXJjZSwgc291cmNlLnRyYW5zZm9ybXMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIHVuaWZvcm1zOiBbXSwgLy8gbGlzdCBvZiB1bmlmb3JtcyB1c2VkIGluIHNoYWRlclxuICAgIGdsc2xGdW5jdGlvbnM6IFtdLCAvLyBsaXN0IG9mIGZ1bmN0aW9ucyB1c2VkIGluIHNoYWRlclxuICAgIGZyYWdDb2xvcjogJycsXG4gICAgcG9zaXRpb246ICcnLFxuICB9LCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhcmFtcyhzaGFkZXJQYXJhbXMsIHNvdXJjZSwgdHJhbnNmb3Jtcykge1xuICBpZiAoIXNoYWRlclBhcmFtcy5mcmFnQ29sb3IpIHtcbiAgICBzaGFkZXJQYXJhbXMuZnJhZ0NvbG9yID0gZ2VuZXJhdGVHbHNsKHNvdXJjZSwgdHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zLCB0eXBlTG9va3VwWydzcmMnXS5yZXR1cm5UeXBlKSgnc3QnLCAndmVjNCcsIDEuMClcbiAgfVxuICBpZiAoIXNoYWRlclBhcmFtcy5wb3NpdGlvbiAmJiAhc2hhZGVyUGFyYW1zLmNvbWJpbmUpIHtcbiAgICBzaGFkZXJQYXJhbXMucG9zaXRpb24gPSBnZW5lcmF0ZUdsc2woc291cmNlLCB0cmFuc2Zvcm1zLmZpbHRlcigodHIpID0+IHtcbiAgICAgIHJldHVybiB0ci50cmFuc2Zvcm0udHlwZSAhPT0gJ2NvbWJpbmUnICYmIHRyLnRyYW5zZm9ybS50eXBlICE9PSAnY2xlYXInO1xuICAgIH0pLCBzaGFkZXJQYXJhbXMsIHR5cGVMb29rdXBbJ3NyYyddLnJldHVyblR5cGUpKCdzdCcsICd2ZWM0JywgMS4wKVxuICB9XG4gIC8vIHJlbW92ZSB1bmlmb3JtcyB3aXRoIGR1cGxpY2F0ZSBuYW1lc1xuICBpZiAoc2hhZGVyUGFyYW1zLnVuaWZvcm1zKSB7XG4gICAgbGV0IHVuaWZvcm1zID0ge31cbiAgICBzaGFkZXJQYXJhbXMudW5pZm9ybXMuZm9yRWFjaCgodW5pZm9ybSkgPT4gdW5pZm9ybXNbdW5pZm9ybS5uYW1lXSA9IHVuaWZvcm0pXG4gICAgc2hhZGVyUGFyYW1zLnVuaWZvcm1zID0gT2JqZWN0LnZhbHVlcyh1bmlmb3JtcylcbiAgfVxuICByZXR1cm4gc2hhZGVyUGFyYW1zXG59XG5cbi8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBzaGFkZXIgc3RyaW5nIGZyb20gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zIGFuZCB1c2VyIGFyZ3VtZW50cy4gT3JkZXIgb2YgZnVuY3Rpb25zIGluIHN0cmluZyBkZXBlbmRzIG9uIHR5cGUgb2YgZnVuY3Rpb25cbi8vIHRvIGRvOiBpbXByb3ZlIHZhcmlhYmxlIG5hbWVzXG5mdW5jdGlvbiBnZW5lcmF0ZUdsc2wgKHNvdXJjZSwgdHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSB7XG4gIC8vIHRyYW5zZm9ybSBmdW5jdGlvbiB0aGF0IG91dHB1dHMgYSBzaGFkZXIgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gZ2xfRnJhZ0NvbG9yXG4gIGNvbnN0IGVtcHR5ID0gKCkgPT4gJyc7XG4gIHZhciBmcmFnQ29sb3IgPSBlbXB0eVxuICB0cmFuc2Zvcm1zLm1hcCgodHJhbnNmb3JtLCBpKSA9PiB7XG4gICAgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ3ZlcnQnICYmICFzb3VyY2UuZ2VvbWV0cnkpIHtcbiAgICAgIHNvdXJjZS5zZXRHZW9tZXRyeSh0cmFuc2Zvcm0udXNlckFyZ3NbMF0pO1xuICAgICAgdHJhbnNmb3JtLnVzZXJBcmdzID0gdHJhbnNmb3JtLnVzZXJBcmdzLnNsaWNlKDEpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRzID0gZm9ybWF0QXJndW1lbnRzKHRyYW5zZm9ybSwgc2hhZGVyUGFyYW1zLnVuaWZvcm1zLmxlbmd0aClcbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY2xlYXInKSB7XG4gICAgICBzb3VyY2UucGFzc2VzLnVuc2hpZnQoe2NsZWFyOiB0cmFuc2Zvcm0udHJhbnNmb3JtLm5hbWUsIHVzZXJBcmdzOiBpbnB1dHMubWFwKChpKSA9PiBpLnZhbHVlKX0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYoaW5wdXQuaXNVbmlmb3JtKSBzaGFkZXJQYXJhbXMudW5pZm9ybXMucHVzaChpbnB1dClcbiAgICB9KVxuXG4gICAgLy8gYWRkIG5ldyBnbHNsIGZ1bmN0aW9uIHRvIHJ1bm5pbmcgbGlzdCBvZiBmdW5jdGlvbnNcbiAgICBpZighY29udGFpbnModHJhbnNmb3JtLCBzaGFkZXJQYXJhbXMuZ2xzbEZ1bmN0aW9ucykpIHNoYWRlclBhcmFtcy5nbHNsRnVuY3Rpb25zLnB1c2godHJhbnNmb3JtKVxuXG4gICAgLy8gY3VycmVudCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBmcmFnIGNvbG9yIHNoYWRlciBjb2RlXG4gICAgdmFyIGYwID0gZnJhZ0NvbG9yXG4gICAgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ3NyYycgfHwgdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAndmVydCcpIHtcbiAgICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke3NoYWRlclN0cmluZyh1diwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ2Nvb3JkJykge1xuICAgICAgZnJhZ0NvbG9yID0gZjAgPT09IGVtcHR5XG4gICAgICAgID8gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICA6ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2YwKGAke3NoYWRlclN0cmluZyh1diwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgJ3ZlYzInKX1gLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29sb3InKSB7XG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiAgYCR7c2hhZGVyU3RyaW5nKGAke2YwKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb21iaW5lJykge1xuICAgICAgLy8gY29tYmluaW5nIHR3byBnZW5lcmF0ZWQgc2hhZGVyIHN0cmluZ3MgKGkuZS4gZm9yIGJsZW5kLCBtdWx0LCBhZGQgZnVudGlvbnMpXG4gICAgICBpZiAoc291cmNlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQgfHwgKGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3JtcyAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgc2hhZGVyUGFyYW1zLCB7XG4gICAgICAgICAgZnJhZ0NvbG9yOiBmcmFnQ29sb3IoJ3N0JywgJ3ZlYzQnLCAxLjApIHx8ICd2ZWM0KDApJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2hhZGVyUGFyYW1zLCBjcmVhdGVQYXJhbXMoe1xuICAgICAgICAgIGdsc2xGdW5jdGlvbnM6IFt0cmFuc2Zvcm1dLFxuICAgICAgICAgIGNvbWJpbmU6IHRydWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgdHJhbnMgPSBzb3VyY2UudHJhbnNmb3Jtcy5zbGljZSgwLCBzb3VyY2UudHJhbnNmb3Jtcy5pbmRleE9mKHRyYW5zZm9ybSkpO1xuICAgICAgICBzb3VyY2UucGFzc2VzLnVuc2hpZnQoc291cmNlLmNyZWF0ZVBhc3MoZ2VuZXJhdGVQYXJhbXMocGFyYW1zLCBzb3VyY2UsIHRyYW5zKSwge2ZyYW1lYnVmZmVyOiBzb3VyY2Uub3V0cHV0LnRlbXBbMF19KSk7XG4gICAgICAgIGNvbnN0IHRlbXAwID0gc3JjKHNvdXJjZS5vdXRwdXQudGVtcFswXSk7XG4gICAgICAgIGYwID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKHRlbXAwLCB0ZW1wMC50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgfVxuICAgICAgdmFyIGYxO1xuICAgICAgaWYgKGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAoaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQgfHwgc291cmNlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnZlcnQpIHtcbiAgICAgICAgICBpbnB1dHNbMF0udmFsdWUub3V0cHV0ID0gc291cmNlLm91dHB1dDtcbiAgICAgICAgICBzb3VyY2UucGFzc2VzLnVuc2hpZnQoLi4uaW5wdXRzWzBdLnZhbHVlLmdsc2woe2ZyYW1lYnVmZmVyOiBzb3VyY2Uub3V0cHV0LnRlbXBbMV19KSk7XG4gICAgICAgICAgY29uc3QgdGVtcDEgPSBzcmMoc291cmNlLm91dHB1dC50ZW1wWzFdKTtcbiAgICAgICAgICBmMSA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2dlbmVyYXRlR2xzbCh0ZW1wMSwgdGVtcDEudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSh1diwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmMSA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGAke2dlbmVyYXRlR2xzbChpbnB1dHNbMF0udmFsdWUsIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZjEgPSAoaW5wdXRzWzBdLmlzVW5pZm9ybSA/ICgpID0+IGlucHV0c1swXS5uYW1lIDogKCkgPT4gaW5wdXRzWzBdLnZhbHVlKVxuICAgICAgfVxuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKGAke2YwKHV2LCAndmVjNCcpfSwgJHtmMSh1diwgJ3ZlYzQnKX1gLCB0cmFuc2Zvcm0sIGlucHV0cy5zbGljZSgxKSwgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29tYmluZUNvb3JkJykge1xuICAgICAgLy8gY29tYmluaW5nIHR3byBnZW5lcmF0ZWQgc2hhZGVyIHN0cmluZ3MgKGkuZS4gZm9yIG1vZHVsYXRlIGZ1bmN0aW9ucylcbiAgICAgIHZhciBmMSA9IGlucHV0c1swXS52YWx1ZSAmJiBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1xuICAgICAgICAgID8gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0c1swXS52YWx1ZSwgaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgICAgOiAoaW5wdXRzWzBdLmlzVW5pZm9ybSA/ICgpID0+IGlucHV0c1swXS5uYW1lIDogKCkgPT4gaW5wdXRzWzBdLnZhbHVlKVxuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7ZjAoYCR7c2hhZGVyU3RyaW5nKGAke3V2fSwgJHtmMSh1diwgJ3ZlYzQnKX1gLCB0cmFuc2Zvcm0sIGlucHV0cy5zbGljZSgxKSwgc2hhZGVyUGFyYW1zLCAndmVjMicpfWAsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdubyBzdXBwb3J0IGZvciB0eXBlOiAnICsgdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlKVxuICAgIH1cbiAgfSlcbiAgaWYgKHNvdXJjZS5nZXR0ZXIpIHtcbiAgICB2YXIgZjIgPSBmcmFnQ29sb3JcbiAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBjYXN0VHlwZShmMih1diwgcmV0dXJuVHlwZSwgYWxwaGEpICsgYC4ke3NvdXJjZS5nZXR0ZXJ9YCwgZ2V0VHlwZUxvb2t1cFtzb3VyY2UuZ2V0dGVyXSwgcmV0dXJuVHlwZSwgMS4wKVxuICB9XG4gIHJldHVybiBmcmFnQ29sb3Jcbn1cblxuLy8gYXNzZW1ibGVzIGEgc2hhZGVyIHN0cmluZyBjb250YWluaW5nIHRoZSBhcmd1bWVudHMgYW5kIHRoZSBmdW5jdGlvbiBuYW1lLCBpLmUuICdvc2ModXYsIGZyZXF1ZW5jeSknXG5mdW5jdGlvbiBzaGFkZXJTdHJpbmcgKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSA9IDAuMCkge1xuICBjb25zdCBzdHIgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5pc1VuaWZvcm0pIHtcbiAgICAgIHJldHVybiBpbnB1dC5uYW1lXG4gICAgfSBlbHNlIGlmIChpbnB1dC52YWx1ZSAmJiBpbnB1dC52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAvLyB0aGlzIGJ5IGRlZmluaXRpb24gbmVlZHMgdG8gYmUgYSBnZW5lcmF0b3IsIGhlbmNlIHdlIHN0YXJ0IHdpdGggJ3N0JyBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgZ2VuZXJhdGluZyB0aGUgZ2xzbCBmcmFnbWVudFxuICAgICAgaWYgKCFpbnB1dC52YWx1ZS5nZXR0ZXIgJiYgdHlwZUxvb2t1cFtpbnB1dC52YWx1ZS50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS50eXBlXSAhPT0gaW5wdXQudHlwZSkge1xuICAgICAgICAvLyB0b2RvOiBhZGQgZ2V0dGVyIG9ubHkgaWYgaW5wdXQudHlwZSBpcyBsYXJnZXJcbiAgICAgICAgaW5wdXQudmFsdWUuZ2V0dGVyID0gZ2V0TG9va3VwW2lucHV0LnR5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke2dlbmVyYXRlR2xzbChpbnB1dC52YWx1ZSwgaW5wdXQudmFsdWUudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSgnc3QnLCBpbnB1dC50eXBlKX1gXG4gICAgfVxuICAgIHJldHVybiBpbnB1dC52YWx1ZVxuICB9KS5yZWR1Y2UoKHAsIGMpID0+IGAke3B9LCAke2N9YCwgJycpXG5cbiAgdmFyIGZ1bmMgPSBgJHt0cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2xOYW1lfSgke3V2fSR7c3RyfSlgXG4gIHJldHVybiBjYXN0VHlwZShmdW5jLCB0eXBlTG9va3VwW3RyYW5zZm9ybS50cmFuc2Zvcm0udHlwZV0ucmV0dXJuVHlwZSwgcmV0dXJuVHlwZSwgYWxwaGEpO1xufVxuXG4vLyBjaGVjayB3aGV0aGVyIGFycmF5XG5mdW5jdGlvbiBjb250YWlucyhvYmplY3QsIGFycikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICBpZihvYmplY3QubmFtZSA9PSBhcnJbaV0ubmFtZSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5cbiIsImltcG9ydCBHbHNsU291cmNlIGZyb20gJy4vZ2xzbC1zb3VyY2UuanMnXG5pbXBvcnQgZ2xzbEZ1bmN0aW9ucyBmcm9tICcuL2dsc2wvZ2xzbC1mdW5jdGlvbnMuanMnXG5pbXBvcnQgdmVydEZ1bmN0aW9ucyBmcm9tICcuL2dsc2wvdmVydC1mdW5jdGlvbnMuanMnXG5pbXBvcnQge3R5cGVMb29rdXB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbmNsYXNzIEdlbmVyYXRvckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgICAgZGVmYXVsdFVuaWZvcm1zLFxuICAgICAgZGVmYXVsdE91dHB1dCxcbiAgICAgIGV4dGVuZFRyYW5zZm9ybXMgPSBbXSxcbiAgICAgIGNoYW5nZUxpc3RlbmVyID0gKCgpID0+IHt9KVxuICAgIH0gPSB7fVxuICAgICkge1xuICAgIHRoaXMuZGVmYXVsdE91dHB1dCA9IGRlZmF1bHRPdXRwdXRcbiAgICB0aGlzLmRlZmF1bHRVbmlmb3JtcyA9IGRlZmF1bHRVbmlmb3Jtc1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBjaGFuZ2VMaXN0ZW5lclxuICAgIHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyA9IGV4dGVuZFRyYW5zZm9ybXNcbiAgICB0aGlzLmdlbmVyYXRvcnMgPSB7fVxuICAgIHRoaXMudXRpbHMgPSB7fVxuICAgIHRoaXMuaW5pdCgpXG4gIH1cbiAgaW5pdCAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25zID0gZ2xzbEZ1bmN0aW9ucygpXG4gICAgdGhpcy5nbHNsVHJhbnNmb3JtcyA9IHt9XG4gICAgdGhpcy5nZW5lcmF0b3JzID0gT2JqZWN0LmVudHJpZXModGhpcy5nZW5lcmF0b3JzKS5yZWR1Y2UoKHByZXYsIFttZXRob2QsIHRyYW5zZm9ybV0pID0+IHtcbiAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIoe3R5cGU6ICdyZW1vdmUnLCBzeW50aDogdGhpcywgbWV0aG9kfSlcbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSwge30pXG5cbiAgICB0aGlzLnNvdXJjZUNsYXNzID0gKCgpID0+IHtcbiAgICAgIHJldHVybiBjbGFzcyBleHRlbmRzIEdsc2xTb3VyY2Uge1xuICAgICAgfVxuICAgIH0pKClcblxuICAgIC8vIGFkZCB1c2VyIGRlZmluaWVkIHRyYW5zZm9ybXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV4dGVuZFRyYW5zZm9ybXMpKSB7XG4gICAgICBmdW5jdGlvbnMuY29uY2F0KHRoaXMuZXh0ZW5kVHJhbnNmb3JtcylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmV4dGVuZFRyYW5zZm9ybXMgPT09ICdvYmplY3QnICYmIHRoaXMuZXh0ZW5kVHJhbnNmb3Jtcy50eXBlKSB7XG4gICAgICBmdW5jdGlvbnMucHVzaCh0aGlzLmV4dGVuZFRyYW5zZm9ybXMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb25zLm1hcCgodHJhbnNmb3JtKSA9PiB0aGlzLnNldEZ1bmN0aW9uKHRyYW5zZm9ybSkpXG5cbiAgICBjb25zdCBmdW5jdGlvbnMyID0gdmVydEZ1bmN0aW9ucyh0aGlzLmdlbmVyYXRvcnMpOyAvLyBzYW5kYm94IGlzIG5vdCByZWFkeSBhdCB0aGlzIG1vbWVudCB5ZXRcbiAgICBmdW5jdGlvbnMyLm1hcCgodHJhbnNmb3JtKSA9PiB0aGlzLnNldEZ1bmN0aW9uKHRyYW5zZm9ybSkpXG4gfVxuXG4gX2FkZE1ldGhvZCAobWV0aG9kLCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHRoaXMuZ2xzbFRyYW5zZm9ybXNbbWV0aG9kXSA9IHRyYW5zZm9ybVxuICAgIGxldCByZXR2YWwgPSB1bmRlZmluZWRcbiAgICBpZiAoWydzcmMnLCAnY29vcmQnLCAnY2xlYXInLCAndmVydCddLmluZGV4T2YodHJhbnNmb3JtLnR5cGUpID4gLTEpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSAoLi4uYXJncykgPT4gbmV3IHRoaXMuc291cmNlQ2xhc3Moe1xuICAgICAgICBuYW1lOiBtZXRob2QsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICB1c2VyQXJnczogYXJncyxcbiAgICAgICAgZGVmYXVsdE91dHB1dDogdGhpcy5kZWZhdWx0T3V0cHV0LFxuICAgICAgICBkZWZhdWx0VW5pZm9ybXM6IHRoaXMuZGVmYXVsdFVuaWZvcm1zLFxuICAgICAgICBzeW50aDogc2VsZixcbiAgICAgICAgdXRpbHM6IHRoaXMudXRpbHMsXG4gICAgICB9KVxuICAgICAgdGhpcy5nZW5lcmF0b3JzW21ldGhvZF0gPSBmdW5jXG4gICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyKHt0eXBlOiAnYWRkJywgc3ludGg6IHRoaXMsIG1ldGhvZH0pXG4gICAgICByZXR2YWwgPSBmdW5jXG4gICAgfVxuICAgIHRoaXMuc291cmNlQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3QgcHJldlRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3Jtc1t0aGlzLnRyYW5zZm9ybXMubGVuZ3RoLTFdLnRyYW5zZm9ybTtcbiAgICAgIGlmIChwcmV2VHJhbnNmb3JtLnR5cGUgPT09ICdjbGVhcicgfHwgKHRyYW5zZm9ybS50eXBlICE9PSAnc3JjJyAmJiB0cmFuc2Zvcm0udHlwZSAhPT0gJ3ZlcnQnKSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaCh7bmFtZTogbWV0aG9kLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSwgdXNlckFyZ3M6IGFyZ3MsIHN5bnRoOiBzZWxmfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGB0cmFuc2Zvcm0gJHt0cmFuc2Zvcm0ubmFtZX0gbm90IGFsbG93ZWQgYWZ0ZXIgJHtwcmV2VHJhbnNmb3JtLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICByZXR1cm4gcmV0dmFsXG4gIH1cblxuICBzZXRGdW5jdGlvbihvYmopIHtcbiAgICAvLyB0b2RvOiByZW1vdmUgdXRpbHMgYW5kIGluc3RlYWQgbWFuYWdlIGZ1bmN0aW9uIGRlcGVuZGVuY2llc1xuICAgIGlmIChvYmoudHlwZSA9PT0gJ3V0aWwnKSB0aGlzLnV0aWxzW29iai5uYW1lXSA9IG9iajtcbiAgICB2YXIgcHJvY2Vzc2VkR2xzbCA9IHByb2Nlc3NGdW5jdGlvbihvYmopXG4gICAgaWYocHJvY2Vzc2VkR2xzbCkgdGhpcy5fYWRkTWV0aG9kKG9iai5uYW1lLCBwcm9jZXNzZWRHbHNsKVxuICB9XG59XG5cbi8vIGV4cGVjdHMgZ2xzbCBvZiBmb3JtYXRcbi8vIHtcbi8vICAgbmFtZTogJ29zYycsIC8vIG5hbWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYWNjZXNzIGZ1bmN0aW9uIGFzIHdlbGwgYXMgd2l0aGluIGdsc2xcbi8vICAgdHlwZTogJ3NyYycsIC8vIGNhbiBiZSBzcmM6IHZlYzQodmVjMiBfc3QpLCBjb29yZDogdmVjMih2ZWMyIF9zdCksIGNvbG9yOiB2ZWM0KHZlYzQgX2MwKSwgY29tYmluZTogdmVjNCh2ZWM0IF9jMCwgdmVjNCBfYzEpLCBjb21iaW5lQ29vcmQ6IHZlYzIodmVjMiBfc3QsIHZlYzQgX2MwKVxuLy8gICBpbnB1dHM6IFtcbi8vICAgICB7XG4vLyAgICAgICBuYW1lOiAnZnJlcScsXG4vLyAgICAgICB0eXBlOiAnZmxvYXQnLCAvLyAnZmxvYXQnICAgLy8sICd0ZXh0dXJlJywgJ3ZlYzQnXG4vLyAgICAgICBkZWZhdWx0OiAwLjJcbi8vICAgICB9LFxuLy8gICAgIHtcbi8vICAgICAgICAgICBuYW1lOiAnc3luYycsXG4vLyAgICAgICAgICAgdHlwZTogJ2Zsb2F0Jyxcbi8vICAgICAgICAgICBkZWZhdWx0OiAwLjFcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuLy8gICAgICAgICAgIHR5cGU6ICdmbG9hdCcsXG4vLyAgICAgICAgICAgZGVmYXVsdDogMC4wXG4vLyAgICAgICAgIH1cbi8vICAgXSxcbiAgIC8vICBnbHNsOiBgXG4gICAvLyAgICB2ZWMyIHN0ID0gX3N0O1xuICAgLy8gICAgZmxvYXQgciA9IHNpbigoc3QueC1vZmZzZXQqMi9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgIC8vICAgIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4gICAvLyAgICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgIC8vICAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7XG4gICAvLyBgXG4vLyB9XG5cbi8vIC8vIGdlbmVyYXRlcyBnbHNsIGZ1bmN0aW9uOlxuLy8gYHZlYzQgb3NjKHZlYzIgX3N0LCBmbG9hdCBmcmVxLCBmbG9hdCBzeW5jLCBmbG9hdCBvZmZzZXQpe1xuLy8gIHZlYzIgc3QgPSBfc3Q7XG4vLyAgZmxvYXQgciA9IHNpbigoc3QueC1vZmZzZXQqMi9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbi8vICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcSkqMC41ICsgMC41O1xuLy8gIGZsb2F0IGIgPSBzaW4oKHN0Lngrb2Zmc2V0L2ZyZXErdGltZSpzeW5jKSpmcmVxKSowLjUgICsgMC41O1xuLy8gIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7XG4vLyB9YFxuXG5mdW5jdGlvbiBwcm9jZXNzRnVuY3Rpb24ob2JqKSB7XG4gIG9iai5nbHNsTmFtZSB8fCAob2JqLmdsc2xOYW1lID0gb2JqLm5hbWUpO1xuICBpZiAob2JqLnR5cGUgPT09ICdjbGVhcicpIHJldHVybiBvYmo7XG4gIGVsc2UgaWYgKG9iai50eXBlID09PSAndXRpbCcpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dsc2wob2JqLCBvYmoucmV0dXJuVHlwZSk7XG4gIH1cbiAgbGV0IHQgPSB0eXBlTG9va3VwW29iai50eXBlXVxuICBpZih0KSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHbHNsKG9iaiwgdC5yZXR1cm5UeXBlLCB0LmFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihgdHlwZSAke29iai50eXBlfSBub3QgcmVjb2duaXplZGAsIG9iailcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHbHNsKG9iaiwgcmV0dXJuVHlwZSwgYXJncyA9IFtdKSB7XG4gICAgbGV0IGJhc2VBcmdzID0gYXJncy5tYXAoKGFyZykgPT4gYXJnKS5qb2luKFwiLCBcIilcbiAgICBsZXQgY3VzdG9tQXJncyA9IChvYmouaW5wdXRzIHx8IChvYmouaW5wdXRzID0gW10pKS5tYXAoKGlucHV0KSA9PiBgJHtpbnB1dC50eXBlfSAke2lucHV0Lm5hbWV9YCkuam9pbignLCAnKVxuICAgIGxldCBhbGxBcmdzID0gYCR7YmFzZUFyZ3N9JHtjdXN0b21BcmdzLmxlbmd0aCA+IDAgPyAnLCAnKyBjdXN0b21BcmdzOiAnJ31gXG5cbiAgICBjb25zdCBmdW5jID0gYCR7cmV0dXJuVHlwZSB8fCAnJ30gJHtvYmouZ2xzbE5hbWV9KCR7YWxsQXJnc31gO1xuICAgIGNvbnN0IGZpeE9yV3JhcCA9IChnbHNsKSA9PiB7XG4gICAgICAgIGlmIChnbHNsLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoZ2xzbC5pbmRleE9mKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWApID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xzbC5yZXBsYWNlKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWAsIGZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5wcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByaW1pdGl2ZUZuID0gb2JqLnByaW1pdGl2ZS5zcGxpdChcIiBcIikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsc2wuaW5kZXhPZihwcmltaXRpdmVGbikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsc2wucmVwbGFjZShgJHtyZXR1cm5UeXBlfSAke3ByaW1pdGl2ZUZufSgke2FsbEFyZ3N9YCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgJHtmdW5jfSkge1xuICAgICAgJHtnbHNsfVxuICB9XG5gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbHNsO1xuICAgIH1cbiAgICBvYmouZ2xzbCA9IGZpeE9yV3JhcChvYmouZ2xzbCk7XG4gICAgaWYgKG9iai52ZXJ0KSB7XG4gICAgICAgIG9iai52ZXJ0ID0gZml4T3JXcmFwKG9iai52ZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgZXh0cmEgaW5wdXQgdG8gYmVnaW5uaW5nIGZvciBiYWNrd2FyZCBjb21iYXRpYmlsaXR5IEB0b2RvIHVwZGF0ZSBjb21waWxlciBzbyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICBpZihvYmoudHlwZSA9PT0gJ2NvbWJpbmUnIHx8IG9iai50eXBlID09PSAnY29tYmluZUNvb3JkJykgb2JqLmlucHV0cy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgdHlwZTogJ3ZlYzQnXG4gICAgfSlcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHJldHVyblR5cGUgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VuZXJhdG9yRmFjdG9yeVxuIiwiaW1wb3J0IGdlbmVyYXRlR2xzbCBmcm9tICcuL2dlbmVyYXRlLWdsc2wuanMnXG5pbXBvcnQgdXRpbGl0eUdsc2wgZnJvbSAnLi9nbHNsL3V0aWxpdHktZnVuY3Rpb25zLmpzJ1xuaW1wb3J0IHZlY3Rvcml6ZVRleHQgZnJvbSAndmVjdG9yaXplLXRleHQnO1xuXG52YXIgR2xzbFNvdXJjZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdGhpcy50cmFuc2Zvcm1zID0gW11cbiAgdGhpcy50cmFuc2Zvcm1zLnB1c2gob2JqKVxuICB0aGlzLmRlZmF1bHRPdXRwdXQgPSBvYmouZGVmYXVsdE91dHB1dFxuICB0aGlzLm91dHB1dCA9IG51bGxcbiAgdGhpcy5zeW50aCA9IG9iai5zeW50aFxuICB0aGlzLnR5cGUgPSAnR2xzbFNvdXJjZSdcbiAgdGhpcy5kZWZhdWx0VW5pZm9ybXMgPSBvYmouZGVmYXVsdFVuaWZvcm1zXG4gIHRoaXMudXRpbHMgPSBPYmplY3QuYXNzaWduKHt9LCB1dGlsaXR5R2xzbCwgb2JqLnV0aWxzKTtcbiAgdGhpcy5ibGVuZE1vZGUgPSB0eXBlb2Yob2JqLnRyYW5zZm9ybS5ibGVuZE1vZGUpICE9PSAndW5kZWZpbmVkJyA/IG9iai50cmFuc2Zvcm0uYmxlbmRNb2RlIDogZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoID0gb2JqLnRyYW5zZm9ybS5saW5lV2lkdGggfHwgMTtcbiAgdGhpcy5fdmlld3BvcnQgPSB7fTtcbiAgcmV0dXJuIHRoaXNcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gKG9iaikgIHtcbiAgdGhpcy50cmFuc2Zvcm1zLnB1c2gob2JqKVxufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5vdXQgPSBmdW5jdGlvbiAoX291dHB1dCkge1xuICB2YXIgb3V0cHV0ID0gX291dHB1dCB8fCB0aGlzLmRlZmF1bHRPdXRwdXRcbiAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gIHZhciBnbHNsID0gdGhpcy5nbHNsKClcbiAgdGhpcy5zeW50aC5jdXJyZW50RnVuY3Rpb25zID0gW11cbiAgaWYob3V0cHV0KSB0cnl7XG4gICAgb3V0cHV0LnJlbmRlcihnbHNsKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKCdzaGFkZXIgY291bGQgbm90IGNvbXBpbGUnLCBlcnJvcilcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUudGV4ID0gZnVuY3Rpb24oX291dHB1dCkge1xuICBpZiAoIXRoaXMub3V0cHV0KSB7XG4gICAgdGhpcy5vdXQoX291dHB1dCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMub3V0cHV0LnJlbmRlclRleHR1cmUoKTtcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuZ2xzbCA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgdGhpcy5wYXNzZXMgPSBbXVxuICB0aGlzLnBhc3Nlcy5wdXNoKHRoaXMuY3JlYXRlUGFzcyhnZW5lcmF0ZUdsc2wodGhpcyksIG9wdGlvbnMpKVxuICByZXR1cm4gdGhpcy5wYXNzZXNcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuZ2V0SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNoYWRlckluZm8gPSBnZW5lcmF0ZUdsc2wodGhpcylcbiAgICB2YXIgdW5pZm9ybXMgPSB7fVxuICAgIHNoYWRlckluZm8udW5pZm9ybXMuZm9yRWFjaCgodW5pZm9ybSkgPT4geyB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybS52YWx1ZSB9KVxuICAgIHJldHVybiB7XG4gICAgICBzaGFkZXJJbmZvLFxuICAgICAgdXRpbGl0eUdsc2w6IHRoaXMudXRpbHMsXG4gICAgICAvLyB0b2RvOiBkaWZmZXJzIGZyb20gY29tcGlsZVxuICAgICAgdmVydDogdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS52ZXJ0LFxuICAgICAgLy8gdG9kbzogZGlmZmVycyBmcm9tIGNvbXBpbGVcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uYXR0cmlidXRlcyxcbiAgICAgIC8vIHRvZG86IGRpZmZlcnMgZnJvbSBjb21waWxlXG4gICAgICBhdHRyaWJ1dGVzQ291bnQ6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uYXR0cmlidXRlc0NvdW50LFxuICAgICAgcHJpbWl0aXZlOiB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnByaW1pdGl2ZSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRVbmlmb3JtcywgdW5pZm9ybXMpXG4gICAgfTtcbiAgfVxufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5jcmVhdGVQYXNzID0gZnVuY3Rpb24oc2hhZGVySW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciB1bmlmb3JtcyA9IHt9XG4gIHNoYWRlckluZm8udW5pZm9ybXMuZm9yRWFjaCgodW5pZm9ybSkgPT4geyB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybS52YWx1ZSB9KVxuXG4gIGlmIChzaGFkZXJJbmZvLmNvbWJpbmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCBmYWxzZSwge1xuICAgICAgICBnbHNsTmFtZTogJ2NvbWJpbmUnLFxuICAgICAgfSwgc2hhZGVySW5mbyksXG4gICAgICB1c2VyQXJnczogdGhpcy50cmFuc2Zvcm1zWzBdLnVzZXJBcmdzLFxuICAgICAgLy8gdG9kbzogZml4IG9yIGRlbGV0ZVxuICAgICAgLy8gYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcbiAgICAgIGxpbmVXaWR0aDogdGhpcy5saW5lV2lkdGgsXG4gICAgICBmcmFnOiBHbHNsU291cmNlLmNvbXBpbGVGcmFnKHRoaXMuZGVmYXVsdE91dHB1dC5wcmVjaXNpb24sIHNoYWRlckluZm8sIHRoaXMudXRpbHMpLFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3JtcyksXG4gICAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnQsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHZlcnRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnR5cGUgPT09ICdjbGVhcicgPyB0aGlzLnRyYW5zZm9ybXNbMV0gOiB0aGlzLnRyYW5zZm9ybXNbMF07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB2ZXJ0OiBHbHNsU291cmNlLmNvbXBpbGVWZXJ0KHRoaXMuZGVmYXVsdE91dHB1dC5wcmVjaXNpb24sIHRydWUsIHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICBwcmltaXRpdmU6IHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSxcbiAgICB1c2VyQXJnczogdmVydFRyYW5zZm9ybS51c2VyQXJncyxcbiAgICBnZW9tZXRyeTogdGhpcy5nZW9tZXRyeSxcbiAgICBibGVuZE1vZGU6IHRoaXMuYmxlbmRNb2RlLFxuICAgIGxpbmVXaWR0aDogdGhpcy5saW5lV2lkdGgsXG4gICAgZnJhZzogR2xzbFNvdXJjZS5jb21waWxlRnJhZyh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0VW5pZm9ybXMsIHVuaWZvcm1zKSxcbiAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnQsXG4gIH0sIG9wdGlvbnMpXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZUhlYWRlciA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgdW5pZm9ybXMgPSB7fSwgdXRpbHMgPSB7fSkge1xuICByZXR1cm4gYFxuICBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuICAke09iamVjdC52YWx1ZXModW5pZm9ybXMpLm1hcCgodW5pZm9ybSkgPT4ge1xuICAgIGxldCB0eXBlID0gdW5pZm9ybS50eXBlXG4gICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCdcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm0ubmFtZX07YFxuICB9KS5qb2luKCcnKX1cbiAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgdmFyeWluZyB2ZWMzIHZwb3NpdGlvbjtcbiAgdmFyeWluZyB2ZWMyIHZ1djtcbiAgdmFyeWluZyB2ZWMzIHZub3JtYWw7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHByZXZCdWZmZXI7XG4gIFxuICAke09iamVjdC52YWx1ZXModXRpbHMpLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgLy8gIGNvbnNvbGUubG9nKHRyYW5zZm9ybS5nbHNsKVxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgfSkuam9pbignJyl9XG4gIGBcbn1cblxuR2xzbFNvdXJjZS5jb21waWxlRnJhZyA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgc2hhZGVySW5mbywgdXRpbHMpIHtcbiAgY29uc3QgaGVhZGVyID0gdGhpcy5jb21waWxlSGVhZGVyKHByZWNpc2lvbiwgc2hhZGVySW5mby51bmlmb3JtcywgdXRpbHMpO1xuICByZXR1cm4gaGVhZGVyICsgYFxuICBcbiAgJHtzaGFkZXJJbmZvLmdsc2xGdW5jdGlvbnMubWFwKCh0cmFuc2Zvcm0pID0+IHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHt0cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2x9XG4gICAgICAgICAgYFxuICB9KS5qb2luKCcnKX1cblxuICB2b2lkIG1haW4gKCkge1xuICAgIHZlYzQgYyA9IHZlYzQoMSwgMCwgMCwgMSk7XG4gICAgLy92ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3Jlc29sdXRpb24ueHk7XG4gICAgdmVjMiBzdCA9IHZ1djtcbiAgICBnbF9GcmFnQ29sb3IgPSAke3NoYWRlckluZm8uZnJhZ0NvbG9yfTtcbiAgfVxuICBgXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZVZlcnQgPSBmdW5jdGlvbihwcmVjaXNpb24sIHVzZUNhbWVyYSwgdHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB1dGlscykge1xuICBjb25zdCB1c2VVViA9IHR5cGVvZih0cmFuc2Zvcm0udXNlVVYpICE9PSAndW5kZWZpbmVkJ1xuICAgID8gdHJhbnNmb3JtLnVzZVVWXG4gICAgOiAoIXRyYW5zZm9ybS5wcmltaXRpdmUgfHwgWydwb2ludHMnLCAnbGluZXMnLCAnbGluZSBzdHJpcCcsICdsaW5lIGxvb3AnXS5pbmRleE9mKHRyYW5zZm9ybS5wcmltaXRpdmUpID09PSAtMSk7XG4gIGNvbnN0IHVzZU5vcm1hbCA9IHR5cGVvZih0cmFuc2Zvcm0udXNlTm9ybWFsKSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gdHJhbnNmb3JtLnVzZU5vcm1hbFxuICAgICAgOiB0cmFuc2Zvcm0udHlwZSA9PT0gJ3ZlcnQnICYmICghdHJhbnNmb3JtLnByaW1pdGl2ZSB8fCBbJ3BvaW50cycsICdsaW5lcycsICdsaW5lIHN0cmlwJywgJ2xpbmUgbG9vcCddLmluZGV4T2YodHJhbnNmb3JtLnByaW1pdGl2ZSkgPT09IC0xKVxuXG4gIGxldCB2ZXJ0SGVhZGVyID0gYFxuICBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbiwgdmlldztcbiAgYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG4gICR7dXNlVVYgPyAnYXR0cmlidXRlIHZlYzIgdXY7JyA6ICcnfVxuICAke3VzZU5vcm1hbCA/ICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyA6ICcnfVxuICB2YXJ5aW5nIHZlYzMgdnBvc2l0aW9uO1xuICB2YXJ5aW5nIHZlYzIgdnV2O1xuICB2YXJ5aW5nIHZlYzMgdm5vcm1hbDtcbiAgYFxuICBsZXQgdmVydEZuID0gYFxuICB2b2lkICR7dHJhbnNmb3JtLmdsc2xOYW1lfSgpIHtcbiAgICB2cG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBnbF9Qb3NpdGlvbiA9ICR7dXNlQ2FtZXJhID8gJ3Byb2plY3Rpb24gKiB2aWV3ICogJyA6ICcnfXZlYzQocG9zaXRpb24sIDEuMCk7XG4gIH0gXG4gIGBcbiAgbGV0IHZlcnRDYWxsID0gYCR7dHJhbnNmb3JtLmdsc2xOYW1lfSgpO2A7XG4gIGlmICh0cmFuc2Zvcm0udmVydCkge1xuICAgIHZlcnRIZWFkZXIgPSB0aGlzLmNvbXBpbGVIZWFkZXIocHJlY2lzaW9uLCBzaGFkZXJJbmZvLnVuaWZvcm1zLCB1dGlscykgKyBgXG4gICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb24sIHZpZXc7XG4gICAgYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG4gICAgJHt1c2VVViA/ICdhdHRyaWJ1dGUgdmVjMiB1djsnIDogJyd9XG4gICAgJHt1c2VOb3JtYWwgPyAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycgOiAnJ31cbiAgICBcbiAgICAke3NoYWRlckluZm8uZ2xzbEZ1bmN0aW9ucy5tYXAoKHRyYW5zKSA9PiB7XG4gICAgICBpZiAodHJhbnMudHJhbnNmb3JtLm5hbWUgIT09IHRyYW5zZm9ybS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zLnRyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKX1cbiAgICBgXG4gICAgdmVydEZuID0gdHJhbnNmb3JtLnZlcnQ7XG4gICAgdmVydENhbGwgPSBgXG4gICAgJHt1c2VVViA/ICd2ZWMyIHN0ID0gdXY7JyA6ICd2ZWMyIHN0ID0gcG9zaXRpb24ueHk7J31cbiAgICB2cG9zaXRpb24gPSAke3NoYWRlckluZm8ucG9zaXRpb259O1xuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZpZXcgKiB2cG9zaXRpb247XG4gICAgYDtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0SGVhZGVyICsgYFxuICAgIFxuICAke3ZlcnRGbn1cblxuICB2b2lkIG1haW4gKCkge1xuICAgICR7dXNlVVYgPyAndnV2ID0gdXY7JyA6ICcnfVxuICAgICR7dXNlTm9ybWFsID8gJ3Zub3JtYWwgPSBub3JtYWw7JyA6ICcnfVxuICAgICR7dmVydENhbGx9XG4gIH1gXG59XG5cbi8vIHRvZG86IG1ha2UgaHlkcmEtc3ludGggZnVuY3Rpb25cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldEJsZW5kID0gZnVuY3Rpb24oYmxlbmRNb2RlID0gdHJ1ZSkge1xuICB0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmVXaWR0aCkge1xuICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgY29uc3QgaXNHZW9tZXRyeSA9ICh2KSA9PiAodi5pc0J1ZmZlckdlb21ldHJ5IHx8ICh2LnBvc2l0aW9ucyAmJiB2LmVkZ2VzKSk7XG4gIGNvbnN0IGlzQ2xhc3MgPSAodikgPT4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbicgJiYgL15cXHMqY2xhc3NcXHMrLy50ZXN0KHYudG9TdHJpbmcoKSk7XG4gIGlmICghaW5wdXQpIGlucHV0ID0gW107XG4gIGlmICghaXNHZW9tZXRyeShpbnB1dCkpIHtcbiAgICBjb25zdCB2ZXJ0VHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS50eXBlID09PSAnY2xlYXInID8gdGhpcy50cmFuc2Zvcm1zWzFdIDogdGhpcy50cmFuc2Zvcm1zWzBdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIGlucHV0ID0gW2lucHV0XTtcbiAgICBpZiAoaXNDbGFzcyh2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5nZW9tZXRyeSkpIHtcbiAgICAgIGlmICh2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5nZW9tZXRyeSA9PT0gR3JpZEdlb21ldHJ5ICYmIHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSAmJiB0eXBlb2YoaW5wdXRbMF0pICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dC51bnNoaWZ0KHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IG5ldyAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkgPT09IHZlY3Rvcml6ZVRleHQgJiYgaW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlucHV0LnB1c2goe1xuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAvLyBmb250OiAnYXJpYWwnLFxuICAgICAgICAgIC8vIHRyaWFuZ2xlczogdHJ1ZSwgLy8gdG9kbzogbWFrZSBpdCB3b3JrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5nZW9tZXRyeSA9IGlucHV0O1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgdGhpcy5fdmlld3BvcnQgPSB7eCwgeSwgdywgaH07XG4gIHJldHVybiB0aGlzO1xufVxuXG5jb25zdCBnbHNsUHJvcHMgPSBbJ3gnLCAneScsICd6JywgJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5JywgJ3h5eicsICd4eXp3J107XG5nbHNsUHJvcHMubWFwKChwcm9wKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHNsU291cmNlLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcHJvcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgR2xzbFNvdXJjZVxuIiwiaW1wb3J0IHtCdWZmZXJHZW9tZXRyeX0gZnJvbSBcInRocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5XCI7XG5pbXBvcnQge0Zsb2F0MzJCdWZmZXJBdHRyaWJ1dGV9IGZyb20gXCJ0aHJlZS9zcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGVcIjtcblxuY2xhc3MgR3JpZEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSAnR3JpZEdlb21ldHJ5JztcblxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBwcmltaXRpdmU6IHR5cGUsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZlcnRpY2VzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50cyc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgfHwgKGhlaWdodCA9IDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGsrMSkgLyAzICUgd2lkdGggLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoTWF0aC5mbG9vcigoay0xKSAvIDMgLyB3aWR0aCkrMC41KSAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpbmVzJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoIHx8ICh3aWR0aCA9IDEpO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSAyICogKHdpZHRoICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrIDwgKHdpZHRoICogNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrKzMpIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGspIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoaysyKSAvIDYgJSBoZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGstMSkgLyA2ICUgaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGluZSBzdHJpcCc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxMCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IHx8IChoZWlnaHQgPSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlZCA9IHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IHdpbGwgYmUgTmFOIHdoZW4gcG9pbnRzWzBdID09IDFcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogbWluaW11bSAyIHBvaW50cz9cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrJTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGsgLyAzICUgd2lkdGggLyAod2lkdGgtY2xvc2VkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGstMSkgLyAzIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaW5lIGxvb3AnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGggfHwgKHdpZHRoID0gMTApO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrIC8gMyAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChrLTEpIC8gMyAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBpbnZhbGlkIEdyaWRHZW9tZXRyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IHsgR3JpZEdlb21ldHJ5IH07IiwiLypcbkZvcm1hdCBmb3IgYWRkaW5nIGZ1bmN0aW9ucyB0byBoeWRyYS4gRm9yIGVhY2ggZW50cnkgaW4gdGhpcyBmaWxlLCBoeWRyYSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBhIGdsc2wgZnVuY3Rpb24gYW5kIGphdmFzY3JpcHQgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBuYW1lLiBZb3UgY2FuIGFsc28gYXNzIGZ1bmN0aW9ucyBkeW5hbWljYWxseSB1c2luZyBzZXRGdW5jdGlvbihvYmplY3QpLlxuXG57XG4gIG5hbWU6ICdvc2MnLCAvLyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFjY2VzcyBmdW5jdGlvbiBpbiBqcyBhcyB3ZWxsIGFzIGluIGdsc2xcbiAgdHlwZTogJ3NyYycsIC8vIGNhbiBiZSAnc3JjJywgJ2NvbG9yJywgJ2NvbWJpbmUnLCAnY29tYmluZUNvb3JkcycuIHNlZSBiZWxvdyBmb3IgbW9yZSBpbmZvXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmcmVxJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIGRlZmF1bHQ6IDAuMFxuICAgIH1cbiAgXSxcbiAgICBnbHNsOiBgXG4gICAgICB2ZWMyIHN0ID0gX3N0O1xuICAgICAgZmxvYXQgciA9IHNpbigoc3QueC1vZmZzZXQqMi9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4gICAgICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7XG4gICBgXG59XG5cbi8vIFRoZSBhYm92ZSBjb2RlIGdlbmVyYXRlcyB0aGUgZ2xzbCBmdW5jdGlvbjpcbmB2ZWM0IG9zYyh2ZWMyIF9zdCwgZmxvYXQgZnJlcSwgZmxvYXQgc3luYywgZmxvYXQgb2Zmc2V0KXtcbiB2ZWMyIHN0ID0gX3N0O1xuIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbiBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xufWBcblxuXG5UeXBlcyBhbmQgZGVmYXVsdCBhcmd1bWVudHMgZm9yIGh5ZHJhIGZ1bmN0aW9ucy5cblRoZSB2YWx1ZSBpbiB0aGUgJ3R5cGUnIGZpZWxkIGxldHMgdGhlIHBhcnNlciBrbm93IHdoaWNoIHR5cGUgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgYXMgd2VsbCBhcyBkZWZhdWx0IGFyZ3VtZW50cy5cblxuY29uc3QgdHlwZXMgPSB7XG4gICdzcmMnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29sb3InOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjNCBfYzAnXVxuICB9LFxuICAnY29tYmluZSc6IHtcbiAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgYXJnczogWyd2ZWM0IF9jMCcsICd2ZWM0IF9jMSddXG4gIH0sXG4gICdjb21iaW5lQ29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnLCAndmVjNCBfYzAnXVxuICB9XG59XG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IFtcbiAge1xuICAgIG5hbWU6ICdjbGVhcicsXG4gICAgdHlwZTogJ2NsZWFyJyxcbiAgICBpbnB1dHM6IFtdLFxuICAgIGdsc2w6IGBgLFxuICB9LFxuICB7XG4gICAgbmFtZTogJ2ZhZGUnLFxuICAgIHR5cGU6ICdjbGVhcicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtuYW1lOiAnYW1vdW50JywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogJzAuMDEnfSxcbiAgICAgICAge25hbWU6ICdjYW1lcmEnLCB0eXBlOiAnYm9vbCcsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICBdLFxuICAgIGdsc2w6IGBgLFxuICB9LFxuICB7XG4gIG5hbWU6ICdub2lzZScsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLjEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHZlYzMoX25vaXNlKHZlYzMoX3N0KnNjYWxlLCBvZmZzZXQqdGltZSkpKSwgMS4wKTtgXG59LFxue1xuICBuYW1lOiAndm9yb25vaScsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgZGVmYXVsdDogMC4zLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2JsZW5kaW5nJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMyBjb2xvciA9IHZlYzMoLjApO1xuICAgLy8gU2NhbGVcbiAgIF9zdCAqPSBzY2FsZTtcbiAgIC8vIFRpbGUgdGhlIHNwYWNlXG4gICB2ZWMyIGlfc3QgPSBmbG9vcihfc3QpO1xuICAgdmVjMiBmX3N0ID0gZnJhY3QoX3N0KTtcbiAgIGZsb2F0IG1fZGlzdCA9IDEwLjsgIC8vIG1pbmltdW4gZGlzdGFuY2VcbiAgIHZlYzIgbV9wb2ludDsgICAgICAgIC8vIG1pbmltdW0gcG9pbnRcbiAgIGZvciAoaW50IGo9LTE7IGo8PTE7IGorKyApIHtcbiAgIGZvciAoaW50IGk9LTE7IGk8PTE7IGkrKyApIHtcbiAgIHZlYzIgbmVpZ2hib3IgPSB2ZWMyKGZsb2F0KGkpLGZsb2F0KGopKTtcbiAgIHZlYzIgcCA9IGlfc3QgKyBuZWlnaGJvcjtcbiAgIHZlYzIgcG9pbnQgPSBmcmFjdChzaW4odmVjMihkb3QocCx2ZWMyKDEyNy4xLDMxMS43KSksZG90KHAsdmVjMigyNjkuNSwxODMuMykpKSkqNDM3NTguNTQ1Myk7XG4gICBwb2ludCA9IDAuNSArIDAuNSpzaW4odGltZSpzcGVlZCArIDYuMjgzMSpwb2ludCk7XG4gICB2ZWMyIGRpZmYgPSBuZWlnaGJvciArIHBvaW50IC0gZl9zdDtcbiAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoZGlmZik7XG4gICBpZiggZGlzdCA8IG1fZGlzdCApIHtcbiAgIG1fZGlzdCA9IGRpc3Q7XG4gICBtX3BvaW50ID0gcG9pbnQ7XG4gICB9XG4gICB9XG4gICB9XG4gICAvLyBBc3NpZ24gYSBjb2xvciB1c2luZyB0aGUgY2xvc2VzdCBwb2ludCBwb3NpdGlvblxuICAgY29sb3IgKz0gZG90KG1fcG9pbnQsdmVjMiguMywuNikpO1xuICAgY29sb3IgKj0gMS4wIC0gYmxlbmRpbmcqbV9kaXN0O1xuICAgcmV0dXJuIHZlYzQoY29sb3IsIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ29zYycsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2ZyZXF1ZW5jeScsXG4gICAgICBkZWZhdWx0OiA2MCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzeW5jJyxcbiAgICAgIGRlZmF1bHQ6IDAuMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdDtcbiAgIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0L2ZyZXF1ZW5jeSt0aW1lKnN5bmMpKmZyZXF1ZW5jeSkqMC41ICArIDAuNTtcbiAgIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSArIDAuNTtcbiAgIGZsb2F0IGIgPSBzaW4oKHN0Lngrb2Zmc2V0L2ZyZXF1ZW5jeSt0aW1lKnN5bmMpKmZyZXF1ZW5jeSkqMC41ICArIDAuNTtcbiAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3NoYXBlJyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2lkZXMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyYWRpdXMnLFxuICAgICAgZGVmYXVsdDogMC4zLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Ntb290aGluZycsXG4gICAgICBkZWZhdWx0OiAwLjAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogMi4gLSAxLjtcbiAgIC8vIEFuZ2xlIGFuZCByYWRpdXMgZnJvbSB0aGUgY3VycmVudCBwaXhlbFxuICAgZmxvYXQgYSA9IGF0YW4oc3QueCxzdC55KSszLjE0MTY7XG4gICBmbG9hdCByID0gKDIuKjMuMTQxNikvc2lkZXM7XG4gICBmbG9hdCBkID0gY29zKGZsb29yKC41K2Evcikqci1hKSpsZW5ndGgoc3QpO1xuICAgcmV0dXJuIHZlYzQodmVjMygxLjAtc21vb3Roc3RlcChyYWRpdXMscmFkaXVzICsgc21vb3RoaW5nICsgMC4wMDAwMDAxLGQpKSwgMS4wKTtgXG59LFxue1xuICBuYW1lOiAnZ3JhZGllbnQnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfc3QsIHNpbih0aW1lKnNwZWVkKSwgMS4wKTtgXG59LFxue1xuICBuYW1lOiAnc3JjJyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgbmFtZTogJ3RleCcsXG4gICAgICBkZWZhdWx0OiBOYU4sXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIC8vICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5L3ZlYzIoMTI4MC4sIDcyMC4pO1xuICAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIGZyYWN0KF9zdCkpO2Bcbn0sXG57XG4gIG5hbWU6ICdzb2xpZCcsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3InLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdnJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYicsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2EnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQociwgZywgYiwgYSk7YFxufSxcbntcbiAgbmFtZTogJ3JvdGF0ZScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAgZGVmYXVsdDogMTAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgLy8gQ29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgIGZsb2F0IGFuZyA9IGFuZ2xlICogKDMuMTQxNTkyNjUzNTg5NzkzIC8gMTgwLjApO1xuICAgYW5nID0gYW5nICsgc3BlZWQgKnRpbWU7XG4gICB4eSA9IG1hdDIoY29zKGFuZyksLXNpbihhbmcpLCBzaW4oYW5nKSxjb3MoYW5nKSkqeHk7XG4gICB4eSArPSAwLjU7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ3NjYWxlJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMS41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3hNdWx0JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAneU11bHQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXRYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXRZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiB4eSA9IF9zdCAtIHZlYzIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICB4eSo9KDEuMC92ZWMyKGFtb3VudCp4TXVsdCwgYW1vdW50KnlNdWx0KSk7XG4gICB4eSs9dmVjMihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgIHJldHVybiB4eTtcbiAgIGBcbn0sXG57XG4gIG5hbWU6ICdwaXhlbGF0ZScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncGl4ZWxYJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3BpeGVsWScsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiB4eSA9IHZlYzIocGl4ZWxYLCBwaXhlbFkpO1xuICAgcmV0dXJuIChmbG9vcihfc3QgKiB4eSkgKyAwLjUpL3h5O2Bcbn0sXG57XG4gIG5hbWU6ICdwb3N0ZXJpemUnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2JpbnMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdnYW1tYScsXG4gICAgICBkZWZhdWx0OiAwLjYsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzQgYzIgPSBwb3coX2MwLCB2ZWM0KGdhbW1hKSk7XG4gICBjMiAqPSB2ZWM0KGJpbnMpO1xuICAgYzIgPSBmbG9vcihjMik7XG4gICBjMi89IHZlYzQoYmlucyk7XG4gICBjMiA9IHBvdyhjMiwgdmVjNCgxLjAvZ2FtbWEpKTtcbiAgIHJldHVybiB2ZWM0KGMyLnh5eiwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdzaGlmdCcsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncicsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnZycsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2InLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzQgYzIgPSB2ZWM0KF9jMCk7XG4gICBjMi5yID0gZnJhY3QoYzIuciArIHIpO1xuICAgYzIuZyA9IGZyYWN0KGMyLmcgKyBnKTtcbiAgIGMyLmIgPSBmcmFjdChjMi5iICsgYik7XG4gICBjMi5hID0gZnJhY3QoYzIuYSArIGEpO1xuICAgcmV0dXJuIHZlYzQoYzIucmdiYSk7YFxufSxcbntcbiAgbmFtZTogJ3JlcGVhdCcsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwZWF0WCcsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcGVhdFknLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXRYJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WScsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBlYXRYLCByZXBlYXRZKTtcbiAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSkgKiBvZmZzZXRYO1xuICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKSAqIG9mZnNldFk7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJlcGVhdCcsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcGVhdFgnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBlYXRZJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WScsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgKiB2ZWMyKHJlcGVhdFgsIHJlcGVhdFkpO1xuICAgc3QueCArPSBzdGVwKDEuLCBtb2Qoc3QueSwyLjApKSArIF9jMC5yICogb2Zmc2V0WDtcbiAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSkgKyBfYzAuZyAqIG9mZnNldFk7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdyZXBlYXRYJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgKiB2ZWMyKHJlcHMsIDEuMCk7XG4gICAvLyAgZmxvYXQgZiA9ICBtb2QoX3N0LnksMi4wKTtcbiAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSkqIG9mZnNldDtcbiAgIHJldHVybiBmcmFjdChzdCk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUmVwZWF0WCcsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcHMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBzLCAxLjApO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC55ICs9IHN0ZXAoMS4sIG1vZChzdC54LDIuMCkpICsgX2MwLnIgKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdyZXBlYXRZJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3QgKiB2ZWMyKDEuMCwgcmVwcyk7XG4gICAvLyAgZmxvYXQgZiA9ICBtb2QoX3N0LnksMi4wKTtcbiAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSkqIG9mZnNldDtcbiAgIHJldHVybiBmcmFjdChzdCk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUmVwZWF0WScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcHMnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBzLCAxLjApO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpICsgX2MwLnIgKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdrYWxlaWQnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ25TaWRlcycsXG4gICAgICBkZWZhdWx0OiA0LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0O1xuICAgc3QgLT0gMC41O1xuICAgZmxvYXQgciA9IGxlbmd0aChzdCk7XG4gICBmbG9hdCBhID0gYXRhbihzdC55LCBzdC54KTtcbiAgIGZsb2F0IHBpID0gMi4qMy4xNDE2O1xuICAgYSA9IG1vZChhLHBpL25TaWRlcyk7XG4gICBhID0gYWJzKGEtcGkvblNpZGVzLzIuKTtcbiAgIHJldHVybiByKnZlYzIoY29zKGEpLCBzaW4oYSkpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZUthbGVpZCcsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ25TaWRlcycsXG4gICAgICBkZWZhdWx0OiA0LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0IC0gMC41O1xuICAgZmxvYXQgciA9IGxlbmd0aChzdCk7XG4gICBmbG9hdCBhID0gYXRhbihzdC55LCBzdC54KTtcbiAgIGZsb2F0IHBpID0gMi4qMy4xNDE2O1xuICAgYSA9IG1vZChhLHBpL25TaWRlcyk7XG4gICBhID0gYWJzKGEtcGkvblNpZGVzLzIuKTtcbiAgIHJldHVybiAoX2MwLnIrcikqdmVjMihjb3MoYSksIHNpbihhKSk7YFxufSxcbntcbiAgbmFtZTogJ3Njcm9sbCcsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2Nyb2xsWCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2Nyb2xsWScsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWRYJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWRZJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYFxuICAgX3N0LnggKz0gc2Nyb2xsWCArIHRpbWUqc3BlZWRYO1xuICAgX3N0LnkgKz0gc2Nyb2xsWSArIHRpbWUqc3BlZWRZO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ3Njcm9sbFgnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9zdC54ICs9IHNjcm9sbFggKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2Nyb2xsWCcsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9zdC54ICs9IF9jMC5yKnNjcm9sbFggKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ3Njcm9sbFknLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9zdC55ICs9IHNjcm9sbFkgKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2Nyb2xsWScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIF9zdC55ICs9IF9jMC5yKnNjcm9sbFkgKyB0aW1lKnNwZWVkO1xuICAgcmV0dXJuIGZyYWN0KF9zdCk7YFxufSxcbntcbiAgbmFtZTogJ2FkZCcsXG4gIHR5cGU6ICdjb21iaW5lJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIChfYzArX2MxKSphbW91bnQgKyBfYzAqKDEuMC1hbW91bnQpO2Bcbn0sXG57XG4gIG5hbWU6ICdzdWInLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiAoX2MwLV9jMSkqYW1vdW50ICsgX2MwKigxLjAtYW1vdW50KTtgXG59LFxue1xuICBuYW1lOiAnbGF5ZXInLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQobWl4KF9jMC5yZ2IsIF9jMS5yZ2IsIF9jMS5hKSwgY2xhbXAoX2MwLmEgKyBfYzEuYSwgMC4wLCAxLjApKTtgXG59LFxue1xuICBuYW1lOiAnYmxlbmQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIF9jMCooMS4wLWFtb3VudCkrX2MxKmFtb3VudDtgXG59LFxue1xuICBuYW1lOiAnbXVsdCcsXG4gIHR5cGU6ICdjb21iaW5lJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIF9jMCooMS4wLWFtb3VudCkrKF9jMCpfYzEpKmFtb3VudDtgXG59LFxue1xuICBuYW1lOiAnZGlmZicsXG4gIHR5cGU6ICdjb21iaW5lJyxcbiAgaW5wdXRzOiBbXG5cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChhYnMoX2MwLnJnYi1fYzEucmdiKSwgbWF4KF9jMC5hLCBfYzEuYSkpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIC8vICByZXR1cm4gZnJhY3Qoc3QrKF9jMC54eS0wLjUpKmFtb3VudCk7XG4gICByZXR1cm4gX3N0ICsgX2MwLnh5KmFtb3VudDtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVTY2FsZScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ211bHRpcGxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSBfc3QgLSB2ZWMyKDAuNSk7XG4gICB4eSo9KDEuMC92ZWMyKG9mZnNldCArIG11bHRpcGxlKl9jMC5yLCBvZmZzZXQgKyBtdWx0aXBsZSpfYzAuZykpO1xuICAgeHkrPXZlYzIoMC41KTtcbiAgIHJldHVybiB4eTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVQaXhlbGF0ZScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ211bHRpcGxlJyxcbiAgICAgIGRlZmF1bHQ6IDEwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gdmVjMihvZmZzZXQgKyBfYzAueCptdWx0aXBsZSwgb2Zmc2V0ICsgX2MwLnkqbXVsdGlwbGUpO1xuICAgcmV0dXJuIChmbG9vcihfc3QgKiB4eSkgKyAwLjUpL3h5O2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJvdGF0ZScsXG4gIHR5cGU6ICdjb21iaW5lQ29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ211bHRpcGxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSBfc3QgLSB2ZWMyKDAuNSk7XG4gICBmbG9hdCBhbmdsZSA9IG9mZnNldCArIF9jMC54ICogbXVsdGlwbGU7XG4gICB4eSA9IG1hdDIoY29zKGFuZ2xlKSwtc2luKGFuZ2xlKSwgc2luKGFuZ2xlKSxjb3MoYW5nbGUpKSp4eTtcbiAgIHh5ICs9IDAuNTtcbiAgIHJldHVybiB4eTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVIdWUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIF9zdCArICh2ZWMyKF9jMC5nIC0gX2MwLnIsIF9jMC5iIC0gX2MwLmcpICogYW1vdW50ICogMS4wL3Jlc29sdXRpb24pO2Bcbn0sXG57XG4gIG5hbWU6ICdpbnZlcnQnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNCgoMS4wLV9jMC5yZ2IpKmFtb3VudCArIF9jMC5yZ2IqKDEuMC1hbW91bnQpLCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ2NvbnRyYXN0JyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMS42LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMgPSAoX2MwLXZlYzQoMC41KSkqdmVjNChhbW91bnQpICsgdmVjNCgwLjUpO1xuICAgcmV0dXJuIHZlYzQoYy5yZ2IsIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnYnJpZ2h0bmVzcycsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDAuNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLnJnYiArIHZlYzMoYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdtYXNrJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcblxuICBdLFxuICBnbHNsOlxuICBgICAgZmxvYXQgYSA9IF9sdW1pbmFuY2UoX2MxLnJnYik7XG4gIHJldHVybiB2ZWM0KF9jMC5yZ2IqYSwgYSpfYzAuYSk7YFxufSxcblxue1xuICBuYW1lOiAnbHVtYScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndGhyZXNob2xkJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd0b2xlcmFuY2UnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBmbG9hdCBhID0gc21vb3Roc3RlcCh0aHJlc2hvbGQtKHRvbGVyYW5jZSswLjAwMDAwMDEpLCB0aHJlc2hvbGQrKHRvbGVyYW5jZSswLjAwMDAwMDEpLCBfbHVtaW5hbmNlKF9jMC5yZ2IpKTtcbiAgIHJldHVybiB2ZWM0KF9jMC5yZ2IqYSwgYSk7YFxufSxcbntcbiAgbmFtZTogJ3RocmVzaCcsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndGhyZXNob2xkJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd0b2xlcmFuY2UnLFxuICAgICAgZGVmYXVsdDogMC4wNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQodmVjMyhzbW9vdGhzdGVwKHRocmVzaG9sZC0odG9sZXJhbmNlKzAuMDAwMDAwMSksIHRocmVzaG9sZCsodG9sZXJhbmNlKzAuMDAwMDAwMSksIF9sdW1pbmFuY2UoX2MwLnJnYikpKSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb2xvcicsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncicsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2cnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMgPSB2ZWM0KHIsIGcsIGIsIGEpO1xuICAgdmVjNCBwb3MgPSBzdGVwKDAuMCwgYyk7IC8vIGRldGVjdCB3aGV0aGVyIG5lZ2F0aXZlXG4gICAvLyBpZiA+IDAsIHJldHVybiByICogX2MwXG4gICAvLyBpZiA8IDAgcmV0dXJuICgxLjAtcikgKiBfYzBcbiAgIHJldHVybiB2ZWM0KG1peCgoMS4wLV9jMCkqYWJzKGMpLCBjKl9jMCwgcG9zKSk7YFxufSxcbntcbiAgbmFtZTogJ3NhdHVyYXRlJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMixcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcbiAgIHZlYzMgaW50ZW5zaXR5ID0gdmVjMyhkb3QoX2MwLnJnYiwgVykpO1xuICAgcmV0dXJuIHZlYzQobWl4KGludGVuc2l0eSwgX2MwLnJnYiwgYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdodWUnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2h1ZScsXG4gICAgICBkZWZhdWx0OiAwLjQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzMgYyA9IF9yZ2JUb0hzdihfYzAucmdiKTtcbiAgIGMuciArPSBodWU7XG4gICAvLyAgYy5yID0gZnJhY3QoYy5yKTtcbiAgIHJldHVybiB2ZWM0KF9oc3ZUb1JnYihjKSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb2xvcmFtYScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDAuMDA1LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMzIGMgPSBfcmdiVG9Ic3YoX2MwLnJnYik7XG4gICBjICs9IHZlYzMoYW1vdW50KTtcbiAgIGMgPSBfaHN2VG9SZ2IoYyk7XG4gICBjID0gZnJhY3QoYyk7XG4gICByZXR1cm4gdmVjNChjLCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ3ByZXYnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG5cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdGV4dHVyZTJEKHByZXZCdWZmZXIsIGZyYWN0KF9zdCkpO2Bcbn0sXG57XG4gIG5hbWU6ICdzdW0nLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAndmVjNCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCB2ID0gX2MwICogcztcbiAgIHJldHVybiB2LnIgKyB2LmcgKyB2LmIgKyB2LmE7XG4gICB9XG4gICBmbG9hdCBzdW0odmVjMiBfc3QsIHZlYzQgcykgeyAvLyB2ZWM0IGlzIG5vdCBhIHR5cG8sIGJlY2F1c2UgYXJndW1lbnQgdHlwZSBpcyBub3Qgb3ZlcmxvYWRlZFxuICAgdmVjMiB2ID0gX3N0Lnh5ICogcy54eTtcbiAgIHJldHVybiB2LnggKyB2Lnk7YFxufSxcbntcbiAgbmFtZTogJ3InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5yICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG57XG4gIG5hbWU6ICdnJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuZyAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICBuYW1lOiAnYicsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLmIgKiBzY2FsZSArIG9mZnNldCk7YFxufSxcbntcbiAgbmFtZTogJ2EnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5hICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG57XG4gICAgbmFtZTogJ21hcCcsXG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICAge25hbWU6ICdzdGFydDEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiBOYU59LFxuICAgICAgICB7bmFtZTogJ3N0b3AxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogTmFOfSxcbiAgICAgICAge25hbWU6ICdzdGFydDInLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwfSxcbiAgICAgICAge25hbWU6ICdzdG9wMicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDF9LFxuICAgIF0sXG4gICAgZ2xzbDogYHJldHVybiAoX2MwIC0gc3RhcnQxKSAvIChzdG9wMSAtIHN0YXJ0MSkgKiAoc3RvcDIgLSBzdGFydDIpICsgc3RhcnQyO2Bcbn0sXG4gICAgLy8gdG9kbzogbWFrZSB0aGVzZSB0eXBlIGFnbm9zdGljIChuZXcgdHlwZTogJ3V0aWwnPylcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzaW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19zaW4nLFxuICAgICAgICB0eXBlOiAnY29vcmQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZnJlcScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIHNpbihfc3QgKiBUV09fUEkgKiBmcmVxKSAqIGFtcDtgLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnY29zJyxcbiAgICAgICAgZ2xzbE5hbWU6ICdfY29zJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb3MoX3N0ICogVFdPX1BJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3RhbicsXG4gICAgICAgIGdsc2xOYW1lOiAnX3RhbicsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdmcmVxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2F0YW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19hdGFuJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBhdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3BvdycsXG4gICAgICAgIGdsc2xOYW1lOiAnX3BvdycsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3dlcicsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogMn0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gcG93KF9zdCwgcG93ZXIpO2BcbiAgICB9XG5dXG4iLCIvLyBmdW5jdGlvbnMgdGhhdCBhcmUgb25seSB1c2VkIHdpdGhpbiBvdGhlciBmdW5jdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfcGk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYCNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1YCxcbiAgfSxcbiAgX3R3b3BpOiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGAjZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE3OTU4NmAsXG4gIH0sXG4gIF9sdW1pbmFuY2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYGZsb2F0IF9sdW1pbmFuY2UodmVjMyByZ2Ipe1xuICAgICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcbiAgICAgIHJldHVybiBkb3QocmdiLCBXKTtcbiAgICB9YFxuICB9LFxuICBfcGVybXV0ZToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgdmVjNCBfcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31gXG4gIH0sXG4gIF9tb2QyODk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxudmVjMyBfbW9kMjg5KHZlYzMgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cblxudmVjNCBfbW9kMjg5KHZlYzQgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cbmBcbiAgfSxcbiAgX3RheWxvckludlNxcnQ6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzQgX3RheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31gXG4gIH0sXG4gIC8vXHRTaW1wbGV4IDNEIE5vaXNlXG4gIC8vXHRieSBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0c1xuICBfbm9pc2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxuICBmbG9hdCBfbm9pc2UodmVjMyB2KXtcbiAgICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XG4gICAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcblxuICAvLyBGaXJzdCBjb3JuZXJcbiAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcbiAgICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xuXG4gIC8vIE90aGVyIGNvcm5lcnNcbiAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcbiAgICB2ZWMzIGwgPSAxLjAgLSBnO1xuICAgIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xuICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xuXG4gICAgLy8gIHgwID0geDAgLSAwLiArIDAuMCAqIENcbiAgICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xuICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgMi4wICogQy54eHg7XG4gICAgdmVjMyB4MyA9IHgwIC0gMS4gKyAzLjAgKiBDLnh4eDtcblxuICAvLyBQZXJtdXRhdGlvbnNcbiAgICBpID0gbW9kKGksIDI4OS4wICk7XG4gICAgdmVjNCBwID0gX3Blcm11dGUoIF9wZXJtdXRlKCBfcGVybXV0ZShcbiAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XG5cbiAgLy8gR3JhZGllbnRzXG4gIC8vICggTipOIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi4pXG4gICAgZmxvYXQgbl8gPSAxLjAvNy4wOyAvLyBOPTdcbiAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcblxuICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKm5zLnopOyAgLy8gIG1vZChwLE4qTilcblxuICAgIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XG4gICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxuXG4gICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xuICAgIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcbiAgICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XG5cbiAgICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xuICAgIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XG5cbiAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcbiAgICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcbiAgICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcblxuICAgIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcbiAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XG5cbiAgICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xuICAgIHZlYzMgcDEgPSB2ZWMzKGEwLnp3LGgueSk7XG4gICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcbiAgICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xuXG4gIC8vTm9ybWFsaXNlIGdyYWRpZW50c1xuICAgIHZlYzQgbm9ybSA9IF90YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcbiAgICBwMCAqPSBub3JtLng7XG4gICAgcDEgKj0gbm9ybS55O1xuICAgIHAyICo9IG5vcm0uejtcbiAgICBwMyAqPSBub3JtLnc7XG5cbiAgLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXG4gICAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XG4gICAgbSA9IG0gKiBtO1xuICAgIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XG4gIH1cbiAgICBgXG4gIH0sXG5cbiAgX3JnYlRvSHN2OiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGB2ZWMzIF9yZ2JUb0hzdih2ZWMzIGMpe1xuICAgICAgICAgICAgdmVjNCBLID0gdmVjNCgwLjAsIC0xLjAgLyAzLjAsIDIuMCAvIDMuMCwgLTEuMCk7XG4gICAgICAgICAgICB2ZWM0IHAgPSBtaXgodmVjNChjLmJnLCBLLnd6KSwgdmVjNChjLmdiLCBLLnh5KSwgc3RlcChjLmIsIGMuZykpO1xuICAgICAgICAgICAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIGMuciksIHZlYzQoYy5yLCBwLnl6eCksIHN0ZXAocC54LCBjLnIpKTtcblxuICAgICAgICAgICAgZmxvYXQgZCA9IHEueCAtIG1pbihxLncsIHEueSk7XG4gICAgICAgICAgICBmbG9hdCBlID0gMS4wZS0xMDtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzKGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgZSkpLCBkIC8gKHEueCArIGUpLCBxLngpO1xuICAgICAgICB9YFxuICB9LFxuICBfaHN2VG9SZ2I6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzMgX2hzdlRvUmdiKHZlYzMgYyl7XG4gICAgICAgIHZlYzQgSyA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcbiAgICAgICAgdmVjMyBwID0gYWJzKGZyYWN0KGMueHh4ICsgSy54eXopICogNi4wIC0gSy53d3cpO1xuICAgICAgICByZXR1cm4gYy56ICogbWl4KEsueHh4LCBjbGFtcChwIC0gSy54eHgsIDAuMCwgMS4wKSwgYy55KTtcbiAgICB9YFxuICB9XG59XG4iLCJpbXBvcnQgZ2xzbCBmcm9tICdnbHNsaWZ5J1xuaW1wb3J0IHtHcmlkR2VvbWV0cnl9IGZyb20gXCIuL2dlb21ldHJpZXMvR3JpZEdlb21ldHJ5LmpzXCI7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWUvc3JjL2dlb21ldHJpZXMvR2VvbWV0cmllcy5qc1wiO1xuaW1wb3J0IHZlY3Rvcml6ZVRleHQgZnJvbSBcInZlY3Rvcml6ZS10ZXh0XCI7XG5cbmNvbnN0IHBvaW50c1ZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvcG9pbnRzLnZlcnRcIik7XG5jb25zdCBsaW5lc1ZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZXMudmVydFwiKTtcbmNvbnN0IGxpbmVzdHJpcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZXN0cmlwLnZlcnRcIik7XG5jb25zdCBsaW5lbG9vcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZWxvb3AudmVydFwiKTtcblxuY29uc3QgcGRvdHNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9wZG90cy5mcmFnXCIpO1xuY29uc3QgcHNxdWFyZXNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9wc3F1YXJlcy5mcmFnXCIpO1xuY29uc3QgcGxpbmVzRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVzLmZyYWdcIik7XG5jb25zdCBwbGluZXN0cmlwRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVzdHJpcC5mcmFnXCIpO1xuY29uc3QgcGxpbmVsb29wRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVsb29wLmZyYWdcIik7XG5jb25zdCBwbGFuZVZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3BsYW5lLnZlcnRcIik7XG5jb25zdCBwaG9uZ0ZyYWcgPSBnbHNsKFwiLi9zaGFkZXJzL3Bob25nLmZyYWdcIik7XG5jb25zdCBsYW1iZXJ0RnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvbGFtYmVydC5mcmFnXCIpO1xuXG4vLyB0b2RvOiByZXNwZWN0IG1ha2VHbG9iYWw/XG5PYmplY3QuYXNzaWduKHdpbmRvdywge0dyaWRHZW9tZXRyeSwgdmVjdG9yaXplVGV4dH0pO1xuT2JqZWN0LmFzc2lnbih3aW5kb3csIFRIUkVFKTtcblxuZXhwb3J0IGRlZmF1bHQgKGh5KSA9PiBbXG4gICAge1xuICAgICAgICBuYW1lOiAncGRvdHMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdzaXplJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMTB9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2ZhZGUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjAyNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBkb3RzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncHNxdWFyZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdzaXplJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnZmFkZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMDI1fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogcHNxdWFyZXNGcmFnLFxuICAgICAgICB2ZXJ0OiBwb2ludHNWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdwb2ludHMnLFxuICAgICAgICBibGVuZE1vZGU6IHRydWUsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwbGluZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBsaW5lc0ZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAnbGluZXMnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncGxpbmVzdHJpcCcsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuc29saWQoaHkubm9pc2UoMSkueCwgaHkubm9pc2UoMikueSwgaHkubm9pc2UoMykueikubWFwKC0xLDEsMCwxKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogcGxpbmVzdHJpcEZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzdHJpcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgc3RyaXAnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncGxpbmVsb29wJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBoeS5zb2xpZChoeS5ub2lzZSgxKS54LCBoeS5ub2lzZSgyKS55LCBoeS5ub2lzZSgzKS56KS5tYXAoLTEsMSwwLDEpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBwbGluZWxvb3BGcmFnLFxuICAgICAgICB2ZXJ0OiBsaW5lbG9vcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgbG9vcCcsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwbGFuZScsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuZ3JhZGllbnQoKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICB2ZXJ0OiBwbGFuZVZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgICAgIGdlb21ldHJ5OiBUSFJFRS5QbGFuZUdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnYm94JyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgICAgIGdlb21ldHJ5OiBUSFJFRS5Cb3hHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NwaGVyZScsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgICAgICBnZW9tZXRyeTogVEhSRUUuU3BoZXJlR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdjeWxpbmRlcicsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgICAgICBnZW9tZXRyeTogVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2NvbmUnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gY29sb3I7YCxcbiAgICAgICAgcHJpbWl0aXZlOiAndHJpYW5nbGVzJyxcbiAgICAgICAgZ2VvbWV0cnk6IFRIUkVFLkNvbmVHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2VkZ2VzJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmVzJyxcbiAgICAgICAgZ2VvbWV0cnk6IFRIUkVFLkVkZ2VzR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIGdlb21ldHJ5OiB2ZWN0b3JpemVUZXh0LFxuICAgICAgICB1c2VVVjogZmFsc2UsXG4gICAgICAgIHVzZU5vcm1hbDogZmFsc2UsXG4gICAgfSxcbiAgICAvLyBsaWdodGluZyByZWxhdGVkIGZ1bmN0aW9uc1xuICAgIHtcbiAgICAgICAgbmFtZTogJ2xhbWJlcnQnLFxuICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnaW50ZW5zaXR5JywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xpZ2h0RGlyZWN0aW9uJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBbMS4wLCAxLjAsIC0xLjBdfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogbGFtYmVydEZyYWcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwaG9uZycsXG4gICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdzaGluaW5lc3MnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiA0fSxcbiAgICAgICAgICAgIHtuYW1lOiAnbGlnaHREaXJlY3Rpb24nLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFsxLjAsIDEuMCwgLTEuMF19LFxuICAgICAgICAgICAge25hbWU6ICdsaWdodENvbG9yJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBbMS4wLCAxLjAsIDEuMF19LFxuICAgICAgICAgICAge25hbWU6ICdhbWJpZW50Q29sb3InLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFswLjEsIDAuMSwgMC4xXX0sXG4gICAgICAgICAgICB7bmFtZTogJ3NwZWN1bGFyQ29sb3InLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFsxLjAsIDEuMCwgMS4wXX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBob25nRnJhZyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ25vcm1hbCcsXG4gICAgICAgIHR5cGU6ICdzcmMnLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIHZlYzQodm5vcm1hbCwgMS4wKTtgLFxuICAgIH0sXG5dO1xuIiwiaW1wb3J0IFdlYmNhbSBmcm9tICcuL2xpYi93ZWJjYW0uanMnXG5pbXBvcnQgU2NyZWVuIGZyb20gJy4vbGliL3NjcmVlbm1lZGlhLmpzJ1xuXG5jbGFzcyBIeWRyYVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yICh7IHJlZ2wsIHdpZHRoLCBoZWlnaHQsIHBiLCBsYWJlbCA9IFwiXCJ9KSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsXG4gICAgdGhpcy5yZWdsID0gcmVnbFxuICAgIHRoaXMuc3JjID0gbnVsbFxuICAgIHRoaXMuZHluYW1pYyA9IHRydWVcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoe1xuICAgICAgLy8gIHNoYXBlOiBbd2lkdGgsIGhlaWdodF1cbiAgICAgIHNoYXBlOiBbIDEsIDEgXVxuICAgIH0pXG4gICAgdGhpcy5wYiA9IHBiXG4gIH1cblxuICBpbml0IChvcHRzLCBwYXJhbXMpIHtcbiAgICBpZiAoJ3NyYycgaW4gb3B0cykge1xuICAgICAgdGhpcy5zcmMgPSBvcHRzLnNyY1xuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXMgfSlcbiAgICB9XG4gICAgaWYgKCdkeW5hbWljJyBpbiBvcHRzKSB0aGlzLmR5bmFtaWMgPSBvcHRzLmR5bmFtaWNcbiAgfVxuXG4gIGluaXRDYW0gKGluZGV4LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIFdlYmNhbShpbmRleClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgc2VsZi5zcmMgPSByZXNwb25zZS52aWRlb1xuICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygnY291bGQgbm90IGdldCBjYW1lcmEnLCBlcnIpKVxuICB9XG5cbiAgaW5pdFZpZGVvICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgLy8gY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCB2aWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgdmlkLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICB2aWQuYXV0b3BsYXkgPSB0cnVlXG4gICAgdmlkLmxvb3AgPSB0cnVlXG4gICAgdmlkLm11dGVkID0gdHJ1ZSAvLyBtdXRlIGluIG9yZGVyIHRvIGxvYWQgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3Qgb25sb2FkID0gdmlkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNyYyA9IHZpZFxuICAgICAgdmlkLnBsYXkoKVxuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgdGhpcy5keW5hbWljID0gdHJ1ZVxuICAgIH0pXG4gICAgdmlkLnNyYyA9IHVybFxuICB9XG5cbiAgaW5pdEltYWdlICh1cmwgPSAnJywgcGFyYW1zKSB7XG4gICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgIGltZy5zcmMgPSB1cmxcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zcmMgPSBpbWdcbiAgICAgIHRoaXMuZHluYW1pYyA9IGZhbHNlXG4gICAgICB0aGlzLnRleCA9IHRoaXMucmVnbC50ZXh0dXJlKHsgZGF0YTogdGhpcy5zcmMsIC4uLnBhcmFtc30pXG4gICAgfVxuICB9XG5cbiAgaW5pdFN0cmVhbSAoc3RyZWFtTmFtZSwgcGFyYW1zKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKFwiaW5pdGluZyBzdHJlYW0hXCIsIHN0cmVhbU5hbWUpXG4gICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgaWYgKHN0cmVhbU5hbWUgJiYgdGhpcy5wYikge1xuICAgICAgdGhpcy5wYi5pbml0U291cmNlKHN0cmVhbU5hbWUpXG5cbiAgICAgIHRoaXMucGIub24oJ2dvdCB2aWRlbycsIGZ1bmN0aW9uIChuaWNrLCB2aWRlbykge1xuICAgICAgICBpZiAobmljayA9PT0gc3RyZWFtTmFtZSkge1xuICAgICAgICAgIHNlbGYuc3JjID0gdmlkZW9cbiAgICAgICAgICBzZWxmLmR5bmFtaWMgPSB0cnVlXG4gICAgICAgICAgc2VsZi50ZXggPSBzZWxmLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHNlbGYuc3JjLCAuLi5wYXJhbXN9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGluZGV4IG9ubHkgcmVsZXZhbnQgaW4gYXRvbS1oeWRyYSArIGRlc2t0b3AgYXBwc1xuICBpbml0U2NyZWVuIChpbmRleCA9IDAsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgU2NyZWVuKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBzZWxmLnNyYyA9IHJlc3BvbnNlLnZpZGVvXG4gICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zfSlcbiAgICAgICAgc2VsZi5keW5hbWljID0gdHJ1ZVxuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJyZWNlaXZlZCBzY3JlZW4gaW5wdXRcIilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKCdjb3VsZCBub3QgZ2V0IHNjcmVlbicsIGVycikpXG4gIH1cblxuICByZXNpemUgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNyYyAmJiB0aGlzLnNyYy5zcmNPYmplY3QpIHtcbiAgICAgIGlmICh0aGlzLnNyYy5zcmNPYmplY3QuZ2V0VHJhY2tzKSB7XG4gICAgICAgIHRoaXMuc3JjLnNyY09iamVjdC5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcmMgPSBudWxsXG4gICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IHNoYXBlOiBbIDEsIDEgXSB9KVxuICB9XG5cbiAgdGljayAodGltZSkge1xuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnNyYywgdGhpcy50ZXgud2lkdGgsIHRoaXMudGV4LmhlaWdodClcbiAgICBpZiAodGhpcy5zcmMgIT09IG51bGwgJiYgdGhpcy5keW5hbWljID09PSB0cnVlKSB7XG4gICAgICBpZiAodGhpcy5zcmMudmlkZW9XaWR0aCAmJiB0aGlzLnNyYy52aWRlb1dpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICB0aGlzLnNyYy52aWRlb1dpZHRoLFxuICAgICAgICAgIHRoaXMuc3JjLnZpZGVvSGVpZ2h0LFxuICAgICAgICAgIHRoaXMudGV4LndpZHRoLFxuICAgICAgICAgIHRoaXMudGV4LmhlaWdodFxuICAgICAgICApXG4gICAgICAgIHRoaXMudGV4LnJlc2l6ZSh0aGlzLnNyYy52aWRlb1dpZHRoLCB0aGlzLnNyYy52aWRlb0hlaWdodClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3JjLndpZHRoICYmIHRoaXMuc3JjLndpZHRoICE9PSB0aGlzLnRleC53aWR0aCkge1xuICAgICAgICB0aGlzLnRleC5yZXNpemUodGhpcy5zcmMud2lkdGgsIHRoaXMuc3JjLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXguc3ViaW1hZ2UodGhpcy5zcmMpXG4gICAgfVxuICB9XG5cbiAgZ2V0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSHlkcmFTb3VyY2VcbiIsIlxuaW1wb3J0IE91dHB1dCBmcm9tICcuL291dHB1dC5qcydcbmltcG9ydCBsb29wIGZyb20gJ3JhZi1sb29wJ1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuL2h5ZHJhLXNvdXJjZS5qcydcbmltcG9ydCBNb3VzZVRvb2xzIGZyb20gJy4vbGliL21vdXNlLmpzJ1xuaW1wb3J0IEF1ZGlvIGZyb20gJy4vbGliL2F1ZGlvLmpzJ1xuaW1wb3J0IFZpZFJlY29yZGVyIGZyb20gJy4vbGliL3ZpZGVvLXJlY29yZGVyLmpzJ1xuaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG4vLyBpbXBvcnQgc3RydWRlbCBmcm9tICcuL2xpYi9zdHJ1ZGVsLmpzJ1xuaW1wb3J0IFNhbmRib3ggZnJvbSAnLi9ldmFsLXNhbmRib3guanMnXG5pbXBvcnQgR2VuZXJhdG9yIGZyb20gJy4vZ2VuZXJhdG9yLWZhY3RvcnkuanMnXG5pbXBvcnQgcmVnbCBmcm9tICdyZWdsJ1xuLy8gY29uc3Qgd2luZG93ID0gZ2xvYmFsLndpbmRvd1xuXG5cblxuY29uc3QgTW91c2UgPSBNb3VzZVRvb2xzKClcbi8vIHRvIGRvOiBhZGQgYWJpbGl0eSB0byBwYXNzIGluIGNlcnRhaW4gdW5pZm9ybXMgYW5kIHRyYW5zZm9ybXNcbmNsYXNzIEh5ZHJhUmVuZGVyZXIge1xuXG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcGIgPSBudWxsLFxuICAgIHdpZHRoID0gMTI4MCxcbiAgICBoZWlnaHQgPSA3MjAsXG4gICAgbnVtU291cmNlcyA9IDQsXG4gICAgbnVtT3V0cHV0cyA9IDQsXG4gICAgbWFrZUdsb2JhbCA9IHRydWUsXG4gICAgYXV0b0xvb3AgPSB0cnVlLFxuICAgIGRldGVjdEF1ZGlvID0gdHJ1ZSxcbiAgICBlbmFibGVTdHJlYW1DYXB0dXJlID0gdHJ1ZSxcbiAgICBjYW52YXMsXG4gICAgcHJlY2lzaW9uLFxuICAgIGV4dGVuZFRyYW5zZm9ybXMgPSB7fSAvLyBhZGQgeW91ciBvd24gZnVuY3Rpb25zIG9uIGluaXRcbiAgfSA9IHt9KSB7XG5cbiAgICBBcnJheVV0aWxzLmluaXQoKVxuXG4gICAgdGhpcy5wYiA9IHBiXG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMucmVuZGVyQWxsID0gZmFsc2VcbiAgICB0aGlzLmRldGVjdEF1ZGlvID0gZGV0ZWN0QXVkaW9cblxuICAgIHRoaXMuX2luaXRDYW52YXMoY2FudmFzKVxuXG4gICAgLy9nbG9iYWwud2luZG93LnRlc3QgPSAnaGknXG4gICAgLy8gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIG1hZGUgYXZhaWxhYmxlIG9uIHRoZSBnbG9iYWwgY29udGV4dCBhbmQgZHVyaW5nIGxvY2FsIGV2YWx1YXRpb25cbiAgICB0aGlzLnN5bnRoID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIGJwbTogMzAsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBmcHM6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIGZwczogMFxuICAgICAgfSxcbiAgICAgIHNwZWVkOiAxLFxuICAgICAgbW91c2U6IE1vdXNlLFxuICAgICAgcmVuZGVyOiB0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSxcbiAgICAgIHNldFJlc29sdXRpb246IHRoaXMuc2V0UmVzb2x1dGlvbi5iaW5kKHRoaXMpLFxuICAgICAgdXBkYXRlOiAoZHQpID0+IHt9LC8vIHVzZXIgZGVmaW5lZCB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGh1c2g6IHRoaXMuaHVzaC5iaW5kKHRoaXMpLFxuICAgICAgdGljazogdGhpcy50aWNrLmJpbmQodGhpcylcbiAgICB9XG5cbiAgICBpZiAobWFrZUdsb2JhbCkgd2luZG93LmxvYWRTY3JpcHQgPSB0aGlzLmxvYWRTY3JpcHRcblxuXG4gICAgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlID0gMFxuICAgIHRoaXMuX3RpbWUgPSAwIC8vIGZvciBpbnRlcm5hbCB1c2UsIG9ubHkgdG8gdXNlIGZvciBkZWNpZGluZyB3aGVuIHRvIHJlbmRlciBmcmFtZXNcblxuICAgIC8vIG9ubHkgYWxsb3cgdmFsaWQgcHJlY2lzaW9uIG9wdGlvbnNcbiAgICBsZXQgcHJlY2lzaW9uT3B0aW9ucyA9IFsnbG93cCcsJ21lZGl1bXAnLCdoaWdocCddXG4gICAgaWYocHJlY2lzaW9uICYmIHByZWNpc2lvbk9wdGlvbnMuaW5jbHVkZXMocHJlY2lzaW9uLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbi50b0xvd2VyQ2FzZSgpXG4gICAgICAvL1xuICAgICAgLy8gaWYoIXByZWNpc2lvblZhbGlkKXtcbiAgICAgIC8vICAgY29uc29sZS53YXJuKCdbaHlkcmEtc3ludGggd2FybmluZ11cXG5Db25zdHJ1Y3RvciB3YXMgcHJvdmlkZWQgYW4gaW52YWxpZCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gdmFsdWUgb2YgXCInICsgcHJlY2lzaW9uICsgJ1wiLiBVc2luZyBkZWZhdWx0IHZhbHVlIG9mIFwibWVkaXVtcFwiIGluc3RlYWQuJylcbiAgICAgIC8vIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlzSU9TID1cbiAgICAoL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSB8fFxuICAgICAgKG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKSkgJiZcbiAgICAhd2luZG93Lk1TU3RyZWFtO1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBpc0lPUyA/ICdoaWdocCcgOiAnbWVkaXVtcCdcbiAgICB9XG5cblxuXG4gICAgdGhpcy5leHRlbmRUcmFuc2Zvcm1zID0gZXh0ZW5kVHJhbnNmb3Jtc1xuXG4gICAgLy8gYm9vbGVhbiB0byBzdG9yZSB3aGVuIHRvIHNhdmUgc2NyZWVuc2hvdFxuICAgIHRoaXMuc2F2ZUZyYW1lID0gZmFsc2VcblxuICAgIC8vIGlmIHN0cmVhbSBjYXB0dXJlIGlzIGVuYWJsZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSBjYXB0dXJlIHN0cmVhbVxuICAgIHRoaXMuY2FwdHVyZVN0cmVhbSA9IG51bGxcblxuICAgIHRoaXMuZ2VuZXJhdG9yID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9pbml0UmVnbCgpXG4gICAgdGhpcy5faW5pdE91dHB1dHMobnVtT3V0cHV0cylcbiAgICB0aGlzLl9pbml0U291cmNlcyhudW1Tb3VyY2VzKVxuICAgIHRoaXMuX2dlbmVyYXRlR2xzbFRyYW5zZm9ybXMoKVxuXG4gICAgdGhpcy5zeW50aC5zY3JlZW5jYXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNhdmVGcmFtZSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlU3RyZWFtQ2FwdHVyZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jYXB0dXJlU3RyZWFtID0gdGhpcy5jYW52YXMuY2FwdHVyZVN0cmVhbSgyNSlcbiAgICAgICAgLy8gdG8gZG86IGVuYWJsZSBjYXB0dXJlIHN0cmVhbSBvZiBzcGVjaWZpYyBzb3VyY2VzIGFuZCBvdXRwdXRzXG4gICAgICAgIHRoaXMuc3ludGgudmlkUmVjb3JkZXIgPSBuZXcgVmlkUmVjb3JkZXIodGhpcy5jYXB0dXJlU3RyZWFtKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1toeWRyYS1zeW50aCB3YXJuaW5nXVxcbm5ldyBNZWRpYVNvdXJjZSgpIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIG9uIGlPUy4nKVxuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZGV0ZWN0QXVkaW8pIHRoaXMuX2luaXRBdWRpbygpXG5cbiAgICBpZihhdXRvTG9vcCkgbG9vcCh0aGlzLnRpY2suYmluZCh0aGlzKSkuc3RhcnQoKVxuXG4gICAgLy8gZmluYWwgYXJndW1lbnQgaXMgcHJvcGVydGllcyB0aGF0IHRoZSB1c2VyIGNhbiBzZXQsIGFsbCBvdGhlcnMgYXJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5XG4gICAgdGhpcy5zYW5kYm94ID0gbmV3IFNhbmRib3godGhpcy5zeW50aCwgbWFrZUdsb2JhbCwgWydzcGVlZCcsICd1cGRhdGUnLCAnYnBtJywgJ2ZwcyddKVxuICB9XG5cbiAgZXZhbChjb2RlKSB7XG4gICAgdGhpcy5zYW5kYm94LmV2YWwoY29kZSlcbiAgfVxuXG4gIGdldFNjcmVlbkltYWdlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbWFnZUNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnNhdmVGcmFtZSA9IHRydWVcbiAgfVxuXG4gIGh1c2goKSB7XG4gICAgdGhpcy5zLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgc291cmNlLmNsZWFyKClcbiAgICB9KVxuICAgIHRoaXMuby5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIHRoaXMuc3ludGguc29saWQoMCwgMCwgMCwgMCkub3V0KG91dHB1dClcbiAgICB9KVxuICAgIHRoaXMuc3ludGgucmVuZGVyKHRoaXMub1swXSlcbiAgICAvLyB0aGlzLnN5bnRoLnVwZGF0ZSA9IChkdCkgPT4ge31cbiAgICB0aGlzLnNhbmRib3guc2V0KCd1cGRhdGUnLCAoZHQpID0+IHt9KVxuICB9XG5cbiAgbG9hZFNjcmlwdCh1cmwgPSBcIlwiLCBvbmNlID0gdHJ1ZSkge1xuICAgY29uc3Qgc2VsZiA9IHRoaXMgfHwgd2luZG93O1xuICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICBpZiAob25jZSkge1xuICAgICAgIHNlbGYubG9hZGVkU2NyaXB0cyB8fCAoc2VsZi5sb2FkZWRTY3JpcHRzID0ge30pO1xuICAgICAgIGlmIChzZWxmLmxvYWRlZFNjcmlwdHNbdXJsXSkge1xuICAgICAgICAgcmVzKCk7XG4gICAgICAgICByZXR1cm47XG4gICAgICAgfVxuICAgICB9XG4gICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgIGNvbnNvbGUubG9nKGBsb2FkZWQgc2NyaXB0ICR7dXJsfWApO1xuICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICBzZWxmLmxvYWRlZFNjcmlwdHNbdXJsXSA9IHRydWU7XG4gICAgICAgfVxuICAgICAgIHJlcygpO1xuICAgICB9O1xuICAgICBzY3JpcHQub25lcnJvciA9IChlcnIpID0+IHtcbiAgICAgICBjb25zb2xlLmxvZyhgZXJyb3IgbG9hZGluZyBzY3JpcHQgJHt1cmx9YCwgXCJsb2ctZXJyb3JcIik7XG4gICAgICAgcmVzKClcbiAgICAgfTtcbiAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgfSk7XG4gICByZXR1cm4gcDtcbiB9XG5cbiAgc2V0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vICBjb25zb2xlLmxvZyh3aWR0aCwgaGVpZ2h0KVxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLy8gaXMgdGhpcyBuZWNlc3Nhcnk/XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLy8gP1xuICAgIHRoaXMuc2FuZGJveC5zZXQoJ3dpZHRoJywgd2lkdGgpXG4gICAgdGhpcy5zYW5kYm94LnNldCgnaGVpZ2h0JywgaGVpZ2h0KVxuICAgIHRoaXMuby5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIG91dHB1dC5yZXNpemUod2lkdGgsIGhlaWdodClcbiAgICB9KVxuICAgIHRoaXMucy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgIHNvdXJjZS5yZXNpemUod2lkdGgsIGhlaWdodClcbiAgICB9KVxuICAgIHRoaXMucmVnbC5fcmVmcmVzaCgpXG4gICAgIGNvbnNvbGUubG9nKHRoaXMuY2FudmFzLndpZHRoKVxuICB9XG5cbiAgY2FudmFzVG9JbWFnZSAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBsZXQgZCA9IG5ldyBEYXRlKClcbiAgICBhLmRvd25sb2FkID0gYGh5ZHJhLSR7ZC5nZXRGdWxsWWVhcigpfS0ke2QuZ2V0TW9udGgoKSArIDF9LSR7ZC5nZXREYXRlKCl9LSR7ZC5nZXRIb3VycygpfS4ke2QuZ2V0TWludXRlcygpfS4ke2QuZ2V0U2Vjb25kcygpfS5wbmdgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKVxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuY2FudmFzLnRvQmxvYiggKGJsb2IpID0+IHtcbiAgICAgICAgaWYoc2VsZi5pbWFnZUNhbGxiYWNrKXtcbiAgICAgICAgICBzZWxmLmltYWdlQ2FsbGJhY2soYmxvYilcbiAgICAgICAgICBkZWxldGUgc2VsZi5pbWFnZUNhbGxiYWNrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYS5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgICAgIGNvbnNvbGUubG9nKGEuaHJlZilcbiAgICAgICAgICBhLmNsaWNrKClcbiAgICAgICAgfVxuICAgIH0sICdpbWFnZS9wbmcnKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGEuaHJlZik7XG4gICAgfSwgMzAwKTtcbiAgfVxuXG4gIF9pbml0QXVkaW8gKCkge1xuICAgIGNvbnN0IHRoYXQgPSB0aGlzXG4gICAgdGhpcy5zeW50aC5hID0gbmV3IEF1ZGlvKHtcbiAgICAgIG51bUJpbnM6IDQsXG4gICAgICBwYXJlbnRFbDogdGhpcy5jYW52YXMucGFyZW50Tm9kZVxuICAgICAgLy8gY2hhbmdlTGlzdGVuZXI6ICh7YXVkaW99KSA9PiB7XG4gICAgICAvLyAgIHRoYXQuYSA9IGF1ZGlvLmJpbnMubWFwKChfLCBpbmRleCkgPT5cbiAgICAgIC8vICAgICAoc2NhbGUgPSAxLCBvZmZzZXQgPSAwKSA9PiAoKSA9PiAoYXVkaW8uZmZ0W2luZGV4XSAqIHNjYWxlICsgb2Zmc2V0KVxuICAgICAgLy8gICApXG4gICAgICAvL1xuICAgICAgLy8gICBpZiAodGhhdC5tYWtlR2xvYmFsKSB7XG4gICAgICAvLyAgICAgdGhhdC5hLmZvckVhY2goKGEsIGluZGV4KSA9PiB7XG4gICAgICAvLyAgICAgICBjb25zdCBhbmFtZSA9IGBhJHtpbmRleH1gXG4gICAgICAvLyAgICAgICB3aW5kb3dbYW5hbWVdID0gYVxuICAgICAgLy8gICAgIH0pXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gY3JlYXRlIG1haW4gb3V0cHV0IGNhbnZhcyBhbmQgYWRkIHRvIHNjcmVlblxuICBfaW5pdENhbnZhcyAoY2FudmFzKSB7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICAgIHRoaXMud2lkdGggPSBjYW52YXMud2lkdGhcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGhcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdwaXhlbGF0ZWQnXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKVxuICAgIH1cbiAgfVxuXG4gIF9pbml0UmVnbCAoKSB7XG4gICAgdGhpcy5yZWdsID0gcmVnbCh7XG4gICAgLy8gIHByb2ZpbGU6IHRydWUsXG4gICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgcGl4ZWxSYXRpbzogMS8vLFxuICAgICAgLy8gZXh0ZW5zaW9uczogW1xuICAgICAgLy8gICAnb2VzX3RleHR1cmVfaGFsZl9mbG9hdCcsXG4gICAgICAvLyAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcidcbiAgICAgIC8vIF0sXG4gICAgICAvLyBvcHRpb25hbEV4dGVuc2lvbnM6IFtcbiAgICAgIC8vICAgJ29lc190ZXh0dXJlX2Zsb2F0JyxcbiAgICAgIC8vICAgJ29lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcidcbiAgICAgLy9dXG4gICB9KVxuXG4gICAgLy8gVGhpcyBjbGVhcnMgdGhlIGNvbG9yIGJ1ZmZlciB0byBibGFjayBhbmQgdGhlIGRlcHRoIGJ1ZmZlciB0byAxXG4gICAgdGhpcy5yZWdsLmNsZWFyKHtcbiAgICAgIGNvbG9yOiBbMCwgMCwgMCwgMV1cbiAgICB9KVxuXG4gICAgdGhpcy5yZW5kZXJBbGwgPSB0aGlzLnJlZ2woe1xuICAgICAgZnJhZzogYFxuICAgICAgcHJlY2lzaW9uICR7dGhpcy5wcmVjaXNpb259IGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDE7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgyO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MztcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMiBzdCA9IHZlYzIoMS4wIC0gdXYueCwgdXYueSk7XG4gICAgICAgIHN0Kj0gdmVjMigyKTtcbiAgICAgICAgdmVjMiBxID0gZmxvb3Ioc3QpLnh5Kih2ZWMyKDIuMCwgMS4wKSk7XG4gICAgICAgIGludCBxdWFkID0gaW50KHEueCkgKyBpbnQocS55KTtcbiAgICAgICAgc3QueCArPSBzdGVwKDEuLCBtb2Qoc3QueSwyLjApKTtcbiAgICAgICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKTtcbiAgICAgICAgc3QgPSBmcmFjdChzdCk7XG4gICAgICAgIGlmKHF1YWQ9PTApe1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgwLCBzdCk7XG4gICAgICAgIH0gZWxzZSBpZihxdWFkPT0xKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MSwgc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHF1YWQ9PTIpe1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgyLCBzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDMsIHN0KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBgLFxuICAgICAgdmVydDogYFxuICAgICAgcHJlY2lzaW9uICR7dGhpcy5wcmVjaXNpb259IGZsb2F0O1xuICAgICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG4gICAgICB2YXJ5aW5nIHZlYzIgdXY7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHV2ID0gcG9zaXRpb247XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgxLjAgLSAyLjAgKiBwb3NpdGlvbiwgMCwgMSk7XG4gICAgICB9YCxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgcG9zaXRpb246IFtcbiAgICAgICAgICBbLTIsIDBdLFxuICAgICAgICAgIFswLCAtMl0sXG4gICAgICAgICAgWzIsIDJdXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB0ZXgwOiB0aGlzLnJlZ2wucHJvcCgndGV4MCcpLFxuICAgICAgICB0ZXgxOiB0aGlzLnJlZ2wucHJvcCgndGV4MScpLFxuICAgICAgICB0ZXgyOiB0aGlzLnJlZ2wucHJvcCgndGV4MicpLFxuICAgICAgICB0ZXgzOiB0aGlzLnJlZ2wucHJvcCgndGV4MycpXG4gICAgICB9LFxuICAgICAgY291bnQ6IDMsXG4gICAgICBkZXB0aDogeyBlbmFibGU6IGZhbHNlIH1cbiAgICB9KVxuXG4gICAgdGhpcy5yZW5kZXJGYm8gPSB0aGlzLnJlZ2woe1xuICAgICAgZnJhZzogYFxuICAgICAgcHJlY2lzaW9uICR7dGhpcy5wcmVjaXNpb259IGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuICAgICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdmVjMigxLjAgLSB1di54LCB1di55KSk7XG4gICAgICB9XG4gICAgICBgLFxuICAgICAgdmVydDogYFxuICAgICAgcHJlY2lzaW9uICR7dGhpcy5wcmVjaXNpb259IGZsb2F0O1xuICAgICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG4gICAgICB2YXJ5aW5nIHZlYzIgdXY7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHV2ID0gcG9zaXRpb247XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgxLjAgLSAyLjAgKiBwb3NpdGlvbiwgMCwgMSk7XG4gICAgICB9YCxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgcG9zaXRpb246IFtcbiAgICAgICAgICBbLTIsIDBdLFxuICAgICAgICAgIFswLCAtMl0sXG4gICAgICAgICAgWzIsIDJdXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB0ZXgwOiB0aGlzLnJlZ2wucHJvcCgndGV4MCcpLFxuICAgICAgICByZXNvbHV0aW9uOiB0aGlzLnJlZ2wucHJvcCgncmVzb2x1dGlvbicpXG4gICAgICB9LFxuICAgICAgY291bnQ6IDMsXG4gICAgICBkZXB0aDogeyBlbmFibGU6IGZhbHNlIH1cbiAgICB9KVxuICB9XG5cbiAgX2luaXRPdXRwdXRzIChudW1PdXRwdXRzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB0aGlzLm8gPSAoQXJyYXkobnVtT3V0cHV0cykpLmZpbGwoKS5tYXAoKGVsLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIG8gPSBuZXcgT3V0cHV0KGluZGV4LCB0aGlzKVxuICAgICAgc2VsZi5zeW50aFsnbycraW5kZXhdID0gb1xuICAgICAgcmV0dXJuIG9cbiAgICB9KVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3V0cHV0XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLm9bMF1cbiAgfVxuXG4gIF9pbml0U291cmNlcyAobnVtU291cmNlcykge1xuICAgIHRoaXMucyA9IFtdXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVNvdXJjZXM7IGkrKykge1xuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoaSlcbiAgICB9XG4gIH1cblxuICBjcmVhdGVTb3VyY2UgKGkpIHtcbiAgICBsZXQgcyA9IG5ldyBTb3VyY2Uoe3JlZ2w6IHRoaXMucmVnbCwgcGI6IHRoaXMucGIsIHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCBsYWJlbDogYHMke2l9YH0pXG4gICAgdGhpcy5zeW50aFsncycgKyB0aGlzLnMubGVuZ3RoXSA9IHNcbiAgICB0aGlzLnMucHVzaChzKVxuICAgIHJldHVybiBzXG4gIH1cblxuICBfZ2VuZXJhdGVHbHNsVHJhbnNmb3JtcyAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5nZW5lcmF0b3IgPSBuZXcgR2VuZXJhdG9yKHtcbiAgICAgIGRlZmF1bHRPdXRwdXQ6IHRoaXMub1swXSxcbiAgICAgIGRlZmF1bHRVbmlmb3JtczogdGhpcy5vWzBdLnVuaWZvcm1zLFxuICAgICAgZXh0ZW5kVHJhbnNmb3JtczogdGhpcy5leHRlbmRUcmFuc2Zvcm1zLFxuICAgICAgY2hhbmdlTGlzdGVuZXI6ICh7dHlwZSwgbWV0aG9kLCBzeW50aH0pID0+IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIHNlbGYuc3ludGhbbWV0aG9kXSA9IHN5bnRoLmdlbmVyYXRvcnNbbWV0aG9kXVxuICAgICAgICAgICAgaWYoc2VsZi5zYW5kYm94KSBzZWxmLnNhbmRib3guYWRkKG1ldGhvZClcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICAvLyB3aGF0IHRvIGRvIGhlcmU/IGRhbmdlcm91c2x5IGRlbGV0aW5nIHdpbmRvdyBtZXRob2RzXG4gICAgICAgICAgICAvL2RlbGV0ZSB3aW5kb3dbbWV0aG9kXVxuICAgICAgICAgIH1cbiAgICAgIC8vICB9XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnN5bnRoLnNldEZ1bmN0aW9uID0gdGhpcy5nZW5lcmF0b3Iuc2V0RnVuY3Rpb24uYmluZCh0aGlzLmdlbmVyYXRvcilcbiAgfVxuXG4gIF9yZW5kZXIgKG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nQWxsID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZ0FsbCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyT3V0IChpKSB7XG4gICAgdGhpcy5vW2ldLnRpY2soe1xuICAgICAgdGltZTogdGhpcy5zeW50aC50aW1lLFxuICAgICAgbW91c2U6IHRoaXMuc3ludGgubW91c2UsXG4gICAgICBicG06IHRoaXMuc3ludGguYnBtLFxuICAgICAgcmVzb2x1dGlvbjogW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdXG4gICAgfSlcbiAgfVxuXG4gIC8vIGR0IGluIG1zXG4gIHRpY2sgKGR0LCB1bmlmb3Jtcykge1xuICAgIHRoaXMuc2FuZGJveC50aWNrKClcbiAgICBpZih0aGlzLmRldGVjdEF1ZGlvID09PSB0cnVlKSB0aGlzLnN5bnRoLmEudGljaygpXG4gIC8vICBsZXQgdXBkYXRlSW50ZXJ2YWwgPSAxMDAwL3RoaXMuc3ludGguZnBzIC8vIG1zXG4gICAgdGhpcy5zYW5kYm94LnNldCgndGltZScsIHRoaXMuc3ludGgudGltZSArPSBkdCAqIDAuMDAxICogdGhpcy5zeW50aC5zcGVlZClcbiAgICB0aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUgKz0gZHRcbiAgICBpZighdGhpcy5zeW50aC5mcHMgfHwgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlID49IDEwMDAvdGhpcy5zeW50aC5mcHMpIHtcbiAgICAvLyAgY29uc29sZS5sb2coMTAwMC90aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpXG4gICAgICB0aGlzLnN5bnRoLnN0YXRzLmZwcyA9IE1hdGguY2VpbCgxMDAwL3RoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSlcbiAgICAgIGlmKHRoaXMuc3ludGgudXBkYXRlKSB7XG4gICAgICAgIHRyeSB7IHRoaXMuc3ludGgudXBkYXRlKHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSkgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKSB9XG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuc3ludGguc3BlZWQsIHRoaXMuc3ludGgudGltZSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc1tpXS50aWNrKHRoaXMuc3ludGgudGltZSlcbiAgICAgIH1cbiAgICAvLyAgY29uc29sZS5sb2codGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlck91dChpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nQWxsKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQWxsKHtcbiAgICAgICAgICB0ZXgwOiB0aGlzLm9bMF0uZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHRleDE6IHRoaXMub1sxXS5nZXRDdXJyZW50KCksXG4gICAgICAgICAgdGV4MjogdGhpcy5vWzJdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICB0ZXgzOiB0aGlzLm9bM10uZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHJlc29sdXRpb246IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLnJlbmRlckZibyh7XG4gICAgICAgICAgdGV4MDogdGhpcy5vdXRwdXQuZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHJlc29sdXRpb246IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlID0gMFxuICAgIH1cbiAgICBpZih0aGlzLnNhdmVGcmFtZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jYW52YXNUb0ltYWdlKClcbiAgICAgIHRoaXMuc2F2ZUZyYW1lID0gZmFsc2VcbiAgICB9XG4gIC8vICB0aGlzLnJlZ2wucG9sbCgpXG4gIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEh5ZHJhUmVuZGVyZXJcbiIsImltcG9ydCBTeW50aCBmcm9tICcuL2h5ZHJhLXN5bnRoLmpzJ1xuLy9pbXBvcnQgU2hhZGVyR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zaGFkZXItZ2VuZXJhdG9yLmpzJylcbi8vIGFsZXJ0KCdoaScpXG4vLyBleHBvcnQgZGVmYXVsdCBTeW50aFxubW9kdWxlLmV4cG9ydHMgPSBTeW50aFxuIiwiLy8gV0lQIHV0aWxzIGZvciB3b3JraW5nIHdpdGggYXJyYXlzXG4vLyBQb3NzaWJseSBzaG91bGQgYmUgaW50ZWdyYXRlZCB3aXRoIGxmbyBleHRlbnNpb24sIGV0Yy5cbi8vIHRvIGRvOiB0cmFuc2Zvcm0gdGltZSByYXRoZXIgdGhhbiBhcnJheSB2YWx1ZXMsIHNpbWlsYXIgdG8gd29ya2luZyB3aXRoIGNvb3JkaW5hdGVzIGluIGh5ZHJhXG5cbmltcG9ydCBlYXNpbmcgZnJvbSAnLi9lYXNpbmctZnVuY3Rpb25zLmpzJ1xuXG52YXIgbWFwID0gKG51bSwgaW5fbWluLCBpbl9tYXgsIG91dF9taW4sIG91dF9tYXgpID0+IHtcbiAgcmV0dXJuIChudW0gLSBpbl9taW4pICogKG91dF9tYXggLSBvdXRfbWluKSAvIChpbl9tYXggLSBpbl9taW4pICsgb3V0X21pbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiAoKSA9PiB7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZmFzdCA9IGZ1bmN0aW9uKHNwZWVkID0gMSkge1xuICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuc21vb3RoID0gZnVuY3Rpb24oc21vb3RoID0gMSkge1xuICAgICAgdGhpcy5fc21vb3RoID0gc21vb3RoXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24oZWFzZSA9ICdsaW5lYXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVhc2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9zbW9vdGggPSAxXG4gICAgICAgIHRoaXMuX2Vhc2UgPSBlYXNlXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlYXNpbmdbZWFzZV0pe1xuICAgICAgICB0aGlzLl9zbW9vdGggPSAxXG4gICAgICAgIHRoaXMuX2Vhc2UgPSBlYXNpbmdbZWFzZV1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKG9mZnNldCA9IDAuNSkge1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0JTEuMFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBBcnJheS5wcm90b3R5cGUuYm91bmNlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gICB0aGlzLm1vZGlmaWVycy5ib3VuY2UgPSB0cnVlXG4gICAgLy8gICByZXR1cm4gdGhpc1xuICAgIC8vIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbihsb3cgPSAwLCBoaWdoID0xKSB7XG4gICAgICBsZXQgbG93ZXN0ID0gTWF0aC5taW4oLi4udGhpcylcbiAgICAgIGxldCBoaWdoZXN0ID0gIE1hdGgubWF4KC4uLnRoaXMpXG4gICAgICB2YXIgbmV3QXJyID0gdGhpcy5tYXAoKG51bSkgPT4gbWFwKG51bSwgbG93ZXN0LCBoaWdoZXN0LCBsb3csIGhpZ2gpKVxuICAgICAgbmV3QXJyLl9zcGVlZCA9IHRoaXMuX3NwZWVkXG4gICAgICBuZXdBcnIuX3Ntb290aCA9IHRoaXMuX3Ntb290aFxuICAgICAgbmV3QXJyLl9lYXNlID0gdGhpcy5fZWFzZVxuICAgICAgcmV0dXJuIG5ld0FyclxuICAgIH1cbiAgfSxcblxuICBnZXRWYWx1ZTogKGFyciA9IFtdKSA9PiAoe3RpbWUsIGJwbX0pID0+e1xuICAgIGxldCBzcGVlZCA9IGFyci5fc3BlZWQgPyBhcnIuX3NwZWVkIDogMVxuICAgIGxldCBzbW9vdGggPSBhcnIuX3Ntb290aCA/IGFyci5fc21vb3RoIDogMFxuICAgIGxldCBpbmRleCA9IHRpbWUgKiBzcGVlZCAqIChicG0gLyA2MCkgKyAoYXJyLl9vZmZzZXQgfHwgMClcblxuICAgIGlmIChzbW9vdGghPT0wKSB7XG4gICAgICBsZXQgZWFzZSA9IGFyci5fZWFzZSA/IGFyci5fZWFzZSA6IGVhc2luZ1snbGluZWFyJ11cbiAgICAgIGxldCBfaW5kZXggPSBpbmRleCAtIChzbW9vdGggLyAyKVxuICAgICAgbGV0IGN1cnJWYWx1ZSA9IGFycltNYXRoLmZsb29yKF9pbmRleCAlIChhcnIubGVuZ3RoKSldXG4gICAgICBsZXQgbmV4dFZhbHVlID0gYXJyW01hdGguZmxvb3IoKF9pbmRleCArIDEpICUgKGFyci5sZW5ndGgpKV1cbiAgICAgIGxldCB0ID0gTWF0aC5taW4oKF9pbmRleCUxKS9zbW9vdGgsMSlcbiAgICAgIHJldHVybiBlYXNlKHQpICogKG5leHRWYWx1ZSAtIGN1cnJWYWx1ZSkgKyBjdXJyVmFsdWVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYXJyW01hdGguZmxvb3IoaW5kZXggJSAoYXJyLmxlbmd0aCkpXVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IE1leWRhIGZyb20gJ21leWRhJ1xuXG5jbGFzcyBBdWRpbyB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgbnVtQmlucyA9IDQsXG4gICAgY3V0b2ZmID0gMixcbiAgICBzbW9vdGggPSAwLjQsXG4gICAgbWF4ID0gMTUsXG4gICAgc2NhbGUgPSAxMCxcbiAgICBpc0RyYXdpbmcgPSBmYWxzZSxcbiAgICBwYXJlbnRFbCA9IGRvY3VtZW50LmJvZHlcbiAgfSkge1xuICAgIHRoaXMudm9sID0gMFxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5jdXRvZmYgPSBjdXRvZmZcbiAgICB0aGlzLnNtb290aCA9IHNtb290aFxuICAgIHRoaXMuc2V0QmlucyhudW1CaW5zKVxuXG4gICAgLy8gYmVhdCBkZXRlY3Rpb24gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3RoZXJld2FzYWd1eS9wNS1tdXNpYy12aXovYmxvYi9naC1wYWdlcy9kZW1vcy8wMWRfYmVhdF9kZXRlY3RfYW1wbGl0dWRlL3NrZXRjaC5qc1xuICAgIHRoaXMuYmVhdCA9IHtcbiAgICAgIGhvbGRGcmFtZXM6IDIwLFxuICAgICAgdGhyZXNob2xkOiA0MCxcbiAgICAgIF9jdXRvZmY6IDAsIC8vIGFkYXB0aXZlIGJhc2VkIG9uIHNvdW5kIHN0YXRlXG4gICAgICBkZWNheTogMC45OCxcbiAgICAgIF9mcmFtZXNTaW5jZUJlYXQ6IDAgLy8ga2VlcHMgdHJhY2sgb2YgZnJhbWVzXG4gICAgfVxuXG4gICAgdGhpcy5vbkJlYXQgPSAoKSA9PiB7XG4gICAgLy8gIGNvbnNvbGUubG9nKFwiYmVhdFwiKVxuICAgIH1cblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDEwMFxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDgwXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSBcIjEwMHB4XCJcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjgwcHhcIlxuICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gJzBweCdcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSAnMHB4J1xuICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKVxuXG4gICAgdGhpcy5pc0RyYXdpbmcgPSBpc0RyYXdpbmdcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICB0aGlzLmN0eC5maWxsU3R5bGU9XCIjREZGRkZGXCJcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZT1cIiMwZmZcIlxuICAgIHRoaXMuY3R4LmxpbmVXaWR0aD0wLjVcbiAgICBpZih3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7dmlkZW86IGZhbHNlLCBhdWRpbzogdHJ1ZX0pXG4gICAgICAudGhlbigoc3RyZWFtKSA9PiB7XG4gICAgICAvLyAgY29uc29sZS5sb2coJ2dvdCBtaWMgc3RyZWFtJywgc3RyZWFtKVxuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgICAgLy8gIHRoaXMuY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKVxuICAgICAgICBsZXQgYXVkaW9fc3RyZWFtID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSlcblxuICAgICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuY29udGV4dClcbiAgICAgICAgdGhpcy5tZXlkYSA9IE1leWRhLmNyZWF0ZU1leWRhQW5hbHl6ZXIoe1xuICAgICAgICAgIGF1ZGlvQ29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIHNvdXJjZTogYXVkaW9fc3RyZWFtLFxuICAgICAgICAgIGZlYXR1cmVFeHRyYWN0b3JzOiBbXG4gICAgICAgICAgICAnbG91ZG5lc3MnLFxuICAgICAgICAgICAgLy8gICdwZXJjZXB0dWFsU3ByZWFkJyxcbiAgICAgICAgICAgIC8vICAncGVyY2VwdHVhbFNoYXJwbmVzcycsXG4gICAgICAgICAgICAvLyAgJ3NwZWN0cmFsQ2VudHJvaWQnXG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZygnRVJST1InLCBlcnIpKVxuICAgIH1cbiAgfVxuXG4gIGRldGVjdEJlYXQgKGxldmVsKSB7XG4gICAgLy9jb25zb2xlLmxvZyhsZXZlbCwgICB0aGlzLmJlYXQuX2N1dG9mZilcbiAgICBpZiAobGV2ZWwgPiB0aGlzLmJlYXQuX2N1dG9mZiAmJiBsZXZlbCA+IHRoaXMuYmVhdC50aHJlc2hvbGQpIHtcbiAgICAgIHRoaXMub25CZWF0KClcbiAgICAgIHRoaXMuYmVhdC5fY3V0b2ZmID0gbGV2ZWwgKjEuMlxuICAgICAgdGhpcy5iZWF0Ll9mcmFtZXNTaW5jZUJlYXQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmJlYXQuX2ZyYW1lc1NpbmNlQmVhdCA8PSB0aGlzLmJlYXQuaG9sZEZyYW1lcyl7XG4gICAgICAgIHRoaXMuYmVhdC5fZnJhbWVzU2luY2VCZWF0ICsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iZWF0Ll9jdXRvZmYgKj0gdGhpcy5iZWF0LmRlY2F5XG4gICAgICAgIHRoaXMuYmVhdC5fY3V0b2ZmID0gTWF0aC5tYXgoICB0aGlzLmJlYXQuX2N1dG9mZiwgdGhpcy5iZWF0LnRocmVzaG9sZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGljaygpIHtcbiAgIGlmKHRoaXMubWV5ZGEpe1xuICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLm1leWRhLmdldCgpXG4gICAgIGlmKGZlYXR1cmVzICYmIGZlYXR1cmVzICE9PSBudWxsKXtcbiAgICAgICB0aGlzLnZvbCA9IGZlYXR1cmVzLmxvdWRuZXNzLnRvdGFsXG4gICAgICAgdGhpcy5kZXRlY3RCZWF0KHRoaXMudm9sKVxuICAgICAgIC8vIHJlZHVjZSBsb3VkbmVzcyBhcnJheSB0byBudW1iZXIgb2YgYmluc1xuICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWU7XG4gICAgICAgbGV0IHNwYWNpbmcgPSBNYXRoLmZsb29yKGZlYXR1cmVzLmxvdWRuZXNzLnNwZWNpZmljLmxlbmd0aC90aGlzLmJpbnMubGVuZ3RoKVxuICAgICAgIHRoaXMucHJldkJpbnMgPSB0aGlzLmJpbnMuc2xpY2UoMClcbiAgICAgICB0aGlzLmJpbnMgPSB0aGlzLmJpbnMubWFwKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICAgICByZXR1cm4gZmVhdHVyZXMubG91ZG5lc3Muc3BlY2lmaWMuc2xpY2UoaW5kZXggKiBzcGFjaW5nLCAoaW5kZXggKyAxKSpzcGFjaW5nKS5yZWR1Y2UocmVkdWNlcilcbiAgICAgICB9KS5tYXAoKGJpbiwgaW5kZXgpID0+IHtcbiAgICAgICAgIC8vIG1hcCB0byBzcGVjaWZpZWQgcmFuZ2VcblxuICAgICAgICAvLyByZXR1cm4gKGJpbiAqICgxLjAgLSB0aGlzLnNtb290aCkgKyB0aGlzLnByZXZCaW5zW2luZGV4XSAqIHRoaXMuc21vb3RoKVxuICAgICAgICAgIHJldHVybiAoYmluICogKDEuMCAtIHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNtb290aCkgKyB0aGlzLnByZXZCaW5zW2luZGV4XSAqIHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNtb290aClcbiAgICAgICB9KVxuICAgICAgIC8vIHZhciB5ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmXG4gICAgICAgLy8gdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAvLyB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeSlcbiAgICAgICAvLyB0aGlzLmN0eC5saW5lVG8oKGluZGV4KzEpKnNwYWNpbmcsIHkpXG4gICAgICAgLy8gdGhpcy5jdHguc3Ryb2tlKClcbiAgICAgICAvL1xuICAgICAgIC8vIHZhciB5TWF4ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqKHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlICsgdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmKVxuICAgICAgIHRoaXMuZmZ0ID0gdGhpcy5iaW5zLm1hcCgoYmluLCBpbmRleCkgPT4gKFxuICAgICAgICAvLyBNYXRoLm1heCgwLCAoYmluIC0gdGhpcy5jdXRvZmYpIC8gKHRoaXMubWF4IC0gdGhpcy5jdXRvZmYpKVxuICAgICAgICAgTWF0aC5tYXgoMCwgKGJpbiAtIHRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZikvdGhpcy5zZXR0aW5nc1tpbmRleF0uc2NhbGUpXG4gICAgICAgKSlcbiAgICAgICBpZih0aGlzLmlzRHJhd2luZykgdGhpcy5kcmF3KClcbiAgICAgfVxuICAgfVxuICB9XG5cbiAgc2V0Q3V0b2ZmIChjdXRvZmYpIHtcbiAgICB0aGlzLmN1dG9mZiA9IGN1dG9mZlxuICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLm1hcCgoZWwpID0+IHtcbiAgICAgIGVsLmN1dG9mZiA9IGN1dG9mZlxuICAgICAgcmV0dXJuIGVsXG4gICAgfSlcbiAgfVxuXG4gIHNldFNtb290aCAoc21vb3RoKSB7XG4gICAgdGhpcy5zbW9vdGggPSBzbW9vdGhcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5zbW9vdGggPSBzbW9vdGhcbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG4gIH1cblxuICBzZXRCaW5zIChudW1CaW5zKSB7XG4gICAgdGhpcy5iaW5zID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMucHJldkJpbnMgPSBBcnJheShudW1CaW5zKS5maWxsKDApXG4gICAgdGhpcy5mZnQgPSBBcnJheShudW1CaW5zKS5maWxsKDApXG4gICAgdGhpcy5zZXR0aW5ncyA9IEFycmF5KG51bUJpbnMpLmZpbGwoMCkubWFwKCgpID0+ICh7XG4gICAgICBjdXRvZmY6IHRoaXMuY3V0b2ZmLFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICBzbW9vdGg6IHRoaXMuc21vb3RoXG4gICAgfSkpXG4gICAgLy8gdG8gZG86IHdoYXQgdG8gZG8gaW4gbm9uLWdsb2JhbCBtb2RlP1xuICAgIHRoaXMuYmlucy5mb3JFYWNoKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICB3aW5kb3dbJ2EnICsgaW5kZXhdID0gKHNjYWxlID0gMSwgb2Zmc2V0ID0gMCkgPT4gKCkgPT4gKGEuZmZ0W2luZGV4XSAqIHNjYWxlICsgb2Zmc2V0KVxuICAgIH0pXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLnNldHRpbmdzKVxuICB9XG5cbiAgc2V0U2NhbGUoc2NhbGUpe1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVxuICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLm1hcCgoZWwpID0+IHtcbiAgICAgIGVsLnNjYWxlID0gc2NhbGVcbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG4gIH1cblxuICBzZXRNYXgobWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXhcbiAgICBjb25zb2xlLmxvZygnc2V0IG1heCBpcyBkZXByZWNhdGVkJylcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuaXNEcmF3aW5nID0gZmFsc2VcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuaXNEcmF3aW5nID0gdHJ1ZVxuICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG5cbiAgfVxuXG4gIGRyYXcgKCkge1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICAgIHZhciBzcGFjaW5nID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLmJpbnMubGVuZ3RoXG4gICAgdmFyIHNjYWxlID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gKHRoaXMubWF4ICogMilcbiAgLy8gIGNvbnNvbGUubG9nKHRoaXMuYmlucylcbiAgICB0aGlzLmJpbnMuZm9yRWFjaCgoYmluLCBpbmRleCkgPT4ge1xuXG4gICAgICB2YXIgaGVpZ2h0ID0gYmluICogc2NhbGVcblxuICAgICB0aGlzLmN0eC5maWxsUmVjdChpbmRleCAqIHNwYWNpbmcsIHRoaXMuY2FudmFzLmhlaWdodCAtIGhlaWdodCwgc3BhY2luZywgaGVpZ2h0KVxuXG4gIC8vICAgY29uc29sZS5sb2codGhpcy5zZXR0aW5nc1tpbmRleF0pXG4gICAgIHZhciB5ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmXG4gICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgIHRoaXMuY3R4Lm1vdmVUbyhpbmRleCpzcGFjaW5nLCB5KVxuICAgICB0aGlzLmN0eC5saW5lVG8oKGluZGV4KzEpKnNwYWNpbmcsIHkpXG4gICAgIHRoaXMuY3R4LnN0cm9rZSgpXG5cbiAgICAgdmFyIHlNYXggPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSoodGhpcy5zZXR0aW5nc1tpbmRleF0uc2NhbGUgKyB0aGlzLnNldHRpbmdzW2luZGV4XS5jdXRvZmYpXG4gICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgIHRoaXMuY3R4Lm1vdmVUbyhpbmRleCpzcGFjaW5nLCB5TWF4KVxuICAgICB0aGlzLmN0eC5saW5lVG8oKGluZGV4KzEpKnNwYWNpbmcsIHlNYXgpXG4gICAgIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgfSlcblxuXG4gICAgLyp2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuY3V0b2ZmXG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgeSlcbiAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5jYW52YXMud2lkdGgsIHkpXG4gICAgdGhpcy5jdHguc3Ryb2tlKClcbiAgICB2YXIgeU1heCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMubWF4XG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgeU1heClcbiAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5jYW52YXMud2lkdGgsIHlNYXgpXG4gICAgdGhpcy5jdHguc3Ryb2tlKCkqL1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvXG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gbm8gZWFzaW5nLCBubyBhY2NlbGVyYXRpb25cbiAgbGluZWFyOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KnQgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KigyLXQpIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDIqdCp0IDogLTErKDQtMip0KSp0IH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAoLS10KSp0KnQrMSB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0PC41ID8gNCp0KnQqdCA6ICh0LTEpKigyKnQtMikqKDIqdC0yKSsxIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KnQqdCp0IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEtKC0tdCkqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDgqdCp0KnQqdCA6IDEtOCooLS10KSp0KnQqdCB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQqdCp0IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDErKC0tdCkqdCp0KnQqdCB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0PC41ID8gMTYqdCp0KnQqdCp0IDogMSsxNiooLS10KSp0KnQqdCp0IH0sXG4gIC8vIHNpbiBzaGFwZVxuICBzaW46IGZ1bmN0aW9uICh0KSB7IHJldHVybiAoMSArIE1hdGguc2luKE1hdGguUEkqdC1NYXRoLlBJLzIpKS8yIH1cbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL21vdXNlLWV2ZW50XG5cbmNvbnN0IG1vdXNlID0ge31cblxuZnVuY3Rpb24gbW91c2VCdXR0b25zKGV2KSB7XG4gIGlmKHR5cGVvZiBldiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZignYnV0dG9ucycgaW4gZXYpIHtcbiAgICAgIHJldHVybiBldi5idXR0b25zXG4gICAgfSBlbHNlIGlmKCd3aGljaCcgaW4gZXYpIHtcbiAgICAgIHZhciBiID0gZXYud2hpY2hcbiAgICAgIGlmKGIgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIDRcbiAgICAgIH0gZWxzZSBpZihiID09PSAzKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgICB9IGVsc2UgaWYoYiA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE8PChiLTEpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCdidXR0b24nIGluIGV2KSB7XG4gICAgICB2YXIgYiA9IGV2LmJ1dHRvblxuICAgICAgaWYoYiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gNFxuICAgICAgfSBlbHNlIGlmKGIgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIDJcbiAgICAgIH0gZWxzZSBpZihiID49IDApIHtcbiAgICAgICAgcmV0dXJuIDE8PGJcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbm1vdXNlLmJ1dHRvbnMgPSBtb3VzZUJ1dHRvbnNcblxuZnVuY3Rpb24gbW91c2VFbGVtZW50KGV2KSB7XG4gIHJldHVybiBldi50YXJnZXQgfHwgZXYuc3JjRWxlbWVudCB8fCB3aW5kb3dcbn1cbm1vdXNlLmVsZW1lbnQgPSBtb3VzZUVsZW1lbnRcblxuZnVuY3Rpb24gbW91c2VSZWxhdGl2ZVgoZXYpIHtcbiAgaWYodHlwZW9mIGV2ID09PSAnb2JqZWN0Jykge1xuICAgIGlmKCdwYWdlWCcgaW4gZXYpIHtcbiAgICAgIHJldHVybiBldi5wYWdlWFxuICAgIH1cbiAgfVxuICByZXR1cm4gMFxufVxubW91c2UueCA9IG1vdXNlUmVsYXRpdmVYXG5cbmZ1bmN0aW9uIG1vdXNlUmVsYXRpdmVZKGV2KSB7XG4gIGlmKHR5cGVvZiBldiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZigncGFnZVknIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYucGFnZVlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbm1vdXNlLnkgPSBtb3VzZVJlbGF0aXZlWVxuXG5leHBvcnQgZGVmYXVsdCBtb3VzZSIsIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL21vdXNlLWNoYW5nZVxuXG5leHBvcnQgZGVmYXVsdCBtb3VzZUxpc3RlblxuXG5pbXBvcnQgbW91c2UgZnJvbSAnLi9tb3VzZS1ldmVudC5qcydcblxuZnVuY3Rpb24gbW91c2VMaXN0ZW4gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGVsZW1lbnRcbiAgICBlbGVtZW50ID0gd2luZG93XG4gIH1cblxuICB2YXIgYnV0dG9uU3RhdGUgPSAwXG4gIHZhciB4ID0gMFxuICB2YXIgeSA9IDBcbiAgdmFyIG1vZHMgPSB7XG4gICAgc2hpZnQ6IGZhbHNlLFxuICAgIGFsdDogZmFsc2UsXG4gICAgY29udHJvbDogZmFsc2UsXG4gICAgbWV0YTogZmFsc2VcbiAgfVxuICB2YXIgYXR0YWNoZWQgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vZHMgKGV2KSB7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZVxuICAgIGlmICgnYWx0S2V5JyBpbiBldikge1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgZXYuYWx0S2V5ICE9PSBtb2RzLmFsdFxuICAgICAgbW9kcy5hbHQgPSAhIWV2LmFsdEtleVxuICAgIH1cbiAgICBpZiAoJ3NoaWZ0S2V5JyBpbiBldikge1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgZXYuc2hpZnRLZXkgIT09IG1vZHMuc2hpZnRcbiAgICAgIG1vZHMuc2hpZnQgPSAhIWV2LnNoaWZ0S2V5XG4gICAgfVxuICAgIGlmICgnY3RybEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LmN0cmxLZXkgIT09IG1vZHMuY29udHJvbFxuICAgICAgbW9kcy5jb250cm9sID0gISFldi5jdHJsS2V5XG4gICAgfVxuICAgIGlmICgnbWV0YUtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2Lm1ldGFLZXkgIT09IG1vZHMubWV0YVxuICAgICAgbW9kcy5tZXRhID0gISFldi5tZXRhS2V5XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVFdmVudCAobmV4dEJ1dHRvbnMsIGV2KSB7XG4gICAgdmFyIG5leHRYID0gbW91c2UueChldilcbiAgICB2YXIgbmV4dFkgPSBtb3VzZS55KGV2KVxuICAgIGlmICgnYnV0dG9ucycgaW4gZXYpIHtcbiAgICAgIG5leHRCdXR0b25zID0gZXYuYnV0dG9ucyB8IDBcbiAgICB9XG4gICAgaWYgKG5leHRCdXR0b25zICE9PSBidXR0b25TdGF0ZSB8fFxuICAgICAgbmV4dFggIT09IHggfHxcbiAgICAgIG5leHRZICE9PSB5IHx8XG4gICAgICB1cGRhdGVNb2RzKGV2KSkge1xuICAgICAgYnV0dG9uU3RhdGUgPSBuZXh0QnV0dG9ucyB8IDBcbiAgICAgIHggPSBuZXh0WCB8fCAwXG4gICAgICB5ID0gbmV4dFkgfHwgMFxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soYnV0dG9uU3RhdGUsIHgsIHksIG1vZHMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZSAoZXYpIHtcbiAgICBoYW5kbGVFdmVudCgwLCBldilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIgKCkge1xuICAgIGlmIChidXR0b25TdGF0ZSB8fFxuICAgICAgeCB8fFxuICAgICAgeSB8fFxuICAgICAgbW9kcy5zaGlmdCB8fFxuICAgICAgbW9kcy5hbHQgfHxcbiAgICAgIG1vZHMubWV0YSB8fFxuICAgICAgbW9kcy5jb250cm9sKSB7XG4gICAgICB4ID0geSA9IDBcbiAgICAgIGJ1dHRvblN0YXRlID0gMFxuICAgICAgbW9kcy5zaGlmdCA9IG1vZHMuYWx0ID0gbW9kcy5jb250cm9sID0gbW9kcy5tZXRhID0gZmFsc2VcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKDAsIDAsIDAsIG1vZHMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW9kcyAoZXYpIHtcbiAgICBpZiAodXBkYXRlTW9kcyhldikpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1dHRvblN0YXRlLCB4LCB5LCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSAoZXYpIHtcbiAgICBpZiAobW91c2UuYnV0dG9ucyhldikgPT09IDApIHtcbiAgICAgIGhhbmRsZUV2ZW50KDAsIGV2KVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVFdmVudChidXR0b25TdGF0ZSwgZXYpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duIChldikge1xuICAgIGhhbmRsZUV2ZW50KGJ1dHRvblN0YXRlIHwgbW91c2UuYnV0dG9ucyhldiksIGV2KVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcCAoZXYpIHtcbiAgICBoYW5kbGVFdmVudChidXR0b25TdGF0ZSAmIH5tb3VzZS5idXR0b25zKGV2KSwgZXYpXG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hMaXN0ZW5lcnMgKCkge1xuICAgIGlmIChhdHRhY2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGF0dGFjaGVkID0gdHJ1ZVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bilcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGNsZWFyU3RhdGUpXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGNsZWFyU3RhdGUpXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBjbGVhclN0YXRlKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cilcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVNb2RzKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZU1vZHMpXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZU1vZHMpXG5cbiAgICBpZiAoZWxlbWVudCAhPT0gd2luZG93KSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZU1vZHMpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZU1vZHMpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBoYW5kbGVNb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaExpc3RlbmVycyAoKSB7XG4gICAgaWYgKCFhdHRhY2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGF0dGFjaGVkID0gZmFsc2VcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgY2xlYXJTdGF0ZSlcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBoYW5kbGVNb2RzKVxuXG4gICAgaWYgKGVsZW1lbnQgIT09IHdpbmRvdykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcbiAgICB9XG4gIH1cblxuICAvLyBBdHRhY2ggbGlzdGVuZXJzXG4gIGF0dGFjaExpc3RlbmVycygpXG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF0dGFjaGVkIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgYXR0YWNoTGlzdGVuZXJzKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhY2hMaXN0ZW5lcnMoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgYnV0dG9uczoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidXR0b25TdGF0ZSB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgeDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHkgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIG1vZHM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kcyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCIvLyBhdHRlbXB0IGN1c3RvbSBldmFsdWF0aW9uIHNhbmRib3ggZm9yIGh5ZHJhIGZ1bmN0aW9uc1xuLy8gZm9yIG5vdywganVzdCBhdm9pZHMgcG9sbHV0aW5nIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4vLyBzaG91bGQgcHJvYmFibHkgYmUgcmVwbGFjZWQgd2l0aCBhbiBhYnN0cmFjdCBzeW50YXggdHJlZVxuXG5leHBvcnQgZGVmYXVsdCAocGFyZW50KSA9PiB7XG4gIHZhciBpbml0aWFsQ29kZSA9IGBgXG5cbiAgdmFyIHNhbmRib3ggPSBjcmVhdGVTYW5kYm94KGluaXRpYWxDb2RlKVxuXG4gIHZhciBhZGRUb0NvbnRleHQgPSAobmFtZSwgb2JqZWN0KSA9PiB7XG4gICAgaW5pdGlhbENvZGUgKz0gYFxuICAgICAgdmFyICR7bmFtZX0gPSAke29iamVjdH1cbiAgICBgXG4gICAgc2FuZGJveCA9IGNyZWF0ZVNhbmRib3goaW5pdGlhbENvZGUpXG4gIH1cblxuXG4gIHJldHVybiB7XG4gICAgYWRkVG9Db250ZXh0OiBhZGRUb0NvbnRleHQsXG4gICAgZXZhbDogKGNvZGUpID0+IHNhbmRib3guZXZhbChjb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2FuZGJveCAoaW5pdGlhbCkge1xuICAgIGdsb2JhbFRoaXMuZXZhbChpbml0aWFsKVxuICAgIC8vIG9wdGlvbmFsIHBhcmFtc1xuICAgIHZhciBsb2NhbEV2YWwgPSBmdW5jdGlvbiAoY29kZSkgIHtcbiAgICAgIGdsb2JhbFRoaXMuZXZhbChjb2RlKVxuICAgIH1cblxuICAgIC8vIEFQSS9kYXRhIGZvciBlbmQtdXNlclxuICAgIHJldHVybiB7XG4gICAgICBldmFsOiBsb2NhbEV2YWxcbiAgICB9XG4gIH1cbn1cbiIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vICBhc3luYyBmdW5jdGlvbiBzdGFydENhcHR1cmUoZGlzcGxheU1lZGlhT3B0aW9ucykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKG9wdGlvbnMpLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICB2aWRlby5wbGF5KClcbiAgICAgICAgcmVzb2x2ZSh7dmlkZW86IHZpZGVvfSlcbiAgICAgIH0pXG4gICAgfSkuY2F0Y2goKGVycikgPT4gcmVqZWN0KGVycikpXG4gIH0pXG59XG4iLCJjbGFzcyBWaWRlb1JlY29yZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpXG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cblxuICAgIC8vIHRlc3RpbmcgdXNpbmcgYSByZWNvcmRpbmcgYXMgaW5wdXRcbiAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbiAgICB0aGlzLm91dHB1dC5hdXRvcGxheSA9IHRydWVcbiAgICB0aGlzLm91dHB1dC5sb29wID0gdHJ1ZVxuXG4gICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ01lZGlhU291cmNlIG9wZW5lZCcpO1xuICAgICAgc2VsZi5zb3VyY2VCdWZmZXIgPSBzZWxmLm1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcigndmlkZW8vd2VibTsgY29kZWNzPVwidnA4XCInKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTb3VyY2UgYnVmZmVyOiAnLCBzb3VyY2VCdWZmZXIpO1xuICAgIH0pXG4gIH1cblxuICBzdGFydCgpIHtcbiAgLy8gIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibSd9O1xuXG4vLyAgIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibTtjb2RlY3M9aDI2NCd9O1xuICAgbGV0IG9wdGlvbnMgPSB7bWltZVR5cGU6ICd2aWRlby93ZWJtO2NvZGVjcz12cDknfTtcblxuICAgIHRoaXMucmVjb3JkZWRCbG9icyA9IFtdXG4gICAgdHJ5IHtcbiAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgfSBjYXRjaCAoZTApIHtcbiAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBjcmVhdGUgTWVkaWFSZWNvcmRlciB3aXRoIG9wdGlvbnMgT2JqZWN0OiAnLCBlMClcbiAgICAgdHJ5IHtcbiAgICAgICBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibSxjb2RlY3M9dnA5J31cbiAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcih0aGlzLnN0cmVhbSwgb3B0aW9ucylcbiAgICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGNyZWF0ZSBNZWRpYVJlY29yZGVyIHdpdGggb3B0aW9ucyBPYmplY3Q6ICcsIGUxKVxuICAgICAgIHRyeSB7XG4gICAgICAgICBvcHRpb25zID0gJ3ZpZGVvL3ZwOCcgLy8gQ2hyb21lIDQ3XG4gICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcih0aGlzLnN0cmVhbSwgb3B0aW9ucylcbiAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgYWxlcnQoJ01lZGlhUmVjb3JkZXIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuXFxuJyArXG4gICAgICAgICAgICdUcnkgRmlyZWZveCAyOSBvciBsYXRlciwgb3IgQ2hyb21lIDQ3IG9yIGxhdGVyLCAnICtcbiAgICAgICAgICAgJ3dpdGggRW5hYmxlIGV4cGVyaW1lbnRhbCBXZWIgUGxhdGZvcm0gZmVhdHVyZXMgZW5hYmxlZCBmcm9tIGNocm9tZTovL2ZsYWdzLicpXG4gICAgICAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgTWVkaWFSZWNvcmRlcjonLCBlMilcbiAgICAgICAgIHJldHVyblxuICAgICAgIH1cbiAgICAgfVxuICAgfVxuICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgTWVkaWFSZWNvcmRlcicsIHRoaXMubWVkaWFSZWNvcmRlciwgJ3dpdGggb3B0aW9ucycsIG9wdGlvbnMpO1xuICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uc3RvcCA9IHRoaXMuX2hhbmRsZVN0b3AuYmluZCh0aGlzKVxuICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uZGF0YWF2YWlsYWJsZSA9IHRoaXMuX2hhbmRsZURhdGFBdmFpbGFibGUuYmluZCh0aGlzKVxuICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KDEwMCkgLy8gY29sbGVjdCAxMDBtcyBvZiBkYXRhXG4gICBjb25zb2xlLmxvZygnTWVkaWFSZWNvcmRlciBzdGFydGVkJywgdGhpcy5tZWRpYVJlY29yZGVyKVxuIH1cblxuICBcbiAgIHN0b3AoKXtcbiAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0b3AoKVxuICAgfVxuXG4gX2hhbmRsZVN0b3AoKSB7XG4gICAvL2NvbnN0IHN1cGVyQnVmZmVyID0gbmV3IEJsb2IocmVjb3JkZWRCbG9icywge3R5cGU6ICd2aWRlby93ZWJtJ30pXG4gICAvLyBjb25zdCBibG9iID0gbmV3IEJsb2IodGhpcy5yZWNvcmRlZEJsb2JzLCB7dHlwZTogJ3ZpZGVvL3dlYm07Y29kZWNzPWgyNjQnfSlcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkZWRCbG9icywge3R5cGU6IHRoaXMubWVkaWFSZWNvcmRlci5taW1lVHlwZX0pXG4gICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgdGhpcy5vdXRwdXQuc3JjID0gdXJsXG5cbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgYS5ocmVmID0gdXJsXG4gICAgbGV0IGQgPSBuZXcgRGF0ZSgpXG4gICAgYS5kb3dubG9hZCA9IGBoeWRyYS0ke2QuZ2V0RnVsbFllYXIoKX0tJHtkLmdldE1vbnRoKCkgKyAxfS0ke2QuZ2V0RGF0ZSgpfS0ke2QuZ2V0SG91cnMoKX0uJHtkLmdldE1pbnV0ZXMoKX0uJHtkLmdldFNlY29uZHMoKX0ud2VibWBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpXG4gICAgYS5jbGljaygpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICB9LCAzMDApO1xuICB9XG5cbiAgX2hhbmRsZURhdGFBdmFpbGFibGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLnJlY29yZGVkQmxvYnMucHVzaChldmVudC5kYXRhKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9SZWNvcmRlclxuIiwiLy9jb25zdCBlbnVtZXJhdGVEZXZpY2VzID0gcmVxdWlyZSgnZW51bWVyYXRlLWRldmljZXMnKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgLnRoZW4oZGV2aWNlcyA9PiBkZXZpY2VzLmZpbHRlcihkZXZpY2VzID0+IGRldmljZXMua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSlcbiAgICAudGhlbihjYW1lcmFzID0+IHtcbiAgICAgIGxldCBjb25zdHJhaW50cyA9IHsgYXVkaW86IGZhbHNlLCB2aWRlbzogdHJ1ZX1cbiAgICAgIGlmIChjYW1lcmFzW2RldmljZUlkXSkge1xuICAgICAgICBjb25zdHJhaW50c1sndmlkZW8nXSA9IHtcbiAgICAgICAgICBkZXZpY2VJZDogeyBleGFjdDogY2FtZXJhc1tkZXZpY2VJZF0uZGV2aWNlSWQgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKGNhbWVyYXMpXG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIH0pXG4gICAgLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICcnKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICcnKVxuICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICcnKVxuICAgICAgLy8gIHZpZGVvLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSlcbiAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgdmlkZW8ucGxheSgpLnRoZW4oKCkgPT4gcmVzb2x2ZSh7dmlkZW86IHZpZGVvfSkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpXG59XG4iLCJpbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCJnbC1tYXQ0XCI7XG5pbXBvcnQgR2xzbFNvdXJjZSBmcm9tIFwiLi9nbHNsLXNvdXJjZS5qc1wiO1xuXG52YXIgT3V0cHV0ID0gZnVuY3Rpb24gKGluZGV4LCBzeW50aCkge1xuICB0aGlzLmlkID0gaW5kZXg7XG4gIHRoaXMuc3ludGggPSBzeW50aDtcbiAgdGhpcy53aWR0aCA9IHN5bnRoLndpZHRoXG4gIHRoaXMuaGVpZ2h0ID0gc3ludGguaGVpZ2h0XG4gIHRoaXMucmVnbCA9IHN5bnRoLnJlZ2xcbiAgdGhpcy5wcmVjaXNpb24gPSBzeW50aC5wcmVjaXNpb25cbiAgdGhpcy5sYWJlbCA9IGBvJHtpbmRleH1gXG4gIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLnJlZ2wuYnVmZmVyKFtcbiAgICBbLTUsIC0xLCAwXSxcbiAgICBbLTEsIC01LCAwXSxcbiAgICBbMywgMywgMF1cbiAgXSlcbiAgdGhpcy51dkJ1ZmZlciA9IHRoaXMucmVnbC5idWZmZXIoW1xuICAgIFstMiwgMF0sXG4gICAgWzAsIC0yXSxcbiAgICBbMiwgMl1cbiAgXSlcblxuICB0aGlzLmRyYXcgPSBbXVxuICB0aGlzLmluaXQoKVxuICB0aGlzLnBpbmdQb25nSW5kZXggPSAwXG5cbiAgLy8gZm9yIGVhY2ggb3V0cHV0LCBjcmVhdGUgdHdvIGZib3MgZm9yIHBpbmdwb25naW5nXG4gIHRoaXMuZmJvcyA9IChBcnJheSgyKSkuZmlsbCgpLm1hcCgoKSA9PiB0aGlzLl9pbml0RmJvKCkpXG5cbiAgLy8gZm9yIGVhY2ggb3V0cHV0LCBjcmVhdGUgdHdvIHRlbXAgYnVmZmVyc1xuICB0aGlzLnRlbXAgPSAoQXJyYXkoMikpLmZpbGwoKS5tYXAoKCkgPT4gdGhpcy5faW5pdEZibygpKVxuXG4gIHRoaXMuY29weVBhc3MgPSB0aGlzLnJlZ2woe1xuICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgwLCB1dik7XG4gICAgICB9XG4gICAgICBgLFxuICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMi4wICogcG9zaXRpb24gLSAxLjAsIDAsIDEpO1xuICAgICAgfWAsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgcG9zaXRpb246IFtcbiAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgWzAsIC0yXSxcbiAgICAgICAgWzIsIDJdXG4gICAgICBdXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICB9LFxuICAgIGNvdW50OiAzLFxuICAgIGRlcHRoOiB7IGVuYWJsZTogZmFsc2UgfSxcbiAgICBmcmFtZWJ1ZmZlcjogKCkgPT4gdGhpcy5nZXRUZXh0dXJlKCksXG4gIH0pXG59XG5cbk91dHB1dC5wcm90b3R5cGUuX2luaXRGYm8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVnbC5mcmFtZWJ1ZmZlcih7XG4gICAgY29sb3I6IHRoaXMucmVnbC50ZXh0dXJlKHtcbiAgICAgIG1hZzogJ25lYXJlc3QnLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZm9ybWF0OiAncmdiYSdcbiAgICB9KSxcbiAgICBkZXB0aFN0ZW5jaWw6IGZhbHNlXG4gIH0pXG59XG5cbk91dHB1dC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLmZib3MuZm9yRWFjaCgoZmJvKSA9PiB7XG4gICAgZmJvLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxuICB0aGlzLnRlbXAuZm9yRWFjaCgodG1wKSA9PiB7XG4gICAgdG1wLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxufVxuXG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmJvc1t0aGlzLnBpbmdQb25nSW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBpbmRleCA9IHRoaXMucGluZ1BvbmdJbmRleCA/IDAgOiAxXG4gIHJldHVybiB0aGlzLmZib3NbaW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uQnVmZmVyLFxuICAgIHV2OiB0aGlzLnV2QnVmZmVyLFxuICB9XG4gIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgdGltZTogdGhpcy5yZWdsLnByb3AoJ3RpbWUnKSxcbiAgICByZXNvbHV0aW9uOiB0aGlzLnJlZ2wucHJvcCgncmVzb2x1dGlvbicpLFxuICB9XG5cbiAgdGhpcy5pbml0Q2FtZXJhKCk7XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5pbml0Q2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhbWVyYSA9IHRoaXMucmVnbCh7XG4gICAgY29udGV4dDoge1xuICAgICAgcHJvamVjdGlvbjogbWF0NC5pZGVudGl0eShbXSksXG4gICAgICB2aWV3OiBtYXQ0LmlkZW50aXR5KFtdKSxcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB2aWV3OiB0aGlzLnJlZ2wuY29udGV4dCgndmlldycpLFxuICAgICAgcHJvamVjdGlvbjogdGhpcy5yZWdsLmNvbnRleHQoJ3Byb2plY3Rpb24nKVxuICAgIH1cbiAgfSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuY2FtZXJhID0gZnVuY3Rpb24oZXllLCB0YXJnZXQgPSBbMCwwLDBdLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGZvdnk6IE1hdGguUEkgLyA0LFxuICAgIG5lYXI6IDAuMSxcbiAgICBmYXI6IDEwMDAuMCxcbiAgfSwgb3B0aW9ucyk7XG4gIHRoaXMuZXllID0gZXllO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGV5ZSAmJiB0YXJnZXQpIHtcbiAgICB0aGlzLl9jYW1lcmEgPSB0aGlzLnJlZ2woe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwZXJzcGVjdGl2ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXQ0LnBlcnNwZWN0aXZlKFtdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm92eSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFzcGVjdCB8fCAoY29udGV4dC52aWV3cG9ydFdpZHRoIC8gY29udGV4dC52aWV3cG9ydEhlaWdodCksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5uZWFyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmFyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXQ0Lm9ydGhvKFtdLCAtMS4wLCAxLjAsIC0xLjAsIDEuMCwgb3B0aW9ucy5uZWFyLCBvcHRpb25zLmZhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoY29udGV4dCwgcHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gbWF0NC5sb29rQXQoW10sXG4gICAgICAgICAgICAgIHByb3BzLmV5ZSxcbiAgICAgICAgICAgICAgcHJvcHMudGFyZ2V0LFxuICAgICAgICAgICAgICBbMCwgMSwgMF0pXG4gICAgICAgIH0sXG4gICAgICAgIGV5ZTogdGhpcy5yZWdsLnByb3AoJ2V5ZScpLFxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHZpZXc6IHRoaXMucmVnbC5jb250ZXh0KCd2aWV3JyksXG4gICAgICAgIHByb2plY3Rpb246IHRoaXMucmVnbC5jb250ZXh0KCdwcm9qZWN0aW9uJyksXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5pbml0Q2FtZXJhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbk91dHB1dC5wcm90b3R5cGUucGVyc3BlY3RpdmUgPSBmdW5jdGlvbihleWUsIHRhcmdldCA9IFswLDAsMF0sIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7dHlwZTogJ3BlcnNwZWN0aXZlJ30sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5jYW1lcmEoZXllLCB0YXJnZXQsIG9wdGlvbnMpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLm9ydGhvID0gZnVuY3Rpb24oZXllLCB0YXJnZXQgPSBbMCwwLDBdLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3R5cGU6ICdvcnRobyd9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuY2FtZXJhKGV5ZSwgdGFyZ2V0LCBvcHRpb25zKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFzc2VzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIGVuc3VyZSBib3RoIGZibydzIGhhdmUgbGFzdCBmcmFtZVxuICB0aGlzLmNvcHlQYXNzKHtcbiAgICB0ZXgwOiB0aGlzLmdldEN1cnJlbnQoKSxcbiAgfSk7XG4gIHNlbGYuZHJhdyA9IFtdO1xuICBmb3IgKGxldCBpPTA7IGk8cGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhc3MgPSBwYXNzZXNbaV1cbiAgICBpZiAocGFzcy5jbGVhcikge1xuICAgICAgc3dpdGNoIChwYXNzLmNsZWFyKSB7XG4gICAgICAgIGNhc2UgJ2NsZWFyJzpcbiAgICAgICAgICBzZWxmLmRyYXcucHVzaCguLi50aGlzLmNsZWFyKGZhbHNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZhZGUnOiB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gdHlwZW9mKHBhc3MudXNlckFyZ3NbMF0pID09PSAnb2JqZWN0JyA/IHBhc3MudXNlckFyZ3NbMF0gOiB7YW1vdW50OiBwYXNzLnVzZXJBcmdzWzBdfTtcbiAgICAgICAgICBvcHQubm93ID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5kcmF3LnB1c2godGhpcy5mYWRlKG9wdCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKGB1bnJlY29nbml6ZWQgY2xlYXI6ICR7cGFzcy5jbGVhcn0oJHtwYXNzLnVzZXJBcmdzLmpvaW4oXCIsIFwiKX0pYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7YXR0cmlidXRlcywgZWxlbWVudHMsIHByaW1pdGl2ZX0gPSB0aGlzLmdldEF0dHJpYnV0ZXMocGFzcy5wcmltaXRpdmUsIHBhc3MuZ2VvbWV0cnkpO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy5nZXRVbmlmb3JtcyhwYXNzLnVuaWZvcm1zKTtcbiAgICBjb25zdCBibGVuZCA9IHRoaXMuZ2V0QmxlbmQocGFzcy5ibGVuZE1vZGUpO1xuICAgIGNvbnN0IGRyYXcgPSBzZWxmLnJlZ2woe1xuICAgICAgZnJhZzogcGFzcy5mcmFnLFxuICAgICAgdmVydDogcGFzcy52ZXJ0LFxuICAgICAgdmlld3BvcnQ6IHR5cGVvZihwYXNzLnZpZXdwb3J0LngpICE9PSAndW5kZWZpbmVkJyA/IHtcbiAgICAgICAgeDogcGFzcy52aWV3cG9ydC54ICogdGhpcy5mYm9zWzBdLndpZHRoLFxuICAgICAgICB5OiBwYXNzLnZpZXdwb3J0LnkgKiB0aGlzLmZib3NbMF0uaGVpZ2h0LFxuICAgICAgICB3aWR0aDogcGFzcy52aWV3cG9ydC53ICogdGhpcy5mYm9zWzBdLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhc3Mudmlld3BvcnQuaCAqIHRoaXMuZmJvc1swXS5oZWlnaHQsXG4gICAgICB9IDoge30sXG4gICAgICBjdWxsOiB7XG4gICAgICAgIGVuYWJsZTogISFwYXNzLmdlb21ldHJ5LFxuICAgICAgICBmYWNlOiAnYmFjaydcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcHJpbWl0aXZlLFxuICAgICAgdW5pZm9ybXMsXG4gICAgICBjb3VudDogdHlwZW9mKGVsZW1lbnRzKSA9PT0gJ251bWJlcicgPyBlbGVtZW50cyA6IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnRzOiB0eXBlb2YoZWxlbWVudHMpID09PSAnbnVtYmVyJyA/IG51bGwgOiBlbGVtZW50cyxcbiAgICAgIGJsZW5kLFxuICAgICAgbGluZVdpZHRoOiBwYXNzLmxpbmVXaWR0aCxcbiAgICAgIGZyYW1lYnVmZmVyOiBwYXNzLmZyYW1lYnVmZmVyIHx8ICgoKSA9PiB7XG4gICAgICAgIHNlbGYucGluZ1BvbmdJbmRleCA9IHNlbGYucGluZ1BvbmdJbmRleCA/IDAgOiAxXG4gICAgICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XVxuICAgICAgfSksXG4gICAgfSlcbiAgICBzZWxmLmRyYXcucHVzaChkcmF3KVxuICB9XG59XG5cbk91dHB1dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihub3cgPSB0cnVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFt0aGlzLmZib3NbMF0sIHRoaXMuZmJvc1sxXSwgdGhpcy50ZW1wWzBdLCB0aGlzLnRlbXBbMV1dLm1hcCgoZmJvKSA9PiB7XG4gICAgY29uc3QgY2xlYXIgPSAoKSA9PiB0aGlzLnJlZ2wuY2xlYXIoe1xuICAgICAgY29sb3I6IFswLCAwLCAwLCAwXSxcbiAgICAgIGZyYW1lYnVmZmVyOiBmYm8sXG4gICAgfSk7XG4gICAgaWYgKG5vdykgY2xlYXIoKTtcbiAgICBlbHNlIHJldHVybiBjbGVhcjtcbiAgfSk7XG4gIGlmIChub3cpIHJldHVybiB0aGlzO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmZhZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGxldCBhbW91bnQgPSBvcHRpb25zO1xuICBsZXQgY2FtZXJhID0gZmFsc2U7XG4gIGxldCBub3cgPSB0cnVlO1xuICBpZiAodHlwZW9mKG9wdGlvbnMpID09PSAnb2JqZWN0Jykge1xuICAgICh7YW1vdW50LCBjYW1lcmF9ID0gb3B0aW9ucyk7XG4gICAgbm93ID0gdHlwZW9mKG9wdGlvbnMubm93KSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5ub3c7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIC8vIHRvZG86IGRvIHdlIG5lZWQgdG8gZmFkZSBhbHNvIHRlbXAgYnVmZmVycz9cbiAgY29uc3QgZmFkZSA9IHNlbGYucmVnbCh7XG4gICAgZnJhZzogYFxuICAgICAgICAgIHByZWNpc2lvbiAke3NlbGYucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdnV2O1xuICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHByZXZCdWZmZXI7XG4gICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgdmVjNCBjb2xvciA9IG1peCh0ZXh0dXJlMkQocHJldkJ1ZmZlciwgdnV2KSwgdmVjNCgwKSwgJHthbW91bnR9KTtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICB2ZXJ0OiBHbHNsU291cmNlLmNvbXBpbGVWZXJ0KHRoaXMucHJlY2lzaW9uLCBjYW1lcmEsIHsgZ2xzbE5hbWU6ICdjbGVhcicgfSksXG4gICAgYXR0cmlidXRlczogc2VsZi5hdHRyaWJ1dGVzLFxuICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIHByZXZCdWZmZXI6ICgpID0+ICB7IHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XSB9LFxuICAgIH0sIHRoaXMudW5pZm9ybXMpLFxuICAgIGNvdW50OiAzLFxuICAgIC8vIG5leHQgZnJhbWVidWZmZXJcbiAgICBmcmFtZWJ1ZmZlcjogKCkgPT4ge1xuICAgICAgcmV0dXJuIHNlbGYuZmJvc1tzZWxmLnBpbmdQb25nSW5kZXggPyAwIDogMV1cbiAgICB9XG4gIH0pO1xuICBpZiAobm93KSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIGZhZGU7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKHByaW1pdGl2ZSwgZ2VvbWV0cnkpIHtcbiAgbGV0IGVsZW1lbnRzID0gMztcbiAgbGV0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gIGlmIChnZW9tZXRyeSkge1xuICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuICAgICAgT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcykuZm9yRWFjaCgoa2V5KSA9PiBhdHRyaWJ1dGVzW2tleV0gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2tleV0uYXJyYXkpO1xuICAgICAgZWxlbWVudHMgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIHByaW1pdGl2ZSB8fCAocHJpbWl0aXZlID0gZ2VvbWV0cnkucGFyYW1ldGVycy5wcmltaXRpdmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS5wb3NpdGlvbnMgJiYgKGdlb21ldHJ5LmVkZ2VzIHx8IGdlb21ldHJ5LmNlbGxzKSkge1xuICAgICAgYXR0cmlidXRlcy5wb3NpdGlvbiA9IFtdOyAvLyB0b2RvOiBzaG91bGQgYmUgRmxvYXQzMkFycmF5XG4gICAgICBnZW9tZXRyeS5wb3NpdGlvbnMubWFwKCh2LCBrKSA9PiBhdHRyaWJ1dGVzLnBvc2l0aW9uLnB1c2godlswXSwgdlsxXSwgMCkpO1xuICAgICAgZWxlbWVudHMgPSBnZW9tZXRyeS5lZGdlcyA/IGdlb21ldHJ5LmVkZ2VzIDogZ2VvbWV0cnkuY2VsbHM7XG4gICAgICBwcmltaXRpdmUgPSBnZW9tZXRyeS5lZGdlcyA/ICdsaW5lcycgOiAndHJpYW5nbGVzJztcbiAgICB9XG4gIH1cbiAgcHJpbWl0aXZlIHx8IChwcmltaXRpdmUgPSAndHJpYW5nbGVzJyk7XG4gIHJldHVybiB7YXR0cmlidXRlcywgZWxlbWVudHMsIHByaW1pdGl2ZX07XG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbih1bmlmb3Jtcykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCB7IHByZXZCdWZmZXI6ICAoKSA9PiAge1xuICAgIC8vIHRvZG86IGNoYW5nZWQsIG9yaWdpbmFsbHk6XG4gICAgLy8gcmV0dXJuIHNlbGYuZmJvc1tzZWxmLnBpbmdQb25nSW5kZXhdXG4gICAgcmV0dXJuIHNlbGYuZmJvc1tzZWxmLnBpbmdQb25nSW5kZXggPyAwIDogMV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBPYmplY3Qua2V5cyh1bmlmb3JtcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gdHlwZW9mKHVuaWZvcm1zW2tleV0pID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodW5pZm9ybXNba2V5XSkgOiB1bmlmb3Jtc1trZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5nZXRCbGVuZCA9IGZ1bmN0aW9uKGJsZW5kTW9kZSkge1xuICBsZXQgZnVuYztcbiAgc3dpdGNoIChibGVuZE1vZGUpIHtcbiAgICBjYXNlICdjdXN0b20nOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnY3VzdG9tJywgIC8vIERlZmluZSB5b3VyIGN1c3RvbSBibGVuZGluZyBmdW5jdGlvbiBoZXJlXG4gICAgICAgIGRzdFJHQjogJ2N1c3RvbScsXG4gICAgICAgIHNyY0FscGhhOiAnY3VzdG9tJyxcbiAgICAgICAgZHN0QWxwaGE6ICdjdXN0b20nLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnZHN0IGNvbG9yJyxcbiAgICAgICAgZHN0UkdCOiAnb25lIG1pbnVzIHNyYyBjb2xvcicsXG4gICAgICAgIHNyY0FscGhhOiAnZHN0IGFscGhhJyxcbiAgICAgICAgZHN0QWxwaGE6ICdvbmUgbWludXMgc3JjIGFscGhhJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnb25lIG1pbnVzIGRzdCBjb2xvcicsXG4gICAgICAgIGRzdFJHQjogJ29uZScsXG4gICAgICAgIHNyY0FscGhhOiAnb25lIG1pbnVzIGRzdCBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAnb25lJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdkc3QgY29sb3InLFxuICAgICAgICBkc3RSR0I6ICd6ZXJvJyxcbiAgICAgICAgc3JjQWxwaGE6ICdkc3QgYWxwaGEnLFxuICAgICAgICBkc3RBbHBoYTogJ3plcm8nLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FkZCc6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdvbmUnLFxuICAgICAgICBkc3RSR0I6ICdvbmUnLFxuICAgICAgICBzcmNBbHBoYTogJ29uZScsXG4gICAgICAgIGRzdEFscGhhOiAnb25lJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbHBoYSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ3NyYyBhbHBoYScsXG4gICAgICAgIHNyY0FscGhhOiAxLFxuICAgICAgICBkc3RSR0I6ICdvbmUgbWludXMgc3JjIGFscGhhJyxcbiAgICAgICAgZHN0QWxwaGE6IDFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuYWJsZTogYmxlbmRNb2RlID8gKHR5cGVvZihibGVuZE1vZGUpID09PSAnc3RyaW5nJyA/IGJsZW5kTW9kZSAhPT0gJ2Rpc2FibGVkJyA6IGJsZW5kTW9kZSkgOiBmYWxzZSxcbiAgICBmdW5jLFxuICB9O1xufVxuXG5PdXRwdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgY29uc3QgZG9EcmF3ID0gKCkgPT4gdGhpcy5kcmF3Lm1hcCgoZm4pID0+IGZuKHByb3BzKSk7XG4gIHRoaXMuX2NhbWVyYSh7XG4gICAgZXllOiB0aGlzLmV5ZSxcbiAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICB9LCBmdW5jdGlvbigpIHtcbiAgICBkb0RyYXcoKTtcbiAgfSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUucmVuZGVyVGV4dHVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN5bnRoLl9yZW5kZXJPdXQodGhpcy5pZCk7XG4gIGNvbnN0IGNvbG9yVGV4ID0gdGhpcy5mYm9zW3RoaXMucGluZ1BvbmdJbmRleF0uY29sb3I7XG4gIHRoaXMuZmJvc1t0aGlzLnBpbmdQb25nSW5kZXhdID0gdGhpcy5faW5pdEZibygpO1xuICByZXR1cm4gY29sb3JUZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE91dHB1dFxuIiwiY29uc3QgdHlwZUxvb2t1cCA9IHtcbiAgICAnc3JjJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICAgIH0sXG4gICAgJ3ZlcnQnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICAgICAgYXJnczogWyd2ZWMyIF9zdCddXG4gICAgfSxcbiAgICAnY29vcmQnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWMyJyxcbiAgICAgICAgYXJnczogWyd2ZWMyIF9zdCddXG4gICAgfSxcbiAgICAnY29sb3InOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICAgICAgYXJnczogWyd2ZWM0IF9jMCddXG4gICAgfSxcbiAgICAnY29tYmluZSc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzQgX2MwJywgJ3ZlYzQgX2MxJ11cbiAgICB9LFxuICAgICdjb21iaW5lQ29vcmQnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWMyJyxcbiAgICAgICAgYXJnczogWyd2ZWMyIF9zdCcsICd2ZWM0IF9jMCddXG4gICAgfVxufVxuXG5jb25zdCBnZXRMb29rdXAgPSB7ZmxvYXQ6ICd4JywgdmVjMjogJ3h5JywgdmVjMzogJ3h5eicsIHZlYzQ6ICd4eXp3J307XG5cbmNvbnN0IGdldFR5cGVMb29rdXAgPSB7XG4gICAgeDogJ2Zsb2F0JywgeTogJ2Zsb2F0JywgejogJ2Zsb2F0JyxcbiAgICB4eTogJ3ZlYzInLCB5eDogJ3ZlYzInLFxuICAgIHh5ejogJ3ZlYzMnLCB4enk6ICd2ZWMzJywgeXp4OiAndmVjMycsIHl4ejogJ3ZlYzMnLCB6eHk6ICd2ZWMzJywgenl4OiAndmVjMycsXG4gICAgeHl6dzogJ3ZlYzQnLFxufTtcblxuY29uc3QgY2FzdFR5cGUgPSAoZnVuYywgZnJvbVR5cGUsIHRvVHlwZSwgYWxwaGEgPSAwLjApID0+IHtcbiAgICBjb25zdCBmcm9tTGVuID0gZnJvbVR5cGUgPT09ICdmbG9hdCcgPyAxIDogZnJvbVR5cGUuc3Vic3RyaW5nKDMpO1xuICAgIGNvbnN0IHRvTGVuID0gKHRvVHlwZSA9PT0gJ2Zsb2F0JyA/IDEgOiB0b1R5cGUuc3Vic3RyaW5nKDMpKTtcbiAgICBpZiAoZnJvbUxlbiA8IHRvTGVuKSB7XG4gICAgICAgIGxldCBkaWZmID0gdG9MZW4gLSBmcm9tTGVuO1xuICAgICAgICBsZXQgbGFzdCA9ICcnO1xuICAgICAgICBpZiAodG9UeXBlID09PSAndmVjNCcpIHtcbiAgICAgICAgICAgIGRpZmYgLT0gMTtcbiAgICAgICAgICAgIGxhc3QgPSAnLCAnK2FscGhhO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmMgPSBgdmVjJHt0b0xlbn0oJHtmdW5jfSR7JywgMC4wJy5yZXBlYXQoZGlmZil9JHtsYXN0fSlgO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbn1cblxuZXhwb3J0IHsgdHlwZUxvb2t1cCwgZ2V0TG9va3VwLCBnZXRUeXBlTG9va3VwLCBjYXN0VHlwZSB9OyJdfQ==
